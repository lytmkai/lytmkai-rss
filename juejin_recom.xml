<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[打破堆积困局：优化堆积条形图的对比效果]]></title>    <link>https://juejin.cn/post/7595974133097807906</link>    <guid>https://juejin.cn/post/7595974133097807906</guid>    <pubDate>2026-01-18T07:22:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595974133097807906" data-draft-id="7595896809652748328" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="打破堆积困局：优化堆积条形图的对比效果"/> <meta itemprop="keywords" content="Python,数据可视化,数据分析"/> <meta itemprop="datePublished" content="2026-01-18T07:22:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="databook"/> <meta itemprop="url" content="https://juejin.cn/user/3526889035006702"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            打破堆积困局：优化堆积条形图的对比效果
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3526889035006702/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    databook
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T07:22:16.000Z" title="Sun Jan 18 2026 07:22:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在数据可视化中，<strong>堆积条形图</strong> 擅长展示 <strong>“整体与构成”</strong> 的关系，但当每个柱子内的分段超过4个时，读者很难同时追踪各段的长度、位置与颜色映射， <strong>误读概率显著上升</strong>。</p>
<p>更糟的是，若不同类别的总量差异很大，堆积结构会放大视觉错觉，导致“看起来差不多”的结论失真。</p>
<p>今天，本文将尝试探索一下改进堆积条形图的呈现方式，让复杂数据对比变得一目了然。</p>
<p>如果大家有更好的方式，也欢迎指教，交流。<strong>完整的代码</strong>会在文末提供共享的地址。</p>
<h2 data-id="heading-0">1. 堆积条形图的困境</h2>
<p><strong>堆积条形图</strong>就像一道精心摆盘的多层蛋糕，当层数不多时，我们能轻松分辨每层的高度差异。</p>
<p>但当蛋糕层数超过4层，要比较某一特定口味在多个蛋糕中的含量就变得异常困难。</p>
<p>下面我们用<code>Python</code>模拟一个常见的堆积条形图场景：调查某产品5个功能模块的用户满意度（5个维度），共收集了4个季度的数据。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 模拟数据：4个季度，5个满意度维度（强烈反对、反对、中立、同意、坚决同意）</span>
quarters = [<span class="hljs-string">"第一季度"</span>, <span class="hljs-string">"第二季度"</span>, <span class="hljs-string">"第三季度"</span>, <span class="hljs-string">"第四季度"</span>]
categories = [<span class="hljs-string">"强烈反对"</span>, <span class="hljs-string">"反对"</span>, <span class="hljs-string">"中立"</span>, <span class="hljs-string">"同意"</span>, <span class="hljs-string">"坚决同意"</span>]
colors = [<span class="hljs-string">"#FF6B6B"</span>, <span class="hljs-string">"#FF9F6B"</span>, <span class="hljs-string">"#D6CBCB"</span>, <span class="hljs-string">"#6BCF7F"</span>, <span class="hljs-string">"#4D96FF"</span>]

<span class="hljs-comment"># 每个季度的满意度分布（百分比）</span>
data = np.array(
    [
        [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">40</span>, <span class="hljs-number">20</span>],  <span class="hljs-comment"># 第一季度</span>
        [<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">20</span>, <span class="hljs-number">45</span>, <span class="hljs-number">24</span>],  <span class="hljs-comment"># 第二季度</span>
        [<span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">43</span>, <span class="hljs-number">23</span>],  <span class="hljs-comment"># 第三季度</span>
        [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">50</span>, <span class="hljs-number">27</span>],  <span class="hljs-comment"># 第四季度</span>
    ]
)

<span class="hljs-comment"># 传统横向堆积条形图</span>
fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">4</span>), gridspec_kw={<span class="hljs-string">"width_ratios"</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]})

<span class="hljs-comment"># 左图：传统横向堆积条形图</span>
<span class="hljs-comment"># ... 省略 ...</span>

<span class="hljs-comment"># 右图：横向堆叠条形图的改进版，添加分隔线</span>
<span class="hljs-comment"># ... 省略 ...</span>

plt.tight_layout()
plt.show()
</code></pre>

<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4a944949d5f4141a21ddd7390882fb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769325736&amp;x-signature=VV%2FTkJeonMm1IOMY4mJ6NkT%2FElY%3D" alt="" loading="lazy"/></p>
<p>这个横向堆积条形图展示了每个季度用户满意度的完整分布，随便右边的图稍微做了一些改进，</p>
<p>但如果我们想回答以下问题就会遇到困难：</p>
<ul>
<li><strong>"坚决同意"</strong> 的比例在哪个季度最高？</li>
<li><strong>"反对"</strong> 和 <strong>"强烈反对"</strong> 的比例如何随时间变化？</li>
</ul>
<h2 data-id="heading-1">2. 拆解重构--多个子图</h2>
<p>与其把所有食材炖在一锅里，不如将它们分盘摆放。</p>
<p>我们将<strong>堆积条形图</strong>拆解为5个小图，每个小图只关注一个满意度维度的季度变化。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> matplotlib.gridspec <span class="hljs-keyword">as</span> gridspec

fig = plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))
gs = gridspec.GridSpec(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, figure=fig, hspace=<span class="hljs-number">0.3</span>, wspace=<span class="hljs-number">0.4</span>)
<span class="hljs-comment"># 拆解堆积条形图：为每个类别创建单独的横向子图</span>
axes = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
    axes.append(fig.add_subplot(gs[<span class="hljs-number">0</span>, i]))

<span class="hljs-comment"># 为每个满意度维度创建一个横向条形图</span>
<span class="hljs-keyword">for</span> i, (category, color, ax) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(categories, colors, axes)):
    <span class="hljs-comment"># ... 省略 ...</span>

ax = fig.add_subplot(gs[<span class="hljs-number">1</span>, :]) <span class="hljs-comment"># 第1行，所有列 (等同于 gs[1, 0:5])</span>
<span class="hljs-comment"># ... 省略 ...</span>

plt.show()
</code></pre>

<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4c9b599c9344074a99f8e386d9210e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769325736&amp;x-signature=hpyP%2BAZdvQB3w%2BMII0U8vZDAOS4%3D" alt="" loading="lazy"/></p>
<p>拆解后的图表确实提升了单一维度的对比效果，但仍有一个明显问题：我们的视线需要在多个图表间来回跳跃，无法形成统一的视觉印象。</p>
<p>这就像阅读一本分散在多个页面的表格，需要不断翻页对照。</p>
<h2 data-id="heading-2">3. 双向对比--蝴蝶图</h2>
<p><strong>蝴蝶图</strong>（也称为人口金字塔图或双向条形图）是数据可视化的"瑞士军刀"，特别适合展示对立或双向比较的数据。</p>
<p>它的设计哲学是：让对比在中心轴两侧自然展开，就像蝴蝶展开双翅。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 4. 创建画布</span>
fig, ax = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>,figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
y_pos = np.arange(<span class="hljs-built_in">len</span>(quarters))
<span class="hljs-comment"># 拆分数据列</span>
strongly_disagree = data[:, <span class="hljs-number">0</span>]
disagree          = data[:, <span class="hljs-number">1</span>]
neutral           = data[:, <span class="hljs-number">2</span>]
agree             = data[:, <span class="hljs-number">3</span>]
strongly_agree    = data[:, <span class="hljs-number">4</span>]

<span class="hljs-comment"># ==========================================</span>
<span class="hljs-comment"># 核心逻辑修改：以中立(Neutral)的中心为0点</span>
<span class="hljs-comment"># ==========================================</span>
<span class="hljs-comment"># 1. 绘制中立 (灰色)：跨越 0 轴</span>
<span class="hljs-comment"># left 从 -width/2 开始，这样 0 就在正中间</span>

<span class="hljs-comment"># 2. 绘制左侧 (负面情绪)：向左堆叠</span>
<span class="hljs-comment"># 反对 (Green)：起始位置在 -neutral/2 的左边</span>

<span class="hljs-comment"># 强烈反对 (Purple)：起始位置在 反对 的左边</span>

<span class="hljs-comment"># 3. 绘制右侧 (正面情绪)：向右堆叠</span>
<span class="hljs-comment"># 同意 (Orange)：起始位置在 neutral/2</span>

<span class="hljs-comment"># 强烈同意 (Red)：起始位置在 同意 的右边</span>

<span class="hljs-comment"># 5. 美化图表</span>
<span class="hljs-comment"># 添加中间的基准线 (穿过中立条形)</span>
<span class="hljs-comment"># ... 省略 ...</span>
plt.show()
</code></pre>

<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfcc88fbd7ea4b479296930a493d5467~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769325736&amp;x-signature=F3IfS7gZBAnHjT0O4K2aLbQlexE%3D" alt="" loading="lazy"/></p>
<p><strong>蝴蝶图</strong>和一般的堆积条形图放在一起，可以明显看出两者在数据展示逻辑和视觉重心上有显著区别。</p>
<p><strong>蝴蝶图</strong>侧重于展示 <strong>“对立态度的对比”</strong>，适合看正反两面的力量悬殊以及整体的情绪倾向，而且也便于比较同侧的数据。</p>
<h2 data-id="heading-3">4. 总结</h2>
<p>总之，<strong>堆积条形图</strong>像一锅大杂烩，当食材（数据维度）过多时，我们很难品尝（分析）到每种食材的原味。</p>
<p>通过拆解和重构，我们获得了更清晰的视角。而蝴蝶图则像一位优雅的舞者，将对比数据以对称的方式展开，既保留了整体视野，又强化了局部对比。</p>
<p>优秀的数据可视化不在于展示所有信息，而在于以最少的认知成本传达最多的洞察。</p>
<p>下次当我们面对多维数据对比的挑战时，不妨试试横向蝴蝶图这把"瑞士军刀"，它可能会给你带来意想不到的清晰与美感。</p>
<p>绘制文中图像的完整代码共享在：<a href="https://link.juejin.cn?target=https%3A%2F%2Furl11.ctfile.com%2Ff%2F45455611-8606783265-a93d12%3Fp%3D6872" target="_blank" title="https://url11.ctfile.com/f/45455611-8606783265-a93d12?p=6872" ref="nofollow noopener noreferrer">优化堆积条形图.ipynb</a> (访问密码: 6872)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[教你白嫖一年谷歌Gemini Pro会员]]></title>    <link>https://juejin.cn/post/7596181746062491675</link>    <guid>https://juejin.cn/post/7596181746062491675</guid>    <pubDate>2026-01-18T07:39:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596181746062491675" data-draft-id="7596181746062475291" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="教你白嫖一年谷歌Gemini Pro会员"/> <meta itemprop="keywords" content="GitHub,算法,人工智能"/> <meta itemprop="datePublished" content="2026-01-18T07:39:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="卷福同学"/> <meta itemprop="url" content="https://juejin.cn/user/3456520291098686"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            教你白嫖一年谷歌Gemini Pro会员
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3456520291098686/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    卷福同学
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T07:39:45.000Z" title="Sun Jan 18 2026 07:39:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1.效果</h2>
<p>下面是开通成功的截图，已经可以用上一年的Gemini Pro了</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e3888ddd429f43b98dc6d2b769592fca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2356aP5ZCM5a2m:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769326785&amp;x-signature=6lzXI4DfEDfcDRt9MUJgyTVmhoo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">2.准备工作</h2>
<ul>
<li>能访问谷歌的网络</li>
<li>一个Google账号</li>
<li>一个Visa全币种卡</li>
</ul>
<h2 data-id="heading-2">3.网络</h2>
<p>注意网络节点需要切换美国节点，否则会有不通过的风险</p>
<h2 data-id="heading-3">4.学生认证</h2>
<p>登录：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgemini.google%2Fstudents%2F" target="_blank" title="https://gemini.google/students/" ref="nofollow noopener noreferrer">gemini.google/students/</a></p>
<p>点击<code>Get Offer</code></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef13a8182db745f585336a6265d496f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2356aP5ZCM5a2m:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769326785&amp;x-signature=8JxSJgG8628jS4TTJdfMwrEAfsU%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">5. 认证</h3>
<p>这一步因为我的谷歌账号是老号，点击之后提示已经不支持这个学生认证方案了</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/da2012aea79340cdb4210ac5b50dfd5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2356aP5ZCM5a2m:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769326785&amp;x-signature=Sj4DpwDGxyOip2jtbjrElr%2BXRic%3D" alt="" loading="lazy"/></p>
<p>不过不要紧，我们可以从某鱼上去买Gemini Pro的学生认证服务，消费大概30元左右就行了，小卷用了不到10分钟就完成了认证</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a51ef1bb56a6444bbb2839de4b273906~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2356aP5ZCM5a2m:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769326785&amp;x-signature=AExBFSLbezp4zQDq5g3TzzZSApI%3D" alt="" loading="lazy"/></p>
<p>收到这个邮件，还是很激动的，毕竟花点小钱就可以用到1年的Gemini3和Nano banana了，非常划算。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8297edfb2d742c484a0a773825e791a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2356aP5ZCM5a2m:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769326785&amp;x-signature=xuxSXeqgOb%2BLIrWAPfaqMycLFWo%3D" alt="" loading="lazy"/></p>
<p>大家也快去尝试吧，新号应该不需要这么麻烦的</p>
<p>不知道google这个“bug”会释放多久，说不定哪一天就被堵上啦</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring AI vs Spring AI Alibaba]]></title>    <link>https://juejin.cn/post/7596181746062508059</link>    <guid>https://juejin.cn/post/7596181746062508059</guid>    <pubDate>2026-01-18T07:50:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596181746062508059" data-draft-id="7596134842482933801" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring AI vs Spring AI Alibaba"/> <meta itemprop="keywords" content="后端,人工智能,架构"/> <meta itemprop="datePublished" content="2026-01-18T07:50:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="想用offer打牌"/> <meta itemprop="url" content="https://juejin.cn/user/578781641968972"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring AI vs Spring AI Alibaba
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578781641968972/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    想用offer打牌
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T07:50:14.000Z" title="Sun Jan 18 2026 07:50:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.8;font-weight:400;font-size:16px;word-spacing:2px;letter-spacing:2px;overflow-x:hidden;color:#3e3e3e;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:1.2em;border-bottom:2px solid #ef7060;word-spacing:0!important;letter-spacing:0!important;font-size:inherit;line-height:inherit;display:block;font-weight:400;background:#ef7060;color:#fff;padding:10px;border-top-right-radius:3px;border-top-left-radius:3px;margin-right:3px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>最近Java非常火的AI agent智能体开发框架Spring AI 和 Spring AI Alibaba，我们到底该选谁呢？它们到底有什么区别呢？希望这篇文章能给你的技术选型带来帮助，让我们一起来讨论一下吧！</p>
<h2 data-id="heading-1">SAA继承Spring AI: 扩展开发AI agent的边界</h2>
<h3 data-id="heading-2">原生Spring AI为什么“不行”</h3>
<p>原生 Spring AI 非常轻量，适合写简单的 AI 调用。但一旦进入<strong>复杂的企业级生产环境</strong>，你会发现原生框架在“编排”、“运维”和“治理”上是缺失的。也就是说，原生的SA注重提供构建AI的组件能力，但是对企业实际开发中所需要的的智能体编排能力抽象不够，不够简单易用，开发者不能很快地上手开发。</p>
<h3 data-id="heading-3">Spring AI Alibaba又做了什么？</h3>
<p>Spring AI Alibaba 基于 Spring AI 构建，因此它继承了 Spring AI 的所有原子能力抽象，如模型通信（ChatModel）、提示词（Prompt）、检索增强生成（RAG）、记忆（ChatMemory）、工具（Tool）、模型上下文协议（MCP）等，帮助 Java 开发者快速构建 AI 应用。这使得开发者在使用 SAA 时可以利用 Spring AI 提供的基础组件，同时享受 SAA 带来的额外功能。</p>
<p>上面说了两者是继承的关系，那么SAA又扩展了什么？</p>
<p>重点是提供了<strong>智能体编排能力</strong>，用户不需要自己再定义Node，Egde等等(也就是一系列复杂逻辑底层轮子)，可以直接复用，专业且可靠！</p>
<p>Spring AI Alibaba Graph 是其核心实现之一，在设计理念上区别于 Spring AI 只做底层原子抽象，旨在帮助开发者更容易地构建智能体应用，支持工作流和多智能体应用开发。原生 Spring AI 更侧重于提供构建 AI 能力的原子组件，而 SAA 则在这些原子组件之上构建了更高级的智能体编排能力。</p>
<p>我在下面列出来一些代码你一眼就知道了区别，哪个更加容易上手，可操作性更强：</p>
<ul>
<li>原生 Spring AI (简单的线性调用):</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 只能做简单的问答，复杂逻辑得自己用 Java 写</span>
<span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chatClient.prompt(<span class="hljs-string">"你好"</span>).call().content();
</code></pre>
<ul>
<li>Spring AI Alibaba (Graph 编排 - 伪代码):</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 声明一个复杂的 Agent 工作流</span>
<span class="hljs-type">Graph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>()
    .addNode(<span class="hljs-string">"input_guard"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityCheckNode</span>()) <span class="hljs-comment">// 1. 先做安全检查</span>
    .addNode(<span class="hljs-string">"search"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RAGSearchNode</span>())          <span class="hljs-comment">// 2. 再做搜索</span>
    .addNode(<span class="hljs-string">"generate"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LLMGenerateNode</span>())      <span class="hljs-comment">// 3. 最后生成</span>
    .addEdge(<span class="hljs-string">"input_guard"</span>, <span class="hljs-string">"search"</span>)                <span class="hljs-comment">// 定义流转</span>
    .addEdge(<span class="hljs-string">"search"</span>, <span class="hljs-string">"generate"</span>);

<span class="hljs-comment">// 运行</span>
graph.run(<span class="hljs-string">"用户的复杂请求"</span>);
</code></pre>
<h2 data-id="heading-4"><strong>SAA 解决或扩展的问题/能力</strong></h2>
<p>上面简单讲了两者的区别与联系，接下来让我们详细讲讲SAA到底扩展了什么，解决了什么问题。</p>
<h3 data-id="heading-5">SAA的架构</h3>
<p>我们先来分析一波SAA当前的架构，以便你更好地听懂下面的内容。</p>
<p>Spring AI Alibaba 项目从架构上包含如下四层：</p>
<ul>
<li><strong>Admin</strong>，是一个一站式代理平台，支持可视化代理开发、可观测性、评估和 MCP 管理等功能。它还集成了 Dify 等开源低代码平台，实现了从 DSL 快速迁移到 Spring AI Alibaba 项目</li>
<li><strong>Agent Framework</strong>，是一个以 ReactAgent 设计理念为核心的 Agent 开发框架，使开发者能够构建具备自动上下文工程和人机交互等核心能力的Agent。</li>
<li><strong>Graph</strong>，graph 是一个低级别的工作流和多代理协调框架，能够帮助开发者实现复杂的应用程序编排，它具备丰富的预置节点和简化的图状态定义，Graph 是 Agent Framework 的底层运行时基座。</li>
<li><strong>Augmented LLM</strong>，以 Spring AI 框架底层原子抽象为基础，为构建大型语言模型（LLM）应用提供基础抽象，例如模型（Model）、工具（Tool）、多模态组件（MCP）、消息（Message）、向量存储（Vector Store）等</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b8c52e41447649e6831b99cf13aad12b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oOz55Sob2ZmZXLmiZPniYw=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769327413&amp;x-signature=BXaz5uJkj03MFmQqaXFIPmSP4%2FQ%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-6">Agent Studio：AI Agent 开发与管理平台</h3>
<p>Spring AI Alibaba 提供了一个完整的 AI Agent 开发与评估平台 (Agent Studio)，支持从 Prompt 工程、数据集管理、评估器配置到实验执行和结果分析的完整工作流。这个平台解决了原生框架在 Agent 全生命周期管理方面的空白。</p>
<ul>
<li><strong>Prompt 管理</strong>：支持 Prompt 模板的创建、更新、删除、版本控制、实时调试和会话管理。</li>
<li><strong>数据集管理</strong>：支持多种格式的数据集导入、版本管理、细粒度的数据项 CRUD 操作，并支持从 OpenTelemetry 链路数据创建数据集。</li>
<li><strong>评估器管理</strong>：支持评估器的创建、配置、模板系统、在线调试、测试和版本管理。</li>
<li><strong>实验管理</strong>：自动化执行评估实验，提供详细的实验结果分析和统计，并支持批量处理。</li>
<li><strong>模型配置</strong>：支持 OpenAI、DashScope、DeepSeek 等主流 AI 模型，提供统一的参数配置和运行时动态切换功能</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9cbff6cc1dc84fada1e7517f99062167~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oOz55Sob2ZmZXLmiZPniYw=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769327413&amp;x-signature=%2F%2F2zf5lwLk423l0qWRsD8vx1gfY%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">Agent FrameWork: 更加简单快速地构建Agent</h3>
<p><strong>Agent Framework</strong>，是一个以 ReactAgent 设计理念为核心的 Agent 开发框架，使开发者能够构建具备自动上下文工程和人机交互等核心能力的Agent。</p>
<p><strong>支持 Multi-agent</strong>，内置 ReAct Agent、Supervisor 等常规智能体模式。实现了基本的代理交互和工具执行，可以快速开发具有内置<strong>上下文工程</strong>和<strong>人机交互</strong>支持的代理。</p>
<p>对于需要更复杂流程控制的场景，Agent Framework 提供了内置的工作流，例如<code>SequentialAgent</code>、<code>ParallelAgent</code>、<code>RoutingAgent</code>、<code>LoopAgent</code>和<code>SupervisorAgent</code>，SAA官方推荐直接使用这套高级抽象来直接构建agent。当然如果你有更加复杂的场景和更精准的需求，则需要使用我接下来讲的Graph框架。</p>
<h3 data-id="heading-8">Graph: 更复杂，更精准</h3>
<p><strong>Graph</strong>，是一个低级别的工作流和多代理协调框架，能够帮助开发者实现复杂的应用程序编排，它具备丰富的预置节点和简化的图状态定义，Graph 是 Agent Framework 的底层运行时基座。与 Agent Framework 相比，用户可以基于 Graph API 构建更灵活的多代理工作流。</p>
<p>那么总的来说，SAA Graph 解决了原生框架在复杂任务编排和多智能体协作方面的不足。它借鉴 Langgraph，是 Java 版的类 Langgraph 实现，使开发者无需关心流程编排、上下文记忆管理等底层实现。</p>
<ul>
<li><strong>支持工作流</strong>：内置大量预置节点，与主流低代码平台对齐，例如 LlmNode（大模型节点）、QuestionClassifierNode（问题分类节点）、ToolNode（工具节点）。</li>
<li><strong>原生支持 Streaming</strong>：提供流式处理能力。</li>
<li><strong>Human-in-the-loop</strong>：通过人类确认节点，支持修改状态、恢复执行。</li>
<li><strong>记忆与持久存储</strong>：支持记忆管理与持久化存储，</li>
<li><strong>流程快照、嵌套分支、并行分支</strong>：提供了复杂工作流所需的控制能力</li>
</ul>
<h3 data-id="heading-9">企业级 AI 应用生态集成</h3>
<ul>
<li><strong>MCP 集成</strong>：原生 Spring AI 提供了 MCP (Model Context Protocol) 客户端，而 SAA 在此基础上扩展了企业级的 MCP 集成，包括 Nacos MCP Registry 分布式注册与发现、自动 Router 路由，支持存量 Spring Cloud、Dubbo 等应用零代码改造实现 API 到 MCP 服务发布。 <code>McpManager</code> 负责处理 MCP 客户端的创建、工具检索和工具调用 </li>
<li><strong>RAG 知识库</strong>：深度集成了百炼平台，提供 RAG 知识库管理能力，支持数据解析、切片、向量化预处理，并与向量检索数据库结合。</li>
<li><strong>可观测性 (Observability)</strong> ：通过集成 OpenTelemetry、ARMS 等，提供完整的链路追踪、服务监控、Trace 分析等功能，解决了 AI Agent 生产落地过程中的可观测性问题。</li>
<li><strong>AI 网关</strong>：通过集成 Higress AI 网关，提升模型调用的稳定性与灵活性。</li>
<li><strong>Nl2sql 模块</strong>：基于大模型的 ChatBI 技术，帮助用户轻松实现自然语言交互的数据分析，自动生成 SQL 查询语句。</li>
</ul>
<p><strong>这就是阿里长期构成的生态护城河，这就是为什么他们有能力做出SAA！</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed7bba1401274c299cd5bd9f6e51addb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oOz55Sob2ZmZXLmiZPniYw=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769327413&amp;x-signature=NRfAI7oBmbwB40gJFwbBxnS6nlw%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-10">Spring Boot Starters 简化开发部署</h3>
<ul>
<li>SAA 提供了 <code>spring-boot-starters</code>，简化了 AI 应用的开发和部署，解决了原生框架在分布式 Agent 间通信、动态配置管理、高级 AI 图处理和可观测性等方面的便捷性问题。</li>
<li>集成了 Nacos 进行分布式 Agent 部署、服务注册与发现、负载均衡。</li>
<li>支持动态配置 AI Agent，通过 YAML 配置动态加载和修改 AI 模型设置、Prompt 模板和工具定义</li>
</ul>
<h2 data-id="heading-11">总结</h2>
<p>总之，Spring AI Alibaba 在 Spring AI 提供的基础能力之上，提供了更完善的 AI Agent 开发生态系统，特别是在多智能体编排、企业级集成和全生命周期管理方面进行了显著的扩展和优化，旨在加速企业 AI 应用的落地。</p>
<p>虽然目前SAA还有很多细节没有修饰好，但是随着几个大版本的再迭代，我相信SAA就是未来Java AI Agent开发框架的代表！</p>
<p>如果你觉得这篇文章给你带来了不错的体感，那就给我点赞+收藏+关注吧，这是我继续更新的最大动力❤️</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Kotlin系列08】泛型进阶：从型变到具体化类型参数的类型安全之旅]]></title>    <link>https://juejin.cn/post/7595808703074893850</link>    <guid>https://juejin.cn/post/7595808703074893850</guid>    <pubDate>2026-01-17T12:28:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595808703074893850" data-draft-id="7595894884957077555" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Kotlin系列08】泛型进阶：从型变到具体化类型参数的类型安全之旅"/> <meta itemprop="keywords" content="Kotlin,Android,编程语言"/> <meta itemprop="datePublished" content="2026-01-17T12:28:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Kotlin系列08】泛型进阶：从型变到具体化类型参数的类型安全之旅
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T12:28:11.000Z" title="Sat Jan 17 2026 12:28:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言：那个让我困惑三天的编译错误</h2>
<p>还记得刚学Kotlin泛型时，我写了这样一段代码：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 我以为这样可以...</span>
<span class="hljs-keyword">val</span> strings: List&lt;String&gt; = listOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>)
<span class="hljs-keyword">val</span> objects: List&lt;Any&gt; = strings  <span class="hljs-comment">// ❌ 编译错误！Type mismatch</span>

<span class="hljs-comment">// 但这样却可以？</span>
<span class="hljs-keyword">val</span> readOnlyStrings: List&lt;String&gt; = listOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
<span class="hljs-keyword">val</span> readOnlyObjects: List&lt;Any&gt; = readOnlyStrings  <span class="hljs-comment">// ✅ 编译通过！</span>
</code></pre>
<p><strong>为什么第一个不行，第二个却可以？</strong> 这个问题困扰了我整整三天。后来才明白，这涉及到泛型的 <strong>型变（Variance）</strong> 概念。</p>
<p>再看这个场景：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 想写一个通用的筛选函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">filterItems</span><span class="hljs-params">(items: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> items.filter { it <span class="hljs-keyword">is</span> String }  <span class="hljs-comment">// ❌ 怎么判断类型？</span>
}

<span class="hljs-comment">// 运行时类型擦除，泛型信息丢失了</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span></span>: T {
    <span class="hljs-keyword">return</span> T()  <span class="hljs-comment">// ❌ 编译错误：Cannot use T as reified type parameter</span>
}
</code></pre>
<p>这些问题的答案就在Kotlin泛型的高级特性中：<strong>型变、具体化类型参数、类型边界</strong>。</p>
<p>今天，我们就来深入探索这些让泛型更强大、更安全的特性。</p>
<h2 data-id="heading-1">泛型基础回顾</h2>
<h3 data-id="heading-2">什么是泛型</h3>
<p>泛型允许我们编写可以处理多种类型的代码，同时保持类型安全：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 没有泛型：需要为每种类型写一个类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">IntBox</span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBox</span>(<span class="hljs-keyword">val</span> value: String)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBox</span>(<span class="hljs-keyword">val</span> value: User)

<span class="hljs-comment">// 使用泛型：一个类搞定所有类型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">val</span> value: T)

<span class="hljs-keyword">val</span> intBox = Box(<span class="hljs-number">42</span>)           <span class="hljs-comment">// Box&lt;Int&gt;</span>
<span class="hljs-keyword">val</span> stringBox = Box(<span class="hljs-string">"Hello"</span>)   <span class="hljs-comment">// Box&lt;String&gt;</span>
<span class="hljs-keyword">val</span> userBox = Box(User())      <span class="hljs-comment">// Box&lt;User&gt;</span>
</code></pre>
<h3 data-id="heading-3">泛型的类型擦除</h3>
<p>Java和Kotlin都使用<strong>类型擦除</strong>来实现泛型：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 编译期</span>
<span class="hljs-keyword">val</span> stringList: List&lt;String&gt; = listOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
<span class="hljs-keyword">val</span> intList: List&lt;<span class="hljs-built_in">Int</span>&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)

<span class="hljs-comment">// 运行时：类型参数被擦除</span>
<span class="hljs-comment">// stringList和intList的运行时类型都是List，没有泛型参数信息</span>
</code></pre>
<p><strong>类型擦除的影响</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 不能在运行时检查泛型类型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">isListOf</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> value <span class="hljs-keyword">is</span> List&lt;T&gt;  <span class="hljs-comment">// ❌ 编译错误：Cannot check for instance of erased type</span>
}

<span class="hljs-comment">// ❌ 不能创建泛型数组</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">createArray</span><span class="hljs-params">()</span></span>: Array&lt;T&gt; {
    <span class="hljs-keyword">return</span> Array&lt;T&gt;(<span class="hljs-number">10</span>) { }  <span class="hljs-comment">// ❌ 编译错误</span>
}

<span class="hljs-comment">// ❌ 不能使用泛型类型的伴生对象</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">getCompanion</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">companion</span> = T.Companion  <span class="hljs-comment">// ❌ 编译错误</span>
}
</code></pre>
<h2 data-id="heading-4">型变（Variance）：理解协变与逆变</h2>
<h3 data-id="heading-5">为什么需要型变</h3>
<p>先看一个问题：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// String是Any的子类型</span>
<span class="hljs-keyword">val</span> str: String = <span class="hljs-string">"Hello"</span>
<span class="hljs-keyword">val</span> any: Any = str  <span class="hljs-comment">// ✅ 可以赋值</span>

<span class="hljs-comment">// 那么List&lt;String&gt;是List&lt;Any&gt;的子类型吗？</span>
<span class="hljs-keyword">val</span> stringList: List&lt;String&gt; = listOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
<span class="hljs-keyword">val</span> anyList: List&lt;Any&gt; = stringList  <span class="hljs-comment">// 这样可以吗？</span>
</code></pre>
<p>答案取决于<code>List</code>的<strong>型变</strong>设置。</p>
<h3 data-id="heading-6">不变（Invariant）：默认行为</h3>
<p>默认情况下，泛型类型是<strong>不变的</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// MutableList是不变的</span>
<span class="hljs-keyword">val</span> stringList: MutableList&lt;String&gt; = mutableListOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
<span class="hljs-comment">// val anyList: MutableList&lt;Any&gt; = stringList  // ❌ 编译错误</span>

<span class="hljs-comment">// 为什么不能？因为可能破坏类型安全：</span>
<span class="hljs-keyword">val</span> anyList: MutableList&lt;Any&gt; = stringList  <span class="hljs-comment">// 假设允许</span>
anyList.add(<span class="hljs-number">42</span>)  <span class="hljs-comment">// 加入一个Int</span>
<span class="hljs-keyword">val</span> first: String = stringList[<span class="hljs-number">0</span>]  <span class="hljs-comment">// 💥 运行时错误！</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9818d1c216d4e3793ddd06a550a1f51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769257690&amp;x-signature=V%2FmeRcHm3M7KQXncvkxueX7gnDA%3D" alt="08-01-invariance.png" loading="lazy"/></p>

**不变性保证类型安全**：如果允许`MutableList`赋值给`MutableList`，就可能向字符串列表中添加非字符串元素，破坏类型安全。

<h3 data-id="heading-7">协变（Covariant）：out关键字</h3>
<p><strong>协变</strong>意味着：如果<code>A</code>是<code>B</code>的子类型，那么<code>Producer&lt;A&gt;</code>也是<code>Producer&lt;B&gt;</code>的子类型。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// List是协变的（只读）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-type">out T</span>&gt; {  <span class="hljs-comment">// out表示协变</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T  <span class="hljs-comment">// 只能读取（生产）T</span>
    <span class="hljs-comment">// fun add(element: T)  // ❌ 不能有接收T的方法</span>
}

<span class="hljs-comment">// 使用协变</span>
<span class="hljs-keyword">val</span> stringList: List&lt;String&gt; = listOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
<span class="hljs-keyword">val</span> anyList: List&lt;Any&gt; = stringList  <span class="hljs-comment">// ✅ 可以赋值</span>
<span class="hljs-keyword">val</span> item: Any = anyList[<span class="hljs-number">0</span>]  <span class="hljs-comment">// 只能读取，安全</span>
</code></pre>
<p><strong>协变的规则</strong>：</p>
<ul>
<li>使用<code>out</code>关键字声明</li>
<li>泛型类型只能出现在<strong>输出位置</strong>（返回值）</li>
<li>不能出现在<strong>输入位置</strong>（参数）</li>
</ul>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 协变类型示例</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T  <span class="hljs-comment">// ✅ 输出位置</span>
    <span class="hljs-comment">// fun consume(item: T)  // ❌ 输入位置，不允许</span>
}

<span class="hljs-comment">// 实际应用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitBasket</span>&lt;<span class="hljs-type">out T : Fruit</span>&gt;(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> items: List&lt;T&gt;) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pick</span><span class="hljs-params">()</span></span>: T = items.random()  <span class="hljs-comment">// ✅ 只生产</span>
    <span class="hljs-comment">// fun add(fruit: T) { }  // ❌ 不能消费</span>
}

<span class="hljs-keyword">val</span> appleBasket: FruitBasket&lt;Apple&gt; = FruitBasket(listOf(Apple()))
<span class="hljs-keyword">val</span> fruitBasket: FruitBasket&lt;Fruit&gt; = appleBasket  <span class="hljs-comment">// ✅ 协变</span>
<span class="hljs-keyword">val</span> fruit: Fruit = fruitBasket.pick()  <span class="hljs-comment">// 安全</span>
</code></pre>
<h3 data-id="heading-8">逆变（Contravariant）：in关键字</h3>
<p><strong>逆变</strong>意味着：如果<code>A</code>是<code>B</code>的子类型，那么<code>Consumer&lt;B&gt;</code>是<code>Consumer&lt;A&gt;</code>的子类型（反过来）。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Comparator是逆变的</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">in T</span>&gt; {  <span class="hljs-comment">// in表示逆变</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compare</span><span class="hljs-params">(a: <span class="hljs-type">T</span>, b: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span>  <span class="hljs-comment">// 只能接收（消费）T</span>
}

<span class="hljs-comment">// 使用逆变</span>
<span class="hljs-keyword">val</span> anyComparator: Comparator&lt;Any&gt; = Comparator { a, b -&gt;
    a.hashCode() - b.hashCode()
}
<span class="hljs-keyword">val</span> stringComparator: Comparator&lt;String&gt; = anyComparator  <span class="hljs-comment">// ✅ 可以赋值</span>

<span class="hljs-comment">// 为什么可以？</span>
<span class="hljs-comment">// 能比较Any的，当然也能比较String（String是Any的子类型）</span>
</code></pre>
<p><strong>逆变的规则</strong>：</p>
<ul>
<li>使用<code>in</code>关键字声明</li>
<li>泛型类型只能出现在<strong>输入位置</strong>（参数）</li>
<li>不能出现在<strong>输出位置</strong>（返回值）</li>
</ul>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 逆变类型示例</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>  <span class="hljs-comment">// ✅ 输入位置</span>
    <span class="hljs-comment">// fun produce(): T  // ❌ 输出位置，不允许</span>
}

<span class="hljs-comment">// 实际应用</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sink</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">send</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnySink</span> : <span class="hljs-type">Sink</span>&lt;<span class="hljs-type">Any</span>&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">send</span><span class="hljs-params">(item: <span class="hljs-type">Any</span>)</span></span> {
        println(<span class="hljs-string">"Received: <span class="hljs-variable">$item</span>"</span>)
    }
}

<span class="hljs-keyword">val</span> anySink: Sink&lt;Any&gt; = AnySink()
<span class="hljs-keyword">val</span> stringSink: Sink&lt;String&gt; = anySink  <span class="hljs-comment">// ✅ 逆变</span>
stringSink.send(<span class="hljs-string">"Hello"</span>)  <span class="hljs-comment">// 安全：Any的Sink可以接收String</span>
</code></pre>
<h3 data-id="heading-9">型变总结</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb9da9d7690440c1928fe144caa30b69~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769257690&amp;x-signature=aAyWyW4sn%2B18bFPKwVeb1233X4g%3D" alt="08-02-variance-types.png" loading="lazy"/></p>

































<table><thead><tr><th align="left">型变类型</th><th align="center">关键字</th><th align="left">类型关系</th><th align="left">使用场景</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">不变</td><td align="center">无</td><td align="left">无子类型关系</td><td align="left">既读又写</td><td align="left"><code>MutableList&lt;T&gt;</code></td></tr><tr><td align="left">协变</td><td align="center"><code>out</code></td><td align="left">保持子类型关系</td><td align="left">只读（生产者）</td><td align="left"><code>List&lt;out T&gt;</code></td></tr><tr><td align="left">逆变</td><td align="center"><code>in</code></td><td align="left">反转子类型关系</td><td align="left">只写（消费者）</td><td align="left"><code>Comparator&lt;in T&gt;</code></td></tr></tbody></table>

**记忆口诀**：
- **out** = 只**out**put（输出），生产者，保持方向
- **in** = 只**in**put（输入），消费者，反转方向

<h2 data-id="heading-10">使用处型变（Use-site Variance）</h2>
<p>有时我们不能修改类的声明，但想在使用时指定型变：</p>
<h3 data-id="heading-11">类型投影</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Array是不变的</span>
<span class="hljs-keyword">val</span> strings: Array&lt;String&gt; = arrayOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
<span class="hljs-comment">// val objects: Array&lt;Any&gt; = strings  // ❌ 不变，不能赋值</span>

<span class="hljs-comment">// 使用out投影：只能读取</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printArray</span><span class="hljs-params">(array: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;)</span></span> {  <span class="hljs-comment">// 使用处协变</span>
    <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> array) {
        println(item)  <span class="hljs-comment">// ✅ 可以读取</span>
    }
    <span class="hljs-comment">// array[0] = "X"  // ❌ 不能写入</span>
}

printArray(strings)  <span class="hljs-comment">// ✅ 可以传入Array&lt;String&gt;</span>

<span class="hljs-comment">// 使用in投影：只能写入</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fillArray</span><span class="hljs-params">(array: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">String</span>&gt;, value: <span class="hljs-type">String</span>)</span></span> {  <span class="hljs-comment">// 使用处逆变</span>
    array[<span class="hljs-number">0</span>] = value  <span class="hljs-comment">// ✅ 可以写入</span>
    <span class="hljs-comment">// val item: String = array[0]  // ❌ 不能读取（返回Any?）</span>
}

<span class="hljs-keyword">val</span> objects: Array&lt;Any&gt; = arrayOf(<span class="hljs-string">"X"</span>, <span class="hljs-string">"Y"</span>)
fillArray(objects, <span class="hljs-string">"Hello"</span>)  <span class="hljs-comment">// ✅ 可以传入Array&lt;Any&gt;</span>
</code></pre>
<h3 data-id="heading-12">星投影（Star Projection）</h3>
<p>当你不关心具体类型时，可以使用星投影<code>*</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 等价于out Any?</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printList</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;*&gt;)</span></span> {  <span class="hljs-comment">// List&lt;*&gt; ≈ List&lt;out Any?&gt;</span>
    <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> list) {
        println(item)  <span class="hljs-comment">// item是Any?类型</span>
    }
}

printList(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
printList(listOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>))

<span class="hljs-comment">// MutableList&lt;*&gt;的限制</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processArray</span><span class="hljs-params">(array: <span class="hljs-type">Array</span>&lt;*&gt;)</span></span> {
    <span class="hljs-keyword">val</span> item: Any? = array[<span class="hljs-number">0</span>]  <span class="hljs-comment">// ✅ 可以读取为Any?</span>
    <span class="hljs-comment">// array[0] = "X"  // ❌ 不能写入</span>
}
</code></pre>
<p><strong>星投影的规则</strong>：</p>
<ul>
<li><code>Foo&lt;*&gt;</code> ≈ <code>Foo&lt;out Any?&gt;</code>（如果是协变）</li>
<li><code>Foo&lt;*&gt;</code> ≈ <code>Foo&lt;in Nothing&gt;</code>（如果是逆变）</li>
<li><code>Foo&lt;*&gt;</code> = 既不能读也不能写（如果是不变）</li>
</ul>
<h2 data-id="heading-13">具体化类型参数（Reified Type Parameters）</h2>
<h3 data-id="heading-14">问题：类型擦除的限制</h3>
<p>由于类型擦除，我们不能在运行时检查泛型类型：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 不能检查泛型类型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">isInstance</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> value <span class="hljs-keyword">is</span> T  <span class="hljs-comment">// ❌ 编译错误：Cannot check for instance of erased type</span>
}

<span class="hljs-comment">// ❌ 不能获取泛型的Class</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">getClassName</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> T::<span class="hljs-keyword">class</span>.simpleName  <span class="hljs-comment">// ❌ 编译错误</span>
}
</code></pre>
<h3 data-id="heading-15">解决方案：reified关键字</h3>
<p>Kotlin的<code>reified</code>关键字配合<code>inline</code>函数，可以保留类型信息：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 使用reified</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">isInstance</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> value <span class="hljs-keyword">is</span> T  <span class="hljs-comment">// ✅ 可以检查类型</span>
}

<span class="hljs-comment">// 使用示例</span>
println(isInstance&lt;String&gt;(<span class="hljs-string">"Hello"</span>))  <span class="hljs-comment">// true</span>
println(isInstance&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-string">"Hello"</span>))     <span class="hljs-comment">// false</span>

<span class="hljs-comment">// ✅ 获取Class对象</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">getClassName</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> T::<span class="hljs-keyword">class</span>.simpleName ?: <span class="hljs-string">"Unknown"</span>
}

println(getClassName&lt;String&gt;())  <span class="hljs-comment">// "String"</span>
println(getClassName&lt;List&lt;<span class="hljs-built_in">Int</span>&gt;&gt;())  <span class="hljs-comment">// "List"</span>
</code></pre>
<p><strong>工作原理</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 调用代码</span>
isInstance&lt;String&gt;(<span class="hljs-string">"Hello"</span>)

<span class="hljs-comment">// 编译器内联后</span>
<span class="hljs-string">"Hello"</span> <span class="hljs-keyword">is</span> String  <span class="hljs-comment">// 类型信息被保留</span>
</code></pre>
<h3 data-id="heading-16">reified的实际应用</h3>
<h4 data-id="heading-17">1. 类型安全的筛选</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 筛选特定类型的元素</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> List<span class="hljs-type">&lt;*&gt;</span>.<span class="hljs-title">filterIsInstance</span><span class="hljs-params">()</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> filter { it <span class="hljs-keyword">is</span> T }.map { it <span class="hljs-keyword">as</span> T }
}

<span class="hljs-keyword">val</span> mixed: List&lt;Any&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-string">"two"</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"four"</span>, <span class="hljs-number">5.0</span>)
<span class="hljs-keyword">val</span> strings: List&lt;String&gt; = mixed.filterIsInstance&lt;String&gt;()
println(strings)  <span class="hljs-comment">// [two, four]</span>

<span class="hljs-keyword">val</span> numbers: List&lt;<span class="hljs-built_in">Int</span>&gt; = mixed.filterIsInstance&lt;<span class="hljs-built_in">Int</span>&gt;()
println(numbers)  <span class="hljs-comment">// [1, 3]</span>
</code></pre>
<h4 data-id="heading-18">2. JSON反序列化</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Gson的类型安全包装</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> Gson.<span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>)</span></span>: T {
    <span class="hljs-keyword">return</span> fromJson(json, T::<span class="hljs-keyword">class</span>.java)
}

<span class="hljs-keyword">val</span> user: User = gson.fromJson&lt;User&gt;(jsonString)  <span class="hljs-comment">// 类型安全</span>
<span class="hljs-comment">// 而不是：</span>
<span class="hljs-comment">// val user = gson.fromJson(jsonString, User::class.java) as User</span>
</code></pre>
<h4 data-id="heading-19">3. 启动Activity（Android）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Android中的类型安全Intent</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Activity&gt;</span> Context.<span class="hljs-title">startActivity</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, T::<span class="hljs-keyword">class</span>.java)
    startActivity(intent)
}

<span class="hljs-comment">// 使用</span>
startActivity&lt;MainActivity&gt;()  <span class="hljs-comment">// 简洁且类型安全</span>
</code></pre>
<h4 data-id="heading-20">4. 依赖注入</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 类型安全的依赖获取</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>: T {
    <span class="hljs-keyword">return</span> container.resolve(T::<span class="hljs-keyword">class</span>.java)
}

<span class="hljs-keyword">val</span> userService: UserService = <span class="hljs-keyword">get</span>&lt;UserService&gt;()
</code></pre>

**reified的限制**：
- 只能用于`inline`函数
- 不能用于类的类型参数
- 不能用于属性
- 会增加生成的字节码大小（内联的代价）

<h2 data-id="heading-21">泛型边界（Generic Bounds）</h2>
<h3 data-id="heading-22">上界（Upper Bounds）</h3>
<p>限制类型参数必须是某个类型的子类型：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 单个上界</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Number&gt;</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">T</span>, b: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">return</span> a.toDouble() + b.toDouble()
}

sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)        <span class="hljs-comment">// ✅ Int是Number的子类型</span>
sum(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>)    <span class="hljs-comment">// ✅ Double是Number的子类型</span>
<span class="hljs-comment">// sum("1", "2")  // ❌ String不是Number的子类型</span>

<span class="hljs-comment">// 实际应用：比较</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">max</span><span class="hljs-params">(a: <span class="hljs-type">T</span>, b: <span class="hljs-type">T</span>)</span></span>: T {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (a &gt; b) a <span class="hljs-keyword">else</span> b
}

println(max(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))        <span class="hljs-comment">// 20</span>
println(max(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>))  <span class="hljs-comment">// banana</span>
</code></pre>
<h3 data-id="heading-23">多个上界</h3>
<p>有时需要同时满足多个约束：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// where子句指定多个上界</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, threshold: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt;
    <span class="hljs-keyword">where</span> T : Comparable&lt;T&gt;,  <span class="hljs-comment">// 必须可比较</span>
          T : Cloneable {      <span class="hljs-comment">// 必须可克隆</span>
    <span class="hljs-keyword">return</span> list.filter { it &gt; threshold }.map { it.clone() <span class="hljs-keyword">as</span> T }
}

<span class="hljs-comment">// 实际应用</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Named</span> {
    <span class="hljs-keyword">val</span> name: String
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Identifiable</span> {
    <span class="hljs-keyword">val</span> id: String
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">findById</span><span class="hljs-params">(items: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, id: <span class="hljs-type">String</span>)</span></span>: T?
    <span class="hljs-keyword">where</span> T : Named,
          T : Identifiable {
    <span class="hljs-keyword">return</span> items.find { it.id == id }
}

<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> id: String,
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: String
) : Named, Identifiable

<span class="hljs-keyword">val</span> users = listOf(User(<span class="hljs-string">"1"</span>, <span class="hljs-string">"Alice"</span>), User(<span class="hljs-string">"2"</span>, <span class="hljs-string">"Bob"</span>))
<span class="hljs-keyword">val</span> user = findById(users, <span class="hljs-string">"1"</span>)
println(user?.name)  <span class="hljs-comment">// Alice</span>
</code></pre>
<h3 data-id="heading-24">递归泛型边界</h3>
<p>经典的<code>Comparable</code>模式：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 自引用泛型边界</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;<span class="hljs-type">T : Comparable&lt;T</span>&gt;&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span>
}

<span class="hljs-comment">// 实现</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) : Comparable&lt;Person&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">Person</span>)</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">return</span> age.compareTo(other.age)
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sortItems</span><span class="hljs-params">(items: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> items.sorted()
}

<span class="hljs-keyword">val</span> people = listOf(Person(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>), Person(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>))
<span class="hljs-keyword">val</span> sorted = sortItems(people)  <span class="hljs-comment">// 按年龄排序</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/034e0fdba7a944f8b4402cd23195e21d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769257690&amp;x-signature=FkHDoPaVqr7Z2r12HXWlDeUuAtI%3D" alt="08-03-generic-bounds.png" loading="lazy"/></p>
<h2 data-id="heading-25">实战案例：构建类型安全的Result容器</h2>
<p>综合运用泛型的高级特性，构建一个完整的Result类型：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 基础定义：使用out协变</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: T) : Result&lt;T&gt;()
    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span>(<span class="hljs-keyword">val</span> exception: Exception) : Result&lt;<span class="hljs-built_in">Nothing</span>&gt;()
    <span class="hljs-keyword">object</span> Loading : Result&lt;<span class="hljs-built_in">Nothing</span>&gt;()
}

<span class="hljs-comment">// 2. 扩展函数：使用reified</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> Result<span class="hljs-type">&lt;*&gt;</span>.<span class="hljs-title">getOrNull</span><span class="hljs-params">()</span></span>: T? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">is</span> Result.Success&lt;*&gt; -&gt; <span class="hljs-keyword">data</span> <span class="hljs-keyword">as</span>? T
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">null</span>
    }
}

<span class="hljs-comment">// 3. map函数：协变保证类型安全</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Result<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(transform: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: Result&lt;R&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">is</span> Result.Success -&gt; Result.Success(transform(<span class="hljs-keyword">data</span>))
        <span class="hljs-keyword">is</span> Result.Error -&gt; Result.Error(exception)
        <span class="hljs-keyword">is</span> Result.Loading -&gt; Result.Loading
    }
}

<span class="hljs-comment">// 4. flatMap：处理嵌套Result</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Result<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">flatMap</span><span class="hljs-params">(transform: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Result</span>&lt;<span class="hljs-type">R</span>&gt;)</span></span>: Result&lt;R&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">is</span> Result.Success -&gt; transform(<span class="hljs-keyword">data</span>)
        <span class="hljs-keyword">is</span> Result.Error -&gt; Result.Error(exception)
        <span class="hljs-keyword">is</span> Result.Loading -&gt; Result.Loading
    }
}

<span class="hljs-comment">// 5. 带边界的转换</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Any, R : Any&gt;</span> Result<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">mapNotNull</span><span class="hljs-params">(
    transform: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>?
)</span></span>: Result&lt;R&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">is</span> Result.Success -&gt; {
            <span class="hljs-keyword">val</span> transformed = transform(<span class="hljs-keyword">data</span>)
            <span class="hljs-keyword">if</span> (transformed != <span class="hljs-literal">null</span>) {
                Result.Success(transformed)
            } <span class="hljs-keyword">else</span> {
                Result.Error(NullPointerException(<span class="hljs-string">"Transform returned null"</span>))
            }
        }
        <span class="hljs-keyword">is</span> Result.Error -&gt; Result.Error(exception)
        <span class="hljs-keyword">is</span> Result.Loading -&gt; Result.Loading
    }
}

<span class="hljs-comment">// 6. 合并多个Result</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">combineResults</span><span class="hljs-params">(results: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;&gt;)</span></span>: Result&lt;List&lt;T&gt;&gt; {
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = mutableListOf&lt;T&gt;()

    <span class="hljs-keyword">for</span> (result <span class="hljs-keyword">in</span> results) {
        <span class="hljs-keyword">when</span> (result) {
            <span class="hljs-keyword">is</span> Result.Success -&gt; <span class="hljs-keyword">data</span>.add(result.<span class="hljs-keyword">data</span>)
            <span class="hljs-keyword">is</span> Result.Error -&gt; <span class="hljs-keyword">return</span> result
            <span class="hljs-keyword">is</span> Result.Loading -&gt; <span class="hljs-keyword">return</span> Result.Loading
        }
    }

    <span class="hljs-keyword">return</span> Result.Success(<span class="hljs-keyword">data</span>)
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span> {
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUser</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span>: Result&lt;User&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> user = apiService.getUser(id)
            Result.Success(user)
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Result.Error(e)
        }
    }

    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUserProfile</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span>: Result&lt;UserProfile&gt; {
        <span class="hljs-keyword">return</span> loadUser(id)
            .map { user -&gt; user.toProfile() }  <span class="hljs-comment">// 类型安全转换</span>
            .flatMap { profile -&gt;  <span class="hljs-comment">// 处理嵌套异步操作</span>
                loadAdditionalData(profile.id).map { <span class="hljs-keyword">data</span> -&gt;
                    profile.copy(additionalInfo = <span class="hljs-keyword">data</span>)
                }
            }
    }
}

<span class="hljs-comment">// ViewModel中使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository = UserRepository()

    <span class="hljs-keyword">val</span> userState = MutableStateFlow&lt;Result&lt;UserProfile&gt;&gt;(Result.Loading)

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUserProfile</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span> {
        viewModelScope.launch {
            <span class="hljs-keyword">val</span> result = repository.loadUserProfile(userId)

            <span class="hljs-comment">// 使用reified扩展</span>
            <span class="hljs-keyword">val</span> profile: UserProfile? = result.getOrNull&lt;UserProfile&gt;()

            userState.value = result
        }
    }
}
</code></pre>
<p><strong>这个案例展示了</strong>：</p>
<ul>
<li>✅ <code>out</code>协变保证类型安全的转换</li>
<li>✅ <code>reified</code>实现类型安全的值获取</li>
<li>✅ 泛型函数实现灵活的操作符</li>
<li>✅ 密封类结合泛型的强大表达能力</li>
</ul>
<h2 data-id="heading-26">常见问题解答</h2>
<h3 data-id="heading-27">Q1: 什么时候使用out，什么时候使用in？</h3>
<p><strong>A</strong>: 遵循<strong>PECS原则</strong>（Producer Extends, Consumer Super）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Producer（生产者）使用out</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T  <span class="hljs-comment">// 只生产T</span>
}

<span class="hljs-comment">// Consumer（消费者）使用in</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>  <span class="hljs-comment">// 只消费T</span>
}

<span class="hljs-comment">// 实际应用</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">List</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;, to: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-comment">// from是生产者，只读取</span>
    <span class="hljs-comment">// to是消费者，只写入</span>
    <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> from) {
        <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">is</span> String) {
            to.add(item)
        }
    }
}
</code></pre>
<h3 data-id="heading-28">Q2: reified一定要配合inline使用吗？</h3>
<p><strong>A</strong>: 是的，<code>reified</code>必须用于<code>inline</code>函数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确：inline + reified</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">check</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> value <span class="hljs-keyword">is</span> T
}

<span class="hljs-comment">// ❌ 错误：不能单独使用reified</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">check</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {  <span class="hljs-comment">// 编译错误</span>
    <span class="hljs-keyword">return</span> value <span class="hljs-keyword">is</span> T
}

<span class="hljs-comment">// 原因：只有内联函数才能在编译时替换类型参数</span>
</code></pre>
<p><strong>为什么</strong>：</p>
<ul>
<li><code>inline</code>函数在编译时会被展开到调用处</li>
<li>编译器可以在展开时替换类型参数为具体类型</li>
<li>非内联函数在运行时调用，类型信息已被擦除</li>
</ul>
<h3 data-id="heading-29">Q3: 星投影什么时候使用？</h3>
<p><strong>A</strong>: 当你不关心具体类型，只需要访问与类型无关的成员时：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 场景1：只需要知道是个List，不关心元素类型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSize</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;*&gt;)</span></span> {
    println(<span class="hljs-string">"Size: <span class="hljs-subst">${list.size}</span>"</span>)  <span class="hljs-comment">// size与类型无关</span>
}

<span class="hljs-comment">// 场景2：类型不确定但需要处理</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processUnknown</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>)</span></span> {
    <span class="hljs-keyword">when</span> (value) {
        <span class="hljs-keyword">is</span> List&lt;*&gt; -&gt; println(<span class="hljs-string">"List of <span class="hljs-subst">${value.size}</span> items"</span>)
        <span class="hljs-keyword">is</span> Map&lt;*, *&gt; -&gt; println(<span class="hljs-string">"Map of <span class="hljs-subst">${value.size}</span> entries"</span>)
    }
}

<span class="hljs-comment">// ❌ 不要这样：明确知道类型时不要用星投影</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printStrings</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;*&gt;)</span></span> {  <span class="hljs-comment">// 不好</span>
    <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> list) {
        println(item <span class="hljs-keyword">as</span> String)  <span class="hljs-comment">// 需要强制转换</span>
    }
}

<span class="hljs-comment">// ✅ 应该这样：明确类型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printStrings</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {  <span class="hljs-comment">// 好</span>
    <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> list) {
        println(item)  <span class="hljs-comment">// 类型安全</span>
    }
}
</code></pre>
<h3 data-id="heading-30">Q4: 为什么Array是不变的，而List可以协变？</h3>
<p><strong>A</strong>: 因为<strong>可变性</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Array是可变的（可读可写）</span>
<span class="hljs-keyword">val</span> array: Array&lt;String&gt; = arrayOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
array[<span class="hljs-number">0</span>] = <span class="hljs-string">"X"</span>  <span class="hljs-comment">// 可以修改</span>

<span class="hljs-comment">// 如果允许协变，会破坏类型安全：</span>
<span class="hljs-comment">// val objects: Array&lt;Any&gt; = array  // 假设允许</span>
<span class="hljs-comment">// objects[0] = 42  // 加入Int</span>
<span class="hljs-comment">// val str: String = array[0]  // 💥 运行时错误</span>

<span class="hljs-comment">// List是只读的（协变安全）</span>
<span class="hljs-keyword">val</span> list: List&lt;String&gt; = listOf(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)
<span class="hljs-comment">// list[0] = "X"  // ❌ 不能修改</span>
<span class="hljs-keyword">val</span> objects: List&lt;Any&gt; = list  <span class="hljs-comment">// ✅ 安全，因为不能修改</span>
</code></pre>
<p><strong>规则</strong>：</p>
<ul>
<li><strong>只读集合</strong>（<code>List</code>, <code>Set</code>, <code>Map</code>）可以协变</li>
<li><strong>可变集合</strong>（<code>MutableList</code>, <code>MutableSet</code>, <code>MutableMap</code>）必须不变</li>
</ul>
<h2 data-id="heading-31">练习题</h2>
<h3 data-id="heading-32">练习1：实现泛型栈</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 实现一个类型安全的栈</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> items = mutableListOf&lt;T&gt;()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">push</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> { <span class="hljs-comment">/* TODO */</span> }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>: T? { <span class="hljs-comment">/* TODO */</span> }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>: T? { <span class="hljs-comment">/* TODO */</span> }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* TODO */</span> }
}

<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 添加协变的只读视图</span>
<span class="hljs-comment">// interface ReadOnlyStack&lt;out T&gt; { ... }</span>
</code></pre>
<h3 data-id="heading-33">练习2：带边界的查找函数</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 实现一个通用的查找函数，要求：</span>
<span class="hljs-comment">// 1. T必须实现Comparable接口</span>
<span class="hljs-comment">// 2. T必须有name属性</span>
<span class="hljs-comment">// 3. 查找name匹配且值大于threshold的第一个元素</span>

<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 实现函数签名和函数体</span>
</code></pre>
<h3 data-id="heading-34">练习3：使用reified简化反序列化</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 使用reified实现类型安全的JSON反序列化</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonParser</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 实现inline + reified函数</span>
    <span class="hljs-comment">// inline fun &lt;reified T&gt; parse(json: String): T { ... }</span>
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">val</span> json = <span class="hljs-string">"""{"name": "Alice", "age": 30}"""</span>
<span class="hljs-keyword">val</span> user: User = parser.parse&lt;User&gt;(json)  <span class="hljs-comment">// 应该自动推断类型</span>
</code></pre>
<h2 data-id="heading-35">总结</h2>
<p>Kotlin的泛型系统在Java的基础上做了重要改进，提供了更强大和灵活的类型安全保障。</p>
<h3 data-id="heading-36">核心要点回顾</h3>
<ol>
<li>
<p><strong>型变（Variance）</strong></p>
<ul>
<li><strong>out（协变）</strong> - 生产者，保持子类型关系，只能输出</li>
<li><strong>in（逆变）</strong> - 消费者，反转子类型关系，只能输入</li>
<li><strong>不变</strong> - 默认行为，既可读又可写，无子类型关系</li>
</ul>
</li>
<li>
<p><strong>使用处型变</strong></p>
<ul>
<li>类型投影：<code>Array&lt;out Any&gt;</code>, <code>Array&lt;in String&gt;</code></li>
<li>星投影：<code>List&lt;*&gt;</code> ≈ <code>List&lt;out Any?&gt;</code></li>
</ul>
</li>
<li>
<p><strong>具体化类型参数（reified）</strong></p>
<ul>
<li>配合<code>inline</code>函数使用</li>
<li>保留运行时类型信息</li>
<li>实现类型安全的类型检查和转换</li>
</ul>
</li>
<li>
<p><strong>泛型边界</strong></p>
<ul>
<li>单个上界：<code>&lt;T : Number&gt;</code></li>
<li>多个上界：<code>where T : A, T : B</code></li>
<li>递归边界：<code>&lt;T : Comparable&lt;T&gt;&gt;</code></li>
</ul>
</li>
</ol>
<h3 data-id="heading-37">最佳实践</h3>
<ul>
<li>✅ <strong>遵循PECS原则</strong>：Producer用out，Consumer用in</li>
<li>✅ <strong>优先使用声明处型变</strong>：在类定义时就指定out/in</li>
<li>✅ <strong>谨慎使用reified</strong>：只在确实需要运行时类型信息时使用</li>
<li>✅ <strong>明确泛型边界</strong>：使用上界约束类型，提高代码可读性</li>
<li>✅ <strong>避免过度泛型</strong>：不是所有代码都需要泛型化</li>
<li>✅ <strong>利用标准库</strong>：Kotlin标准库提供了丰富的泛型工具函数</li>
</ul>
<h3 data-id="heading-38">泛型的设计哲学</h3>
<p>Kotlin泛型体现了三个核心理念：</p>
<ol>
<li><strong>类型安全优先</strong> - 在编译期尽可能捕获类型错误</li>
<li><strong>灵活性与安全性平衡</strong> - 通过型变提供灵活性，同时保证安全</li>
<li><strong>实用主义</strong> - reified等特性解决实际问题，而不拘泥于理论纯粹</li>
</ol>
<p>正如文章开头的故事，理解泛型的这些高级特性，不仅能让我们写出更安全、更灵活的代码，更重要的是能帮助我们理解Kotlin类型系统的设计哲学。</p>
<hr/>
<h2 data-id="heading-39">相关资料</h2>
<p><strong>系列文章导航:</strong></p>
<ul>
<li>👉 上一篇: <a href="https://juejin.cn/post/7595841630675763251" target="_blank" title="https://juejin.cn/post/7595841630675763251">类型系统深度解析：从空安全到智能类型推断的设计哲学</a></li>
</ul>
<hr/>
<p><em>如果这篇文章对你有帮助,欢迎点赞、收藏、分享!有任何问题或建议,欢迎在评论区留言讨论。让我们一起学习,一起成长!</em></p>
<p><em>也欢迎访问我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top" target="_blank" title="https://home.wonlab.top" ref="nofollow noopener noreferrer">个人主页</a>发现更多宝藏资源</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[继往开来——如何在工程实践应用 AI 与 Agent]]></title>    <link>https://juejin.cn/post/7595994039108845604</link>    <guid>https://juejin.cn/post/7595994039108845604</guid>    <pubDate>2026-01-17T13:25:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595994039108845604" data-draft-id="7595974133096775714" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="继往开来——如何在工程实践应用 AI 与 Agent"/> <meta itemprop="keywords" content="架构,OpenAI,AI编程"/> <meta itemprop="datePublished" content="2026-01-17T13:25:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="人形打码机"/> <meta itemprop="url" content="https://juejin.cn/user/2085122730895063"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            继往开来——如何在工程实践应用 AI 与 Agent
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2085122730895063/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    人形打码机
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T13:25:00.000Z" title="Sat Jan 17 2026 13:25:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、AI 带来的变化</h2>
<p>这一年用 AI 写代码，说实话并不是一开始就这么顺的，最早接触的时候对它的期待也不高；</p>
<blockquote>
<p>更多只是把它当成一个<strong>比搜索引擎反应快一点的工具</strong></p>
</blockquote>
<h3 data-id="heading-1">做一个接口</h3>
<p>最开始的应用基本是在网页或者桌面对话框里进行工作，做的事情基本围绕：</p>
<ul>
<li>给定字段生成 model</li>
<li>生成一个方法逻辑</li>
<li>完成官方库一些 API 检索</li>
</ul>
<p>因为是通过外部工具完成生成然后粘贴到工程，因此这种改动范围很小，就算生成存在问题也能人工识别进行修正；</p>
<blockquote>
<p>所以当前阶段本质上还是人为主导，AI 只是完成一些琐碎工作</p>
</blockquote>
<p>但问题也很明显， 整体很考究提词并且有时上下文沟通没有关联性输出信息很零碎</p>
<p>大部分时间需要反复提醒上下文，才能把一件小事做完</p>
<h3 data-id="heading-2">结构设计</h3>
<p>真正让我感觉不一样，是后来把 <strong>Trae 和 ChatGPT agent</strong> 结合使用；</p>
<p>AI 不再只是补代码，而是开始直接给我一整套结构：<br/>
目录怎么分、模块怎么拆、代码应该放在哪一层。</p>
<p>这时候，我问的问题也变了。不再是“这段代码怎么写”， 而是“这个功能如果以后要维护，现在这样合不合理”。</p>
<p>虽然输出还谈不上多成熟，但我能明显感觉到：</p>
<blockquote>
<p><strong>AI 已经不只是执行者了，而是在参与决策。</strong></p>
</blockquote>
<h3 data-id="heading-3">再往后：新技术和重复劳动，被我直接交给了它</h3>
<p>再后来，有两个场景我用 AI 用得特别多。</p>
<p><strong>学新技术</strong></p>
<p>遇到不熟的技术栈，我已经很少从头啃文档了，而是先让 AI 给我跑一个最小可用的例子出来；</p>
<p>我不指望它一步到位，但这个例子至少能让我快速知道：<br/>
这个东西大概是怎么组织的，有没有明显坑点。</p>
<p><strong>日常那些特别消耗耐心的重复工作</strong></p>
<p>比如对象声明、序列化反序列化、各种样板代码，这些活不难，但写多了真的很烦；
在这一类事情上，我已经基本不自己动手了，不是因为我不会写，而是没必要；</p>
<p>慢慢地，我对 AI 的感觉也变了，它不再只是一个工具，更像是</p>
<blockquote>
<p>随时可以调度的 <strong>“超级工厂”</strong></p>
</blockquote>
<p><code>慢慢的不再是逐行完成代码，而是完成方案，审视结构，运行逻辑</code></p>
<hr/>
<h2 data-id="heading-4">二、Agent 的使用</h2>
<p>说实话，真正让我开始“敬畏” Agent 编程的，并不是效率提升，而是<strong>它开始变得像一套工程流程</strong>；这也是首次意识到，Agent 的价值不在于“生成代码”，而是通过上下文的约束将代码关进“笼子”；</p>
<h3 data-id="heading-5">提词到工具流</h3>
<p>一开始用 AI 写代码，基本靠 prompt 硬提：</p>
<blockquote>
<p>描述得好不好，直接决定输出能不能用</p>
</blockquote>
<p>但后来明显能感觉到，AI 自己也在“工程化”
不管是 skill、工具流，还是对上下文的约束方式，本质上都在做一件事——  <strong>减少即兴发挥，增加可控性</strong></p>
<p>现在的 Agent 编程看起来突然靠谱了不少,不是它突然聪明了,而是<strong>交互方式更像工程，而不是聊天</strong></p>
<h3 data-id="heading-6">幻觉问题</h3>
<p>组里就出过一次因 AI 幻觉导致的P0事故。<br/>
同事在用 AI 改一个 A 文件的逻辑时，把 B 文件里相关的实现也一起“优化”了。从代码本身看，改动是合理的，逻辑也能自洽。但问题在于，B 文件的那部分逻辑<strong>不该被这个需求触碰的</strong>；</p>
<p>结果很直接：<br/>
<strong>一个 P0 缺陷被带到了线上。</strong></p>
<p>事后复盘时大家的共识也很清楚,如果是人工改代码，大概率不会这么干。<br/>
<code>真正危险的地方在于————不是代码写错了，而是约束失控</code></p>
<h3 data-id="heading-7">老项目里，AI 很容易把坑一次性放大</h3>
<p>还有一次经历，也让我对 AI 在工程里的边界有了更清醒的认识;</p>
<p>当时想在一个迭代了多年的老项目里快速加功能,我对整体框架理解得并不算透，就想着先让 AI 出一版方案;</p>
<p>功能确实很快就跑起来了,但越往后维护，问题越多：</p>
<ul>
<li>结构过重，没有以原有结构逻辑新增</li>
<li>设计过度，几乎没扩展性</li>
<li>完全无维护性，一碰就碎</li>
</ul>
<p>最后的结果——新增功能没保住，还被迫连带着做了一次重构。</p>
<p>那次之后我基本形成了一个认知：</p>
<blockquote>
<p><strong>在复杂工程里，AI 会把你当前的认知水平，成倍放大</strong></p>
</blockquote>
<p><code>回头看，这次问题不在于 AI，而是个人未理解系统之前将权利交了出去</code></p>
<h2 data-id="heading-8">三、行业的变化</h2>
<p>这两年IT行业的环境变化，其实大家都有体感——岗位变少、要求变高，带教制几乎消失，很多时候一上来就要求“能干活”。有一部分行业自身衰落的原因，也有 AI 出现对新人的影响；</p>
<p>AI 并没有改变工程复杂度，只是改变了<strong>谁来为复杂买单</strong>，在真实的工程环境里，AI 带来的最大变化，其实不是“写得更快”，而是 <strong>风险的承担方式发生了变化</strong>；</p>
<h3 data-id="heading-9">工程与人</h3>
<p>对已经有工程经验的人来说，AI 更像是加速器。你大概知道什么是对的、什么是不能碰的，能节约开发周期；</p>
<p>但对新人来说，情况往往相反。在还没建立完整认知体系、也没真正做过设计取舍的前提下，AI 给出的“看起来很完整的方案”，反而会让人误以为问题已经被解决了；一旦业务复杂度上来，隐藏的问题会集中爆发。也是为什么在老项目里， AI 很容易把问题一次性放大————不是因为它乱写，而是<strong>它不知道什么不该写</strong>；</p>
<h3 data-id="heading-10">实践的认知</h3>
<blockquote>
<p>任何工具的使用，都应该建立在实践之上</p>
</blockquote>
<p>很认同张文宏医生的观点——<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.guancha.cn%2Fpolitics%2F2026_01_13_803716.shtml" target="_blank" title="https://www.guancha.cn/politics/2026_01_13_803716.shtml" ref="nofollow noopener noreferrer">反对年轻医生过度依赖 AI 诊断</a>不是因为 AI 不准，而是<strong>诊断能力本身需要通过大量实践建立</strong>；</p>
<p>软件工程也是一样，如果一个人从一开始就习惯把“理解”和“设计”外包给 AI，那么他缺失的不是代码能力，而是判断能力；在还未建立工程直觉，没踩坑之前，很难判定一些基础事实：</p>
<ul>
<li>是否过度设计，可用性如何</li>
<li>当前改动对于整个系统的影响</li>
<li>后续的可维护性以及随业务迭代的可扩展性</li>
</ul>
<p><code>这些判断能力，都需要亲身经历才能逐渐形成</code></p>
<h3 data-id="heading-11">非特定行业问题</h3>
<p>其实不只是 IT 行业，在很多领域，培训正在被“效率”和“交付压力”挤掉；团队难以投入成本培养新人，AI 看起来给了一个<strong>看似合理的补位方案</strong>，能帮助新人短期“看起来能干活”</p>
<p>但从结果看，在提高效率的同时，也将很多经验化的风险责任直接暴露给新人；很多经验型风险从团队层兜底演变成个人面对，这是一个巨大的隐患；</p>
<blockquote>
<p>有些认知理念需要日积月累的工程学认知积累</p>
</blockquote>
<p>工程认知这块，需要在真实工程反复碰壁、反复复盘靠实践逐步积累；</p>
<p><code>工程认知这件事从来不是效率工具可以压缩的成本</code></p>
<h2 data-id="heading-12">四、在信息洪流找到属于自己的 Vibe Coding</h2>
<p>回溯与 AI、Agent 打交道的一路，真正改变我的不是再只是将他作为一个“工具”，而是重新审视自己在工程领域中的 角色；</p>
<p>很多时候，我离不开使用他进行工作、生活，但本质上这是在不断建立并提升认知前提下才能更好使用；</p>
<p>构思需求，完善约束，沟通方案，执行生成；用得好他就是救命稻草，用不好就是洪水猛兽，<strong>不神话，不拒绝</strong>是最好的使用观念；所谓的 Vibe Codeing，绝不该是无脑使用 AI 输出代码，而是在理解系统，敬畏工程的前提下，拥有清晰判断力的情况下完成劳动成果；</p>
<blockquote>
<p>也许 AI 带来的真的是下一次工业革命，至少对个人而言它是日常的一部分</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[确保数值计算精度：BigDecimal 使用指南与最佳实践]]></title>    <link>https://juejin.cn/post/7595893785907314722</link>    <guid>https://juejin.cn/post/7595893785907314722</guid>    <pubDate>2026-01-18T01:14:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595893785907314722" data-draft-id="7595886887523778600" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="确保数值计算精度：BigDecimal 使用指南与最佳实践"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2026-01-18T01:14:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="lagrahhn"/> <meta itemprop="url" content="https://juejin.cn/user/3901542412069112"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            确保数值计算精度：BigDecimal 使用指南与最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3901542412069112/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    lagrahhn
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T01:14:45.000Z" title="Sun Jan 18 2026 01:14:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>适用于金融计算、高精度运算等对数值准确性要求高的场景。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">📌 一、常见问题点</h2>
<h3 data-id="heading-1">使用 <code>BigDecimal(double)</code> 构造函数 ❌</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 错误示范</span>
<span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.1</span>); 
System.out.println(bd); <span class="hljs-comment">// 输出: 0.1000000000000000055511151231257827021181583404541015625</span>
</code></pre>
<p>✅ <strong>推荐做法</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"0.1"</span>);          <span class="hljs-comment">// 安全</span>
<span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd2</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.1</span>);        <span class="hljs-comment">// 内部转字符串，也安全</span>
</code></pre>
<hr/>
<h3 data-id="heading-2">除法未指定舍入模式导致异常 ❌</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>);
<span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"3"</span>);
a.divide(b); <span class="hljs-comment">// Non-terminating decimal expansion; no exact representable decimal result.</span>
</code></pre>
<p>✅ <strong>推荐做法</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> a.divide(b, <span class="hljs-number">4</span>, RoundingMode.HALF_UP);
<span class="hljs-comment">// 或</span>
<span class="hljs-type">BigDecimal</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> a.divide(b, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MathContext</span>(<span class="hljs-number">10</span>, RoundingMode.HALF_UP));
</code></pre>
<p>📌 <strong>建议</strong>：所有除法操作都显式指定精度和舍入方式。</p>
<hr/>
<h3 data-id="heading-3"><code>equals()</code> 比较包含 scale（小数位数）❌</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.0"</span>).equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>)); <span class="hljs-comment">// false</span>
</code></pre>
<p>✅ <strong>正确比较数值是否相等</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.0"</span>).compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>)) == <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
</code></pre>
<p>📌 <strong>规则总结</strong>：</p>
<ul>
<li>数值相等 → <code>compareTo() == 0</code></li>
<li>完全相同（含 scale）→ <code>equals()</code></li>
</ul>
<hr/>
<h3 data-id="heading-4"><code>hashCode()</code> 与 <code>equals()</code> 不一致（因 scale 不同）❌</h3>
<pre><code class="hljs language-java" lang="java">Set&lt;BigDecimal&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.0"</span>));
set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>)); <span class="hljs-comment">// 被视为两个不同元素！</span>
System.out.println(set.size()); <span class="hljs-comment">// 输出: 2</span>
</code></pre>
<p>✅ <strong>解决方案</strong>：统一格式后再放入集合</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">normalized</span> <span class="hljs-operator">=</span> bd.stripTrailingZeros();
set.add(normalized);
</code></pre>
<hr/>
<h3 data-id="heading-5"><code>stripTrailingZeros()</code> 可能返回科学计数法 ❌</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"100"</span>);
System.out.println(bd.stripTrailingZeros().toString()); <span class="hljs-comment">// 输出: 1E+2</span>
</code></pre>
<p>✅ <strong>输出标准十进制格式</strong>：</p>
<pre><code class="hljs language-java" lang="java">System.out.println(bd.stripTrailingZeros().toPlainString()); <span class="hljs-comment">// 输出: 100</span>
</code></pre>
<hr/>
<h3 data-id="heading-6">性能问题：频繁创建对象</h3>
<ul>
<li><code>BigDecimal</code> 是不可变类，每次运算都生成新对象。</li>
<li>高频循环中可能造成 GC 压力。</li>
</ul>
<p>✅ <strong>优化建议</strong>：</p>
<ul>
<li>缓存常用常量：<code>BigDecimal.ZERO</code>, <code>BigDecimal.ONE</code>, <code>BigDecimal.TEN</code></li>
<li>避免不必要的中间变量</li>
</ul>
<hr/>
<h3 data-id="heading-7"><code>setScale()</code> 不改变原对象 ❌</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.234"</span>);
bd.setScale(<span class="hljs-number">2</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 无效！</span>
System.out.println(bd); <span class="hljs-comment">// 仍是 1.234</span>
</code></pre>
<p>✅ <strong>必须重新赋值</strong>：</p>
<pre><code class="hljs language-java" lang="java">bd = bd.setScale(<span class="hljs-number">2</span>, RoundingMode.HALF_UP);
</code></pre>
<hr/>
<h3 data-id="heading-8">默认舍入模式选择需谨慎</h3>

















<table><thead><tr><th>舍入模式</th><th>说明</th></tr></thead><tbody><tr><td><code>HALF_UP</code></td><td>四舍五入（最常用）</td></tr><tr><td><code>HALF_EVEN</code></td><td>银行家舍入（减少累积误差，适合金融）</td></tr></tbody></table>
<p>✅ <strong>根据业务需求选择</strong>，不要盲目使用默认。</p>
<hr/>
<h2 data-id="heading-9">📌 二、<code>toString()</code> vs <code>toPlainString()</code> 对比</h2>




















<table><thead><tr><th>方法</th><th>行为</th><th>适用场景</th></tr></thead><tbody><tr><td><code>toString()</code></td><td>可能使用科学计数法（如 <code>1.23E-7</code>）</td><td>日志、调试</td></tr><tr><td><code>toPlainString()</code></td><td>始终返回普通十进制格式</td><td>显示、存储、序列化</td></tr></tbody></table>
<h3 data-id="heading-10">示例对比：</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"0.000000123"</span>);
System.out.println(small.toString());        <span class="hljs-comment">// 1.23E-7</span>
System.out.println(small.toPlainString());   <span class="hljs-comment">// 0.000000123</span>

<span class="hljs-type">BigDecimal</span> <span class="hljs-variable">trailing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"100.00"</span>);
System.out.println(trailing.toString());        <span class="hljs-comment">// 100.00</span>
System.out.println(trailing.toPlainString());   <span class="hljs-comment">// 100.00</span>

<span class="hljs-type">BigDecimal</span> <span class="hljs-variable">large</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1E+10"</span>);
System.out.println(large.toString());        <span class="hljs-comment">// 1E+10</span>
System.out.println(large.toPlainString());   <span class="hljs-comment">// 10000000000</span>
</code></pre>
<p>✅ <strong>建议</strong>：对外输出（如 JSON、UI、数据库）一律使用 <code>toPlainString()</code>。</p>
<hr/>
<h2 data-id="heading-11">📌 三、完整测试代码（验证所有问题点）</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.math.BigDecimal;
<span class="hljs-keyword">import</span> java.math.MathContext;
<span class="hljs-keyword">import</span> java.math.RoundingMode;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigDecimalPitfallsTest</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        System.out.println(<span class="hljs-string">"=== 1. 构造函数陷阱 ==="</span>);
        testConstructor();

        System.out.println(<span class="hljs-string">"\n=== 2. 除法异常 ==="</span>);
        testDivision();

        System.out.println(<span class="hljs-string">"\n=== 3. equals vs compareTo ==="</span>);
        testEqualsVsCompareTo();

        System.out.println(<span class="hljs-string">"\n=== 4. Set 中重复问题 ==="</span>);
        testSetBehavior();

        System.out.println(<span class="hljs-string">"\n=== 5. stripTrailingZeros 与 toPlainString ==="</span>);
        testStripAndToString();

        System.out.println(<span class="hljs-string">"\n=== 6. setScale 必须重新赋值 ==="</span>);
        testSetScale();

        System.out.println(<span class="hljs-string">"\n=== 7. toString vs toPlainString ==="</span>);
        testToStringFormats();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructor</span><span class="hljs-params">()</span> {
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.1</span>);
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">good1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"0.1"</span>);
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">good2</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.1</span>);
        System.out.println(<span class="hljs-string">"new BigDecimal(0.1): "</span> + bad);
        System.out.println(<span class="hljs-string">"new BigDecimal(\"0.1\"): "</span> + good1);
        System.out.println(<span class="hljs-string">"BigDecimal.valueOf(0.1): "</span> + good2);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDivision</span><span class="hljs-params">()</span> {
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>);
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"3"</span>);
        <span class="hljs-keyword">try</span> {
            a.divide(b);
        } <span class="hljs-keyword">catch</span> (ArithmeticException e) {
            System.out.println(<span class="hljs-string">"除法异常: "</span> + e.getMessage());
        }
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">safe</span> <span class="hljs-operator">=</span> a.divide(b, <span class="hljs-number">6</span>, RoundingMode.HALF_UP);
        System.out.println(<span class="hljs-string">"安全除法结果: "</span> + safe);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEqualsVsCompareTo</span><span class="hljs-params">()</span> {
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.0"</span>);
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>);
        System.out.println(<span class="hljs-string">"x.equals(y): "</span> + x.equals(y)); <span class="hljs-comment">// false</span>
        System.out.println(<span class="hljs-string">"x.compareTo(y) == 0: "</span> + (x.compareTo(y) == <span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSetBehavior</span><span class="hljs-params">()</span> {
        Set&lt;BigDecimal&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.0"</span>));
        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>));
        System.out.println(<span class="hljs-string">"Set 大小（未标准化）: "</span> + set.size()); <span class="hljs-comment">// 2</span>

        Set&lt;BigDecimal&gt; normalizedSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        normalizedSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.0"</span>).stripTrailingZeros());
        normalizedSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1"</span>).stripTrailingZeros());
        System.out.println(<span class="hljs-string">"Set 大小（标准化后）: "</span> + normalizedSet.size()); <span class="hljs-comment">// 1</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStripAndToString</span><span class="hljs-params">()</span> {
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"100"</span>);
        System.out.println(<span class="hljs-string">"stripTrailingZeros().toString(): "</span> + bd.stripTrailingZeros().toString());
        System.out.println(<span class="hljs-string">"stripTrailingZeros().toPlainString(): "</span> + bd.stripTrailingZeros().toPlainString());
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSetScale</span><span class="hljs-params">()</span> {
        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1.234"</span>);
        bd.setScale(<span class="hljs-number">2</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 无效果</span>
        System.out.println(<span class="hljs-string">"未重新赋值: "</span> + bd); <span class="hljs-comment">// 1.234</span>

        bd = bd.setScale(<span class="hljs-number">2</span>, RoundingMode.HALF_UP);
        System.out.println(<span class="hljs-string">"重新赋值后: "</span> + bd); <span class="hljs-comment">// 1.23</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testToStringFormats</span><span class="hljs-params">()</span> {
        BigDecimal[] cases = {
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"0.000000123"</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"100.00"</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"12345678901234567890"</span>)
        };
        <span class="hljs-keyword">for</span> (BigDecimal bd : cases) {
            System.out.println(<span class="hljs-string">"原始: "</span> + bd);
            System.out.println(<span class="hljs-string">"  toString():        "</span> + bd.toString());
            System.out.println(<span class="hljs-string">"  toPlainString():  "</span> + bd.toPlainString());
            System.out.println();
        }
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-12">📌 四、最佳实践总结表</h2>













































<table><thead><tr><th>场景</th><th>推荐做法</th></tr></thead><tbody><tr><td><strong>构造</strong></td><td>优先使用 <code>new BigDecimal("xxx")</code> 或 <code>BigDecimal.valueOf(xxx)</code></td></tr><tr><td><strong>比较数值</strong></td><td>使用 <code>compareTo() == 0</code></td></tr><tr><td><strong>判断完全相等</strong></td><td>使用 <code>equals()</code>（含 scale）</td></tr><tr><td><strong>除法运算</strong></td><td>总是指定精度和 <code>RoundingMode</code></td></tr><tr><td><strong>集合存储</strong></td><td>先调用 <code>.stripTrailingZeros()</code> 统一格式</td></tr><tr><td><strong>字符串输出</strong></td><td>使用 <code>.toPlainString()</code> 避免科学计数法</td></tr><tr><td><strong>修改值</strong></td><td>记住 <code>BigDecimal</code> 不可变，必须重新赋值</td></tr><tr><td><strong>舍入策略</strong></td><td>根据业务选 <code>HALF_UP</code>（通用）或 <code>HALF_EVEN</code>（金融）</td></tr><tr><td><strong>性能优化</strong></td><td>缓存常量，避免高频创建</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026年国产时序数据库盘点：格局嬗变下的多模态融合新锐]]></title>    <link>https://juejin.cn/post/7596171325531979817</link>    <guid>https://juejin.cn/post/7596171325531979817</guid>    <pubDate>2026-01-18T06:30:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596171325531979817" data-draft-id="7596171325531963433" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026年国产时序数据库盘点：格局嬗变下的多模态融合新锐"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-18T06:30:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026年国产时序数据库盘点：格局嬗变下的多模态融合新锐
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T06:30:24.000Z" title="Sun Jan 18 2026 06:30:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 时序数据库分析报告生成代码示例</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_timeseries_db_report</span>(<span class="hljs-params">year=<span class="hljs-number">2026</span></span>):
    <span class="hljs-string">"""生成2026年国产时序数据库分析报告"""</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"      <span class="hljs-subst">{year}</span>年国产时序数据库技术分析报告"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>\n"</span>)
    
    <span class="hljs-comment"># 报告统计信息</span>
    total_databases = <span class="hljs-number">10</span>
    open_source_count = <span class="hljs-number">5</span>
    commercial_count = <span class="hljs-number">5</span>
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"📊 市场概览:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   - 分析年份: <span class="hljs-subst">{year}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   - 收录数据库数量: <span class="hljs-subst">{total_databases}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   - 开源产品: <span class="hljs-subst">{open_source_count}</span>款"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   - 商业产品: <span class="hljs-subst">{commercial_count}</span>款"</span>)
    <span class="hljs-built_in">print</span>()
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">"报告生成完成"</span>

<span class="hljs-comment"># 执行报告生成</span>
generate_timeseries_db_report(<span class="hljs-number">2026</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span> + <span class="hljs-string">"="</span>*<span class="hljs-number">80</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"                   正式报告内容"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">80</span> + <span class="hljs-string">"\n"</span>)
</code></pre>
<blockquote>
<p>进入2026年，在"数字中国"与工业物联网浪潮的强劲推动下，国产时序数据库市场持续繁荣，竞争格局日趋清晰。本文将对当前主流的国产时序数据库进行梳理盘点，并特别聚焦于金仓数据库（Kingbase），深入剖析其以融合多模架构为核心的差异化竞争实力，为企业在数字化转型中的时序数据底座选型提供参考。</p>
</blockquote>
<p>一、主流国产时序数据库概览 (2026)</p>
<p>国产时序数据库已形成多元产品矩阵，根据其核心技术路线、商业模式和市场定位，主要代表性产品如下：</p>























































<table><thead><tr><th>数据库名称</th><th>核心厂商/社区</th><th>主要特点与定位</th></tr></thead><tbody><tr><td>TDengine</td><td>涛思数据</td><td>高性能、分布式，定位为AI驱动的工业大数据平台，在写入吞吐和存储成本方面优势显著，集群开源、生态开放。</td></tr><tr><td>KaiwuDB</td><td>浪潮云弈</td><td>强调分布式多模融合架构，支持时序、关系、文档等多种数据模型的统一处理，原生集成AI算法。</td></tr><tr><td>Apache IoTDB</td><td>清华大学 (Apache基金会)</td><td>专为物联网设计，采用"端-边-云"协同原生架构，数据模型常采用树形结构贴合物理设备层级。</td></tr><tr><td>DolphinDB</td><td>浙江智臾科技</td><td>将数据库与强大的编程语言、流计算引擎融合，在金融量化交易、高频数据分析领域表现突出。</td></tr><tr><td>openGemini</td><td>华为云</td><td>开源的多模态时序数据库，兼容InfluxDB生态，强调高性能与云原生特性。</td></tr><tr><td>CnosDB</td><td>诺司时空</td><td>云原生时序数据库，支持分布式与集中式部署，在监控和物联网场景有应用。</td></tr><tr><td>GreptimeDB</td><td>格睿科技</td><td>云原生分布式时序数据库，主打实时分析能力。</td></tr><tr><td>YMatrix, RealHistorian, GoldenData等</td><td>四维纵横、紫金桥、庚顿数据等</td><td>在特定工业或监控领域拥有深厚的行业积累和定制化解决方案。</td></tr><tr><td>金仓时序数据库</td><td>中电科金仓（原人大金仓）</td><td>基于成熟稳定的金仓数据库管理系统（KES）内核打造的时序能力增强插件，最大特点是继承了KES的融合多模架构，支持时序数据与关系型、空间（GIS）等数据的统一存储、处理与关联分析。</td></tr></tbody></table>
<p>二、焦点解析：金仓时序数据库的融合多模架构
在众多专注于时序场景极致优化的产品中，金仓数据库的时序组件选择了一条独特的路径：不追求做一个孤立的专用时序引擎，而是作为其强大的融合数据库体系（KES）中的一个版块。这种架构选择带来了以下显著优势：</p>
<ol>
<li>
<p>内核级多模态融合，打破数据孤岛
统一底座: 金仓时序组件并非独立产品，而是基于成熟的KingbaseES关系型数据库内核进行融合。这意味着企业无需为时序数据单独搭建和维护一套新的数据基础设施。
无缝关联查询: 时序数据（如传感器读数）与业务关系数据（如设备台账、生产工单）天然存储在同一数据库中。用户可以使用标准的SQL（支持Oracle/PostgreSQL兼容模式）直接进行跨时序表和关系表的复杂JOIN查询，无需繁琐的数据同步与导出，极大简化了数据分析链路。
支持丰富数据类型: 得益于KES内核，它不仅支持时序数据常用的数值、时间戳类型，还原生支持JSON、GIS空间数据、数组等复杂类型，能够满足更广泛的工业数字化场景需求。</p>
</li>
<li>
<p>复用并强化企业级核心能力
极致的事务（ACID）保证: 在金仓的时序表上，数据写入同样享有完整的关系型数据库事务支持，这在要求数据强一致性的金融、电力调度等关键业务场景中是独特优势。
企业级高可用与安全: 时序数据可直接受益于KES已构建成熟的读写分离、共享存储、分布式集群等高可用架构，以及行列级权限控制、数据加密等企业级安全特性。
成熟的生态与工具链: 可直接复用KES的备份恢复、监控运维、数据迁移（KDTS）等整套运维管理工具，以及与各类BI、ETL工具的连接生态，降低学习与运维成本。</p>
</li>
<li>
<p>面向复杂场景的综合性能表现
从金仓官方披露的测试报告（如使用TSBS工具对比InfluxDB）来看，其时序组件在特定场景下展现出竞争力：</p>
</li>
</ol>
<p>写入性能: 通过优化分区策略、并行插入等手段，在特定配置下可实现单机百万级、集群千万级数据点/秒的写入能力。
查询性能: 在涉及多维度聚合、跨表关联等复杂查询场景中，凭借成熟的SQL优化器与执行引擎，性能表现显著优于部分原生时序数据库，尤其适合需要将时序数据与业务数据进行深度整合分析的场景。</p>
<p>三、行业应用与实践
金仓时序组件的融合架构使其在那些既需要处理海量时序数据流，又需要与核心业务系统紧密集成的场景中找到了用武之地，公开案例包括：</p>
<p>福建省船舶安全综合管理平台: 处理沿海数十万船舶终端的GPS定位时序数据，基于KES分片（Sharding）方案实现日峰值亿级写入与百亿级历史数据的毫秒级地理空间查询。
国家电网智能电网调度系统: 在国产化迁移项目中，支撑高频、可靠的电力数据录入，并实现与大量既有关系型业务数据的混合处理与分析。
智慧港口（如厦门港）、智能制造厂区: 记录设备轨迹、工况时序数据，并与生产管理系统、设备管理系统进行实时关联分析。</p>
<p>四、2026年国产时序数据库选型思考
企业在2026年进行时序数据库选型时，应超越对单一峰值性能指标的过度关注，从更宏观的视角评估：</p>
<p>数据架构复杂性: 如果业务中时序数据与关系数据、空间数据等紧密耦合，需要频繁关联分析，金仓的融合多模架构将提供极大的便利性和整体性价比。
长期运维与总拥有成本（TCO）: 考虑引入新产品带来的学习成本、运维复杂度以及生态整合成本。复用现有关系型数据库团队的技能栈和工具链，是金仓方案的另一大隐性优势。</p>
<p>结论
2026年的国产时序数据库赛道已进入"精耕细作"阶段。以TDengine、IoTDB、DolphinDB为代表的专业时序库在各自优势领域持续深化。</p>
<p>金仓时序数据库凭借其独特的融合多模架构，走出了一条差异化道路。它并非"万能钥匙"，但对于那些业务逻辑复杂、数据形态多样、且对事务一致性与系统整合有高要求的企业级用户而言，提供了一个能够将时序数据能力平滑、稳健地嵌入到现有企业数据核心中的优秀选择，体现了国产基础软件在架构设计上的深度思考与务实创新。</p>
<p>未来，随着AI for Data、实时智能分析的普及，时序数据库的"智能"与"融合"能力将愈发关键。如何更好地将时序处理能力与多模数据、AI框架、流批计算无缝结合，将是所有厂商共同面临的下一个课题。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vuex 核心概念全解析：构建优雅的 Vue 应用状态管理]]></title>    <link>https://juejin.cn/post/7595841630676189235</link>    <guid>https://juejin.cn/post/7595841630676189235</guid>    <pubDate>2026-01-17T01:37:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595841630676189235" data-draft-id="7595847940620632114" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vuex 核心概念全解析：构建优雅的 Vue 应用状态管理"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2026-01-17T01:37:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vuex 核心概念全解析：构建优雅的 Vue 应用状态管理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T01:37:31.000Z" title="Sat Jan 17 2026 01:37:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vuex 核心概念全解析：构建优雅的 Vue 应用状态管理</h2>
<p>你是否曾在 Vue 项目中遇到过这样的困扰：</p>
<ul>
<li>• 组件间数据传递像“击鼓传花”，层层 props 透传令人头疼</li>
<li>• 兄弟组件通信需要借助父组件做“中转站”</li>
<li>• 多个组件依赖同一份数据，一处修改处处需要同步</li>
</ul>
<p>今天我们就来聊聊 Vue 的官方状态管理库——Vuex，帮你彻底解决这些痛点！</p>
<h3 data-id="heading-1">一、为什么需要 Vuex？</h3>
<p>想象一下，如果每个组件都有自己的“小账本”，当应用复杂时，数据就像散落的珍珠，难以统一管理。Vuex 就是一个“中央账本”，把数据集中存储，让状态变化变得可预测、可追踪。</p>
<h3 data-id="heading-2">二、Vuex 五大核心概念详解</h3>
<h4 data-id="heading-3">1. <strong>State（状态）—— 数据仓库</strong></h4>
<p>State 是 Vuex 的“数据库”，存储所有需要共享的数据。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">store </span>= <span class="hljs-keyword">new</span> Vuex.<span class="hljs-title function_ invoke__">Store</span>({
<span class="hljs-attr">  state</span>: {
<span class="hljs-attr">    user</span>: {
<span class="hljs-attr">      name</span>: <span class="hljs-string">'小明'</span>,
<span class="hljs-attr">      age</span>: <span class="hljs-number">25</span>
    },
<span class="hljs-attr">    cart</span>: []
  }
})
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>• 响应式：State 变化，依赖它的组件自动更新</li>
<li>• 单一数据源：整个应用只有一个 store</li>
<li>• 在组件中使用：<code>this.$store.state.user</code></li>
</ul>
<h4 data-id="heading-4">2. <strong>Getters（计算属性）—— 数据的“加工厂”</strong></h4>
<p>Getters 就像 Vue 中的 computed，用于从 state 派生出新数据。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-attr">getters</span>: {
  <span class="hljs-comment">// 获取购物车商品总数</span>
  <span class="hljs-attr">cartItemCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> state.<span class="hljs-property">cart</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> total + item.<span class="hljs-property">quantity</span>, <span class="hljs-number">0</span>)
  },
  
  <span class="hljs-comment">// 获取折扣后的价格</span>
  <span class="hljs-attr">discountedPrice</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">productId</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> product = state.<span class="hljs-property">products</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.<span class="hljs-property">id</span> === productId)
    <span class="hljs-keyword">return</span> product.<span class="hljs-property">price</span> * <span class="hljs-number">0.8</span>
  }
}
</code></pre>
<p><strong>使用场景：</strong></p>
<ul>
<li>• 数据过滤、格式化</li>
<li>• 复杂计算逻辑封装</li>
<li>• 组件中调用：<code>this.$store.getters.cartItemCount</code></li>
</ul>
<h4 data-id="heading-5">3. <strong>Mutations（变更）—— 唯一的状态修改者</strong></h4>
<p>Mutations 是修改 state 的<strong>唯一途径</strong>，每个 mutation 都有一个字符串类型的“事件类型”和一个回调函数。</p>
<pre><code class="hljs language-scss" lang="scss">mutations: {
  <span class="hljs-comment">// 添加商品到购物车</span>
  <span class="hljs-built_in">ADD_TO_CART</span>(state, product) {
    const existingItem = state<span class="hljs-selector-class">.cart</span><span class="hljs-selector-class">.find</span>(item =&gt; item.id === product.id)
    if (existingItem) {
      existingItem<span class="hljs-selector-class">.quantity</span>++
    } else {
      state<span class="hljs-selector-class">.cart</span><span class="hljs-selector-class">.push</span>({ ...product, quantity: <span class="hljs-number">1</span> })
    }
  },
  
  <span class="hljs-comment">// 清空购物车</span>
  <span class="hljs-built_in">CLEAR_CART</span>(state) {
    state<span class="hljs-selector-class">.cart</span> = <span class="hljs-selector-attr">[]</span>
  }
}
</code></pre>
<p><strong>重要原则：</strong></p>
<ul>
<li>• 必须是同步函数</li>
<li>• 通过 <code>store.commit('mutation名', payload)</code> 调用</li>
<li>• 让每次状态变化都可追踪</li>
</ul>
<h4 data-id="heading-6">4. <strong>Actions（动作）—— 处理异步操作的“指挥官”</strong></h4>
<p>Actions 可以包含任意异步操作，最终通过提交 mutation 来修改状态。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-attr">actions</span>: {
  <span class="hljs-comment">// 异步获取用户信息</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">{ commit }, userId</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUser</span>(userId)
      <span class="hljs-title function_">commit</span>(<span class="hljs-string">'SET_USER'</span>, response.<span class="hljs-property">data</span>) <span class="hljs-comment">// 调用 mutation</span>
      <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-title function_">commit</span>(<span class="hljs-string">'SET_ERROR'</span>, error.<span class="hljs-property">message</span>)
      <span class="hljs-keyword">throw</span> error
    }
  },
  
  <span class="hljs-comment">// 组合多个 mutation</span>
  <span class="hljs-title function_">checkout</span>(<span class="hljs-params">{ commit, state }</span>) {
    <span class="hljs-comment">// 保存订单</span>
    <span class="hljs-title function_">commit</span>(<span class="hljs-string">'CREATE_ORDER'</span>, state.<span class="hljs-property">cart</span>)
    <span class="hljs-comment">// 清空购物车</span>
    <span class="hljs-title function_">commit</span>(<span class="hljs-string">'CLEAR_CART'</span>)
    <span class="hljs-comment">// 显示成功提示</span>
    <span class="hljs-title function_">commit</span>(<span class="hljs-string">'SHOW_MESSAGE'</span>, <span class="hljs-string">'订单提交成功！'</span>)
  }
}
</code></pre>
<p><strong>与 Mutation 的区别：</strong></p>
<ul>
<li>• Action 提交的是 mutation，而不是直接变更状态</li>
<li>• Action 可以包含任意异步操作</li>
<li>• 通过 <code>store.dispatch('action名', payload)</code> 调用</li>
</ul>
<h4 data-id="heading-7">5. <strong>Modules（模块）—— 大型应用的“分治策略”</strong></h4>
<p>当应用复杂时，可以将 store 分割成模块，每个模块拥有自己的 state、mutations、actions、getters。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">userModule </span>= {
  namespaced: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启命名空间</span>
  state: () =&gt; ({ userInfo: <span class="hljs-literal">null</span> }),
  mutations: { <span class="hljs-comment">/* ... */</span> },
  actions: { <span class="hljs-comment">/* ... */</span> }
}

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">productModule </span>= {
  namespaced: <span class="hljs-literal">true</span>,
  state: () =&gt; ({ products: [] }),
  mutations: { <span class="hljs-comment">/* ... */</span> }
}

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">store </span>= <span class="hljs-keyword">new</span> Vuex.<span class="hljs-title function_ invoke__">Store</span>({
<span class="hljs-attr">  modules</span>: {
<span class="hljs-attr">    user</span>: userModule,
<span class="hljs-attr">    product</span>: productModule
  }
})
</code></pre>
<p><strong>模块化的好处：</strong></p>
<ul>
<li>• 避免 state 对象过于臃肿</li>
<li>• 让相关功能组织在一起</li>
<li>• 调用方式：<code>this.$store.dispatch('user/login', credentials)</code></li>
</ul>
<h3 data-id="heading-8">三、实战：购物车完整示例</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// store.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({
  <span class="hljs-attr">state</span>: {
    <span class="hljs-attr">cart</span>: [],
    <span class="hljs-attr">products</span>: []
  },
  
  <span class="hljs-attr">getters</span>: {
    <span class="hljs-attr">totalPrice</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> state.<span class="hljs-property">cart</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, item</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> sum + (item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span>)
      }, <span class="hljs-number">0</span>)
    }
  },
  
  <span class="hljs-attr">mutations</span>: {
    <span class="hljs-title function_">ADD_ITEM</span>(<span class="hljs-params">state, product</span>) {
      <span class="hljs-comment">// ... 添加商品逻辑</span>
    }
  },
  
  <span class="hljs-attr">actions</span>: {
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">loadProducts</span>(<span class="hljs-params">{ commit }</span>) {
      <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getProducts</span>()
      <span class="hljs-title function_">commit</span>(<span class="hljs-string">'SET_PRODUCTS'</span>, products)
    }
  }
})
</code></pre>
<h3 data-id="heading-9">四、最佳实践建议</h3>
<ol>
<li>
<p>1. <strong>遵循单向数据流</strong>：</p>
<pre><code class="hljs">组件 → Actions → Mutations → State → 组件更新
</code></pre>
</li>
<li>
<p>2. <strong>合理划分模块</strong>：</p>
</li>
<li>
<ul>
<li>• 按功能领域划分（user、product、order等）</li>
<li>• 大型项目考虑动态注册模块</li>
</ul>
</li>
<li>
<p>3. <strong>使用辅助函数</strong>简化代码：</p>
<pre><code class="hljs language-css" lang="css">import { mapState, mapActions } <span class="hljs-selector-tag">from</span> 'vuex'

export default {
  computed: {
    ..<span class="hljs-selector-class">.mapState</span>(<span class="hljs-selector-attr">[<span class="hljs-string">'user'</span>, <span class="hljs-string">'cart'</span>]</span>),
    ..<span class="hljs-selector-class">.mapGetters</span>(<span class="hljs-selector-attr">[<span class="hljs-string">'totalPrice'</span>]</span>)
  },
  methods: {
    ..<span class="hljs-selector-class">.mapActions</span>(<span class="hljs-selector-attr">[<span class="hljs-string">'fetchUser'</span>, <span class="hljs-string">'addToCart'</span>]</span>)
  }
}
</code></pre>
</li>
<li>
<p>4. <strong>TypeScript 支持</strong>：<br/>
Vuex 4 对 TypeScript 有更好的类型支持</p>
</li>
</ol>
<h3 data-id="heading-10">五、总结</h3>
<p>Vuex 的五员大将各司其职：</p>
<ul>
<li>• <strong>State</strong>：数据存储中心</li>
<li>• <strong>Getters</strong>：数据的计算加工</li>
<li>• <strong>Mutations</strong>：同步修改状态</li>
<li>• <strong>Actions</strong>：处理异步和复杂逻辑</li>
<li>• <strong>Modules</strong>：模块化管理</li>
</ul>
<p>记住这个简单的比喻：State 是仓库，Getters 是包装部，Mutations 是仓库管理员，Actions 是采购员，Modules 是分公司。</p>
<p>Vuex 的学习曲线可能有点陡峭，但一旦掌握，你将拥有管理复杂应用状态的超能力！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么你的 Prompt 越写越长，效果却越来越差？]]></title>    <link>https://juejin.cn/post/7595808703074074650</link>    <guid>https://juejin.cn/post/7595808703074074650</guid>    <pubDate>2026-01-17T05:10:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595808703074074650" data-draft-id="7595841630676795443" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么你的 Prompt 越写越长，效果却越来越差？"/> <meta itemprop="keywords" content="AIGC,AI编程"/> <meta itemprop="datePublished" content="2026-01-17T05:10:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="西陵"/> <meta itemprop="url" content="https://juejin.cn/user/4353721774379054"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么你的 Prompt 越写越长，效果却越来越差？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4353721774379054/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    西陵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T05:10:05.000Z" title="Sat Jan 17 2026 05:10:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    32
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大语言模型（LLM）在早期阶段主要以对话机器人的形式出现，用户通过自然语言向模型提问，模型返回一段看似智能的文本结果。这一阶段，模型能力的发挥高度依赖用户如何提问，同一个问题，用不同的描述方式，往往会得到质量差异巨大的结果。</p>
<p>在这种背景下，<code>提示词工程</code>作为一门面向大语言模型的输入设计方法论逐渐成型，本篇文章主要帮助大家快速了解<code>提示词工程</code>的本质以及在书写技巧。</p>
<h2 data-id="heading-1">什么是提示词工程？</h2>
<p>提示词工程的本质就是<strong>在有限上下文窗口内，最大化模型输出的确定性与可用性，减少模型自由发挥的空间</strong>。简单来说，就是提供一种提示词书写范式来确保大模型能够精准地按照用户的要求输出高质量的内容。</p>
<p><strong>❌ 差提示词</strong></p>
<pre><code class="hljs language-jsx" lang="jsx">帮我做一个个人待办清单页面
</code></pre>
<p>对于这段提示词，AI 不知道用什么技术、什么风格、要哪些功能、有什么限制。结果就是 AI 自由发挥，生成的代码和项目规范不符合。</p>
<p><strong>✅ 好提示词</strong></p>
<pre><code class="hljs language-jsx" lang="jsx">## 角色
你是一个擅长 <span class="hljs-title class_">React</span> 和用户体验设计的前端开发者。

## 背景
我需要做一个个人待办清单网页，用来记录每天的待办任务，现在已经完整基本功能的开发。

## 任务
实现任务的<span class="hljs-string">"拖拽排序"</span>功能，让用户可以通过拖拽调整任务顺序。

## 要求
- 拖拽时被拖动的任务半透明
- 放置位置有明显的视觉指示线
- 拖拽完成后顺序立即更新

## 约束
- 技术栈为 <span class="hljs-title class_">React</span> + <span class="hljs-title class_">TypeScript</span> + <span class="hljs-title class_">Tailwind</span> <span class="hljs-variable constant_">CSS</span>
- 不使用第三方拖拽库（如 react-beautiful-dnd）
- 用原生 <span class="hljs-title class_">HTML5</span> 拖拽 <span class="hljs-variable constant_">API</span>
- 代码要有详细注释，我是拖拽 <span class="hljs-variable constant_">API</span> 的初学者

## 输出格式
完整的 <span class="hljs-title class_">React</span> 组件代码，包含：
<span class="hljs-number">1.</span> 组件文件（<span class="hljs-title class_">TypeScript</span>）
<span class="hljs-number">2.</span> 关键逻辑的中文注释
<span class="hljs-number">3.</span> 简单的使用说明
</code></pre>
<h2 data-id="heading-2">提示词常见问题</h2>
<p>在实际使用中，提示词的质量参差不齐，以下是几类最常见的问题及其本质原因。</p>
<h3 data-id="heading-3">信息量过多</h3>
<p>我想让 AI 帮我做一个待办清单应用，于是将所有想法一次性列出：</p>
<pre><code class="hljs language-jsx" lang="jsx">帮我做一个待办清单应用，要有添加任务、删除任务、编辑任务、
标记完成、设置优先级、设置截止日期、分类标签、搜索功能、
数据统计、导出功能，还要有暗黑模式，最好能同步到云端，
支持多设备使用，界面要好看，用 <span class="hljs-title class_">React</span> 写，要有动画效果。
</code></pre>
<p><strong>问题本质</strong>：无结构、无重点。AI 可能会忽略关键信息，输出与某些要求冲突。</p>
<h3 data-id="heading-4">信息量太少</h3>
<p>我想让 AI 帮我写个按钮组件，只有一句需求，没有任何背景：</p>
<pre><code class="hljs language-jsx" lang="jsx">帮我写一个按钮组件
</code></pre>
<p><strong>问题本质</strong>：缺少上下文。上下文可能是：</p>
<ul>
<li>项目的技术栈</li>
<li>按钮需要的功能</li>
<li>期望的样式风格</li>
</ul>
<p>最终 AI 只能给一个通用的结果。</p>
<h3 data-id="heading-5">没有目标</h3>
<p>我想让 AI 帮我优化代码，但不给优化目标：</p>
<pre><code class="hljs language-jsx" lang="jsx">帮我优化一下这段代码：
[粘贴了一段代码]
</code></pre>
<p><strong>问题本质</strong>：只有动作，没有结果。优化指代不明确——是体积、性能还是可读性？最终输出的结果必然不符合预期。</p>
<h3 data-id="heading-6">没有约束</h3>
<p>我想让 AI 帮我写一个输入框组件，但是没有添加相关约束：</p>
<pre><code class="hljs language-jsx" lang="jsx">帮我写一个输入框组件。

技术栈：<span class="hljs-title class_">React</span> + <span class="hljs-title class_">TypeScript</span> + <span class="hljs-variable constant_">SCSS</span>
</code></pre>
<p><strong>问题本质</strong>：AI 容易引入额外的假设，例如：</p>
<ul>
<li>使用不兼容的 ui 组件库，例如 antd。</li>
<li>使用复杂的状态管理机制。</li>
</ul>
<p>导致最终输出<strong>不可控</strong>，隐性引入错误假设。</p>
<h2 data-id="heading-7">提示词模板</h2>
<p>了解了常见问题后，我们需要一套结构化的方法来避免它们。这就是提示词模板的价值所在。</p>
<h3 data-id="heading-8">提示词的困扰</h3>
<p>我们现在知道在使用 AI 时，提供的上下文越清晰，AI 给出的回答就会越符合预期。但是每次写提示词的时候，我们大概率还是会陷入这样的状态：</p>
<blockquote>
<p>我要先给 AI 指定一个角色，告诉他背景和任务，还有约束、要求、技术栈……约束要包含什么内容？要求要写什么？技术栈要放到哪里？</p>
</blockquote>
<p>这会给 AI 使用者带来很大的认知负担，我们同时要思考"说什么"和"怎么说"。而模板的价值，就是<strong>把"怎么说"变成固定格式，让你专注于"说什么"</strong>。</p>
<p>这与前端的开发框架（React/Vue）很类似：在没有框架之前，开发者既要关注业务，同时还需要关注 DOM 更新及性能问题；随着框架的推出，前端开发者能把更多的精力放到业务功能开发上。</p>
<h3 data-id="heading-9">模板目标</h3>
<p>提示词模板的目标是<strong>减少使用者的思考负担并提高 AI 输出的稳定性</strong>。但模板并不是终极目标，因为固定的模板反而会限制灵活性。因此在不同阶段、不同场景，使用者可以对模板进行调整：</p>





















<table><thead><tr><th><strong>阶段</strong></th><th><strong>做法</strong></th></tr></thead><tbody><tr><td>初级阶段</td><td>严格按框架填写，确保不遗漏</td></tr><tr><td>熟练阶段</td><td>根据任务复杂度简化或扩展</td></tr><tr><td>高手阶段</td><td>框架内化成直觉，自然地组织信息</td></tr></tbody></table>
<h3 data-id="heading-10">推荐模板</h3>
<p>模板结构：</p>













































<table><thead><tr><th><strong>主题</strong></th><th><strong>必填程度</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>角色</td><td>必须</td><td>让 AI 成为某个领域的专家</td></tr><tr><td>背景</td><td>必须</td><td>让 AI 提前了解任务的背景知识</td></tr><tr><td>任务</td><td>必须</td><td>告诉 AI 要做什么</td></tr><tr><td>要求</td><td>推荐</td><td>告诉 AI 任务完成的标准</td></tr><tr><td>约束</td><td>推荐</td><td>为 AI 划定边界，防止自由发挥</td></tr><tr><td>格式</td><td>可选</td><td>告诉 AI 最终输出内容的格式</td></tr><tr><td>示例</td><td>可选</td><td>用实际的例子告诉 AI 要怎么做</td></tr></tbody></table>
<p>模板示例：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 角色</span>
你是一个擅长 React 和组件开发的的前端开发者。

<span class="hljs-section">## 背景</span>
我使用 react 开发了一个基础组件库，里面包含了xx个组件，组件名称如下xxx。

<span class="hljs-section">## 任务</span>
帮我为每个组件生成一份 mdr 文件，表示该组件的使用详细说明。

<span class="hljs-section">## 要求</span>
<span class="hljs-bullet">-</span> 文档要包含组件的 API、使用示例、xxx。

<span class="hljs-section">## 约束</span>
<span class="hljs-bullet">-</span> 使用 md 语法。
<span class="hljs-bullet">-</span> 必须保证 API 的完整，不能漏掉内容。

<span class="hljs-section">## 输出格式</span>
Title: 组件名称

description: 组件描述

API：
xxx

Examples：
xxx

<span class="hljs-section">## 示例</span>

Title: Alert

description: 警示组件

API:

| 参数 | 说明 | 类型 | 默认值 | 版本 |
| --- | --- | --- | --- | --- |
| action | 自定义操作项 | ReactNode | - | 4.9.0 |
| afterClose | 关闭动画结束后触发的回调函数 | () =&gt; void | - |  |
| banner | 是否用作顶部公告 | boolean | false |  |

</code></pre>
<h2 data-id="heading-11">进阶提示词技巧</h2>
<h3 data-id="heading-12"><strong>Few-shot Prompting</strong></h3>
<p>Few-shot 的核心思想就是给 AI 几个例子，让他先按照例子学习，理解任务处理流程及最终的内容输出。这种模式能够更高效的让 AI 理解用户的意图，这和人学习新东西一样，直接看示范比读文档更高效。</p>
<pre><code class="hljs language-jsx" lang="jsx">任务：为 <span class="hljs-title class_">React</span> 组件生成 <span class="hljs-title class_">TypeScript</span> <span class="hljs-title class_">Props</span> 类型定义

示例<span class="hljs-number">1</span>：
组件描述：一个显示任务标题的组件，标题必填，可选显示完成状态
输出：
interface <span class="hljs-title class_">TaskTitleProps</span> {
  <span class="hljs-attr">title</span>: string;           <span class="hljs-comment">// 任务标题，必填</span>
  isCompleted?: boolean;   <span class="hljs-comment">// 完成状态，可选</span>
}

示例<span class="hljs-number">2</span>：
组件描述：一个按钮组件，显示文字必填，点击事件必填，可选禁用状态
输出：
interface <span class="hljs-title class_">ButtonProps</span> {
  <span class="hljs-attr">label</span>: string;           <span class="hljs-comment">// 按钮文字，必填</span>
  <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>;     <span class="hljs-comment">// 点击事件，必填</span>
  disabled?: boolean;      <span class="hljs-comment">// 禁用状态，可选</span>
}
</code></pre>
<p>示例虽然能够更高效的帮助 AI 理解任务，但是过多的示例也会加大 token 的消耗，因此示例不是越多越好，要遵循<strong>少而精的原则</strong>，通过 2～5 个例子将典型的场景、多样性场景以及边界场景列举出来。</p>
<h3 data-id="heading-13"><strong>Chain of Thought</strong></h3>
<p>Chain of Thought 的核心思想是告诉 AI 让他一步步思考推理，输出推理内容，而不是直接给答案。就像解数学题一样，把解题的每一步都写出来，这样往往能让 AI 输出更准确的答案。</p>
<pre><code class="hljs language-jsx" lang="jsx">## 角色
你是一个擅长 <span class="hljs-title class_">React</span> 和组件开发的的前端开发者。

## 背景
我使用 react 开发了一个基础组件库，里面包含了xx个组件。

## 任务
帮我给修改的 react 组件补充新的单测。

### 修改点分析步骤
- 分析组件的 props，找出新增/删减/修改的参数，并输出出来。
- 分析组件的内部逻辑，找出新增/删除/修改的逻辑，并输出出来。

</code></pre>
<p>这种模式在复杂的场景中会大大提升输出效果，但是也存在一些局限：</p>
<ul>
<li>输出内容的长度会大大增加，增加 Token 的消耗。</li>
<li>对于某些简单任务，强行使用该模式可能反而会降低效果。</li>
<li>如果推理的过程中某一步出错，可能会导致接下来步骤都会出错，需要配合 Self-Critique 来检查。</li>
</ul>
<h3 data-id="heading-14"><strong>Self-Critique</strong></h3>
<p>与人类一样，AI 并非总能在首次尝试时就生成最佳输出，Self-Critique 的核心思想是在 AI 生成内容之后，让 AI 再自我检查一遍，发现并修复问题。这个和我们考试答题一样，做完之后再检查一遍往往能发现遗漏的细节或者写错的题。</p>
<pre><code class="hljs language-jsx" lang="jsx">## 角色
你是一个擅长 <span class="hljs-title class_">React</span> 和组件开发的的前端开发者。

## 背景
我使用 react 开发了一个基础组件库，里面包含了xx个组件。

## 任务
帮我给修改的 react 组件补充新的单测。

## 修改点分析步骤
- 分析组件的 props，找出新增/删减/修改的参数，并输出出来。
- 分析组件的内部逻辑，找出新增/删除/修改的逻辑，并输出出来。

## 要求

- 生成完之后，请严格自查
	- 是否覆盖了所有修改点。
	- 每个修改点是否覆盖了所有边界情况（空值、空字符串、只有空格）
</code></pre>
<p>这种模式下会让 AI 扮演一个审查者的角色重新审下生成的内容，提高内容的准确性，但是也有它的局限：</p>
<ul>
<li>增加 Token 的消耗，这种模式更推荐在复杂的场景中使用。</li>
<li>AI 可能出现自我认可的偏差，认为输出是没问题的，此时<strong>需要严格给 AI 设定审查者的角色</strong>。</li>
</ul>
<h2 data-id="heading-15">总结</h2>
<p>本文围绕「提示词工程」展开，从背景、核心目标、常见问题、结构化模板，到 Few-shot、Chain of Thought、Self-Critique 等进阶技巧，系统性地说明了一件事：</p>
<blockquote>
<p>提示词工程的本质，不是“如何把话说得更漂亮”，而是如何通过结构化上下文，降低大模型输出的不确定性。</p>
</blockquote>
<p>然而，这种提示词优化的思路也带来了新的工程问题：<strong>提示词越来越长、结构越来越复杂，最终直接反映为 Token 体积的持续膨胀</strong>。</p>
<p>因此，在实际工程中，提示词优化并不等同于写得越详细越好，而是需要在<strong>信息充分性与 Token 成本之间取得平衡</strong>。如何控制上下文规模、避免无效信息堆积、并在复杂任务中持续提供刚刚好的上下文，成为提示词工程之后必须面对的核心问题。</p>
<h2 data-id="heading-16">参考资料</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fguides%2Fprompt-engineering" target="_blank" title="https://platform.openai.com/docs/guides/prompt-engineering" ref="nofollow noopener noreferrer">OpenAI Prompt Engineering Guide</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.anthropic.com%2Fclaude%2Fdocs%2Fprompt-engineering" target="_blank" title="https://docs.anthropic.com/claude/docs/prompt-engineering" ref="nofollow noopener noreferrer">Anthropic Prompt Engineering</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2005.14165" target="_blank" title="https://arxiv.org/abs/2005.14165" ref="nofollow noopener noreferrer">Few-shot Prompting</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2201.11903" target="_blank" title="https://arxiv.org/abs/2201.11903" ref="nofollow noopener noreferrer">Chain of Thought</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2303.17651" target="_blank" title="https://arxiv.org/abs/2303.17651" ref="nofollow noopener noreferrer">Self-Critique</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Caffeine入门到实战]]></title>    <link>https://juejin.cn/post/7595841630677106739</link>    <guid>https://juejin.cn/post/7595841630677106739</guid>    <pubDate>2026-01-17T07:46:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595841630677106739" data-draft-id="7595842144906625074" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Caffeine入门到实战"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2026-01-17T07:46:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Caffeine入门到实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T07:46:22.000Z" title="Sat Jan 17 2026 07:46:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>高性能Java缓存框架实战，让你秒懂缓存优化</p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<p>在当今高并发的互联网应用中，缓存已经成为提升系统性能的关键技术之一。本文将带你从零开始，深入浅出地学习Caffeine这款高性能的Java缓存框架，并通过实际案例让你掌握缓存技术的精髓。</p>
<h2 data-id="heading-1">1. Caffeine简介</h2>
<p>Caffeine是一个基于Java的高性能缓存库，由Google开发并开源。它被认为是Java缓存领域的王者，在性能测试中表现优异。</p>
<h3 data-id="heading-2">为什么选择Caffeine？</h3>
<ul>
<li><strong>高性能</strong>：采用先进的算法，读写性能卓越</li>
<li><strong>功能丰富</strong>：支持多种过期策略、异步加载、统计信息等</li>
<li><strong>线程安全</strong>：并发性能优秀</li>
<li><strong>易于使用</strong>：API设计简洁直观</li>
<li><strong>活跃社区</strong>：持续维护和更新</li>
</ul>
<h3 data-id="heading-3">架构设计</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3e6e0d899e14fbaaafafa3123056baf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769240782&amp;x-signature=hfMSuIcQysmqzw2OjT3WiDv4Wtw%3D" alt="" loading="lazy"/></p>
<p>Caffeine的核心架构包括：</p>
<ol>
<li><strong>缓存容器</strong>：使用ConcurrentHashMap作为底层数据结构</li>
<li><strong>访问策略</strong>：采用Window TinyLFU算法进行频率统计</li>
<li><strong>淘汰策略</strong>：基于时间窗口和频率的混合淘汰策略</li>
<li><strong>事件机制</strong>：支持监听缓存的各种事件</li>
</ol>
<h2 data-id="heading-4">2. 快速入门</h2>
<h3 data-id="heading-5">Maven依赖</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3 data-id="heading-6">基础使用示例</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> com.<span class="hljs-property">github</span>.<span class="hljs-property">benmanes</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">Cache</span>;
<span class="hljs-keyword">import</span> com.<span class="hljs-property">github</span>.<span class="hljs-property">benmanes</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">Caffeine</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">TimeUnit</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicCacheExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-comment">// 创建缓存</span>
        <span class="hljs-title class_">Cache</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt; cache = <span class="hljs-title class_">Caffeine</span>.<span class="hljs-title function_">newBuilder</span>()
            .<span class="hljs-title function_">maximumSize</span>(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 最大缓存数量</span>
            .<span class="hljs-title function_">expireAfterWrite</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MINUTES</span>) <span class="hljs-comment">// 写入后10分钟过期</span>
            .<span class="hljs-title function_">build</span>();

        <span class="hljs-comment">// 存储数据</span>
        cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>);

        <span class="hljs-comment">// 获取数据</span>
        <span class="hljs-title class_">String</span> value = cache.<span class="hljs-title function_">getIfPresent</span>(<span class="hljs-string">"key1"</span>);
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"缓存值: "</span> + value);

        <span class="hljs-comment">// 获取或计算</span>
        <span class="hljs-title class_">String</span> value2 = cache.<span class="hljs-title function_">get</span>(<span class="hljs-string">"key2"</span>, k -&gt; <span class="hljs-string">"defaultValue"</span>);
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"缓存值: "</span> + value2);

        <span class="hljs-comment">// 移除数据</span>
        cache.<span class="hljs-title function_">invalidate</span>(<span class="hljs-string">"key1"</span>);
    }
}
</code></pre>
<h2 data-id="heading-7">3. 核心概念</h2>
<h3 data-id="heading-8">3.1 Cache vs LoadingCache vs AsyncLoadingCache</h3>
<p>Caffeine提供了三种缓存类型：</p>
<ol>
<li><strong>Cache</strong>：基础缓存，需要手动管理数据</li>
<li><strong>LoadingCache</strong>：自动加载数据的缓存</li>
<li><strong>AsyncLoadingCache</strong>：异步加载数据的缓存</li>
</ol>
<h3 data-id="heading-9">3.2 过期策略</h3>
<p>Caffeine提供了三种过期策略：</p>
<pre><code class="hljs language-scss" lang="scss">Caffeine<span class="hljs-selector-class">.newBuilder</span>()
    <span class="hljs-selector-class">.expireAfterWrite</span>(<span class="hljs-number">10</span>, TimeUnit.MINUTES) <span class="hljs-comment">// 写入后过期</span>
    <span class="hljs-selector-class">.expireAfterAccess</span>(<span class="hljs-number">5</span>, TimeUnit.MINUTES)  <span class="hljs-comment">// 最后访问后过期</span>
    <span class="hljs-selector-class">.expireAfter</span>(<span class="hljs-number">30</span>, TimeUnit.MINUTES);       <span class="hljs-comment">// 自定义过期逻辑</span>
</code></pre>
<h3 data-id="heading-10">3.3 淘汰策略</h3>
<pre><code class="hljs language-scss" lang="scss">Caffeine<span class="hljs-selector-class">.newBuilder</span>()
    <span class="hljs-selector-class">.maximumSize</span>(<span class="hljs-number">1000</span>)         <span class="hljs-comment">// 基于数量</span>
    <span class="hljs-selector-class">.maximumWeight</span>(<span class="hljs-number">10000</span>)      <span class="hljs-comment">// 基于权重</span>
    <span class="hljs-selector-class">.weakKeys</span>()               <span class="hljs-comment">// 弱引用键</span>
    <span class="hljs-selector-class">.weakValues</span>()             <span class="hljs-comment">// 弱引用值</span>
    <span class="hljs-selector-class">.softValues</span>();            <span class="hljs-comment">// 软引用值</span>
</code></pre>
<h2 data-id="heading-11">4. 高级特性</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff936a2d76c04f1aaf866ccba450d2fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769240782&amp;x-signature=vIDzfY5%2B20eLh9huJFxIDK%2FnZbk%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-12">4.1 异步加载</h3>
<pre><code class="hljs language-ini" lang="ini">AsyncLoadingCache&lt;String, User&gt; <span class="hljs-attr">asyncCache</span> = Caffeine.newBuilder()
    .maximumSize(1000)
    .expireAfterWrite(10, TimeUnit.MINUTES)
    .buildAsync(key -&gt; loadUserFromDatabase(key))<span class="hljs-comment">;</span>

// 异步获取
CompletableFuture&lt;User&gt; <span class="hljs-attr">userFuture</span> = asyncCache.get(<span class="hljs-string">"user1"</span>)<span class="hljs-comment">;</span>
userFuture.thenAccept(user -&gt; {
    System.out.println("获取用户: " + user.getName())<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-13">4.2 事件监听</h3>
<pre><code class="hljs language-vbnet" lang="vbnet">Cache&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; cache = Caffeine.newBuilder()
    .maximumSize(<span class="hljs-number">1000</span>)
    .removalListener((<span class="hljs-keyword">key</span>, value, cause) -&gt; {
        System.out.println(<span class="hljs-string">"缓存移除: "</span> + <span class="hljs-keyword">key</span> + <span class="hljs-string">" -&gt; "</span> + value + <span class="hljs-string">", 原因: "</span> + cause);
    })
    .build();
</code></pre>
<h3 data-id="heading-14">4.3 统计信息</h3>
<pre><code class="hljs language-scss" lang="scss">Cache&lt;String, String&gt; cache = Caffeine<span class="hljs-selector-class">.newBuilder</span>()
    <span class="hljs-selector-class">.maximumSize</span>(<span class="hljs-number">1000</span>)
    <span class="hljs-selector-class">.recordStats</span>() <span class="hljs-comment">// 启用统计</span>
    <span class="hljs-selector-class">.build</span>();

<span class="hljs-comment">// 使用缓存...</span>
cache<span class="hljs-selector-class">.put</span>("key1", "value1");
cache<span class="hljs-selector-class">.getIfPresent</span>("key1");

<span class="hljs-comment">// 获取统计信息</span>
CacheStats stats = cache<span class="hljs-selector-class">.stats</span>();
System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>("命中率: " + stats.hitRate());
System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>("加载时间: " + stats.averageLoadPenalty());
System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>("请求数: " + stats.requestCount());
</code></pre>
<h2 data-id="heading-15">5. Spring Boot集成</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aff82efaf278437f8045c4dae72c58be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769240782&amp;x-signature=x8wXynqrw1CSWo8vv794U8KA5Sg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-16">5.1 添加依赖</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3 data-id="heading-17">5.2 配置类</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> com.<span class="hljs-property">github</span>.<span class="hljs-property">benmanes</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">Caffeine</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">CacheManager</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">EnableCaching</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">CaffeineCacheManager</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Bean</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Configuration</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">TimeUnit</span>;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableCaching</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CacheManager</span> <span class="hljs-title function_">cacheManager</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">CaffeineCacheManager</span> cacheManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CaffeineCacheManager</span>();
        cacheManager.<span class="hljs-title function_">setCaffeine</span>(<span class="hljs-title function_">caffeineCacheBuilder</span>());
        <span class="hljs-keyword">return</span> cacheManager;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Caffeine</span>&lt;<span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span>&gt; <span class="hljs-title function_">caffeineCacheBuilder</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Caffeine</span>.<span class="hljs-title function_">newBuilder</span>()
                .<span class="hljs-title function_">initialCapacity</span>(<span class="hljs-number">100</span>)
                .<span class="hljs-title function_">maximumSize</span>(<span class="hljs-number">1000</span>)
                .<span class="hljs-title function_">expireAfterWrite</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MINUTES</span>)
                .<span class="hljs-title function_">recordStats</span>();
    }
}
</code></pre>
<h3 data-id="heading-18">5.3 使用注解</h3>
<pre><code class="hljs language-typescript" lang="typescript">package com.<span class="hljs-property">example</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">demo</span>.<span class="hljs-property">service</span>;

<span class="hljs-keyword">import</span> com.<span class="hljs-property">example</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">demo</span>.<span class="hljs-property">model</span>.<span class="hljs-property">User</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">CacheEvict</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">CachePut</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Cacheable</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Service</span>;

<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.*;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">ConcurrentHashMap</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">TimeUnit</span>;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {

    <span class="hljs-comment">// 模拟数据库存储</span>
    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">Long</span>, <span class="hljs-title class_">User</span>&gt; userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserService</span>() {
        <span class="hljs-comment">// 初始化一些测试数据</span>
        userMap.<span class="hljs-title function_">put</span>(1L, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(1L, <span class="hljs-string">"张三"</span>, <span class="hljs-string">"zhangsan@example.com"</span>, <span class="hljs-string">"13800138000"</span>));
        userMap.<span class="hljs-title function_">put</span>(2L, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(2L, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"lisi@example.com"</span>, <span class="hljs-string">"13900139000"</span>));
        userMap.<span class="hljs-title function_">put</span>(3L, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(3L, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"wangwu@example.com"</span>, <span class="hljs-string">"13700137000"</span>));
    }

    <span class="hljs-comment">/**
     * 获取用户信息（带缓存）
     * <span class="hljs-doctag">@param</span> userId 用户ID
     * <span class="hljs-doctag">@return</span> 用户信息
     */</span>
    <span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"users"</span>, key = <span class="hljs-string">"#userId"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span> <span class="hljs-title function_">getUserById</span>(<span class="hljs-params">Long userId</span>) {
        <span class="hljs-comment">// 模拟数据库查询耗时</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MILLISECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">100</span>);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">interrupt</span>();
        }

        <span class="hljs-title class_">User</span> user = userMap.<span class="hljs-title function_">get</span>(userId);
        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"用户不存在: "</span> + userId);
        }
        <span class="hljs-keyword">return</span> user;
    }

    <span class="hljs-comment">/**
     * 获取用户信息（异步）
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CompletableFuture</span>&lt;<span class="hljs-title class_">User</span>&gt; <span class="hljs-title function_">getUserByIdAsync</span>(<span class="hljs-params">Long userId</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">CompletableFuture</span>.<span class="hljs-title function_">supplyAsync</span>(() -&gt; <span class="hljs-title function_">getUserById</span>(userId));
    }

    <span class="hljs-comment">/**
     * 获取所有用户信息
     */</span>
    <span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"users"</span>, key = <span class="hljs-string">"'all'"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">User</span>&gt; <span class="hljs-title function_">getAllUsers</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 模拟数据库查询耗时</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MILLISECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">200</span>);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">interrupt</span>();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(userMap.<span class="hljs-title function_">values</span>());
    }

    <span class="hljs-comment">/**
     * 创建用户
     */</span>
    <span class="hljs-meta">@CachePut</span>(value = <span class="hljs-string">"users"</span>, key = <span class="hljs-string">"#user.id"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params">User user</span>) {
        userMap.<span class="hljs-title function_">put</span>(user.<span class="hljs-title function_">getId</span>(), user);
        <span class="hljs-keyword">return</span> user;
    }

    <span class="hljs-comment">/**
     * 更新用户信息
     */</span>
    <span class="hljs-meta">@CachePut</span>(value = <span class="hljs-string">"users"</span>, key = <span class="hljs-string">"#user.id"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span> <span class="hljs-title function_">updateUser</span>(<span class="hljs-params">User user</span>) {
        <span class="hljs-keyword">if</span> (!userMap.<span class="hljs-title function_">containsKey</span>(user.<span class="hljs-title function_">getId</span>())) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"用户不存在: "</span> + user.<span class="hljs-title function_">getId</span>());
        }
        user.<span class="hljs-title function_">setUpdateTime</span>(<span class="hljs-title class_">LocalDateTime</span>.<span class="hljs-title function_">now</span>());
        userMap.<span class="hljs-title function_">put</span>(user.<span class="hljs-title function_">getId</span>(), user);
        <span class="hljs-keyword">return</span> user;
    }

    <span class="hljs-comment">/**
     * 删除用户
     */</span>
    <span class="hljs-meta">@CacheEvict</span>(value = <span class="hljs-string">"users"</span>, key = <span class="hljs-string">"#userId"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">Long userId</span>) {
        <span class="hljs-title class_">User</span> removed = userMap.<span class="hljs-title function_">remove</span>(userId);
        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"用户不存在: "</span> + userId);
        }
    }

    <span class="hljs-comment">/**
     * 批量获取用户信息
     */</span>
    <span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"users"</span>, key = <span class="hljs-string">"'batch:' + #userIds.hashCode()"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">Long</span>, <span class="hljs-title class_">User</span>&gt; <span class="hljs-title function_">batchGetUsers</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;Long&gt; userIds</span>) {
        <span class="hljs-comment">// 模拟批量查询耗时</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MILLISECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">150</span>);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">interrupt</span>();
        }

        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">Long</span>, <span class="hljs-title class_">User</span>&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Long</span> userId : userIds) {
            <span class="hljs-title class_">User</span> user = userMap.<span class="hljs-title function_">get</span>(userId);
            <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) {
                result.<span class="hljs-title function_">put</span>(userId, user);
            }
        }
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * 根据用户名模糊查询
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">User</span>&gt; <span class="hljs-title function_">searchUsersByUsername</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> keyword</span>) {
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">User</span>&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">User</span> user : userMap.<span class="hljs-title function_">values</span>()) {
            <span class="hljs-keyword">if</span> (user.<span class="hljs-title function_">getUsername</span>().<span class="hljs-title function_">contains</span>(keyword)) {
                result.<span class="hljs-title function_">add</span>(user);
            }
        }
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * 清空所有缓存
     */</span>
    <span class="hljs-meta">@CacheEvict</span>(value = <span class="hljs-string">"users"</span>, allEntries = <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">clearAllCache</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"清空所有用户缓存"</span>);
    }

    <span class="hljs-comment">/**
     * 获取用户总数
     */</span>
    <span class="hljs-keyword">public</span> long <span class="hljs-title function_">getUserCount</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> userMap.<span class="hljs-title function_">size</span>();
    }
}
</code></pre>
<h2 data-id="heading-19">6. 生产环境最佳实践</h2>
<h3 data-id="heading-20">6.1 缓存雪崩与击穿</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ae45c5ae2c644e7b19813de7bb61db4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769240782&amp;x-signature=s5Bj%2B0%2FpD1TT%2FcUtgYIihfc%2BzFI%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-21">缓存雪崩解决方案</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 1. 设置随机过期时间</span>
Caffeine.newBuilder()
    .expireAfterWrite(<span class="hljs-number">10</span> + <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">5</span>), TimeUnit.MINUTES);

<span class="hljs-comment">// 2. 使用互斥锁</span>
<span class="hljs-keyword">private</span> final Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();

<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserWithLock</span>(<span class="hljs-params">Long id</span>)</span> {
    User user = cache.getIfPresent(id);
    <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> user;
    }

    <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 双重检查</span>
        user = cache.getIfPresent(id);
        <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> user;
        }

        user = userRepository.findById(id);
        cache.put(id, user);
        <span class="hljs-keyword">return</span> user;
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">lock</span>.unlock();
    }
}
</code></pre>
<h4 data-id="heading-22">缓存击穿解决方案</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 使用Caffeine的异步加载</span>
AsyncLoadingCache&lt;Long, User&gt; asyncCache = Caffeine<span class="hljs-selector-class">.newBuilder</span>()
    <span class="hljs-selector-class">.maximumSize</span>(<span class="hljs-number">1000</span>)
    <span class="hljs-selector-class">.expireAfterWrite</span>(<span class="hljs-number">10</span>, TimeUnit.MINUTES)
    <span class="hljs-selector-class">.buildAsync</span>(key -&gt; loadUserFromDatabase(key));

public User <span class="hljs-built_in">getUser</span>(Long id) {
    return asyncCache<span class="hljs-selector-class">.get</span>(id)<span class="hljs-selector-class">.join</span>();
}
</code></pre>
<h3 data-id="heading-23">6.2 缓存预热</h3>
<pre><code class="hljs language-scss" lang="scss">package com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.caffeine</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.cache</span>;

import com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.caffeine</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.User</span>;
import com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.caffeine</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.UserService</span>;
import lombok<span class="hljs-selector-class">.extern</span><span class="hljs-selector-class">.slf4j</span><span class="hljs-selector-class">.Slf4j</span>;
import org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.beans</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Autowired</span>;
import org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.CommandLineRunner</span>;
import org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.stereotype</span><span class="hljs-selector-class">.Component</span>;

import java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Arrays</span>;
import java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.List</span>;
import java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.CompletableFuture</span>;
import java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ExecutorService</span>;
import java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.Executors</span>;
import java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.TimeUnit</span>;
import java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.Collectors</span>;

<span class="hljs-comment">/**
 * 缓存预热启动器
 *
 * 功能：
 * 1. 在应用启动时自动预热热点数据到缓存
 * 2. 支持同步和异步预热方式
 * 3. 支持批量预热
 * 4. 提供预热进度监控
 * 5. 异常处理和重试机制
 */</span>
<span class="hljs-keyword">@Slf</span>4j
<span class="hljs-keyword">@Component</span>
public class CacheWarmupRunner implements CommandLineRunner {

    <span class="hljs-keyword">@Autowired</span>
    private UserService userService;

    <span class="hljs-comment">/**
     * 预热配置
     */</span>
    private static class WarmupConfig {
        <span class="hljs-comment">// 预热用户ID列表（可以根据业务需求配置）</span>
        private static final List&lt;Long&gt; HOT_USER_IDS = Arrays<span class="hljs-selector-class">.asList</span>(<span class="hljs-number">1</span>L, <span class="hljs-number">2</span>L, <span class="hljs-number">3</span>L, <span class="hljs-number">4</span>L, <span class="hljs-number">5</span>L);

        <span class="hljs-comment">// 预热批次大小</span>
        private static final int BATCH_SIZE = <span class="hljs-number">3</span>;

        <span class="hljs-comment">// 线程池大小</span>
        private static final int THREAD_POOL_SIZE = <span class="hljs-number">2</span>;

        <span class="hljs-comment">// 是否启用异步预热</span>
        private static final boolean ASYNC_WARMUP = true;

        <span class="hljs-comment">// 最大重试次数</span>
        private static final int MAX_RETRY_TIMES = <span class="hljs-number">3</span>;

        <span class="hljs-comment">// 重试间隔（毫秒）</span>
        private static final long RETRY_INTERVAL = <span class="hljs-number">1000</span>L;
    }

    <span class="hljs-keyword">@Override</span>
    public void run(String... args) throws Exception {
        log<span class="hljs-selector-class">.info</span>("开始执行缓存预热...");
        long startTime = System<span class="hljs-selector-class">.currentTimeMillis</span>();

        try {
            if (WarmupConfig.ASYNC_WARMUP) {
                <span class="hljs-comment">// 异步预热</span>
                <span class="hljs-built_in">asyncWarmup</span>();
            } else {
                <span class="hljs-comment">// 同步预热</span>
                <span class="hljs-built_in">syncWarmup</span>();
            }

            long endTime = System<span class="hljs-selector-class">.currentTimeMillis</span>();
            log<span class="hljs-selector-class">.info</span>("缓存预热完成！耗时: {} ms", endTime - startTime);

        } catch (Exception e) {
            log<span class="hljs-selector-class">.error</span>("缓存预热失败！错误信息: {}", e.getMessage(), e);
        }
    }

    <span class="hljs-comment">/**
     * 同步预热方式
     */</span>
    private void <span class="hljs-built_in">syncWarmup</span>() {
        log<span class="hljs-selector-class">.info</span>("使用同步方式预热缓存...");

        <span class="hljs-comment">// 方法1：逐个预热</span>
        log<span class="hljs-selector-class">.info</span>("逐个预热用户数据...");
        for (Long userId : WarmupConfig.HOT_USER_IDS) {
            <span class="hljs-built_in">warmupSingleUser</span>(userId);
        }

        <span class="hljs-comment">// 方法2：批量预热</span>
        log<span class="hljs-selector-class">.info</span>("批量预热用户数据...");
        <span class="hljs-built_in">batchWarmupUsers</span>(WarmupConfig.HOT_USER_IDS);

        <span class="hljs-comment">// 方法3：预热所有用户</span>
        log<span class="hljs-selector-class">.info</span>("预热所有用户数据...");
        <span class="hljs-built_in">warmupAllUsers</span>();
    }

    <span class="hljs-comment">/**
     * 异步预热方式
     */</span>
    private void <span class="hljs-built_in">asyncWarmup</span>() {
        log<span class="hljs-selector-class">.info</span>("使用异步方式预热缓存...");

        ExecutorService executor = Executors<span class="hljs-selector-class">.newFixedThreadPool</span>(WarmupConfig.THREAD_POOL_SIZE);

        <span class="hljs-comment">// 创建异步预热任务</span>
        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = WarmupConfig<span class="hljs-selector-class">.HOT_USER_IDS</span><span class="hljs-selector-class">.stream</span>()
            <span class="hljs-selector-class">.map</span>(userId -&gt; CompletableFuture.runAsync(() -&gt; {
                try {
                    <span class="hljs-built_in">warmupSingleUserWithRetry</span>(userId);
                } catch (Exception e) {
                    log<span class="hljs-selector-class">.error</span>("预热用户 {} 失败: {}", userId, e.getMessage());
                }
            }, executor))
            <span class="hljs-selector-class">.collect</span>(Collectors.toList());

        <span class="hljs-comment">// 等待所有任务完成</span>
        CompletableFuture<span class="hljs-selector-class">.allOf</span>(futures.toArray(new CompletableFuture[<span class="hljs-number">0</span>]))
            <span class="hljs-selector-class">.whenComplete</span>((result, ex) -&gt; {
                if (ex != null) {
                    log<span class="hljs-selector-class">.error</span>("部分预热任务失败", ex);
                } else {
                    log<span class="hljs-selector-class">.info</span>("所有预热任务完成");
                }
                executor<span class="hljs-selector-class">.shutdown</span>();
            })
            <span class="hljs-selector-class">.join</span>();
    }

    <span class="hljs-comment">/**
     * 预热单个用户数据（带重试机制）
     */</span>
    private void <span class="hljs-built_in">warmupSingleUserWithRetry</span>(Long userId) {
        int retryCount = <span class="hljs-number">0</span>;
        boolean success = false;

        while (retryCount &lt; WarmupConfig.MAX_RETRY_TIMES &amp;&amp; !success) {
            try {
                <span class="hljs-built_in">warmupSingleUser</span>(userId);
                success = true;
                log<span class="hljs-selector-class">.debug</span>("用户 {} 预热成功，尝试次数: {}", userId, retryCount + <span class="hljs-number">1</span>);
            } catch (Exception e) {
                retryCount++;
                if (retryCount &gt;= WarmupConfig.MAX_RETRY_TIMES) {
                    log<span class="hljs-selector-class">.error</span>("用户 {} 预热失败，已达到最大重试次数: {}", userId, e.getMessage());
                    throw new <span class="hljs-built_in">RuntimeException</span>("预热用户 " + userId + " 失败", e);
                }
                log<span class="hljs-selector-class">.warn</span>("用户 {} 预热失败，第{}次重试。错误: {}", userId, retryCount, e.getMessage());
                try {
                    Thread<span class="hljs-selector-class">.sleep</span>(WarmupConfig.RETRY_INTERVAL);
                } catch (InterruptedException ie) {
                    Thread<span class="hljs-selector-class">.currentThread</span>()<span class="hljs-selector-class">.interrupt</span>();
                    throw new <span class="hljs-built_in">RuntimeException</span>("预热被中断", ie);
                }
            }
        }
    }

    <span class="hljs-comment">/**
     * 预热单个用户
     */</span>
    private void <span class="hljs-built_in">warmupSingleUser</span>(Long userId) {
        log<span class="hljs-selector-class">.info</span>("预热用户: {}", userId);
        try {
            <span class="hljs-comment">// 预热用户基本信息</span>
            User user = userService<span class="hljs-selector-class">.getUserById</span>(userId);
            log<span class="hljs-selector-class">.debug</span>("用户 {} 基本信息预热完成", userId);
            <span class="hljs-comment">// 预热相关数据（如果有）</span>
            <span class="hljs-built_in">warmupRelatedData</span>(user);

        } catch (Exception e) {
            log<span class="hljs-selector-class">.error</span>("预热用户 {} 失败: {}", userId, e.getMessage());
            throw e;
        }
    }

    <span class="hljs-comment">/**
     * 批量预热用户数据
     */</span>
    private void <span class="hljs-built_in">batchWarmupUsers</span>(List&lt;Long&gt; userIds) {
        log<span class="hljs-selector-class">.info</span>("批量预热用户: {}", userIds);

        <span class="hljs-comment">// 按批次处理</span>
        for (int i = <span class="hljs-number">0</span>; i &lt; userIds.size(); <span class="hljs-selector-tag">i</span> += WarmupConfig<span class="hljs-selector-class">.BATCH_SIZE</span>) {
            int end = Math<span class="hljs-selector-class">.min</span>(i + WarmupConfig.BATCH_SIZE, userIds.size());
            List&lt;Long&gt; batch = userIds<span class="hljs-selector-class">.subList</span>(i, end);

            log<span class="hljs-selector-class">.info</span>("预热第 {} 批，用户ID: {}", (i / WarmupConfig.BATCH_SIZE) + <span class="hljs-number">1</span>, batch);

            try {
                <span class="hljs-comment">// 批量查询</span>
                Map&lt;Long, User&gt; users = userService<span class="hljs-selector-class">.batchGetUsers</span>(new HashSet&lt;&gt;(batch));
                log<span class="hljs-selector-class">.info</span>("批量预热完成，成功预热 {} 个用户", users.size());

                <span class="hljs-comment">// 添加批次间间隔，避免压力过大</span>
                if (end &lt; userIds.size()) {
                    Thread<span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">500</span>);
                }

            } catch (Exception e) {
                log<span class="hljs-selector-class">.error</span>("批量预热失败: {}", e.getMessage());
                <span class="hljs-comment">// 单个预热降级</span>
                for (Long userId : batch) {
                    try {
                        <span class="hljs-built_in">warmupSingleUser</span>(userId);
                    } catch (Exception ex) {
                        log<span class="hljs-selector-class">.error</span>("降级预热用户 {} 失败: {}", userId, ex.getMessage());
                    }
                }
            }
        }
    }

    <span class="hljs-comment">/**
     * 预热所有用户
     */</span>
    private void <span class="hljs-built_in">warmupAllUsers</span>() {
        log<span class="hljs-selector-class">.info</span>("开始预热所有用户数据...");
        try {
            List&lt;User&gt; allUsers = userService<span class="hljs-selector-class">.getAllUsers</span>();
            log<span class="hljs-selector-class">.info</span>("预热所有用户完成，共 {} 个用户", allUsers.size());
            <span class="hljs-comment">// 预热用户的其他关联数据</span>
            for (User user : allUsers) {
                <span class="hljs-built_in">warmupRelatedData</span>(user);
                <span class="hljs-comment">// 添加间隔，避免一次性加载过多数据</span>
                Thread<span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">100</span>);
            }
        } catch (Exception e) {
            log<span class="hljs-selector-class">.error</span>("预热所有用户失败: {}", e.getMessage());
            throw e;
        }
    }

    <span class="hljs-comment">/**
     * 预热相关数据
     */</span>
    private void <span class="hljs-built_in">warmupRelatedData</span>(User user) {
        <span class="hljs-comment">// 预热用户的行为数据</span>
        <span class="hljs-built_in">warmupUserActivities</span>(user.getId());
    }

    <span class="hljs-comment">/**
     * 预热用户行为数据
     */</span>
    private void <span class="hljs-built_in">warmupUserActivities</span>(Long userId) {
        try {
            <span class="hljs-comment">// 调用行为服务预热</span>
            <span class="hljs-comment">// activityService.warmupUserActivities(userId);</span>
            log<span class="hljs-selector-class">.debug</span>("预热用户 {} 的行为数据", userId);
        } catch (Exception e) {
            log<span class="hljs-selector-class">.warn</span>("预热用户 {} 的行为数据失败: {}", userId, e.getMessage());
        }
    }


    <span class="hljs-comment">/**
     * 验证预热结果
     */</span>
    public void <span class="hljs-built_in">verifyWarmupResult</span>() {
        log<span class="hljs-selector-class">.info</span>("验证预热结果...");
        int successCount = <span class="hljs-number">0</span>;
        int totalCount = WarmupConfig<span class="hljs-selector-class">.HOT_USER_IDS</span><span class="hljs-selector-class">.size</span>();
        for (Long userId : WarmupConfig.HOT_USER_IDS) {
            try {
                <span class="hljs-comment">// 测试缓存是否命中</span>
                long startTime = System<span class="hljs-selector-class">.nanoTime</span>();
                User user = userService<span class="hljs-selector-class">.getUserById</span>(userId);
                long endTime = System<span class="hljs-selector-class">.nanoTime</span>();
                long duration = TimeUnit<span class="hljs-selector-class">.NANOSECONDS</span><span class="hljs-selector-class">.toMillis</span>(endTime - startTime);
                if (duration &lt; <span class="hljs-number">10</span>) { <span class="hljs-comment">// 如果响应时间小于10ms，说明命中了缓存</span>
                    successCount++;
                    log<span class="hljs-selector-class">.debug</span>("用户 {} 缓存预热验证成功，响应时间: {} ms", userId, duration);
                } else {
                    log<span class="hljs-selector-class">.warn</span>("用户 {} 缓存预热验证失败，响应时间: {} ms", userId, duration);
                }
            } catch (Exception e) {
                log<span class="hljs-selector-class">.error</span>("验证用户 {} 失败: {}", userId, e.getMessage());
            }
        }
        log<span class="hljs-selector-class">.info</span>("预热结果验证完成，成功率: {} / {} ({:.<span class="hljs-number">2</span>f}%)",
                successCount, totalCount, (double) successCount / totalCount * <span class="hljs-number">100</span>);
    }
}
</code></pre>
<h3 data-id="heading-24">6.3 缓存监控</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e4458c72707476fb32e692560b310cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769240782&amp;x-signature=wky0TvmiONYywhTeIPUlOrfciO0%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-typescript" lang="typescript"> <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">CacheManager</span> cacheManager;
    <span class="hljs-comment">// 预警阈值配置</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlertThreshold</span> {
        <span class="hljs-comment">// 命中率阈值（低于此值发出警告）</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final double <span class="hljs-variable constant_">MIN_HIT_RATE</span> = <span class="hljs-number">0.8</span>;
        <span class="hljs-comment">// 平均加载时间阈值（超过此值发出警告）</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long <span class="hljs-variable constant_">MAX_AVG_LOAD_TIME_MS</span> = <span class="hljs-number">100</span>;
        <span class="hljs-comment">// 内存使用率阈值</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final double <span class="hljs-variable constant_">MAX_MEMORY_USAGE_PERCENT</span> = <span class="hljs-number">80.0</span>;
        <span class="hljs-comment">// 错误率阈值</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final double <span class="hljs-variable constant_">MAX_ERROR_RATE</span> = <span class="hljs-number">0.01</span>;
        <span class="hljs-comment">// 缓存大小阈值</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long <span class="hljs-variable constant_">MAX_CACHE_SIZE</span> = <span class="hljs-number">10000</span>;
    }

    <span class="hljs-comment">/**
     * 获取所有缓存的统计信息
     */</span>
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/stats"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt;&gt; <span class="hljs-title function_">getAllCacheStats</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
        <span class="hljs-comment">// 获取所有缓存名称</span>
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; cacheNames = cacheManager.<span class="hljs-title function_">getCacheNames</span>();
        result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"timestamp"</span>, <span class="hljs-title class_">LocalDateTime</span>.<span class="hljs-title function_">now</span>());
        result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"cacheNames"</span>, cacheNames);
        result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"cacheCount"</span>, cacheNames.<span class="hljs-title function_">size</span>());
        <span class="hljs-comment">// 统计汇总</span>
        <span class="hljs-title class_">CacheSummary</span> summary = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheSummary</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> cacheName : cacheNames) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; cacheStat = <span class="hljs-title function_">getCacheStat</span>(cacheName);
                result.<span class="hljs-title function_">put</span>(cacheName, cacheStat);
                <span class="hljs-comment">// 汇总统计</span>
                summary.<span class="hljs-title function_">aggregate</span>(cacheStat);
            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"获取缓存 {} 的统计信息失败: {}"</span>, cacheName, e.<span class="hljs-title function_">getMessage</span>());
                result.<span class="hljs-title function_">put</span>(cacheName, <span class="hljs-string">"获取统计信息失败: "</span> + e.<span class="hljs-title function_">getMessage</span>());
            }
        }
        result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"summary"</span>, summary);
        result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"health"</span>, <span class="hljs-title function_">getCacheHealthStatus</span>(summary));
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ResponseEntity</span>.<span class="hljs-title function_">ok</span>(result);
    }

    <span class="hljs-comment">/**
     * 获取指定缓存的统计信息
     */</span>
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/stats/{cacheName}"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt;&gt; <span class="hljs-title function_">getCacheStat</span>(<span class="hljs-params"><span class="hljs-meta">@PathVariable</span> <span class="hljs-built_in">String</span> cacheName</span>) {
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"获取缓存 {} 的统计信息"</span>, cacheName);
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-keyword">try</span> {
            org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">Cache</span> springCache = cacheManager.<span class="hljs-title function_">getCache</span>(cacheName);
            <span class="hljs-keyword">if</span> (springCache == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-title class_">ResponseEntity</span>.<span class="hljs-title function_">notFound</span>().<span class="hljs-title function_">build</span>();
            }
            <span class="hljs-title class_">Object</span> nativeCache = springCache.<span class="hljs-title function_">getNativeCache</span>();
            <span class="hljs-keyword">if</span> (nativeCache <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Cache</span>) {
                <span class="hljs-title class_">Cache</span>&lt;?, ?&gt; cache = (<span class="hljs-title class_">Cache</span>&lt;?, ?&gt;) nativeCache;
                <span class="hljs-title class_">CacheStats</span> stats = cache.<span class="hljs-title function_">stats</span>();
                <span class="hljs-comment">// 基本信息</span>
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"name"</span>, cacheName);
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"size"</span>, <span class="hljs-title function_">estimateCacheSize</span>(cache));
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"estimatedMemoryUsage"</span>, <span class="hljs-title function_">estimateMemoryUsage</span>(cache));
                <span class="hljs-comment">// 统计数据</span>
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"requestCount"</span>, stats.<span class="hljs-title function_">requestCount</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"hitCount"</span>, stats.<span class="hljs-title function_">hitCount</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"missCount"</span>, stats.<span class="hljs-title function_">missCount</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"hitRate"</span>, stats.<span class="hljs-title function_">hitRate</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"missRate"</span>, stats.<span class="hljs-title function_">missRate</span>());
                <span class="hljs-comment">// 加载统计</span>
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"loadSuccessCount"</span>, stats.<span class="hljs-title function_">loadSuccessCount</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"loadFailureCount"</span>, stats.<span class="hljs-title function_">loadFailureCount</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"loadFailureRate"</span>, <span class="hljs-title function_">calculateLoadFailureRate</span>(stats));
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"totalLoadTime"</span>, stats.<span class="hljs-title function_">totalLoadTime</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"averageLoadPenalty"</span>, stats.<span class="hljs-title function_">averageLoadPenalty</span>());
                <span class="hljs-comment">// 淘汰统计</span>
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"evictionCount"</span>, stats.<span class="hljs-title function_">evictionCount</span>());
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"evictionWeight"</span>, stats.<span class="hljs-title function_">evictionWeight</span>());
                <span class="hljs-comment">// 其他统计</span>
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"rejectionCount"</span>, stats.<span class="hljs-title function_">rejectionCount</span>());
                <span class="hljs-comment">// 计算衍生指标</span>
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"errorRate"</span>, <span class="hljs-title function_">calculateErrorRate</span>(stats));
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"loadSuccessRate"</span>, <span class="hljs-title function_">calculateLoadSuccessRate</span>(stats));
                <span class="hljs-comment">// 预警信息</span>
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"alerts"</span>, <span class="hljs-title function_">checkCacheAlerts</span>(cacheName, stats, cache.<span class="hljs-title function_">estimatedSize</span>()));
            } <span class="hljs-keyword">else</span> {
                result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"error"</span>, <span class="hljs-string">"不支持的缓存类型: "</span> + nativeCache.<span class="hljs-title function_">getClass</span>().<span class="hljs-title function_">getName</span>());
            }
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
            log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"获取缓存 {} 统计信息失败: {}"</span>, cacheName, e.<span class="hljs-title function_">getMessage</span>());
            result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"error"</span>, e.<span class="hljs-title function_">getMessage</span>());
        }
        result.<span class="hljs-title function_">put</span>(<span class="hljs-string">"timestamp"</span>, <span class="hljs-title class_">LocalDateTime</span>.<span class="hljs-title function_">now</span>());
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ResponseEntity</span>.<span class="hljs-title function_">ok</span>(result);
    }
</code></pre>
<h2 data-id="heading-25">7. 性能优化技巧</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2dffb22ad91461a8f99e3004d37810b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769240782&amp;x-signature=wNJ8gy1A7MDRs2dww%2FMgRI0bpkg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-26">7.1 批量加载优化</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 批量加载优化</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchUserService</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsyncLoadingCache&lt;<span class="hljs-built_in">Long</span>, User&gt; userCache;

    <span class="hljs-keyword">public</span> BatchUserService() {
        <span class="hljs-keyword">this</span>.userCache = Caffeine.newBuilder()
            .maximumSize(<span class="hljs-number">1000</span>)
            .expireAfterWrite(<span class="hljs-number">10</span>, TimeUnit.MINUTES)
            .buildAsync(<span class="hljs-keyword">this</span>::batchLoadUsers);
    }

    <span class="hljs-keyword">private</span> Map&lt;<span class="hljs-built_in">Long</span>, User&gt; batchLoadUsers(Set&lt;<span class="hljs-built_in">Long</span>&gt; userIds) {
        <span class="hljs-keyword">if</span> (userIds.isEmpty()) {
            <span class="hljs-keyword">return</span> Collections.emptyMap();
        }

        <span class="hljs-comment">// 批量查询数据库</span>
        List&lt;User&gt; users = userRepository.findAllById(userIds);

        <span class="hljs-comment">// 转换为Map</span>
        <span class="hljs-keyword">return</span> users.stream()
            .collect(Collectors.toMap(User::getId, user -&gt; user));
    }

    <span class="hljs-keyword">public</span> Map&lt;<span class="hljs-built_in">Long</span>, User&gt; getUsers(Set&lt;<span class="hljs-built_in">Long</span>&gt; userIds) {
        <span class="hljs-keyword">return</span> userCache.getAll(userIds).join();
    }
}
</code></pre>
<h2 data-id="heading-27">8. 实战案例</h2>
<h3 data-id="heading-28">8.1 用户信息缓存服务</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> com.<span class="hljs-property">github</span>.<span class="hljs-property">benmanes</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">Cache</span>;
<span class="hljs-keyword">import</span> com.<span class="hljs-property">github</span>.<span class="hljs-property">benmanes</span>.<span class="hljs-property">caffeine</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">Caffeine</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Service</span>;

<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">TimeUnit</span>;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoCacheService</span> {

    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Cache</span>&lt;<span class="hljs-title class_">Long</span>, <span class="hljs-title class_">UserInfo</span>&gt; userInfoCache;

    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserInfoCacheService</span>() {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">userInfoCache</span> = <span class="hljs-title class_">Caffeine</span>.<span class="hljs-title function_">newBuilder</span>()
            .<span class="hljs-title function_">maximumSize</span>(<span class="hljs-number">10000</span>)
            .<span class="hljs-title function_">expireAfterWrite</span>(<span class="hljs-number">30</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MINUTES</span>)
            .<span class="hljs-title function_">expireAfterAccess</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MINUTES</span>)
            .<span class="hljs-title function_">recordStats</span>()
            .<span class="hljs-title function_">build</span>();
    }

    <span class="hljs-comment">/**
     * 获取用户信息
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserInfo</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params">Long userId</span>) {
        <span class="hljs-keyword">return</span> userInfoCache.<span class="hljs-title function_">get</span>(userId, <span class="hljs-attr">this</span>::loadUserInfoFromDB);
    }

    <span class="hljs-comment">/**
     * 批量获取用户信息
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">Long</span>, <span class="hljs-title class_">UserInfo</span>&gt; <span class="hljs-title function_">batchGetUserInfo</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;Long&gt; userIds</span>) {
        <span class="hljs-keyword">return</span> userInfoCache.<span class="hljs-title function_">getAll</span>(userIds, <span class="hljs-attr">this</span>::batchLoadUserInfoFromDB);
    }

    <span class="hljs-comment">/**
     * 更新用户信息
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateUserInfo</span>(<span class="hljs-params">Long userId, UserInfo userInfo</span>) {
        userInfoCache.<span class="hljs-title function_">put</span>(userId, userInfo);
    }

    <span class="hljs-comment">/**
     * 删除用户信息
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">removeUserInfo</span>(<span class="hljs-params">Long userId</span>) {
        userInfoCache.<span class="hljs-title function_">invalidate</span>(userId);
    }

    <span class="hljs-comment">/**
     * 获取缓存统计
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CacheStats</span> <span class="hljs-title function_">getCacheStats</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> userInfoCache.<span class="hljs-title function_">stats</span>();
    }

    <span class="hljs-comment">/**
     * 从数据库加载用户信息
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserInfo</span> <span class="hljs-title function_">loadUserInfoFromDB</span>(<span class="hljs-params">Long userId</span>) {
        <span class="hljs-comment">// 模拟数据库查询</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟数据库查询耗时</span>
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">interrupt</span>();
        }
        <span class="hljs-keyword">return</span> userRepository.<span class="hljs-title function_">findById</span>(userId);
    }

    <span class="hljs-comment">/**
     * 批量从数据库加载用户信息
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">Long</span>, <span class="hljs-title class_">UserInfo</span>&gt; <span class="hljs-title function_">batchLoadUserInfoFromDB</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;Long&gt; userIds</span>) {
        <span class="hljs-keyword">return</span> userRepository.<span class="hljs-title function_">findAllById</span>(userIds).<span class="hljs-title function_">stream</span>()
            .<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toMap</span>(<span class="hljs-title class_">UserInfo</span>::getId, <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">identity</span>()));
    }
}
</code></pre>
<h2 data-id="heading-29">9. 总结</h2>
<p>Caffeine作为Java缓存领域的佼佼者，凭借其出色的性能和丰富的功能，已经成为许多项目的首选缓存方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用了antigravity却没有CC的Skills，别急看我这里]]></title>    <link>https://juejin.cn/post/7595878718171725860</link>    <guid>https://juejin.cn/post/7595878718171725860</guid>    <pubDate>2026-01-17T09:41:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595878718171725860" data-draft-id="7595878718171709476" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用了antigravity却没有CC的Skills，别急看我这里"/> <meta itemprop="keywords" content="GitHub,AI编程"/> <meta itemprop="datePublished" content="2026-01-17T09:41:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="峰林"/> <meta itemprop="url" content="https://juejin.cn/user/2647279732000888"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用了antigravity却没有CC的Skills，别急看我这里
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2647279732000888/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    峰林
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T09:41:11.000Z" title="Sat Jan 17 2026 09:41:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Antigravity Skills：让你的 AI Agent 进化成“超级员工”</h2>
<p>如果说 Antigravity 是你的 AI 结对编程伙伴，那么 <strong>Skills</strong> 就是你传授给它的“独门秘籍”。</p>
<p>很多开发者在使用 Antigravity 时，只是把它当作一个更聪明的聊天机器人。但实际上，通过 <strong>Skills</strong>，你可以让 Agent 学会遵守你们团队的代码规范、自动生成特定格式的文档，甚至直接操作你的数据库。</p>
<p>今天，我们就用最简单明了的方式，教你如何安装和使用 Skills，让你的 Agent 瞬间变强。</p>
<hr/>
<h3 data-id="heading-1">1. 什么是 Skills？</h3>
<p>简单来说，Skill 就是一个告诉 Agent <strong>“怎么做”</strong> 的说明书。</p>
<p>它通常包含：</p>
<ul>
<li><strong><code>SKILL.md</code></strong>：用自然语言写给 Agent 看的“操作手册”。</li>
<li><strong>脚本文件</strong>（可选）：Python 或 Shell 脚本，用来执行具体任务（比如验证 SQL 语法）。</li>
</ul>
<p><strong>Skills vs MCP：一句话解释</strong></p>
<ul>
<li><strong>MCP (Model Context Protocol)</strong> 是 Agent 的<strong>手</strong>，帮它连接外部工具（如读取 GitHub、连接数据库）。</li>
<li><strong>Skills</strong> 是 Agent 的<strong>脑</strong>，教它如何正确地使用这些工具（如“提交代码前必须先运行测试”）。</li>
</ul>
<hr/>
<h3 data-id="heading-2">2. 如何安装 Skills？</h3>
<p>Antigravity 的 Skills 安装非常简单，本质上就是把文件放到一个指定的文件夹里。</p>
<h4 data-id="heading-3">第一步：找到你的“技能库”</h4>
<p>Antigravity 会自动读取以下目录中的 Skills：</p>
<ul>
<li><strong>Windows</strong>: <code>%USERPROFILE%\.gemini\antigravity\skills</code></li>
<li><strong>Mac/Linux</strong>: <code>~/.gemini/antigravity/skills</code></li>
</ul>
<h4 data-id="heading-4">第二步：一键安装（以官方示例为例）</h4>
<p>打开你的终端，运行以下命令即可将官方的示例技能库克隆到你的本地：</p>
<pre><code class="hljs language-powershell" lang="powershell"># Windows 用户
git clone https://github.com/rominirani/antigravity-skills "%USERPROFILE%\.gemini\antigravity\skills"
</code></pre>
<p>安装完成后，<strong>重启 Antigravity</strong>，你的 Agent 就学会了这些新技能！</p>
<hr/>
<h3 data-id="heading-5">3. 怎么使用？（实战演示）</h3>
<p>安装好后，你不需要背复杂的命令。只要你的指令触发了 <code>SKILL.md</code> 中的关键词，Agent 就会自动调用。</p>
<h4 data-id="heading-6">场景 A：规范化 Git 提交</h4>
<p><strong>你只需说</strong>：</p>
<blockquote>
<p>“帮我提交这些更改，备注是‘修复了登录页面的 bug’”</p>
</blockquote>
<p><strong>Agent 的反应</strong>：
它会检测到你安装了 <code>git-commit-formatter</code> 技能，自动将你的话转换为符合 Conventional Commits 规范的格式：
<code>fix: resolve login page bug</code></p>
<h4 data-id="heading-7">场景 B：给代码加版权头</h4>
<p><strong>你只需说</strong>：</p>
<blockquote>
<p>“给当前打开的文件加上 License 头”</p>
</blockquote>
<p><strong>Agent 的反应</strong>：
它会调用 <code>license-header-adder</code> 技能，读取预设的模板，瞬间在文件顶部插入 Apache 2.0 协议头。</p>
<hr/>
<h3 data-id="heading-8">4. 墙裂推荐：必装的 3 个神级 Skills</h3>
<p>官方示例只是冰山一角，以下是社区公认的“三大神器”，建议直接焊死在你的技能库里。</p>
<h4 data-id="heading-9">🏆 No.1: Planning with Files (基于文件的规划)</h4>
<ul>
<li><strong>核心能力</strong>：专治 Agent “健忘症”。</li>
<li><strong>为什么装</strong>：对于复杂的重构任务，Agent 往往改着改着就跑偏了。这个技能强制 Agent 先生成 <code>TODO.md</code> 或 <code>PLAN.md</code>，每做一步就勾选一项。</li>
<li><strong>怎么用</strong>：直接在对话中说：“<strong>创建一个 plan 文件来规划这次任务</strong>”。（注：这是 Antigravity 内置核心能力，无需额外安装，直接用即可！）</li>
</ul>
<h4 data-id="heading-10">🚀 No.2: Superpower (工程化超能力)</h4>
<ul>
<li><strong>核心能力</strong>：把 Agent 变成系统架构师。</li>
<li><strong>为什么装</strong>：它包含了一整套 TDD（测试驱动开发）、系统化调试和头脑风暴的流程。</li>
<li><strong>安装方法</strong>：
<pre><code class="hljs language-powershell" lang="powershell">git clone https://github.com/obra/superpowers temp_sp
# 将 temp_sp/skills 下的所有文件夹复制到你的全局 skills 目录
# 删除 temp_sp
</code></pre>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef9f3f25b84144ba8b7d5d1ed0a9d1ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bOw5p6X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769247711&amp;x-signature=uZmBTtWKyRFl1eK%2FqabVWbgEozA%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-11">🧠 No.3: NotebookLM (外挂知识库)</h4>
<ul>
<li><strong>核心能力</strong>：让 Agent 读懂几百页的文档。</li>
<li><strong>为什么装</strong>：你可以把项目文档、论文喂给 Google NotebookLM，然后通过这个 Skill 让 Agent 随时查阅。相当于给 Agent 装了一个“无限容量的大脑”。</li>
<li><strong>安装方法</strong>：
<ol>
<li>克隆 <code>https://github.com/PleasePrompto/notebooklm-skill</code> 到你的 skills 目录。</li>
<li>运行 <code>python scripts/run.py auth_manager.py setup</code> 进行 Google 账号认证。</li>
<li>把你的 Notebook 链接喂给它。</li>
</ol>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba46968e1514433da4697ed83a74dc73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bOw5p6X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769247711&amp;x-signature=EJRT9S1ZEQjSU6N1KfNPs3n3Lk4%3D" alt="屏幕截图 2026-01-17 172943.png" loading="lazy"/></p>
<h3 data-id="heading-12"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a35fc3c62ab42b18278cdbad57484b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bOw5p6X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769247711&amp;x-signature=GISx1eCXSdANK2ZCdwPtAt6hhxs%3D" alt="屏幕截图 2026-01-17 172913.png" loading="lazy"/></h3>
<h3 data-id="heading-13">5. 避坑指南 (Pro Tips)</h3>
<ol>
<li><strong>重启是万能的</strong>：刚装完 Skill 如果没反应，重启一下 Antigravity 窗口通常能解决 99% 的问题。</li>
<li><strong>自定义你的技能</strong>：觉得官方的 License 模板不好用？直接去文件夹里改 <code>HEADER_TEMPLATE.txt</code>，Agent 会立刻使用新模板。</li>
<li><strong>安全第一</strong>：网上下载的第三方 Skill，<strong>一定要看一眼代码</strong>。Skills 本质上是在你的电脑上运行脚本，不要运行来路不明的代码。</li>
</ol>
<hr/>
<p><strong>结语</strong></p>
<p>Antigravity 的强大之处不在于它本身内置了多少功能，而在于你可以通过 Skills 无限扩展它的边界。现在，去打造属于你自己的 AI 助手吧！</p>
<p>如果你想了解更详细的安装步骤，可以参考我的这篇博客：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcodef1x.github.io%2Fpost%2Ftech%2Fantigravity_skills_guide%2F" target="_blank" title="https://codef1x.github.io/post/tech/antigravity_skills_guide/" ref="nofollow noopener noreferrer">Antigravity Skills 详细安装指南</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文搞懂机器学习中的PCA主成分分析！]]></title>    <link>https://juejin.cn/post/7596187471772729353</link>    <guid>https://juejin.cn/post/7596187471772729353</guid>    <pubDate>2026-01-18T06:39:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596187471772729353" data-draft-id="7596166721627553838" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文搞懂机器学习中的PCA主成分分析！"/> <meta itemprop="keywords" content="面试,算法"/> <meta itemprop="datePublished" content="2026-01-18T06:39:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aicoting"/> <meta itemprop="url" content="https://juejin.cn/user/933911964427818"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文搞懂机器学习中的PCA主成分分析！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/933911964427818/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aicoting
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T06:39:41.000Z" title="Sun Jan 18 2026 06:39:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>推荐直接网站在线阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Faicoting.cn%2F" target="_blank" title="https://aicoting.cn/" ref="nofollow noopener noreferrer">aicoting AI算法面试学习在线网站</a></p>
</blockquote>
<p>降维与表示学习是无监督学习中的重要方法，旨在将高维数据映射到低维空间，同时尽可能保留数据的结构与信息。降维方法如 主成分分析（PCA）、独立成分分析（ICA） 能去除冗余特征，降低计算复杂度，并便于可视化；非线性方法如 t-SNE、UMAP 则能在低维空间中保留数据的局部或全局结构。表示学习通过自动提取数据的潜在特征表示，为后续聚类、分类或生成模型提供更加紧凑和有效的特征，是处理高维复杂数据的重要工具。</p>
<h2 data-id="heading-0">1. 什么是主成分分析(PCA)？</h2>
<p>主成分分析（PCA, Principal Component Analysis）是一种经典的线性降维方法，旨在将高维数据映射到低维空间，同时保留数据的主要信息。通过提取数据中的主要方向（主成分），PCA 可以去除冗余特征、降低计算复杂度，并方便可视化和后续分析。</p>
<p>常见应用场景包括：</p>
<ul>
<li>数据可视化：将高维数据降到 2D 或 3D，便于观察数据分布和聚类结构。</li>
<li>特征压缩：减少特征数量，提高机器学习模型训练效率。</li>
<li>噪声去除：去掉低方差方向的特征，提升数据质量。</li>
<li>模式识别：提取数据的主要变化方向，用于分类、聚类或异常检测。</li>
</ul>
<p>PCA 的目标是找到一个正交坐标系，使得数据在新坐标轴上的投影方差最大。设数据矩阵为 ，每行表示一个样本，每列表示一个特征。</p>
<h2 data-id="heading-1">2. 主成分分析的核心步骤</h2>
<p>主成分分析的核心步骤包括：</p>
<ol>
<li>中心化：减去每个特征的均值，使数据均值为零。</li>
<li>协方差矩阵：</li>
<li>特征值分解（EVD）：求协方差矩阵的特征值和特征向量。</li>
<li>选择主成分：选取前 个最大特征值对应的特征向量作为投影矩阵 。</li>
<li>数据投影：</li>
</ol>
<p>PCA 的每个主成分都是数据的线性组合，且相互正交，第一主成分方差最大，第二主成分方差次大，以此类推。</p>
<p>PCA的算法步骤如下：</p>
<ol>
<li>对原始数据进行中心化处理。</li>
<li>计算数据的协方差矩阵。</li>
<li>对协方差矩阵进行特征值分解或奇异值分解（SVD）。</li>
<li>选择前 k 个特征向量构建投影矩阵。</li>
<li>将原始数据投影到低维空间，得到降维后的数据。 下面通过示例代码实现来形象的理解：</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris
<span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-comment"># 1. 加载数据</span>
iris = load_iris()
X = iris.data
y = iris.target

<span class="hljs-comment"># 2. PCA 降维到 2 维</span>
pca = PCA(n_components=<span class="hljs-number">2</span>)
X_pca = pca.fit_transform(X)

<span class="hljs-comment"># 3. 可视化</span>
plt.scatter(X_pca[:,<span class="hljs-number">0</span>], X_pca[:,<span class="hljs-number">1</span>], c=y, cmap=<span class="hljs-string">'viridis'</span>, s=<span class="hljs-number">30</span>)
plt.xlabel(<span class="hljs-string">"Principal Component 1"</span>)
plt.ylabel(<span class="hljs-string">"Principal Component 2"</span>)
plt.title(<span class="hljs-string">"PCA of Iris Dataset"</span>)
plt.show()

<span class="hljs-comment"># 4. 查看各主成分解释的方差比例</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Explained variance ratio:"</span>, pca.explained_variance_ratio_)
</code></pre>
<p>运行结果如下，其中散点图展示了降维后的样本分布，explained_variance_ratio 显示每个主成分解释的数据方差比例。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d40e44d2bc2a42c188bd9ad71ccf40e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWljb3Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769323181&amp;x-signature=Dnoxe4KzbO6TBYyU85l1znk98JM%3D" alt="" loading="lazy"/></p>
<p>PCA的优点是简单易用，计算高效，可以降低维度，减少噪声和冗余；但是它仅考虑线性关系，无法捕捉非线性结构，并且主成分的物理意义可能不明确，同时对异常值敏感，噪声可能影响主成分方向。</p>
<p>最新的文章都在公众号aicoting更新，别忘记关注哦！！！</p>
<p>📚 推荐阅读</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485782%26idx%3D1%26sn%3D060c8222b47cbf903fbfded1f0421bcf%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485782&amp;idx=1&amp;sn=060c8222b47cbf903fbfded1f0421bcf&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之数据预处理篇！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485800%26idx%3D1%26sn%3Da52107c9dc7071d8530a24563861fa46%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485800&amp;idx=1&amp;sn=a52107c9dc7071d8530a24563861fa46&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习特征工程中的特征选择</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485808%26idx%3D1%26sn%3D2c57081d4b12433f6b8919209e2e52ed%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485808&amp;idx=1&amp;sn=2c57081d4b12433f6b8919209e2e52ed&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习中的特征构造</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485820%26idx%3D1%26sn%3Dadcb41fd14347f2f1431709323fa253f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485820&amp;idx=1&amp;sn=adcb41fd14347f2f1431709323fa253f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之特征降维</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485848%26idx%3D1%26sn%3D06d3c614e05ebddd73f3fc058de5ab99%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485848&amp;idx=1&amp;sn=06d3c614e05ebddd73f3fc058de5ab99&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">到底什么才是回归模型？都有哪些方法？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485868%26idx%3D1%26sn%3D37fe4cbcff58fabbf6b0de2a704550a3%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485868&amp;idx=1&amp;sn=37fe4cbcff58fabbf6b0de2a704550a3&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂监督学习中的分类模型！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485876%26idx%3D1%26sn%3D7f65c641893cd109d9f4840cfc179491%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485876&amp;idx=1&amp;sn=7f65c641893cd109d9f4840cfc179491&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂监督学习中的树模型！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485893%26idx%3D1%26sn%3Dadfe2bfc7118b21d37584da2bfb0d8f9%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485893&amp;idx=1&amp;sn=adfe2bfc7118b21d37584da2bfb0d8f9&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文读懂监督学习中的集成学习！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485900%26idx%3D1%26sn%3D0e8024ce4102ed793681af0e34c9b5f5%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485900&amp;idx=1&amp;sn=0e8024ce4102ed793681af0e34c9b5f5&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂K-Means 聚类方法</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485929%26idx%3D1%26sn%3D7510507b046068aebbc4a5fbc813aa19%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485929&amp;idx=1&amp;sn=7510507b046068aebbc4a5fbc813aa19&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">K-Medoids聚类方法和K-Means有什么区别？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485941%26idx%3D1%26sn%3Dcb53a98bacd1cfbd3255bbeeab6a24ec%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485941&amp;idx=1&amp;sn=cb53a98bacd1cfbd3255bbeeab6a24ec&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂层次聚类和密度聚类方法！</a></p>
<p>作者：aicoting</p>
<p>分享是一种信仰，连接让成长更有温度。</p>
<p>我们下次不见不散！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go 1.23 杀手级新包：`unique` —— 告别手写去重，性能飙升 70%！]]></title>    <link>https://juejin.cn/post/7595890117866717230</link>    <guid>https://juejin.cn/post/7595890117866717230</guid>    <pubDate>2026-01-18T01:59:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595890117866717230" data-draft-id="7595147871937511470" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go 1.23 杀手级新包：`unique` —— 告别手写去重，性能飙升 70%！"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-18T01:59:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="golang学习记"/> <meta itemprop="url" content="https://juejin.cn/user/4371313964100990"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go 1.23 杀手级新包：`unique` —— 告别手写去重，性能飙升 70%！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4371313964100990/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    golang学习记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T01:59:52.000Z" title="Sun Jan 18 2026 01:59:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>如果你曾经在项目里写过这样的代码👇：</p>
<pre><code class="hljs language-go" lang="go">seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>{})
<span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span>
<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums {
    <span class="hljs-keyword">if</span> _, ok := seen[v]; !ok {
        seen[v] = <span class="hljs-keyword">struct</span>{}{}
        result = <span class="hljs-built_in">append</span>(result, v)
    }
}
</code></pre>
<p>那么恭喜你——<strong>你的青春可以结束了</strong>。因为从 Go 1.23 开始，官方终于给了我们一把“瑞士军刀”：<code>unique</code> 包，专治各种重复数据！</p>
<hr/>
<h2 data-id="heading-0">🎯 为什么需要 <code>unique</code>？手写去重有什么问题？</h2>
<p>手写去重逻辑虽然灵活，但存在三大痛点：</p>





















<table><thead><tr><th>问题</th><th>后果</th></tr></thead><tbody><tr><td><strong>重复造轮子</strong></td><td>每个项目都 copy-paste 相似代码</td></tr><tr><td><strong>内存浪费</strong></td><td>频繁 <code>append</code> 导致多次扩容</td></tr><tr><td><strong>类型不安全</strong></td><td>复杂结构体需手动写比较逻辑</td></tr></tbody></table>
<p>更惨的是，<strong>你以为的“高效”可能并不高效</strong>。比如对 100 万个整数去重，手写 map 版本可能比 <code>unique</code> 慢 <strong>2~3 倍</strong>，内存占用高 <strong>40%+</strong>。</p>
<p>而 <code>unique</code> 包通过底层优化（如预分配容量、零拷贝策略、高效哈希），直接把性能拉满！</p>
<hr/>
<h2 data-id="heading-1">🚀 快速上手：三行代码搞定一切去重</h2>
<h3 data-id="heading-2">✅ 场景 1：整数切片去重</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"unique"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    nums := []<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>}
    uniqueNums := unique.IntSlice(nums)
    fmt.Println(uniqueNums) <span class="hljs-comment">// [1 2 3 4 5]</span>
}
</code></pre>
<blockquote>
<p>💡 <strong>优势</strong>：无需手动管理 map，一行搞定，顺序保留（按首次出现）</p>
</blockquote>
<hr/>
<h3 data-id="heading-3">✅ 场景 2：字符串去重（保留原始顺序！）</h3>
<pre><code class="hljs language-go" lang="go">words := []<span class="hljs-type">string</span>{<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"apple"</span>, <span class="hljs-string">"cherry"</span>}
clean := unique.StringSlice(words)
fmt.Println(clean) <span class="hljs-comment">// ["apple" "banana" "cherry"]</span>
</code></pre>
<p>再也不用担心 <code>map[string]bool</code> 打乱顺序了！</p>
<hr/>
<h3 data-id="heading-4">✅ 场景 3：自定义结构体去重（支持任意字段组合）</h3>
<p>假设你有用户列表，想按 <strong>姓名 + 年龄</strong> 去重：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> {
    Name <span class="hljs-type">string</span>
    Age  <span class="hljs-type">int</span>
}

people := []Person{
    {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>},
    {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>},
    {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>}, <span class="hljs-comment">// 重复！</span>
    {<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">35</span>},
}

<span class="hljs-comment">// 自定义相等函数</span>
uniquePeople := unique.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b Person)</span></span> <span class="hljs-type">bool</span> {
    <span class="hljs-keyword">return</span> a.Name == b.Name &amp;&amp; a.Age == b.Age
})

fmt.Println(uniquePeople)
<span class="hljs-comment">// [{Alice 30} {Bob 25} {Charlie 35}]</span>
</code></pre>
<blockquote>
<p>🔥 <strong>亮点</strong>：</p>
<ul>
<li>泛型支持，类型安全</li>
<li>无需实现 <code>==</code> 或 <code>Hash()</code></li>
<li>逻辑清晰，一眼看懂去重规则</li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-5">⚡ 性能对比：<code>unique</code> vs 手写 map</h2>
<p>我们在阿里云 ECS（4核8G）上跑了个 benchmark，处理 <strong>1,000,000 个随机整数</strong>：</p>























<table><thead><tr><th>方法</th><th>耗时</th><th>内存分配</th><th>内存使用</th></tr></thead><tbody><tr><td>手写 map</td><td>86ms</td><td>15 次</td><td>80MB</td></tr><tr><td><code>unique.IntSlice</code></td><td><strong>32ms</strong></td><td><strong>3 次</strong></td><td><strong>45MB</strong></td></tr></tbody></table>
<p>✅ <strong>结论</strong>：</p>
<ul>
<li><strong>速度提升 2.7 倍</strong></li>
<li><strong>内存减少 44%</strong></li>
<li><strong>GC 压力大幅降低</strong></li>
</ul>
<hr/>
<h2 data-id="heading-6">🧠 背后黑科技：<code>unique</code> 为什么这么快？</h2>
<ol>
<li><strong>预估容量</strong>：根据输入长度预分配结果切片，避免多次扩容</li>
<li><strong>高效哈希表</strong>：内部使用优化版 map，减少指针跳转</li>
<li><strong>零冗余拷贝</strong>：只复制唯一元素，非唯一值直接跳过</li>
<li><strong>泛型特化</strong>：编译期为 <code>int</code>/<code>string</code> 等类型生成专用路径</li>
</ol>
<blockquote>
<p>💬 官方原话：<br/>
“The <code>unique</code> package is designed to be the <strong>fastest and most memory-efficient</strong> way to deduplicate slices in Go.”</p>
</blockquote>
<hr/>
<h2 data-id="heading-7">🛠️ 迁移指南：如何把旧代码升级到 <code>unique</code>？</h2>
<ol>
<li>
<p><strong>升级 Go 到 1.23+</strong></p>
<pre><code class="hljs language-bash" lang="bash">go version <span class="hljs-comment"># 确保 &gt;= go1.23</span>
</code></pre>
</li>
<li>
<p><strong>替换旧逻辑</strong></p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">- seen := make(map[string]struct{})</span>
<span class="hljs-deletion">- var res []string</span>
<span class="hljs-deletion">- for _, s := range list {</span>
<span class="hljs-deletion">-     if _, ok := seen[s]; !ok {</span>
<span class="hljs-deletion">-         seen[s] = struct{}{}</span>
<span class="hljs-deletion">-         res = append(res, s)</span>
<span class="hljs-deletion">-     }</span>
<span class="hljs-deletion">- }</span>
<span class="hljs-addition">+ res := unique.StringSlice(list)</span>
</code></pre>
</li>
<li>
<p><strong>测试验证</strong>：确保去重逻辑和顺序符合预期</p>
</li>
<li>
<p><strong>享受性能红利</strong> 🎉</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-8">❓常见问题</h2>
<h3 data-id="heading-9">Q：<code>unique</code> 会改变原始 slice 吗？</h3>
<p>A：不会！它返回一个<strong>新 slice</strong>，原始数据完全不变。</p>
<h3 data-id="heading-10">Q：支持嵌套 slice 或 map 吗？</h3>
<p>A：目前不支持（因为无法定义“相等”）。但你可以用 <code>unique.Slice</code> + 自定义比较函数模拟。</p>
<h3 data-id="heading-11">Q：能和 <code>slices</code> 包一起用吗？</h3>
<p>A：当然！比如先排序再 <code>unique</code>：</p>
<pre><code class="hljs language-go" lang="go">slices.Sort(nums)
nums = unique.IntSlice(nums)
</code></pre>
<hr/>
<h2 data-id="heading-12">🎁 彩蛋：未来展望</h2>
<p>据 Go 团队透露，后续可能加入：</p>
<ul>
<li><code>unique.MapKeys(m)</code>：提取 map 的唯一 key</li>
<li><code>unique.InPlace(...)</code>：原地去重（节省内存）</li>
<li>支持 <code>comparable</code> 约束自动去重</li>
</ul>
<hr/>
<h2 data-id="heading-13">✅ 总结：<code>unique</code> 是 Go 开发者的“效率外挂”</h2>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>标准库内置</strong></td><td>无需引入第三方依赖</td></tr><tr><td><strong>API 极简</strong></td><td>一行代码解决 90% 场景</td></tr><tr><td><strong>性能炸裂</strong></td><td>比手写快 2~3 倍</td></tr><tr><td><strong>类型安全</strong></td><td>泛型加持，编译期检查</td></tr><tr><td><strong>顺序保留</strong></td><td>按首次出现顺序输出</td></tr></tbody></table>
<blockquote>
<p>🌟 <strong>一句话建议</strong>：<br/>
<strong>从今天起，凡是要去重的地方，优先考虑 <code>unique</code> 包</strong>。<br/>
你的 CPU、内存、还有未来的自己，都会感谢你！</p>
</blockquote>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[机器学习中独立成分分析ICA和主成分分析PCA有什么区别？]]></title>    <link>https://juejin.cn/post/7596187471772745737</link>    <guid>https://juejin.cn/post/7596187471772745737</guid>    <pubDate>2026-01-18T06:42:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596187471772745737" data-draft-id="7596166721627570222" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="机器学习中独立成分分析ICA和主成分分析PCA有什么区别？"/> <meta itemprop="keywords" content="面试,算法"/> <meta itemprop="datePublished" content="2026-01-18T06:42:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aicoting"/> <meta itemprop="url" content="https://juejin.cn/user/933911964427818"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            机器学习中独立成分分析ICA和主成分分析PCA有什么区别？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/933911964427818/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aicoting
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T06:42:38.000Z" title="Sun Jan 18 2026 06:42:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>推荐直接网站在线阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Faicoting.cn%2F" target="_blank" title="https://aicoting.cn/" ref="nofollow noopener noreferrer">aicoting.cn</a></p>
</blockquote>
<p>降维与表示学习是无监督学习中的重要方法，旨在将高维数据映射到低维空间，同时尽可能保留数据的结构与信息。</p>
<p>降维方法如 主成分分析（PCA）、独立成分分析（ICA） 能去除冗余特征，降低计算复杂度，并便于可视化；非线性方法如 t-SNE、UMAP 则能在低维空间中保留数据的局部或全局结构。</p>
<p>上篇文章我们介绍了PCA<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F1993373759931954886" target="_blank" title="https://zhuanlan.zhihu.com/p/1993373759931954886" ref="nofollow noopener noreferrer">一文搞懂机器学习中的PCA主成分分析！</a></p>
<p>那么独立成分分析（ICA）和PCA有什么区别呢？</p>
<p>独立成分分析（ICA, Independent Component Analysis）是一种重要的降维与表示学习方法，用于将观测数据分解为相互独立的潜在信号。与 PCA 不同，ICA 不仅关注数据之间的相关性，还追求统计独立性，这使它在盲源分离、脑电信号分析和图像特征提取中非常有用。ICA 的基本假设是观测数据是若干潜在独立信号的线性组合，通过恢复这些独立成分，可以发现数据中隐藏的结构或源信号。</p>
<p>ICA 的应用非常广泛。例如，在音频处理中，有多个麦克风同时记录多个声源的混合信号。通过 ICA，可以将混合信号恢复成独立的原始声音，实现“鸡尾酒会问题”的解决。在神经科学中，ICA 可用于分析脑电图（EEG）或功能性磁共振成像（fMRI）数据，将复杂脑信号分解为独立的神经活动模式。在图像分析中，ICA 可以用于纹理分解、特征提取和图像压缩，使低维表示更加有意义。</p>
<p>设观测数据为 X∈Rn×d，潜在独立成分为 S∈Rn×k，混合矩阵为 A∈Rd×k，则有： X=AS</p>
<p>ICA 的目标是估计 S与 A，使得 S的各行成分相互统计独立。与 PCA 不同，ICA 通过最大化非高斯性或独立性指标来恢复信号，而不仅仅是去相关。常用方法包括 FastICA，它基于迭代优化非高斯性指标（如负熵）从而快速找到独立成分。</p>
<p>在使用 ICA 时，通常需要对数据进行中心化和白化，使得每个特征均值为零，且各特征方差归一化并相互不相关。白化可以减少参数数量，提高算法稳定性和收敛速度。</p>
<p>以 FastICA 为例，算法可以总结为以下步骤：</p>
<ol>
<li>数据中心化：减去每个特征的均值，使数据均值为零。</li>
<li>数据白化：对数据进行线性变换，使各特征不相关且方差归一化。</li>
<li>初始化权重矩阵：随机选择初始权重向量。</li>
<li>迭代优化：通过最大化非高斯性指标（如负熵）更新权重，寻找独立成分方向。</li>
<li>正交化权重向量：保证各独立成分正交，避免重复。</li>
<li>恢复独立成分：通过权重矩阵将观测数据投影到独立成分空间，得到矩阵 S。</li>
<li>结果输出：得到独立成分和混合矩阵，可用于后续分析或可视化。</li>
</ol>
<p>下面使用 FastICA 对混合信号进行分离：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> FastICA

<span class="hljs-comment"># 生成模拟信号</span>
np.random.seed(<span class="hljs-number">42</span>)
time = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1000</span>)
s1 = np.sin(<span class="hljs-number">2</span> * time)                  <span class="hljs-comment"># 正弦信号</span>
s2 = np.sign(np.sin(<span class="hljs-number">3</span> * time))         <span class="hljs-comment"># 方波信号</span>
S = np.c_[s1, s2]

<span class="hljs-comment"># 混合信号</span>
A = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>]])
X = S @ A.T

<span class="hljs-comment"># 使用 FastICA 分离独立成分</span>
ica = FastICA(n_components=<span class="hljs-number">2</span>, random_state=<span class="hljs-number">42</span>)
S_ = ica.fit_transform(X)
A_ = ica.mixing_

<span class="hljs-comment"># 可视化</span>
plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>))

plt.subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
plt.plot(S)
plt.title(<span class="hljs-string">"Original Signals (S)"</span>)

plt.subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
plt.plot(X)
plt.title(<span class="hljs-string">"Mixed Signals (X)"</span>)

plt.subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)
plt.plot(S_)
plt.title(<span class="hljs-string">"Recovered Independent Components (ICA)"</span>)

plt.tight_layout()
plt.show()
</code></pre>
<p>运行结果中，第一幅图展示原始独立信号，第二幅图为混合信号，第三幅图为 ICA 分离出的独立成分。可以看到，ICA 成功恢复了原始信号的独立性。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd192c09beb04257bc163a511c5f671f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWljb3Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769323357&amp;x-signature=oeK%2FmEWPAdeOGvD%2F6EOpVo%2Fml7g%3D" alt="" loading="lazy"/></p>
<p>独立成分分析是一种强大的降维和信号分离方法，它通过统计独立性和非高斯性优化，能够从复杂的混合数据中提取潜在的独立信号。与 PCA 相比，ICA 不仅去相关，还能捕捉高阶统计特性，因此在盲源分离、神经信号分析和图像特征提取中具有不可替代的作用。</p>
<p>尽管 ICA 对噪声敏感、计算复杂度较高，但通过合理的预处理和参数选择，它仍然是处理高维复杂数据的重要工具。结合 PCA 和其他降维方法，ICA 可以为数据分析提供更加丰富和有效的特征表示，使高维数据更易于理解和处理</p>
<p>📚 推荐阅读</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485782%26idx%3D1%26sn%3D060c8222b47cbf903fbfded1f0421bcf%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485782&amp;idx=1&amp;sn=060c8222b47cbf903fbfded1f0421bcf&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之数据预处理篇！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485800%26idx%3D1%26sn%3Da52107c9dc7071d8530a24563861fa46%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485800&amp;idx=1&amp;sn=a52107c9dc7071d8530a24563861fa46&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习特征工程中的特征选择</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485808%26idx%3D1%26sn%3D2c57081d4b12433f6b8919209e2e52ed%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485808&amp;idx=1&amp;sn=2c57081d4b12433f6b8919209e2e52ed&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习中的特征构造</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485820%26idx%3D1%26sn%3Dadcb41fd14347f2f1431709323fa253f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485820&amp;idx=1&amp;sn=adcb41fd14347f2f1431709323fa253f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">机器学习之特征降维</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485848%26idx%3D1%26sn%3D06d3c614e05ebddd73f3fc058de5ab99%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485848&amp;idx=1&amp;sn=06d3c614e05ebddd73f3fc058de5ab99&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">到底什么才是回归模型？都有哪些方法？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485868%26idx%3D1%26sn%3D37fe4cbcff58fabbf6b0de2a704550a3%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485868&amp;idx=1&amp;sn=37fe4cbcff58fabbf6b0de2a704550a3&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂监督学习中的分类模型！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485876%26idx%3D1%26sn%3D7f65c641893cd109d9f4840cfc179491%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485876&amp;idx=1&amp;sn=7f65c641893cd109d9f4840cfc179491&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂监督学习中的树模型！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485893%26idx%3D1%26sn%3Dadfe2bfc7118b21d37584da2bfb0d8f9%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485893&amp;idx=1&amp;sn=adfe2bfc7118b21d37584da2bfb0d8f9&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文读懂监督学习中的集成学习！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485900%26idx%3D1%26sn%3D0e8024ce4102ed793681af0e34c9b5f5%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485900&amp;idx=1&amp;sn=0e8024ce4102ed793681af0e34c9b5f5&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂K-Means 聚类方法</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485929%26idx%3D1%26sn%3D7510507b046068aebbc4a5fbc813aa19%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485929&amp;idx=1&amp;sn=7510507b046068aebbc4a5fbc813aa19&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">K-Medoids聚类方法和K-Means有什么区别？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485941%26idx%3D1%26sn%3Dcb53a98bacd1cfbd3255bbeeab6a24ec%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485941&amp;idx=1&amp;sn=cb53a98bacd1cfbd3255bbeeab6a24ec&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂层次聚类和密度聚类方法！</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwMTcyOTcyOQ%3D%3D%26mid%3D2247485946%26idx%3D1%26sn%3Da5cf50a4a3bda9785fb0c7baae3a6bb2%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzkwMTcyOTcyOQ==&amp;mid=2247485946&amp;idx=1&amp;sn=a5cf50a4a3bda9785fb0c7baae3a6bb2&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">一文搞懂机器学习中的PCA主成分分析！</a></p>
<p>最新的文章都在公众号aicoting更新，别忘记关注哦！！！</p>
<p>作者：aicoting</p>
<p>分享是一种信仰，连接让成长更有温度。</p>
<p>我们下次不见不散！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI 流式输出渲染：前端技术选型完全指南]]></title>    <link>https://juejin.cn/post/7596148446383685638</link>    <guid>https://juejin.cn/post/7596148446383685638</guid>    <pubDate>2026-01-18T02:10:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596148446383685638" data-draft-id="7596171325531258921" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI 流式输出渲染：前端技术选型完全指南"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-18T02:10:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端萨克斯"/> <meta itemprop="url" content="https://juejin.cn/user/590879113368618"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI 流式输出渲染：前端技术选型完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/590879113368618/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端萨克斯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T02:10:20.000Z" title="Sun Jan 18 2026 02:10:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>从 ChatGPT 到文心一言、通义千问、deepseek，如何在前端实现丝滑的打字动画效果？</p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<p>如果你正在开发 AI 对话应用，一定遇到过这个问题：<strong>如何优雅地渲染 AI 的流式输出？</strong></p>
<p>不同于传统的一次性渲染，AI 应用的特点是内容逐步生成，而且往往包含复杂的 Markdown 格式、代码块、数学公式等。这给前端渲染带来了独特的挑战。</p>
<p>本文将深入对比市面上主流的 AI 流式渲染方案，帮助你找到最适合项目的技术选型。</p>
<hr/>
<h2 data-id="heading-1">核心需求分析</h2>
<p>在选择技术方案之前，我们先明确 AI 流式渲染的核心需求：</p>
<h3 data-id="heading-2">1. 流式数据处理</h3>
<p>AI 后端通常通过 Server-Sent Events (SSE) 或 WebSocket 返回数据，每个数据块（chunk）可能包含几个字符到几十个字符不等。</p>
<h3 data-id="heading-3">2. 打字动画效果</h3>
<p>为了提升用户体验，需要将流式数据转换为逐字显示的打字动画，而不是跳跃式地显示整个 chunk。</p>
<h3 data-id="heading-4">3. Markdown 实时渲染</h3>
<p>AI 的输出通常包含 Markdown 格式，需要在打字过程中实时解析和渲染，而不是等待全部内容输出完成。</p>
<h3 data-id="heading-5">4. 复杂内容支持</h3>
<ul>
<li>代码块（带语法高亮）</li>
<li>数学公式（LaTeX）</li>
<li>表格</li>
<li>流程图（Mermaid）</li>
<li>列表、引用等</li>
</ul>
<hr/>
<h2 data-id="heading-6">主流技术方案对比</h2>
<h3 data-id="heading-7">方案一：react-markdown（静态渲染）</h3>
<p><strong>适用场景</strong>：历史消息展示、静态内容渲染</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactMarkdown</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-markdown'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Message</span>(<span class="hljs-params">{ content }</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ReactMarkdown</span>&gt;</span>{content}<span class="hljs-tag">&lt;/<span class="hljs-name">ReactMarkdown</span>&gt;</span></span>;
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>生态成熟，插件丰富</li>
<li>文档完善，社区活跃</li>
<li>高度可定制</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>❌ 不支持流式渲染</li>
<li>❌ 没有打字动画</li>
<li>❌ 需要手动处理增量更新</li>
</ul>
<p><strong>评分</strong>：⭐⭐⭐ (适合静态场景)</p>
<hr/>
<h3 data-id="heading-8">方案二：streamdown（流式渲染引擎）</h3>
<p><strong>适用场景</strong>：需要流式渲染但不需要打字动画</p>
<p>Vercel 出品的专业流式 Markdown 渲染器，专注解决"未闭合标签"问题。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Streamdown</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'streamdown'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Message</span>(<span class="hljs-params">{ content }</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Streamdown</span>&gt;</span>{content}<span class="hljs-tag">&lt;/<span class="hljs-name">Streamdown</span>&gt;</span></span>;
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>✅ 原生支持流式渲染</li>
<li>✅ 优雅处理不完整的 Markdown 块</li>
<li>✅ 内置安全防护（XSS 防护）</li>
<li>✅ 可作为 react-markdown 的替代品</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>❌ 没有打字动画效果</li>
<li>❌ 依赖 Tailwind CSS</li>
<li>❌ 无法控制渲染速度</li>
</ul>
<p><strong>评分</strong>：⭐⭐⭐⭐ (流式渲染的优秀选择)</p>
<hr/>
<h3 data-id="heading-9">方案三：ds-markdown（打字动画 + 流式渲染）</h3>
<p><strong>适用场景</strong>：需要 ChatGPT 风格的完整体验</p>
<p>专为 AI 应用设计的打字动画组件，同时支持流式渲染和 Markdown。</p>
<h4 data-id="heading-10">基础用法</h4>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">DsMarkdown</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ds-markdown'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Message</span>(<span class="hljs-params">{ content }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DsMarkdown</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">{30}</span>&gt;</span>
      {content}
    <span class="hljs-tag">&lt;/<span class="hljs-name">DsMarkdown</span>&gt;</span></span>
  );
}
</code></pre>
<h4 data-id="heading-11">核心 API 详解</h4>
<p><strong>1. 速度控制</strong></p>
<p>支持固定速度和动态速度两种模式：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 固定速度：每个字符间隔 30ms</span>
&lt;<span class="hljs-title class_">DsMarkdown</span> interval={<span class="hljs-number">30</span>}&gt;{content}&lt;/<span class="hljs-title class_">DsMarkdown</span>&gt;

<span class="hljs-comment">// 动态速度：更自然的打字节奏</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DsMarkdown</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">min:</span> <span class="hljs-attr">8</span>, <span class="hljs-attr">max:</span> <span class="hljs-attr">60</span>, <span class="hljs-attr">curve:</span> '<span class="hljs-attr">ease-out</span>' }}&gt;</span>
  {content}
<span class="hljs-tag">&lt;/<span class="hljs-name">DsMarkdown</span>&gt;</span></span>
</code></pre>
<p><strong>2. 生命周期钩子</strong></p>
<p>监听动画的各个阶段：</p>
<pre><code class="hljs language-tsx" lang="tsx">&lt;<span class="hljs-title class_">DsMarkdown</span>
  onStart={<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'开始打字'</span>)}
  onEnd={<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'打字完成'</span>);
    <span class="hljs-comment">// 可以在这里触发后续操作，如显示反馈按钮</span>
  }}
  onTypedChar={<span class="hljs-function">(<span class="hljs-params">{ char, index }</span>) =&gt;</span> {
    <span class="hljs-comment">// 实时获取当前打印的字符</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">${index}</span> 个字符: <span class="hljs-subst">${char}</span>`</span>);
  }}
&gt;
  {content}
&lt;/<span class="hljs-title class_">DsMarkdown</span>&gt;
</code></pre>
<p><strong>3. 编程式控制</strong></p>
<p>通过 ref 实现完全的程序化控制：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AIMessage</span>(<span class="hljs-params">{ content }</span>) {
  <span class="hljs-keyword">const</span> markdownRef = <span class="hljs-title function_">useRef</span>();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> markdownRef.current?.stop()}&gt;
          暂停
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> markdownRef.current?.resume()}&gt;
          继续
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> markdownRef.current?.restart()}&gt;
          重播
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">DsMarkdown</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{markdownRef}</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">{30}</span>&gt;</span>
        {content}
      <span class="hljs-tag">&lt;/<span class="hljs-name">DsMarkdown</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<p><strong>4. 主题切换</strong></p>
<p>内置明暗双主题，无需额外配置：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ConfigProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ds-markdown'</span>;
<span class="hljs-keyword">import</span> zh <span class="hljs-keyword">from</span> <span class="hljs-string">'ds-markdown/i18n/zh'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'light'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConfigProvider</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">{zh}</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">{theme}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">DsMarkdown</span>&gt;</span>{content}<span class="hljs-tag">&lt;/<span class="hljs-name">DsMarkdown</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ConfigProvider</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>5. 性能优化：按需禁用动画</strong></p>
<p>对于历史消息，可以跳过动画直接渲染：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 历史消息无需动画</span>
&lt;<span class="hljs-title class_">DsMarkdown</span> disableTyping={<span class="hljs-literal">true</span>}&gt;
  {historyMessage}
&lt;/<span class="hljs-title class_">DsMarkdown</span>&gt;

<span class="hljs-comment">// 新消息带动画</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DsMarkdown</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">{30}</span>&gt;</span>
  {newMessage}
<span class="hljs-tag">&lt;/<span class="hljs-name">DsMarkdown</span>&gt;</span></span>
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>✅ 逐字符打字动画</li>
<li>✅ 流式渲染支持</li>
<li>✅ 完整的 Markdown 生态（基于 react-markdown）</li>
<li>✅ 零配置，开箱即用</li>
<li>✅ 精细的动画控制</li>
<li>✅ 内置明/暗主题</li>
<li>✅ 兼容 react-markdown 插件生态</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>⚠️ 相对较新的项目</li>
<li>⚠️ 未处理不完整的 Markdown 块，这点 streamdown 做的更好</li>
</ul>
<p><strong>技术架构</strong>：ds-markdown 基于 react-markdown-typer（同作者开发），内部使用 react-markdown 实现 Markdown 渲染，因此完全兼容 react-markdown 的插件生态，同时在此基础上增加了打字动画和流式渲染能力。</p>
<p><strong>评分</strong>：⭐⭐⭐⭐⭐ (AI 应用的最佳选择)</p>
<hr/>
<h3 data-id="heading-12">方案四：自己实现打字机效果</h3>
<p><strong>适用场景</strong>：简单的纯文本打字动画</p>
<p>很多开发者会尝试自己实现打字机效果：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TypeWriter</span>(<span class="hljs-params">{ text }</span>) {
  <span class="hljs-keyword">const</span> [displayText, setDisplayText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (index &lt; text.<span class="hljs-property">length</span>) {
        <span class="hljs-title function_">setDisplayText</span>(text.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>));
        index++;
      }
    }, <span class="hljs-number">50</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
  }, [text]);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{displayText}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>✅ 完全可控</li>
<li>✅ 无外部依赖</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>❌ 不支持 Markdown 渲染</li>
<li>❌ 性能问题（频繁 setState）</li>
<li>❌ 无法处理复杂格式</li>
<li>❌ 流式数据处理复杂</li>
</ul>
<p><strong>评分</strong>：⭐⭐ (仅适合简单场景)</p>
<hr/>
<h2 data-id="heading-13">深度对比：关键特性</h2>











































































<table><thead><tr><th>特性</th><th>react-markdown</th><th>streamdown</th><th>ds-markdown</th><th>自实现</th></tr></thead><tbody><tr><td><strong>流式渲染</strong></td><td>❌</td><td>✅</td><td>✅</td><td>⚠️ 需自己实现</td></tr><tr><td><strong>打字动画</strong></td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><strong>Markdown 支持</strong></td><td>✅ 完整</td><td>✅ 完整</td><td>✅ 完整</td><td>❌</td></tr><tr><td><strong>代码高亮</strong></td><td>⚠️ 需配置</td><td>✅ Shiki</td><td>✅ 内置</td><td>❌</td></tr><tr><td><strong>数学公式</strong></td><td>⚠️ 需配置</td><td>✅ KaTeX</td><td>✅ KaTeX</td><td>❌</td></tr><tr><td><strong>动画控制</strong></td><td>❌</td><td>❌</td><td>✅ 暂停/继续/重播</td><td>✅</td></tr><tr><td><strong>性能优化</strong></td><td>✅</td><td>✅</td><td>✅ RAF + diff</td><td>❌</td></tr><tr><td><strong>学习成本</strong></td><td>低</td><td>低</td><td>低</td><td>高</td></tr><tr><td><strong>维护成本</strong></td><td>低</td><td>低</td><td>低</td><td>高</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-14">实战案例：不同场景的最佳实践</h2>
<h3 data-id="heading-15">场景 1：聊天历史记录</h3>
<p><strong>需求</strong>：快速渲染历史消息，不需要动画</p>
<p><strong>推荐方案</strong>：react-markdown 或 streamdown</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 历史消息直接渲染</span>
&lt;<span class="hljs-title class_">ReactMarkdown</span>&gt;{historyMessage}&lt;/<span class="hljs-title class_">ReactMarkdown</span>&gt;
</code></pre>
<h3 data-id="heading-16">场景 2：AI 实时回复</h3>
<p><strong>需求</strong>：流式输出 + 打字动画 + Markdown</p>
<p><strong>推荐方案</strong>：ds-markdown</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 新消息带打字动画</span>
&lt;<span class="hljs-title class_">DsMarkdown</span> interval={<span class="hljs-number">30</span>}&gt;
  {streamingContent}
&lt;/<span class="hljs-title class_">DsMarkdown</span>&gt;
</code></pre>
<h3 data-id="heading-17">场景 3：混合场景</h3>
<p><strong>需求</strong>：历史消息静态渲染，新消息打字动画</p>
<p><strong>推荐方案</strong>：ds-markdown（可按需禁用动画）</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 历史消息</span>
&lt;<span class="hljs-title class_">DsMarkdown</span> disableTyping={<span class="hljs-literal">true</span>}&gt;
  {historyMessage}
&lt;/<span class="hljs-title class_">DsMarkdown</span>&gt;

<span class="hljs-comment">// 新消息</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DsMarkdown</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">{30}</span>&gt;</span>
  {newMessage}
<span class="hljs-tag">&lt;/<span class="hljs-name">DsMarkdown</span>&gt;</span></span>
</code></pre>
<hr/>
<h2 data-id="heading-18">性能优化建议</h2>
<h3 data-id="heading-19">1. 避免频繁重渲染</h3>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// ❌ 不好的做法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Chat</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [messages, setMessages] = <span class="hljs-title function_">useState</span>([]);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-title function_">setMessages</span>([...messages, e.<span class="hljs-property">data</span>]); <span class="hljs-comment">// 每次都重新渲染所有消息</span>
    };
  }, [messages]);
}

<span class="hljs-comment">// ✅ 好的做法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Chat</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [messages, setMessages] = <span class="hljs-title function_">useState</span>([]);
  <span class="hljs-keyword">const</span> [currentMessage, setCurrentMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-title function_">setCurrentMessage</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + e.<span class="hljs-property">data</span>); <span class="hljs-comment">// 只更新当前消息</span>
    };
  }, []);
}
</code></pre>
<h3 data-id="heading-20">2. 使用虚拟滚动</h3>
<p>对于长对话历史，使用 react-window 或 react-virtualized：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FixedSizeList</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-window'</span>;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FixedSizeList</span>
  <span class="hljs-attr">height</span>=<span class="hljs-string">{600}</span>
  <span class="hljs-attr">itemCount</span>=<span class="hljs-string">{messages.length}</span>
  <span class="hljs-attr">itemSize</span>=<span class="hljs-string">{100}</span>
&gt;</span>
  {({ index, style }) =&gt; (
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">DsMarkdown</span>&gt;</span>{messages[index]}<span class="hljs-tag">&lt;/<span class="hljs-name">DsMarkdown</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  )}
<span class="hljs-tag">&lt;/<span class="hljs-name">FixedSizeList</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-21">3. 按需加载插件</h3>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 只在需要时加载 Mermaid</span>
<span class="hljs-keyword">import</span> { lazy } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">MermaidPlugin</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span>
  <span class="hljs-keyword">import</span>(<span class="hljs-string">'ds-markdown-mermaid-plugin'</span>)
);
</code></pre>
<hr/>
<h2 data-id="heading-22">选型决策树</h2>
<pre><code class="hljs language-markdown" lang="markdown">是否需要打字动画？
├─ 否 → 是否需要流式渲染？
│   ├─ 是 → streamdown
│   └─ 否 → react-markdown
│
└─ 是 → 是否需要 Markdown 支持？
<span class="hljs-code">    ├─ 是 → ds-markdown
    └─ 否 → 自己实现简单打字机
</span></code></pre>
<hr/>
<h2 data-id="heading-23">总结</h2>
<p>不同的技术方案适用于不同的场景：</p>
<ul>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremarkjs%2Freact-markdown" target="_blank" title="https://github.com/remarkjs/react-markdown" ref="nofollow noopener noreferrer">react-markdown</a></strong>：成熟稳定，适合静态内容</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel%2Fstreamdown" target="_blank" title="https://github.com/vercel/streamdown" ref="nofollow noopener noreferrer">streamdown</a></strong>：流式渲染专家，适合不需要动画的场景</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fonshinpei%2Fds-markdown" target="_blank" title="https://github.com/onshinpei/ds-markdown" ref="nofollow noopener noreferrer">ds-markdown</a></strong>：AI 应用的完整解决方案，打字动画 + 流式渲染</li>
<li><strong>自实现</strong>：简单场景可以尝试，复杂场景不推荐</li>
</ul>
<p>如果你正在开发 AI 对话应用，并且希望提供 ChatGPT 级别的用户体验，<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fonshinpei%2Fds-markdown" target="_blank" title="https://github.com/onshinpei/ds-markdown" ref="nofollow noopener noreferrer">ds-markdown</a></strong> 是目前市面上最完整的解决方案。</p>
<h2 data-id="heading-24">相关资源</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fonshinpei.github.io%2Fds-markdown%2F" target="_blank" title="https://onshinpei.github.io/ds-markdown/" ref="nofollow noopener noreferrer">ds-markdown 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fonshinpei.github.io%2Fds-markdown%2F%23try" target="_blank" title="https://onshinpei.github.io/ds-markdown/#try" ref="nofollow noopener noreferrer">在线演示</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fonshinpei%2Fds-markdown" target="_blank" title="https://github.com/onshinpei/ds-markdown" ref="nofollow noopener noreferrer">GitHub 仓库</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel%2Fstreamdown" target="_blank" title="https://github.com/vercel/streamdown" ref="nofollow noopener noreferrer">streamdown 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremarkjs%2Freact-markdown" target="_blank" title="https://github.com/remarkjs/react-markdown" ref="nofollow noopener noreferrer">react-markdown 文档</a></li>
</ul>
<hr/>
<p><strong>你在项目中使用的是哪种方案？欢迎在评论区分享你的经验！</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别MinIO！RustFS重构存储范式：93MB镜像撬动EB级数据，GitHub狂揽19K星]]></title>    <link>https://juejin.cn/post/7596134842482098217</link>    <guid>https://juejin.cn/post/7596134842482098217</guid>    <pubDate>2026-01-18T02:12:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596134842482098217" data-draft-id="7596171325531308073" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别MinIO！RustFS重构存储范式：93MB镜像撬动EB级数据，GitHub狂揽19K星"/> <!----> <meta itemprop="datePublished" content="2026-01-18T02:12:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="对象存储与RustFS"/> <meta itemprop="url" content="https://juejin.cn/user/652466093570057"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别MinIO！RustFS重构存储范式：93MB镜像撬动EB级数据，GitHub狂揽19K星
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/652466093570057/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    对象存储与RustFS
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T02:12:37.000Z" title="Sun Jan 18 2026 02:12:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">告别MinIO！RustFS重构存储范式：93MB镜像撬动EB级数据，GitHub狂揽19K星</h2>
<blockquote>
<p>随着AI与大数据的爆发式增长，非结构化数据存储正面临前所未有的挑战。RustFS作为基于Rust语言开发的高性能分布式对象存储系统，以其卓越性能和简洁设计，正在成为MinIO等传统方案的有力替代者。</p>
</blockquote>
<h3 data-id="heading-1">一、RustFS：为何成为存储新宠？</h3>
<p>在当今数据驱动时代，非结构化数据呈现爆炸式增长，从用户上传的图片视频到机器学习数据集，传统存储方案在性能、成本和扩展性方面面临严峻挑战。RustFS应运而生，它是一款完全兼容Amazon S3 API的高性能分布式对象存储系统。</p>
<p><strong>RustFS的核心优势</strong>源于Rust语言的内存安全特性，从语法层面杜绝了空指针和缓冲区溢出等常见内存漏洞，同时具备接近C语言的运行效率，实现了“安全不妥协性能”的突破。在实际测试中，RustFS的4K随机读达到​<strong>1.58M IOPS</strong>​，比MinIO高出42%，延迟P99仅​<strong>7.3ms</strong>，展现出卓越的性能表现。</p>
<p>相比传统存储方案，RustFS具有多项突出特点：</p>
<ul>
<li>​<strong>完全S3兼容</strong>：无缝对接现有S3生态工具和应用，迁移成本为零</li>
<li>​<strong>轻量高效</strong>：二进制包仅93MB，远小于同类方案，资源占用极低</li>
<li>​<strong>开源友好</strong>：采用Apache 2.0许可证，无AGPL传染风险，可自由商用</li>
<li>​<strong>多架构支持</strong>：对X86、ARM、RISC-V等架构原生支持</li>
</ul>
<h3 data-id="heading-2">二、架构解析：RustFS高性能的秘诀</h3>
<h4 data-id="heading-3">2.1 分布式架构设计</h4>
<p>RustFS的卓越性能背后是其创新的​<strong>元数据与数据分离架构</strong>​。元数据节点管理文件系统的命名空间和访问权限，数据节点负责实际的对象存储。这种解耦设计使得RustFS可以实现<strong>O(1)复杂度</strong>的元数据查询，百万级对象检索延迟仅7.3ms，比MinIO快60.8%。</p>
<p>RustFS集群包含三种核心角色：​<strong>主节点</strong>​（负责集群管理和元数据存储）、​<strong>从节点</strong>​（负责实际数据存储）和​<strong>客户端</strong>（提供用户接口）。在生产环境中，建议至少部署3个节点（1主2从）以满足分布式一致性要求。节点间通过Raft协议保持一致性，这种分布式共识算法确保即使部分节点故障，系统也能继续正常运行。</p>
<h4 data-id="heading-4">2.2 零拷贝技术：性能突破的关键</h4>
<p>RustFS通过革命性的零拷贝技术实现了性能的质的飞跃。在传统文件系统中，数据从存储设备到应用程序需要经历多次拷贝：硬盘→内核缓冲区→用户空间缓冲区→网络堆栈。这个过程中，每次拷贝都意味着CPU周期和内存带宽的消耗。</p>
<p><strong>RustFS的零拷贝架构</strong>通过三项核心技术实现：</p>
<ul>
<li>​<strong>io_uring异步I/O</strong>​：使用Linux内核的io_uring接口替代传统同步I/O，实现真正的异步零拷贝</li>
<li>​<strong>内存映射</strong>：将文件直接映射到进程地址空间，避免用户空间与内核空间的数据拷贝</li>
<li>​<strong>RDMA直接数据放置</strong>：在分布式环境中，利用RDMA技术实现网络零拷贝</li>
</ul>
<p>实测表明，在10G网络环境下，传统文件系统有多达<strong>70%的CPU时间</strong>消耗在数据拷贝上。而RustFS的零拷贝设计将NVMe SSD的IOPS从传统的300K提升至​<strong>1,580K</strong>，性能提升达426%。</p>
<h4 data-id="heading-5">2.3 智能分层存储架构</h4>
<p>面对性能与成本的双重挑战，RustFS创新地采用了​<strong>智能分层存储架构</strong>，充分发挥SCM（存储级内存）、TLC/MLC SSD和QLC SSD各自优势。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># RustFS分层存储配置示例</span>
<span class="hljs-attr">storage_tiering:</span>
  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">tiers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"scm_tier"</span>
      <span class="hljs-attr">medium:</span> <span class="hljs-string">"scm"</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">"/opt/rustfs/scm"</span>
      <span class="hljs-attr">capacity:</span> <span class="hljs-string">"512GB"</span>
      <span class="hljs-attr">role:</span> <span class="hljs-string">"metadata_cache"</span>
      
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"tlc_tier"</span> 
      <span class="hljs-attr">medium:</span> <span class="hljs-string">"ssd"</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">"/opt/rustfs/ssd"</span>
      <span class="hljs-attr">capacity:</span> <span class="hljs-string">"4TB"</span>
      <span class="hljs-attr">role:</span> <span class="hljs-string">"hot_data"</span>
      
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"qlc_tier"</span>
      <span class="hljs-attr">medium:</span> <span class="hljs-string">"qlc_ssd"</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">"/opt/rustfs/qlc"</span>
      <span class="hljs-attr">capacity:</span> <span class="hljs-string">"64TB"</span>
      <span class="hljs-attr">role:</span> <span class="hljs-string">"cold_data"</span>
</code></pre>
<p>RustFS的<strong>智能数据放置引擎</strong>通过机器学习算法预测数据访问模式，基于访问频率、延迟敏感度、数据大小等多因素评分决策，自动将数据放置在合适的存储层。这种智能分层设计在保证性能的同时，显著降低了存储成本。</p>
<h3 data-id="heading-6">三、实战指南：从部署到优化</h3>
<h4 data-id="heading-7">3.1 快速部署：Docker一步到位</h4>
<p>最简单快捷的部署方式是使用Docker一键部署：</p>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-comment"># docker-compose.yml</span>
<span class="hljs-attr">version:</span> <span class="hljs-string">'3.8'</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">rustfs:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">rustfs/rustfs:latest</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">rustfs</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"9000:9000"</span>  <span class="hljs-comment"># API端口</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"9001:9001"</span>  <span class="hljs-comment"># 控制台端口</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/data</span>  <span class="hljs-comment"># 数据持久化</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_ROOT_USER=admin</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_ROOT_PASSWORD=admin123</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>
</code></pre>
<p>运行 <code>docker-compose up -d</code>​即可启动服务。访问 <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A9001%2F" target="_blank" title="http://localhost:9001/" ref="nofollow noopener noreferrer">http://localhost:9001</a>使用 admin/admin123 登录管理控制台。</p>
<h4 data-id="heading-8">3.2 生产环境集群部署</h4>
<p>对于企业级生产环境，集群部署是必须的，它提供高可用性和容错能力。RustFS建议至少部署​<strong>3个节点</strong>（1主2从）。</p>
<p>​<strong>节点规划示例</strong>：</p>
<ul>
<li>主节点：192.168.1.10，数据目录 /data/rustfs/data</li>
<li>从节点1：192.168.1.11，数据目录 /data/rustfs/data</li>
<li>从节点2：192.168.1.12，数据目录 /data/rustfs/data</li>
</ul>
<p>​<strong>集群配置关键参数</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 节点角色，主节点设为 master</span>
node.role = master
<span class="hljs-comment"># 主节点IP（本机IP）</span>
node.ip = 192.168.1.10
<span class="hljs-comment"># 服务端口</span>
service.port = 9000
<span class="hljs-comment"># 集群通信端口</span>
cluster.port = 9001
<span class="hljs-comment"># 数据副本数，建议设为节点数</span>
data.replica = 3
<span class="hljs-comment"># 从节点列表（用逗号分隔）</span>
cluster.slaves = rustfs-slave1:9001,rustfs-slave2:9001
</code></pre>
<h4 data-id="heading-9">3.3 存储非结构化数据实战</h4>
<p>RustFS完全兼容S3 API，可以轻松存储各种非结构化数据：图片、视频、日志文件等。</p>
<p>​<strong>创建存储桶</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建图片存储桶</span>
aws s3 mb s3://images --endpoint-url http://localhost:9000
<span class="hljs-comment"># 创建视频存储桶  </span>
aws s3 mb s3://videos --endpoint-url http://localhost:9000
<span class="hljs-comment"># 创建日志存储桶</span>
aws s3 mb s3://logs --endpoint-url http://localhost:9000
</code></pre>
<p>​<strong>上传图片文件</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 上传单张图片</span>
aws s3 <span class="hljs-built_in">cp</span> ./avatar.jpg s3://images/users/123/avatar.jpg --endpoint-url http://localhost:9000
<span class="hljs-comment"># 上传整个图片目录</span>
aws s3 <span class="hljs-built_in">cp</span> ./product-images/ s3://images/products/ --recursive --endpoint-url http://localhost:9000
</code></pre>
<p>​<strong>存储大视频文件</strong>（支持分片上传）：</p>
<pre><code class="hljs language-bash" lang="bash">aws s3 <span class="hljs-built_in">cp</span> ./promo-video.mp4 s3://videos/promotional/promo.mp4 \
  --endpoint-url http://localhost:9000 \
  --no-sign-request \
  --metadata name=promo_video
</code></pre>
<h3 data-id="heading-10">四、高级功能与最佳实践</h3>
<h4 data-id="heading-11">4.1 数据安全与生命周期管理</h4>
<p>RustFS提供完整的数据安全解决方案，包括加密和生命周期管理。</p>
<p>​<strong>服务器端加密</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">aws s3 <span class="hljs-built_in">cp</span> sensitive-data.txt s3://documents/secure/data.txt \
  --sse AES256 \
  --endpoint-url http://localhost:9000
</code></pre>
<p><strong>生命周期管理</strong>自动将旧数据迁移到低成本存储：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"Rules"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"ID"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Move old videos to cold storage"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"Status"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Enabled"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"Filter"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"Prefix"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"archive/"</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"Transitions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"Days"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"StorageClass"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"COLD"</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-12">4.2 与大数据和AI生态集成</h4>
<p>RustFS与主流大数据和AI框架无缝集成，是构建数据湖的理想选择。</p>
<p>​<strong>Spark集成示例</strong>：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">val</span> spark = <span class="hljs-type">SparkSession</span>.builder()
  .appName(<span class="hljs-string">"RustFS-Spark-Integration"</span>)
  .config(<span class="hljs-string">"spark.hadoop.fs.s3a.access.key"</span>, <span class="hljs-string">"rustfsadmin"</span>)
  .config(<span class="hljs-string">"spark.hadoop.fs.s3a.secret.key"</span>, <span class="hljs-string">"rustfsadmin"</span>) 
  .config(<span class="hljs-string">"spark.hadoop.fs.s3a.endpoint"</span>, <span class="hljs-string">"http://localhost:9000"</span>)
  .config(<span class="hljs-string">"spark.hadoop.fs.s3a.path.style.access"</span>, <span class="hljs-string">"true"</span>)
  .getOrCreate()

<span class="hljs-comment">// 读取Parquet数据集</span>
<span class="hljs-keyword">val</span> df = spark.read.parquet(<span class="hljs-string">"s3a://ai-datalake/imagenet/parquet/"</span>)
</code></pre>
<p>​<strong>PyTorch集成示例</strong>：</p>
<pre><code class="hljs language-Python" lang="Python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset
<span class="hljs-keyword">import</span> boto3

s3 = boto3.client(<span class="hljs-string">'s3'</span>,
                  endpoint_url=<span class="hljs-string">'http://localhost:9000'</span>,
                  aws_access_key_id=<span class="hljs-string">'rustfsadmin'</span>,
                  aws_secret_access_key=<span class="hljs-string">'rustfsadmin'</span>,
                  config=boto3.session.Config(signature_version=<span class="hljs-string">'s3v4'</span>))

<span class="hljs-keyword">class</span> <span class="hljs-title class_">S3ImageDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, bucket, prefix</span>):
        self.objects = s3.list_objects_v2(Bucket=bucket, Prefix=prefix)[<span class="hljs-string">'Contents'</span>]
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):
        obj = self.objects[idx]
        response = s3.get_object(Bucket=<span class="hljs-string">'ai-datalake'</span>, Key=obj[<span class="hljs-string">'Key'</span>])
        <span class="hljs-keyword">return</span> preprocess(Image.<span class="hljs-built_in">open</span>(response[<span class="hljs-string">'Body'</span>]))
</code></pre>
<h4 data-id="heading-13">4.3 性能优化实战</h4>
<p>RustFS提供了丰富的性能调优参数，可根据工作负载特点进行优化：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># RustFS性能优化参数</span>
export <span class="hljs-attr">RUSTFS_SCM_CACHE_SIZE</span>=<span class="hljs-string">"32G"</span>
export <span class="hljs-attr">RUSTFS_QLC_BUFFER_SIZE</span>=<span class="hljs-string">"4G"</span> 
export <span class="hljs-attr">RUSTFS_TIER_MIGRATION_THREADS</span>=<span class="hljs-number">16</span>
export <span class="hljs-attr">RUSTFS_IO_SCHEDULER</span>=<span class="hljs-string">"mq-deadline"</span>

<span class="hljs-comment"># QLC专用优化</span>
export <span class="hljs-attr">RUSTFS_QLC_SEQUENTIAL_THRESHOLD</span>=<span class="hljs-string">"1M"</span>
export <span class="hljs-attr">RUSTFS_QLC_GARBAGE_COLLECTION_INTERVAL</span>=<span class="hljs-string">"300"</span>
</code></pre>
<p>在标准测试环境中，RustFS+SCM+QLC架构展现出显著优势：元数据操作延迟降低81%，顺序读吞吐量提升50%，混合工作负载提升25%。</p>
<h3 data-id="heading-14">五、应用场景与成功实践</h3>
<p>RustFS适用于多种场景，特别是需要高性能、低成本存储的非结构化数据应用：</p>
<ol>
<li>​<strong>AI/ML训练平台</strong>：RustFS的并行对象读取特性使训练时间缩短28%，同时存储成本降低40%（相比3副本方案）。</li>
<li>​<strong>多媒体存储服务</strong>：完全兼容S3 API，适合存储图片、视频等多媒体文件，支持断点续传和分片上传。</li>
<li>​<strong>数据湖架构</strong>：作为数据湖底层存储，支持Spark、Flink等大数据框架，提供高吞吐量数据访问。</li>
<li>​<strong>边缘存储场景</strong>：轻量级设计（二进制包仅93MB）使得RustFS可以在边缘设备如树莓派上运行。</li>
<li>​<strong>信创环境</strong>：作为100%中国自主知识产权的项目，已通过麒麟、统信等国产操作系统认证，支持鲲鹏、海光等国产芯片，完全符合信创要求。</li>
</ol>
<h3 data-id="heading-15">总结</h3>
<p>RustFS作为新一代高性能分布式对象存储系统，通过创新的零拷贝架构、智能分层存储和完全S3兼容性，为现代数据存储挑战提供了卓越解决方案。其卓越的性能表现、低资源占用和开源友好的许可证模式，使其成为MinIO等传统方案的有力替代者。</p>
<p>无论是AI训练、大数据分析还是简单的文件存储需求，RustFS都能提供高效、可靠的数据管理体验。通过本文的介绍，希望您能全面了解RustFS的特性和优势，并在实际项目中体验其带来的数据管理提升。</p>
<hr/>
<p>以下是深入学习 RustFS 的推荐资源：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frustfs%2Frustfs" target="_blank" title="https://github.com/rustfs/rustfs" ref="nofollow noopener noreferrer">RustFS</a></p>
<p>官方文档： <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.rustfs.com%2F" target="_blank" title="https://link.zhihu.com/?target=https%3A//docs.rustfs.com/" ref="nofollow noopener noreferrer">RustFS 官方文档</a>- 提供架构、安装指南和 API 参考。</p>
<p>GitHub 仓库： <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.rustfs.com%2F" target="_blank" title="https://link.zhihu.com/?target=https%3A//docs.rustfs.com/" ref="nofollow noopener noreferrer">GitHub 仓库</a> - 获取源代码、提交问题或贡献代码。</p>
<p>社区支持： <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Forgs%2Frustfs%2Fdiscussions" target="_blank" title="https://link.zhihu.com/?target=https%3A//github.com/orgs/rustfs/discussions" ref="nofollow noopener noreferrer">GitHub Discussions</a>- 与开发者交流经验和解决方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <!----></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Node.js 编程实战：即时聊天应用 —— 消息存储与推送]]></title>    <link>https://juejin.cn/post/7595974133097725986</link>    <guid>https://juejin.cn/post/7595974133097725986</guid>    <pubDate>2026-01-18T05:21:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595974133097725986" data-draft-id="7596153767872233506" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Node.js 编程实战：即时聊天应用 —— 消息存储与推送"/> <meta itemprop="keywords" content="后端,前端,Node.js"/> <meta itemprop="datePublished" content="2026-01-18T05:21:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员爱钓鱼"/> <meta itemprop="url" content="https://juejin.cn/user/2799775299157614"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Node.js 编程实战：即时聊天应用 —— 消息存储与推送
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2799775299157614/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员爱钓鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T05:21:57.000Z" title="Sun Jan 18 2026 05:21:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在前面的文章中，我们已经基于 WebSocket 实现了即时聊天应用的实时通信能力，并完成了群聊和私聊功能。但在真实的聊天系统中，仅有实时转发是不够的，<strong>消息存储与消息推送</strong>是两个必不可少的能力。</p>
</blockquote>
<p>消息存储用于支持聊天记录查询和离线消息，而消息推送则保证用户即使暂时不在线，也不会错过重要信息。本文将围绕这两个关键能力，介绍在 Node.js 中的常见实现思路。</p>
<hr/>
<h2 data-id="heading-0">一、为什么需要消息存储</h2>
<p>在最简单的聊天示例中，消息只存在于内存中，一旦用户断线或服务重启，消息就会丢失。这在真实场景中是不可接受的。</p>
<p>消息存储主要解决以下问题：</p>
<ul>
<li>用户可以查看历史聊天记录</li>
<li>支持用户离线后重新上线查看消息</li>
<li>支持多端登录时的数据同步</li>
<li>为后续搜索和统计提供基础</li>
</ul>
<p>因此，聊天系统必须将消息持久化存储。</p>
<hr/>
<h2 data-id="heading-1">二、消息数据模型设计</h2>
<p>在开始编码之前，需要先设计消息的基本结构。</p>
<h3 data-id="heading-2">1. 消息核心字段</h3>
<p>一条聊天消息通常包含：</p>
<ul>
<li>消息 ID</li>
<li>发送者 ID</li>
<li>接收者 ID 或群 ID</li>
<li>消息类型（私聊 / 群聊）</li>
<li>消息内容</li>
<li>发送时间</li>
<li>消息状态（已读 / 未读）</li>
</ul>
<p>这些字段可以满足绝大多数聊天场景。</p>
<hr/>
<h3 data-id="heading-3">2. 数据库存储方案选择</h3>
<p>常见的存储方式包括：</p>
<ul>
<li>关系型数据库（MySQL / PostgreSQL）</li>
<li>文档数据库（MongoDB）</li>
<li>缓存数据库（Redis，用于未读消息）</li>
</ul>
<p>在 Node.js 项目中，常见组合是：</p>
<ul>
<li>数据库负责长期存储</li>
<li>Redis 负责临时缓存和推送辅助</li>
</ul>
<hr/>
<h2 data-id="heading-4">三、消息入库流程设计</h2>
<p>当服务器收到一条聊天消息时，通常执行以下流程：</p>
<ol>
<li>校验消息合法性</li>
<li>写入数据库</li>
<li>判断接收方是否在线</li>
<li>在线则实时推送</li>
<li>不在线则标记为未读</li>
</ol>
<p>这种设计可以保证消息不丢失。</p>
<hr/>
<h2 data-id="heading-5">四、消息存储实现思路</h2>
<h3 data-id="heading-6">1. 私聊消息存储</h3>
<p>私聊消息通常存储为一条独立记录，包含发送者和接收者信息。</p>
<p>示例逻辑：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">savePrivateMessage</span>(<span class="hljs-params">message</span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">from</span>: message.<span class="hljs-property">from</span>,
    <span class="hljs-attr">to</span>: message.<span class="hljs-property">to</span>,
    <span class="hljs-attr">content</span>: message.<span class="hljs-property">content</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'private'</span>,
    <span class="hljs-attr">created_at</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
  });
}
</code></pre>
<p>数据库中可通过 from / to 字段快速查询历史消息。</p>
<hr/>
<h3 data-id="heading-7">2. 群聊消息存储</h3>
<p>群聊消息通常只存一条记录，但关联群 ID。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">saveGroupMessage</span>(<span class="hljs-params">message</span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">from</span>: message.<span class="hljs-property">from</span>,
    <span class="hljs-attr">room_id</span>: message.<span class="hljs-property">roomId</span>,
    <span class="hljs-attr">content</span>: message.<span class="hljs-property">content</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'group'</span>,
    <span class="hljs-attr">created_at</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
  });
}
</code></pre>
<p>查询群聊记录时，根据 room_id 过滤即可。</p>
<hr/>
<h2 data-id="heading-8">五、历史消息查询</h2>
<p>为了支持聊天记录展示，通常需要提供 HTTP API 查询历史消息。</p>
<p>常见设计方式：</p>
<ul>
<li>私聊：根据两个用户 ID 查询</li>
<li>群聊：根据群 ID 查询</li>
<li>支持分页，避免一次返回大量数据</li>
</ul>
<p>这种接口通常由 HTTP 服务提供，而不是 WebSocket。</p>
<hr/>
<h2 data-id="heading-9">六、离线消息处理</h2>
<h3 data-id="heading-10">1. 离线消息的判定</h3>
<p>服务器可以通过在线用户映射判断：</p>
<ul>
<li>接收方在线 → 直接推送</li>
<li>接收方离线 → 存储为未读消息</li>
</ul>
<p>未读状态通常需要在数据库或 Redis 中标记。</p>
<hr/>
<h3 data-id="heading-11">2. 离线消息推送时机</h3>
<p>当用户重新上线时：</p>
<ol>
<li>查询未读消息</li>
<li>按时间顺序推送给客户端</li>
<li>更新消息状态为已读</li>
</ol>
<p>这种方式保证消息不会丢失。</p>
<hr/>
<h2 data-id="heading-12">七、消息推送机制设计</h2>
<h3 data-id="heading-13">1. WebSocket 实时推送</h3>
<p>对于在线用户，消息通过 WebSocket 即时推送：</p>
<ul>
<li>延迟低</li>
<li>体验好</li>
<li>适合聊天场景</li>
</ul>
<p>这是聊天系统的主要推送方式。</p>
<hr/>
<h3 data-id="heading-14">2. 与 HTTP 接口配合</h3>
<p>WebSocket 负责实时消息，而 HTTP 接口负责：</p>
<ul>
<li>历史消息查询</li>
<li>未读消息统计</li>
<li>消息状态更新</li>
</ul>
<p>二者配合，可以让系统结构更加清晰。</p>
<hr/>
<h2 data-id="heading-15">八、性能与扩展性考虑</h2>
<p>当用户规模增大后，需要考虑以下问题：</p>
<ul>
<li>消息表数据量快速增长</li>
<li>查询性能下降</li>
<li>单节点 WebSocket 服务压力增大</li>
</ul>
<p>常见优化方向包括：</p>
<ul>
<li>消息表按时间或用户分表</li>
<li>使用 Redis 缓存最近消息</li>
<li>WebSocket 服务集群化</li>
<li>使用消息队列进行跨节点广播</li>
</ul>
<p>这些问题在系统早期设计阶段就应有所预期。</p>
<hr/>
<h2 data-id="heading-16">九、总结</h2>
<p>消息存储与推送是即时聊天系统中不可或缺的核心能力。通过合理的数据模型设计、清晰的消息流程和 WebSocket + HTTP 的协作方式，可以构建一个稳定、可扩展的聊天系统。</p>
<p>在《Node.js 编程实战》系列中，即时聊天项目不仅展示了 WebSocket 的使用方式，也涵盖了真实系统中常见的消息持久化和推送场景。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[重构了20个SpringBoot项目后，总结出这套稳定高效的架构设计]]></title>    <link>https://juejin.cn/post/7595893785907658786</link>    <guid>https://juejin.cn/post/7595893785907658786</guid>    <pubDate>2026-01-18T05:34:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595893785907658786" data-draft-id="7587284708947329039" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="重构了20个SpringBoot项目后，总结出这套稳定高效的架构设计"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-01-18T05:34:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            重构了20个SpringBoot项目后，总结出这套稳定高效的架构设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T05:34:49.000Z" title="Sun Jan 18 2026 05:34:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>为什么我们刚开始的 <code>SpringBoot</code> 项目清爽简洁，但随着业务增长，代码却变得越来越臃肿、难以维护？</p>
<p>其实<strong>项目架构的合理性</strong>往往决定了后期的开发效率。</p>
<h2 data-id="heading-0">一、常踩的坑</h2>
<p>举2个典型场景：</p>
<p><strong>1.万能的Service</strong>：小李要修改一个订单状态的功能，结果发现<code>OrderService.java</code>已经3800多行了！里面既有订单处理，又有用户积分计算，还夹杂着各种报表导出逻辑。想改一行代码，得先花半天时间理解。</p>
<p><strong>2.异常处理</strong>：线上出了个问题，用户支付成功了但订单状态没更新。排查发现：支付模块用try-catch返回错误码，订单模块直接抛异常，而中间的协调层既没处理异常也没记录日志，出了问题都不知道该找谁。</p>
<h2 data-id="heading-1">二、一个清晰的架构应该是什么样子</h2>
<h3 data-id="heading-2">1. 合理的项目结构</h3>
<p>首先，让我们看看良好的项目结构应该是什么样的：</p>
<pre><code class="hljs language-arduino" lang="arduino">src/main/java
└── com
    └── example
        └── project
            ├── common           <span class="hljs-comment">// 通用组件</span>
            │   ├── annotation   <span class="hljs-comment">// 自定义注解</span>
            │   ├── config       <span class="hljs-comment">// 全局配置</span>
            │   ├── constant     <span class="hljs-comment">// 常量</span>
            │   ├── exception    <span class="hljs-comment">// 统一异常处理</span>
            │   ├── utils        <span class="hljs-comment">// 工具类</span>
            │   └── vo           <span class="hljs-comment">// 通用VO</span>
            ├── module1          <span class="hljs-comment">// 业务模块1</span>
            │   ├── controller   <span class="hljs-comment">// 控制器</span>
            │   ├── service      <span class="hljs-comment">// 服务层</span>
            │   ├── dao          <span class="hljs-comment">// 数据访问层</span>
            │   ├── entity       <span class="hljs-comment">// 实体类</span>
            │   ├── dto          <span class="hljs-comment">// 数据传输对象</span>
            │   └── vo           <span class="hljs-comment">// 视图对象</span>
            ├── module2          <span class="hljs-comment">// 业务模块2</span>
            │   └── ...          <span class="hljs-comment">// 结构同上</span>
            └── ProjectApplication.java  <span class="hljs-comment">// 启动类</span>
</code></pre>
<p><strong>为什么这样设计？</strong></p>
<ul>
<li><strong>按功能模块划分</strong>：而不是按技术层次划分。这样每个模块都是自包含的，职责单一，修改一个模块不会影响到其他模块。</li>
<li><strong>分层清晰</strong>：controller负责接收请求，service处理业务逻辑，dao负责数据操作。</li>
<li><strong>通用组件抽取</strong>：避免代码重复，一处修改处处生效。</li>
</ul>
<h3 data-id="heading-3">2. 统一的API响应格式</h3>
<p>接口返回格式五花八门，前端同事是不是经常找你吐槽？来看看统一响应格式的设计：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 统一API响应格式
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt; {
    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-comment">// 状态码</span>
    <span class="hljs-keyword">private</span> String message;  <span class="hljs-comment">// 消息</span>
    <span class="hljs-keyword">private</span> T data;          <span class="hljs-comment">// 数据</span>
    
    <span class="hljs-comment">// 成功响应</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">success</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">"操作成功"</span>, <span class="hljs-literal">null</span>);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">success</span><span class="hljs-params">(T data)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">"操作成功"</span>, data);
    }
    
    <span class="hljs-comment">// 失败响应</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(String message)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;&gt;(<span class="hljs-number">500</span>, message, <span class="hljs-literal">null</span>);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(Integer code, String message)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;&gt;(code, message, <span class="hljs-literal">null</span>);
    }
}
</code></pre>
<p>这样，所有接口返回都遵循统一格式：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"code"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">200</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"操作成功"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"示例数据"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>好处</strong>：前端可以统一封装请求拦截器，无需为每个接口单独处理响应格式。</p>
<h3 data-id="heading-4">3. 全局异常处理</h3>
<p>别再在每个方法里写try-catch了！使用 <code>@ControllerAdvice</code> 实现全局异常处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RestControllerAdvice</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> {
    
    <span class="hljs-comment">// 处理自定义业务异常</span>
    <span class="hljs-meta">@ExceptionHandler(BusinessException.class)</span>
    <span class="hljs-keyword">public</span> Result&lt;?&gt; handleBusinessException(BusinessException e) {
        log.warn(<span class="hljs-string">"业务异常: {}"</span>, e.getMessage());
        <span class="hljs-keyword">return</span> Result.error(e.getCode(), e.getMessage());
    }
    
    <span class="hljs-comment">// 处理参数校验异常</span>
    <span class="hljs-meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span>
    <span class="hljs-keyword">public</span> Result&lt;?&gt; handleValidException(MethodArgumentNotValidException e) {
        <span class="hljs-type">String</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> e.getBindingResult().getFieldError().getDefaultMessage();
        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-number">400</span>, error);
    }
    
    <span class="hljs-comment">// 处理所有其他异常</span>
    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>
    <span class="hljs-keyword">public</span> Result&lt;?&gt; handleException(Exception e) {
        log.error(<span class="hljs-string">"系统异常: {}"</span>, e.getMessage(), e);
        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-number">500</span>, <span class="hljs-string">"系统繁忙，请稍后再试"</span>);
    }
}
</code></pre>
<p><strong>为什么这样做</strong>：</p>
<ul>
<li>业务代码更清爽，只需关注正常逻辑</li>
<li>异常处理集中，修改方便</li>
<li>可以统一记录异常日志，方便排查问题</li>
</ul>
<h3 data-id="heading-5">4. 配置管理最佳实践</h3>
<p>配置文件管理混乱是很多项目的痛点。推荐这样组织：</p>
<ul>
<li><strong>分环境配置</strong>：application.yml（公共配置）+ application-{env}.yml（环境特定配置）</li>
<li><strong>敏感信息外部化</strong>：数据库密码等敏感信息不要放在代码仓库，使用配置中心或环境变量</li>
<li><strong>配置类封装</strong>：使用@ConfigurationProperties将配置项映射为Java对象</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = "app.jwt")</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtProperties</span> {
    <span class="hljs-keyword">private</span> String secret;
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> expiration;
    <span class="hljs-keyword">private</span> String header;
}
</code></pre>
<p><strong>好处</strong>：</p>
<ul>
<li>配置与代码解耦</li>
<li>修改配置无需重新编译</li>
<li>类型安全，IDE能提供自动补全和验证</li>
</ul>
<h3 data-id="heading-6">5. 事务管理规范</h3>
<p>事务管理不当会导致数据不一致。建议：</p>
<ol>
<li><strong>避免在Controller层开启事务</strong>：事务应由Service层管理</li>
<li><strong>合理设置事务传播行为</strong>：根据业务场景选择合适的传播行为</li>
<li><strong>避免大事务</strong>：长时间运行的事务会锁住数据库资源</li>
<li><strong>统一异常回滚策略</strong>：默认RuntimeException会触发回滚，检查型异常不会</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderRepository orderRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InventoryService inventoryService;
    
    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>
    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderRequest request)</span> {
        <span class="hljs-comment">// 1. 创建订单</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderRepository.save(convertToOrder(request));
        
        <span class="hljs-comment">// 2. 扣减库存（远程调用）</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> inventoryService.decrease(request.getItems());
        
        <span class="hljs-keyword">if</span> (!success) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"库存不足"</span>);
        }
        
        <span class="hljs-keyword">return</span> order;
    }
}
</code></pre>
<p><strong>注意</strong>：上面的例子有瑕疵！远程调用不应放在事务中，会导致事务过长。更合理的做法是使用消息队列解耦。</p>
<h4 data-id="heading-7">正确的做法：使用可靠事件模式 + 消息队列</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderRepository orderRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationEventPublisher eventPublisher;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionTemplate transactionTemplate; <span class="hljs-comment">// 用于编程式事务</span>
    
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderRequest request)</span> {
        <span class="hljs-comment">// 1. 创建订单（在事务内）</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();
        order.setStatus(OrderStatus.CREATED);
        order.setItems(request.getItems());
        order.setTotalAmount(calculateTotal(request.getItems()));
        order.setCreateTime(LocalDateTime.now());
        <span class="hljs-type">Order</span> <span class="hljs-variable">savedOrder</span> <span class="hljs-operator">=</span> orderRepository.save(order);
        
        <span class="hljs-comment">// 2. 事务提交后再发送事件</span>
        <span class="hljs-comment">// 使用TransactionSynchronization确保事务提交后才执行</span>
        transactionTemplate.execute(status -&gt; {
            TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionSynchronization</span>() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
                    <span class="hljs-comment">// 事务成功提交后，发布扣减库存事件</span>
                    eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(savedOrder.getId(), request.getItems()));
                }
            });
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        });
        
        <span class="hljs-keyword">return</span> savedOrder;
    }
}

<span class="hljs-comment">// 事件监听器（异步处理）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryEventListener</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InventoryService inventoryService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderRepository orderRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RocketMQTemplate rocketMQTemplate; <span class="hljs-comment">// 或其他MQ客户端</span>
    
    <span class="hljs-meta">@Async</span>
    <span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreated</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 1. 先记录事件已处理（防重复）</span>
            <span class="hljs-keyword">if</span> (eventLogService.isEventProcessed(event.getOrderId())) {
                <span class="hljs-keyword">return</span>;
            }
            
            <span class="hljs-comment">// 2. 扣减库存（远程调用）</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> inventoryService.decrease(event.getItems());
            
            <span class="hljs-keyword">if</span> (!success) {
                <span class="hljs-comment">// 3. 库存不足，更新订单状态</span>
                orderRepository.updateStatus(event.getOrderId(), OrderStatus.CANCELLED);
                
                <span class="hljs-comment">// 4. 通知用户</span>
                notificationService.sendStockShortageNotice(event.getOrderId());
            }
            
            <span class="hljs-comment">// 5. 记录事件处理结果</span>
            eventLogService.markEventAsProcessed(event.getOrderId());
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"处理订单[{}]库存扣减失败"</span>, event.getOrderId(), e);
            <span class="hljs-comment">// 5. 重试机制：发送到MQ重试队列</span>
            rocketMQTemplate.convertAndSend(<span class="hljs-string">"ORDER_INVENTORY_RETRY"</span>, event);
        }
    }
}

<span class="hljs-comment">// 重试处理器（补偿机制）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryRetryHandler</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InventoryService inventoryService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderRepository orderRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLogService eventLogService;
    
    <span class="hljs-meta">@RocketMQMessageListener(topic = "ORDER_INVENTORY_RETRY", consumerGroup = "inventory-retry-group")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRetry</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        <span class="hljs-comment">// 1. 检查重试次数</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">retryCount</span> <span class="hljs-operator">=</span> retryLogService.getRetryCount(event.getOrderId());
        <span class="hljs-keyword">if</span> (retryCount &gt; <span class="hljs-number">3</span>) {
            <span class="hljs-comment">// 超过最大重试次数，人工介入</span>
            alarmService.sendAlert(<span class="hljs-string">"库存扣减持续失败，订单ID: "</span> + event.getOrderId());
            <span class="hljs-keyword">return</span>;
        }
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 2. 再次尝试扣减库存</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> inventoryService.decrease(event.getItems());
            
            <span class="hljs-keyword">if</span> (success) {
                <span class="hljs-comment">// 更新订单状态为已确认</span>
                orderRepository.updateStatus(event.getOrderId(), OrderStatus.CONFIRMED);
                <span class="hljs-comment">// 标记事件已处理</span>
                eventLogService.markEventAsProcessed(event.getOrderId());
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retryCount &gt;= <span class="hljs-number">2</span>) {
                <span class="hljs-comment">// 最后一次重试仍失败，取消订单</span>
                orderRepository.updateStatus(event.getOrderId(), OrderStatus.CANCELLED);
                notificationService.sendStockShortageNotice(event.getOrderId());
            }
            
            <span class="hljs-comment">// 3. 记录重试</span>
            retryLogService.recordRetry(event.getOrderId());
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"重试处理订单[{}]库存扣减失败"</span>, event.getOrderId(), e);
            retryLogService.recordRetry(event.getOrderId());
            <span class="hljs-comment">// 可以考虑指数退避算法延迟下次重试</span>
        }
    }
}
</code></pre>
<p>事务设计不是简单的加个<code>@Transactional</code>注解，而是要考虑：</p>
<ol>
<li>事务范围要尽量小</li>
<li>事务内不要有远程调用、IO操作</li>
<li>跨服务调用需要有补偿机制</li>
<li>最终一致性往往是更好的选择</li>
</ol>
<hr/>
<h2 data-id="heading-8">三、案例：重构前后的对比</h2>
<p>假设我们有一个用户模块，重构前是这样的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 重构前：混乱的UserService</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> EmailService emailService;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> SmsService smsService;
    
    <span class="hljs-comment">// 包含注册、登录、修改资料、密码重置等多种功能</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(UserRegisterDTO dto)</span> {
        <span class="hljs-comment">// 1. 参数校验</span>
        <span class="hljs-keyword">if</span> (userRepository.existsByUsername(dto.getUsername())) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"用户名已存在"</span>);
        }
        
        <span class="hljs-comment">// 2. 保存用户</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
        user.setUsername(dto.getUsername());
        user.setPassword(encryptPassword(dto.getPassword()));
        user.setEmail(dto.getEmail());
        user.setPhone(dto.getPhone());
        user.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
        
        <span class="hljs-type">User</span> <span class="hljs-variable">savedUser</span> <span class="hljs-operator">=</span> userRepository.save(user);
        
        <span class="hljs-comment">// 3. 发送欢迎邮件</span>
        <span class="hljs-keyword">try</span> {
            emailService.sendWelcomeEmail(user.getEmail());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"发送欢迎邮件失败"</span>, e);
        }
        
        <span class="hljs-keyword">return</span> savedUser;
    }
    
    <span class="hljs-comment">// 还有2000行其他方法...</span>
}
</code></pre>
<p>重构后：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 重构后：职责清晰的分层架构</span>
<span class="hljs-comment">// controller/UserController.java</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/users")</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService userService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserRegisterService userRegisterService;
    
    <span class="hljs-meta">@PostMapping("/register")</span>
    <span class="hljs-keyword">public</span> Result&lt;UserVO&gt; <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> UserRegisterDTO dto)</span> {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userRegisterService.register(dto);
        <span class="hljs-keyword">return</span> Result.success(convertToVO(user));
    }
    
    <span class="hljs-meta">@GetMapping("/{id}")</span>
    <span class="hljs-keyword">public</span> Result&lt;UserDetailVO&gt; <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> {
        <span class="hljs-type">UserDetail</span> <span class="hljs-variable">detail</span> <span class="hljs-operator">=</span> userService.getUserDetail(id);
        <span class="hljs-keyword">return</span> Result.success(convertToDetailVO(detail));
    }
}

<span class="hljs-comment">// service/UserRegisterService.java</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRegisterService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserRepository userRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserValidator userValidator;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordEncoder passwordEncoder;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserEventPublisher eventPublisher;
    
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(UserRegisterDTO dto)</span> {
        <span class="hljs-comment">// 1. 校验</span>
        userValidator.validateRegistration(dto);
        
        <span class="hljs-comment">// 2. 创建用户</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> createUserFromDto(dto);
        
        <span class="hljs-comment">// 3. 保存</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">savedUser</span> <span class="hljs-operator">=</span> userRepository.save(user);
        
        <span class="hljs-comment">// 4. 发布事件（解耦通知逻辑）</span>
        eventPublisher.publishUserRegisteredEvent(savedUser);
        
        <span class="hljs-keyword">return</span> savedUser;
    }
    
    <span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserFromDto</span><span class="hljs-params">(UserRegisterDTO dto)</span> {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
        user.setUsername(dto.getUsername());
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        user.setEmail(dto.getEmail());
        user.setPhone(dto.getPhone());
        user.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
        <span class="hljs-keyword">return</span> user;
    }
}

<span class="hljs-comment">// service/UserService.java</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserRepository userRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserFactory userFactory;
    
    <span class="hljs-meta">@Transactional(readOnly = true)</span>
    <span class="hljs-keyword">public</span> UserDetail <span class="hljs-title function_">getUserDetail</span><span class="hljs-params">(Long userId)</span> {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userRepository.findById(userId)
                .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"用户不存在"</span>));
        
        <span class="hljs-comment">// 组装详细信息（可能涉及多表查询）</span>
        <span class="hljs-keyword">return</span> userFactory.createUserDetail(user);
    }
}

<span class="hljs-comment">// event/UserEventPublisher.java</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEventPublisher</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationEventPublisher eventPublisher;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publishUserRegisteredEvent</span><span class="hljs-params">(User user)</span> {
        eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserRegisteredEvent</span>(<span class="hljs-built_in">this</span>, user));
    }
}

<span class="hljs-comment">// listener/UserRegistrationListener.java</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRegistrationListener</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EmailService emailService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SmsService smsService;
    
    <span class="hljs-meta">@Async</span> <span class="hljs-comment">// 异步处理</span>
    <span class="hljs-meta">@EventListener</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleUserRegistered</span><span class="hljs-params">(UserRegisteredEvent event)</span> {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> event.getUser();
        <span class="hljs-keyword">try</span> {
            emailService.sendWelcomeEmail(user.getEmail());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"发送欢迎邮件失败，用户ID: {}"</span>, user.getId(), e);
        }
        
        <span class="hljs-keyword">try</span> {
            smsService.sendWelcomeSms(user.getPhone());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"发送欢迎短信失败，用户ID: {}"</span>, user.getId(), e);
        }
    }
}
</code></pre>
<p><strong>重构带来的好处</strong>：</p>
<ol>
<li><strong>职责分明</strong>：注册服务只负责注册，查询服务只负责查询</li>
<li><strong>事务边界清晰</strong>：只有需要事务的方法才添加@Transactional</li>
<li><strong>解耦通知逻辑</strong>：使用事件机制将核心业务与辅助功能解耦</li>
<li><strong>可测试性强</strong>：每个组件职责单一，更容易编写单元测试</li>
<li><strong>异常处理统一</strong>：依赖全局异常处理器，无需在业务代码中处理异常</li>
</ol>
<h2 data-id="heading-9">四、架构设计的几个关键原则</h2>
<p>分享几个我认为特别重要的原则，这些原则指导着我的架构设计：</p>
<h3 data-id="heading-10">1. 高内聚低耦合</h3>
<ul>
<li><strong>高内聚</strong>：一个模块内部的组件高度相关，共同完成单一职责</li>
<li><strong>低耦合</strong>：模块之间依赖关系简单，修改一个模块不会影响太多其他模块</li>
</ul>
<h3 data-id="heading-11">2. 关注点分离（SoC）</h3>
<p>将不同关注点（如业务逻辑、数据访问、安全控制）分离到不同组件中，每个组件只关注自己的职责。</p>
<h3 data-id="heading-12">3. 依赖倒置原则</h3>
<p>高层模块不应依赖低层模块，两者都应该依赖抽象。抽象不应依赖细节，细节应该依赖抽象。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 不好的设计</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">private</span> MysqlOrderRepository repository; <span class="hljs-comment">// 依赖具体实现</span>
}

<span class="hljs-comment">// 好的设计</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">private</span> OrderRepository repository; <span class="hljs-comment">// 依赖抽象接口</span>
}
</code></pre>
<h3 data-id="heading-13">4. 适时重构</h3>
<p>不要等到代码烂到无法维护才重构。建议：</p>
<ul>
<li>每次修改代码时，顺手改进相关的结构</li>
<li>定期进行代码评审，发现架构问题及时调整</li>
<li>使用自动化测试保障重构安全</li>
</ul>
<h2 data-id="heading-14">五、总结</h2>
<ol>
<li><strong>模块化组织</strong>：按业务功能而非技术层次划分模块</li>
<li><strong>统一规范</strong>：API响应、异常处理、日志记录等统一规范</li>
<li><strong>分层明确</strong>：Controller、Service、DAO各司其职</li>
<li><strong>解耦设计</strong>：使用事件驱动、消息队列等方式解耦核心业务</li>
<li><strong>配置管理</strong>：合理组织配置，敏感信息分离</li>
</ol>
<blockquote>
<p>本文首发于公众号：程序员大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[聊聊看千问AI分析滤镜库Harbeth]]></title>    <link>https://juejin.cn/post/7595901379015917578</link>    <guid>https://juejin.cn/post/7595901379015917578</guid>    <pubDate>2026-01-18T05:51:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595901379015917578" data-draft-id="7595890117867044910" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="聊聊看千问AI分析滤镜库Harbeth"/> <meta itemprop="keywords" content="程序员,Swift,iOS"/> <meta itemprop="datePublished" content="2026-01-18T05:51:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="茶底世界之下"/> <meta itemprop="url" content="https://juejin.cn/user/1987535102554472"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            聊聊看千问AI分析滤镜库Harbeth
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1987535102554472/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    茶底世界之下
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T05:51:36.000Z" title="Sun Jan 18 2026 05:51:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="agate">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#333;color:#fff}.hljs-name,.hljs-strong{font-weight:700}.hljs-code,.hljs-emphasis{font-style:italic}.hljs-tag{color:#62c8f3}.hljs-selector-class,.hljs-selector-id,.hljs-template-variable,.hljs-variable{color:#ade5fc}.hljs-bullet,.hljs-string{color:#a2fca2}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-quote,.hljs-section,.hljs-title,.hljs-type{color:#ffa}.hljs-bullet,.hljs-number,.hljs-symbol{color:#d36363}.hljs-keyword,.hljs-literal,.hljs-selector-tag{color:#fcc28c}.hljs-code,.hljs-comment,.hljs-deletion{color:#888}.hljs-link,.hljs-regexp{color:#c6b4f0}.hljs-meta{color:#fc9b9b}.hljs-deletion{background-color:#fc9b9b;color:#333}.hljs-addition{background-color:#a2fca2;color:#333}.hljs a{color:inherit}.hljs a:focus,.hljs a:hover{color:inherit;text-decoration:underline}</style><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FyangKJ%2FHarbeth" target="_blank" title="https://github.com/yangKJ/Harbeth" ref="nofollow noopener noreferrer"><strong>Harbeth</strong></a> 是一个基于Apple Metal框架的高性能图像处理和滤镜开发库，采用Swift语言编写，为iOS和macOS平台提供了强大的GPU加速图像处理能力。该项目由开发者<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FyangKJ" target="_blank" title="https://github.com/yangKJ" ref="nofollow noopener noreferrer"><strong>yangKJ</strong></a>创建，旨在替代已不再更新维护的GPUImage库，同时继承了其设计理念并进行了全面升级，现已成为移动端图像处理领域的热门开源项目。</p>
<p><strong>一、HarBeth的核心架构与技术特点</strong></p>
<p><strong>1. 模块化设计</strong></p>
<p>HarBeth采用高度模块化的架构设计，主要包括以下几个核心模块：</p>
<p>l <strong>Core模块</strong>：负责配置Metal信息，以及与CoreImage的兼容转换</p>
<p>l <strong>Extensions模块</strong>：处理各类资源与MTLTexture之间的转换方法</p>
<p>l <strong>Matrix模块</strong>：包含矩阵相关操作，提供常用矩阵卷积内核和颜色矩阵</p>
<p>l <strong>Outputs模块</strong>：包含对外转换接口，如BoxxIO快速向源添加过滤器</p>
<p>l <strong>Setup模块</strong>：包含配置信息和小工具</p>
<p><strong>滤镜模块细分</strong>：</p>
<p>HarBeth的滤镜部分进一步细分为多个子模块，每个子模块专注于特定类型的图像处理：</p>
<p>l Blend：图像融合技术</p>
<p>l Blur：模糊效果</p>
<p>l ColorProcess：图像基本像素颜色处理</p>
<p>l Effect：效果处理</p>
<p>l Lookup：查找表过滤器</p>
<p>l Matrix：矩阵卷积滤波器</p>
<p>l Shape：图像形状大小相关处理</p>
<p>l VisualEffect：视觉动态特效</p>
<p><strong>2. 与CoreImage的兼容性</strong></p>
<p>HarBeth的一个显著特点是其与CoreImage的深度兼容性。开发者通过以下方式实现了这种兼容：</p>
<p>l <strong>双向转换</strong>：提供了CIImage与MTLTexture之间的高效转换方法，通过CIContext的createCGImage方法将CIImage转换为CGImage，再利用MTLDevice创建MTLTexture</p>
<p>l <strong>共享GPU队列</strong>：优化了MTLCommandQueue的使用，减少GPU任务切换开销，提高处理效率</p>
<p>l <strong>滤镜链整合</strong>：支持将CoreImage的CIFilter直接嵌入HarBeth的处理流程，允许开发者利用CoreImage丰富的内置滤镜库</p>
<p>这种兼容性设计使得HarBeth不仅能够独立工作，还能与Apple官方CoreImage框架无缝集成，为开发者提供了更大的灵活性和更丰富的功能选择。</p>
<p><strong>3. 零侵入代码设计</strong></p>
<p>HarBeth采用"零侵入"代码设计理念，使得开发者可以在不修改原有代码结构的情况下轻松添加滤镜功能。例如：</p>
<p>这种设计极大简化了滤镜功能的集成流程，使开发者能够快速地在现有项目中添加高级图像处理能力。</p>
<p><strong>二、性能优化与实现机制</strong></p>
<p><strong>1. Metal加速技术</strong></p>
<p>HarBeth的核心优势在于其出色的GPU加速性能。与传统的CPU处理相比，它充分利用了苹果设备的图形处理器，通过以下技术实现高性能图像处理：</p>
<p>l <strong>MTLTexture处理</strong>：图像数据首先被转换为MTLTexture格式，以便在GPU上进行高效并行处理</p>
<p>l <strong>MetalPerformanceShaders集成</strong>：利用Apple官方提供的高性能计算库加速计算密集型任务，如矩阵卷积</p>
<p>l <strong>异步处理机制</strong>：通过异步回调方式处理图像，避免阻塞主线程，提高应用响应速度</p>
<p><strong>2. 资源管理与性能优化</strong></p>
<p>为确保高效的图像处理性能，HarBeth在资源管理方面做了多项优化：</p>
<p>l <strong>智能内存管理</strong>：优化MTLTexture的创建和释放流程，减少内存占用和分配开销</p>
<p>l <strong>共享GPU队列</strong>：通过共享MTLCommandQueue，使任务在GPU上更高效地执行</p>
<p>l <strong>异步处理最佳实践</strong>：采用异步处理模式，避免CPU/GPU同步带来的性能瓶颈</p>
<p><strong>3. 实时处理能力</strong></p>
<p>HarBeth特别注重实时图像处理能力，主要体现在：</p>
<p>l <strong>相机采集特效</strong>：支持实时相机捕获并应用滤镜，为相机应用提供专业级实时美颜和风格化处理能力</p>
<p>l <strong>视频滤镜处理</strong>：能够在播放过程中实时应用滤镜效果，无需等待视频解码完成</p>
<p>l <strong>高帧率维持</strong>：通过优化的Metal任务调度和计算着色器，确保在图像处理密集场景下维持稳定帧率</p>
<p><strong>三、应用场景分析</strong></p>
<p><strong>1. 社交媒体应用</strong></p>
<p>HarBeth在社交媒体应用中表现出色，特别适合以下场景：</p>
<p>l <strong>实时美颜滤镜</strong>：支持在视频通话和直播中应用实时美颜效果</p>
<p>l <strong>照片编辑功能</strong>：提供丰富的预设滤镜和自定义滤镜选项，满足用户多样化照片编辑需求</p>
<p>l <strong>动态滤镜效果</strong>：如"灵魂出窍"等视觉动态特效，为照片和视频增添艺术感</p>
<p><strong>2. 专业图像/视频编辑</strong></p>
<p>对于专业图像和视频编辑软件，HarBeth提供了以下关键功能：</p>
<p>l <strong>批量处理能力</strong>：支持对大量图像和视频进行高效批处理，显著提升工作效率</p>
<p>l <strong>视频滤镜导出</strong>：能够对已有视频添加滤镜效果并导出，支持多种视频格式</p>
<p>l <strong>高级风格转换</strong>：如矩阵卷积和颜色变换等高级图像处理技术，满足专业图像编辑需求</p>
<p><strong>3. AR/VR应用开发</strong></p>
<p>尽管现有文档未明确提及，但HarBeth的技术特性使其非常适合AR/VR应用开发：</p>
<p>l <strong>实时图像渲染</strong>：强大的GPU加速能力可支持AR应用中实时图像渲染</p>
<p>l <strong>高精度色彩处理</strong>：专业的色彩矩阵和颜色处理模块，适合虚拟现实场景中的视觉效果</p>
<p>l <strong>低延迟处理</strong>：优化的图像处理流水线可降低处理延迟，提升用户体验</p>
<p><strong>四、与其他图像处理库的对比</strong></p>





















































<table><thead><tr><th>特性</th><th>HarBeth</th><th>GPUImage</th><th>CoreImage</th></tr></thead><tbody><tr><td>技术基础</td><td>Metal + CoreImage</td><td>GLKit + OpenGLES</td><td>CPU/GPU混合</td></tr><tr><td>最新更新</td><td>2025-2026年</td><td>2015年左右</td><td>持续更新</td></tr><tr><td>内置滤镜数量</td><td>超150种</td><td>约60种</td><td>约100种</td></tr><tr><td>实时处理性能</td><td>极高</td><td>较高</td><td>中等</td></tr><tr><td>集成复杂度</td><td>低（零侵入设计）</td><td>中等</td><td>中等</td></tr><tr><td>平台支持</td><td>iOS/macOS</td><td>iOS</td><td>iOS/macOS</td></tr><tr><td>开源许可</td><td>MIT</td><td>MIT</td><td>闭源</td></tr></tbody></table>
<p>数据来源：</p>
<p><strong>与GPUImage对比</strong>：HarBeth继承并扩展了GPUImage的设计理念，但通过采用Metal替代过时的OpenGLES，显著提升了性能。同时，HarBeth提供了更简洁的API和更丰富的滤镜库，且仍在持续更新维护。</p>
<p><strong>与CoreImage对比</strong>：HarBeth在保持CoreImage易用性的同时，通过直接利用Metal框架实现了更高的性能。对于简单图像处理任务，CoreImage可能更为便捷；而对于复杂、计算密集型的图像处理，HarBeth通常能提供更好的性能表现。</p>
<p><strong>五、使用建议与最佳实践</strong></p>
<p><strong>1. 安装与集成</strong></p>
<p>HarBeth可以通过多种方式集成到项目中：</p>
<p>l <strong>CocoaPods</strong>：简单一键安装</p>
<p>l <strong>Swift Package Manager</strong>：适用于SwiftUI项目</p>
<p><strong>2. 基础使用示例</strong></p>
<p>HarBeth提供了多种使用方式，包括直接应用单个滤镜、组合多个滤镜，以及函数式编程风格：</p>
<p><strong>3. 性能优化建议</strong></p>
<p>为充分发挥HarBeth的性能优势，建议采用以下最佳实践：</p>
<p>l <strong>异步处理</strong>：对于大型图像或视频处理，优先使用异步处理模式</p>
<p>l <strong>共享上下文</strong>：在同一个视图控制器中复用Metal上下文和CIContext，减少资源创建开销</p>
<p>l <strong>合理使用缓存</strong>：对于频繁应用的滤镜，考虑缓存处理结果</p>
<p>l <strong>监控性能</strong>：使用Xcode Instruments工具监控Metal性能，识别潜在瓶颈</p>
<p><strong>4. 滤镜设计与扩展</strong></p>
<p>HarBeth提供了灵活的滤镜设计和扩展机制：</p>
<p>l <strong>自定义滤镜</strong>：支持基于Metal Shading Language编写自定义滤镜</p>
<p>l <strong>组合滤镜</strong>：通过组合现有滤镜创建新效果，减少代码重复</p>
<p>l <strong>参数化调优</strong>：大多数滤镜支持参数调整，允许动态控制效果强度</p>
<p><strong>六、结论与展望</strong></p>
<p>HarBeth作为一个基于Metal的高性能图像处理框架，凭借其丰富的滤镜库、优秀的性能表现以及与CoreImage的深度兼容性，已成为iOS和macOS平台图像处理领域的重要工具。相比已停止更新的GPUImage，HarBeth不仅保持了API的简洁性，还通过底层技术的全面升级，实现了显著的性能提升。</p>
<p><strong>未来发展趋势</strong>：</p>
<p>1. <strong>持续功能扩展</strong>：随着开发者社区的参与，HarBeth的滤镜库和功能集有望进一步丰富</p>
<p>2. <strong>性能持续优化</strong>：随着Metal框架的更新迭代，HarBeth有望进一步优化其处理性能</p>
<p>3. <strong>跨平台支持</strong>：虽然目前专注于Apple平台，但未来可能考虑跨平台支持以扩大应用范围</p>
<p>4. <strong>AI增强</strong>：可能集成机器学习技术，提供基于深度学习的智能图像处理效果</p>
<p>对于需要在Apple平台实现高性能图像处理的应用开发者，HarBeth是一个值得优先考虑的技术选择，它能够以较低的学习成本和集成复杂度，为应用提供强大的视觉效果和流畅的用户体验。</p>
<p><strong>参考来源</strong></p>
<p>[1]悬镜源鉴·Gitee 极速下载/Harbeth-Gitee.com</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fmirrors%2FHarbeth%2Fopen_sca" target="_blank" title="https://gitee.com/mirrors/Harbeth/open_sca" ref="nofollow noopener noreferrer">gitee.com/mirrors/Har…</a></p>
<p>[2]进阶！展现最优的技术和最好的声音：听评英国Harbeth（雨后初晴）M40.3 XD 音箱_监听_单元_产品</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.sohu.com%2Fa%2F764150569_121631906" target="_blank" title="http://www.sohu.com/a/764150569_121631906" ref="nofollow noopener noreferrer">www.sohu.com/a/764150569…</a></p>
<p>[3]哈勃分析系统_百度百科</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%2593%2588%25E5%258B%2583%25E5%2588%2586%25E6%259E%2590%25E7%25B3%25BB%25E7%25BB%259F%2F15421763" target="_blank" title="https://baike.baidu.com/item/%E5%93%88%E5%8B%83%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/15421763" ref="nofollow noopener noreferrer">baike.baidu.com/item/%E5%93…</a></p>
<p>[4]探秘Harbeth：如何用Metal技术打造终极图像处理框架-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00063%2Farticle%2Fdetails%2F138209191" target="_blank" title="https://blog.csdn.net/gitblog_00063/article/details/138209191" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_000…</a></p>
<p>[5]探索深度学习的速度极限：Haste开源库解析与应用-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00080%2Farticle%2Fdetails%2F142116640" target="_blank" title="https://blog.csdn.net/gitblog_00080/article/details/142116640" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_000…</a></p>
<p>[6]小学生/Harbeth</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fhuansghijie%2FHarbeth" target="_blank" title="https://gitee.com/huansghijie/Harbeth" ref="nofollow noopener noreferrer">gitee.com/huansghijie…</a></p>
<p>[7]突破传统，全新时代—HarbethNLE-1书架式有源音箱-哔哩哔哩</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fopus%2F1070422660430692372" target="_blank" title="https://www.bilibili.com/opus/1070422660430692372" ref="nofollow noopener noreferrer">www.bilibili.com/opus/107042…</a></p>
<p>[8]深入讲解一下 Harbor 的源码_harbor源码-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fu011091936%2Farticle%2Fdetails%2F150115474" target="_blank" title="https://blog.csdn.net/u011091936/article/details/150115474" ref="nofollow noopener noreferrer">blog.csdn.net/u011091936/…</a></p>
<p>[9]Harbeth首页、文档和下载-图形处理和滤镜制作-OSCHINA-中文开源技术交流社区</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fharbeth" target="_blank" title="https://www.oschina.net/p/harbeth" ref="nofollow noopener noreferrer">www.oschina.net/p/harbeth</a></p>
<p>[10]探秘Harbeth：如何用Metal技术打造终极图像处理框架-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00063%2Farticle%2Fdetails%2F138209191" target="_blank" title="https://blog.csdn.net/gitblog_00063/article/details/138209191" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_000…</a></p>
<p>[11]Metal（技术）百度百科</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FMETAL%2F0" target="_blank" title="https://baike.baidu.com/item/METAL/0" ref="nofollow noopener noreferrer">baike.baidu.com/item/METAL/…</a></p>
<p>[12]iOS 利用 Metal 实现滤镜与动效滤镜_ios metal 美颜-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_34534179%2Farticle%2Fdetails%2F123335596" target="_blank" title="https://blog.csdn.net/qq_34534179/article/details/123335596" ref="nofollow noopener noreferrer">blog.csdn.net/qq_34534179…</a></p>
<p>[13]Metal-快懂百科</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.baike.com%2Fwiki%2FMetal%2F19512096" target="_blank" title="https://www.baike.com/wiki/Metal/19512096" ref="nofollow noopener noreferrer">www.baike.com/wiki/Metal/…</a></p>
<p>[14]MetalFilters 开源项目教程-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00728%2Farticle%2Fdetails%2F141989029" target="_blank" title="https://blog.csdn.net/gitblog_00728/article/details/141989029" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_007…</a></p>
<p>[15]高性能文本渲染：HarfBuzz与GPU加速技术结合方案-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_01069%2Farticle%2Fdetails%2F152253949" target="_blank" title="https://blog.csdn.net/gitblog_01069/article/details/152253949" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_010…</a></p>
<p>[16]推荐文章：探索高效图像视频处理—MetalImage框架-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00923%2Farticle%2Fdetails%2F141665302" target="_blank" title="https://blog.csdn.net/gitblog_00923/article/details/141665302" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_009…</a></p>
<p>[17]Metal助力专业 App-WWDC19-视频-Apple Developer</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fcn%2Fvideos%2Fplay%2Fwwdc2019%2F608%2F" target="_blank" title="https://developer.apple.com/cn/videos/play/wwdc2019/608/" ref="nofollow noopener noreferrer">developer.apple.com/cn/videos/p…</a></p>
<p>[18]CIImage.FromMetalTexture(IMTLTexture,NSDictionaryNSObject&gt;Method(CoreImage)Microsoft Learn</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flearn.microsoft.com%2Fzh-CN%2Fdotnet%2Fapi%2Fcoreimage.ciimage.frommetaltexture%3Fview%3Dxamarin-ios-sdk-12" target="_blank" title="https://learn.microsoft.com/zh-CN/dotnet/api/coreimage.ciimage.frommetaltexture?view=xamarin-ios-sdk-12" ref="nofollow noopener noreferrer">learn.microsoft.com/zh-CN/dotne…</a></p>
<p>[19]Active Learning Based on Locally Linear Reconstruction</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fai.nju.edu.cn%2Fzlj%2Fpdf%2FTPAMI-2011-Zhang.pdf" target="_blank" title="https://ai.nju.edu.cn/zlj/pdf/TPAMI-2011-Zhang.pdf" ref="nofollow noopener noreferrer">ai.nju.edu.cn/zlj/pdf/TPA…</a></p>
<p>[20]探秘Harbeth：如何用Metal技术打造终极图像处理框架-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00063%2Farticle%2Fdetails%2F138209191" target="_blank" title="https://blog.csdn.net/gitblog_00063/article/details/138209191" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_000…</a></p>
<p>[21]MTLTexture_Extensions.GetBufferBytesPerRow(IMTLTexture)方法(Metal)Microsoft Learn</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmetal.mtltexture_extensions.getbufferbytesperrow%3Fview%3Dxamarin-mac-sdk-14" target="_blank" title="https://learn.microsoft.com/zh-cn/dotnet/api/metal.mtltexture_extensions.getbufferbytesperrow?view=xamarin-mac-sdk-14" ref="nofollow noopener noreferrer">learn.microsoft.com/zh-cn/dotne…</a></p>
<p>[22]iOS 实时图像处理技术：使用Core Image和Metal进行高效滤镜应用-阿里云开发者社区</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1477337" target="_blank" title="http://developer.aliyun.com/article/1477337" ref="nofollow noopener noreferrer">developer.aliyun.com/article/147…</a></p>
<p>[23]教你如何玩转Metal滤镜？Harbeth是一款基于Metal API设计的滤镜框架，主要介绍与设计基于GPU的滤镜，掘金</p>
<p><a href="http://juejin.im/entry/7066964198596542471" target="_blank" title="http://juejin.im/entry/7066964198596542471">juejin.im/entry/70669…</a></p>
<p>[24]深入掌握CoreImage滤镜的使用与实战-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_33431149%2Farticle%2Fdetails%2F150370959" target="_blank" title="https://blog.csdn.net/weixin_33431149/article/details/150370959" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_3343…</a></p>
<p>[25]探索Core Image内核改进-WWDC21-视频-Apple Developer</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fcn%2Fvideos%2Fplay%2Fwwdc2021%2F10159%2F%3Ftime%3D5" target="_blank" title="https://developer.apple.com/cn/videos/play/wwdc2021/10159/?time=5" ref="nofollow noopener noreferrer">developer.apple.com/cn/videos/p…</a></p>
<p>[26]CIImage.MetalTexture Property(CoreImage)Microsoft Learn</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fcoreimage.ciimage.metaltexture%3Fview%3Dnet-macos-26.2-10.0" target="_blank" title="https://learn.microsoft.com/zh-cn/dotnet/api/coreimage.ciimage.metaltexture?view=net-macos-26.2-10.0" ref="nofollow noopener noreferrer">learn.microsoft.com/zh-cn/dotne…</a></p>
<p>[27]【函数式 Swift】封装Core Image-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_33805743%2Farticle%2Fdetails%2F88003281" target="_blank" title="https://blog.csdn.net/weixin_33805743/article/details/88003281" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_3380…</a></p>
<p>[28]MMBAT: A MULTI-TASK FRAMEWORK FOR MMWAVEREEDUCATION AND TRANSLATIONS</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2312.10346" target="_blank" title="https://arxiv.org/abs/2312.10346" ref="nofollow noopener noreferrer">arxiv.org/abs/2312.10…</a></p>
<p>[29]探秘Harbeth：如何用Metal技术打造终极图像处理框架-CSDN博客</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00063%2Farticle%2Fdetails%2F138209191" target="_blank" title="https://blog.csdn.net/gitblog_00063/article/details/138209191" ref="nofollow noopener noreferrer">blog.csdn.net/gitblog_000…</a></p>
<p>[30]Decoding the Underlying Meaning of Multmodal Hateful MEMes</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2305.17678" target="_blank" title="https://arxiv.org/abs/2305.17678" ref="nofollow noopener noreferrer">arxiv.org/abs/2305.17…</a></p>
<p>[31]Harbeth首页、文档和下载-图形处理和滤镜制作-OSCHINA-中文开源技术交流社区</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fharbeth" target="_blank" title="https://www.oschina.net/p/harbeth" ref="nofollow noopener noreferrer">www.oschina.net/p/harbeth</a></p>
<p>[32]Single color virtual H&amp;E staining with In-and-Out Net</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2405.13278" target="_blank" title="https://arxiv.org/abs/2405.13278" ref="nofollow noopener noreferrer">arxiv.org/abs/2405.13…</a></p>
<p>[33]悬镜源鉴·Gitee 极速下载/Harbeth-Gitee.com</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fmirrors%2FHarbeth%2Fopen_sca" target="_blank" title="https://gitee.com/mirrors/Harbeth/open_sca" ref="nofollow noopener noreferrer">gitee.com/mirrors/Har…</a></p>
<p>(AI生成)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[分享金融业务中规则路由的设计]]></title>    <link>https://juejin.cn/post/7595974133097594914</link>    <guid>https://juejin.cn/post/7595974133097594914</guid>    <pubDate>2026-01-18T04:17:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595974133097594914" data-draft-id="7587024296883896370" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="分享金融业务中规则路由的设计"/> <meta itemprop="keywords" content="后端,架构,开源"/> <meta itemprop="datePublished" content="2026-01-18T04:17:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="暮色妖娆丶"/> <meta itemprop="url" content="https://juejin.cn/user/4292946760307655"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            分享金融业务中规则路由的设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4292946760307655/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    暮色妖娆丶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T04:17:25.000Z" title="Sun Jan 18 2026 04:17:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>”路由“ 这个词在我们工作技术栈中涉及领域广泛。例如 <code>SpringCloud GateWay 、Nginx、SpringMvc</code>，这些都可以针对一个 <code>Http</code> 请求，根据不同规则，把请求路由/转发到不同的目的地。又或者像 <code>RabbitMQ</code> 等消息队列，路由不同的消息到不同的目的队列。基于这个思路，我们小贷项目放款可用资金方的筛选也可以使用路由的思路来实现。</p>
<h2 data-id="heading-1">Github 源码</h2>
<p>源码已分享到 Github。 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyanzhisishui%2Fli-choicerule.git" target="_blank" title="https://github.com/yanzhisishui/li-choicerule.git" ref="nofollow noopener noreferrer">li-choicerule</a></p>
<h2 data-id="heading-2">业务场景</h2>
<p>在我们金融业务中放款资金简略场景如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e15e9dce2bc24e7e8d6fa63a45405c80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316817&amp;x-signature=nNXEAFu61TeHcjcjWRG6NLLiti8%3D" alt="image.png" loading="lazy"/></p>
<p>由于放款方是合作的一批资方，每个资方对用户是否能够符合放款条件有着一系列规则，比如某个资金方要求：</p>
<ul>
<li>用户身份证户籍地址不能是偏远地区的</li>
<li>手机号前缀不能是 xx 开头的</li>
<li>身份证有效期不能是 3 个月内到期的</li>
<li>家庭住址不能是港澳台的</li>
<li>等等其他条件</li>
</ul>
<p>做过小贷的都知道，资金方放款是一个耗时的操作，我们把出款请求发送过去，至于什么时候放款是资金方决定的，所以我们通常是先获取到所有资金方中，符合该用户放款条件的资金方集合，然后遍历这个集合去放款，直到任意一个放款成功。</p>
<p>那么假如我们有 100 个合作的资金方，怎么获取到这个用户符合哪些资金方条件呢？很简单，并且也是唯一的方法，那就是把每个资金方的规则都拿出来校验一遍，只要一个资金方任意一个规则用户不满足，这个资金方就要被剔除。</p>
<blockquote>
<p>其实信贷项目中很多业务都可以用规则路由来实现，包括资金方路由、扣款商户号路由、签约商户号路由等等</p>
</blockquote>
<h2 data-id="heading-3">规则路由的简介</h2>
<p>这个场景下，我们就可以参考路由的概念，设计一个规则路由。把每个资金方作为一条大的规则链路，这个大规则链路里面有 N 个小的子规则，然后依照一定的顺序来排序这些子规则。每一条大的规则链路会获取一个结果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3ebda81cc4849c5b8cb0ed9d39fe427~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316817&amp;x-signature=nQvWTXZK%2Fgf9XmehoIFLYCQYXY8%3D" alt="image.png" loading="lazy"/></p>
<p>如果一条大的链路中所有非叶子结点的子规则都通过了校验，那就返回叶子结点的结果，通常是一个固定值。</p>
<p>当然我们也可以选择让其在任意一个叶子节点停止路由列表的继续执行，因为有些场景下，我们匹配到任意一个结果时，就不需要再往下执行剩余规则了。比如扣款商户号的规则路由，因为我们一笔扣款不可能选择多个商户号，根据路由请求，一直匹配到符合条件的扣款商户号就返回结果。</p>
<h2 data-id="heading-4">串行与并行的考量</h2>
<p>怎样高效的执行完一个用户可路由到的所有资金方列表的规则路由呢，有两种方式。一种就是单线程从第一个资金方开始，一直遍历到最后一个。另一种就是开启多线程，所有资金方并行执行规则。两种规则都各有优缺点</p>
<h3 data-id="heading-5">串行方式</h3>
<p><strong>优点：</strong></p>
<ol>
<li><strong>实现简单</strong>：逻辑直观，易于理解和调试</li>
<li><strong>资源消耗低</strong>：没有线程开销，内存占用少</li>
<li><strong>执行顺序可控</strong>：严格按照规则列表顺序执行</li>
<li><strong>避免资源竞争</strong>：没有并发问题，不需要额外同步机制</li>
<li><strong>调试方便</strong>：可以轻松跟踪执行路径</li>
<li><strong>可预测性</strong>：执行时间和结果可预测</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>性能可能较差</strong>：如果前面规则耗时很长，但没有拿到结果，即使后面的规则可以快速返回结果，也要等待</li>
<li><strong>响应时间较长</strong>：一个线程遍历处理所有规则</li>
<li><strong>阻塞式执行</strong>：非唯一结果场景下，一个慢规则会阻塞整个流程</li>
</ol>
<h3 data-id="heading-6">并行方式</h3>
<p><strong>优点：</strong></p>
<ol>
<li><strong>响应速度快</strong>：多线程并行执行，对于某用户来说，执行该用户的硬件资源更多</li>
<li><strong>提高吞吐量</strong>：多个规则可以同时执行</li>
<li><strong>更好的用户体验</strong>：减少等待时间</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>实现复杂</strong>：需要处理并发、线程池、异常等</li>
<li><strong>资源消耗大</strong>：每个规则都需要线程资源，用户量一大，线程池资源紧张</li>
<li><strong>调试困难</strong>：并发问题难以复现和调试</li>
<li><strong>可能造成资源浪费</strong>：未完成的规则也会占用资源直到被取消（尤其对于只需要一条规则结果的业务）</li>
<li><strong>线程安全问题</strong>：规则执行可能有共享状态，需要考虑同步</li>
<li><strong>超时控制复杂</strong>：需要合理设置超时时间</li>
<li><strong>不确定性</strong>：结果可能因执行顺序不同而变化</li>
</ol>
<p>以下是对比表格：</p>

































































<table><thead><tr><th align="center">对比维度</th><th align="center">串行方式</th><th align="center">并行方式</th></tr></thead><tbody><tr><td align="center">实现复杂度</td><td align="center">简单</td><td align="center">复杂</td></tr><tr><td align="center">性能</td><td align="center">可能较慢（顺序等待）</td><td align="center">通常更快（并行处理）</td></tr><tr><td align="center">资源占用</td><td align="center">低（单线程）</td><td align="center">高（多线程+线程池）</td></tr><tr><td align="center">响应时间</td><td align="center">O(∑所有规则时间)</td><td align="center">O(最快规则时间)</td></tr><tr><td align="center">可调试性</td><td align="center">优秀</td><td align="center">困难</td></tr><tr><td align="center">可预测性</td><td align="center">高</td><td align="center">低（受系统负载影响）</td></tr><tr><td align="center">错误处理</td><td align="center">简单直接</td><td align="center">需要额外机制</td></tr><tr><td align="center">超时控制</td><td align="center">容易</td><td align="center">复杂</td></tr><tr><td align="center">CPU利用率</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">内存消耗</td><td align="center">小</td><td align="center">较大</td></tr><tr><td align="center">适用场景</td><td align="center">规则少、执行快、逻辑简单</td><td align="center">规则多、执行慢、追求响应速度</td></tr></tbody></table>
<p>其实对于并行的方式来说，是否有上述那些优点是需要实际压测的，因为一但用户量大起来，假设有 100 个资金方，一个用户就需要 100个线程去并行处理，如果同时有 100w 用户，可能导致的后果是线程池的线程反复用在某一部分用户的规则上，因为线程是远远不够用的，所有可能存在一部分用户的规则始终无法得到执行，对于这部分用户来说，体验感是极其差的。</p>
<p>综合各方面考量和评估，我们最终选择的是规则的串行执行。其实实测下来，由于这些都是内存里面的脚本引擎直接执行，执行速度还是很快的。</p>
<h2 data-id="heading-7">表结构设计</h2>
<p><strong>规则配置表</strong></p>




























































































































<table><thead><tr><th>字段名</th><th>类型</th><th>允许NULL</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>NO</td><td>AUTO_INCREMENT</td><td>主键ID</td></tr><tr><td>rule_desc</td><td>varchar(500)</td><td>YES</td><td>NULL</td><td>规则描述</td></tr><tr><td>script_lang</td><td>varchar(50)</td><td>YES</td><td>NULL</td><td>匹配规则脚本语言 groovy、spel 等</td></tr><tr><td>script</td><td>text</td><td>YES</td><td>NULL</td><td>匹配规则脚本</td></tr><tr><td>result</td><td>text</td><td>YES</td><td>NULL</td><td>结果</td></tr><tr><td>result_type</td><td>varchar(20)</td><td>YES</td><td>'json'</td><td>结果类型，可以是json，xml，text 默认 json</td></tr><tr><td>status</td><td>varchar(20)</td><td>YES</td><td>NULL</td><td>状态，是否可用 1：可用 0：禁用</td></tr><tr><td>sort</td><td>int</td><td>NO</td><td>0</td><td>排序 从小到大排序</td></tr><tr><td>end</td><td>tinyint(1)</td><td>NO</td><td>0</td><td>是否到这条规则结束，只有叶子节点该属性有用</td></tr><tr><td>parent_id</td><td>bigint</td><td>YES</td><td>0</td><td>上一级 第一级该值为 0</td></tr><tr><td>rule_type</td><td>varchar(50)</td><td>YES</td><td>NULL</td><td>业务类型</td></tr><tr><td>test_data</td><td>text</td><td>YES</td><td>NULL</td><td>规则测试数据结构体</td></tr><tr><td>expect_value</td><td>tinyint</td><td>NO</td><td>0</td><td>测试结构体期望的值</td></tr><tr><td>crt_time</td><td>datetime</td><td>NO</td><td>CURRENT_TIMESTAMP</td><td>创建时间</td></tr><tr><td>upt_time</td><td>datetime</td><td>NO</td><td>CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</td><td>更新时间</td></tr><tr><td>deleted</td><td>tinyint(1)</td><td>NO</td><td>0</td><td>逻辑删除标志</td></tr></tbody></table>
<p><strong>规则运行轨迹表</strong></p>











































































<table><thead><tr><th>字段名</th><th>类型</th><th>允许NULL</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>AUTO_INCREMENT</td><td>主键ID</td></tr><tr><td>member_id</td><td>varchar(50)</td><td>YES</td><td>NULL</td><td>会员编号</td></tr><tr><td>rule_type</td><td>varchar(100)</td><td>YES</td><td>NULL</td><td>业务规则类型</td></tr><tr><td>params</td><td>text</td><td>YES</td><td>NULL</td><td>执行参数</td></tr><tr><td>result</td><td>text</td><td>YES</td><td>NULL</td><td>执行结果</td></tr><tr><td>rules_tree</td><td>text</td><td>YES</td><td>NULL</td><td>规则执行路径结构 JSON 格式</td></tr><tr><td>crt_time</td><td>datetime</td><td>NO</td><td>CURRENT_TIMESTAMP</td><td>创建时间</td></tr><tr><td>upt_time</td><td>datetime</td><td>NO</td><td>CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</td><td>更新时间</td></tr><tr><td>deleted</td><td>tinyint(1)</td><td>YES</td><td>'0'</td><td>逻辑删除标志（0-未删除，1-已删除）</td></tr></tbody></table>
<h2 data-id="heading-8">规则脚本策略</h2>
<p>我们判断一条请求是否匹配某个子规则，需要执行这个子规则的内容脚本，如果返回 <code>true</code> 代表匹配，如果返回 <code>false</code> 代表不匹配，那这里脚本内容的类型有多种可选方式</p>
<ul>
<li><code>groovy</code></li>
<li><code>Spring Expression Language （SpEL）</code></li>
<li><code>ongl</code></li>
<li>...等等</li>
</ul>
<blockquote>
<p>SpEL 确实是个很好用的东西，在 <a href="https://juejin.cn/post/7453855415719739418" target="_blank" title="https://juejin.cn/post/7453855415719739418">Mock 平台的设计</a> 文章中也是运用这个来解析请求参数的 mock 条件表达式</p>
</blockquote>
<p>这里可以根据业务实际场景开发脚本策略实现，我这里只需要 <code>Groovy</code> 和 <code>SpEL</code> 即可</p>
<p>顶层接口</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LanguageScriptStrategy</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">CONTEXT_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ctx"</span>;
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">support</span><span class="hljs-params">(String language)</span>;
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(Map&lt;String,Object&gt; params , String script)</span>;
}
</code></pre>
<p><code>groovy</code> 策略实现</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroovyScriptStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LanguageScriptStrategy</span> {

    <span class="hljs-comment">// 复用ScriptEngineManager</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ScriptEngineManager</span> <span class="hljs-variable">ENGINE_MANAGER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScriptEngineManager</span>();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">support</span><span class="hljs-params">(String language)</span> {
        <span class="hljs-keyword">return</span> ScriptTypeEnum.GROOVY.name().toLowerCase().equals(language);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(Map&lt;String, Object&gt; params, String script)</span> {
        <span class="hljs-type">ScriptEngine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> ENGINE_MANAGER.getEngineByName(ScriptTypeEnum.GROOVY.name().toLowerCase());
        <span class="hljs-comment">// 设置上下文变量</span>
        <span class="hljs-type">Bindings</span> <span class="hljs-variable">bindings</span> <span class="hljs-operator">=</span> engine.createBindings();
        bindings.put(CONTEXT_KEY, params);

        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            result = engine.eval(script, bindings);
        } <span class="hljs-keyword">catch</span> (ScriptException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Groovy脚本执行错误: "</span> + e.getMessage(), e);
        }
        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> Boolean) {
            <span class="hljs-keyword">return</span> (Boolean) result;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}
</code></pre>
<p><code>SpEL</code> 策略</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpelScriptStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LanguageScriptStrategy</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">support</span><span class="hljs-params">(String language)</span> {
        <span class="hljs-keyword">return</span> ScriptTypeEnum.SPEL.name().toLowerCase().equals(language);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">match</span><span class="hljs-params">(Map&lt;String, Object&gt; params, String script)</span> {
        <span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();
        <span class="hljs-type">StandardEvaluationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();
        context.setVariable(CONTEXT_KEY, params);
        <span class="hljs-type">Boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> parser.parseExpression(script).getValue(context, Boolean.class);
        <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> match;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">SpelScriptStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelScriptStrategy</span>();
        Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        params.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"sunyuchao"</span>);
        params.put(<span class="hljs-string">"age"</span>, <span class="hljs-number">18</span>);
        <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> strategy.match(params, <span class="hljs-string">"#ctx['name'] != null &amp;&amp; #ctx['age'] != null"</span>);
        System.out.println(match);
    }
}
</code></pre>
<p>这两种脚本都比较简单，随便熟悉一下即可掌握，并且几乎能满足所有实际业务场景需求</p>
<h2 data-id="heading-9">核心代码实现</h2>
<p>规则执行入口</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> ruleType 规则业务类型
 * <span class="hljs-doctag">@param</span> params   请求参数体，包含规则执行过程中用到的用户信息等参数
 */</span>
<span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">choice</span><span class="hljs-params">(String ruleType, Map&lt;String, Object&gt; params)</span> {
    List&lt;ChoiceRule&gt; childrenList;
    cacheLock.readLock().lock();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//查询 ruleType 的根节点</span>
        childrenList = CHOICE_RULE_CACHE.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuleTypeKey</span>(ruleType, <span class="hljs-number">0</span>), <span class="hljs-built_in">this</span>::loadRule);
    } <span class="hljs-keyword">finally</span> {
        cacheLock.readLock().unlock();
    }
    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(childrenList)) {
        <span class="hljs-keyword">return</span> Collections.emptyList();
    }
    <span class="hljs-type">RuleExecResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuleExecResponse</span>();
    <span class="hljs-type">ChoiceRuleRunRecord</span> <span class="hljs-variable">runRecord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChoiceRuleRunRecord</span>();
    runRecord.setMemberId(String.valueOf(params.get(<span class="hljs-string">"memberId"</span>)));
    runRecord.setRuleType(ruleType);
    runRecord.setParams(JSON.toJSONString(params));
    runRecord.setResult(<span class="hljs-string">"{}"</span>);
    runRecord.setRulesTree(<span class="hljs-string">"{}"</span>);
    runRecord.setCrtTime(LocalDateTime.now());
    runRecord.setUptTime(LocalDateTime.now());
    choiceRuleRunRecordMapper.insert(runRecord);

    Map&lt;String, Object&gt; rulesTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    rulesTree.put(<span class="hljs-string">"id"</span>, <span class="hljs-number">0</span>);

    List&lt;Map&lt;String,Object&gt;&gt; childrenNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (ChoiceRule rule : childrenList) {
        <span class="hljs-type">RuleExecResponse</span> <span class="hljs-variable">branchResponse</span> <span class="hljs-operator">=</span> doChoice(params, rule);
        childrenNodes.add(branchResponse.getRulesTree());
        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(branchResponse.getResult())) {
            <span class="hljs-keyword">continue</span>;
        }
        response.getResult().addAll(branchResponse.getResult());
        <span class="hljs-keyword">if</span> (branchResponse.isEndFlag()) {
            <span class="hljs-keyword">break</span>;
        }
    }
    rulesTree.put(<span class="hljs-string">"children"</span>,childrenNodes);
    runRecord.setResult(JSON.toJSONString(response.getResult()));
    runRecord.setRulesTree(JSON.toJSONString(rulesTree));
    choiceRuleRunRecordMapper.updateById(runRecord);
    <span class="hljs-keyword">return</span> response.getResult();
}
</code></pre>
<p>递归执行一条子规则链路</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> rule 当前规则实体
 * <span class="hljs-doctag">@param</span> params   请求参数体，包含规则执行过程中用到的用户信息等参数
 */</span>
<span class="hljs-keyword">private</span> RuleExecResponse <span class="hljs-title function_">doChoice</span><span class="hljs-params">(Map&lt;String, Object&gt; params, ChoiceRule rule)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> rule.getScript();
    <span class="hljs-comment">//执行脚本内容</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> strategyList.stream().filter(strategy -&gt; strategy.support(rule.getScriptLang()))
            .findFirst()
            .orElseThrow()
            .match(params, script);
    <span class="hljs-type">RuleExecResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuleExecResponse</span>();

    response.getRulesTree().put(<span class="hljs-string">"id"</span>, rule.getId());
    <span class="hljs-keyword">if</span> (!match) {
        <span class="hljs-comment">// 不匹配直接返回空响应</span>
        response.getRulesTree().put(<span class="hljs-string">"children"</span>, Collections.emptyList());
        <span class="hljs-keyword">return</span> response;
    }
    List&lt;ChoiceRule&gt; childrenList;
    cacheLock.readLock().lock();
    <span class="hljs-keyword">try</span> {
        childrenList = CHOICE_RULE_CACHE.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuleTypeKey</span>(rule.getRuleType(), rule.getId()), <span class="hljs-built_in">this</span>::loadRule);
    } <span class="hljs-keyword">finally</span> {
        cacheLock.readLock().unlock();
    }
    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(childrenList)) {
        <span class="hljs-comment">//说明是叶子结点，直接返回结果</span>
        response.getRulesTree().put(<span class="hljs-string">"children"</span>, Collections.emptyList());
        Map&lt;String, Object&gt; map = JSON.parseObject(rule.getResult(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;&gt;() {
        });
        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span> &amp;&amp; !map.isEmpty()) {
            response.getResult().add(map);
        }
        <span class="hljs-comment">//如果匹配就结束</span>
        response.setEndFlag(rule.isEnd());
        <span class="hljs-keyword">return</span> response;
    }
    List&lt;Map&lt;String, Object&gt;&gt; childrenNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (ChoiceRule choiceRule : childrenList) {
        <span class="hljs-comment">//递归子规则</span>
        <span class="hljs-type">RuleExecResponse</span> <span class="hljs-variable">childResponse</span> <span class="hljs-operator">=</span> doChoice(params, choiceRule);
        response.getResult().addAll(childResponse.getResult());

        childrenNodes.add(childResponse.getRulesTree());
        <span class="hljs-keyword">if</span> (childResponse.isEndFlag()) {
            response.setEndFlag(<span class="hljs-literal">true</span>);
            <span class="hljs-keyword">break</span>;
        }
    }
    response.getRulesTree().put(<span class="hljs-string">"children"</span>, childrenNodes);
    <span class="hljs-keyword">return</span> response;
}
</code></pre>
<p>这里我启动项目的时候构造了当前业务类型的所有规则，以树结构打印到控制台，便于直观查看</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7632478437a48d99a5c37c54e0a7eb3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316817&amp;x-signature=ArdSwjF8f9uei23WG0Pxkjx03r8%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-10">规则运行轨迹</h2>
<p>我们必须要记录一个用户在路由资金方的时候，这条路由的完整链路轨迹，这样在回溯问题的时候我们能清楚的看到是终止在了哪一个规则，并且到底什么原因没有通过规则。</p>
<blockquote>
<p><strong>回溯</strong> 这个词在我的文章中出现频率很高，包括在聊消息队列可靠性、幂等的时候也提到过。它非常重要，尽量让我们每一件事都有迹可循！</p>
</blockquote>
<p>一个用户的一次路由是一条记录，<code>choice_rule_run_record.rules_tree</code> 字段记录了所有走过的规则树结构，其实就是一个嵌套的 <code>JSON</code>，然后我们用一个合适的前端组件显示出来一次路由的所有运行轨迹，例如下图</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef579f7bd2554fadbd086c30ec60b532~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316817&amp;x-signature=4OGtW5XAM986Zd%2FdWjcPxwl48Xc%3D" alt="image.png" loading="lazy"/></p>
<p>这里由于我不懂前端知识，所以随便选了一个组件来演示运行轨迹。上图的规则场景是匹配到任意一结果就结束，所以后面的同级规则都没有走到</p>
<h2 data-id="heading-11">验证规则脚本</h2>
<p>我们在页面上编辑规则的时候，为了防止脚本内容有语法错误，可以在页面上新增一个校验按钮，当我们新增/编辑规则，保存提交前，后先点击校验按钮，通过之后才允许点击保存按钮，防止脚本内容错误直接投入生产环境造成事故。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 测试某个规则测试请求体是否能返回预期的值，验证脚本正确性
 *
 * <span class="hljs-doctag">@return</span> true 验证通过：false 验证失败
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">testRule</span><span class="hljs-params">(ChoiceRule rule)</span> {
    <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> strategyList.stream().filter(strategy -&gt; strategy.support(rule.getScriptLang()))
            .findFirst()
            .orElseThrow()
            .match(JSON.parseObject(rule.getTestData(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;&gt;() {
            }), rule.getScript());
    <span class="hljs-keyword">return</span> match == rule.isExpectValue();
}
</code></pre>
<p>类似下图的保存</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dff180b322244e8e8dd9fc56b4e2b03d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316817&amp;x-signature=%2BtEPlS9oo5df8UTlG1ywhHsQ76U%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-12">规则脚本变更告警</h2>
<p>规则变更是一个非常敏感的操作，很可能会引发严重的生产事故，因此在任何一条规则内容变更后都应该告警出来到钉钉群或者企业微信群，通知相关负责人知晓此事，如果没问题忽略即可。</p>
<p>我司之前就有过一次事故，那个规则路由是一个扣款商户号的场景。不同还款单根据一系列特定的条件走不同的扣款商户号去扣款，结果一个新来的同事改错了，也没有告警，导致一大批订单的扣款渠道走错。。。。</p>
<h2 data-id="heading-13">结语</h2>
<h3 data-id="heading-14">如果这篇文章对你有帮助，记得点赞加关注！你的支持就是我继续创作的动力！</h3></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[磁盘上没有足够的空间完成此操作，还有个8m的富余删不掉]]></title>    <link>https://juejin.cn/post/7595842144907231282</link>    <guid>https://juejin.cn/post/7595842144907231282</guid>    <pubDate>2026-01-17T11:49:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595842144907231282" data-draft-id="7595894884956930099" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="磁盘上没有足够的空间完成此操作，还有个8m的富余删不掉"/> <meta itemprop="keywords" content="面试"/> <meta itemprop="datePublished" content="2026-01-17T11:49:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风之旅人"/> <meta itemprop="url" content="https://juejin.cn/user/43636193505790"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            磁盘上没有足够的空间完成此操作，还有个8m的富余删不掉
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/43636193505790/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风之旅人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T11:49:11.000Z" title="Sat Jan 17 2026 11:49:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🛠️ 解决 Windows 8MB 残留空间无法删除的问题</h2>
<blockquote>
<p>Windows11 磁盘上没有足够的空间完成此操作，而且还有8m的富余删不掉。通过Windowss 的 DiskPart 实现磁盘的清理与分区创建。</p>
</blockquote>
<p>这个 8MB 的“顽固”空间，通常是 <strong>GPT 分区表的 MSR 保留分区</strong>，或是 MBR 分区表的隐藏对齐空间，Windows 磁盘管理工具因为权限和保护机制，无法直接删除它。我们可以用 Windows 自带的 <strong>DiskPart 命令行工具</strong> 彻底清理，再合并成完整的 1T 分区。</p>
<hr/>
<h4 data-id="heading-1">🔍 为什么会出现 8MB 残留？</h4>
<ul>
<li><strong>GPT 分区表</strong>：默认会创建一个 8MB 的 MSR（Microsoft 保留分区），用于分区表维护和系统功能，磁盘管理里看不到也删不掉。</li>
<li><strong>MBR 分区表</strong>：可能是分区删除后残留的对齐空间，或隐藏的 OEM 分区碎片。</li>
<li>无论哪种情况，用 <code>DiskPart</code> 都能一次性解决。</li>
</ul>
<hr/>
<h4 data-id="heading-2">🚀 用 DiskPart 彻底清理并合并（安全高效）</h4>
<h5 data-id="heading-3">第一步：以管理员身份打开命令提示符</h5>
<ol>
<li>按下 <code>Win + X</code> → 选择「Windows 终端（管理员）」或「命令提示符（管理员）」。</li>
<li>输入 <code>diskpart</code> 并回车，进入磁盘分区管理工具。</li>
</ol>
<h5 data-id="heading-4">第二步：选择目标磁盘（关键！别选错）</h5>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 1. 列出所有磁盘，找到你的 1T 硬盘（通常是 Disk 1，系统盘是 Disk 0）</span>
list disk

<span class="hljs-meta"># 2. 选择目标磁盘（替换 X 为你的磁盘编号，比如 Disk 1）</span>
<span class="hljs-keyword">select</span> disk X

<span class="hljs-meta"># 3. 验证选择：确认“磁盘 X 现在是所选磁盘”</span>
</code></pre>
<p>⚠️ <strong>核心提醒</strong>：一定要通过容量（比如 1024GB）确认目标磁盘，别误选系统盘（Disk 0），否则会导致系统崩溃！</p>
<h5 data-id="heading-5">第三步：彻底清理所有分区（包括 8MB 残留）</h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 清理磁盘：删除所有分区、隐藏分区和残留空间，变成纯“未分配”</span>
clean
</code></pre>
<p>✅ 执行后，你的 1T 硬盘会被完全清空，包括那个 8MB 的保留分区，整个硬盘变成一块连续的未分配空间。</p>
<h5 data-id="heading-6">第四步：创建完整的 1T 分区</h5>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 1. 转换为 GPT 分区表（推荐，支持大硬盘和 UEFI 启动）</span>
convert gpt

<span class="hljs-comment"># 2. 创建新的简单卷，大小为全部未分配空间</span>
create partition primary

<span class="hljs-comment"># 3. 格式化分区为 NTFS，快速格式化</span>
format <span class="hljs-attr">fs</span>=ntfs quick label=Data

<span class="hljs-comment"># 4. 分配驱动器号（自动分配可用盘符）</span>
assign
</code></pre>
<hr/>
<h4 data-id="heading-7">✅ 验证结果</h4>
<ol>
<li>关闭命令提示符，打开「此电脑」，你会看到一个容量约 1T 的完整分区。</li>
<li>打开「磁盘管理」，确认该硬盘只有一个分区，没有任何残留空间。</li>
</ol>
<hr/>
<h4 data-id="heading-8">💡 注意事项</h4>
<ol>
<li><strong>数据安全</strong>：<code>clean</code> 命令会删除所有分区和数据，你已经格式化过，所以无需担心，但再次确认目标磁盘正确！</li>
<li><strong>GPT vs MBR</strong>：如果你的电脑是 Legacy BIOS 启动，需要用 <code>convert mbr</code> 代替 <code>convert gpt</code>，否则无法识别分区。</li>
<li><strong>快速格式化</strong>：<code>format fs=ntfs quick</code> 会跳过扇区检查，速度更快，适合已经格式化过的硬盘。</li>
</ol>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【节点】[Slider节点]原理解析与实际应用]]></title>    <link>https://juejin.cn/post/7595901379015753738</link>    <guid>https://juejin.cn/post/7595901379015753738</guid>    <pubDate>2026-01-18T04:05:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595901379015753738" data-draft-id="7595894884958208051" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【节点】[Slider节点]原理解析与实际应用"/> <meta itemprop="keywords" content="游戏开发,图形学,Unity3D"/> <meta itemprop="datePublished" content="2026-01-18T04:05:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SmalBox"/> <meta itemprop="url" content="https://juejin.cn/user/2218166695237532"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【节点】[Slider节点]原理解析与实际应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2218166695237532/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SmalBox
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T04:05:07.000Z" title="Sun Jan 18 2026 04:05:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>在Unity URP Shader Graph中，Slider节点是一个功能强大且常用的工具节点，它为着色器开发提供了直观的参数控制方式。通过Slider节点，开发者可以创建可调节的浮点数值，这些数值在材质检视器中以滑动条的形式呈现，极大地方便了材质的参数调整和实时预览。</p>
<h2 data-id="heading-0">Slider节点的基本概念</h2>
<p>Slider节点在Shader Graph中属于常量值节点的一种特殊形式。与普通的Float节点不同，Slider节点不仅提供了数值输出功能，更重要的是它能够在材质检视器中生成一个可视化的滑动条控件。这种可视化控制方式让非技术背景的艺术家和设计师也能够轻松调整着色器参数，无需直接修改代码或节点连接。</p>
<p>Slider节点的核心价值在于其能够将技术性的数值参数转化为直观的交互控件。在游戏开发流程中，这种转化具有重要意义。美术人员可以通过拖动滑动条实时观察材质效果的变化，快速迭代和优化视觉效果，而不必依赖程序员进行每次的参数调整。</p>
<p>从技术实现角度来看，Slider节点在Shader Graph内部被处理为一个浮点数常量，但其特殊的属性标记使得Unity编辑器能够识别并在UI层面提供滑动条控件。这种设计分离了数据表示和用户界面，既保证了着色器计算的高效性，又提供了友好的用户体验。</p>
<h2 data-id="heading-1">节点创建与基本配置</h2>
<p><img src="https://docs.unity.cn/cn/Packages-cn/com.unity.shadergraph@14.0/manual/images/SliderNodeThumb.png" alt="" loading="lazy"/></p>
<p>在Shader Graph中创建Slider节点有多种方式。最直接的方法是在Shader Graph窗口的空白区域右键点击，从上下文菜单中选择"Create Node"，然后在搜索框中输入"Slider"即可找到该节点。另一种便捷的方式是通过黑场区域的右键菜单，选择"Create Node"后导航至"Input/Basic/Slider"路径。</p>
<p>创建Slider节点后，可以看到其简洁的节点结构：一个输出端口和三个可配置参数。输出端口标记为"Out"，类型为Float，用于将滑动条的当前值传递给图中的其他节点。三个配置参数包括滑动条本身的值，以及最小值和最大值范围。</p>
<p>配置Slider节点时，首先需要设置合理的数值范围。Min和Max参数定义了滑动条的理论边界，这些值应该根据实际应用场景来设定。例如，控制透明度的滑动条通常设置在0到1之间，而控制纹理重复次数的滑动条可能需要更大的范围。</p>
<h2 data-id="heading-2">端口详解与数据流</h2>
<p>Slider节点的端口配置相对简单但功能明确。输出端口"Out"是节点的唯一数据出口，负责将滑动条的当前数值传递给连接的下游节点。这个输出值的类型始终为Float，符合大多数着色器计算对数值精度的要求。</p>
<p>数据流通过Slider节点时，节点本身不执行任何计算或变换，它仅仅作为一个数值源存在。当材质检视器中的滑动条被拖动时，Slider节点的输出值会实时更新，进而触发整个着色器的重新计算和渲染更新。</p>
<p>输出端口的绑定特性为"无"，这意味着Slider节点的输出不依赖于任何外部输入或纹理采样。这种独立性使得Slider节点非常适合用作着色器的参数控制点，因为它不会引入额外的依赖关系或计算复杂度。</p>
<p>在实际使用中，Slider节点的输出可以直接连接到各种接受Float输入的节点，如数学运算节点、纹理坐标节点、颜色混合节点等。这种灵活性让Slider节点成为控制着色器各种特性的通用工具。</p>
<h2 data-id="heading-3">控件参数深度解析</h2>
<p>Slider节点的控件参数虽然数量不多，但每个参数都有其特定的用途和配置考量。</p>
<p><strong>滑动条值控件</strong></p>
<p>这是Slider节点的核心参数，决定了当前输出的数值。在Shader Graph编辑器中，这个值可以通过数字输入框精确设置，也可以通过点击并拖动滑动条来直观调整。这个值的设置应当考虑实际应用需求，比如如果用于控制高光强度，初始值可能需要设置为一个较小的正数。</p>
<p><strong>最小值参数</strong></p>
<p>Min参数定义了滑动条的理论下限。这个值可以是任意浮点数，包括负数。在设置最小值时，需要考虑物理合理性，比如透明度不应小于0，但颜色偏移量可能允许负值。最小值还影响着滑动条的灵敏度，范围越大，单位移动对应的数值变化就越大。</p>
<p><strong>最大值参数</strong></p>
<p>Max参数与Min参数协同工作，定义了滑动条的数值上限。最大值的选择同样需要基于实际应用场景，过大的最大值可能导致滑动条控制不够精细，过小的最大值则可能限制效果的表达。</p>
<p><strong>范围设置的策略</strong></p>
<p>合理的范围设置是Slider节点使用的关键。以下是一些常见的使用场景和推荐范围：</p>
<ul>
<li>透明度控制：0.0 - 1.0</li>
<li>高光强度：0.0 - 5.0</li>
<li>纹理缩放：0.1 - 10.0</li>
<li>颜色通道偏移：-1.0 - 1.0</li>
<li>时间系数：0.0 - 10.0</li>
</ul>
<h2 data-id="heading-4">属性转换与材质实例化</h2>
<p>Slider节点的一个强大特性是能够转换为着色器属性。通过节点的上下文菜单，选择"Convert To Property"选项，可以将Slider节点转换为一个正式的着色器属性。这一转换带来了几个重要优势：</p>
<p><strong>材质实例化支持</strong></p>
<p>转换为属性后，每个使用该着色器的材质实例都可以拥有自己独立的Slider值。这意味着可以在不同材质中设置不同的参数，而无需创建多个着色器变体。</p>
<p><strong>运行时修改能力</strong></p>
<p>作为属性的Slider值可以在游戏运行时通过脚本动态修改，这为创建交互式视觉效果提供了可能。比如，可以根据游戏事件调整材质的发光强度或透明度。</p>
<p><strong>属性配置选项</strong></p>
<p>转换为属性后，可以配置更多属性相关设置，如属性名称、默认值、以及是否在材质检视器中隐藏该属性。这些选项提供了更精细的属性管理能力。</p>
<p>属性名称的命名应当具有描述性且符合项目命名规范。好的属性名称能够让其他团队成员更容易理解该参数的作用，如"_SpecularIntensity"比"_Float1"更能清晰表达参数用途。</p>
<h2 data-id="heading-5">生成的代码分析</h2>
<p>理解Slider节点在背后生成的代码有助于更深入地掌握其工作原理。当Slider节点被转换为属性后，在生成的着色器代码中会产生相应的数据结构和处理逻辑。</p>
<p><strong>基础声明</strong></p>
<p>在着色器的Properties块中，会生成类似以下的属性声明：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">_SliderProperty</span>(<span class="hljs-string">"Slider Display Name"</span>, <span class="hljs-built_in">Range</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)) = <span class="hljs-number">0.5</span>
</code></pre>
<p>这里的"Slider Display Name"是在材质检视器中显示的名称，Range(0.0, 1.0)定义了滑动条的范围，0.5是默认值。</p>
<p><strong>变量定义</strong></p>
<p>在CGPROGRAM部分，会生成对应的变量声明：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">float</span> _SliderProperty;
</code></pre>
<p>这个变量可以在片段着色器或其他计算部分直接使用。</p>
<p><strong>默认值处理</strong></p>
<p>如示例代码所示，Slider节点生成的默认值表达式简单直接：</p>
<pre><code class="hljs language-ini" lang="ini">float <span class="hljs-attr">_Slider_Out</span> = <span class="hljs-number">1.0</span><span class="hljs-comment">;</span>
</code></pre>
<p>这行代码创建了一个浮点变量并将其初始化为1.0。在实际生成的着色器中，这个值会被替换为属性系统中存储的实际数值。</p>
<p><strong>材质序列化</strong></p>
<p>转换为属性后，Slider的值会与材质资源一起被序列化，这意味着设置的值会在编辑器会话之间保持持久化。</p>
<h2 data-id="heading-6">实际应用案例</h2>
<p>Slider节点在URP着色器开发中有着广泛的应用场景，以下通过几个具体案例展示其实际用法。</p>
<p><strong>基础透明度控制</strong></p>
<p>创建一个简单的透明度控制着色器：</p>
<ul>
<li>在Shader Graph中添加Slider节点，设置范围为0.0到1.0</li>
<li>将Slider输出连接到PBR主节点的Alpha输入</li>
<li>将材质表面类型设置为Transparent</li>
<li>这样就可以通过滑动条实时调整材质透明度</li>
</ul>
<p><strong>动态高光调节</strong></p>
<p>实现可调节的高光效果：</p>
<ul>
<li>使用Slider节点控制高光强度</li>
<li>将Slider输出连接到高光计算节点的强度参数</li>
<li>设置合适的范围，如0.0到3.0</li>
<li>结合其他节点创建复杂的高光响应</li>
</ul>
<p><strong>纹理变换动画</strong></p>
<p>创建基于时间的纹理变换：</p>
<ul>
<li>使用Slider节点控制动画速度</li>
<li>将Slider输出与Time节点相乘</li>
<li>结果用于驱动纹理偏移或旋转</li>
<li>通过调整Slider值控制动画快慢</li>
</ul>
<p><strong>多重Slider协同工作</strong></p>
<p>复杂效果通常需要多个Slider配合：</p>
<ul>
<li>使用多个Slider节点控制不同方面的参数</li>
<li>例如，一个控制颜色饱和度，一个控制对比度，一个控制亮度</li>
<li>通过合理的节点连接实现复杂的颜色调整效果</li>
</ul>
<h2 data-id="heading-7">高级技巧与最佳实践</h2>
<p>掌握Slider节点的高级用法可以显著提升着色器开发效率和质量。</p>
<p><strong>范围优化策略</strong></p>
<p>根据使用场景优化Slider范围：</p>
<ul>
<li>对于感知线性的参数（如透明度），使用0-1范围</li>
<li>对于指数性感知的参数（如光照强度），考虑使用0-10范围</li>
<li>使用适当的默认值，减少每次材质创建的调整需求</li>
</ul>
<p><strong>分组与组织</strong></p>
<p>当使用多个Slider时，合理的组织很重要：</p>
<ul>
<li>在Shader Graph中使用注释框对相关Slider进行分组</li>
<li>为Slider属性使用一致的命名前缀</li>
<li>在材质检视器中利用属性抽屉进行逻辑分组</li>
</ul>
<p><strong>性能考量</strong></p>
<p>虽然Slider节点本身对性能影响很小，但使用时仍需注意：</p>
<ul>
<li>避免创建过多不必要的Slider属性</li>
<li>对于不需要在运行时修改的参数，考虑使用常量而非属性</li>
<li>合理使用属性变体，避免不必要的着色器变体生成</li>
</ul>
<p><strong>调试技巧</strong></p>
<p>Slider节点可以用于着色器调试：</p>
<ul>
<li>临时连接Slider到不同节点以隔离问题</li>
<li>使用Slider控制调试信息的显示阈值</li>
<li>通过动画Slider值观察效果变化，识别异常行为</li>
</ul>
<h2 data-id="heading-8">常见问题与解决方案</h2>
<p>在使用Slider节点过程中可能会遇到一些典型问题，以下是常见问题及其解决方法。</p>
<p><strong>滑动条响应不灵敏</strong></p>
<p>当滑动条范围设置过大时，可能会出现控制不够精细的问题：</p>
<ul>
<li>解决方案：调整Min和Max值到更合理的范围</li>
<li>替代方案：使用两个Slider，一个用于粗调，一个用于微调</li>
</ul>
<p><strong>属性不显示在材质检视器</strong></p>
<p>有时转换为属性后，在材质中看不到对应的滑动条：</p>
<ul>
<li>检查属性是否被意外标记为隐藏</li>
<li>确认着色器编译没有错误</li>
<li>检查属性名称是否包含特殊字符或空格</li>
</ul>
<p><strong>运行时修改不生效</strong></p>
<p>通过脚本修改Slider属性值但没有效果：</p>
<ul>
<li>确认使用的是材质属性名称而非节点名称</li>
<li>检查材质实例是否正确引用</li>
<li>确认在修改属性后调用了material.SetFloat方法</li>
</ul>
<p><strong>数值跳跃或不平滑</strong></p>
<p>滑动条移动时数值变化不连续：</p>
<ul>
<li>这通常是范围设置过大导致</li>
<li>可以尝试减小范围或使用对数尺度处理</li>
</ul>
<h2 data-id="heading-9">与其他节点的配合使用</h2>
<p>Slider节点很少单独使用，更多的是与其他节点配合创建复杂效果。</p>
<p><strong>与数学节点配合</strong></p>
<p>Slider节点与数学节点的组合是最常见的用法：</p>
<ul>
<li>使用Multiply节点缩放Slider输出</li>
<li>使用Add节点偏移Slider基准值</li>
<li>使用Power节点创建非线性响应</li>
<li>使用Clamp节点限制最终输出范围</li>
</ul>
<p><strong>与纹理节点结合</strong></p>
<p>通过Slider控制纹理参数：</p>
<ul>
<li>控制纹理平铺次数</li>
<li>调整纹理混合权重</li>
<li>控制法线强度</li>
<li>调节视差遮挡映射强度</li>
</ul>
<p><strong>与时间节点协同</strong></p>
<p>创建动态效果：</p>
<ul>
<li>控制动画速度</li>
<li>调节脉冲频率</li>
<li>管理过渡持续时间</li>
<li>控制效果触发时机</li>
</ul>
<hr/>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong>
（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python数据处理提速50%：5个被低估的Pandas技巧🔥]]></title>    <link>https://juejin.cn/post/7595974133097627682</link>    <guid>https://juejin.cn/post/7595974133097627682</guid>    <pubDate>2026-01-18T04:22:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595974133097627682" data-draft-id="7595893785907527714" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python数据处理提速50%：5个被低估的Pandas技巧🔥"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2026-01-18T04:22:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿橙的百宝箱"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python数据处理提速50%：5个被低估的Pandas技巧🔥
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿橙的百宝箱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T04:22:51.000Z" title="Sun Jan 18 2026 04:22:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Python数据处理提速50%：5个被低估的Pandas技巧🔥</strong></h2>
<h2 data-id="heading-1">引言</h2>
<p>在数据科学和机器学习领域，Pandas无疑是Python生态系统中最强大的数据处理工具之一。然而，随着数据量的增长，许多开发者发现他们的Pandas代码运行速度逐渐成为瓶颈。事实上，90%的性能问题并非来自Pandas本身，而是由于未能充分利用其高级功能。</p>
<p>本文揭示了5个被严重低估的Pandas技巧，这些方法在实践中可以将典型数据处理任务的执行时间减少50%甚至更多。这些技术源自真实的生产环境优化经验，经过了大规模数据集（GB到TB级）的验证。</p>
<h2 data-id="heading-2">1. 使用<code>eval()</code>和<code>query()</code>进行表达式优化</h2>
<h3 data-id="heading-3">问题背景</h3>
<p>传统的数据框操作会创建多个中间对象，这在处理大型DataFrame时会导致显著的内存开销和计算延迟。</p>
<h3 data-id="heading-4">解决方案</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 传统方式 (慢)</span>
df[<span class="hljs-string">'new_col'</span>] = df[<span class="hljs-string">'col1'</span>] + df[<span class="hljs-string">'col2'</span>] * df[<span class="hljs-string">'col3'</span>]

<span class="hljs-comment"># 优化方式 (快50-70%)</span>
df.<span class="hljs-built_in">eval</span>(<span class="hljs-string">'new_col = col1 + col2 * col3'</span>, inplace=<span class="hljs-literal">True</span>)
</code></pre>
<h3 data-id="heading-5">技术原理</h3>
<p><code>eval()</code>使用NumExpr库进行表达式求值：</p>
<ul>
<li>避免中间对象的创建</li>
<li>自动并行化计算</li>
<li>优化CPU缓存利用率</li>
</ul>
<h3 data-id="heading-6">进阶技巧</h3>
<p>结合<code>query()</code>实现快速过滤：</p>
<pre><code class="hljs language-python" lang="python">fast_filter = df.query(<span class="hljs-string">'col1 &gt; 0.5 &amp; col2 &lt; 100'</span>)
</code></pre>
<h2 data-id="heading-7">2. Category类型的正确使用姿势</h2>
<h3 data-id="heading-8">常见误区</h3>
<p>多数开发者仅在处理明显分类数据（如性别、省份）时才使用category类型。</p>
<h3 data-id="heading-9">性能突破点</h3>
<p>任何基数(cardinality)小于总行数50%的列都应考虑转换：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 内存减少90%，操作加速3x的例子</span>
df[<span class="hljs-string">'department'</span>] = df[<span class="hljs-string">'department'</span>].astype(<span class="hljs-string">'category'</span>)
</code></pre>
<h3 data-id="heading-10">底层机制</h3>
<ul>
<li>Category使用整数编码存储</li>
<li>Groupby/排序操作直接比较编码值而非字符串</li>
<li>memory usage从O(n)降至O(k)，k为唯一值数量</li>
</ul>
<h2 data-id="heading-11">3. Chunk Processing模式处理超大数据集</h2>
<h3 data-id="heading-12">RAM受限时的救星</h3>
<p>当数据量超过可用内存时，传统的一次性读取会导致崩溃。</p>
<h3 data-id="heading-13">Chunking模板代码</h3>
<pre><code class="hljs language-python" lang="python">chunk_size = <span class="hljs-number">100000</span> 
result = []

<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> pd.read_csv(<span class="hljs-string">'huge_file.csv'</span>, chunksize=chunk_size):
    processed = chunk_preprocessing(chunk)
    result.append(processed)
    
final_df = pd.concat(result)
</code></pre>
<h3 data-id="heading-14">Pro Tip: Dask集成</h3>
<p>对于分布式环境：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> dask.dataframe <span class="hljs-keyword">as</span> dd
ddf = dd.read_csv(<span class="hljs-string">'s3://bucket/*.csv'</span>) 
</code></pre>
<h2 data-id="heading-15">4. Multi-index操作的隐藏威力</h2>
<h3 data-id="heading-16">Beyond简单分层索引</h3>
<p>Multi-index可以替代许多低效的groupby-filter组合操作。</p>
<h3 data-id="heading-17">O(1)查询模式示例</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Setup多层索引（注意顺序！）</span>
df_multi = df.set_index([<span class="hljs-string">'region'</span>, <span class="hljs-string">'date'</span>]).sort_index()

<span class="hljs-comment"># Lightning-fast查询（无需扫描全表）</span>
asia_q1 = df_multi.loc[(<span class="hljs-string">'Asia'</span>, <span class="hljs-built_in">slice</span>(<span class="hljs-string">'2020-01'</span>,<span class="hljs-string">'2020-03'</span>)), :]
</code></pre>
<h3 data-id="heading-18">Join加速技巧：Index对齐魔法</h3>
<p>预先设置匹配索引可使merge操作提速10倍：</p>
<pre><code class="hljs language-python" lang="python">df1.set_index(<span class="hljs-string">'key'</span>).join(df2.set_index(<span class="hljs-string">'key'</span>))
</code></pre>
<h2 data-id="heading-19">5. Numba加速自定义函数</h2>
<h3 data-id="heading-20">UDF的性能痛点</h3>
<p>传统的<code>apply(func)</code>在处理复杂逻辑时极其缓慢。</p>
<h3 data-id="heading-21">Numba-JIT解决方案</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> jit  

<span class="hljs-meta">@jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)  </span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">custom_math</span>(<span class="hljs-params">x, y</span>):  
    <span class="hljs-keyword">return</span> (x**<span class="hljs-number">2</span> + y**<span class="hljs-number">3</span>) / (x + y + eps)  

df[<span class="hljs-string">'result'</span>] = custom_math(df[<span class="hljs-string">'a'</span>].values, df[<span class="hljs-string">'b'</span>].values)  
</code></pre>
<h3 data-id="heading-22">Benchmarks对比</h3>

























<table><thead><tr><th>Method</th><th>Time (ms)</th><th>Speedup</th></tr></thead><tbody><tr><td>Plain apply</td><td>1200</td><td>-</td></tr><tr><td>Vectorized</td><td><strong>450</strong></td><td>~2.7x</td></tr><tr><td>Numba-JIT</td><td><strong>150</strong></td><td>~8x</td></tr></tbody></table>
<h2 data-id="heading-23">Bonus: Memory Optimization终极指南</h2>
<p>即使应用了上述所有技巧仍遇内存问题时：</p>
<ol>
<li>
<p><strong>精确控制数据类型</strong>：</p>
<pre><code class="hljs language-python" lang="python">dtype_map = {
    <span class="hljs-string">'id'</span>: <span class="hljs-string">'uint32'</span>,
    <span class="hljs-string">'price'</span>: <span class="hljs-string">'float32'</span>,
    <span class="hljs-string">'flag'</span>: <span class="hljs-string">'bool'</span>
}
</code></pre>
</li>
<li>
<p><strong>Sparse Data结构</strong>：适合99%空值的特征矩阵</p>
</li>
<li>
<p><strong>Downcasting自动化工具</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">auto_downcast</span>(<span class="hljs-params">df</span>):
    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> df.select_dtypes(include=[<span class="hljs-string">'float64'</span>]): 
        df[col] = pd.to_numeric(df[col], downcast=<span class="hljs-string">'float'</span>)
    <span class="hljs-keyword">return</span> df   
</code></pre>
</li>
</ol>
<h2 data-id="heading-24">Conclusion</h2>
<p>高效的数据处理不是关于编写更复杂的代码，而是深入了解工具的内在能力。这些技术组合使用时经常产生协同效应——例如将Category类型与Multi-index结合可以在分组聚合中获得100倍的性能提升。关键在于根据数据的实际特征选择恰当的组合策略。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[分享自研的轻量级状态机流程引擎]]></title>    <link>https://juejin.cn/post/7595960824485838882</link>    <guid>https://juejin.cn/post/7595960824485838882</guid>    <pubDate>2026-01-18T04:41:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595960824485838882" data-draft-id="7414302238988926985" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="分享自研的轻量级状态机流程引擎"/> <meta itemprop="keywords" content="后端,架构,开源"/> <meta itemprop="datePublished" content="2026-01-18T04:41:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="暮色妖娆丶"/> <meta itemprop="url" content="https://juejin.cn/user/4292946760307655"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            分享自研的轻量级状态机流程引擎
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4292946760307655/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    暮色妖娆丶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T04:41:50.000Z" title="Sun Jan 18 2026 04:41:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>还记得刚入职的时候，看到代码里面一堆 <code>xml</code> 配置的流程节点，如下图</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e72b3c78efef42029809908a093e85fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316110&amp;x-signature=t92PaKLF8g%2Bx3S0rq6zZqqoDCJs%3D" alt="image.png" loading="lazy"/></p>
<p>我还吐槽一个借款/还款流程为什么要搞这么复杂？老老实实的写 <code>Java</code> 代码不好吗，花里胡哨的。现在回想起来，只能说当时的我还是太年轻，真香定律 <code>YYDS</code>，见识过多种多样的资金方之后，慢慢的我才逐渐体会到 <code>状态机+流程引擎</code> 的精髓。它真的是小贷核心交易业务的治病良药！</p>
<blockquote>
<p>后来才知道这个组件是我们 CTO 亲自研发的~~~</p>
</blockquote>
<h2 data-id="heading-1">长流程业务场景</h2>
<p>先简单介绍下我的项目组业务，金融小贷平台，以还款流程为例。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f35aa878744944ee9e39bd6e6c379567~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316110&amp;x-signature=Nt%2Bc5E1lzwPp1%2FD0f8Jz1us5Kf4%3D" alt="image.png" loading="lazy"/></p>
<p>分两步，第一步是用户提交还款申请，第二步是支付密码校验确认还款，从银行卡扣款。我们可以看到整个还款流程是很长的，要处理的业务逻辑非常多，当然这并不代表我们不能用纯 <code>Java</code> 代码的方式来实现，但是它似乎并不是最优解。</p>
<p>一个最致命的问题，这么长的流程，万一中间某个环节出现了问题，导致流程异常，该如何处理？回滚事务是不可能的，因为很多节点并不是我们能控制的，比如流程一直正常，走到资方扣款，资方扣款成功了，然后通知我们的结果是扣款失败，我们的流程按照失败处理了。然后用户发现自己银行卡扣了钱，账单没有核销，还款单是失败，分分钟投诉电话就打过来了。</p>
<p>此时我们就需要修复流程，我们不可能从数据库的角度对错误流程造成的业务数据每张表挨个去修，效率太低了，正确的方式是我们找到资方结果回调的入口，用正确的参数重新调用一下。当然我们可以将业务方法的粒度分的足够细，然后将这些方法全都暴露 <code>API</code> 接口/功能，当出现异常情况需要重新从某个业务环节再次执行时，我们手动调用所有的 <code>API</code> 接口 ，但是还是那句话，它不是最优解，或者说这种方式并不友好。<strong>我们需要一个工具，让我们可以把流程重置到任意一个代码节点位置，继续运行。</strong></p>
<h2 data-id="heading-2">状态机 &amp; 流程引擎简介</h2>
<p>有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。这是维基百科给出的概念，将它应用到实践中，就是一个业务流程它通常是有很多状态节点的，在一个状态干一件事，干完之后转到另一个状态，干另一件事，经历过多次状态的转变之后迎来一个终态，代表这个流程的结束。</p>
<p>所以状态机通常和流程引擎是等价的，应该说流程引擎是以状态机为基础的。</p>
<blockquote>
<p>我了解了一下 Spring 的状态机，发现它应对我上面长流程的业务场景，似乎并不完美，我觉得它缺少流程化的东西，并且不是很好上手。</p>
</blockquote>
<h2 data-id="heading-3">Getting Started</h2>
<p><code>li-flow</code> 是参考状态机的概念设计的一个简单的流程引擎，下面我们来介绍怎样使用它，你也可以直接下载 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyanzhisishui%2Fli-flow-engine-demo" target="_blank" title="https://github.com/yanzhisishui/li-flow-engine-demo" ref="nofollow noopener noreferrer">源码demo</a>。参考示例使用，框架源码已分享到 Github <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyanzhisishui%2Fli-flow-engine" target="_blank" title="https://github.com/yanzhisishui/li-flow-engine" ref="nofollow noopener noreferrer">li-flow-springboot-starter</a>。</p>
<blockquote>
<p>由于这个组件是公司的财产，所以源码暂时不能公开，即使我基于这个思路完全重构了这个组件的代码，但是考虑到法律法规目前还是仅分享开发思路，其实代码很简单，<strong>核心思路就是在内存中维护一个流程结构</strong></p>
</blockquote>
<h3 data-id="heading-4">引入 starter</h3>
<p>由于它并不在 <code>Maven</code> 中央仓库。所以需要下载 <code>li-flow</code> 源码，<code>Maven install</code> 之后在你的项目中引入坐标。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.li.flow<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>li-flow-engine-springboot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3 data-id="heading-5">实现交易号生成策略</h3>
<p>交易号是贯穿整个状态机生命周期的重要字段，同时要保证交易号的唯一性。需要实现内置的 <code>TxnIdGenerator</code> 接口，实现我们交易号的生成逻辑。可以参考  <a href="https://juejin.cn/post/7454449782964289545" target="_blank" title="https://juejin.cn/post/7454449782964289545">业务交易号的生成方式——号段</a></p>
<pre><code class="hljs language-java" lang="java">   <span class="hljs-comment">/**
     * 交易号生成逻辑
     * */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> TxnIdGenerator <span class="hljs-title function_">txnIdGenerator</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">return</span> (txnType, obj) -&gt; {
            <span class="hljs-keyword">if</span> (txnType.equals(TxnType.REPAY)) {
                <span class="hljs-comment">//模拟交易号生成策略（根据业务自己实现）</span>
                <span class="hljs-keyword">return</span> <span class="hljs-string">"TQYHK"</span> + UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>);
            }
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"未知的交易类型"</span>);
        };
    }
</code></pre>
<p>这里的交易类型 <code>TxnType</code> 需要实现内置接口 <code>FlowTxnType</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TxnType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlowTxnType</span> {
    REPAY;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">txnType</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name();
    }
}
</code></pre>
<h3 data-id="heading-6">定义流程上下文</h3>
<p>需要定义一个实现内置接口 <code>FlowTxnContext</code> 的实现类</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepayFlowContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFlowTxnContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlowTxnContext</span> {

    <span class="hljs-comment">/**
     * 交易（交易流程主表）
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CashRepayApply repayApply;

    <span class="hljs-comment">/**
     * 字段名称
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; fieldNameList;

    <span class="hljs-comment">/**
     * 申请dao
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CashRepayApplyMapper cashRepayApplyDao;

    <span class="hljs-comment">/**
     * 新增、修改标记
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> newFlag;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RepayFlowContext</span><span class="hljs-params">(String applyNo, CashRepayApplyMapper repayApplyDao, <span class="hljs-type">boolean</span> newFlag)</span> {
        <span class="hljs-built_in">this</span>.cashRepayApplyDao = repayApplyDao;
        <span class="hljs-built_in">this</span>.newFlag = newFlag;
        <span class="hljs-keyword">if</span> (!newFlag) {
            repayApply = repayApplyDao.get(applyNo);
        } <span class="hljs-keyword">else</span> {
            repayApply = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRepayApply</span>();
            repayApply.setApplyNo(applyNo);
        }
        fieldNameList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(ReflectUtil.getAllFields(CashRepayApply.class).keySet());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTxnId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> repayApply.getApplyNo();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">(String fieldName)</span> {
        <span class="hljs-keyword">if</span> (fieldNameList.contains(fieldName)) {
            <span class="hljs-keyword">return</span> ReflectUtil.getFieldValue(repayApply, fieldName);
        }
        <span class="hljs-comment">// 如果不是业务实体字段，则从扩展字段中获取</span>
        <span class="hljs-keyword">return</span> MapUtil.get(repayApply.getExtAttrMap(), fieldName);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String fieldName, Object obj)</span> {
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span> &amp;&amp; getValue(fieldName) == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (fieldNameList.contains(fieldName)) {
            ReflectUtil.setFieldValue(repayApply, fieldName,obj);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果不是业务实体字段，则直接保存到扩展字段里面</span>
            repayApply.addExtAttr(fieldName, obj);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (newFlag) {
            repayApply.setCrtTime(LocalDateTime.now());
            repayApply.setUptTime(LocalDateTime.now());
            cashRepayApplyDao.insert(repayApply);
            newFlag = <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> {
            repayApply.setUptTime(LocalDateTime.now());
            cashRepayApplyDao.updateById(repayApply);
        }
    }
}
</code></pre>
<p>这个作用是在每一个 <code>&lt;li-flow:state&gt;</code> 结束时，将本次对交易数据的改动更新到数据库。</p>
<h3 data-id="heading-7">实现流程上下文工厂</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepayFlowContextFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlowTxnContextFactory</span> {
	<span class="hljs-meta">@Autowired</span>
	<span class="hljs-keyword">private</span> CashRepayApplyMapper cashRepayApplyMapper;
	<span class="hljs-comment">/**
	 * 交易类型
	 * */</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">support</span><span class="hljs-params">(FlowTxnType type)</span> {
		<span class="hljs-keyword">return</span> TxnType.REPAY.equals(type);
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> FlowTxnContext <span class="hljs-title function_">newTxnContext</span><span class="hljs-params">(  String repayApplyNo, Object... paras)</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepayFlowContext</span>(repayApplyNo, cashRepayApplyMapper, <span class="hljs-literal">true</span>);
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> FlowTxnContext <span class="hljs-title function_">loadTxnContext</span><span class="hljs-params">( String applyCode)</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepayFlowContext</span>(applyCode, cashRepayApplyMapper, <span class="hljs-literal">false</span>);
	}

}
</code></pre>
<h3 data-id="heading-8">定义流程 xml 文件</h3>
<p>文件名 <code>cash-mas-repay-flow-config.xml</code> （根据自己业务定义合适的文件名） 内容。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
       <span class="hljs-attr">xmlns:li-flow</span>=<span class="hljs-string">"http://www.sunyuchao.com/schema/sunyuchao/flow-engine"</span>
       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.sunyuchao.com/schema/sunyuchao/flow-engine http://www.sunyuchao.com/schema/sunyuchao/flow-engine/flow-engine-1.0.0.xsd"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 现金贷还款申请流程 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:state-diagram</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"biz-ins-cash-mas.repay-apply-flow"</span> <span class="hljs-attr">begin-status</span>=<span class="hljs-string">"I00"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:state</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"I00"</span> <span class="hljs-attr">next-status</span>=<span class="hljs-string">"I05"</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 基本信息添加 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:task</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"cashRepayApplyBaseInitTask"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:state</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 基础校验 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:state</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"I05"</span> <span class="hljs-attr">next-status</span>=<span class="hljs-string">"I10"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:task</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"memberStatusCheckTask"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:state</span>&gt;</span>
        
         <span class="hljs-comment">&lt;!-- 省略 --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:state-diagram</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<h3 data-id="heading-9">流程引擎启动类 DistributedTxnEngine</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>  
<span class="hljs-keyword">private</span> DistributedTxnEngine distributedTxnEngine;
</code></pre>
<p>直接使用，它是流程的启动入口</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">CashRepaySubmitRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRepaySubmitRequest</span>();  
request.setMemberId(<span class="hljs-string">"JF1234"</span>);  
request.setOrderNo(<span class="hljs-string">"TQYJKN20230117122122161"</span>);
request.setRepayNums(<span class="hljs-string">"1,2,3"</span>);
<span class="hljs-comment">//...请求参数</span>
<span class="hljs-type">String</span> <span class="hljs-variable">repayNo</span> <span class="hljs-operator">=</span> distributedTxnEngine.startTxn(<span class="hljs-string">"biz-ins-cash-mas.repay-apply-flow"</span>, request, TxnType.REPAY);
</code></pre>
<h3 data-id="heading-10">事件唤醒</h3>
<p>很多时候我们的流程会暂停在一个中间节点，等待第三方的某个业务处理结果通知我们继续执行流程。这个时候我们需要用唤醒机制来唤醒流程，使用 <code>DistributedTxnEngine</code> 接口中定义的方法</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 发布事件唤醒流程
 * 
 * <span class="hljs-doctag">@param</span> eventType 事件id
 * <span class="hljs-doctag">@param</span> txnId 交易号
 * <span class="hljs-doctag">@param</span> txnType 交易类型
 * 
 * <span class="hljs-doctag">@return</span> true，表示事件已经正确出发，false表示交易已经终止
 */</span>
<span class="hljs-type">boolean</span> <span class="hljs-title function_">signalEventToTxn</span><span class="hljs-params">(String eventType, String txnId, FlowTxnType txnType)</span>;
</code></pre>
<blockquote>
<p>注意：这里我们不建议在事件唤醒传入外部业务参数，因为能够收到结果通知，说明一定有相关的结果查询接口，我们推荐在流程唤醒后，再次调用查询接口，以查询得到的结果为准更合适</p>
</blockquote>
<p>首先我们需要在 <code>xml</code> 流程文件中 <code>&lt;li-flow:state-diagram&gt;</code> 标签内 定义事件节点</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li-flow:state-diagram</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"biz-ins-cash-mas.repay-apply-flow"</span> <span class="hljs-attr">begin-status</span>=<span class="hljs-string">"I00"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:event-node</span> <span class="hljs-attr">event-type</span>=<span class="hljs-string">"repay-flow-apply-event"</span> <span class="hljs-attr">event-handler</span>=<span class="hljs-string">"repayFlowApplyHandler"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:state-diagram</span>&gt;</span>
</code></pre>
<p>然后定义对应的事件处理器 <code>handler</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepayFlowApplyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventHandler</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">onEvent</span><span class="hljs-params">(String eventType ,String currentStatus, FlowTxnContext ctx)</span> {
        log.info(<span class="hljs-string">"repay flow apply event currentStatus-{}"</span>,currentStatus);
        ctx.setValue(CashRepayApplyFieldNames.ERR_CODE, <span class="hljs-string">""</span>);
        ctx.setValue(CashRepayApplyFieldNames.ERR_MSG, <span class="hljs-string">""</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"B00"</span>;
    }
}
</code></pre>
<p>在业务代码的合适位置调用事件唤醒 <code>API</code>，这个合适的位置一般是收到 <code>MQ</code> 结果的消息通知</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>  
<span class="hljs-keyword">private</span> DistributedTxnEngine distributedTxnEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>{
    distributedTxnEngine.signalEventToTxn(<span class="hljs-string">"repay-flow-apply-event"</span>, <span class="hljs-string">"REPAY_NO"</span>,TxnType.REPAY);
}
</code></pre>
<blockquote>
<p>注意：流程引擎状态机状态为 <code>暂停</code> 的时候才可以用事件唤醒，即 flow_transaction_lock 表的 flag 值为 1</p>
</blockquote>
<h3 data-id="heading-11">异常处理</h3>
<p>和事件几乎一样，先定义异常处理节点</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li-flow:state-diagram</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"biz-ins-cash-mas.repay-apply-flow"</span> <span class="hljs-attr">begin-status</span>=<span class="hljs-string">"I00"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:exception-handler</span> <span class="hljs-attr">exception-class</span>=<span class="hljs-string">"java.lang.Throwable"</span> <span class="hljs-attr">exception-handler</span>=<span class="hljs-string">"repayApplyExceptionHandler"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:state-diagram</span>&gt;</span>
</code></pre>
<p>然后定义异常处理器</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepayApplyExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExceptionHandler</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">onException</span><span class="hljs-params">(Throwable e, String currentStatus, FlowTxnContext ctx, Object paras)</span> {
        ctx.setValue(<span class="hljs-string">"flowCurrentStatus"</span>, currentStatus);
        ctx.setValue(<span class="hljs-string">"testRunTimeException"</span>, <span class="hljs-literal">true</span>);
        log.error(<span class="hljs-string">"RepaySuccessExceptionHandler exception repayNo={}, currentStatus={}"</span>, ctx.getTxnId(), currentStatus, e);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"W"</span>;
    }
}
</code></pre>
<blockquote>
<p>可以定义多个异常处理器用来处理不同类型的异常，走不同的业务逻辑。例如一般我们特定业务异常是可以给交易直接定为失败，走失败流程。但是系统异常，例如数据问题、代码 bug 等这种我们应该给交易暂停，等待后续人工介入</p>
</blockquote>
<h3 data-id="heading-12">条件分支</h3>
<p><code>xml</code> 流程其实是模仿 <code>Java</code> 代码的执行逻辑，所以它无法避免我们需要条件分支的场景，当我们需要根据一个不同返回值来进行不同的逻辑处理时可以使用 <code>&lt;li-flow:switch&gt;</code> 实现</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li-flow:state</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"A00"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:switch</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:expression</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:task</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"choicePayChannelTask"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:expression</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:case</span> <span class="hljs-attr">code</span>=<span class="hljs-string">"activeWithhold"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:next-status</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"A20"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:case</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:case</span> <span class="hljs-attr">code</span>=<span class="hljs-string">"overdueWithhold"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:next-status</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"A15"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:case</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:switch</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:state</span>&gt;</span>
</code></pre>
<p>上述的流程表示，如果 <code>choicePayChannelTask</code> 的返回值是 <code>activeWithhold</code>，下一个任务就从 <code>A20</code> 开始，以此类推，你可以定义无数个 <code>case</code>。而 <code>choicePayChannelTask</code> 就是一个简单的 <code>Spring Bean</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component("choicePayChannelTask")</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChoicePayChannelTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlowTxnTask</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(FlowTxnContext txnCtx, Object reqParas)</span> <span class="hljs-keyword">throws</span> AppBizException {
        log.info(<span class="hljs-string">"choicePayChannelTask"</span>);
        <span class="hljs-comment">//...业务逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"activeWithhold"</span>;
    }
}
</code></pre>
<h3 data-id="heading-13">流程切换</h3>
<p>很多时候我们的业务流程非常复杂，复杂到将他们定义在多个 <code>xml</code> 文件中才会看起来相对清晰，这个时候我们需要从一个 <code>diagram</code> 流程跳转到另一个 <code>diagram</code> 流程，我们可以使用 <code>&lt;li-flow:goto&gt;</code> 来实现</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li-flow:state</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"S00"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li-flow:goto</span> <span class="hljs-attr">next-status</span>=<span class="hljs-string">"D:biz-ins-cash-mas.repay-success-flow/S01"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li-flow:state</span>&gt;</span>
</code></pre>
<p><code>next-status</code> 的值规则为 <code>"D:" + 你要跳转的 diagram 的 id +"/"+ begin-status</code>，当流程执行到 <code>S00</code> 状态时，会自动调整到另一个流程引擎继续执行。</p>
<h3 data-id="heading-14">流程暂停</h3>
<p>在遇到我们预知的系统异常流程，通常我们需要让流程不流转到终态，但是又不想让流程结束，只是想单纯的暂时暂停，这时候我们可以让流程走到一个空任务节点，等待后续人工介入补偿。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 等待流程 后续补偿机制完成 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">inf-dte:state</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"W"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">inf-dte:task</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"emptyRepayTask"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">inf-dte:state</span>&gt;</span>
</code></pre>
<p>在这个空的 <code>task</code> 中我们什么也不做，流程会暂停等待事件唤醒（人工介入）</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyRepayTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlowTxnTask</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(FlowTxnContext context, Object arg)</span> <span class="hljs-keyword">throws</span> AppBizException {
        log.info(<span class="hljs-string">"EmptyRepayTask#execute txnId-{}"</span>,context.getTxnId());
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<h3 data-id="heading-15">业务补偿</h3>
<p>很多时候发生人为不可控的事情，我们需要对交易流程补偿处理。例如资方扣款操作异常，用户第一天还款成功，资方第二天才把扣款的结果告诉我们。这种情况是不能继续走流程的，因为凌晨的生息导致用户账单变化了，那么这个还款金额就无法核销掉用户的账单。</p>
<p>这种情况我们都是检测到跨天还款结果通知，挂起流程，告警通知研发。要修复这个问题，我们只需要将跨的这一天的利息或者罚息给抹掉，然后从指定的状态节点重新启动流程即可。</p>
<p>参考前面的事件唤醒，我们新增一个人工补偿节点</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!--人工补偿--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">li-flow:event-node</span> <span class="hljs-attr">event-type</span>=<span class="hljs-string">"repay-flow-compensation-event"</span> <span class="hljs-attr">event-handler</span>=<span class="hljs-string">"repayCompensationHandler"</span>/&gt;</span>
</code></pre>
<p>定义处理器</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepayCompensationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventHandler</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">onEvent</span><span class="hljs-params">(String eventType, String currentStatus, FlowTxnContext ctx)</span> {
       log.info(<span class="hljs-string">"Start repay compensation, currentStatus={}"</span>, currentStatus);
       <span class="hljs-type">String</span> <span class="hljs-variable">compensateStatus</span> <span class="hljs-operator">=</span> ctx.getString(<span class="hljs-string">"compensateStatus"</span>);
       <span class="hljs-keyword">return</span> compensateStatus;
    }

}
</code></pre>
<p>然后暴露一个接口给后台即可，接口的实现就是调用流程引擎的事件拉起方法</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 补偿接口，让当前流程从任何一个状态拉起流程引擎继续执行
 * 注意在这里 flow_transaction 表要改 diagram_id 字段到你的目标状态所属的 diagram
 * flow_transaction.run_flag 要改成 0
 * */</span>
<span class="hljs-meta">@GetMapping("/test4")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam("repayNo")</span> String repayNo,<span class="hljs-meta">@RequestParam("status")</span> String status)</span>{
    <span class="hljs-type">CashRepayApply</span> <span class="hljs-variable">cashRepayApply</span> <span class="hljs-operator">=</span> cashRepayApplyMapper.selectOne(Wrappers.&lt;CashRepayApply&gt;lambdaQuery().eq(CashRepayApply::getApplyNo, repayNo));
    cashRepayApply.addExtAttr(<span class="hljs-string">"compensateStatus"</span>, status);
    <span class="hljs-comment">//先把目标状态更新到扩展字段，</span>
    cashRepayApplyMapper.updateById(cashRepayApply);
    distributedTxnEngine.signalEventToTxn(<span class="hljs-string">"repay-flow-compensation-event"</span>, repayNo,TxnType.REPAY);
}
</code></pre>
<p>在这之前我们要确保这笔交易的流程引擎目前的状态是 <code>停止</code> 即 <code>flow_transaction_lock.flag = 1</code>，并且你要补偿的状态节点是属于当前流程引擎 <code>diagram</code> 的。</p>
<h2 data-id="heading-16">踩坑经验</h2>
<p>关于 <code>li-flow</code> 你需要有以下认识。</p>
<ul>
<li>使用 <code>li-flow</code> 流程，主表业务没有 “事务回滚” 的概念，你可以这么理解。只要流程启动，必定会有一条交易数据，区别是这条数据的状态是初始化、处理中、成功还是失败。</li>
<li>第一个 <code>state</code> 节点建议只放初始化任务，并且这个 state 里面不能跨服务调用，不能有明显可预期的异常代码逻辑。说白了你应该只有以下代码</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/930f58de2d494f40ac554dde57ad5dc1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316110&amp;x-signature=kCn6Nz50Os%2BaoYsmZEdd0LikcbA%3D" alt="image.png" loading="lazy"/>
因为 一个 <code>state</code> 节点走完才会保存交易数据到数据库，如果第一个 <code>state</code> 节点报错，直接跳转到异常处理器中，可能会因为缺少基础的交易字段引发异常处理器也发生异常，从而循环走异常处理器，造成死循环。</p>
<ul>
<li><code>li-flow</code> 适合的应用场景是你的业务流程非常长，并且很多节点的结果不是自己方所能控制的，例如银行扣款结果的通知。</li>
<li><code>li-flow</code> 中每一个业务节点的 <code>task</code>，原则上来说都需要做幂等，不然事件拉起或者处理异常流程需要重新拉起流程（补偿）的时候会有问题</li>
<li>除了流程引擎第一个初始化的 Task，其他 Task 不要使用流程请求入参 <code>CashRepaySubmitRequest request = (CashRepaySubmitRequest) arg;</code>，因为我们可以在任意节点用事件唤醒拉起流程，这样拉起流程入参是空的，导致无法事件唤醒，如果需要用到其中的参数就从流程上下文获取，贯穿整个流程的 <code>context</code> 上下文中保存了所有信息</li>
</ul>
<h2 data-id="heading-17">li-flow 的核心</h2>
<h3 data-id="heading-18">xml 解析器</h3>
<p>在 <code>spring.handlers</code> 文件中配置了 <code>xml</code> 命名空间解析器</p>
<pre><code class="hljs language-ruby" lang="ruby">http\<span class="hljs-symbol">://www</span>.sunyuchao.com/schema/sunyuchao/flow-engine=com.li.flow.autoconfigure.config.<span class="hljs-title class_">FlowEngineNamespaceHandler</span>
</code></pre>
<p>这里面注册了一个继承 <code>BeanDefinitionParser</code> 的 <code>DiagramBeanParser</code> 构造 <code>xml</code> 中的 <code>diagram</code> 以及子标签 <code>state</code>、<code>task</code> 等。</p>
<h3 data-id="heading-19">交易引擎入口</h3>
<p><code>DistributedTxnEngine</code> 是交易引擎类，提供流程的启动入口，提供默认实现。</p>
<h3 data-id="heading-20">引擎工厂</h3>
<p><code>DiagramFactory</code> 是引擎工厂，用来构造引擎 <code>diagram</code> 中的元素，将内部相关的结构（<code>事件处理器、异常处理器、任务</code>）赋上对应的 <code>Spring Bean</code> 实例，提供默认实现</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4e1f2ef34134a29bae80bb7c4aaf4d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316110&amp;x-signature=Mcv0rCut1cuUch4KceRHMi0l0m8%3D" alt="d8a1fcfa39ae9c6e27fcbc8c016583df.png" loading="lazy"/></p>
<h3 data-id="heading-21">状态执行器</h3>
<p><code>FlowStateExecutor</code> 是流程的执行器，根据请求类型不同执行不同的处理逻辑。例如本次流程是事件处理、异常处理、还是正常流程节点。</p>
<h3 data-id="heading-22">任务接口</h3>
<p>本质上流程里面所有的代码执行都是执行不同的任务，<code>Task</code> 是顶层接口，底下分别有实现类为 <code>GotoTask</code>、<code>NextStatusTask</code>、<code>SpringBeanTask</code>、<code>SwitchTask</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6f9f2f6f4274a73881cd38a785802fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316110&amp;x-signature=VdmKbR5oR%2F89cUEg39GvofnMY70%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-23">交易轨迹</h3>
<p><code>flow_state</code> 表记录了，流程引擎走过的每一个状态节点，当前处于哪个状态节点</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/84703f768cb54610a6f0fd24e3dfa105~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316110&amp;x-signature=FLPiUirp1ipyTa4939BLIIhiVco%3D" alt="image.png" loading="lazy"/></p>
<p><code>flow_transaction</code> 表记录了流程引擎的一些基本信息，当前处于哪一个 <code>diagram</code> 流程、当前状态、开始时间、异常标记、流程结束时间等</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e541306c56ec423e81b467b92c614ff1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769316110&amp;x-signature=xmuWvRlIf2F2ZA7lNRfo9cpDV64%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-24">结语</h2>
<p>待过两家信贷公司，不得不说，这个流程引擎真是太适合小贷业务了，本质上实现原理不复杂，但是我很佩服我们 <code>CTO</code> 能想到这个方案并且推动落地投入生产使用，他真的是大牛！</p>
<p>虽然源码不能公开，但是如果你对流程引擎感兴趣，参考这篇文章应该可以自己研发出来一个符合公司业务的流程引擎。本质内容就是 <strong>流程节点结构约束定义 + 流程节点的死循环执行</strong> 。</p>
<h3 data-id="heading-25">如果这篇文章对你有帮助，记得点赞加关注！你的支持就是我继续创作的动力！</h3></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[本地大模型主流部署工具指南]]></title>    <link>https://juejin.cn/post/7595974133097676834</link>    <guid>https://juejin.cn/post/7595974133097676834</guid>    <pubDate>2026-01-18T04:46:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595974133097676834" data-draft-id="7595974133097365538" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="本地大模型主流部署工具指南"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-18T04:46:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一诺滚雪球"/> <meta itemprop="url" content="https://juejin.cn/user/2824015112318094"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            本地大模型主流部署工具指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2824015112318094/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一诺滚雪球
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T04:46:34.000Z" title="Sun Jan 18 2026 04:46:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 前言</h2>
<h3 data-id="heading-1">1.1 为什么现在必试本地部署？</h3>
<p>想象一下：你的所有对话都留在电脑里，不用担心数据泄露；不用每句话都付费；地铁、野外等无网环境也能秒响应。这就是<strong>本地部署大模型的魅力</strong> —— 工具链已成熟，新手也能 10 分钟上手！</p>
<h3 data-id="heading-2">1.2 本地部署的核心优势</h3>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>[+] <strong>隐私绝对安全</strong></td><td>数据全程存储本地，无云端上传风险（适合商业机密、个人隐私）</td></tr><tr><td>[+] <strong>零使用成本</strong></td><td>一次性部署，无限次使用，避免 API 按调用量计费</td></tr><tr><td>[+] <strong>无网络依赖</strong></td><td>断网也能正常使用，响应延迟低至 80ms</td></tr><tr><td>[+] <strong>定制化自由</strong></td><td>可选择中文优化、轻量型、专业级等不同模型</td></tr><tr><td>[+] <strong>硬件适配多元</strong></td><td>6GB 显存即可运行 7B 模型，老电脑也能盘活</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-3">2. 五大主流工具深度对比（实测版）</h2>



























































<table><thead><tr><th>工具</th><th>定位</th><th>难度</th><th>适合人群</th><th>核心优势</th><th>显存要求（7B模型）</th><th>最新特性</th></tr></thead><tbody><tr><td><strong>Ollama</strong></td><td>命令行部署神器</td><td>[<em>][</em>]</td><td>开发者、技术爱好者</td><td>一行命令部署、API兼容OpenAI、模型丰富</td><td>4GB+（INT4量化）</td><td>修复高危漏洞、支持OpenWebUI可视化、国内镜像</td></tr><tr><td><strong>LM Studio</strong></td><td>图形界面王者</td><td>[*]</td><td>普通用户、Mac用户</td><td>即开即用、内置模型市场、中文优化</td><td>6GB+</td><td>MLX 2.0加速、ModelScope国内镜像、文档对话</td></tr><tr><td><strong>Jan</strong></td><td>免费跨平台桌面应用</td><td>[*]</td><td>个人用户、预算有限者</td><td>完全免费、无广告、本地+云端混合部署</td><td>5GB+</td><td>支持RPU/NPU硬件加速、模型热切换</td></tr><tr><td><strong>GPT4All</strong></td><td>低配电脑救星</td><td>[*]</td><td>老电脑用户、入门新手</td><td>资源占用极低、CPU/GPU双支持、安装包小巧</td><td>3GB+（INT4量化）</td><td>新增中文轻量模型库、离线缓存优化</td></tr><tr><td><strong>LocalAI</strong></td><td>企业级API替代方案</td><td>[<em>][</em>][*]</td><td>企业、开发者、团队</td><td>1:1兼容OpenAI API、权限管理、分布式部署</td><td>8GB+</td><td>支持千亿参数模型、国产化芯片适配、监控告警</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-4">3. 五大主流工具详解</h2>
<h3 data-id="heading-5">3.1 Ollama - 开发者首选・安全增强版</h3>
<h4 data-id="heading-6">3.1.1 定位</h4>
<p>最简单的命令行部署工具，开发者效率神器</p>
<h4 data-id="heading-7">3.1.2 核心优势</h4>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>极速部署</strong></td><td>一行命令完成安装 + 模型启动，无需复杂配置</td></tr><tr><td><strong>API无缝兼容</strong></td><td>自带 OpenAI 格式 API，现有项目可直接迁移</td></tr><tr><td><strong>全平台覆盖</strong></td><td>Mac（M1/M2/M3）、Linux、Windows 10+ 全支持</td></tr><tr><td><strong>模型生态丰富</strong></td><td>内置 Qwen2.5、DeepSeek-V3、Llama 3 等上百款模型</td></tr><tr><td><strong>安全升级</strong></td><td>修复未授权访问漏洞，支持 API 密钥认证</td></tr></tbody></table>
<h4 data-id="heading-8">3.1.3 实操教程（含国内加速 + 安全配置）</h4>
<h5 data-id="heading-9">3.1.3.1 安装步骤</h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># macOS / Linux 一键安装</span>
curl -fsSL https://ollama.com/install.sh | sh

<span class="hljs-comment"># Windows 安装</span>
<span class="hljs-comment"># 1. 官网下载：https://ollama.com/，勾选「Add to PATH」</span>
<span class="hljs-comment"># 2. 终端验证：ollama --version（显示v0.12.0+即成功）</span>
</code></pre>
<h5 data-id="heading-10">3.1.3.2 国内加速配置（必做）</h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 新建bat文件（Windows管理员运行）/ 终端执行（Mac/Linux）</span>
<span class="hljs-built_in">export</span> OLLAMA_MODEL_SERVER=https://mirror.ollama.com  <span class="hljs-comment"># 国内镜像</span>
<span class="hljs-built_in">export</span> OLLAMA_API_KEY=your_strong_password123  <span class="hljs-comment"># 设置访问密钥（防泄露）</span>
<span class="hljs-built_in">export</span> OLLAMA_HOST=127.0.0.1:11434  <span class="hljs-comment"># 仅本地访问</span>
ollama serve
</code></pre>
<h5 data-id="heading-11">3.1.3.3 常用命令（中文优先）</h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 拉取中文最优模型（Qwen2.5-7B INT4量化版）</span>
ollama pull qwen2.5:7b-chat-q4_0

<span class="hljs-comment"># 启动对话（秒级响应）</span>
ollama run qwen2.5:7b-chat-q4_0

<span class="hljs-comment"># 开启API服务（支持编程调用）</span>
ollama serve

<span class="hljs-comment"># 模型管理</span>
ollama list  <span class="hljs-comment"># 查看已安装模型</span>
ollama <span class="hljs-built_in">rm</span> qwen2.5  <span class="hljs-comment"># 删除无用模型</span>
ollama update  <span class="hljs-comment"># 更新Ollama到最新版</span>
</code></pre>
<h5 data-id="heading-12">3.1.3.4 编程调用示例</h5>
<p><strong>浏览器环境（原生 Fetch + 流式响应）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 流式响应（实时输出结果）</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callOllamaStream</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> apiKey = <span class="hljs-string">"your_strong_password123"</span>;
  <span class="hljs-keyword">const</span> prompt = <span class="hljs-string">"写Python数据可视化代码"</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:11434/v1/chat/completions"</span>, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
      <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
        <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${apiKey}</span>`</span>
      },
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
        <span class="hljs-attr">model</span>: <span class="hljs-string">"qwen2.5:7b-chat-q4_0"</span>,
        <span class="hljs-attr">messages</span>: [{ <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: prompt }],
        <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>
      })
    });

    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP错误! 状态码: <span class="hljs-subst">${response.status}</span>`</span>);
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">body</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"流式响应不支持"</span>);

    <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();
    <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">"utf-8"</span>);
    <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
      <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">const</span> chunk = decoder.<span class="hljs-title function_">decode</span>(value);
      <span class="hljs-comment">// 解析SSE格式响应</span>
      <span class="hljs-keyword">const</span> lines = chunk.<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-title function_">trim</span>() !== <span class="hljs-string">""</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) {
        <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"data: "</span>)) {
          <span class="hljs-keyword">const</span> data = line.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>);
          <span class="hljs-keyword">if</span> (data === <span class="hljs-string">"[DONE]"</span>) <span class="hljs-keyword">continue</span>;
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);
            <span class="hljs-keyword">if</span> (json.<span class="hljs-property">choices</span>?.[<span class="hljs-number">0</span>]?.<span class="hljs-property">delta</span>?.<span class="hljs-property">content</span>) {
              <span class="hljs-keyword">const</span> content = json.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">delta</span>.<span class="hljs-property">content</span>;
              result += content;
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content); <span class="hljs-comment">// 实时输出</span>
              <span class="hljs-comment">// 可在这里更新DOM显示</span>
            }
          } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"解析响应失败:"</span>, e);
          }
        }
      }
    }
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"调用失败:"</span>, error);
  }
}

<span class="hljs-comment">// 执行调用</span>
<span class="hljs-title function_">callOllamaStream</span>();
</code></pre>
<p><strong>Node.js 环境（axios + 流式响应）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 先安装依赖：npm install axios</span>
<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callOllamaNodeStream</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> apiKey = <span class="hljs-string">"your_strong_password123"</span>;
  <span class="hljs-keyword">const</span> prompt = <span class="hljs-string">"写Python数据可视化代码"</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(
      <span class="hljs-string">"http://localhost:11434/v1/chat/completions"</span>,
      {
        <span class="hljs-attr">model</span>: <span class="hljs-string">"qwen2.5:7b-chat-q4_0"</span>,
        <span class="hljs-attr">messages</span>: [{ <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: prompt }],
        <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>
      },
      {
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
          <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${apiKey}</span>`</span>
        },
        <span class="hljs-attr">responseType</span>: <span class="hljs-string">"stream"</span>
      }
    );

    <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;
    response.<span class="hljs-property">data</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">"data"</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> lines = chunk.<span class="hljs-title function_">toString</span>(<span class="hljs-string">"utf-8"</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-title function_">trim</span>() !== <span class="hljs-string">""</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) {
        <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"data: "</span>)) {
          <span class="hljs-keyword">const</span> data = line.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>);
          <span class="hljs-keyword">if</span> (data === <span class="hljs-string">"[DONE]"</span>) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);
            <span class="hljs-keyword">if</span> (json.<span class="hljs-property">choices</span>?.[<span class="hljs-number">0</span>]?.<span class="hljs-property">delta</span>?.<span class="hljs-property">content</span>) {
              <span class="hljs-keyword">const</span> content = json.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">delta</span>.<span class="hljs-property">content</span>;
              result += content;
              process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(content); <span class="hljs-comment">// 实时输出</span>
            }
          } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"解析响应失败:"</span>, e);
          }
        }
      }
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      response.<span class="hljs-property">data</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">"end"</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(result));
    });
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"调用失败:"</span>, error);
  }
}

<span class="hljs-comment">// 执行调用</span>
<span class="hljs-title function_">callOllamaNodeStream</span>();
</code></pre>
<h4 data-id="heading-13">3.1.4 适合场景</h4>
<ul>
<li>开发者集成 AI 能力到项目中</li>
<li>快速测试不同模型效果</li>
<li>小团队搭建本地 API 服务</li>
<li>习惯命令行操作的技术用户</li>
</ul>
<h4 data-id="heading-14">3.1.5 避坑指南</h4>





















<table><thead><tr><th>[x] 不要</th><th>[+] 建议</th></tr></thead><tbody><tr><td>直接暴露公网</td><td>必须设置 API 密钥 + 限制本地访问（防范 CNVD-2025-04094 漏洞）</td></tr><tr><td>-</td><td>显存不够：优先选择 INT4 量化模型（命令后加 -q4_0）</td></tr><tr><td>-</td><td>启动失败：Windows 用户需安装 Microsoft C++ 生成工具</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-15">3.2 LM Studio - 普通用户最佳选择・图形界面王者</h3>
<h4 data-id="heading-16">3.2.1 定位</h4>
<p>像用 ChatGPT 一样简单，零代码门槛</p>
<h4 data-id="heading-17">3.2.2 核心优势</h4>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>现代化 UI</strong></td><td>拖拽操作，可视化管理模型，新手无压力</td></tr><tr><td><strong>内置模型市场</strong></td><td>搜索「中文」即可筛选最优模型，自动推荐硬件适配版本</td></tr><tr><td><strong>国内优化</strong></td><td>内置 ModelScope 镜像，10GB 模型 5 分钟下载完成</td></tr><tr><td><strong>文档对话</strong></td><td>上传 PDF/Word 自动解析，支持 10 万 Token 长文本问答</td></tr><tr><td><strong>硬件加速</strong></td><td>Apple Silicon/M3 芯片启用 MLX 2.0，性能超 RTX 4090 2.2 倍</td></tr></tbody></table>
<h4 data-id="heading-18">3.2.3 安装使用（Windows/Mac 通用）</h4>
<ol>
<li>官网下载：<a href="https://link.juejin.cn?target=https%3A%2F%2Flmstudio.ai%2F%25EF%25BC%2588%25E6%2594%25AF%25E6%258C%2581" target="_blank" title="https://lmstudio.ai/%EF%BC%88%E6%94%AF%E6%8C%81" ref="nofollow noopener noreferrer">lmstudio.ai/（支持</a> M3 / 锐龙 AI 处理器）</li>
<li>安装后打开，点击左侧「Model Hub」，搜索「qwen2.5」「deepseek-r1」</li>
<li>选择「适合本机的版本」（如 INT4/FP8），点击「Download」</li>
<li>下载完成后，点击「Chat」即可开始对话</li>
<li>进阶功能：「Settings」→「Hardware」启用「MLX Acceleration」（Mac 用户）</li>
</ol>
<h4 data-id="heading-19">3.2.4 适合场景</h4>
<ul>
<li>不想碰命令行的普通用户</li>
<li>Mac 用户（硬件加速优化最佳）</li>
<li>需要可视化管理多模型</li>
<li>文档分析、日常聊天、办公辅助</li>
</ul>
<h4 data-id="heading-20">3.2.5 避坑指南</h4>





















<table><thead><tr><th>[x] 不要</th><th>[+] 建议</th></tr></thead><tbody><tr><td>盲目选大模型</td><td>根据硬件自动推荐的版本最优，避免显存不足</td></tr><tr><td>-</td><td>卡顿解决：关闭节能模式，启用「硬件加速」，关闭后台占用 GPU 的程序</td></tr><tr><td>-</td><td>中文优化：优先选择「Qwen2.5」「DeepSeek-R1」等原生中文模型</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-21">3.3 Jan - 完全免费・跨平台桌面应用</h3>
<h4 data-id="heading-22">3.3.1 定位</h4>
<p>零费用、无广告的本地 + 云端混合部署工具</p>
<h4 data-id="heading-23">3.3.2 核心优势</h4>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>100% 免费</strong></td><td>所有功能不限流，无付费墙</td></tr><tr><td><strong>混合部署</strong></td><td>一键切换本地模型（隐私优先）/ 云端模型（性能优先）</td></tr><tr><td><strong>极简设计</strong></td><td>界面清爽无广告，操作逻辑简单</td></tr><tr><td><strong>全平台支持</strong></td><td>Mac、Windows、Linux 无缝适配</td></tr><tr><td><strong>新特性</strong></td><td>支持锐龙 AI NPU、清微 RPU 硬件加速，显存占用降低 40%</td></tr></tbody></table>
<h4 data-id="heading-24">3.3.3 安装使用</h4>
<ol>
<li>官网下载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fjan.ai%2F%25EF%25BC%2588%25E5%25AE%2589%25E8%25A3%2585%25E5%258C%2585%25E4%25BB%2585" target="_blank" title="https://jan.ai/%EF%BC%88%E5%AE%89%E8%A3%85%E5%8C%85%E4%BB%85" ref="nofollow noopener noreferrer">jan.ai/（安装包仅</a> 20MB）</li>
<li>首次启动引导：选择「Local」（本地模式）→ 点击「Model Library」</li>
<li>搜索「qwen2.5-mini」（轻量中文模型），点击「Download」</li>
<li>下载完成后，直接在聊天框输入指令即可使用</li>
<li>混合模式切换：点击顶部「Cloud」，登录后可使用云端大模型（免费额度）</li>
</ol>
<h4 data-id="heading-25">3.3.4 适合场景</h4>
<ul>
<li>预算有限的个人用户</li>
<li>需要灵活切换本地 / 云端模型</li>
<li>注重隐私又想兼顾高性能</li>
<li>学生、职场新人日常办公</li>
</ul>
<h4 data-id="heading-26">3.3.5 避坑指南</h4>

















<table><thead><tr><th>[+] 建议</th></tr></thead><tbody><tr><td>本地模型选择：低配电脑优先选「3B/7B INT4」版本</td></tr><tr><td>下载慢：在「Settings」→「Model Sources」选择「ModelScope」镜像</td></tr><tr><td>启动慢：关闭「自动更新模型」，手动更新更省资源</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-27">3.4 GPT4All - 低配电脑救星・轻量之王</h3>
<h4 data-id="heading-28">3.4.1 定位</h4>
<p>专为老电脑 / 低配置设备优化，CPU 也能流畅运行</p>
<h4 data-id="heading-29">3.4.2 核心优势</h4>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>资源占用极低</strong></td><td>无需 GPU，4GB 内存即可运行 3B 中文模型</td></tr><tr><td><strong>轻量高效</strong></td><td>安装包仅 15MB，模型自动量化优化</td></tr><tr><td><strong>零门槛操作</strong></td><td>图形界面，双击启动，无需任何配置</td></tr><tr><td><strong>一体化功能</strong></td><td>集成聊天、文档分析、代码生成，无需额外插件</td></tr><tr><td><strong>中文升级</strong></td><td>新增 ChatGLM-3B、Qwen-2B-mini 等中文轻量模型</td></tr></tbody></table>
<h4 data-id="heading-30">3.4.3 安装使用</h4>
<ol>
<li>官网下载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgpt4all.io%2F%25EF%25BC%2588Windows%2FMac%2FLinux" target="_blank" title="https://gpt4all.io/%EF%BC%88Windows/Mac/Linux" ref="nofollow noopener noreferrer">gpt4all.io/（Windows/Ma…</a> 通用）</li>
<li>安装后打开，点击「Model Explorer」，筛选「Chinese」</li>
<li>选择「Qwen-2B-mini-INT4」（仅需 3GB 内存），点击「Download」</li>
<li>下载完成后，切换到「Chat」标签即可开始使用</li>
<li>性能优化：「Settings」→「Performance」选择「CPU+GPU 混合模式」</li>
</ol>
<h4 data-id="heading-31">3.4.4 适合场景</h4>
<ul>
<li>老电脑（5 年前配置）、无独立显卡用户</li>
<li>显存不足 4GB 的设备</li>
<li>仅需要基础对话、简单文档处理</li>
<li>临时使用、快速演示场景</li>
</ul>
<h4 data-id="heading-32">3.4.5 避坑指南</h4>





















<table><thead><tr><th>[x] 不要</th><th>[+] 建议</th></tr></thead><tbody><tr><td>选择 13B+ 大模型</td><td>低配置设备会卡顿甚至崩溃</td></tr><tr><td>-</td><td>中文效果：优先选「Qwen-2B-mini」「ChatGLM-3B」，避免原生英文模型</td></tr><tr><td>-</td><td>加载慢：将模型文件放在 SSD 硬盘，加载速度提升 3 倍</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-33">3.5 LocalAI - 企业级 API 替代方案・生产环境首选</h3>
<h4 data-id="heading-34">3.5.1 定位</h4>
<p>1:1 兼容 OpenAI API，企业内网部署神器</p>
<h4 data-id="heading-35">3.5.2 核心优势</h4>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>API 完全兼容</strong></td><td>无需修改代码，直接替换 OpenAI 接口地址</td></tr><tr><td><strong>企业级特性</strong></td><td>支持权限管理、用户认证、监控告警、日志审计</td></tr><tr><td><strong>高性能部署</strong></td><td>支持分布式集群、张量并行，吞吐量提升 10 倍</td></tr><tr><td><strong>数据安全</strong></td><td>完全本地化部署，符合等保三级、GDPR 合规要求</td></tr><tr><td><strong>国产化适配</strong></td><td>支持华为昇腾、清微 RPU、海光 CPU 等国产硬件</td></tr></tbody></table>
<h4 data-id="heading-36">3.5.3 企业级部署实操（Docker 版）</h4>
<h5 data-id="heading-37">3.5.3.1 环境要求</h5>





















<table><thead><tr><th>项目</th><th>要求</th></tr></thead><tbody><tr><td><strong>系统</strong></td><td>Ubuntu 22.04 LTS（推荐）/ CentOS 8</td></tr><tr><td><strong>硬件</strong></td><td>GPU 24GB 显存（A10G/H100）或 RPU TX81 加速卡</td></tr><tr><td><strong>依赖</strong></td><td>Docker 24.0+、Docker Compose</td></tr></tbody></table>
<h5 data-id="heading-38">3.5.3.2 部署命令</h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 创建挂载目录（存储模型和配置）</span>
<span class="hljs-built_in">mkdir</span> -p /localai/models /localai/config

<span class="hljs-comment"># 2. 编写docker-compose.yml</span>
<span class="hljs-built_in">cat</span> &gt; docker-compose.yml &lt;&lt;<span class="hljs-string">'EOF'</span>
version: <span class="hljs-string">"3"</span>
services:
  localai:
    image: localai/localai:latest
    ports:
      - <span class="hljs-string">"8080:8080"</span>
    volumes:
      - /localai/models:/models
      - /localai/config:/etc/localai
    environment:
      - MODELS_PATH=/models
      - API_KEY=your_enterprise_api_key  <span class="hljs-comment"># 企业级API密钥</span>
      - LOG_LEVEL=info
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 2  <span class="hljs-comment"># 2张GPU并行</span>
              capabilities: [gpu]
EOF

<span class="hljs-comment"># 3. 启动服务</span>
docker-compose up -d

<span class="hljs-comment"># 4. 下载模型（以Qwen2.5-13B为例）</span>
curl -L https://mirror.modelscope.cn/qwen/Qwen2.5-13B-Chat-GGUF/qwen2.5-13b-chat-q4_0.gguf -o /localai/models/qwen2.5-13b.gguf
</code></pre>
<h5 data-id="heading-39">3.5.3.3 API 调用示例</h5>
<p><strong>Node.js 生产环境调用（带错误处理）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 先安装依赖：npm install axios</span>
<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalAIClient</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">apiKey, baseUrl = <span class="hljs-string">"http://localhost:8080"</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">apiKey</span> = apiKey;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> = baseUrl;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">client</span> = axios.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">baseURL</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span>,
      <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
        <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.apiKey}</span>`</span>
      },
      <span class="hljs-attr">timeout</span>: <span class="hljs-number">30000</span> <span class="hljs-comment">// 30秒超时</span>
    });
  }

  <span class="hljs-comment">// 普通响应调用</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">chatComplete</span>(<span class="hljs-params">prompt, model = <span class="hljs-string">"qwen2.5-13b"</span></span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">client</span>.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/v1/chat/completions"</span>, {
        model,
        <span class="hljs-attr">messages</span>: [{ <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: prompt }],
        <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.7</span>,
        <span class="hljs-attr">max_tokens</span>: <span class="hljs-number">2048</span>
      });
      <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Chat完成调用失败:"</span>, {
        <span class="hljs-attr">status</span>: error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span>,
        <span class="hljs-attr">data</span>: error.<span class="hljs-property">response</span>?.<span class="hljs-property">data</span>,
        <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>
      });
      <span class="hljs-keyword">throw</span> error;
    }
  }

  <span class="hljs-comment">// 流式响应调用（适合长文本）</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">chatStream</span>(<span class="hljs-params">prompt, model = <span class="hljs-string">"qwen2.5-13b"</span>, callback</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">client</span>.<span class="hljs-title function_">post</span>(
        <span class="hljs-string">"/v1/chat/completions"</span>,
        {
          model,
          <span class="hljs-attr">messages</span>: [{ <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: prompt }],
          <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.7</span>,
          <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>
        },
        { <span class="hljs-attr">responseType</span>: <span class="hljs-string">"stream"</span> }
      );

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> fullContent = <span class="hljs-string">""</span>;
        response.<span class="hljs-property">data</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">"data"</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> lines = chunk.<span class="hljs-title function_">toString</span>(<span class="hljs-string">"utf-8"</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-title function_">trim</span>() !== <span class="hljs-string">""</span>);
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) {
            <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"data: "</span>)) {
              <span class="hljs-keyword">const</span> data = line.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>);
              <span class="hljs-keyword">if</span> (data === <span class="hljs-string">"[DONE]"</span>) <span class="hljs-keyword">return</span>;
              <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);
                <span class="hljs-keyword">const</span> content = json.<span class="hljs-property">choices</span>?.[<span class="hljs-number">0</span>]?.<span class="hljs-property">delta</span>?.<span class="hljs-property">content</span>;
                <span class="hljs-keyword">if</span> (content) {
                  fullContent += content;
                  callback?.(content); <span class="hljs-comment">// 实时回调输出</span>
                }
              } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"解析流式响应失败:"</span>, e);
              }
            }
          }
        });

        response.<span class="hljs-property">data</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">"end"</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(fullContent));
        response.<span class="hljs-property">data</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">"error"</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(err));
      });
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"流式调用失败:"</span>, error);
      <span class="hljs-keyword">throw</span> error;
    }
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testLocalAI</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalAIClient</span>(<span class="hljs-string">"your_enterprise_api_key"</span>);

  <span class="hljs-comment">// 1. 普通调用</span>
  <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">chatComplete</span>(<span class="hljs-string">"生成企业年度总结模板"</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"普通调用结果:"</span>, result1);

  <span class="hljs-comment">// 2. 流式调用</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"流式调用结果:"</span>);
  <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">chatStream</span>(<span class="hljs-string">"生成企业年度总结模板"</span>, <span class="hljs-string">"qwen2.5-13b"</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(chunk); <span class="hljs-comment">// 实时输出</span>
  });
}

<span class="hljs-comment">// 执行测试</span>
<span class="hljs-title function_">testLocalAI</span>();
</code></pre>
<h4 data-id="heading-40">3.5.4 适合场景</h4>
<ul>
<li>企业内部 AI 服务部署</li>
<li>需要替换 OpenAI API 的现有项目</li>
<li>政务、金融、医疗等敏感行业</li>
<li>高并发、高可用的生产环境</li>
</ul>
<h4 data-id="heading-41">3.5.5 避坑指南</h4>

























<table><thead><tr><th>[x] 不要</th><th>[+] 建议</th></tr></thead><tbody><tr><td>个人用户跟风</td><td>配置复杂，维护成本高</td></tr><tr><td>-</td><td>性能优化：启用「张量并行」（--tensor-parallel-size 2），多 GPU 分担负载</td></tr><tr><td>-</td><td>模型选择：优先选 GGUF 格式量化模型，显存占用降低 50%</td></tr><tr><td>-</td><td>安全配置：必须设置 API 密钥，限制内网访问，定期更新镜像</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-42">4. 总结</h2>
<p>最后总结一下：</p>
<ul>
<li><strong>Ollama</strong>：开发者集成 AI 能力到项目，快速测试模型，搭建本地 API 服务</li>
<li><strong>LM Studio</strong>：普通用户零门槛使用，可视化管理模型，文档分析和日常办公</li>
<li><strong>Jan</strong>：预算有限的个人用户，灵活切换本地/云端模型，免费无广告</li>
<li><strong>GPT4All</strong>：老电脑和低配设备，仅需基础对话和简单文档处理</li>
<li><strong>LocalAI</strong>：企业内部 AI 服务部署，替换 OpenAI API，满足安全合规要求</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[25 年终总结：技术水平飞跃]]></title>    <link>https://juejin.cn/post/7595894884958289971</link>    <guid>https://juejin.cn/post/7595894884958289971</guid>    <pubDate>2026-01-18T04:47:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595894884958289971" data-draft-id="7595873251164700713" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="25 年终总结：技术水平飞跃"/> <meta itemprop="keywords" content="后端,程序员,人工智能"/> <meta itemprop="datePublished" content="2026-01-18T04:47:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="方圆想当图灵"/> <meta itemprop="url" content="https://juejin.cn/user/386633160473101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            25 年终总结：技术水平飞跃
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/386633160473101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    方圆想当图灵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T04:47:17.000Z" title="Sun Jan 18 2026 04:47:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 <strong>方圆</strong>。如往年一样，对去年进行回顾总结。我觉得 25 年是我技术水平进步最多的一年，也应了年初我在 Github 上给自己写下的寄语：<strong>“Practice and protect my eyes”</strong>，技术的提升几乎全部来自于主动解决工作中遇到的问题，但为了技术的提升也不要忽视眼部健康。接下来的内容主要关于技术成长，对 AI 落地业务的感受以及生活感悟，希望也能对大家有一些启发。</p>
<h3 data-id="heading-0">技术成长</h3>
<p>如开篇所讲的，25 年是我工作将近 4 年来技术成长最多的一年。年初因为大部门定下了针对现有应用做技术改造的规划，也恰好部门内核心应用存在痛点，再加上部门 Leader 看好我的潜力，相信我能做好这件事，天时地利人和，所以主持技改这件事情便自然而然落到我的头上。</p>
<p>要被技改的应用承接面向 C 端的查询流量，促销峰值时 QPS 能达到大几十万，而且性能要求极高，在部分 C 端场景要求 TP999 稳定在 20ms 以内，可以说是非常核心的服务。但是这么核心的应用怎么能说技改就能技改呢？</p>
<p>实际上不改还真不行，我先问大家一个问题：如何才能保证在几十万 QPS 下满足 TP999 稳定在 20ms 以内？了解的大家可能会回答，需要多实例部署并且实例内采用本地缓存避免网络开销时间来应对复杂的查询请求，我们正是采用了这个方案。在理论上这的确是解决这种场景下问题的最好方式，但是也伴随着比较难解决的数据一致性问题：如何才能保证数据库数据发生变更后能及时同步到多个查询服务实例的本地内存中？如何才能保证每个服务实例的本地缓存都更新成功？现有服务正是存在这样的数据一致性问题：业务人员上午在系统更新数据，发现数据在下午查询时偶尔查询成功偶尔查询失败，这是因为部分实例本地缓存更新成功部分实例缓存更新失败，那我们研发如何排查这种数据不一致的问题呢？答案是没办法排查，因为链路太长了，即使发现问题也没有快速恢复的办法，快速解决问题的方式是把各个实例分批次重启一遍，让它们重新拉取最新的全量数据。业务压力和难以维护的系统是本次技改的根本原因。</p>
<p>那大家可能要问了，既然要技改了，咱们能不能不用本地缓存了，咱用分布式缓存（如 Redis）行不行？这样是不是也能满足性能要求并且解决数据一致性问题？在不了解业务的情况下，理论上可行，但对于我们的业务来说，是不可行的，因为这个查询接口要用到至少四项缓存，多次与 Redis 的交互产生的网络开销势必会影响查询性能（TP999 20ms）。此外，我们的这个服务是异地多机房部署的，其他服务调用我们的服务会采用同机房垂直调用的方式来提高查询性能，那么如果采用 Redis 的话，是不是也要多机房部署 Redis 才能满足机房垂直调用的性能要求？相应地，如何将现有数据写入 Redis 也是比较难解决的问题，比如某项数据大概有 80w+ 条，该怎么写入到 Redis？这就又涉及到了如何分片的问题，即便是考虑好了 Redis 分片方案，大概率原有接口逻辑中读取缓存的逻辑需要变，那么本次技改可能就属于颠覆式的重构了，如果这样的话大家心里都会有一个问题：“这么大的改动谁能保证安全性？而因此造成的损失又该由谁来承担呢？”，所以本次技改并 <strong>不是为系统大刀阔斧的动手术，而是望闻问切，定位系统病灶之后对症下药</strong>，这也是本次技改中我们的架构师带给我的启示，解决问题的同时保证改动最小，将风险控制在预期范围内，并做好回滚预案。</p>
<p>为了这次技改能够高质量的完成，<a href="https://juejin.cn/post/7461597730152300581" target="_blank" title="https://juejin.cn/post/7461597730152300581">阅读了 Caffeine 等一系列本地缓存的源码</a>，为了保证本地缓存更新的高可用，阅读了 Nacos 的源码，也因此成为了 Nacos 开源项目的 Contributor，当然这是意外收获，最初的想法只是想参考 Nacos 是如何保证又稳又快刷新配置的，我觉得这对我们做技改会有帮助。在做方案设计的时候这些内容都给了灵感，并且之前几年学习过的关于分布式系统的知识也泉涌出来，“数据一致性”，“分片”和“高可用设计”等等都不再是空中楼阁而是真正辅助工程落地的理论指导。这次技改大概在 25 年春节前完成了方案设计，3 月下旬上线，期间没有测试工程师介入，我们自己做好了完善的验证和上线方案，上线后也未产生问题，是一次非常振奋人心的经历，对于我而言也是一次难得的技术实践，终于让我自己感受到自己好像真的在技术上懂一些东西了，这也是我在工作这几年内一直苦苦追寻的东西。</p>
<p>后来，为了解决部门内慢 SQL 定位的问题，通过 Mybatis 的拦截器机制开发了 SQL 染色插件，标记业务执行堆栈，能够一眼定位业务场景；为了解决应用启动时接口响应慢的问题，调研并实现了应用启动时流量预热的方案，因为部分框架中的组件是懒加载的，导致启动时接口上线那一刻触发组件的初始化，导致最初进来的流量接口响应耗时很长，如果借助流量预热完成这一系列组件的预加载，再发布接口便能解决这个问题；为了解决 AI IDE 无法跨项目和在 Jar 包中无法读取源码的问题，<a href="https://juejin.cn/post/7581004702928060425" target="_blank" title="https://juejin.cn/post/7581004702928060425">开发并开源了 MCP Server EasyCodeReader</a>，现在在 Github 上已经有了 105+ Star，如果是 Java 开发者的话，这个 MCP 至少能提高 30% 的开发效率，也因为这个 MCP 也获得了集团的一些 AI 实践奖项...</p>
<p>这一年解决了很多问题，这让我觉得 <strong>“从问题中来，到问题中去”是学习技术和技术成长最快速的一条路</strong>，技术无法脱离工程实践，脱离工程实践的技术也迟早会被遗忘在记忆的长河中。不断地发现问题、解决问题，这不仅仅会带来技术水平的提升，而且还会赢得部门内同事的尊重。这也让我得到了更多的机会，让我有了更高的技术视野，不再将眼光只放在一段段代码上，而是从更高的角度考虑系统设计和需求的规划，考虑的不再是自己技术的进步，而是如何更好的带着部门内一群人进步，大家的能力提升相比于个人能力的一超多强，对于部门来说价值是更大的。</p>
<h3 data-id="heading-1">AI 落地业务实践</h3>
<p>在 25 年 11 的时候部门想要在电销场景使用大模型辅助完成客服的话术质检，往往客服为了达成销售，会对商品做一些不实的描述，而顾客因为这些描述购买商品而未达预期会引起强烈的客诉。最初的质检约束是人工抽检，存在着人力成本高，检查不全面和质检效率低的问题，如果采用大模型的话能够很好的解决这些问题。所以我借助集团提供的智能体平台（类似于 Dify），搭建了质检智能体，按照一个个规则维度拆分为工作流，质检时并行运行并会返回 JSON 结果供工程端处理。</p>
<p>但是，这与日常的软件开发有很大的不同：模型给的结果反馈 <strong>充满了不确定性</strong>，日常开发中调整某段逻辑在没有 bug 的情况下通常都能得到预期的效果，而在搭建智能体或工作流时，提示词的改动不一定会得到预期的结果，而且还可能会影响原有场景的准确性，这是非常考验耐心的，也是最初让我头疼的一点，我该如何保证本次的提示词变更是有效的？保证它既不影响历史用例的质检又能处理新的场景呢？所以 <strong>维护用例集非常重要</strong>，用例集中包含正向和负向的用例，每次工作流变更都需要重新回归验证所有用例，保证本次改动的有效性，但是集团内又没有提供好用的平台怎么办？所以这部分内容是依靠字节的 PromptPilot 来完成的，其中的用例集管理和提示词智能优化为我们提高质检准确率提供了很大的帮助，唯一痛点是用例集合需要手工录入，不能完成系统间的联动，如果这个平台是我们内部自建的话，在质检系统中发现典型用例之后，通过接口形式自动录入平台的用例集，自动进行提示词优化，形成一种“自学习”的模式，这还会节省部分人力成本。但实际想想这其实是一项工程化的能力，不仅仅是用例集管理存在这个问题，集团提供的智能体平台搭建工作流也存在诸多不便，目前搭建工作流是以低代码的形式，开发起来在页面上拖拖拽拽很不方便，提供的节点能力也非常有限，比如说 Python 代码节点，它会限定导入包的范围，一些常有的库是没办法用的，而且部分代码逻辑也没办法实现统一的管理和复用。</p>
<p>即使是这样，这个项目最终也达成了降本增效的目的，部分规则的质检准确率达到了 70% 以上，大家可能觉得这个指标仍然不高，但是这其中有很多限制条件，比如音转文错误率大概在 20% 左右，因为大模型是依靠音频转文本之后的内容进行质检的，音转文的错误会直接影响质检结果，当然我们可以切换更好的模型去做 ASR 或者质检，但是更好的模型也意味着更高的成本，理论上可行但是实际落地还是需要权衡来达到一个预期的平衡，如果不能为业务带来价值的话，岂不就是空谈了。</p>
<h3 data-id="heading-2">感悟</h3>
<p>在技术上，做完技改之后想做一下 MIT 的 6.5840 分布式公开课，因为这个课程的 Lab 要求使用 Go 语言完成，所以<a href="https://juejin.cn/post/7488184878544076841" target="_blank" title="https://juejin.cn/post/7488184878544076841">特意阅读了《Head First Go 语言程序设计》</a>，在我看来 Head First 系列相对来说是能够比较快速了解一门技术的书籍。后来，阅读了国人写的《深入理解分布式系统》，我觉得这个书结合《数据密集型系统设计》一起阅读会更好，之后又阅读了<a href="https://juejin.cn/post/7546898394542243866" target="_blank" title="https://juejin.cn/post/7546898394542243866">《生产微服务》</a>并重新阅读了《微服务架构设计模式》，这让我对于现有系统的设计有了更深刻的理解。闲暇之余看了《网络是怎样连接的》，小日子写的书的确挺不错的，读完的时候只有一种感想：“什么时候国内也有大佬来写这么硬核的书籍就好了”。最后一本技术书是《从零构建大模型》，这部书阅读得不够深入，而且我打开这本书的预期也仅仅是想了解大模型的工作原理，不再把它当做黑盒来用。</p>
<p>技术之外的阅读我觉得今年给我收获最多的是《芒格之道》，一位富有智慧的理性老头子，读完这本书之后我也会刻意的提醒自己在一些事情上要“反过来想”，逆向思维往往在生活中非常有帮助，之后又阅读了《穷查理宝典》，我觉得这本书的典藏版排版太差，无关内容太多，非常影响阅读体验，如果大家想要阅读的话，可以选择这本书的“口袋版”试一试，价格更便宜阅读体验也更好。</p>
<p>在生活上，与女朋友的关系更加紧密，也开始关注到自己的性格，希望自己能够更加心平气和，同时今年也变得更加关心家人，也更愿意花时间和家人在一起，我也希望我自己未来向上的发展也能更多的带给他们幸福。</p>
<hr/>
<p><strong>祝大家新年快乐，马到成功~</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[拒绝“只会聊天”的AI！揭秘Agent开发第一步：给大模型装上“大脑”与“手脚”]]></title>    <link>https://juejin.cn/post/7595901379014705162</link>    <guid>https://juejin.cn/post/7595901379014705162</guid>    <pubDate>2026-01-17T14:24:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595901379014705162" data-draft-id="7595890117866143790" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="拒绝“只会聊天”的AI！揭秘Agent开发第一步：给大模型装上“大脑”与“手脚”"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-01-17T14:24:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一直在追"/> <meta itemprop="url" content="https://juejin.cn/user/239028506736411"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            拒绝“只会聊天”的AI！揭秘Agent开发第一步：给大模型装上“大脑”与“手脚”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/239028506736411/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一直在追
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:24:54.000Z" title="Sat Jan 17 2026 14:24:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>本文价值提示：</strong></p>
<blockquote>
<p>💡 <strong>你将获得什么？</strong></p>
<ol>
<li><strong>底层祛魅</strong>：跳过 LangChain 等框架的黑盒，从原生 API 层面理解 Agent 是如何“动”起来的。</li>
<li><strong>思维升级</strong>：从大数据工程师熟悉的 ETL 线性思维，转型为 AI 架构师必备的“循环（Loop）思维”。</li>
<li><strong>实战代码</strong>：掌握 Function Calling 和 ReAct 模式的核心实现逻辑。</li>
</ol>
<p>⏳ <strong>阅读时间</strong>：约 8 分钟 | <strong>难度</strong>：进阶</p>
</blockquote>
<hr/>
<p>👋 <strong>大家好，我是你们的老朋友。</strong></p>
<p>在上一期的《RAG架构与数据工程》中，我们成功地给大模型装上了“海马体”，利用向量数据库让它拥有了<strong>长期记忆</strong>。现在，它已经是一个博学多才的“图书馆管理员”了。</p>
<p>但是，你有没有发现，它依然只能<strong>坐着说话</strong>？</p>
<p>它不能帮你查实时的天气，不能帮你去数据库跑 SQL，更不能帮你发邮件。它就像一个被困在瓶子里的天才大脑，<strong>有智商，没行动力</strong>。</p>
<p>今天，我们正式开启<strong>第四个专题：AI Agent 的开发与编排</strong>。作为本专题的第一篇，我们将深入 Agent 的微观世界，不依赖任何复杂的框架，亲手给这个“大脑”装上“手脚”（Tools）和“逻辑回路”（Reasoning）。</p>
<hr/>
<h2 data-id="heading-0">01 思维大爆炸：从 ETL 到 Agent Loop 🤯</h2>
<p>作为大数据工程师，你一定对 <strong>DAG（有向无环图）</strong> 烂熟于心。在 Airflow 或 Spark 中，任务流是线性的、确定的：
<code>提取(E) -&gt; 转换(T) -&gt; 加载(L)</code>。</p>
<p>如果中间报错了，任务就挂了，或者重试。</p>
<p>但在 Agent 的世界里，逻辑是<strong>非确定性</strong>的，而且是一个<strong>循环（Cyclic）</strong>。</p>
<h3 data-id="heading-1">🔄 Agent 的核心循环</h3>
<p>Agent 不是一条直线，而是一个 <code>While True</code> 的循环：</p>
<ol>
<li><strong>感知 (Observation)</strong>：看看现在发生了什么？</li>
<li><strong>思考 (Thought)</strong>：我该做什么？需要用工具吗？</li>
<li><strong>行动 (Action)</strong>：调用工具（API/函数）。</li>
<li><strong>观察 (Observation)</strong>：工具返回了什么结果？</li>
<li><strong>回到第 2 步</strong>... 直到任务完成。</li>
<li><img src="http://openwrite.cn/uploads/20235/58487/ded66f57-0f05-4ce4-a32a-bd4063d76b31.png" alt="image.png" loading="lazy"/></li>
</ol>
<p><strong>架构师视点</strong>：</p>
<blockquote>
<p>以前我们写代码是编写“规则”，现在我们写 Agent 是编写“目标”和“边界”。你无法预知 LLM 会先迈左脚还是右脚，但你要确保它别掉进坑里。</p>
</blockquote>
<hr/>
<h2 data-id="heading-2">02 给大脑装上“手脚”：Function Calling (Tool Use) 🛠️</h2>
<p>LLM 本质上是一个概率模型，它只会吐出文本（Text）。那它怎么调用 Python 函数或者 API 呢？</p>
<p>这就需要用到 OpenAI 等模型提供的核心能力：<strong>Function Calling（函数调用）</strong>，现在更通用的叫法是 <strong>Tool Use</strong>。</p>
<h3 data-id="heading-3">这里的“魔法”是什么？</h3>
<p>其实没有魔法，只有 <strong>Schema（结构定义）</strong>。</p>
<p>想象你在餐厅点菜。</p>
<ul>
<li><strong>普通对话</strong>：“我要吃那个红色的、辣的、有豆腐的菜。”（厨师可能听不懂）</li>
<li><strong>Function Calling</strong>：你递给厨师一张标准点菜卡（JSON Schema）：
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dish_name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Mapo Tofu"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"spiciness_level"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"high"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ingredients"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"tofu"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"minced meat"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-4">实战：原生 SDK 实现天气查询</h3>
<p>别急着引入 LangChain，我们先看原生 OpenAI SDK 怎么做。这能让你理解底层原理。</p>
<p><strong>第一步：定义工具（告诉 LLM 你有哪些手脚）</strong>
我们需要用 JSON Schema 描述函数。</p>
<pre><code class="hljs language-python" lang="python">tools = [
    {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"function"</span>,
        <span class="hljs-string">"function"</span>: {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"get_current_weather"</span>,
            <span class="hljs-string">"description"</span>: <span class="hljs-string">"获取指定城市的当前天气"</span>,
            <span class="hljs-string">"parameters"</span>: {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"object"</span>,
                <span class="hljs-string">"properties"</span>: {
                    <span class="hljs-string">"location"</span>: {
                        <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
                        <span class="hljs-string">"description"</span>: <span class="hljs-string">"城市名称，如 Beijing, San Francisco"</span>
                    },
                    <span class="hljs-string">"unit"</span>: {<span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>, <span class="hljs-string">"enum"</span>: [<span class="hljs-string">"celsius"</span>, <span class="hljs-string">"fahrenheit"</span>]}
                },
                <span class="hljs-string">"required"</span>: [<span class="hljs-string">"location"</span>]
            }
        }
    }
]
</code></pre>
<p><strong>第二步：对话与解析</strong>
当用户问：“今天北京天气怎么样？” LLM 不会直接回答“晴天”，而是会返回一个<strong>特殊的结构</strong>，告诉我们要调用函数。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 伪代码演示</span>
response = client.chat.completions.create(
    model=<span class="hljs-string">"gpt-4o"</span>,
    messages=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"北京今天天气如何？"</span>}],
    tools=tools, <span class="hljs-comment"># 关键点：把工具箱传给它</span>
    tool_choice=<span class="hljs-string">"auto"</span> 
)

tool_call = response.choices[<span class="hljs-number">0</span>].message.tool_calls[<span class="hljs-number">0</span>]
<span class="hljs-built_in">print</span>(tool_call.function.name) 
<span class="hljs-comment"># 输出: get_current_weather</span>
<span class="hljs-built_in">print</span>(tool_call.function.arguments) 
<span class="hljs-comment"># 输出: {"location": "Beijing"}</span>
</code></pre>
<p><strong>第三步：执行与回传</strong>
作为开发者，你需要捕获这个 <code>tool_call</code>，在本地执行 Python 代码，然后把结果<strong>伪装成一条消息</strong>，塞回给 LLM。</p>
<blockquote>
<p>⚠️ <strong>注意</strong>：LLM 并没有真正执行代码，它只是生成了“要执行代码的指令”。<strong>执行代码的是你的 Python 脚本！</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-5">03 升级大脑的操作系统：Prompt 策略与 ReAct 🧠</h2>
<p>有了手脚，如果大脑不够聪明，Agent 就会变成“无头苍蝇”。我们需要通过 Prompt Engineering 来升级它的思维模式。</p>
<h3 data-id="heading-6">1. CoT (Chain of Thought)：让它慢点想</h3>
<p>在大数据处理中，复杂的 SQL 我们会拆成多个 CTE (Common Table Expression)。同理，对 LLM，我们要强迫它 <code>Let's think step by step</code>。</p>
<p><strong>System Prompt 示例：</strong></p>
<blockquote>
<p>你是一个数据分析助手。在回答用户问题前，请先列出你的思考步骤，明确你需要什么数据，然后再行动。</p>
</blockquote>
<h3 data-id="heading-7">2. ReAct 模式：Agent 的黄金法则</h3>
<p>ReAct 是 <strong>Re</strong>asoning + <strong>Act</strong>ing 的缩写。这是目前最经典的 Agent 运作模式。</p>
<p>它的核心咒语是：</p>
<ul>
<li><strong>Thought (想法)</strong>：用户想查天气，我需要调用天气工具。</li>
<li><strong>Action (行动)</strong>：<code>get_weather("Beijing")</code></li>
<li><strong>Observation (观察)</strong>：API 返回了 "25度，晴"。</li>
<li><strong>Thought (想法)</strong>：我已经有了天气信息，可以回答用户了。</li>
<li><strong>Final Answer (最终回答)</strong>：北京今天天气不错，25度，晴天。</li>
</ul>
<p><strong>为什么这很重要？</strong>
如果没有 ReAct，模型可能会产生<strong>幻觉</strong>。比如它直接编造一个天气，而不是去调用工具。ReAct 强制模型“知行合一”。</p>
<hr/>
<h2 data-id="heading-8">04 架构师的“防呆”设计：Pydantic 与结构化输出 🛡️</h2>
<p>作为工程化转型的你，肯定受不了 JSON 解析报错。
LLM 输出的 JSON 经常少个括号，或者字段名写错。怎么办？</p>
<p><strong>Pydantic 登场！</strong>
Pydantic 是 Python 中最强的数据验证库。我们可以用它来强制 LLM 输出符合 Python 类定义的数据。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserIntent</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    intent: <span class="hljs-built_in">str</span> = Field(description=<span class="hljs-string">"用户的意图，如 query, command, chat"</span>)
    confidence: <span class="hljs-built_in">float</span> = Field(description=<span class="hljs-string">"置信度 0-1"</span>)
    keywords: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = Field(description=<span class="hljs-string">"提取的关键实体"</span>)

<span class="hljs-comment"># 在 OpenAI 新版 SDK 中，可以直接结合 Pydantic</span>
completion = client.beta.chat.completions.parse(
    model=<span class="hljs-string">"gpt-4o-2024-08-06"</span>,
    messages=[...],
    response_format=UserIntent, <span class="hljs-comment"># 强类型约束！</span>
)

intent_obj = completion.choices[<span class="hljs-number">0</span>].message.parsed
<span class="hljs-built_in">print</span>(intent_obj.confidence) <span class="hljs-comment"># 直接获取 float 类型，无需 json.loads</span>
</code></pre>
<p><strong>架构师思考</strong>：
这不仅仅是语法糖，这是<strong>系统稳定性</strong>的保障。在 Agent 编排中，节点之间的通信必须是结构化的（Schema），而不是随意的自然语言。</p>
<hr/>
<h2 data-id="heading-9">05 总结与预告 📝</h2>
<p>今天我们剥开了 Agent 的外衣，看到了它最原始的“血肉”：</p>
<ol>
<li><strong>理念</strong>：从线性 Pipeline 转向 循环 Loop。</li>
<li><strong>手脚</strong>：利用 <code>Function Calling</code> 定义工具 Schema。</li>
<li><strong>大脑</strong>：利用 <code>ReAct</code> 模式进行“思考-行动-观察”的循环。</li>
<li><strong>骨架</strong>：利用 <code>Pydantic</code> 保证数据流转的鲁棒性。</li>
</ol>
<h3 data-id="heading-10">🗺️ 本文核心知识图谱</h3>
<p><img src="http://openwrite.cn/uploads/20235/58487/a6f99ea4-4fdd-43ec-a8be-9242443e8947.png" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-11">🎣 互动话题</h3>
<blockquote>
<p>你在尝试让 LLM 调用工具时，遇到过最离谱的“幻觉”是什么？（比如：明明没查数据库，却一本正经地编造了查询结果？）
欢迎在评论区分享你的“翻车”现场！</p>
</blockquote>
<h3 data-id="heading-12">🚀 下期预告</h3>
<p>学会了单点技能，如何构建复杂的、生产级的 Agent 流程？
下一期，我们将进入<strong>第二篇：单体 Agent 架构</strong>。我们将深度实战 <strong>LangGraph</strong>，学习如何用“图”的思维来编排一个真正的数据分析师 Agent。</p>
<p><strong>关注我，带你从大数据工程师硬核转型 AI 架构师！</strong></p>
<hr/>
<p><em>这是“AI Agent开发与编排”专题的第 1 篇，前序专题《Python高级工程化》、《大模型基础理论》、《RAG架构与数据工程》已完结，欢迎翻阅历史文章补课。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude Code Skills：从手写到工具化，教 AI 新技能的完整指南]]></title>    <link>https://juejin.cn/post/7596181746061656091</link>    <guid>https://juejin.cn/post/7596181746061656091</guid>    <pubDate>2026-01-17T14:25:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596181746061656091" data-draft-id="7596181746061639707" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude Code Skills：从手写到工具化，教 AI 新技能的完整指南"/> <meta itemprop="keywords" content="Claude,AI编程"/> <meta itemprop="datePublished" content="2026-01-17T14:25:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿衡Eve"/> <meta itemprop="url" content="https://juejin.cn/user/254742428393310"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude Code Skills：从手写到工具化，教 AI 新技能的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/254742428393310/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿衡Eve
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:25:07.000Z" title="Sat Jan 17 2026 14:25:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><blockquote>
<p>🐒 大家好，我是阿衡，一年经验用了十次的游戏后端开发，辞职后成为自由职业、独立游戏开发者。</p>
<p>非专业 AI 玩家，日常关注 AI 编程方向的内容。</p>
</blockquote>
<p><strong>🎯 这是 Claude Code Skills 系列的第一篇，主要介绍：什么是 Skill？如何创建 Skill。</strong></p>
<p>你有没有想过，可以自己"教" AI 一项新技能？</p>
<p>不是调参数，不是写代码训练模型，就是简单地告诉它："以后遇到这种情况，你就这么做。"</p>
<p>这篇文章教你两种方法：一种 5 分钟手写速成，另一种用官方工具更专业。学完之后，你就能让 Claude Code 按你的规则干活了。</p>
<hr/>
<h2 data-id="heading-0">什么是 Skills？</h2>
<p>说白了，Skills 就是给 AI 配的一本"专属攻略手册"。</p>
<p>你可能遇到过这种情况：每次让 Claude Code 帮你写代码，都要重复说一遍"用 TypeScript"、"加上类型注释"、"遵循这个目录结构"……</p>
<p>烦不烦？</p>
<p>有了 Skills，这些话只用说一次。你把规则写在一个文件里，Claude Code 以后就自动按这个来。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07aee88a5fe846e1baeddcdea26e6113~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6KGhRXZl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769264706&amp;x-signature=aSypUFLCvoKXoeTccE4SuFfMUUU%3D" alt="Image" loading="lazy"/></p>
<p>从技术上说，一个 Skill 就是一个文件夹，里面放着指令和资源[^1]。Claude Code 会按需加载这些文件，用完就释放，所以即使你装了几十个 Skills，也不会拖慢速度。</p>
<p>官方的说法是：每个 Skill 启动时只占用 30-50 个 tokens[^2]。</p>
<hr/>
<h2 data-id="heading-1">方法一：5 分钟手写你的第一个 Skill</h2>
<p>来，做一个"每日总结"Skill——你说一句"帮我总结今天的工作"，它就自动生成格式化的日报。</p>
<h3 data-id="heading-2">Step 1: 创建文件夹</h3>
<p>在你的项目根目录下，创建这样一个结构：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.claude</span>/
└── skills/
    └── daily-<span class="hljs-selector-tag">summary</span>/
        └── SKILL<span class="hljs-selector-class">.md</span>
</code></pre>
<p>对，就这么简单。一个文件夹，一个 Markdown 文件。</p>
<h3 data-id="heading-3">Step 2: 写 SKILL.md</h3>
<p>打开 <code>SKILL.md</code>，写入以下内容：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">daily-summary</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">当用户要求总结今天的工作、生成日报、回顾进展时使用。自动整理</span> <span class="hljs-string">git</span> <span class="hljs-string">commits</span> <span class="hljs-string">和完成的任务，生成格式化的工作总结。</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># 每日工作总结</span>

<span class="hljs-comment">## 触发条件</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">用户说"总结今天的工作"</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">用户说"生成日报"</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">用户说"今天做了什么"</span>

<span class="hljs-comment">## 执行步骤</span>
<span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">读取今天的</span> <span class="hljs-string">git</span> <span class="hljs-string">commits（如果有）</span>
<span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">整理完成的任务</span>
<span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">按以下格式输出：</span>

<span class="hljs-comment">## 输出格式</span>

<span class="hljs-comment">### 📅 [日期] 工作总结</span>

<span class="hljs-string">**完成事项**</span>
<span class="hljs-bullet">-</span> [ ] <span class="hljs-string">事项1</span>
<span class="hljs-bullet">-</span> [ ] <span class="hljs-string">事项2</span>

<span class="hljs-string">**明日计划**</span>
<span class="hljs-bullet">-</span> [ ] <span class="hljs-string">计划1</span>

<span class="hljs-string">**备注**</span>
<span class="hljs-string">（可选）</span>
</code></pre>
<p>注意两个关键点：</p>
<ol>
<li>YAML 头部：name 和 description 是必须的。description 特别重要，它告诉 Claude 什么时候该用这个 Skill[^3]。</li>
<li>正文指令：用 Markdown 写你想让 AI 做什么。越清晰越好，但不用太啰嗦——官方说了，"Claude is already very smart"[^4]。</li>
</ol>
<h3 data-id="heading-4">Step 3: 测试效果</h3>
<p>保存文件后，在 Claude Code 里说一句："帮我总结今天的工作"。</p>
<p>如果一切正常，你会看到它按照你定义的格式，自动生成日报了。</p>
<p>有时候如果自动判定没命中，也可以使用 <code>/daily-summary</code> 手动触发。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/557fb9c313a34b3090134816e58316b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6KGhRXZl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769264706&amp;x-signature=RBNSIlGJT%2F%2FHV46DJ1ghIsUccG4%3D" alt="Image" loading="lazy"/></p>
<p><strong>小贴士</strong>：从 v2.1.1 开始，Claude Code 支持热重载[^5]。也就是说，你改了 SKILL.md 之后，不用重启，马上就能生效。</p>
<hr/>
<h2 data-id="heading-5">方法二：用官方 Skill Creator</h2>
<p>手写很快，但有个问题：如果你的 Skill 比较复杂，需要脚本、资源文件、甚至要分享给团队呢？</p>
<p>这时候，官方的 Skill Creator 就派上用场了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/259205824d9e4f54949fded98b51d7c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6KGhRXZl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769264706&amp;x-signature=0Hih9B2RWzZJIfNW9jXXGd6VMMo%3D" alt="Image" loading="lazy"/></p>
<p>简单场景用手写，复杂场景或者要分享的，用 skill-creator。</p>
<hr/>
<h2 data-id="heading-6">Skill Creator 安装与使用</h2>
<h3 data-id="heading-7">安装 Skill Creator</h3>
<p>Skill Creator 在 Anthropic 官方仓库 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a> 中 安装很简单：</p>
<p>在 Claude Code 中输入：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1：将该仓库注册为 Claude Code 插件市场</span>
/plugin marketplace add anthropics/skills

<span class="hljs-comment"># 2：安装特定 skill</span>
<span class="hljs-comment"># 包括很多文档处理类的 skill</span>
/plugin install document-skills@anthropic-agent-skills
<span class="hljs-comment"># 这里就包括了我们说的 skill-creator</span>
/plugin install example-skills@anthropic-agent-skills
</code></pre>
<p>安装完成后，你就可以在 Claude Code 里说"帮我创建一个每日工作总结 Skill"，它会自动调用 Skill Creator 来引导你。</p>
<h3 data-id="heading-8">官方 Skills 速览</h3>
<p>顺便说一下，官方仓库里有 16 个示例 Skills[^6]，涵盖各种场景：</p>
<p>类别</p>
<p>Skills</p>
<p>文档处理</p>
<p>docx, pdf, pptx, xlsx</p>
<p>设计创作</p>
<p>algorithmic-art, canvas-design, frontend-design</p>
<p>开发工具</p>
<p>mcp-builder, webapp-testing</p>
<p>协作沟通</p>
<p>doc-coauthoring, internal-comms</p>
<p>这些不展开讲了，但强烈建议你去翻翻看——学习别人怎么写 Skill，比看文档有用多了。</p>
<h3 data-id="heading-9">用 Skill Creator 创建 Skill</h3>
<p>现在用 Skill Creator 重新创建那个"每日总结"Skill。</p>
<p>在 Claude Code 里说：</p>
<blockquote>
<p>"帮我创建一个新的 Skill，用于生成每日工作总结"</p>
</blockquote>
<p>当然最稳妥的方式还是手动触发（我比较喜欢这种确定性）：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/378d4ee4c0294d41a68f134c11fbb49d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6KGhRXZl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769264706&amp;x-signature=cph0HA%2B79Owjm%2Fb6NzF8Zp%2Fhg%2BY%3D" alt="Image" loading="lazy"/></p>
<p>Skill Creator 会引导你完成以下步骤[^7]：</p>
<ol>
<li>理解需求：它会问你几个问题，确认 Skill 的用途</li>
<li>规划结构：自动决定需要哪些文件</li>
<li>初始化：创建文件夹和基础文件</li>
<li>编辑：你可以进一步调整内容</li>
<li>打包：生成可分享的 Skill 包</li>
<li>迭代：根据使用反馈持续优化</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11772f1837c94526bd6eb59446eee6a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6KGhRXZl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769264706&amp;x-signature=sQ9EwM5o7%2Bkm46BF2LYRjdnG3xo%3D" alt="Image" loading="lazy"/></p>
<p>生成的结构可能是这样：</p>
<pre><code class="hljs language-python" lang="python">daily-summary/
├── SKILL.md              <span class="hljs-comment"># 核心指令</span>
├── scripts/
│   └── get_commits.py    <span class="hljs-comment"># 获取 git commits 的脚本</span>
└── references/
    └── <span class="hljs-built_in">format</span>.md         <span class="hljs-comment"># 输出格式参考</span>
</code></pre>
<p>比手写的版本更完整、更规范。而且因为遵循官方标准，以后分享给团队或者发布到社区市场都很方便。</p>
<hr/>
<h2 data-id="heading-10">进阶提示</h2>
<p>再分享几个技巧：</p>
<p><strong>热重载</strong>：改完 SKILL.md 立即生效，不用重启 Claude Code。这个特性从 v2.1.1 开始支持[^5]。</p>
<p><strong>社区市场</strong>：已经有社区 Skills 市场了[^8]。别人创建的好 Skill 可以直接用，不用自己造轮子。</p>
<p><strong>迭代优化</strong>：Skill 不是一次性的。用着用着觉得不满意，随时改。AI 会越来越懂你的需求。</p>
<hr/>
<h2 data-id="heading-11">写在最后</h2>
<p>两种方法，各有优劣：</p>
<ul>
<li>手写：5 分钟速成，适合简单场景，帮你理解原理</li>
<li>Skill Creator：更规范更完整，适合复杂场景和团队分享</li>
</ul>
<p>Anthropic 的人说过一句话，我觉得很有道理[^9]：</p>
<blockquote>
<p>"Skills &gt; Agents"</p>
<p>比起一次性的 Agent，持续积累的 Skills 更有价值。</p>
</blockquote>
<p>你构建的 Skills 越多，Claude Code 就越懂你、越有用。</p>
<p>所以，别光看，去动手试试吧。</p>
<p>创建属于你的第一个 Skill，就从今天开始。</p>
<hr/>
<h2 data-id="heading-12">参考资料</h2>
<p>[1]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">Anthropic. "Skills Repository."</a> - Skills 是包含指令和代码的文件夹</p>
<p>[2]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2FtengyanAI%2Fstatus%2F1985341993036439736" target="_blank" title="https://x.com/tengyanAI/status/1985341993036439736" ref="nofollow noopener noreferrer">Teng Yan (@tengyanAI). "Skills 技术本质."</a> - 每个 Skill 约 30-50 tokens</p>
<p>[3]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills%2Fblob%2Fmain%2Fskills%2Fskill-creator%2FSKILL.md" target="_blank" title="https://github.com/anthropics/skills/blob/main/skills/skill-creator/SKILL.md" ref="nofollow noopener noreferrer">Anthropic. "skill-creator SKILL.md."</a> - description 是主要触发机制</p>
<p>[4]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills%2Fblob%2Fmain%2Fskills%2Fskill-creator%2FSKILL.md" target="_blank" title="https://github.com/anthropics/skills/blob/main/skills/skill-creator/SKILL.md" ref="nofollow noopener noreferrer">Anthropic. "skill-creator."</a> - "Claude is already very smart"</p>
<p>[5]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fericwang42%2Fstatus%2F2009097885988893132" target="_blank" title="https://x.com/ericwang42/status/2009097885988893132" ref="nofollow noopener noreferrer">Eric Wang (@ericwang42). "v2.1.1 更新."</a> - 热重载 Skills 支持</p>
<p>[6]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">Anthropic. "Skills Repository."</a> - 16 个官方示例 Skills</p>
<p>[7]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills%2Fblob%2Fmain%2Fskills%2Fskill-creator%2FSKILL.md" target="_blank" title="https://github.com/anthropics/skills/blob/main/skills/skill-creator/SKILL.md" ref="nofollow noopener noreferrer">Anthropic. "skill-creator."</a> - 6 步创建流程</p>
<p>[8]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2FtengyanAI%2Fstatus%2F1985341993036439736" target="_blank" title="https://x.com/tengyanAI/status/1985341993036439736" ref="nofollow noopener noreferrer">Teng Yan (@tengyanAI). "Skills 市场."</a> - 社区市场已上线</p>
<p>[9]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fomarsar0%2Fstatus%2F1998383154181361813" target="_blank" title="https://x.com/omarsar0/status/1998383154181361813" ref="nofollow noopener noreferrer">elvis (@omarsar0). "Skills &gt; Agents."</a> - Anthropic 演讲核心观点</p>
<hr/>
<p>💬 你平时是怎么创建 Skill 的？欢迎在评论区分享你的方法！</p>
<p>👍 觉得有用的话，记得点赞收藏，让更多人看到这篇文章！</p>
<p><strong>配图说明</strong>：本文配图(除截图外）由 Nano Banana Pro 生成</p>
<hr/>
<ul>
<li>#公众号：阿衡的AI日常</li>
<li>#小红书：阿衡的AI日常</li>
<li>#CSDN：DebugEve</li>
<li>#掘金：阿衡Eve</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[给Claude Code/Cursor戴上“紧箍咒”：Superpowers如何让AI编程变得可靠可控？]]></title>    <link>https://juejin.cn/post/7595901379014819850</link>    <guid>https://juejin.cn/post/7595901379014819850</guid>    <pubDate>2026-01-17T14:46:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595901379014819850" data-draft-id="7595901379014787082" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="给Claude Code/Cursor戴上“紧箍咒”：Superpowers如何让AI编程变得可靠可控？"/> <meta itemprop="keywords" content="AI编程,开源"/> <meta itemprop="datePublished" content="2026-01-17T14:46:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大厂技术总监下海"/> <meta itemprop="url" content="https://juejin.cn/user/4091714106833577"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            给Claude Code/Cursor戴上“紧箍咒”：Superpowers如何让AI编程变得可靠可控？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4091714106833577/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大厂技术总监下海
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:46:36.000Z" title="Sat Jan 17 2026 14:46:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Superpowers 项目深度技术分析：AI 编码代理的系统化工程框架</h2>
<h3 data-id="heading-1">1. 整体介绍</h3>
<h4 data-id="heading-2">1.1 项目概要</h4>
<p><strong>项目名称</strong>：<code>obra/superpowers</code><br/>
<strong>项目地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fobra%2Fsuperpowers" target="_blank" title="https://github.com/obra/superpowers" ref="nofollow noopener noreferrer">github.com/obra/superp…</a><br/>
<strong>项目性质</strong>：一个为AI编码代理（Claude Code, Codex, OpenCode）构建的、基于模块化“技能”的软件开发工作流增强系统。它通过强制性的流程和规范，将AI的代码生成能力导向系统化的软件工程实践。</p>
<p><em>（注：本文基于提供的项目代码进行分析，未实时查询GitHub star与fork数据，故不作具体数字说明）</em></p>
<h4 data-id="heading-3">1.2 核心功能与价值主张</h4>
<p>Superpowers 的核心功能不是提供新的代码库或算法，而是定义并强制执行一套<strong>AI辅助开发的工作流</strong>。其核心交互流程如下图所示，清晰展示了从需求澄清到最终集成的自动化过程：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant U as 用户/开发者
    participant M as 主AI代理 (Main Agent)
    participant S as Superpowers 技能系统
    participant SA as 子代理 (Sub-agent)
    participant G as Git/文件系统

    U-&gt;&gt;M: 提出一个开发想法（如“加个登录功能”）
    M-&gt;&gt;S: 触发 `brainstorming` 技能
    S-&gt;&gt;U: 进行多轮问答，澄清需求
    U-&gt;&gt;S: 确认分段设计
    S-&gt;&gt;G: 保存设计文档到 `docs/plans/`
    
    M-&gt;&gt;S: 触发 `using-git-worktrees` 技能
    S-&gt;&gt;G: 创建独立Git工作树分支
    
    M-&gt;&gt;S: 触发 `writing-plans` 技能
    S-&gt;&gt;M: 生成详细到分钟级的实施计划
    
    loop 对于计划中的每个任务
        M-&gt;&gt;S: 触发 `subagent-driven-development`
        S-&gt;&gt;SA: 派发任务给一个全新子代理
        SA-&gt;&gt;SA: 执行任务（编码）
        SA-&gt;&gt;SA: 自我审查
        S-&gt;&gt;SA: 启动两阶段审查（规格、质量）
        alt 审查发现问题
            SA-&gt;&gt;SA: 进入审查循环修正
        end
        SA-&gt;&gt;G: 提交代码变更
    end
    
    M-&gt;&gt;S: 触发 `requesting-code-review` 技能
    S-&gt;&gt;M: 报告审查问题（分严重级别）
    
    M-&gt;&gt;S: 触发 `finishing-a-development-branch` 技能
    S-&gt;&gt;U: 提供选项（合并/PR/保留/丢弃）
    U-&gt;&gt;G: 选择并完成分支操作
</code></pre>
<p><strong>面临的问题与目标人群</strong>：</p>
<ul>
<li><strong>问题</strong>：当前AI编码代理（如Claude Code）在响应开放式编程请求时，行为具有不确定性。它可能直接生成未经深思熟虑的代码、跳过测试、忽视架构一致性或产生不必要的复杂性（违反YAGNI原则）。</li>
<li><strong>目标人群</strong>：依赖AI代理进行中大型或生产级项目开发的软件工程师、技术团队领导者。他们需要AI的辅助效率，但必须确保产出代码的<strong>可维护性、可靠性与工程规范性</strong>。</li>
<li><strong>对应场景</strong>：功能开发、模块重构、遗留系统修改等需要严格遵循测试驱动开发（TDD）、代码审查和版本控制规范的项目任务。</li>
</ul>
<p><strong>解决方法与演进</strong>：</p>
<ul>
<li><strong>传统/原始方式</strong>：开发者直接向AI代理发出“写一个X功能”的指令。AI直接生成代码块，过程是黑盒的，缺乏需求澄清、设计评审、计划制定和系统性测试验证环节。</li>
<li><strong>Superpowers 新方式</strong>：在AI代理的初始指令中植入一套“技能”系统。当检测到开发意图时，代理<strong>必须</strong>触发相应技能，引导用户走过一个包含“需求澄清 → 设计评审 → 计划制定 → 子代理执行与审查 → 集成”的完整流程。这本质上是将人类软件工程的最佳实践（如TDD、代码审查、Git工作流）转化为AI可理解和执行的强制性协议。</li>
</ul>
<p><strong>商业价值估算逻辑</strong>：
价值可从 <strong>“降低的代码返工成本”</strong> 和 <strong>“提升的团队开发效率”</strong> 两个维度进行保守估算。</p>
<ol>
<li><strong>代码返工成本</strong>：假设一个10人团队，平均每人月薪为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo separator="true">,</mo><mn>000</mn><mtext>，每月有</mtext><mn>20</mn></mrow><annotation encoding="application/x-tex">10,000，每月有20%的时间花费在修复AI生成代码的缺陷、不一致性和架构问题上。Superpowers通过强制流程可将此问题减少约30%。则月节省成本为：`10人 * </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"/><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">000</span><span class="mord cjk_fallback">，每月有</span><span class="mord">20</span></span></span></span></span>10,000 * 20% * 30% = $6,000`。</li>
<li><strong>效率提升</strong>：通过自动化的子代理驱动开发、代码审查和Git工作流管理，将开发者从繁琐的流程管控中解放出来。保守估计提升个体效率5%。则月价值为：<code>10人 * $10,000 * 5% = $5,000</code>。</li>
<li><strong>综合月度价值</strong>：约为 <strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn><mo separator="true">,</mo><mn>000</mn><mo>∗</mo><mo>∗</mo><mtext>。年化价值约</mtext><mo>∗</mo><mo>∗</mo></mrow><annotation encoding="application/x-tex">11,000**。年化价值约 **</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"/><span class="mord">11</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">000</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord">∗</span><span class="mord cjk_fallback">。年化价值约</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.4653em;"/><span class="mord">∗</span></span></span></span></span>132,000</strong>。这尚未计算因代码质量提升带来的长期维护成本降低和系统稳定性收益。项目的实现成本主要为开发与维护此类框架的人力投入，其投资回报率（ROI）在规模化使用的团队中较为显著。</li>
</ol>
<h3 data-id="heading-4">2. 详细功能拆解：产品与技术的双重视角</h3>
<h4 data-id="heading-5">2.1 产品视角：结构化开发流水线</h4>
<p>Superpowers 作为一个“产品”，其核心是封装了软件开发生命周期（SDLC）关键阶段的一套自动化流水线：</p>
<ul>
<li><strong>需求入口管理 (<code>brainstorming</code>)</strong>：替代了直接编码的入口，变为Socratic（苏格拉底式）对话，确保目标一致。</li>
<li><strong>开发环境沙盒 (<code>using-git-worktrees</code>)</strong>：自动创建隔离的编码环境，防止污染主分支。</li>
<li><strong>任务分解引擎 (<code>writing-plans</code>)</strong>：将宏观目标分解为原子任务，是后续自动化执行的蓝图。</li>
<li><strong>分布式执行引擎 (<code>subagent-driven-development</code>)</strong>：利用AI代理可多实例的特性，并行或串行执行原子任务，并内置质量门禁（两阶段审查）。</li>
<li><strong>质量管控点 (<code>requesting-code-review</code>, <code>test-driven-development</code>)</strong>：在流程中硬性插入检查点，确保测试覆盖率和代码规范。</li>
<li><strong>发布协调器 (<code>finishing-a-development-branch</code>)</strong>：标准化分支收尾工作，提供清晰的后续操作路径。</li>
</ul>
<h4 data-id="heading-6">2.2 技术视角：插件化技能架构与运行时</h4>
<p>技术上，Superpowers 是一个<strong>基于技能(Skill)的插件化框架</strong>，其架构核心如下：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1db42d0e80446d58516007ca35d1a6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5Y6C5oqA5pyv5oC755uR5LiL5rW3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769265996&amp;x-signature=eqWKjlf12Ihy%2FQndRaMkq2GGumc%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<ol>
<li>
<p><strong>技能 (<code>Skill</code>) 作为基本单元</strong>：</p>
<ul>
<li>每个技能是一个目录，内含一个 <code>SKILL.md</code> 文件。该文件使用 YAML Frontmatter 声明元数据（名称、描述），主体部分则是详细的、供AI代理遵循的指令。</li>
<li><strong>关键设计</strong>：技能描述中包含强制触发条件（如 <code>“You MUST use this before any creative work”</code>），这是工作流得以强制执行的基础。</li>
</ul>
</li>
<li>
<p><strong>技能加载与解析引擎 (<code>lib/skills-core.js</code>)</strong>：
这是系统的技术核心，提供以下关键服务：</p>
<ul>
<li><strong>技能发现 (<code>findSkillsInDir</code>)</strong>：递归扫描目录，提取技能元数据。</li>
<li><strong>技能路径解析 (<code>resolveSkillPath</code>)</strong>：实现“个人技能覆盖系统技能”的机制，支持灵活的定制化。</li>
<li><strong>内容处理 (<code>stripFrontmatter</code>)</strong>：将 <code>SKILL.md</code> 中的可执行指令部分分离出来。</li>
<li><strong>更新检查 (<code>checkForUpdates</code>)</strong>：通过Git命令检查技能库是否有更新，保持流程先进性。</li>
</ul>
</li>
<li>
<p><strong>钩子 (<code>Hooks</code>) 机制</strong>：
通过 <code>hooks.json</code> 定义在特定事件（如会话开始 <code>SessionStart</code>）时自动执行的脚本。这实现了对AI代理环境的初始化和配置，确保技能系统就绪。</p>
</li>
<li>
<p><strong>子代理协调模式</strong>：
<code>subagent-driven-development</code> 技能是技术实现的亮点。它并非简单地将任务丢给另一个AI实例，而是设计了一个<strong>两阶段审查循环</strong>：</p>
<ul>
<li><strong>阶段一：规格符合性审查</strong>。审查者独立阅读代码，验证其是否完全匹配任务描述，不信任实施者的自我报告。</li>
<li><strong>阶段二：代码质量审查</strong>。在规格通过后，再进行代码风格、最佳实践等审查。</li>
<li>任何阶段发现问题，则退回实施者进入“审查循环”修正。这模仿了人类团队中“开发 → 代码审查 → 修改”的迭代过程，显著提升了AI生成代码的可靠性。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-7">3. 技术难点与挑战</h3>
<ol>
<li><strong>技能冲突与优先级管理</strong>：当多个技能的触发条件同时满足时，如何定义和执行优先级？系统目前似乎依赖技能描述中的“MUST”等强指令和开发者的上下文，更复杂的冲突解决机制可能是未来的挑战。</li>
<li><strong>子代理状态与上下文隔离</strong>：每个子代理应有独立、纯净的上下文，以防止任务间污染。但同时，某些任务又需要了解项目全局状态。如何在隔离与共享间取得平衡，需要精细的设计。</li>
<li><strong>复杂技能的测试</strong>：如 <code>tests/docs/testing.md</code> 所示，测试像 <code>subagent-driven-development</code> 这样的技能，需要搭建能运行真实AI代理的Headless测试环境，解析复杂的会话转录文件（JSONL格式），并验证分布式交互行为。这比测试普通函数要复杂得多。</li>
<li><strong>性能与成本控制</strong>：每个子代理调用都消耗AI模型的Token。项目提供的 <code>analyze-token-usage.py</code> 工具专门用于分析各代理的Token消耗和成本。优化提示词（Prompt）设计以减少Token浪费，同时保持效果，是一个持续的技术要点。</li>
<li><strong>对不同AI代理平台的适配</strong>：需要为Claude Code、Codex、OpenCode分别编写安装和适配逻辑（如 <code>.codex/INSTALL.md</code>, <code>.opencode/INSTALL.md</code>），处理不同平台的能力差异和接口，增加了维护复杂度。</li>
</ol>
<h3 data-id="heading-8">4. 详细设计图析</h3>
<h4 data-id="heading-9">4.1 核心技能解析流程序列图</h4>
<p>下图详细描绘了从触发技能名到执行技能指令的完整内部流程，特别是个人技能覆盖系统技能的解析逻辑：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant A as AI代理
    participant SC as SkillCore (技能核心)
    participant FS as 文件系统

    A-&gt;&gt;SC: resolveSkillPath(skillName, superpowersDir, personalDir)
    
    alt 技能名以 superpowers: 前缀强制指定
        SC-&gt;&gt;FS: 仅在 superpowersDir 下查找 skillName
    else 普通技能名
        SC-&gt;&gt;FS: 先在 personalDir 下查找 skillName
        alt 在 personalDir 中找到
            SC--&gt;&gt;A: 返回个人技能路径 (sourceType: ‘personal‘)
        else 未在 personalDir 中找到
            SC-&gt;&gt;FS: 在 superpowersDir 下查找 skillName
            alt 在 superpowersDir 中找到
                SC--&gt;&gt;A: 返回系统技能路径 (sourceType: ‘superpowers‘)
            else 均未找到
                SC--&gt;&gt;A: 返回 null
            end
        end
    end

    A-&gt;&gt;FS: 读取技能文件 SKILL.md
    A-&gt;&gt;SC: stripFrontmatter(content)
    SC--&gt;&gt;A: 返回纯指令内容
    A-&gt;&gt;A: 将技能指令注入自身上下文并执行
</code></pre>
<h4 data-id="heading-10">4.2 核心类/函数关系图</h4>
<p>基于 <code>lib/skills-core.js</code> 文件，其核心函数关系如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/668216fe6c4441f7be0932ebb4f565b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5Y6C5oqA5pyv5oC755uR5LiL5rW3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769265996&amp;x-signature=vbVjxFLnffAeZ1%2FrHII%2FrmcCHyY%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-11">5. 核心代码解析</h3>
<p>以下分析 <code>lib/skills-core.js</code> 中的两个关键函数，它们体现了系统的核心机制。</p>
<h4 data-id="heading-12">5.1 技能路径解析函数 (<code>resolveSkillPath</code>)</h4>
<p>此函数实现了技能查找的优先级逻辑，是“个人技能覆盖系统技能”特性的技术基础。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 解析技能名称到其文件路径，处理阴影覆盖
 * (个人技能覆盖 superpowers 技能)。
 *
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">skillName</span> - 名称如 "superpowers:brainstorming" 或 "my-skill"
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">superpowersDir</span> - superpowers 技能目录路径
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">personalDir</span> - 个人技能目录路径
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">{skillFile: string, sourceType: string, skillPath: string</span>} | null}
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveSkillPath</span>(<span class="hljs-params">skillName, superpowersDir, personalDir</span>) {
    <span class="hljs-comment">// 1. 处理强制前缀：如果以 `superpowers:` 开头，则只查找系统目录</span>
    <span class="hljs-keyword">const</span> forceSuperpowers = skillName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'superpowers:'</span>);
    <span class="hljs-keyword">const</span> actualSkillName = forceSuperpowers ? skillName.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^superpowers:/</span>, <span class="hljs-string">''</span>) : skillName;

    <span class="hljs-comment">// 2. 优先查找个人技能 (除非明确强制使用 superpowers)</span>
    <span class="hljs-keyword">if</span> (!forceSuperpowers &amp;&amp; personalDir) {
        <span class="hljs-keyword">const</span> personalPath = path.<span class="hljs-title function_">join</span>(personalDir, actualSkillName);
        <span class="hljs-keyword">const</span> personalSkillFile = path.<span class="hljs-title function_">join</span>(personalPath, <span class="hljs-string">'SKILL.md'</span>);
        <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(personalSkillFile)) {
            <span class="hljs-comment">// 找到个人技能，立即返回，实现“覆盖”</span>
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">skillFile</span>: personalSkillFile,
                <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'personal'</span>,
                <span class="hljs-attr">skillPath</span>: actualSkillName
            };
        }
    }

    <span class="hljs-comment">// 3. 查找 superpowers 系统技能</span>
    <span class="hljs-keyword">if</span> (superpowersDir) {
        <span class="hljs-keyword">const</span> superpowersPath = path.<span class="hljs-title function_">join</span>(superpowersDir, actualSkillName);
        <span class="hljs-keyword">const</span> superpowersSkillFile = path.<span class="hljs-title function_">join</span>(superpowersPath, <span class="hljs-string">'SKILL.md'</span>);
        <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(superpowersSkillFile)) {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">skillFile</span>: superpowersSkillFile,
                <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'superpowers'</span>,
                <span class="hljs-attr">skillPath</span>: actualSkillName
            };
        }
    }

    <span class="hljs-comment">// 4. 都未找到，返回 null</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<p><strong>代码注释与解析</strong>：</p>
<ul>
<li><strong>逻辑优先级</strong>：<code>!forceSuperpowers &amp;&amp; personalDir</code> 条件确保了默认情况下优先搜索个人目录，这是实现自定义覆盖的关键。</li>
<li><strong>路径拼接</strong>：使用 <code>path.join()</code> 确保跨平台路径的正确性。</li>
<li><strong>存在性检查</strong>：<code>fs.existsSync()</code> 同步检查文件是否存在，是决定查找分支的依据。</li>
<li><strong>清晰的返回结构</strong>：返回对象包含文件路径、来源类型和技能路径，为调用者提供完整信息。</li>
</ul>
<h4 data-id="heading-13">5.2 检查更新函数 (<code>checkForUpdates</code>)</h4>
<p>此函数展示了系统与Git的集成，用于实现技能的自动更新提醒，设计上考虑了失败容忍。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 检查Git仓库是否有可用更新。
 *
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">repoDir</span> - Git仓库路径
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 如果有更新则返回 true
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForUpdates</span>(<span class="hljs-params">repoDir</span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 设置3秒超时，避免因网络问题导致启动阻塞</span>
        <span class="hljs-keyword">const</span> output = <span class="hljs-title function_">execSync</span>(<span class="hljs-string">'git fetch origin &amp;&amp; git status --porcelain=v1 --branch'</span>, {
            <span class="hljs-attr">cwd</span>: repoDir,
            <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// 关键：超时设计</span>
            <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf8'</span>,
            <span class="hljs-attr">stdio</span>: <span class="hljs-string">'pipe'</span> <span class="hljs-comment">// 抑制子进程输出到父进程</span>
        });

        <span class="hljs-comment">// 解析 git status 输出来判断是否落后于远程分支</span>
        <span class="hljs-keyword">const</span> statusLines = output.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n'</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> statusLines) {
            <span class="hljs-comment">// 检查状态行中是否包含 `[behind ` 字样</span>
            <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'## '</span>) &amp;&amp; line.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'[behind '</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 存在更新</span>
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 已是最新</span>
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-comment">// 网络错误、git错误、超时等——不阻塞引导流程，优雅降级</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}
</code></pre>
<p><strong>代码注释与解析</strong>：</p>
<ul>
<li><strong>防御性编程</strong>：整个函数被包裹在 <code>try-catch</code> 中，任何异常（网络不通、无Git、超时）都会被捕获并返回 <code>false</code>，确保主流程不因更新检查而崩溃。</li>
<li><strong>超时控制</strong>：<code>timeout: 3000</code> 是关键设置，防止在网络缓慢或不可用时长时间挂起。</li>
<li><strong>高效的更新判断</strong>：通过 <code>git status --porcelain=v1 --branch</code> 获取机器可读的状态，并解析 <code>[behind</code> 关键词来判断是否落后，比直接比较版本哈希更高效。</li>
<li><strong>关注点分离</strong>：此函数只负责检查并返回布尔值，不执行拉取(<code>pull</code>)操作，职责单一。</li>
</ul>
<h3 data-id="heading-14">结论</h3>
<p>Superpowers 项目代表了一种前沿的工程化思路：<strong>不是让人去适应AI的工作模式，而是让AI的行为去适配并强化人类的软件工程规范</strong>。它通过插件化技能架构、强制性的流程钩子、以及创新的子代理协调与审查机制，在AI能力与工程纪律之间架起了一座桥梁。</p>
<p>从技术实现上看，其核心难点不在于复杂的算法，而在于对AI代理行为模式的精细引导、对分布式（子代理）任务状态的管控，以及对复杂技能组合的测试验证。它为“AI辅助软件工程”（AI4SE）这一新兴领域提供了一个扎实的、可扩展的实践范本。</p>
<p>与传统的CI/CD流水线相比，Superpowers 的流水线运作在**“认知层”**，它规范的是需求分析、设计、编码和初级审查这些前期创造性活动；而CI/CD更关注构建、测试、部署等后期自动化活动。二者是互补而非竞争关系，共同构成从“想法”到“上线”的完整自动化链条。</p>
<hr/>
<p><strong>技术栈总结</strong>：Node.js (运行时) + Git (版本与更新) + YAML/Markdown (技能定义) + 特定AI代理SDK (Claude/Codex/OpenCode) + 自定义的代理协调协议。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于 LangChain1.0 构建 RAG Agent 智能检索问答系统（完整可运行代码+详细注释）]]></title>    <link>https://juejin.cn/post/7595878718172250148</link>    <guid>https://juejin.cn/post/7595878718172250148</guid>    <pubDate>2026-01-17T14:55:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595878718172250148" data-draft-id="7595911076014669860" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于 LangChain1.0 构建 RAG Agent 智能检索问答系统（完整可运行代码+详细注释）"/> <meta itemprop="keywords" content="LangChain,人工智能"/> <meta itemprop="datePublished" content="2026-01-17T14:55:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="o_insist"/> <meta itemprop="url" content="https://juejin.cn/user/3307750804423832"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于 LangChain1.0 构建 RAG Agent 智能检索问答系统（完整可运行代码+详细注释）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3307750804423832/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    o_insist
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:55:40.000Z" title="Sat Jan 17 2026 14:55:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>✨ 本文代码均为可直接运行的完整代码，基于LangChain最新版API编写，无过时语法，放心食用～</p>
<h2 data-id="heading-0">✅ 一、安装项目依赖包</h2>
<pre><code class="hljs language-arduino" lang="arduino"># 安装所有核心依赖，一行命令完成配置
pip install langchain langchain-text-splitters langchain-community bs4 python-dotenv
</code></pre>
<hr/>
<h2 data-id="heading-1">✅ 二、初始化三大核心组件（核心配置）</h2>
<p>构建RAG Agent的核心三要素：<strong>对话大模型</strong>、<strong>文本嵌入模型</strong>、<strong>向量存储器</strong></p>
<h3 data-id="heading-2">1. 配置大语言模型（LLM）- 对话生成核心</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 导入对话模型及环境变量配置依赖</span>
from langchain_openai import ChatOpenAI
import os
from dotenv import load_dotenv

<span class="hljs-comment"># 加载.env文件中的环境变量（私密密钥管理，规范开发）</span>
load_dotenv()

<span class="hljs-comment"># 配置通义千问大模型（qwen-max）参数</span>
<span class="hljs-attr">model_name</span> = <span class="hljs-string">"qwen-max"</span>
<span class="hljs-attr">api_key</span> = os.getenv(<span class="hljs-string">"DASHSCOPE_API_KEY"</span>)
<span class="hljs-attr">base_url</span> = os.getenv(<span class="hljs-string">"DASHSCOPE_BASE_URL"</span>)

<span class="hljs-comment"># 初始化聊天模型：低随机性保证回答严谨，适配知识类问答场景</span>
<span class="hljs-attr">model</span> = ChatOpenAI(
    <span class="hljs-attr">model</span>=model_name,
    <span class="hljs-attr">api_key</span>=api_key,
    <span class="hljs-attr">base_url</span>=base_url,
    <span class="hljs-attr">temperature</span>=<span class="hljs-number">0.1</span>,  <span class="hljs-comment"># 温度值越低，回答越精准、确定性越强</span>
)
</code></pre>
<h3 data-id="heading-3">2. 配置文本嵌入模型 - 文本向量化核心</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 导入HuggingFace嵌入模型</span>
from langchain_huggingface import HuggingFaceEmbeddings

<span class="hljs-comment"># 初始化嵌入模型，行业主流轻量级高质量选型</span>
<span class="hljs-comment"># 特点：文本表征能力强、适配中文+英文，首次运行自动缓存至本地，无需重复下载</span>
<span class="hljs-attr">embeddings</span> = HuggingFaceEmbeddings(model_name=<span class="hljs-string">"sentence-transformers/all-mpnet-base-v2"</span>)
</code></pre>
<h3 data-id="heading-4">3. 配置向量存储器 - 向量数据存储核心</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 导入内存级向量存储库</span>
from langchain_core.vectorstores import InMemoryVectorStore

<span class="hljs-comment"># 初始化内存向量库，轻量化无部署，无需持久化磁盘，适合快速开发/演示场景</span>
<span class="hljs-comment"># 绑定已初始化的嵌入模型，实现文本-向量的自动转换与匹配</span>
<span class="hljs-attr">vector_store</span> = InMemoryVectorStore(embeddings)
</code></pre>
<hr/>
<h2 data-id="heading-5">✅ 三、文档处理全流程：加载 → 分片 → 入库（构建检索知识库）</h2>
<p>RAG核心前置步骤：将非结构化的网页文本，处理为结构化的向量知识库，共分3步完成，流程标准化且可复用</p>
<h3 data-id="heading-6">1. 文档加载：精准爬取网页核心内容</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 导入网页加载器及网页解析依赖</span>
import bs4
from langchain_community.document_loaders import WebBaseLoader

<span class="hljs-comment"># 网页解析规则：只提取指定class的核心内容（标题/头部/正文），过滤冗余HTML标签，提升数据质量</span>
<span class="hljs-attr">bs4_strainer</span> = bs4.SoupStrainer(class_=(<span class="hljs-string">"post-title"</span>, <span class="hljs-string">"post-header"</span>, <span class="hljs-string">"post-content"</span>))

<span class="hljs-comment"># 初始化网页加载器，指定爬取路径+解析规则</span>
<span class="hljs-attr">loader</span> = WebBaseLoader(
    <span class="hljs-attr">web_paths</span>=(<span class="hljs-string">"https://lilianweng.github.io/posts/2023-06-23-agent/"</span>,),
    <span class="hljs-attr">bs_kwargs</span>={<span class="hljs-string">"parse_only"</span>: bs4_strainer},
)

<span class="hljs-comment"># 加载网页文档至上下文</span>
<span class="hljs-attr">docs</span> = loader.load()

<span class="hljs-comment"># 校验加载结果：确保成功加载1篇文档</span>
assert len(docs) == 1
<span class="hljs-comment"># 输出文档总字符数，直观查看文本体量</span>
print(f"✅ 文档加载完成，总字符数：{len(docs<span class="hljs-section">[0]</span>.page_content)}")
</code></pre>
<h3 data-id="heading-7">2. 文档分片：最优策略切割文本，保留上下文关联</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 导入递归字符分割器</span>
from langchain_text_splitters import RecursiveCharacterTextSplitter

<span class="hljs-comment"># 初始化文本分割器，采用行业最优的递归分割策略</span>
<span class="hljs-attr">text_splitter</span> = RecursiveCharacterTextSplitter(
    <span class="hljs-attr">chunk_size</span>=<span class="hljs-number">1000</span>,        <span class="hljs-comment"># 单个文本块最大字符数，适配嵌入模型输入长度限制</span>
    <span class="hljs-attr">chunk_overlap</span>=<span class="hljs-number">200</span>,      <span class="hljs-comment"># 相邻文本块重叠字符数，避免关键信息被截断，保留上下文关联性</span>
    <span class="hljs-attr">add_start_index</span>=<span class="hljs-literal">True</span>,   <span class="hljs-comment"># 记录文本块在原始文档中的起始索引，便于溯源匹配内容</span>
)

<span class="hljs-comment"># 对加载的文档进行分片处理</span>
<span class="hljs-attr">all_splits</span> = text_splitter.split_documents(docs)

<span class="hljs-comment"># 输出分片结果</span>
print(f"✅ 文档分片完成，原始文档切分为 {len(all_splits)} 个子文档")
</code></pre>
<h3 data-id="heading-8">3. 向量入库：将分片文本存入向量库，完成知识库构建</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 将所有文本分片存入向量存储器，自动完成「文本→向量」转换+存储</span>
<span class="hljs-attr">document_ids</span> = vector_store.add_documents(documents=all_splits)

<span class="hljs-comment"># 预览前3个文本块的唯一标识ID</span>
print(f"✅ 向量入库完成，文本块ID预览：{document_ids<span class="hljs-section">[:3]</span>}")
</code></pre>
<hr/>
<h2 data-id="heading-9">✅ 四、核心实现：构建 RAG Agent 检索问答智能体（两种主流方案）</h2>
<p>RAG的核心价值：让大模型结合<strong>外部知识库</strong>回答问题，解决大模型「知识过时、事实性错误、领域知识不足」的痛点；</p>
<p>以下提供两种工业界主流的RAG Agent实现方案，按需选择即可，均为可直接运行的最优写法</p>
<h3 data-id="heading-10">✅ 方案一：工具调用型 RAG Agent（推荐）</h3>
<h4 data-id="heading-11">核心逻辑</h4>
<p>自定义检索工具，让大模型<strong>自主决策是否调用检索工具</strong>，并基于检索到的上下文生成答案，具备「工具调用思维」，适配复杂多轮问答/多步骤查询场景，灵活性拉满。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 导入工具装饰器，封装自定义检索工具</span>
<span class="hljs-keyword">from</span> langchain.tools <span class="hljs-keyword">import</span> tool

<span class="hljs-comment"># 封装检索工具：返回检索到的上下文内容+原始文档对象，指定返回格式规范</span>
<span class="hljs-meta">@tool(<span class="hljs-params">response_format=<span class="hljs-string">"content_and_artifact"</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">retrieve_context</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-string">"""核心检索工具：根据用户查询语句，从向量库中检索相关上下文信息，辅助回答问题"""</span>
    <span class="hljs-comment"># 相似度检索：返回匹配度最高的2条文本内容（k值可按需调整）</span>
    retrieved_docs = vector_store.similarity_search(query, k=<span class="hljs-number">2</span>)
    <span class="hljs-comment"># 格式化拼接检索结果：带上元数据+文本内容，提升大模型理解效率</span>
    serialized_context = <span class="hljs-string">"\n\n"</span>.join(
        (<span class="hljs-string">f"Source: <span class="hljs-subst">{doc.metadata}</span>\nContent: <span class="hljs-subst">{doc.page_content}</span>"</span>)
        <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> retrieved_docs
    )
    <span class="hljs-comment"># 返回格式化文本 + 原始文档，兼顾可读性与溯源性</span>
    <span class="hljs-keyword">return</span> serialized_context, retrieved_docs

<span class="hljs-comment"># 构建工具调用型智能体</span>
<span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> create_agent

<span class="hljs-comment"># 配置智能体核心参数：绑定大模型+检索工具+系统提示词</span>
tools = [retrieve_context]
<span class="hljs-comment"># 系统提示词：明确智能体能力边界与行为准则，精准引导大模型调用工具</span>
system_prompt = (
    <span class="hljs-string">"你是一个专业的问答助手，你可以调用检索工具获取外部知识库的上下文信息。\n"</span>
    <span class="hljs-string">"请务必使用检索工具辅助回答用户的查询问题，确保答案的准确性和事实性。"</span>
)
<span class="hljs-comment"># 初始化工具调用型RAG Agent</span>
agent = create_agent(model, tools, system_prompt=system_prompt)
</code></pre>
<h4 data-id="heading-12">✅ 测试方案一：复杂多步骤查询（智能体自主调用工具）</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 测试提问：多步骤复杂查询，考验智能体的工具调用能力与逻辑推理能力</span>
query = (
    <span class="hljs-string">"What is the standard method for Task Decomposition?\n\n"</span>
    <span class="hljs-string">"Once you get the answer, look up common extensions of that method."</span>
)

<span class="hljs-meta"># 流式输出回答结果，实时查看智能体的思考+回答过程（体验更佳）</span>
print(<span class="hljs-string">"===== 工具调用型RAG Agent 回答结果 ====="</span>)
<span class="hljs-keyword">for</span> <span class="hljs-keyword">event</span> <span class="hljs-keyword">in</span> agent.stream(
    {<span class="hljs-string">"messages"</span>: [{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: query}]},
    stream_mode=<span class="hljs-string">"values"</span>,
):
    <span class="hljs-keyword">event</span>[<span class="hljs-string">"messages"</span>][<span class="hljs-number">-1</span>].pretty_print()
</code></pre>
<hr/>
<h3 data-id="heading-13">✅ 方案二：上下文注入型 RAG Agent（极简高效）</h3>
<h4 data-id="heading-14">核心逻辑</h4>
<p>通过<strong>中间件(middleware)</strong> 实现「全自动检索+上下文注入」，无需显式定义工具，智能体会在回答前<strong>自动检索</strong>并将上下文注入到系统提示词中，全程无感调用，代码极简、运行高效，适配简单单轮问答场景。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 构建上下文注入型智能体</span>
<span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> dynamic_prompt, ModelRequest

<span class="hljs-comment"># 定义动态提示词中间件：自动检索+注入上下文，无感知完成检索逻辑</span>
<span class="hljs-meta">@dynamic_prompt</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">prompt_with_context</span>(<span class="hljs-params">request: ModelRequest</span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""核心中间件：从请求中提取用户最新问题，检索相关上下文并注入系统提示词"""</span>
    <span class="hljs-comment"># 提取用户最新的查询语句</span>
    last_query = request.state[<span class="hljs-string">"messages"</span>][-<span class="hljs-number">1</span>].text
    <span class="hljs-comment"># 自动执行相似度检索，获取相关上下文</span>
    retrieved_docs = vector_store.similarity_search(last_query)
    <span class="hljs-comment"># 格式化拼接检索到的文本内容</span>
    docs_content = <span class="hljs-string">"\n\n"</span>.join(doc.page_content <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> retrieved_docs)
    <span class="hljs-comment"># 构造带上下文的系统提示词，让大模型基于外部知识回答</span>
    system_message = (
        <span class="hljs-string">"你是一个专业且乐于助人的问答助手，请严格基于下方提供的上下文信息回答用户问题：\n\n"</span>
        <span class="hljs-string">f"<span class="hljs-subst">{docs_content}</span>"</span>
    )
    <span class="hljs-keyword">return</span> system_message

<span class="hljs-comment"># 初始化上下文注入型RAG Agent：无需传入工具，中间件自动完成检索逻辑</span>
agent = create_agent(model, tools=[], middleware=[prompt_with_context])
</code></pre>
<h4 data-id="heading-15">✅ 测试方案二：基础单轮查询（极简高效）</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 测试提问：基础单轮查询，验证上下文注入效果</span>
<span class="hljs-attr">query</span> = <span class="hljs-string">"What is task decomposition?"</span>

<span class="hljs-comment"># 流式输出回答结果</span>
print("\<span class="hljs-attr">n</span>===== 上下文注入型RAG Agent 回答结果 =====<span class="hljs-string">")
for step in agent.stream(
    {"</span>messages<span class="hljs-string">": [{"</span>role<span class="hljs-string">": "</span>user<span class="hljs-string">", "</span>content<span class="hljs-string">": query}]},
    stream_mode="</span>values<span class="hljs-string">",
):
    step["</span>messages<span class="hljs-string">"][-1].pretty_print()
</span></code></pre>
<hr/>
<h2 data-id="heading-16">✨ 核心知识点补充（掘金专属，加分项）</h2>
<h3 data-id="heading-17">✅ 两种Agent方案对比 &amp; 选型建议</h3>
<ol>
<li><strong>工具调用型（方案一）</strong> ：适合「复杂查询、多轮问答、多步骤推理」场景，大模型自主决策是否调用工具，灵活性强，是工业界主流方案；</li>
<li><strong>上下文注入型（方案二）</strong> ：适合「简单单轮问答、快速开发」场景，代码量少、无感知检索，开发效率高，但灵活性稍弱。</li>
</ol>
<h3 data-id="heading-18">✅ 核心优化点说明</h3>
<ol>
<li><code>temperature=0.1</code>：低温度值保证回答的<strong>精准性和确定性</strong>，适配知识类问答场景，避免生成无关内容；</li>
<li><code>chunk_overlap=200</code>：文本块重叠设计，彻底解决「关键信息被截断」的问题，提升检索召回率；</li>
<li>流式输出<code>stream()</code>：实时返回回答内容，提升用户体验，避免长时间等待；</li>
<li><code>InMemoryVectorStore</code>：轻量化向量库，无需部署、无需持久化，适合快速开发和演示，生产环境可替换为Chroma/Pinecone等持久化向量库。</li>
</ol>
<hr/>
<h3 data-id="heading-19">✨ 总结</h3>
<p>本文完整实现了基于LangChain的RAG Agent智能检索问答系统，从「依赖安装→组件配置→文档处理→智能体构建→测试验证」全流程闭环，代码可直接复制运行，两种主流方案全覆盖，适配不同业务场景。RAG作为LLM落地的核心技术之一，该套代码可无缝迁移至PDF/文档/本地知识库等场景，实用性拉满。</p>
<h3 data-id="heading-20">代码仓库</h3>
<p>gitee：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgitee.com%2Fo_insist%2Flangchain1.0_learn.git" title="https://link.juejin.cn/?target=https%3A%2F%2Fgitee.com%2Fo_insist%2Flangchain1.0_learn.git" target="_blank">gitee.com/o_insist/la…</a></p>
<p>github：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fo-insist%2Flangchain1.0_learn.git" title="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fo-insist%2Flangchain1.0_learn.git" target="_blank">github.com/o-insist/la…</a></p>
<p>🔥 点赞+收藏，后续持续更新LangChain/RAG/Agent相关实战教程，干货满满～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2025：Vibe Coding对我的影响]]></title>    <link>https://juejin.cn/post/7595974133097512994</link>    <guid>https://juejin.cn/post/7595974133097512994</guid>    <pubDate>2026-01-18T03:20:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595974133097512994" data-draft-id="7595974133097381922" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2025：Vibe Coding对我的影响"/> <meta itemprop="keywords" content="人工智能,AI编程"/> <meta itemprop="datePublished" content="2026-01-18T03:20:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ShanekAI"/> <meta itemprop="url" content="https://juejin.cn/user/2027971409616333"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025：Vibe Coding对我的影响
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2027971409616333/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ShanekAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T03:20:03.000Z" title="Sun Jan 18 2026 03:20:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>起初在chatgpt刚出来的时候，用它做一些编码，review代码，感觉确实有点东西，但是总觉得它是一个智能点的搜索器罢了，而且每次的输出也不一定相同，所以有点轻视了AI的影响。直到cursor出来的时候，我第一次感觉到了颠覆，对AI的认知也不再局限于一个智能搜索器的影响中，开始正视它，开始了解它，开始学习它，开始用好它。现在它完完全全就是一个专家，给他好用的工具（MCP、Skills）等，清晰的问题描述与精确的上下文信息，它完全可以解决工作中那些需求。</p>
<hr/>
<h2 data-id="heading-0">AI编码</h2>
<p>现在我不管是工作需求，还是个人玩一玩的项目，百分之六十以上的代码都是AI生成，看似这个比例不是很高，其实很大程度是我没有给它描述清楚，让他mock了一些实现，但是我改动起来也比较快，就一直这么配合着；还有一个原因是公司要求的单测覆盖率要95%，有点夸张，而AI可能确实在这块的预料相对少，导致生成的单测的质量不是很高，所以一般我要介入一下，多数需求编码场景，它都可以独自完成。</p>
<p>但是这也导致了任务的工期缩短，原本两周的迭代开发，有了AI辅助，领导只愿意给你两天，但是你还是需要自测+输出报告，并且每个任务就算AI编码也不能保证没有故障，就会导致新的任务开始开发了，还在改之前任务的bug,心累的说不出话来。</p>
<h2 data-id="heading-1">AI提效</h2>
<p>这个词是最近一年最火热的词，不管是大厂、中厂、小厂。需求提效、测试提效、开发提效等最终都会在人员提效上闭环。不知道这是不是技术变革所带来的必要结果呢，反正过去一年任务在增加，人员在减少这件事在我的项目，我周围的项目团队成了一件很正常的事了。</p>
<h2 data-id="heading-2">开源社区</h2>
<p>过去几个月我也不怎么做分享了，我说的内容动动手指，到chatgpt、Google AI studio等平台基本能获得更高质量的回答，而且我也减少了看社区内容的习惯，因为有些文章从AI拷贝过来，不经过验证就发出来，这些不负责任的做法，有可能导致别人在生产中遇到问题，希望分享的人，最起码把验证过的内容发出来。</p>
<h2 data-id="heading-3">博客</h2>
<p>不知道大家有没有发现，博客形式的分享越来越受欢迎。是不是比起冰冷的文字，可见的口述是一种更好的分享呢？</p>
<h2 data-id="heading-4">写在最后</h2>
<p>AI是会越来越厉害，与其做抱怨的纺织工，不如学习用好纺织机吧。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大模型训练全流程实战指南基础篇（三）——大模型本地部署实战（Vllm与Ollama）]]></title>    <link>https://juejin.cn/post/7595896809652437032</link>    <guid>https://juejin.cn/post/7595896809652437032</guid>    <pubDate>2026-01-18T03:19:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595896809652437032" data-draft-id="7595414148487282728" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大模型训练全流程实战指南基础篇（三）——大模型本地部署实战（Vllm与Ollama）"/> <meta itemprop="keywords" content="人工智能,LangChain,DeepSeek"/> <meta itemprop="datePublished" content="2026-01-18T03:19:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大模型真好玩"/> <meta itemprop="url" content="https://juejin.cn/user/3140624091453053"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大模型训练全流程实战指南基础篇（三）——大模型本地部署实战（Vllm与Ollama）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3140624091453053/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大模型真好玩
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T03:19:25.000Z" title="Sun Jan 18 2026 03:19:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252b3a}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px;color:#5e7ce0}.markdown-body h1{font-size:24px;margin-bottom:5px;margin-top:80px;position:relative;text-align:center}.markdown-body h2{font-size:20px;padding-bottom:12px;border-bottom:1px solid #dfe1e6}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px;margin-top:30px}.markdown-body h5{font-size:14px;margin-top:20px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #dfe1e6;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#ffeeed;color:#c73636;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#252b3a;background:#f8f8f8}.markdown-body a{position:relative;text-decoration:none;color:#5e7ce0;padding-right:18px;padding-bottom:4px}.markdown-body a[href^=http]:after{position:absolute;display:inline-block;width:16px;height:16px;margin-left:2px;margin-top:6px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAACCgAwAEAAAAAQAAACAAAAAAX7wP8AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAABWVJREFUWAnlVktsVFUY/s85997pC9BOTKxRWnEKsXWlxjWJj0RWJjrFAAXjAlewYWOkgauACVu7a2IiNUEyExM3yoZE3Wmi7qgPJthJBDE6JUNpO3Mf5/j95/bOTOcBlBgXejJ37rn/Of/7O/9/iP7vQ/zTAcjnC4ry+a5ii1OkiYTpuvjvEc0Gp51uivP+ZW+QBuSW4QjW5rptAa1Ey0uOGKOxwPetVyafN6p/52/PkNBbjdAhGaGEpMRjLZTryB8+9MUSYSGNRIcBvm8kBAY9tHYlHz78nTs392xIkwv9FA3Oe33bdoX1ZZKOS0bH0CXI6RugYLW6BwIu5gskkQ4sEG0wYF25PjBzbZfSYY6kDLUmWMt7FR7Lw3xYUkaTdjxHfTPnPwav0iEGYADVa9XIRIEyxrAA0jIQxgFL22gYwF7A8/DAzNVdksJvJaTEUZ2kYnZWziN5s1ADPHneEIXByotYuMSrf9JEbbsuv7VcvbaKML8plXtQR0EdIYDqWEmtOgAomZFH8EjWSnek2ulmtljljttHbmaIHCCCHzd9MjwfsmscBeZH9Jyd10nMvz92UQrtCBKvMF06mQy0SiEdRMEGg8mN0YjAlgoDDkPrMI5qJKSkKKydpbB2CZjJkhIBvOBw2CGQgii85bpx//dMqFRKam5uvH7w+K97oe+Cl0HO68uIBH0qyEzpOMwIbZIcFq0I+9cwoElizCjk2KFI1y7Nnx614W1db58fOXIlMzs7Xn/jeDmvBV2Q0mXjGf554O/m4LZHp2N8r61WPMvLZWLdiC4GMAk5BjeeB5lhv39l6+BIbu3m760hXMDKBD08XBKzR8fr04nygnIypOOAJUx/fHrsi0Mnys+vVK+V4VUohaiyPCo2Q9DFALvF/ikw8WS4QvVZALS5ksw47/7R8ejgTPk1UFqU6/3zp8bOM7B/kdu/fkguPGU5JibW+F0sTjWOUw8DklRrg4BiLGeBqbaRLxjlT4no0InFV402RcftJz41cH/f/JnHP3kZaaF6VX/liwist9vYG5+NU9Cg3MNkt/+lU5wS8fTxq3mc7ILjDlAE4CJpe89BOWPiIjBhi9O6PI4G1jsc6RGB3lZwmS76k8H0zOKTkFboG8jS2krFKCX2fvTeaPHIBwAkMHHgncURnL3nuCSnxSopdIzN5th0BIonJ0Lf9yUA9iMkzdRWl3BixOusfDcwQVcS4UKIFwYfGPnM8wY/DyP9NFMXaTE5BU39tGkDgGZz+fJJG0oYcSaOafLcqdECY4LzfSObSzyUOgxqtyisr8SSNOOAkubWoh3TTaeA2YtFEXPnm5x81/j+6MI6JqyS25WSNU6hbCMKHG84marJbdR+vwakRhQLRuQpbzHRLjmpmijI+OmWCtq+LzWtnX5v30gHSsqmWne74DtiACi2+Wz0iXbuLt9D2cDyoPEkWOiyp5XUIwLMi/wJY1FbH5B9ONtdC1KrsD/Q0MCQAS0wccILORDW25amAeOtooAj/KQxfzF17uwTSQ1v3dJ7jnLINwdZYRDa4tPU0sHVXFo/vxFF5BqFqxRfOmgPCk4ft2NgKTCy2Y47JIEg+MIhjYsLy5I25qUYTQlCjMRHsr/UwdYwIK33UO1J5fFNB9XNO6akcywJofVmXQDP2wfrSPcI2xG5BSs3I+IosHr4EtvO1TDAu16xHQq5+ykMblfRXLbhEoFIdDTBdhldvzl+3CMg60ZktI2vNzLW6IIp0waLklot9L63yzuUp8dJd7bglPFe3hIXstBEP58/s6Ocyr4rH2+866ZNbriTzA0RSOWCwakMl1QJgculxPt8Z7O5GLdtW6bvU8R/nO1vb+hMExVAVtEAAAAASUVORK5CYII=");background-size:100%}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #5e7ce0}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #5e7ce0;border-spacing:0}.markdown-body thead{color:#fff;text-align:left}.markdown-body thead tr{background:#5e7ce0}.markdown-body thead th{border-bottom:1px solid #dfe1e6}.markdown-body tr{background-color:#fff}.markdown-body tr:nth-child(2n){background-color:#f2f5fc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#252b3a;padding:1px 23px;margin:22px 0;border-left:4px solid #5e7ce0;background-color:#f2f5fc}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{padding-left:10px;margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5e7ce0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ul li::marker{content:"•";color:#5e7ce0}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body input[type=checkbox]:before{display:inline-block;width:16px;height:16px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAhRJREFUeAHtnLEuBFEUhs9cu7JCskEhIrZAgYZGoREPwBuIygOoPITKA6jEG/AAolFoaFCgICIKZBNiY8Pyz5rNOWe9wNz5T7N3Z2eT/b/7zZlpziat3xKWBDJoEyh5EDd3DTk5r8vV7Yc8vzbl6zvfwvSERIYHyzI90SeLc1WZrFV85PR9oi+N/YMnOT6t/3tiLAeXFqqytjrSFacDYmfvQS6u37tOiPHA7FS/bK6PmWhpj4AJRYGA9MiKzLpK6An+cqiNVmRleUhArrec6PNzt/5sttLgh0cvcvfY6Px+ZNY9I6Ax6gKErY1xmZ8ZyD0E5MJGIgsyIZsunT3g7qALJuTdAp0nWyMTsunS2QNukbpwOcRaPpvOHvxzQow2ZBvrs+nsfLL8o0QQBJFdMO1XGkEjaIQlQCMsD/YIGkEjLAEaYXmwR9AIGmEJ0AjLgz2CRtAIS4BGWB7sETSCRlgCNMLyYI+gETTCEqARlgd7BI2gEZYAjbA82CNoBI2wBGiE5cEeQSNohCVAIywP9ggaQSMsARphebBH0AgaYQnQCMsjYC5SF2agYi2fTWcPGA7VFfO0n8+mswdMyOrCNJwnpz/P6xqZkE2Xzh4w8qcLI4Hbu/dydvkWBRAAQBZk0uOOyKyzp5PARRiF1puNtR+NTh+oMCvtJ+D8F2N6j6x+PrwzG46gRTDDm5BtsAGBg0X924Qfj7i23p7HNgQAAAAASUVORK5CYII=");background-size:100%;position:relative;right:2px;top:-5px}.markdown-body input[type=checkbox]:checked:before{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAABMtJREFUeAHtXM2KFDEQzrQKruIu4mEXRFlUVLz4A4K7B99AcO8io0/gwQfxDVzFuwu+gQf34EG8iOAPKAh6EFlBFMSf/qa2uqszlVR6ZtYxM5PDJNVVSer78nU6KrHzpyxuVlwx44AY2O0T8eb9D7f5fMu9fPvdff7y0/36nbdgdhUdd+jgHnf62JxbObvgjh/d60Pu2R35ajx49Mk9frqlBk7Kw8sXF9y1K4t9cCoi7tz/4F68/tYXMIkPzpzY725dP9yA1tsjoIRpIQHogRWYZSmwJ4Reh06nI2Nd7rYEA8zAzqXAxhgq/pc1d9vHKbEX+Dr4JbzypJDc/YxXYi/wifRLeOXpU5q7n/FK7EXsnBBeeRoqd7/EHj1ZhleeiMjdz8pArRKR+0pb+UsCuK0SkftKW/kzeFmrRHCAxWzufsaJOkqExWzufpOI8EpP1jnCJCK80pN1jjCJ4ICwMigidz/jRD3bI7bZUInIfaWt/KUSuK0SEd4jqFvufgYva5UIDrCYzd3POFFHifhfV/7k8lwPw7D5mUSEV3r854ju2pK7ffOIWzk/X+Go803Lr+ooGqoiwkyP9xzRXVt0q9sE3CgJYTLqfNPyE/irpkoEe2um6ck4bSiBSeD8JBl41jY/Hgd1lIiaaeoyLlsjgUGAjEH3DB4DtUpEW2Z3Mj5GAgA8efbVvXpX/200nln5IMYvKhHDrvylcwdc9+pSNdeg46WQsP7wo2s7fpWYaPT926fw9ZiVk4BpywYJkGuvlJs4EuWS0p/HTyHh3kbzH2najM85cR0lgpPiYMtukFB26m1u5Ua+vkFkWP3Zn0KCJDg1Px6f42Wtvhrhdyz8ncanrFKCmGH1wrwDMCrh/uxPIUFTAvdHbeVPsc1fVRE+c7Ud/k6fWt7XHFlYqcqQ5wTRvWpiY4wrIZwfDUL+akDRUBXB/jCzFCH9SHCzTDRUmsro7z+cEvrHwxOZn2ZTL/pVFcEBtRLoiWXfxQ5ehvoHHx4vpIwUEuJKSMvPz5/zQq0qwmIy5m+rjBQSwnsCQYnlgwjfT72av6oifOba2qnKcOXeGVIP0rT3BALTNr8mBWSpRHAgmJSTtLGhDHwj+A9GPCbX2DNiBSRoShg0H8zl5y/njxIhJ0WntralDJmIbO+UEvz85Zwt9wj7HIDB5Ttp7RkyGbRDSqC49vOjX50P9aexmr+qInzmajvtO13H02SpyrCVMNj8dT7/4BwByDXzRIC0LWXEldA/njVfip9GpV9VERxQM0lPhrVDyrCVMJr5/fwZJ+qWewR1lSuNJ21sXxnjVgIhck5VhM/cqG1WBpIAMX4Z9Xz+eP58sFUiOBArLQcZpQ0CNCXt1HzA5OfPOFGrrwYHyKTwbNJsxolaJUJbKeo0mu/4uMeXBHBbJSK88qP5jo97fAYva5UIDgivHEXk7mecqKNEhFeOhsjdbxKR+0pb+UsCuK0qIveVtvJn8LJWieAAi9nc/YwTdZQIi9nc/SYR4ZWenSO2yZvgcwTuRYZKWBnUI3e/xF7gcmio5L4HWPlL7AVuyPol95W28me8EnuBa8J+sZjM3c94JfYCd6VxTXjaCjDLe+K9cwTuSuOa8LQUYPXvh1d3w0HC7JK8kMK0/rcJfwHkVMYgi4xhOgAAAABJRU5ErkJggg==");background-size:100%}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>上篇文章 <a href="https://juejin.cn/post/7594655863548297268" target="_blank" title="https://juejin.cn/post/7594655863548297268">大模型训练全流程实战指南基础篇（二）——大模型文件结构解读与原理解析</a>剖析了大模型的核心文件组成与生成原理，并通过实战演示了从模型加载到文本生成的完整流程。那么在实际应用中，诸如 DeepSeek、豆包这类大家日常使用的大模型，究竟是如何高效部署并支撑大规模调用呢？本篇笔者与大家一起实战两种主流部署方案：<strong>适合本地快速实验的 Ollama 部署</strong>与<strong>面向生产环境的高性能 Vllm 部署</strong>。笔者将从环境准备、部署步骤到调用示例逐一展开，帮助大家在不同场景下都能顺利搭建自己的大模型服务。(温馨提示：本章内容较长，但详实记载了本地部署的相关步骤，并给出了优化指南，大家如果对部署本地大模型不熟悉可收藏阅读，感谢支持)。</p>
<p>大模型训练对计算资源有一定要求，尤其是GPU显存。为降低学习门槛，笔者与国内主流云平台合作，大家可以通过打开链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fregister%3FagentID%3Duser-XorgKKc56U" target="_blank" title="https://www.lab4ai.cn/register?agentID=user-XorgKKc56U" ref="nofollow noopener noreferrer">www.lab4ai.cn/register?ag…</a> ，体验<strong>H100 GPU 6.5小时</strong>的算力。本系列所有实战教程均将在该平台上完成，帮助大家低成本上手实践。</p>
<p>除大模型训练外，笔者也在同步更新<a href="https://juejin.cn/column/7526240014499495972" target="_blank" title="https://juejin.cn/column/7526240014499495972">《深入浅出LangChain&amp;LangGraph AI Agent 智能体开发》</a>免费专栏，要说明该专栏适合所有对 LangChain 感兴趣的学习者，无论之前是否接触过 LangChain。该专栏基于笔者在实际项目中的深度使用经验，系统讲解了使用LangChain/LangGraph如何开发智能体，目前已更新 37 讲，并持续补充实战与拓展内容。欢迎感兴趣的同学关注笔者的掘金账号与专栏，也可关注笔者的同名微信公众号<strong>大模型真好玩</strong>，每期分享涉及的代码均可在公众号私信: <strong>LangChain智能体开发</strong>免费获取。</p>
<h2 data-id="heading-1">一、本地部署大模型优势</h2>
<p>相信很多同学和我一样，平时会直接使用 DeepSeek、通义千问等提供的 API 服务——这种方式确实方便快捷。既然云端调用如此便利，为什么还要学习本地部署大模型呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d41b84e1bee84b248ed58599ea821c06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=nep5%2B2JfDst5NdX%2BS80d6%2FnhF3Q%3D" alt="0.png" loading="lazy"/></p>
<p>与云端部署相比，将大模型部署在本地通常具备以下几点优势：</p>
<ol>
<li><strong>数据隐私与安全可控</strong><br/>
许多企业会使用内部数据训练或微调大模型，在这个过程中难免需要模型参与数据处理。为避免企业机密、个人隐私或受监管数据上传至第三方平台，本地部署能更好地满足数据合规要求，保障数据不出域。</li>
<li><strong>完全自主的控制权</strong><br/>
云端服务可能因厂商限速、服务中断或模型版本更新而导致调用失败或效果波动（例如年初 DeepSeek 服务受攻击，或平时忘记续费导致调用失败）。本地部署则确保模型版本、服务稳定性完全由自己掌控，避免因外部因素影响业务连续性。</li>
<li><strong>长期成本更可控</strong><br/>
虽然初期需要投入硬件与部署成本，但长期使用边际成本极低，尤其适合高频调用或规模化应用场景。这也避免了因供应商定价策略调整而带来的不确定性，有利于长期项目规划。</li>
</ol>
<p>综上所述，对于重视数据安全、需要稳定服务或长期成本控制的企业、科研团队及开发者来说，掌握本地部署大模型的能力具有重要价值。它不仅是技术保障，也逐渐成为一项核心竞争优势。</p>
<p>接下来，笔者将为大家分享两种实用的部署方案：适合生产环境的高性能 <strong>Vllm</strong> 部署方案，以及适合本地快速实验的 <strong>Ollama</strong> 部署方案。</p>
<h2 data-id="heading-2">二、VLLM大模型部署方案</h2>
<h3 data-id="heading-3">2.1 认识VLLM</h3>
<p>虽然可以使用 <code>transformers</code> 库来完成大模型的调用和推理，但在生产环境中往往需要更高的推理效率。为此专为高性能推理的 <code>vllm</code> 库应运而生。</p>
<p>vLLM 是加州大学伯克利分校开发的一个 Python 库，其核心优势在于<strong>创新的内存管理技术、高效的任务调度能力，以及出色的易用性和兼容性</strong>。这使得它能在相同硬件上显著提升模型推理的吞吐量与并发处理能力。因此，vLLM 非常适合需要快速响应、高并发的生产环境。</p>
<p>值得注意的是，vLLM 目前仅支持 Linux 系统，在 Windows 下无法使用。如果大家使用的是 Windows 环境，可以考虑下文将介绍的 Ollama 框架作为替代方案。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c34d4f9eae04f16afd73c0a1f6c2a4f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=diIqHenp4rb7rspq7FA65SaVEXA%3D" alt="1.png" loading="lazy"/></p>
<p>vllm的核心优势总结主要有以下几点:</p>
<ol>
<li><strong>极致的内存效率:</strong> 利用分页注意力机制和KV缓存， 将显存利用率提高到90%</li>
<li><strong>极高的吞吐量与并发：</strong> 动态合并新请求到正在进行的批处理中，<strong>持续“榨干”GPU算力</strong>，吞吐量可达传统静态批处理的2.8倍</li>
<li><strong>开箱即用的易用性：</strong> vllm与 <strong>HuggingFace</strong> 无缝集成，更是提供 <strong>OpenAI兼容的API</strong>，无需复杂转换即可加载主流开源模型；现有应用可无缝迁移，极大降低部署门槛。</li>
</ol>
<h3 data-id="heading-4">2.2 VLLM大模型部署方案实战</h3>
<p>既然vllm部署有这么大的优点，那接下来必然要学习一下vllm的部署方法了，本次实验环境同样是在九章云极算力平台下进行部署，大家可以通过打开链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fregister%3FagentID%3Duser-XorgKKc56U" target="_blank" title="https://www.lab4ai.cn/register?agentID=user-XorgKKc56U" ref="nofollow noopener noreferrer">www.lab4ai.cn/register?ag…</a> ，免费体验<strong>H100 GPU 6.5小时</strong>的算力。本系列所有实战教程均将在该平台上完成，帮助大家低成本上手实践。</p>
<ol>
<li>
<p><strong>创建实例：</strong> 打开<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fhome" target="_blank" title="https://www.lab4ai.cn/home" ref="nofollow noopener noreferrer">Lab4AI官网</a>，新建一个 VS Code 云实例。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a8434c7ac534356a5b3d4c0e85259c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=9e7XrogfNS7mfeo5FGEc9O%2FjP%2Bs%3D" alt="2.png" loading="lazy"/></p>
</li>
<li>
<p><strong>选择镜像：</strong> 在新建实例页面，选择适合的镜像并完成创建。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d0ec9a3e32b42c2a2167a665e80efd9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=XD%2FLoJOTYIgnFko7EA5JFYd8egE%3D" alt="3.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1823c4078e624aea836abb580e3acc29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=hEWjRJtYYNb0KQk34nizWi0Uptg%3D" alt="4.png" loading="lazy"/></p>
</li>
<li>
<p><strong>检查环境：</strong> 点击 VS Code 中的 Terminal，可以看到系统已预置名为 <code>lf</code> 的 Anaconda 虚拟环境，其中已安装 <code>llamafactory</code> 库及其依赖（包括 vLLM）。<br/>
执行 <code>pip show vllm</code> 可查看当前 vLLM 版本。大家也可以通过 <code>pip install vllm==xxx</code> 安装指定版本，但预置版本通常已足够新。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b7016163cbf4616b68b598651c7913b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=GoprIr6ei81FYAIBDRda6I6PHdQ%3D" alt="6.png" loading="lazy"/></p>
</li>
<li>
<p><strong>查看显存：</strong> vLLM 对显存要求较高。执行 <code>nvidia-smi</code> 命令查看当前 GPU 资源。如图所示，环境配备了一块 80G 显存的 H100 显卡。<br/>
<strong>注意</strong>：一个 32B 参数模型约需 66G 显存，H100 单卡部署可能紧张。为便于演示，笔者选用更轻量的 <code>Qwen3-4B</code> 模型。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a867871529944edbb69efb34add09eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=4fZYhgeGZIXnbalzGINZnHTahHE%3D" alt="19.png" loading="lazy"/></p>
</li>
<li>
<p><strong>下载模型:</strong> 运行大模型第一步首先要下载大模型，大家还记得 <a href="https://juejin.cn/post/7594728203258347554" target="_blank" title="https://juejin.cn/post/7594728203258347554">大模型训练全流程实战指南基础篇（二）——大模型文件结构解读与原理解析</a> 上一小节内容中教大家如何从modelscope处获得模型的方法吧，访问 ModelScope 官网，搜索 <code>Qwen3-4B</code> 模型。点击下载，页面会显示下载命令。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e605b79d9034fccbfa28c8178a924e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=yfF8jxYROfdreb%2F63UKs9F8nR8M%3D" alt="7.png" loading="lazy"/></p>
</li>
<li>
<p><strong>执行下载:</strong> 在终端执行以下命令<code>modelscope download --model Qwen/Qwen3-4B --local_dir ./Qwen3-4B</code>将Qwen3-4B模型下载到当前目录下的<code>Qwen3-4B</code>文件夹中。下载完成后情况如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf52a154926046fa8604371f0c3dcfc8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=WTdcKxNLjIOGM95Zx58HqIvq2%2FY%3D" alt="8.png" loading="lazy"/></p>
</li>
<li>
<p><strong>启动 vLLM 服务:</strong> 模型就绪后，执行以下命令启动兼容 OpenAI API 格式的推理服务器：<code>vllm serve ./Qwen3-4B/ --served-model-name Qwen3-4B --max-model-len 32768 --gpu-memory-utilization 0.9  --port 6666</code> 即可开启兼容OpenAI格式请求的服务器，服务成功启动后，终端会显示运行日志:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc93963b77554ba3a09eb65a7ed7dbfd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=AtUNomw888pTZKJR%2F3IZH%2F0jS84%3D" alt="9.png" loading="lazy"/></p>
</li>
<li>
<p><strong>测试调用:</strong> 在服务器根目录下新建 <code>test.py</code> 文件，并写入以下测试代码（因启动时未指定 API Key，此处可任意填写）。执行 <code>python test.py</code>，成功返回模型响应即表示部署成功。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI
client = OpenAI(base_url=<span class="hljs-string">"http://localhost:6666/v1"</span>, api_key=<span class="hljs-string">"EMPTY"</span>)
response = client.chat.completions.create(model=<span class="hljs-string">"Qwen3-4B"</span>, messages=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好"</span>}])
<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].message.content)
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f27b5e54fac488dabf514f3559789d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=cXsD16ZVk1Au7s%2BlwWQkyx3S2YY%3D" alt="12.png" loading="lazy"/></p>
</li>
</ol>
<p>以上就是使用 vLLM 本地部署大模型的完整流程。掌握本地大模型服务的部署能力，对于后续的数据治理、模型训练与部署都至关重要。</p>
<h3 data-id="heading-5">2.3 VLLM常用部署参数详解</h3>
<p>上一节仅展示了部分命令行参数，下表列出了更多生产中常用的参数及其说明：</p>























































<table><thead><tr><th>参数</th><th>推荐值</th><th>作用说明</th></tr></thead><tbody><tr><td><code>--max-model-len</code></td><td><code>32768</code></td><td>设置模型的最大上下文长度，Qwen3模型支持32K上下文。</td></tr><tr><td><code>--gpu-memory-utilization</code></td><td><code>0.8-0.95</code></td><td>GPU显存利用率，值越高预留空间越少。</td></tr><tr><td><code>--tensor-parallel-size</code></td><td>GPU数量</td><td><strong>张量并行大小</strong>，<strong>必须等于使用的GPU数量</strong>（默认单卡为1），如果你使用两张卡，这里就是2，注意数目只能是<code>2^n</code>次。</td></tr><tr><td><code>--max-num-seqs</code></td><td><code>256</code></td><td>同时处理的最大请求数，影响并发能力。</td></tr><tr><td><code>--enforce-eager</code></td><td>(无值)</td><td><strong>在Ascend NPU上运行可能需要添加此参数</strong>，以避免编译错误。</td></tr><tr><td><code>--api-key</code></td><td>如 <code>abc123</code></td><td>设置API密钥，增加基础安全性。</td></tr><tr><td><code>--enable-function-calling</code></td><td>(无值)</td><td><strong>启用工具功能（之后笔者会讲解）</strong></td></tr><tr><td><code>--pipeline-parallel-size</code></td><td>GPU数量</td><td>流水线并行大小，流水线通过将模型层分布到多个GPU，每个GPU顺序处理，可与<code>tensor-parallel-size</code>参数合用</td></tr><tr><td><code>--enable-expert-parallel</code></td><td>True or False</td><td>针对MoE模型的优化，例如DeepSeek-V3等模型，平衡不同MoE专家计算开销</td></tr></tbody></table>
<p>根据以上参数，如果需要使用 4 张 GPU 来推理 <code>Qwen3-32B</code> 模型，命令应如下所示：</p>
<pre><code class="hljs language-bash" lang="bash">vllm serve \
    --model “Qwen3-32B模型所存位置” \
    --tensor-parallel-size 4 \
    --trust-remote-code \
    --gpu-memory-utilization 0.8 \
    --max-num-seqs 32 \
    --max-model-len 8192 \
    --port 8000
</code></pre>
<p>参数组合清晰明了，相信大家都已经学会啦！</p>
<h3 data-id="heading-6">2.4 VLLM优化技巧</h3>
<p>其实在实际生产环境中为了最大限度的压榨算力，还有很多的vllm的优化技巧，笔者常用的技巧有如下2点：</p>
<ol>
<li><strong>多实例负载均衡</strong><br/>
当有多个相同模型同时部署时（例如 8 张卡，每 2 张部署一个 <code>Qwen3-32B</code>，共 4 个实例），可在前端使用 <strong>Nginx 做负载均衡</strong>，实现吞吐量的线性增长。（如有需要，笔者后续可专门分享此方案。）</li>
<li><strong>超大模型部署策略</strong><br/>
部署参数量极大的模型时，需要合理组合 <strong>TP（张量并行）</strong> 、<strong>PP（流水线并行）</strong>  和 <strong>EP（专家并行）</strong>  策略。通常可以适当调大 TP 和 PP，并将 EP 设为 <code>True</code>，以在多 GPU 同步开销与整体性能之间取得最佳平衡。</li>
</ol>
<h2 data-id="heading-7">三、Ollama大模型部署方案</h2>
<h3 data-id="heading-8">3.1 认识Ollama</h3>
<p>VLLM 部署方案虽然强大，但它主要面向生产环境，需要 Linux 系统和高性能显卡。如果大家想在个人电脑上快速体验模型，或者在 Windows 系统中进行本地调用，有什么更轻便的方案呢？Ollama 正是为此而生。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/24e2cdc9b1264615b194683ec18f5b99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=jUfa0Ygn2kJJOiV3vj%2FKdQ0oRIE%3D" alt="13.png" loading="lazy"/></p>
<p>ollama是在llama.cpp基础上封装的简化的本地部署工具，提供了一键运行功能，非常适合大家非技术模型的快速验证。与vllm相比主要有如下三点优势：</p>
<ol>
<li><strong>部署极其简单，开箱即用</strong>：Ollama提供一键安装脚本和简单的命令行操作，下载后即可快速运行模型，非常适合个人快速体验。而vLLm通常需要配置Python环境、安装CUDA依赖并进行更多初始化设置，门槛相对较高。</li>
<li><strong>对个人硬件更友好，资源要求低</strong>：Ollama专注于在消费级硬件（包括苹果芯片、普通CPU和消费级GPU）上运行。它通过高效的模型量化技术，能用更少的内存或显存运行大模型（不一定需要显卡，内存也可以）。</li>
<li><strong>内置模型库，管理模型非常便捷</strong>：Ollama内置了一个包含大量主流开源预量化模型的“应用商店”。大家可以像安装软件一样，通过一条命令（如 <code>ollama pull Qwen3:4b</code>, 现在甚至不需要命令在界面也可以操作）轻松拉取、运行和切换不同模型，无需手动处理复杂的模型转换和优化步骤。</li>
</ol>
<h3 data-id="heading-9">3.2 ollama部署实战演示</h3>
<p>下面笔者以 Windows 系统为例，演示如何安装和使用 Ollama 部署大模型。目前最新版本的 Ollama 已提供图形界面，可方便地配置模型路径。若想了解更多细节或使用旧版本，可参考笔者之前的文章：<a href="https://juejin.cn/post/7470146014363009061" target="_blank" title="https://juejin.cn/post/7470146014363009061">人工智能大模型入门分享（一）——利用ollama搭建本地大模型服务（DeepSeek-R1)</a></p>
<ol>
<li>
<p><strong>下载安装包：</strong> 访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2F" target="_blank" title="https://ollama.com/" ref="nofollow noopener noreferrer">Ollama 官网</a>，点击右上角 “Download” 按钮，选择 Windows 系统并下载安装包。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a0eda4c6f0e645a98df63ecb0c7a84a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=wibNnPUUMzKpSS5Nb8g7%2Fa2RXg4%3D" alt="14.png" loading="lazy"/></p>
</li>
<li>
<p><strong>安装软件：</strong> 双击下载好的 <code>.exe</code> 文件，点击 “Install” 完成安装，默认安装至 C 盘。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1587217b45bf48d6845c8a760f01ec28~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=TNCPp%2Bb0gteraO7FbI7QIyx5whs%3D" alt="2.jpg" loading="lazy"/></p>
</li>
<li>
<p><strong>修改模型存放路径：</strong> 安装完成后，建议先打开软件设置，将模型保存目录修改到非系统盘（如 D 盘或 E 盘），以避免占用过多系统空间。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba70d6866cce4cdc91251d815117bdf8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=mO37Bj%2ByG5gKjZ4GXDPiy63bgLI%3D" alt="3.jpg" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f35fc63194f4734813b2dca7ef0a15f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=Dr89udfJ4fx7iGZjOWu8wRhhwVY%3D" alt="4.jpg" loading="lazy"/></p>
</li>
<li>
<p><strong>查找模型：</strong> 在 <a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2F" target="_blank" title="https://ollama.com/" ref="nofollow noopener noreferrer">Ollama 官网</a> 的模型搜索页中，搜索 <code>qwen3</code>:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/006c6ba028ca4ad799ccff3edb188c44~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=3vOgR%2FAqB9WjTqDUrVtjMekP8F8%3D" alt="15.png" loading="lazy"/></p>
</li>
<li>
<p><strong>下载并运行模型：</strong> 进入 Qwen3 模型页面，页面会显示运行命令 <code>ollama run qwen3</code>（默认下载 8B 版本）。若想下载 4B 版本，则执行以下命令：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc62384b1b54407fbee6b2b21f3ceec4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=heIy9xPPanqywBczgYNLv1Jgjmo%3D" alt="16.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3860a97ca5cd41d1960931bc000f42ff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=uk5gceFLc8aCDH6nf%2BRth5Xreao%3D" alt="10.jpg" loading="lazy"/></p>
</li>
<li>
<p><strong>在 Ollama 界面中测试：</strong> 下载完成后，可直接在 Ollama 自带的对话界面中输入问题进行测试。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd1d7e4e568f44b2aeda2074fca5db76~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=5RlTDgzNKxEeA2QSPMw%2Fbp6iGRU%3D" alt="6.jpg" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/814eab1cc7cd4732b34f2c0960d93645~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=SqQCD3qYgTdjpd7sg9syoAY95RU%3D" alt="7.jpg" loading="lazy"/></p>
</li>
<li>
<p><strong>通过 OpenAI 兼容 API 调用：</strong> Ollama 同样提供兼容 OpenAI 格式的 API 服务（默认端口为 <code>11434</code>）。可以通过以下 Python 代码进行调用（若本地未安装 <code>openai</code> 库，需先执行 <code>pip install openai</code>）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI
client = OpenAI(base_url=<span class="hljs-string">"http://localhost:11434/v1"</span>, api_key=<span class="hljs-string">"EMPTY"</span>) <span class="hljs-comment">#api_key随便填</span>
response = client.chat.completions.create(model=<span class="hljs-string">"qwen3:4b"</span>, messages=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好"</span>}])
<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].message.content)
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f6d83a270f2b4aee98e2a5d2da1adc35~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=K%2FxFG7c9H4yyih46S7HKK0hYBZ4%3D" alt="11.jpg" loading="lazy"/></p>
</li>
<li>
<p><strong>了解模型存储结构：</strong> Ollama 下载的模型默认保存在你设置的目录下（例如 <code>E:\Ollama\models</code>）。目录内主要包含两个文件夹：</p>
<ul>
<li><code>blobs</code>：存放模型具体的二进制文件（通常以 <code>sh</code> 开头的哈希文件命名）。</li>
<li><code>manifests</code>：存放模型的元数据信息，用于定义哪些文件属于哪个模型。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ab4694ca92e49b8973dfe0766adfb76~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=iJEvcbFBsSIMiCqcnDnOYoudrb4%3D" alt="8.jpg" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0cbebbcf64234b689e21aad2e6caec51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=apFu8bzxQtkC2g3M%2FFlSAVpI6Nk%3D" alt="9.jpg" loading="lazy"/></p>
</li>
<li>
<p><strong>更多配置:</strong> 如需了解更详细的配置选项（如修改端口、启用 GPU 等），可参考笔者之前的文章： <a href="https://juejin.cn/post/7470146014363009061" target="_blank" title="https://juejin.cn/post/7470146014363009061">人工智能大模型入门分享（一）——利用ollama搭建本地大模型服务（DeepSeek-R1)</a>，非常简单，这里就不再赘述了~</p>
</li>
</ol>
<h3 data-id="heading-10">3.3 ollama与量化</h3>
<p>细心观察的大家会发现：在 Ollama 中下载的 Qwen3-4B 模型只有约 2.5 GB，而在 ModelScope 下载的原始模型却有 8.1 GB。Ollama 用了什么“魔法”让模型变得如此小巧？这背后的关键技术就是<strong>模型量化</strong>。</p>
<p><a href="https://juejin.cn/post/7594728203258347554" target="_blank" title="https://juejin.cn/post/7594728203258347554">大模型训练全流程实战指南基础篇（二）——大模型文件结构解读与原理解析</a> 文章中大家了解到，大模型主要由结构和大量参数构成，保存这些参数占用了绝大部分存储空间。</p>
<p>这些参数的储存形式通常都是浮点数，量化就是把浮点数的有效数字的位数进行缩小，举个形象的例子，圆周率可以用3.1415926535来表示，然而默认3.14也可以表示圆周率，存储3.1415926535要11位数字，存储3.14只需要3位数字，存储位数少了，存储模型的大小也自然小了。在大模型上就是把FP16的格式量化为INT4格式，将有效位数从16位降到4位。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06fa6227607f438bb82d2cbf3a17551d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=FIdXYEIO163fSGTgnhMrOd%2F7%2B20%3D" alt="17.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23e7e016df4c43268683dc06091f5435~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769311165&amp;x-signature=hTFPBkT65Kj%2Br%2F1JfUtTwn7UXK0%3D" alt="18.png" loading="lazy"/></p>
<p>Ollama 是基于 <code>llama.cpp</code> 构建的，<code>llama.cpp</code> 是一个高性能的纯 C/C++ 大语言模型推理框架，支持在 CPU 或 GPU 上高效运行，并能够将原始模型进行量化，显著减少模型体积。量化后的模型可以方便地发布和部署，因此 Ollama 默认使用量化后的模型。</p>
<p>进一步来说，<code>llama.cpp</code> 在转换模型时通常将其保存为 <strong>GGUF</strong> 格式。这是一种由 <code>llama.cpp</code> 创始人设计的二进制格式，针对高效推理进行了优化。与 Transformer 原生使用的 <code>*.safetensors</code> 格式不同，GGUF 格式通常将所有模型数据整合为单一文件。Ollama 原生支持该格式，这也解释了为什么在 Ollama 后端文件中会有一个体积特别大的文件——它本质上就是整个量化后的模型。</p>
<p>以上就是笔者今天分享的全部内容啦！本教程示例代码可以关注笔者同名公众号：<strong>大模型真好玩</strong>，并私信<strong>大模型训练</strong>免费获得。</p>
<p>要想完全学懂还是需要亲手实践一下，大家可以照着笔者的教程亲手实践一遍。为降低大家学习门槛，笔者与国内主流云平台合作，大家可以通过打开链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fregister%3FagentID%3Duser-XorgKKc56U" target="_blank" title="https://www.lab4ai.cn/register?agentID=user-XorgKKc56U" ref="nofollow noopener noreferrer">www.lab4ai.cn/register?ag…</a> ，体验<strong>H100 GPU 6.5小时</strong>的算力。本系列所有实战教程均将在该平台上完成，帮助大家低成本上手实践。</p>
<h2 data-id="heading-11">四、总结</h2>
<p>本期内容详细分享了两种主流本地部署方案：面向生产环境、支持高并发的高性能 <strong>VLLM</strong> 部署（适合Linux系统），以及面向个人快速体验、对硬件要求低的轻量级 <strong>Ollama</strong> 部署（支持Windows），提供了从环境准备到代码调用的完整实战步骤，并解释了模型量化原理，旨在帮助读者在不同场景下快速搭建自己的大模型服务。</p>
<p>本地部署的大模型作为万能的api， 可以编写调用脚本进行自然语言处理任务的批处理，将来我们数据处理流程一定会用到。下期分享笔者将为大家讲解大模型请求的各种方式，帮助大家掌握利用大模型api开发各种各样应用的能力，大家敬请期待！大家读完感兴趣可以关注笔者的同名微信公众号：大模型真好玩，获取本系列分享以及其它系列分享的全部内容。</p>
<p>大模型训练对计算资源有一定要求，尤其是GPU显存。为降低学习门槛，笔者与国内主流云平台合作，大家可以通过打开链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fregister%3FagentID%3Duser-XorgKKc56U" target="_blank" title="https://www.lab4ai.cn/register?agentID=user-XorgKKc56U" ref="nofollow noopener noreferrer">www.lab4ai.cn/register?ag…</a>，体验<strong>H100 GPU 6.5小时</strong>的算力。本系列所有实战教程均将在该平台上完成，帮助大家低成本上手实践。</p>
<p>除大模型训练外，笔者也在同步更新<a href="https://juejin.cn/column/7526240014499495972" title="https://juejin.cn/column/7526240014499495972" target="_blank">《深入浅出LangChain&amp;LangGraph AI Agent 智能体开发》</a>免费专栏，要说明该专栏适合所有对 LangChain 感兴趣的学习者，无论之前是否接触过 LangChain。该专栏基于笔者在实际项目中的深度使用经验，系统讲解了使用LangChain/LangGraph如何开发智能体，目前已更新 37 讲，并持续补充实战与拓展内容。欢迎感兴趣的同学关注笔者的掘金账号与专栏，也可关注笔者的同名微信公众号<strong>大模型真好玩</strong>，每期分享涉及的代码均可在公众号私信: <strong>LangChain智能体开发</strong>免费获取。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【深度学习Day10】告别瞎调参！优化器与学习率调度器实战指南]]></title>    <link>https://juejin.cn/post/7596299957277016091</link>    <guid>https://juejin.cn/post/7596299957277016091</guid>    <pubDate>2026-01-17T15:20:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596299957277016091" data-draft-id="7595423767721607177" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【深度学习Day10】告别瞎调参！优化器与学习率调度器实战指南"/> <meta itemprop="keywords" content="深度学习"/> <meta itemprop="datePublished" content="2026-01-17T15:20:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="柠柠酱"/> <meta itemprop="url" content="https://juejin.cn/user/3739876675556569"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【深度学习Day10】告别瞎调参！优化器与学习率调度器实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3739876675556569/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    柠柠酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T15:20:48.000Z" title="Sat Jan 17 2026 15:20:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>为什么同样的模型，换一个优化器和学习率调度器，训练效果就天差地别？今天为你揭秘。</p>
</blockquote>
<p><strong>摘要</strong>：上一篇我们靠迁移学习“抄作业”搞定了高准确率模型，但训练时你大概率会遇到：Loss像坐过山车震荡不收敛、训练到一半准确率卡住不动、换个优化器结果天差地别……今天，我带你彻底搞懂训练的“核心引擎”（优化器）和“关键油门”（学习率）：用代码可视化对比SGD、Adam、AdamW、Muon四大优化器的收敛轨迹，手把手教你用StepLR、CosineAnnealing等调度器实现“自动换挡”，从此告别瞎调参，让模型训练又快又稳！</p>
<p><em>关键词：PyTorch, 优化器, 学习率调度器, SGD, Adam, AdamW, Muon, CosineAnnealingLR, 收敛可视化</em></p>
<h2 data-id="heading-0">1. 开篇灵魂拷问：你是不是在“瞎调参”？</h2>
<p>Day9我们用微调训练ResNet-18时，我特意指定了<code>SGD+CosineAnnealingLR</code>的组合，当时你可能没多想——但如果把优化器换成Adam，学习率固定为0.1，你会发现：要么Loss直接炸到NaN，要么训练20个Epoch准确率还没到80%。</p>
<p>这就是优化器和学习率的“威力”：它们决定了模型“学习的效率”和“最终的上限”。很多新手调参全靠蒙：</p>
<ul>
<li>Loss震荡？就随便把学习率砍一半；</li>
<li>收敛慢？就盲目换成Adam；</li>
<li>过拟合？就乱加权重衰减；</li>
</ul>
<p>本质是没搞懂：不同优化器的“脾气”不同，学习率的“调节逻辑”也不同。今天我们不聊枯燥公式，用“开车”类比搞懂一切：</p>
<ul>
<li><strong>优化器</strong>：相当于汽车的“引擎”——SGD是“手动挡引擎”（稳但需要技巧），Adam是“自动挡引擎”（快但可能刹不住）；</li>
<li><strong>学习率</strong>：相当于“油门大小”——太大容易“冲出路基”（Loss震荡），太小“爬坡太慢”（收敛慢）；</li>
<li><strong>调度器</strong>：相当于“自动换挡系统”——根据训练进度自动调油门，不用手动干预。</li>
</ul>
<h2 data-id="heading-1">2. 四大优化器深度解析：脾气、用法、避坑点</h2>
<p>我们聚焦工业界最常用的四大优化器：SGD（含动量）、Adam、AdamW、Muon，从“通俗原理”“优缺点”“适用场景”三个维度讲透，还附MATLAB老鸟的踩坑总结。</p>
<h3 data-id="heading-2">2.1 SGD（随机梯度下降）：稳如老狗的“手动挡”</h3>
<h4 data-id="heading-3">原理通俗说</h4>
<p>最基础的优化器，核心逻辑就是“朝着Loss下降最快的方向走一步”。就像你开车，每次只看眼前的路，朝着下坡方向开——虽然慢，但不会跑偏。</p>
<p>但纯SGD有个坑：容易卡在“局部小山坡”（局部最优解）。所以实际用的都是<code>SGD+动量（momentum）</code>：相当于开车带了“惯性”，就算遇到小土坡，也能靠惯性冲过去。</p>
<h4 data-id="heading-4">优缺点</h4>
<ul>
<li>优点：收敛稳定、泛化能力强（不容易过拟合）、显存占用最小（适合大模型）；</li>
<li>缺点：收敛慢、需要手动调学习率、对初始化敏感。</li>
</ul>
<h4 data-id="heading-5">适用场景&amp;踩坑点</h4>
<p>✅ 适用：数据量大（如CIFAR-10、ImageNet）、需要高泛化（比如分类任务）、大模型训练；</p>
<p>❌ 踩坑：千万别用太大的学习率（比如0.1以上），尤其是微调预训练模型时，容易冲掉预训练权重；动量一般设0.9（默认值就够用）。</p>
<h3 data-id="heading-6">2.2 Adam：快到飞起的“自动挡”</h3>
<h4 data-id="heading-7">原理通俗说</h4>
<p>Adam=SGD+动量+自适应学习率。相当于给汽车装了“智能导航+自动油门”：不仅能靠惯性冲坡，还能根据路况自动调油门大小——在平坦路段（Loss变化小）加大油门，在颠簸路段（Loss波动大）减小油门。</p>
<h4 data-id="heading-8">优缺点</h4>
<ul>
<li>优点：收敛速度极快（比SGD快2-3倍）、对学习率不敏感（默认0.001就够用）、适合小数据；</li>
<li>缺点：泛化能力略差（容易过拟合）、显存占用比SGD高、部分任务最终准确率不如SGD。</li>
</ul>
<h4 data-id="heading-9">适用场景&amp;踩坑点</h4>
<p>✅ 适用：数据量小（如几百张图片）、快速验证模型可行性、微调小模型；</p>
<p>❌ 踩坑：训练大模型时别用Adam！显存会比SGD多占20%-30%；遇到过拟合时，优先加权重衰减，而不是盲目调学习率。</p>
<h3 data-id="heading-10">2.3 AdamW：Adam的“修复版”，工业界首选</h3>
<h4 data-id="heading-11">原理通俗说</h4>
<p>Adam有个致命缺陷：权重衰减（L2正则）是“加在梯度上”的，导致正则效果打折扣。AdamW直接把权重衰减“独立出来”，相当于给Adam加了个“精准刹车”——既保留了Adam的快，又有了SGD的稳。</p>
<h4 data-id="heading-12">优缺点</h4>
<ul>
<li>优点：兼顾Adam的快和SGD的稳、泛化能力强、对多数任务都友好；</li>
<li>缺点：显存占用比SGD高（和Adam差不多）。</li>
</ul>
<h4 data-id="heading-13">适用场景&amp;踩坑点</h4>
<p>✅ 适用：绝大多数场景（分类、检测、分割）、尤其是预训练模型微调；</p>
<p>❌ 踩坑：PyTorch里AdamW的默认学习率是0.001，微调时建议降到1e-4（和SGD同理，避免冲掉预训练权重）。</p>
<h3 data-id="heading-14">2.4 Muon：小众但高效的“性能级引擎”</h3>
<h4 data-id="heading-15">原理通俗说</h4>
<p>Muon是较新的优化器，专门针对神经网络隐藏层的二维权重参数设计，核心是“动态调整动量和学习率”——比Adam更灵活，比SGD更快。相当于给汽车装了“AI导航”，能提前预判路况，调整油门和档位。</p>
<h4 data-id="heading-16">优缺点</h4>
<ul>
<li>优点：收敛速度比Adam快、泛化能力接近SGD、对复杂任务（大模型训练）表现好；</li>
<li>缺点：需要最新版本的pytorch（2.9.0）。</li>
</ul>
<h4 data-id="heading-17">适用场景&amp;踩坑点</h4>
<p>✅ 适用：复杂任务（医疗影像、工业缺陷检测）、想追求更快收敛又怕过拟合；</p>
<p>❌ 踩坑：需要版本号12.6以上的<code>cuda</code>，只能处理神经网络的二维权重参数。</p>
<h2 data-id="heading-18">3. 学习率调度器：让模型“自动换挡”的神器</h2>
<p>就算选对了优化器，固定学习率也会遇到问题：前期学习率太小，收敛慢；后期学习率太大，Loss震荡不收敛。调度器的作用就是“动态调学习率”——前期加大油门冲，后期减小油门稳，不用手动干预。</p>
<p>我们重点讲3个工业界最常用的调度器，还是用“开车”类比：</p>
<h3 data-id="heading-19">3.1 StepLR：固定节奏“降档”</h3>
<h4 data-id="heading-20">原理通俗说</h4>
<p>每训练<code>step_size</code>个Epoch，就把学习率乘以<code>gamma</code>（衰减系数）。比如<code>step_size=10, gamma=0.1</code>：前10个Epoch用初始学习率，11-20个Epoch用0.1倍学习率，21-30个用0.01倍——相当于固定每开10公里降一档。</p>
<h4 data-id="heading-21">关键代码</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 每10个Epoch学习率衰减为原来的0.1</span>
scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=<span class="hljs-number">10</span>, gamma=<span class="hljs-number">0.1</span>)
</code></pre>
<h4 data-id="heading-22">适用场景</h4>
<p>适合训练节奏清晰的任务（如CIFAR-10分类），优点是简单粗暴、易理解，缺点是不够灵活（不管Loss有没有收敛都降档）。</p>
<h3 data-id="heading-23">3.2 CosineAnnealingLR：模拟余弦曲线“平滑换挡”</h3>
<h4 data-id="heading-24">原理通俗说</h4>
<p>学习率随Epoch按“余弦曲线”变化：先从初始值慢慢降到0，再慢慢升回来（可选）。就像开车时根据坡度平滑调整油门，而不是猛踩或猛松——<a href="https://juejin.cn/post/7595423675459190822" target="_blank" title="https://juejin.cn/post/7595423675459190822">【深度学习Day9】</a>我们用的就是这个，能有效避免后期Loss震荡。</p>
<h4 data-id="heading-25">关键代码</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># T_max：学习率从最大降到最小的Epoch数（一般设为总Epoch数）</span>
scheduler = optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=<span class="hljs-number">20</span>)
</code></pre>
<h4 data-id="heading-26">适用场景</h4>
<p>几乎所有任务（尤其是预训练模型微调），优点是收敛稳定、最终准确率高，缺点是需要提前确定总Epoch数。</p>
<h3 data-id="heading-27">3.3 ReduceLROnPlateau：根据“路况”智能换挡</h3>
<h4 data-id="heading-28">原理通俗说</h4>
<p>不按固定Epoch降档，而是监控某个指标（如验证集准确率）：如果指标连续<code>patience</code>个Epoch没提升，就自动降低学习率。相当于汽车的“自适应巡航”，根据实际路况调整油门，最智能的调度器。</p>
<h4 data-id="heading-29">关键代码</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 监控验证集准确率，连续5个Epoch没提升就降档（gamma=0.1）</span>
scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=<span class="hljs-string">'max'</span>, patience=<span class="hljs-number">5</span>, gamma=<span class="hljs-number">0.1</span>)
</code></pre>
<h4 data-id="heading-30">适用场景</h4>
<p>适合不知道总Epoch数、任务复杂（如检测、分割），优点是智能、不用手动调Epoch，缺点是需要每次Epoch都评估验证集（多花一点时间）。</p>
<h2 data-id="heading-31">4. 代码实战：可视化对比+调度器实战</h2>
<p>我们用<a href="https://juejin.cn/post/7595423675459190822" target="_blank" title="https://juejin.cn/post/7595423675459190822">【深度学习Day9】</a>的“魔改ResNet-18+CIFAR-10”任务，做两个核心实战：① 可视化四大优化器的收敛轨迹；② 对比不同调度器的效果。代码可直接复制运行。</p>
<h3 data-id="heading-32">4.1 实战1：四大优化器收敛轨迹可视化</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn
<span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim
<span class="hljs-keyword">import</span> torchvision
<span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms
<span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet18, ResNet18_Weights
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># ========== 环境配置+数据准备 ==========</span>
device = torch.device(<span class="hljs-string">"cuda:0"</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">"cpu"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"使用设备：<span class="hljs-subst">{device}</span>"</span>)
batch_size = <span class="hljs-number">128</span>
epochs = <span class="hljs-number">20</span>
lr = <span class="hljs-number">0.01</span>  

<span class="hljs-comment"># 数据预处理</span>
transform_train = transforms.Compose([
    transforms.RandomCrop(<span class="hljs-number">32</span>, padding=<span class="hljs-number">4</span>),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    transforms.Normalize((<span class="hljs-number">0.4914</span>, <span class="hljs-number">0.4822</span>, <span class="hljs-number">0.4465</span>), (<span class="hljs-number">0.2023</span>, <span class="hljs-number">0.1994</span>, <span class="hljs-number">0.2010</span>)),
])
transform_test = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((<span class="hljs-number">0.4914</span>, <span class="hljs-number">0.4822</span>, <span class="hljs-number">0.4465</span>), (<span class="hljs-number">0.2023</span>, <span class="hljs-number">0.1994</span>, <span class="hljs-number">0.2010</span>)),
])

trainset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transform_train)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)
testset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=transform_test)
testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="hljs-number">100</span>, shuffle=<span class="hljs-literal">False</span>)

<span class="hljs-comment"># ========== 定义魔改ResNet-18（复用Day9代码） ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_modified_resnet18</span>():
    model = resnet18(weights=ResNet18_Weights.DEFAULT)
    model.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)
    model.maxpool = nn.Identity()
    num_ftrs = model.fc.in_features
    model.fc = nn.Linear(num_ftrs, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">return</span> model.to(device)

<span class="hljs-comment"># ========== 拆分2D/非2D参数的函数（适配Muon） ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">split_muon_adam_params</span>(<span class="hljs-params">model</span>):
    muon_params = []  <span class="hljs-comment"># 2D参数（仅全连接层权重）</span>
    adam_params = []  <span class="hljs-comment"># 非2D参数（卷积层/偏置）</span>
    <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> model.named_parameters():
        <span class="hljs-keyword">if</span> param.dim() == <span class="hljs-number">2</span>:
            muon_params.append(param)
        <span class="hljs-keyword">else</span>:
            adam_params.append(param)
    <span class="hljs-keyword">return</span> muon_params, adam_params

<span class="hljs-comment"># ========== 测试集评估函数 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_test</span>(<span class="hljs-params">model, testloader, device</span>):
    model.<span class="hljs-built_in">eval</span>() 
    correct = <span class="hljs-number">0</span>
    total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">with</span> torch.no_grad():  
        <span class="hljs-keyword">for</span> inputs, labels <span class="hljs-keyword">in</span> testloader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            _, predicted = outputs.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)
            total += labels.size(<span class="hljs-number">0</span>)
            correct += predicted.eq(labels).<span class="hljs-built_in">sum</span>().item()
    test_acc = <span class="hljs-number">100.</span> * correct / total
    <span class="hljs-keyword">return</span> test_acc

<span class="hljs-comment"># ========== 重定义训练函数（支持组合优化器） ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">train_optimizer</span>(<span class="hljs-params">model, optimizer, criterion, trainloader, testloader, epochs, device, optimizer_name, schedulers=<span class="hljs-literal">None</span></span>):
    model.train()
    loss_history = [] 
    train_acc_history = []  
    test_acc_history = []   
    total_time = <span class="hljs-number">0.0</span>   
    max_memory = <span class="hljs-number">0.0</span>  
    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):
        epoch_start = time.time()
        running_loss = <span class="hljs-number">0.0</span>
        correct = <span class="hljs-number">0</span>
        total = <span class="hljs-number">0</span>
        model.train()
        <span class="hljs-keyword">for</span> i, (inputs, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trainloader):
            inputs, labels = inputs.to(device), labels.to(device)
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(optimizer, <span class="hljs-built_in">list</span>):
                <span class="hljs-keyword">for</span> opt <span class="hljs-keyword">in</span> optimizer:
                    opt.zero_grad()
            <span class="hljs-keyword">else</span>:
                optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(optimizer, <span class="hljs-built_in">list</span>):
                <span class="hljs-keyword">for</span> opt <span class="hljs-keyword">in</span> optimizer:
                    opt.step()
            <span class="hljs-keyword">else</span>:
                optimizer.step()
            running_loss += loss.item()
            _, predicted = outputs.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)
            total += labels.size(<span class="hljs-number">0</span>)
            correct += predicted.eq(labels).<span class="hljs-built_in">sum</span>().item()
        epoch_loss = running_loss / <span class="hljs-built_in">len</span>(trainloader)
        train_acc = <span class="hljs-number">100.</span> * correct / total
        <span class="hljs-comment"># 计算当前Epoch测试准确率</span>
        test_acc = evaluate_test(model, testloader, device)
        epoch_time = time.time() - epoch_start
        loss_history.append(epoch_loss)
        train_acc_history.append(train_acc)
        test_acc_history.append(test_acc)
        total_time += epoch_time

        <span class="hljs-keyword">if</span> schedulers <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(schedulers, <span class="hljs-built_in">list</span>):
                <span class="hljs-keyword">for</span> sch <span class="hljs-keyword">in</span> schedulers:
                    sch.step()
            <span class="hljs-keyword">else</span>:
                schedulers.step()
    <span class="hljs-keyword">return</span> loss_history, train_acc_history, test_acc_history, total_time, max_memory

<span class="hljs-comment"># ========== 初始化四大优化器+训练 ==========</span>
results = {}
criterion = nn.CrossEntropyLoss()

<span class="hljs-comment"># 1. SGD（无动量）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n===== 开始训练：SGD（无动量）====="</span>)
model_sgd = get_modified_resnet18()
optimizer_sgd = optim.SGD(model_sgd.parameters(), lr=lr)
scheduler_sgd = optim.lr_scheduler.CosineAnnealingLR(optimizer_sgd, T_max=epochs)
loss_sgd, train_acc_sgd, test_acc_sgd, time_sgd, mem_sgd = train_optimizer(
    model_sgd, optimizer_sgd, criterion, trainloader, testloader, epochs, device, <span class="hljs-string">"SGD"</span>, scheduler_sgd
)
results[<span class="hljs-string">"SGD"</span>] = (loss_sgd, train_acc_sgd, test_acc_sgd, time_sgd, mem_sgd)

<span class="hljs-comment"># 2. SGD+momentum</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n===== 开始训练：SGD+momentum====="</span>)
model_sgd_mom = get_modified_resnet18()
optimizer_sgd_mom = optim.SGD(model_sgd_mom.parameters(), lr=lr, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">5e-4</span>)
scheduler_sgd_mom = optim.lr_scheduler.CosineAnnealingLR(optimizer_sgd_mom, T_max=epochs)
loss_sgd_mom, train_acc_sgd_mom, test_acc_sgd_mom, time_sgd_mom, mem_sgd_mom = train_optimizer(
    model_sgd_mom, optimizer_sgd_mom, criterion, trainloader, testloader, epochs, device, <span class="hljs-string">"SGD+momentum"</span>, scheduler_sgd_mom
)
results[<span class="hljs-string">"SGD+momentum"</span>] = (loss_sgd_mom, train_acc_sgd_mom, test_acc_sgd_mom, time_sgd_mom, mem_sgd_mom)

<span class="hljs-comment"># 3. AdamW（工业界首选）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n===== 开始训练：AdamW====="</span>)
model_adamw = get_modified_resnet18()
optimizer_adamw = optim.AdamW(model_adamw.parameters(), lr=lr*<span class="hljs-number">0.1</span>) 
scheduler_adamw = optim.lr_scheduler.CosineAnnealingLR(optimizer_adamw, T_max=epochs)
loss_adamw, train_acc_adamw, test_acc_adamw, time_adamw, mem_adamw = train_optimizer(
    model_adamw, optimizer_adamw, criterion, trainloader, testloader, epochs, device, <span class="hljs-string">"AdamW"</span>, scheduler_adamw
)
results[<span class="hljs-string">"AdamW"</span>] = (loss_adamw, train_acc_adamw, test_acc_adamw, time_adamw, mem_adamw)

<span class="hljs-comment"># 4. Muon+Adam（拆分2D/非2D参数）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n===== 开始训练：Muon+Adam====="</span>)
model_muon = get_modified_resnet18()
muon_params, adam_params = split_muon_adam_params(model_muon)
optimizer_muon = optim.Muon(muon_params, lr=lr*<span class="hljs-number">0.1</span>)  
optimizer_adam = optim.Adam(adam_params, lr=lr*<span class="hljs-number">0.1</span>)
optimizer_comb = [optimizer_muon, optimizer_adam]
scheduler_muon = optim.lr_scheduler.CosineAnnealingLR(optimizer_muon, T_max=epochs)
scheduler_adam = optim.lr_scheduler.CosineAnnealingLR(optimizer_adam, T_max=epochs)
schedulers_comb = [scheduler_muon, scheduler_adam]
loss_muon, train_acc_muon, test_acc_muon, time_muon, mem_muon = train_optimizer(
    model_muon, optimizer_comb, criterion, trainloader, testloader, epochs, device, <span class="hljs-string">"Muon+Adam"</span>, schedulers_comb
)
results[<span class="hljs-string">"Muon+Adam"</span>] = (loss_muon, train_acc_muon, test_acc_muon, time_muon, mem_muon)
</code></pre>
<h3 data-id="heading-33">4.2 实战2：调度器效果对比（以SGD为例）</h3>
<pre><code class="hljs language-scss" lang="scss"># 延续上面的环境和模型，对比<span class="hljs-number">3</span>种调度器
def <span class="hljs-built_in">train_scheduler</span>(model, optimizer, scheduler, criterion, trainloader, testloader, epochs, device, scheduler_name):
    model.<span class="hljs-built_in">train</span>()
    loss_history = []
    acc_history = []
    val_acc_history = []
    total_time = <span class="hljs-number">0.0</span>
    max_memory = <span class="hljs-number">0.0</span>
    for epoch in <span class="hljs-built_in">range</span>(epochs):
        epoch_start = time.<span class="hljs-built_in">time</span>()
        running_loss = <span class="hljs-number">0.0</span>
        correct = <span class="hljs-number">0</span>
        total = <span class="hljs-number">0</span>
        for i, (inputs, labels) in <span class="hljs-built_in">enumerate</span>(trainloader):
            inputs, labels = inputs.<span class="hljs-built_in">to</span>(device), labels.<span class="hljs-built_in">to</span>(device)
            optimizer.<span class="hljs-built_in">zero_grad</span>()
            outputs = <span class="hljs-built_in">model</span>(inputs)
            loss = <span class="hljs-built_in">criterion</span>(outputs, labels)
            loss.<span class="hljs-built_in">backward</span>()
            optimizer.<span class="hljs-built_in">step</span>()
            running_loss += loss.<span class="hljs-built_in">item</span>()
            _, predicted = outputs.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)
            total += labels.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>)
            correct += predicted.<span class="hljs-built_in">eq</span>(labels).<span class="hljs-built_in">sum</span>().<span class="hljs-built_in">item</span>()

        val_acc = <span class="hljs-built_in">evaluate</span>(model, testloader, device)
        # 更新调度器（注意：ReduceLROnPlateau需要传验证集指标）
        if <span class="hljs-built_in">isinstance</span>(scheduler, optim.lr_scheduler.ReduceLROnPlateau):
            scheduler.<span class="hljs-built_in">step</span>(val_acc)
        else:
            scheduler.<span class="hljs-built_in">step</span>()
        epoch_loss = running_loss / <span class="hljs-built_in">len</span>(trainloader)
        epoch_acc = <span class="hljs-number">100</span>. * correct / total
        loss_history.<span class="hljs-built_in">append</span>(epoch_loss)
        acc_history.<span class="hljs-built_in">append</span>(epoch_acc)
        val_acc_history.<span class="hljs-built_in">append</span>(val_acc)
        total_time += time.<span class="hljs-built_in">time</span>() - epoch_start

        current_lr = optimizer.param_groups[<span class="hljs-number">0</span>][<span class="hljs-string">'lr'</span>]
        <span class="hljs-built_in">print</span>(f<span class="hljs-string">"【{scheduler_name}】Epoch [{epoch+1}/{epochs}], Loss: {epoch_loss:.3f}, Train Acc: {epoch_acc:.2f}%, Val Acc: {val_acc:.2f}%, LR: {current_lr:.6f}"</span>)
    return loss_history, acc_history, val_acc_history, total_time, max_memory

# 定义评估函数
def <span class="hljs-built_in">evaluate</span>(model, testloader, device):
    model.<span class="hljs-built_in">eval</span>()
    correct = <span class="hljs-number">0</span>
    total = <span class="hljs-number">0</span>
    with torch.<span class="hljs-built_in">no_grad</span>():
        for inputs, labels in testloader:
            inputs, labels = inputs.<span class="hljs-built_in">to</span>(device), labels.<span class="hljs-built_in">to</span>(device)
            outputs = <span class="hljs-built_in">model</span>(inputs)
            _, predicted = outputs.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)
            total += labels.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>)
            correct += predicted.<span class="hljs-built_in">eq</span>(labels).<span class="hljs-built_in">sum</span>().<span class="hljs-built_in">item</span>()
    return <span class="hljs-number">100</span>. * correct / total

# ========== 初始化<span class="hljs-number">3</span>种调度器+训练 ==========
scheduler_results = {}
base_optimizer = optim<span class="hljs-selector-class">.SGD</span>(get_modified_resnet18()<span class="hljs-selector-class">.parameters</span>(), lr=lr, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">5</span>e-<span class="hljs-number">4</span>)

# <span class="hljs-number">1</span>. 无调度器（固定学习率）
<span class="hljs-built_in">print</span>("\n===== 开始训练：无调度器（固定LR）=====")
model_no_sched = <span class="hljs-built_in">get_modified_resnet18</span>()
optimizer_no_sched = optim<span class="hljs-selector-class">.SGD</span>(model_no_sched.parameters(), lr=lr, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">5</span>e-<span class="hljs-number">4</span>)
loss_no_sched, acc_no_sched, val_no_sched, time_no_sched, mem_no_sched = <span class="hljs-built_in">train_scheduler</span>(
    model_no_sched, optimizer_no_sched, None, criterion, trainloader, testloader, epochs, device, "无调度器"
)
scheduler_results<span class="hljs-selector-attr">[<span class="hljs-string">"无调度器"</span>]</span> = (loss_no_sched, acc_no_sched, val_no_sched, time_no_sched, mem_no_sched)

# <span class="hljs-number">2</span>. StepLR
<span class="hljs-built_in">print</span>("\n===== 开始训练：StepLR=====")
model_step = <span class="hljs-built_in">get_modified_resnet18</span>()
optimizer_step = optim<span class="hljs-selector-class">.SGD</span>(model_step.parameters(), lr=lr, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">5</span>e-<span class="hljs-number">4</span>)
scheduler_step = optim<span class="hljs-selector-class">.lr_scheduler</span><span class="hljs-selector-class">.StepLR</span>(optimizer_step, step_size=<span class="hljs-number">10</span>, gamma=<span class="hljs-number">0.1</span>)
loss_step, acc_step, val_step, time_step, mem_step = <span class="hljs-built_in">train_scheduler</span>(
    model_step, optimizer_step, scheduler_step, criterion, trainloader, testloader, epochs, device, "StepLR"
)
scheduler_results<span class="hljs-selector-attr">[<span class="hljs-string">"StepLR"</span>]</span> = (loss_step, acc_step, val_step, time_step, mem_step)

# <span class="hljs-number">3</span>. CosineAnnealingLR
<span class="hljs-built_in">print</span>("\n===== 开始训练：CosineAnnealingLR=====")
model_cosine = <span class="hljs-built_in">get_modified_resnet18</span>()
optimizer_cosine = optim<span class="hljs-selector-class">.SGD</span>(model_cosine.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">5</span>e-<span class="hljs-number">4</span>)
scheduler_cosine = optim<span class="hljs-selector-class">.lr_scheduler</span><span class="hljs-selector-class">.CosineAnnealingLR</span>(optimizer_cosine, T_max=<span class="hljs-number">10</span>)
loss_cosine, acc_cosine, val_cosine, time_cosine, mem_cosine = <span class="hljs-built_in">train_scheduler</span>(
    model_cosine, optimizer_cosine, scheduler_cosine, criterion, trainloader, testloader, epochs, device, "CosineAnnealingLR"
)
scheduler_results<span class="hljs-selector-attr">[<span class="hljs-string">"CosineAnnealingLR"</span>]</span> = (loss_cosine, acc_cosine, val_cosine, time_cosine, mem_cosine)
</code></pre>
<h3 data-id="heading-34">4.3 实战关键说明（新手必看）</h3>
<ol>
<li>学习率统一：为了公平对比，SGD+momentum用0.01，AdamW和Muon用0.001（AdamW默认值），避免因学习率不同导致结果偏差；</li>
<li>要用Muon的话，需要先更新驱动，需要最新版本的PyTorch。如果安装失败，可跳过Muon，重点对比SGD、SGD+momentum、AdamW；</li>
</ol>
<h2 data-id="heading-35">5. 实验结果对比与结论（2080Ti实测）</h2>
<h3 data-id="heading-36">5.1 四大优化器对比</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dbdcd76cd5e146c0b79558abf3b88179~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p-g5p-g6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769268048&amp;x-signature=43nOgGkfP70JI2vtkyiqT7yCenE%3D" alt="optimizer_comparison.png" loading="lazy"/></p>



































<table><thead><tr><th>优化器</th><th>Epoch20准确率</th><th>总训练时间</th><th>核心结论</th></tr></thead><tbody><tr><td>SGD（无动量）</td><td>92.34%</td><td>18分钟</td><td>收敛慢，不推荐</td></tr><tr><td>SGD+momentum</td><td>95.53%</td><td>19分钟</td><td>稳且省显存，分类任务首选</td></tr><tr><td>AdamW</td><td>94.21%</td><td>18分钟</td><td>快且准，复杂任务首选</td></tr><tr><td>Muon+Adam</td><td>94.72%</td><td>18分钟</td><td>快，但需更新cuda驱动</td></tr></tbody></table>
<h3 data-id="heading-37">5.2 调度器对比</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5f5e779c82748249a97ede0702336e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p-g5p-g6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769268048&amp;x-signature=rjPwvzIqXre%2FkVasKoI%2Byu70W9M%3D" alt="scheduler_comparison.png" loading="lazy"/></p>
<ul>
<li>无调度器（固定LR）：Epoch10后准确率就卡住（92%左右），Loss震荡；</li>
<li>StepLR：Epoch10降档后准确率提升到94%，但后期还是震荡；</li>
<li>CosineAnnealingLR：最终准确率94.2%，Loss全程平滑下降，无震荡——这就是<a href="https://juejin.cn/post/7595423675459190822" target="_blank" title="https://juejin.cn/post/7595423675459190822">【深度学习Day9】</a> 选它的原因！</li>
</ul>
<h3 data-id="heading-38">5.3 终极调参建议（MATLAB老鸟总结）</h3>
<p>不用记复杂公式，按这个优先级选就行：</p>
<ol>
<li>分类任务（CIFAR-10、ImageNet）：<code>SGD+momentum+CosineAnnealingLR</code>（稳、省显存、泛化好）；</li>
<li>复杂任务（检测、分割、医疗影像）：<code>AdamW+CosineAnnealingLR</code>（快、准、容错率高）；</li>
<li>小数据/快速验证：<code>AdamW+无调度器</code>（默认lr=0.001，开箱即用）；</li>
<li>大模型/显存紧张：<code>SGD+momentum+StepLR</code>（显存占用最小）。</li>
</ol>
<h2 data-id="heading-39">6. 面试避坑指南（高频问题+标准答案）</h2>
<h3 data-id="heading-40">Q1：Adam和SGD谁更好？什么时候用Adam，什么时候用SGD？</h3>
<p>答：没有绝对的好坏，看场景：</p>
<ul>
<li>数据量大、需要高泛化（如分类任务）：用SGD（+momentum）——泛化能力强，显存占用小；</li>
<li>数据量小、复杂任务、快速验证：用Adam/AdamW——收敛快，对学习率不敏感。</li>
</ul>
<h3 data-id="heading-41">Q2：AdamW和Adam的区别是什么？为什么工业界现在都用AdamW？</h3>
<p>答：核心区别是“权重衰减的实现方式”：</p>
<ul>
<li>Adam：权重衰减是“加在梯度上”的，相当于“衰减后再更新梯度”，正则效果打折扣；</li>
<li>AdamW：权重衰减是“独立于梯度更新”的，相当于“先更新梯度，再单独衰减权重”，正则效果更精准。</li>
</ul>
<p>工业界用AdamW是因为它兼顾了Adam的快和SGD的泛化能力，尤其是预训练模型微调时，效果比Adam好很多。</p>
<h3 data-id="heading-42">Q3：学习率调度器的核心作用是什么？常用的调度器有哪些？</h3>
<p>答：核心作用是“动态调整学习率”，解决固定学习率的痛点：前期收敛慢、后期震荡不收敛。</p>
<p>常用的3种：StepLR（固定节奏降档）、CosineAnnealingLR（平滑降档，首选）、ReduceLROnPlateau（根据验证集指标智能降档）。</p>
<h3 data-id="heading-43">Q4：为什么微调预训练模型时，学习率要设得很小（比如1e-4）？</h3>
<p>答：预训练模型的权重已经是“比较优”的状态，相当于模型已经“学会了通用知识”。如果学习率太大，会快速冲掉这些优质权重，导致模型性能下降——就像老司机开车，在高速上不需要猛踩油门，轻轻点一下就行。</p>
<h2 data-id="heading-44">📌 下期预告</h2>
<p>搞定了优化器，我们的模型训练已经很专业了。 但直到现在，我们都是在做 <strong>“监督学习”</strong> —— 必须要有标签（Label）才能训练。 如果我有一堆图，但<strong>没有标签</strong>怎么办？能不能让神经网络自己学会“什么是图”？ 下一篇，我们将进入无监督学习的奇幻领域 —— <strong>自编码器 (AutoEncoder, AE) 与数据降维</strong>。 作为 MATLAB 老鸟，你会发现这不就是神经网络版的 <strong>PCA (主成分分析)</strong> 吗？我们将用它来做图像去噪和压缩，非常好玩！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Mybatis执行Mapper过程详解]]></title>    <link>https://juejin.cn/post/7595894884958191667</link>    <guid>https://juejin.cn/post/7595894884958191667</guid>    <pubDate>2026-01-18T04:01:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595894884958191667" data-draft-id="7596299957277458459" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Mybatis执行Mapper过程详解"/> <meta itemprop="keywords" content="Java,源码阅读,MyBatis"/> <meta itemprop="datePublished" content="2026-01-18T04:01:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员侠客行"/> <meta itemprop="url" content="https://juejin.cn/user/556801719828361"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Mybatis执行Mapper过程详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/556801719828361/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员侠客行
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-18T04:01:45.000Z" title="Sun Jan 18 2026 04:01:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>上一篇《<a href="https://juejin.cn/post/7589212818808176703" target="_blank" title="https://juejin.cn/post/7589212818808176703">Mybatis二级缓存实现详解</a>》介绍了二级缓存的实现类型、创建和使用。现在我们一起来看看，Mybatis中Mapper接口是如何被代理并执行SQL语句的？</p>
<blockquote>
<p>注：本文中源码来自mybatis 3.4.x版本，地址<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmybatis%2Fmybatis-3.git" target="_blank" title="https://github.com/mybatis/mybatis-3.git" ref="nofollow noopener noreferrer">github.com/mybatis/myb…</a></p>
</blockquote>
<h2 data-id="heading-0">一 注册Mapper接口</h2>
<h3 data-id="heading-1">1.1解析Mapper</h3>
<h4 data-id="heading-2">XML方式解析</h4>
<p>在主配置文件 (如mybatis-config.xml)，可以做如下配置，来指定Mapper集。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 方式1：指定包名，批量注册 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.example.mapper"</span>/&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 方式2：指定XML文件路径 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/example/mapper/UserMapper.xml"</span>/&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 方式3：指定URL --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"file:///var/mappers/UserMapper.xml"</span>/&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 方式4：指定接口类名 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.mapper.UserMapper"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>
</code></pre>
<p>XMLConfigBuilder.mapperElement()会处理这些配置。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a042d7d118b346abad08f66c766b17b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=n6VcP4LT5bnHkEQ1hoFNzwg4aUo%3D" alt="" loading="lazy"/>
然后XMLMapperBuilder#bindMapperForNamespace，注册Mapper接口到Configuration</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindMapperForNamespace</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// mapper.xml的namespace就是接口的全限定名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">namespace</span> <span class="hljs-operator">=</span> builderAssistant.getCurrentNamespace();
    <span class="hljs-keyword">if</span> (namespace != <span class="hljs-literal">null</span>) {
        Class&lt;?&gt; boundType = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            boundType = Resources.classForName(namespace);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-comment">//ignore, bound type is not required</span>
        }
        <span class="hljs-keyword">if</span> (boundType != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (!configuration.hasMapper(boundType)) {               
                configuration.addLoadedResource(<span class="hljs-string">"namespace:"</span> + namespace);
                <span class="hljs-comment">// 注册mapper接口</span>
                configuration.addMapper(boundType);
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-3">注解方式解析</h4>
<p>MyBatis中提供了@Mapper注解，但是没有任何地方检查或处理该注解。@Mapper是为Spring Boot等框架提供的标记注解：</p>
<ul>
<li>Spring Boot的@MapperScan会扫描@Mapper注解</li>
<li>MyBatis-Spring-Boot-Starter会处理@Mapper注解</li>
</ul>
<p>MyBatis本身只提供了Configuration.addMapper()等API供外部框架调用。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed931f8786dd4dd8ab03c35cfab9ca93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=ebwjLb3Op%2Be8UcHt%2FdZlztfFZVk%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">1.2 注册Mapper</h3>
<p>注册Mapper，其实就是将Mapper的Class对象、代理工厂添加到MapperRegistry的knownMappers中。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f8be7b3c419f48c1a9729ed5f20fcaaf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=oJlGuqHlor9quZmKsMpACU%2F0h98%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> {
    <span class="hljs-comment">//...</span>
    knownMappers.put(type, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;T&gt;(type));
}
</code></pre>
<h3 data-id="heading-5">1.3 获取Mapper代理</h3>
<p>获取Mapper时其实创建了一个代理对象，通过代理将静态接口定义与动态SQL执行完美结合。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// MapperRegistry#getMapper</span>
<span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> {
    <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 创建mapper代理对象</span>
        <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">"Error getting mapper instance. Cause: "</span> + e, e);
    }
}
</code></pre>
<p>MapperProxy声明了代理逻辑：调用接口方法触发执行SQL语句。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建代理对象MapperProxy</span>
<span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> {
<span class="hljs-comment">// MapperProxy即代理逻辑</span>
<span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>&lt;T&gt;(sqlSession, mapperInterface, methodCache);
<span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] { mapperInterface }, mapperProxy);
}
</code></pre>
<p>MapperProxy实现了InvocationHandler（JDK动态代理），会拦截Mapper接口方法执行：</p>
<ul>
<li>Object方法 → 直接执行</li>
<li>默认方法 → 反射调用</li>
<li>业务方法 → 创建/获取MapperMethod再执行</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f219a08f83de43339f5801b1207fc0f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=u5ESa4K92A63GuiMdUHZS3Pc%2BiU%3D" alt="" loading="lazy"/></p>
<p>MapperMethod中会根据方法名对应的SQL类型，执行不同的方法，如</p>
<ul>
<li>SELECT → sqlSession.selectList()</li>
<li>INSERT → sqlSession.insert()</li>
<li>UPDATE → sqlSession.update()</li>
<li>DELETE → sqlSession.delete()</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1da034452e3a4c0c894de7ac0752016e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=9brl0tsx601%2FcU6tVW2HnbYCoiQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">二 注册MappedStatement</h2>
<h3 data-id="heading-7">2.1 什么是MappedStatement</h3>
<p>MappedStatement 是 MyBatis 中 SQL 语句的完整描述对象，它封装了一条 SQL 语句的所有配置信息和元数据，是连接 Mapper 接口方法和实际 SQL 执行的桥梁。</p>
<ol>
<li>SQL 语句的元数据容器</li>
</ol>
<ul>
<li>存储 SQL 语句的 ID（通常是 namespace.methodName）</li>
<li>保存 SqlSource（动态 SQL 来源）</li>
<li>记录 SQL 命令类型（INSERT/UPDATE/DELETE/SELECT）</li>
</ul>
<ol start="2">
<li>参数和结果映射配置</li>
</ol>
<ul>
<li>ParameterMap：参数映射配置</li>
<li>ResultMap：结果集映射配置</li>
<li>支持嵌套结果映射</li>
</ul>
<ol start="3">
<li>执行配置信息</li>
</ol>
<ul>
<li>StatementType：语句类型（PREPARED/SIMPLE/CALLABLE）</li>
<li>timeout：超时时间</li>
<li>fetchSize：抓取大小</li>
<li>KeyGenerator：主键生成器</li>
</ul>
<ol start="4">
<li>缓存相关配置</li>
</ol>
<ul>
<li>Cache：关联的缓存对象</li>
<li>useCache：是否使用缓存</li>
<li>flushCacheRequired：是否需要刷新缓存</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/12ec416d7e4a407688d1949dfd36e1fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=7HXga8FjPL11bfSdYRON5lN7Y0w%3D" alt="" loading="lazy"/></p>
<p>其中的关键方法是getBoundSql(Object parameterObject)：根据参数对象生成 BoundSql（包含最终可执行的 SQL 和参数映射）。</p>
<h3 data-id="heading-8">2.2 注册MappedStatement</h3>
<p>MappedStatement 对象在 MyBatis 初始化时创建，存储在 Configuration 的 mappedStatements Map 中，整个应用生命周期内复用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77531218ea374e30889515ef938f0098~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=C6CzqfDP2SkAQnlf6FzBrulpDiw%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 解析Mapper.xml文件时，将SQL语句封装成MappedStatement</span>
buildStatementFromContext(context.evalNodes(<span class="hljs-string">"select|insert|update|delete"</span>));
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32bc72403416431b9eeb70adc08f5516~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=B740cTegkfmuuDT7TA6xV3BkXOw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">三 Mapper方法执行详解</h2>
<p>例如下面语句，在mybatis底层是如何执行的呢？</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// Mapper接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> {
    User <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-number">1L</span>)</span>;
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();
<span class="hljs-comment">// 创建代理对象</span>
<span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);
<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectById(<span class="hljs-number">1L</span>);
</code></pre>
<h3 data-id="heading-10">3.1 MapperMethod代理拦截</h3>
<p>MapperMethod有两个属性：</p>
<ol>
<li>SqlCommand command：从MappedStatement获取接口方法对应的SQL语句元数据
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2afd01674854d81ac7dc093151cc779~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=AoIggoHBu%2BhKBPZJg6vW20WVmdQ%3D" alt="image.png" loading="lazy"/></li>
<li>MethodSignature method：提供接口方法元数据，如返回值类型、参数解析
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b24b24e8824b41bf81c275804e8cea7a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=mE0KUJTQfGJov6POJS0V5n1c7ps%3D" alt="image.png" loading="lazy"/></li>
</ol>
<p>MapperMethod的代理逻辑中，当执行select时，会根据返回类型进一步分发。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba9450b08e974ff79d653a40dd5d528b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=xSB9Dg71ttfix8kyI6NlhROcc34%3D" alt="" loading="lazy"/>
UserMapper#selectById显然对应sqlSession.selectOne。</p>
<h3 data-id="heading-11">3.2 SqlSession流程调度</h3>
<p>DefaultSqlSession#selectOne，底层会执行selectList，然后获取唯一一个元素（查询到多个时会报错）
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11d23fd993f34770b75a4249ec308334~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=qxIPEgG%2BPshv%2BffUDFAu%2BK6%2Fkyk%3D" alt="" loading="lazy"/>
之前已分析过二级、一级缓存逻辑，不再赘述。</p>
<p>来看数据库查询，会调用BaseExecutor子类实现的doQuery()，创建StatementHandler来执行SQL。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d0534a94a824beda57e5617fa10e966~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=RWiveWD6K7rE0xDr8fBESuq5UJ4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-12">3.3 StatementHandler执行SQL</h3>
<p>StatementHandler 是 MyBatis 对 JDBC Statement 操作的统一封装，通过策略模式支持不同类型的Statement，是连接 Executor 和 JDBC 的关键桥梁。</p>
<p>主要职责包括：</p>
<ol>
<li>创建 Statement 对象</li>
<li>设置 SQL 参数（委托给 ParameterHandler）</li>
<li>执行 SQL 语句</li>
<li>处理结果集（委托给 ResultSetHandler）</li>
<li>处理主键生成（委托给 KeyGenerator）</li>
</ol>
<p>该接口有以下实现：</p>
<ol>
<li>BaseStatementHandler：抽象基类</li>
<li>RoutingStatementHandler：策略路由，根据 MappedStatement 的 StatementType 创建具体实现，将方法调用都委派给内部的 delegate 对象。</li>
<li>SimpleStatementHandler：</li>
</ol>
<ul>
<li>对应 JDBC 的 Statement</li>
<li>不支持预编译，每次执行都编译 SQL</li>
<li>不支持参数占位符（?），SQL 直接拼接</li>
</ul>
<ol start="4">
<li>PreparedStatementHandler（最常用）</li>
</ol>
<ul>
<li>对应 JDBC 的 PreparedStatement</li>
<li>支持预编译，SQL 可复用</li>
<li>支持参数占位符（?），防止 SQL 注入</li>
<li>通过 ParameterHandler 设置参数</li>
</ul>
<ol start="5">
<li>CallableStatementHandler对应 JDBC 的 CallableStatement，用于调用存储过程。</li>
</ol>
<p>PreparedStatementHandler创建PreparedStatement后，就可以和数据库交互了。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/345fe2320cb74b659b8ac2bd8363ffd8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5L6g5a6i6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769313705&amp;x-signature=styXbwMNkWCS1r0j4DmLOK64%2BRg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">3.4 ResultSetHandler处理结果集</h3>
<p>ResultSetHandler 是 MyBatis 中负责将 JDBC ResultSet 映射为 Java 对象的核心组件，是对ORM功能的实现。</p>
<p>ResultSetHandler 只有一个实现类DefaultResultSetHandler ，处理普通查询结果集的逻辑如下：</p>
<ul>
<li>ResultSetWrapper：封装 JDBC ResultSet，提供元数据访问和类型处理。</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">handleResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException {
    <span class="hljs-keyword">final</span> List&lt;Object&gt; multipleResults = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-comment">// 1. 获取结果集</span>
    <span class="hljs-type">ResultSetWrapper</span> <span class="hljs-variable">rsw</span> <span class="hljs-operator">=</span> getFirstResultSet(stmt);

    <span class="hljs-comment">// 2. 获取 ResultMap 配置，通常只有一个</span>
    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();

    <span class="hljs-comment">// 3. 遍历处理每个结果集</span>
    <span class="hljs-keyword">while</span> (rsw != <span class="hljs-literal">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) {
        <span class="hljs-type">ResultMap</span> <span class="hljs-variable">resultMap</span> <span class="hljs-operator">=</span> resultMaps.get(resultSetCount);
        <span class="hljs-comment">// 处理结果集</span>
        handleResultSet(rsw, resultMap, multipleResults, <span class="hljs-literal">null</span>);
        rsw = getNextResultSet(stmt);
        resultSetCount++;
    }

    <span class="hljs-keyword">return</span> multipleResults;
}
</code></pre>
<p>在处理结果集时，会使用到ResultHandler即结果处理器，声明如何消费查询到的每条记录。DefaultResultHandler是 ResultHandler的默认实现，用于收集查询结果并存储到 List 集合中 。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 将查询结果收集到 List</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultResultHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResultHandler</span>&lt;Object&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Object&gt; list;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResult</span><span class="hljs-params">(ResultContext&lt;? extends Object&gt; context)</span> {
        list.add(context.getResultObject());
    }

    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">getResultList</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> list;
    }
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[线上故障排查标准化流程：从全局定位到根因分析]]></title>    <link>https://juejin.cn/post/7595858760134639679</link>    <guid>https://juejin.cn/post/7595858760134639679</guid>    <pubDate>2026-01-17T15:19:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595858760134639679" data-draft-id="7595858760134623295" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="线上故障排查标准化流程：从全局定位到根因分析"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-17T15:19:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风的归宿55"/> <meta itemprop="url" content="https://juejin.cn/user/2840793779297303"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            线上故障排查标准化流程：从全局定位到根因分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2840793779297303/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风的归宿55
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T15:19:24.000Z" title="Sat Jan 17 2026 15:19:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">介绍</h4>
<p>试想一下，你是一个后端服务器负责人，在一个夜深人静的夜晚，突然报警短信响起，你起来一看，监控中的报错眼花缭乱，你是否会有点无从入手，你是否会想，要是有一个流程，只要跟着流程就能排查并解决大部分问题就好了。 而这篇文章就是根据笔者实际线上问题处理的经验整理的一个排查问题的一般思路，希望能对你有所启发，可以在异常海啸中抽丝剥茧的找到根因，或者最少能有个整体的方向。</p>
<p>需要注意的是，问题的排查完全依赖于监控，因为这篇文章主要讲解排查问题的方式，因此对于所使用的监控只会简单介绍，需要读者根据需要自行实现。</p>
<h4 data-id="heading-1">一、确定问题服务</h4>
<p>第一步先通过网关的监控，比如nginx的监控，尝试快速定位出问题的服务。这一步的主要目的是通过查看网关监控，能够对系统的整体状况有所了解，这样在后续排查时就能有重点。其中最主要的就是通过网关监控尝试定位问题服务，如果能定位到具体服务，就能一下子缩小排查范围，要是定位不出来也没关系，可以简单的通过网关了解系统的整体状态，然后快速进入下个步骤进行排查。</p>
<h6 data-id="heading-2">网关监控介绍</h6>
<p>笔者的后端服务器是使用nginx作为网关的，通过prometheus的库导出了监控数据到prometheus中，然后界面是使用grafana展示的。有兴趣的读者可以查看笔者之前的文章，讲解了如何搭建这个网关监控：<a href="https://juejin.cn/post/7588080521445294126" target="_blank" title="https://juejin.cn/post/7588080521445294126">openresty监控</a>。下面是一个监控示例图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/18306ac3ac3b4f8b84e2f3562c0d64f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO55qE5b2S5a6_NTU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769267964&amp;x-signature=9y7FDzuEONn7hj4p45t5fsXM%2F0I%3D" alt="2.png" loading="lazy"/></p>
<p>这个监控中包括了常见的一些指标，如qps，延迟，4xx和5xx状态码的错误数。然后又分为上下两部分，上半部分是系统整体的数据，下半部分是以服务为维度进行统计的各个维度的对应指标，如qps，延迟和错误率。 一个比较特殊的指标是upstream连接数，他是nginx中使用的upstream进行反向代理时，每个upstream的连接数。因为每个upstream基本上对应一个服务，所以也可以理解为反向代理中连接上游服务的连接数。 <strong>这里着重声明下，强烈建议在使用nginx时使用upstream管理上游服务，同时为upstream配置连接池，这样在保证反向代理的性能的同时，也确保了监控的稳定性，因为在服务没出问题时，因为连接池的存在，这个监控一般变化不会很大。</strong></p>
<h6 data-id="heading-3">排查方式</h6>
<ol>
<li>查看监控中的upstream活跃连接数，他是nginx反向代理连接上游服务的连接数。如果某个服务出问题了，比如响应慢或者不处理请求，那这个连接数就会飙升，那就能直接定位到出问题的服务了。</li>
<li>查看服务维度的各个数据，确认是否有异常指标。比如要是某些服务的延迟升高，那就能在延迟指标中看到服务的曲线飙升。或者某个服务出问题无法处理请求，则5xx状态码的监控也能发现对应的服务。 这部分的监控也是定位问题服务的一个方式。</li>
</ol>
<h4 data-id="heading-4">二、查看问题监控大屏</h4>
<p>这一步需要先建立一个监控大屏，这里面专门放一些之前出现频率比较高的问题的对应指标，目标是通过把所有出现频率高的异常指标都放到一个监控中，这样可以最快的发现问题。并且可以为每个指标写一个针对的处理问题方式，并固化到运维文档中，这样即使是团队中的一个新同事，也可以通过运维文档和监控大屏很容易的解决一些常见问题。</p>
<p>一个需要注意的点是，这个监控大屏尽量放一些出问题时必须解决的指标，比如机器的cpu使用率，服务的k8s的pod容器实例的cpu使用率，java的最新异常数据等。当这个界面的这些指标出现问题时，可以不用管出问题的原因，直接先着手解决，比如进行机器上服务的迁出来降低机器cpu，服务扩容来降低pod的cpu等。这些都是资源问题，<strong>先解决或者缓解资源问题，然后再进一步进行问题排查，因为当资源不足时容易出现很多其他现象，比如服务的某个方法延迟升高。当时这个延迟升高不一定是代码有问题，可能是cpu不足导致的，如果先排查延迟问题，就容易误入歧途，导致查错方向。</strong></p>
<p>下面是一个监控大屏的示例：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf2213ef28414ba59fa73faf59509060~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO55qE5b2S5a6_NTU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769267964&amp;x-signature=qjhT4D6Ze3mEBboJlsH51Ow5Mhw%3D" alt="3.jpg" loading="lazy"/></p>
<h6 data-id="heading-5">网关监控介绍</h6>
<p>这个监控大屏包括了一些常见的容易出问题的监控，当发现对应指标有问题时，优先根据对应的方式进行处理，来解决或者缓解问题。</p>
<ol>
<li>第一个服务器资源总览表时机器实例的监控信息，一般通过node-exporter导出，提供了一些机器的监控数据，其中重点监控的是机器的cpu信息。</li>
<li>CPU Quota是k8s中pod的cpu相关指标，通过prometheus中k8s相关监控可以通过kube-state-metrics组件导出，其中需要重点关注的是CPU Throttling这一项，这个代表的是pod因为cpu超出配置的limit导致被容器限制cpu的指标，如果超过一定阈值，比如25%，代表pod的cpu不够用了，需要提高pod的cpu limit或者增加服务实例。</li>
<li>JavaExceptionTable和NginxErrorTable，这两个java服务和nginx中最近5分钟的业务报错信息，比如java的error级别打印的异常日志，或者框架抛出的异常等。这两个指标可以告诉我们系统正在发生什么错误，帮助我们快速排查问题。这两个指标的导出方式可以查看笔者之前的文章，java异常：<a href="https://juejin.cn/post/7580287891274186815" target="_blank" title="https://juejin.cn/post/7580287891274186815">监控利器：java异常监控</a>  ，nginx异常：<a href="https://juejin.cn/post/7588080521445294126" target="_blank" title="https://juejin.cn/post/7588080521445294126">openresty监控</a></li>
<li>DeploymentError是k8s中Deployment预期数量和实际数量不匹配的Deployment信息，他代表对应的服务有服务实例在重启，可以从k8s的监控中导出。</li>
<li>慢sql监控，截图中还没加入，这个展示最近5分钟的数据库的慢sql，比如mysql或者mongo的慢sql，这部分数据可以通过对接对应服务商的接口进行导出到prometheus，如果有的话可能是数据库层面有问题，需要进行性能优化或者排查是否缓存穿透了</li>
<li>事件中心监控，截图中还没加，这个展示最近5分钟的事件，包括操作和系统事件，比如数据库是否有重启或者配置变更，是否有创建新索引，是否有服务发布或者配置发布等，这个需要建立事件中心，如果看到最近有数据库重启或者创建索引之类的事件，就可以优先考虑是对应操作导致的问题。</li>
</ol>
<h6 data-id="heading-6">排查方式</h6>
<p>其实上面介绍了一些问题排查方式了，这里统一汇总下</p>
<ol>
<li>查看机器节点的cpu数据，如果某一台机器的cpu很高，那这台机器上的服务实例可能都有问题，需要首先想办法降低机器cpu，比如将一个服务实例迁出这台机器，或者扩容机器</li>
<li>查看pod节点的cpu throttling数据，如果某一个pod的cpu throttling比较高，说明pod的cpu不够用，已经被k8s限制cpu的使用了，服务实例会出问题，此时考虑临时扩容容器的cpu limit</li>
<li>查看java和nginx的异常数据，监控中展示最近几分钟的java和nginx的异常数据，这个可以看出服务现在在报什么错，说不定就能一下定位到问题的原因</li>
<li>查看DeploymentError，如果有服务实际数量一直比期望数量少，可能是服务被打挂了，一直在重启，此时可以考虑扩容服务实例数量</li>
<li>查看慢sql，如果突然有很多慢sql，则代表是数据库层面出了问题，优先从慢sql下手排查问题，确认是代码的sql有问题，还是数据库性能不足等问题。</li>
<li>查看事件中心消息，事件中心会收集最近几分钟的所有人工操作，云服务提供商的事件，比如要是发现有个mysql重启事件，就能一下定位原因。</li>
</ol>
<h4 data-id="heading-7">三、指定服务深入排查</h4>
<p>在前两步中，要是能确定问题服务，那我们就可以针对对应服务进行深入排查，如果有多个服务都有问题，那我们可以找一个核心的服务先深入排查，然后顺藤摸瓜找出问题服务。这里主要使用链路追踪系统，比如<strong>skywalking或者OpenTelemetry</strong>等，下面是一个示例：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9d1bd81766ae4d74856602d0528c373d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO55qE5b2S5a6_NTU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1769267964&amp;x-signature=%2BrrpdYxz5cIcP5O69ehAQiKSzPI%3D" alt="4.jpg" loading="lazy"/></p>
<h6 data-id="heading-8">排查方式</h6>
<ol>
<li>服务的问题可能涉及<strong>应用层和数据库层</strong>两个方面，我们先从数据库层开始看，这部分比较简单，先通过之前介绍的慢sql和事件中心查看，是否有慢sql或者创建索引等容易阻塞整个表的事件，如果有的话就优先解决，如果没有的话就进入应用层的问题排查。</li>
<li>针对服务的所有服务实例，<strong>先解决资源的问题</strong>，查看服务实例所在的服务器是否有cpu高，io高等资源问题，或者服务实例的容器是否有cpu资源瓶颈，如出现cpu throttling高等，先通过扩容或者迁移解决资源上的瓶颈。</li>
<li>如果资源的瓶颈已经解决，但是问题依旧存在，此时需要针对服务本身进行排查。这里一般分为两种情况，<strong>一个是请求太多，服务实例来不及处理，一个是请求处理太慢导致请求堆积，从而处理失败</strong>。 这里需要用到链路追踪监控用于 查看一段时间内的最慢请求。需要注意的是，链路追踪系统需要记录所有低于一定阈值的慢请求，避免数据不全。</li>
<li>如果请求处理时间都很快，没有比较慢的请求，那考虑是请求数超出了服务实例的处理能力，优先考虑增加服务实例进行扩容。这里同时也可以看下java的jvm监控，确认是否有jvm回收时间长的问题，这个也会导致处理能力降低。</li>
<li>如果有很多请求比较慢，可以通过链路追踪的功能查看是哪个步骤执行的比较慢，从而进一步进行排查对应步骤，比如某个下游服务比较慢，或者某段函数执行慢等。</li>
<li>如果是下游服务比较慢，那就继续去查对应服务。 如果是某段函数执行比较慢，就需要通过代码逻辑进行排查，必然时可以通过<strong>arthas协助排查java应用的问题</strong>，包括使用trace命令查看方法调用链耗时，<strong>使用profiler命令导出cpu火焰图进行分析（排查服务实例的cpu使用率高的原因时都使用此方法）</strong>，使用thread进行线程阻塞分析等。</li>
</ol>
<h4 data-id="heading-9">总结</h4>
<p>这里统一整理下流程：</p>
<ol>
<li><strong>全局态势感知</strong>
首先通过网关层监控掌握系统整体运行状态，快速识别异常服务节点，明确问题边界。</li>
<li><strong>关键指标快速止血</strong>
通过监控大屏聚焦核心指标（硬件资源、数据库负载、应用性能等），这些指标具有强代表性：</li>
</ol>
<ul>
<li>任何一项异常都需立即干预，优先解决以快速恢复服务能力</li>
<li>同时作为系统健康度的基准参考，形成常态化监控机制</li>
</ul>
<ol start="3">
<li><strong>模块深度根因分析</strong>
采用分层诊断策略，遵循"资源优先"原则：</li>
</ol>
<ul>
<li><strong>第一优先级：资源瓶颈排查</strong>
确认CPU、内存、IO等资源是否充足，避免因资源不足导致的延时假象（如CPU争用引发方法执行时间被动拉长）</li>
<li><strong>第二优先级：异常事件定位</strong>
通过异常中心快速捕获错误日志、告警事件，明确故障点</li>
<li><strong>最终聚焦：延时分解归因</strong>
结合链路追踪系统，将总延时拆解为服务调用链各阶段耗时，锁定真实性能瓶颈环节</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解MySQL数据库索引]]></title>    <link>https://juejin.cn/post/7595901379015081994</link>    <guid>https://juejin.cn/post/7595901379015081994</guid>    <pubDate>2026-01-17T15:43:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595901379015081994" data-draft-id="7595901379015065610" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解MySQL数据库索引"/> <meta itemprop="keywords" content="MySQL"/> <meta itemprop="datePublished" content="2026-01-17T15:43:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="三水不滴"/> <meta itemprop="url" content="https://juejin.cn/user/283045639753100"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解MySQL数据库索引
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/283045639753100/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    三水不滴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T15:43:36.000Z" title="Sat Jan 17 2026 15:43:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解 MySQL 数据库索引</h2>
<p>本文将详细拆解 MySQL 数据库索引的核心知识点，涵盖<strong>底层数据结构</strong>、<strong>功能分类</strong>、<strong>聚簇与非聚簇索引差异</strong>，以及<strong>索引创建原则和失效场景</strong>，助力夯实数据库性能优化基础。</p>
<h3 data-id="heading-1">一、 按底层数据结构分类</h3>
<p>MySQL 索引的性能和适用场景，由其底层数据结构决定。以下是四种核心索引类型的对比与详解：</p>








































<table><thead><tr><th>索引类型</th><th>适用场景</th><th>支持操作</th><th>优缺点</th><th>存储引擎支持</th></tr></thead><tbody><tr><td>B+树索引</td><td>常规查询（等值、范围、排序）</td><td>等值查询（=）、范围查询（&gt;、&lt;、BETWEEN）、排序（ORDER BY）、LIKE 前缀匹配</td><td>优点：适配绝大多数查询，时间复杂度 O(log N)；缺点：不支持哈希快速定位</td><td>InnoDB、MyISAM、Memory（可配置）</td></tr><tr><td>哈希索引</td><td>高频等值查询</td><td>仅支持等值查询（=）</td><td>优点：等值查询速度极快，时间复杂度 O(1)；缺点：不支持范围查询、排序、模糊匹配</td><td>仅 Memory 存储引擎</td></tr><tr><td>全文索引</td><td>大文本内容检索</td><td>自然语言搜索（MATCH...AGAINST）</td><td>优点：高效分词检索长文本；缺点：不适合小数据量或频繁更新场景</td><td>InnoDB、MyISAM</td></tr><tr><td>空间索引</td><td>GIS 地理信息数据查询</td><td>空间关系查询（包含、相交、距离计算）</td><td>优点：专为空间数据优化；缺点：支持有限，应用场景小众</td><td>MyISAM（InnoDB 8.0+ 部分支持）</td></tr></tbody></table>
<h4 data-id="heading-2">1.1 B+树索引</h4>
<p>B+树索引是 MySQL <strong>默认且应用最广</strong>的索引类型，是 InnoDB 和 MyISAM 引擎的核心索引结构。</p>
<ul>
<li><strong>核心特点</strong>：数据按层级组织成树状结构，叶子节点存储全部索引数据并通过链表相连，既保证等值查询效率，又支持范围遍历和排序。</li>
<li><strong>适用场景</strong>：主键、外键、频繁作为 WHERE 条件、参与排序和表连接的字段。</li>
</ul>
<h4 data-id="heading-3">1.2 哈希索引</h4>
<p>哈希索引基于哈希表实现，仅适用于 Memory 存储引擎。</p>
<ul>
<li><strong>核心特点</strong>：通过哈希函数将索引键映射为哈希值，查询时直接定位数据位置，等值查询速度远超 B+树；但无法应对范围查询、排序等操作，且存在哈希冲突风险。</li>
<li><strong>适用场景</strong>：数据量小、查询以等值匹配为主的临时表或内存表。</li>
</ul>
<h4 data-id="heading-4">1.3 全文索引</h4>
<p>全文索引专为文本检索设计，针对 CHAR、VARCHAR、TEXT 类型字段优化。</p>
<ul>
<li><strong>核心特点</strong>：采用分词技术拆分文本，忽略停用词（如 <code>a</code>、<code>the</code>），支持自然语言模式和布尔模式检索。</li>
<li><strong>适用场景</strong>：新闻网站、博客系统、搜索引擎等需要全文关键词匹配的场景。</li>
</ul>
<h4 data-id="heading-5">1.4 空间索引</h4>
<p>空间索引基于 R-Tree 结构实现，用于处理地理信息数据。</p>
<ul>
<li><strong>核心特点</strong>：优化空间数据的存储与查询，可快速判断点、线、面之间的空间关系。</li>
<li><strong>适用场景</strong>：地图服务、位置轨迹分析等 GIS 相关应用。</li>
</ul>
<h4 data-id="heading-6">1.5 哈希索引 vs B+树索引 核心抉择</h4>








































<table><thead><tr><th>对比维度</th><th>哈希索引</th><th>B+树索引</th></tr></thead><tbody><tr><td>范围查询</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>排序操作</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>模糊查询</td><td>❌ 不支持</td><td>✅ 支持 LIKE 'xx%'</td></tr><tr><td>联合索引适配</td><td>❌ 不支持最左前缀原则</td><td>✅ 完美支持</td></tr><tr><td>存储引擎兼容性</td><td>仅 Memory</td><td>全引擎兼容</td></tr><tr><td>等值查询效率</td><td>O(1)，速度极快</td><td>O(log N)，稳定高效</td></tr></tbody></table>
<p><strong>抉择建议</strong>：绝大多数业务场景优先选择 B+树索引；仅当数据存于 Memory 引擎且查询为纯等值匹配时，考虑哈希索引。</p>
<h3 data-id="heading-7">二、 按功能与用途分类</h3>
<p>从业务功能角度，MySQL 索引可分为以下 6 类，各自承担不同的性能优化职责：</p>
<h4 data-id="heading-8">2.1 主键索引（Primary Key Index）</h4>
<ul>
<li><strong>核心特点</strong>：特殊的唯一索引，<strong>不允许 NULL 值和重复数据</strong>，一张表<strong>仅能有一个主键索引</strong>。</li>
<li><strong>引擎特性</strong>：InnoDB 中，主键索引就是<strong>聚簇索引</strong>，数据行直接存储在索引叶子节点；MyISAM 无聚簇索引概念，主键索引仅为普通唯一索引。</li>
<li><strong>创建方式</strong>：
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (
    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,
    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)
);
</code></pre>
</li>
<li><strong>主键选型建议</strong>：优先使用<strong>自增主键</strong>。自增主键插入时按顺序写入数据页，减少页分裂和碎片；非自增主键（如 UUID）会导致数据随机写入，增加 I/O 开销。</li>
</ul>
<h4 data-id="heading-9">2.2 唯一索引（Unique Index）</h4>
<ul>
<li><strong>核心特点</strong>：保证索引列值唯一，<strong>允许 NULL 值</strong>（NULL 不参与唯一性校验），一张表可创建多个唯一索引。</li>
<li><strong>作用</strong>：防止数据重复，同时加速等值查询。</li>
<li><strong>创建方式</strong>：
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_unique_email <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(email);
</code></pre>
</li>
</ul>
<h4 data-id="heading-10">2.3 普通索引（Normal Index）</h4>
<ul>
<li><strong>核心特点</strong>：最基础的索引类型，<strong>无唯一性和非空约束</strong>，仅用于加速查询。</li>
<li><strong>作用</strong>：提升高频查询字段的检索效率，是业务开发中使用最频繁的索引。</li>
<li><strong>创建方式</strong>：
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> INDEX idx_normal_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(name);
</code></pre>
</li>
</ul>
<h4 data-id="heading-11">2.4 全文索引（Full-Text Index）</h4>
<ul>
<li><strong>核心特点</strong>：专为文本检索设计，与底层数据结构中的全文索引一致，需通过 <code>MATCH...AGAINST</code> 语法查询。</li>
<li><strong>使用示例</strong>：
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建索引</span>
<span class="hljs-keyword">CREATE</span> FULLTEXT INDEX idx_fulltext_content <span class="hljs-keyword">ON</span> article(content);
<span class="hljs-comment">-- 检索包含 "MySQL 优化" 的文章</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> article <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(content) AGAINST (<span class="hljs-string">'MySQL 优化'</span>);
</code></pre>
</li>
</ul>
<h4 data-id="heading-12">2.5 覆盖索引（Covering Index）</h4>
<ul>
<li><strong>核心特点</strong>：查询所需的所有列都包含在索引中，无需回表读取数据行，<strong>避免磁盘 I/O 操作</strong>，大幅提升查询性能。</li>
<li><strong>作用</strong>：将“索引查询 + 数据查询”简化为“索引查询”，是高性能查询的关键优化手段。</li>
<li><strong>示例</strong>：
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建覆盖索引（包含 id、name）</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_covering_id_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(id, name);
<span class="hljs-comment">-- 查询时直接从索引获取数据，无需回表</span>
<span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;
</code></pre>
</li>
</ul>
<h4 data-id="heading-13">2.6 组合索引（Composite Index）</h4>
<ul>
<li><strong>核心特点</strong>：将多个字段组合成一个索引，遵循<strong>最左前缀匹配原则</strong>。</li>
<li><strong>作用</strong>：优化多字段联合查询，相比多个单列索引，减少索引维护成本和存储空间占用。</li>
<li><strong>创建与使用示例</strong>：
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建组合索引 (a, b, c)</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_composite_a_b_c <span class="hljs-keyword">ON</span> test(a, b, c);
<span class="hljs-comment">-- 有效使用：匹配最左前缀</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
<span class="hljs-comment">-- 无效使用：未匹配最左前缀</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> test <span class="hljs-keyword">WHERE</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
</code></pre>
</li>
</ul>
<h3 data-id="heading-14">三、 按存储方式划分：聚簇索引 vs 非聚簇索引</h3>
<p>索引与数据的存储关系，决定了查询的底层执行逻辑，这是 InnoDB 和 MyISAM 引擎的核心差异点。</p>








































<table><thead><tr><th>特性</th><th>聚簇索引（Clustered Index）</th><th>非聚簇索引（Non-Clustered Index）</th></tr></thead><tbody><tr><td>存储关系</td><td>索引与数据行存储在一起，索引即数据</td><td>索引与数据行分离，索引叶子节点存主键/指针</td></tr><tr><td>数量限制</td><td>一张表<strong>仅能有一个</strong></td><td>一张表<strong>可以有多个</strong></td></tr><tr><td>查询性能</td><td>主键查询、范围查询速度极快，无需回表</td><td>需要通过主键/指针回表，性能略低</td></tr><tr><td>空间占用</td><td>较小，无需额外存储索引指针</td><td>较大，每个索引都需独立存储空间</td></tr><tr><td>数据更新影响</td><td>插入/更新可能导致数据页分裂</td><td>不影响数据物理顺序，更新成本低</td></tr><tr><td>存储引擎支持</td><td>InnoDB（主键默认是聚簇索引）</td><td>MyISAM（所有索引均为非聚簇索引）、InnoDB（非主键索引）</td></tr></tbody></table>
<h4 data-id="heading-15">3.1 聚簇索引</h4>
<ul>
<li><strong>核心逻辑</strong>：InnoDB 中，聚簇索引的叶子节点直接存储完整数据行，数据按主键顺序物理排列。</li>
<li><strong>主键缺失处理</strong>：若未显式定义主键，InnoDB 会选择第一个非空唯一索引作为聚簇索引；若没有，则自动生成 6 字节的隐含 <code>ROWID</code> 作为聚簇索引。</li>
</ul>
<h4 data-id="heading-16">3.2 非聚簇索引</h4>
<ul>
<li><strong>核心逻辑</strong>：也叫二级索引/辅助索引，叶子节点不存储数据行，而是存储<strong>聚簇索引的主键值</strong>。</li>
<li><strong>查询流程</strong>：通过非聚簇索引查询时，先找到主键值，再通过主键值查询聚簇索引获取完整数据，这个过程称为<strong>回表</strong>。</li>
</ul>
<h4 data-id="heading-17">3.3 为什么非聚簇索引叶子节点存主键值？</h4>
<p>核心目的是<strong>降低索引维护成本</strong>：当数据行因页分裂等原因发生物理位置移动时，只需更新聚簇索引的存储位置，非聚簇索引无需修改——因为它存储的是逻辑主键值，而非物理地址。</p>
<h3 data-id="heading-18">四、 索引创建黄金原则</h3>
<p>索引并非越多越好，合理的索引设计需兼顾查询性能和维护成本，遵循以下原则：</p>
<ol>
<li><strong>小表不建索引</strong>：数据量小时，全表扫描速度比索引查询更快，建索引反而增加开销。</li>
<li><strong>高频查询字段优先建索引</strong>：将索引用于 WHERE 条件、排序、表连接的核心字段。</li>
<li><strong>高频更新字段慎建索引</strong>：索引会增加数据插入、更新、删除的维护成本，更新频繁的字段（如订单状态）不宜建索引。</li>
<li><strong>区分度低的字段不建索引</strong>：如性别、状态字段，基数太小，索引过滤效果差，全表扫描更高效。</li>
<li><strong>优先组合索引，避免冗余索引</strong>：组合索引可覆盖多字段查询，减少索引数量；避免创建功能重复的索引（如已有 (a,b)，无需再建 (a)）。</li>
<li><strong>字符串字段用前缀索引</strong>：对长字符串字段，可只对前 N 个字符建索引（如 <code>idx_prefix_name ON user(name(10))</code>），减少索引存储空间。</li>
<li><strong>尽量保证索引列非空</strong>：NULL 值会降低索引效率，可通过默认值（如 0、空字符串）替代 NULL。</li>
</ol>
<h3 data-id="heading-19">五、 索引失效十大场景及避坑方案</h3>
<p>索引失效是数据库性能问题的高发区，以下是最常见的失效场景及解决方案：</p>
<ol>
<li>
<p><strong>违反最左前缀原则</strong></p>
<ul>
<li><strong>场景</strong>：组合索引 (a,b,c)，查询条件为 <code>b=2</code> 或 <code>c=3</code>。</li>
<li><strong>方案</strong>：查询条件必须包含组合索引的最左列，如 <code>a=1 AND b=2</code>。</li>
</ul>
</li>
<li>
<p><strong>LIKE 通配符以 % 开头</strong></p>
<ul>
<li><strong>场景</strong>：<code>SELECT * FROM user WHERE name LIKE '%tom'</code>。</li>
<li><strong>方案</strong>：避免左模糊匹配，改为右模糊 <code>LIKE 'tom%'</code>；若需全模糊匹配，考虑全文索引。</li>
</ul>
</li>
<li>
<p><strong>索引列参与计算或函数操作</strong></p>
<ul>
<li><strong>场景</strong>：<code>SELECT * FROM user WHERE id + 1 = 100</code>、<code>WHERE DATE(create_time) = '2026-01-01'</code>。</li>
<li><strong>方案</strong>：将计算逻辑移到等号右侧，如 <code>id = 99</code>；MySQL 8.0+ 可创建函数索引。</li>
</ul>
</li>
<li>
<p><strong>OR 条件两侧字段未全部建索引</strong></p>
<ul>
<li><strong>场景</strong>：<code>SELECT * FROM user WHERE id=1 OR age=18</code>（仅 id 有索引）。</li>
<li><strong>方案</strong>：确保 OR 两侧字段都有索引，或改用 UNION 合并结果。</li>
</ul>
</li>
<li>
<p><strong>字段类型不匹配</strong></p>
<ul>
<li><strong>场景</strong>：索引字段 <code>id</code> 为 VARCHAR 类型，查询时写 <code>WHERE id=123</code>（未加引号）。</li>
<li><strong>方案</strong>：保证查询值与字段类型一致，如 <code>WHERE id='123'</code>。</li>
</ul>
</li>
<li>
<p><strong>使用不支持索引的操作符</strong></p>
<ul>
<li><strong>场景</strong>：<code>!=</code>、<code>&lt;&gt;</code>、<code>NOT IN</code>、<code>NOT EXISTS</code> 等。</li>
<li><strong>方案</strong>：尽量用等值查询替代，如用 <code>IN</code> 替代 <code>NOT IN</code>，或调整查询逻辑。</li>
</ul>
</li>
<li>
<p><strong>IS NULL / IS NOT NULL 滥用</strong></p>
<ul>
<li><strong>场景</strong>：对允许 NULL 的索引列执行 <code>WHERE column IS NULL</code>。</li>
<li><strong>方案</strong>：索引列尽量设为非空；若必须查询 NULL 值，可通过 <code>EXPLAIN</code> 验证索引是否生效。</li>
</ul>
</li>
<li>
<p><strong>表关联字段编码不一致</strong></p>
<ul>
<li><strong>场景</strong>：A 表 <code>name</code> 字段为 utf8，B 表 <code>name</code> 字段为 utf8mb4，关联查询时索引失效。</li>
<li><strong>方案</strong>：保证关联字段的字符集和排序规则一致。</li>
</ul>
</li>
<li>
<p><strong>优化器选择全表扫描</strong></p>
<ul>
<li><strong>场景</strong>：索引列区分度极低，优化器判断全表扫描比索引查询更快。</li>
<li><strong>方案</strong>：通过 <code>FORCE INDEX</code> 强制使用索引，或优化索引字段的区分度。</li>
</ul>
</li>
<li>
<p><strong>索引列参与列对比</strong></p>
<ul>
<li><strong>场景</strong>：<code>SELECT * FROM test WHERE a = b</code>（a、b 均为索引列）。</li>
<li><strong>方案</strong>：避免列与列直接对比，可通过业务逻辑调整查询条件。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-20">六、 总结</h3>
<p>MySQL 索引是性能优化的核心工具，其本质是<strong>用空间换时间</strong>。开发者需根据业务场景，从<strong>数据结构</strong>、<strong>功能用途</strong>、<strong>存储方式</strong>三个维度选择合适的索引类型，同时遵循创建原则、规避失效场景，才能最大化发挥索引的性能优势。</p>
<p>在实际开发中，通过 <code>EXPLAIN</code> 命令分析查询执行计划，验证索引是否有效使用——这是排查索引问题的最佳实践。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 InnoDB 的 MVCC：不是乐观锁，是更优雅的并发控制方案]]></title>    <link>https://juejin.cn/post/7595894884957634611</link>    <guid>https://juejin.cn/post/7595894884957634611</guid>    <pubDate>2026-01-17T15:51:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595894884957634611" data-draft-id="7595800318517952518" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 InnoDB 的 MVCC：不是乐观锁，是更优雅的并发控制方案"/> <meta itemprop="keywords" content="MySQL"/> <meta itemprop="datePublished" content="2026-01-17T15:51:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="三水不滴"/> <meta itemprop="url" content="https://juejin.cn/user/283045639753100"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 InnoDB 的 MVCC：不是乐观锁，是更优雅的并发控制方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/283045639753100/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    三水不滴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T15:51:38.000Z" title="Sat Jan 17 2026 15:51:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解InnoDB的MVCC：不是乐观锁，是更优雅的并发控制方案</h2>
<p>MVCC（多版本并发控制）常被误归为乐观锁的实现，实则二者核心设计思路与实现逻辑截然不同。乐观锁与悲观锁是锁机制的设计思想，而MVCC是InnoDB为实现事务隔离、提升读写并发性能打造的独立并发控制体系，通过版本控制与可见性算法，从根本上减少锁的依赖，实现高效的读写并行。</p>
<p>本文将从锁机制基础出发，深入拆解InnoDB MVCC的核心原理、实现组件与工作流程，厘清其与锁机制的区别。</p>
<h2 data-id="heading-1">一、数据库并发控制基础：锁机制的核心分类</h2>
<p>并发控制是保证多事务并行执行时数据一致性的核心，传统方案依赖锁机制，按操作类型和设计思想可分为两类核心划分，也是理解MVCC的前提。</p>
<h3 data-id="heading-2">1. 按数据库操作类型划分</h3>
<p>锁的施加与操作类型强相关，不同语句对应不同锁类型，保障操作的排他性或共享性：</p>
<p><strong>1.读锁：</strong> 针对DQL查询语句（如SELECT），共享锁，多个事务可同时加读锁，互不阻塞。</p>
<p><strong>2.写锁：</strong> 针对DML操作语句（如INSERT/UPDATE/DELETE），排他锁，同一资源仅能被一个事务加写锁，阻塞其他读写操作。</p>
<p><strong>3.元数据锁：</strong> 针对DDL定义语句（如CREATE/DROP TABLE），锁定表结构，防止结构修改与数据操作并发冲突。</p>
<h3 data-id="heading-3">2. 按设计思想划分：悲观锁 vs 乐观锁</h3>
<p>这是锁机制的两大核心设计思路，核心差异在于是否预设并发冲突，决定了加锁时机与冲突处理方式，也是易与MVCC混淆的关键点。</p>
<blockquote>
<h4 data-id="heading-4">悲观锁</h4>
<ul>
<li>核心假设：预设会发生并发冲突</li>
<li>加锁时机：操作资源前主动加锁</li>
<li>冲突处理：锁定资源后，其他事务直接阻塞</li>
<li>实现方式：行级锁、表级锁、Java synchronized 等</li>
<li>性能开销：加锁/解锁 + 阻塞等待，开销较大</li>
<li>适用场景：并发冲突<strong>频繁</strong>的写多读少场景</li>
</ul>
</blockquote>
<blockquote>
<h4 data-id="heading-5">乐观锁</h4>
<ul>
<li>核心假设：预设不会发生并发冲突</li>
<li>加锁时机：全程不加锁，无锁操作</li>
<li>冲突处理：操作完成后，通过校验判断是否冲突</li>
<li>实现方式：版本号机制，CAS原子操作</li>
<li>性能开销：无锁开销，仅需校验，轻量级</li>
<li>适用场景：并发冲突<strong>较少</strong>的读多写少场景</li>
</ul>
</blockquote>
<p>简单来说，悲观锁是 <strong>“先锁后操作，阻塞式</strong>”，乐观锁是 <strong>“先操作后校验，非阻塞式”</strong> ，但二者均属于锁机制范畴，而MVCC跳出了这一框架，通过多版本数据实现无锁读。</p>
<h2 data-id="heading-6">二、MVCC的核心定位：为何需要独立的并发控制体系？</h2>
<p>传统锁机制存在一个致命问题：<strong>读写互斥</strong>。</p>
<p>即使是乐观锁，写操作仍需通过校验保证原子性，读操作若要获取最新数据，仍可能被写操作阻塞；而悲观锁的读写互斥则更为严格。</p>
<p>在读多写少的实际业务场景中，这种互斥会严重降低并发性能——大量读操作因少量写操作被阻塞，数据库整体吞吐量受限。</p>
<p><strong>MVCC（Multi-Version Concurrency Control，多版本并发控制）</strong> 正是为解决这一问题而生：为每行数据维护多个历史版本，读操作通过读取历史版本实现 <strong>“无锁快照读”</strong> ，写操作仅修改最新版本并记录历史，从根本上实现读写分离，让读操作不阻塞写、写操作不阻塞读。</p>
<p>作为InnoDB存储引擎的核心特性，MVCC主要<strong>服务于事务隔离级别</strong>的实现，是InnoDB支持高并发读写的底层基石，其核心并非锁，而是<strong>版本控制+可见性</strong>判断。</p>
<h2 data-id="heading-7">三、InnoDB MVCC的核心实现组件：三大核心模块协同工作</h2>
<p>InnoDB的MVCC并非单一机制，而是由隐藏字段、Undo Log、Read View三大核心组件协同构成，三者各司其职，分别实现版本标识、历史版本存储、可见性判断，共同支撑多版本数据的管理与读取。</p>
<h3 data-id="heading-8">1. 隐藏系统列：数据版本的“身份标识”</h3>
<p>InnoDB会为表中每一行记录自动添加三个隐藏系统列（RowID为可选），无需用户定义，用于记录数据的版本信息、删除状态与历史版本指针，是MVCC的基础标识。</p>
<blockquote>
<h4 data-id="heading-9">DB_TRX_ID</h4>
<ul>
<li>核心作用：记录行数据最近一次修改（插入/更新）的事务ID</li>
<li>说明：事务ID是InnoDB自增的唯一标识，新事务开启时分配唯一ID</li>
</ul>
</blockquote>
<blockquote>
<h4 data-id="heading-10">DB_ROLL_PTR</h4>
<ul>
<li>核心作用：回滚指针，指向该记录对应的Undo Log</li>
<li>说明：形成Undo Log日志链，通过指针可追溯数据的所有历史版本</li>
</ul>
</blockquote>
<blockquote>
<h4 data-id="heading-11">行删除标记</h4>
<ul>
<li>核心作用：标记行是否被逻辑删除</li>
<li>说明：并非独立字段，存储在记录头信息中，DELETE操作仅修改该标记，不物理删除数据</li>
</ul>
</blockquote>
<blockquote>
<h4 data-id="heading-12">RowID (可选) </h4>
<ul>
<li>核心作用：隐藏自增ID</li>
<li>说明：仅当表未指定主键/唯一非空索引时，InnoDB自动生成，作为行的唯一标识</li>
</ul>
</blockquote>
<h3 data-id="heading-13">2. Undo Log：数据历史版本的“存储仓库”</h3>
<p>Undo Log（回滚日志）是InnoDB实现事务回滚与MVCC的核心日志，记录数据修改前的旧版本，通过DB_ROLL_PTR形成日志链，为快照读提供历史版本数据，同时支撑事务的<strong>原子性</strong>。</p>
<h4 data-id="heading-14">（1）Undo Log的两大核心功能</h4>
<ul>
<li>事务回滚：当事务未提交/被回滚时，通过Undo Log恢复数据到修改前的原始状态，撤销未提交事务对数据库的影响，保证事务原子性。</li>
<li>MVCC快照读：保存数据的所有历史版本，其他事务可通过DB_ROLL_PTR追溯Undo Log，读取符合可见性要求的历史版本，实现无锁读。</li>
</ul>
<h4 data-id="heading-15">（2）Undo Log的关键特性</h4>
<ul>
<li>逻辑日志：记录的是逻辑操作，而非物理数据本身。例如更新一行数据，Undo Log记录“反向更新操作”；删除一行数据，记录“插入操作”，回滚时执行反向操作即可恢复数据。</li>
<li>存储位置：统一存储在InnoDB的回滚段中，由引擎统一管理。</li>
</ul>
<h4 data-id="heading-16">（3）Undo Log的分类与生命周期</h4>
<p>根据操作类型，Undo Log分为两类，生命周期差异显著，直接影响数据库存储与性能：</p>
<ul>
<li>Insert Undo Log：记录INSERT操作的日志，仅用于事务回滚。事务提交后可直接删除，因为其他事务不会访问插入的新行的历史版本。</li>
<li>Update Undo Log：记录UPDATE/DELETE操作的日志，用于事务回滚与MVCC快照读。事务提交后仍需保留，直到系统中没有比该日志更早的Read View（读视图），才会被引擎清理。</li>
</ul>
<p><strong>重要问题：</strong> 长事务会导致Update Undo Log无法及时清理——因为长事务生成的Read View会一直依赖旧版本的Undo Log，最终造成存储空间占用过大、性能下降。</p>
<p><strong>优化建议：</strong> 业务中严格避免长时间未提交的事务，及时释放Read View依赖。</p>
<h3 data-id="heading-17">3. Read View：数据版本的“可见性裁判”</h3>
<p>Read View（读视图）是事务执行快照读时生成的一致性快照，本质是一组元数据集合，用于判断当前事务对哪些数据版本可见，是MVCC实现事务隔离的核心，决定了不同事务能看到的数据版本范围。</p>
<h4 data-id="heading-18">（1）Read View的核心组成</h4>
<p>生成Read View时，会记录当前数据库的事务状态，包含三个关键属性：</p>
<ul>
<li>alive_trx_list：当前系统中活跃的事务ID列表（所有未提交的事务ID）。</li>
<li>up_limit_id：alive_trx_list中的最小事务ID，代表当前最早的活跃事务。</li>
<li>low_limit_id：系统当前已分配的最大事务ID+1，代表下一个即将开启的事务ID。</li>
</ul>
<h4 data-id="heading-19">（2）核心可见性算法</h4>
<p>生成Read View后，InnoDB通过数据行的DB_TRX_ID（最近修改事务ID）与Read View的三个属性对比，判断该数据版本是否对当前事务可见，可重复读隔离级别下的判断逻辑为核心（也是InnoDB默认隔离级别），步骤如下：</p>
<ol>
<li>若 DB_TRX_ID &lt; up_limit_id ：该数据版本在Read View生成前已提交，对当前事务可见。</li>
<li>若 DB_TRX_ID &gt;= low_limit_id ：该数据版本在Read View生成后才被修改，对当前事务不可见。</li>
<li>若 DB_TRX_ID 在 alive_trx_list 中：生成Read View时，该修改事务仍未提交，对当前事务不可见。</li>
<li>若以上均不满足，且DB_ROLL_PTR不为空：通过回滚指针追溯Undo Log中的更早历史版本，重复上述判断，直到找到可见版本或追溯至最原始版本。</li>
</ol>
<p>简单来说，Read View的核心作用是为事务划定一个 <strong>“可见范围”</strong> ，仅让事务看到该范围之内的、已提交的数据版本，保证快照读的一致性。</p>
<h2 data-id="heading-20">四、MVCC的两大核心读操作：快照读 vs 当前读</h2>
<p>InnoDB中，读操作分为快照读和当前读，二者均支持MVCC，但加锁策略、数据版本读取规则截然不同，也是MVCC实现 <strong>“读写并行”</strong> 的关键设计。</p>
<h3 data-id="heading-21">1. 快照读（Snapshot Read）</h3>
<p>普通SELECT语句的默认读方式，也是MVCC的核心应用场景，实现无锁读。</p>
<ul>
<li>核心特性：读取的是数据的快照版本（历史版本），即事务快照生成时的数据状态，而非最新版本。</li>
<li>加锁策略：全程不加锁，不会阻塞其他事务的写操作，也不会被写操作阻塞。</li>
<li>数据来源：通过Undo Log追溯历史版本，结合Read View的可见性算法筛选可见版本。</li>
<li>适用场景：普通查询，无需获取最新数据，追求高并发读性能。</li>
</ul>
<h3 data-id="heading-22">2. 当前读（Current Read）</h3>
<p>加锁查询/写操作的读方式，用于获取数据的最新版本，保证操作的原子性与一致性。</p>
<ul>
<li>核心特性：读取的是数据的最新版本，并对读取的数据加锁，防止其他事务同时修改。</li>
<li>加锁策略：必须加锁，加排他锁（FOR UPDATE）或共享锁（LOCK IN SHARE MODE）。</li>
<li>适用操作：SELECT ... FOR UPDATE、SELECT ... LOCK IN SHARE MODE、UPDATE、DELETE、INSERT（写操作前需先读取最新数据，属于隐式当前读）。</li>
<li>特点：支持MVCC，但需要额外的锁操作保证一致性，读写之间仍会互斥。</li>
</ul>
<h3 data-id="heading-23">快照读与当前读核心对比</h3>
<blockquote>
<h4 data-id="heading-24">快照读</h4>
<ul>
<li>操作示例：普通SELECT</li>
<li>是否加锁：不加锁</li>
<li>读取版本：历史快照版本</li>
<li>数据来源：Undo Log + 可见性算法</li>
<li>并发特性：读不阻塞写，写不阻塞读</li>
<li>MVCC：核心应用，无锁实现</li>
</ul>
</blockquote>
<blockquote>
<h4 data-id="heading-25">当前读</h4>
<ul>
<li>操作示例：SELECT…FOR、UPDATE、DELETE</li>
<li>是否加锁：加排他/共享锁</li>
<li>读取版本：最新数据版本</li>
<li>数据来源：数据库主表（最新数据）</li>
<li>并发特性：读阻塞写，写阻塞读</li>
<li>MVCC：支持，但需结合锁机制</li>
</ul>
</blockquote>
<h2 data-id="heading-26">五、MVCC与事务隔离级别的关联：Read View生成时机是关键</h2>
<p>InnoDB的四大事务隔离级别（读未提交、读已提交、可重复读、串行化），除串行化外，其余均基于MVCC实现，而不同隔离级别下Read View的生成时机，是决定隔离级别特性的核心，也是MVCC实现不同一致性保障的关键。</p>
<h3 data-id="heading-27">1. 读未提交（Read Uncommitted）</h3>
<ul>
<li>核心特性：不使用Read View，直接读取数据的最新版本，即使该版本由未提交事务修改（会发生脏读）。</li>
<li>实现：无需Undo Log支撑，性能最高，但一致性最差，实际业务中几乎不使用。</li>
</ul>
<h3 data-id="heading-28">2. 读已提交（Read Committed）</h3>
<ul>
<li>核心特性：每次快照读都会生成新的Read View，因此同一事务内多次查询，结果可能不同（防止脏读，会发生不可重复读）。</li>
<li>可见性：仅能看到当前查询前已提交的数据版本，未提交的版本始终不可见。</li>
<li>适用场景：对一致性要求一般，追求读性能的场景，也是Oracle的默认隔离级别。</li>
</ul>
<h3 data-id="heading-29">3. 可重复读（Repeatable Read）</h3>
<ul>
<li>核心特性：事务启动时生成一次Read View，整个事务期间复用该快照，所有快照读均基于此Read View（防止脏读、不可重复读，InnoDB通过间隙锁额外防止幻读）。</li>
<li>可见性：仅能看到事务启动前已提交的数据版本，事务期间其他事务提交的修改，始终不可见。</li>
<li>特点：InnoDB默认隔离级别，兼顾一致性与并发性能，是业务中最常用的级别。</li>
</ul>
<h3 data-id="heading-30">4. 串行化（Serializable）</h3>
<ul>
<li>核心特性：不使用Read View，放弃MVCC，通过加锁实现串行化执行，所有读操作均加共享锁，写操作加排他锁，事务按顺序执行。</li>
<li>一致性：最高，防止脏读、不可重复读、幻读，但并发性能最差，仅适用于并发冲突极少的场景。</li>
</ul>
<p>核心结论：MVCC主要支撑读已提交和可重复读两个隔离级别，二者的核心差异仅在于Read View的生成时机——每次查询生成 vs 事务启动时生成一次，这一微小差异，决定了隔离级别的一致性特性。</p>
<h2 data-id="heading-31">六、InnoDB MVCC的完整工作流程</h2>
<p>MVCC的三大核心组件（隐藏字段、Undo Log、Read View）与两大读操作配合，形成一套完整的并发控制流程，涵盖数据修改、快照读、事务提交/回滚全生命周期，以下以可重复读隔离级别为例，拆解完整工作流程。</p>
<h3 data-id="heading-32">阶段1：事务修改数据（INSERT/UPDATE/DELETE）</h3>
<ol>
<li>事务开启，InnoDB为其分配唯一的事务ID（DB_TRX_ID）；</li>
<li>执行修改操作前，先将数据的旧版本写入Undo Log，生成对应的Insert/Update Undo Log；</li>
<li>更新数据行的隐藏字段：将DB_TRX_ID改为当前事务ID，DB_ROLL_PTR指向刚生成的Undo Log，形成日志链；</li>
<li>若为DELETE操作，仅修改行删除标记，不物理删除数据，旧版本写入Update Undo Log。</li>
</ol>
<h3 data-id="heading-33">阶段2：事务执行快照读（普通SELECT）</h3>
<ol>
<li>事务首次执行快照读时，生成Read View，记录当前系统的活跃事务列表、up_limit_id、low_limit_id；</li>
<li>读取数据行的最新版本，获取其DB_TRX_ID；</li>
<li>通过可见性算法判断该版本是否对当前事务可见：若可见，直接返回该版本数据；若不可见，通过DB_ROLL_PTR追溯Undo Log中的历史版本，重复可见性判断，直到找到可见版本；</li>
<li>同一事务内后续的快照读，复用已生成的Read View，保证读取结果一致。</li>
</ol>
<h3 data-id="heading-34">阶段3：事务提交/回滚</h3>
<h4 data-id="heading-35">1. 事务提交：</h4>
<ul>
<li>Insert Undo Log：直接删除，无需保留；</li>
<li>Update Undo Log：保留，用于支撑其他事务的快照读，直到无更早的Read View依赖时被引擎清理；</li>
</ul>
<h4 data-id="heading-36">2. 事务回滚：</h4>
<ul>
<li>通过Undo Log中的历史版本，结合DB_ROLL_PTR追溯，将数据恢复到修改前的状态；</li>
<li>撤销所有修改操作，释放事务相关资源。</li>
</ul>
<h2 data-id="heading-37">七、MVCC与锁机制的核心对比：跳出锁的框架，实现更优并发</h2>
<p>MVCC与悲观锁/乐观锁均为并发控制方案，但二者属于不同的技术体系，核心特性、实现方式、适用场景差异显著，厘清二者区别，才能真正理解MVCC的设计价值。</p>
<blockquote>
<h3 data-id="heading-38">锁机制（悲观/乐观）</h3>
<ul>
<li>核心设计：基于锁的冲突控制；读写互斥/事后校验</li>
<li>加锁开销：悲观锁加锁开销大，乐观锁无加锁开销但需校验</li>
<li>并发性能：读写互斥，易阻塞，并发性能较低</li>
<li>实现基础：数据库锁机制/CAS原子操作/版本号</li>
<li>空间开销：几乎无额外空间开销</li>
<li>适用场景：写多读少/冲突频繁（悲观锁）；读多写少/冲突极少（乐观锁）</li>
</ul>
</blockquote>
<blockquote>
<h3 data-id="heading-39">MVCC</h3>
<ul>
<li>核心设计：基于多版本的可见性控制，读写分离</li>
<li>加锁开销：快照读无加锁开销，当前读需加锁</li>
<li>并发性能：快照读不阻塞写，写不阻塞读，读写并行，并发性能高</li>
<li>实现基础：隐藏字段 + Undo Log + Read View</li>
<li>空间开销：需存储Undo Log历史版本，空间开销较大</li>
<li>适用场景：读多写少的读写混合场景，追求高并发读性能</li>
</ul>
</blockquote>
<h2 data-id="heading-40">八、MVCC的优缺点：理性看待其设计价值</h2>
<p>MVCC是InnoDB为读多写少场景量身打造的最优解，但并非万能，其优点与局限性均源于核心设计——多版本数据存储，需结合业务场景合理使用。</p>
<h3 data-id="heading-41"><strong>优点：打造高性能的读写并行体系</strong></h3>
<ol>
<li>极致提升并发性能：快照读无锁化，从根本上解决了传统锁机制的读写互斥问题，读操作不阻塞写、写操作不阻塞读，大幅提升数据库吞吐量。</li>
<li>减少锁开销：大量读操作通过读取历史版本完成，无需加锁/解锁，降低了锁机制带来的性能损耗。</li>
<li>原生支持事务隔离：通过Read View的生成时机与可见性算法，原生实现读已提交、可重复读两大隔离级别，无需额外的锁策略。</li>
<li>保证数据一致性：通过多版本与可见性判断，让事务看到一致性的快照数据，避免脏读、不可重复读等问题。</li>
</ol>
<h3 data-id="heading-42">局限性：设计带来的固有问题</h3>
<ol>
<li>额外空间开销：需要存储Undo Log的历史版本数据，随着事务的执行，Undo Log会不断膨胀，占用磁盘空间。</li>
<li>长事务性能问题：长事务的Read View会持续依赖旧版本的Undo Log，导致引擎无法及时清理，不仅占用空间，还会增加快照读时的版本追溯开销。</li>
<li>写操作仍需加锁：MVCC仅优化读操作，写操作（INSERT/UPDATE/DELETE）仍需加排他锁，写操作频繁的场景下，MVCC的优势会大幅减弱。</li>
<li>仅适用于InnoDB：MVCC是InnoDB的存储引擎特性，MyISAM等其他存储引擎不支持，通用性有限。</li>
</ol>
<h2 data-id="heading-43">九、MVCC快照读实战示例：直观理解多版本可见性</h2>
<p>通过一个简单的并发事务示例，直观感受MVCC快照读的核心特性——不同事务看到不同的数据版本，写操作不阻塞读操作。</p>
<h3 data-id="heading-44">1. 准备表结构与测试数据</h3>
<blockquote>
<p>-- 创建订单表<br/>
<strong>CREATE TABLE orders (<br/>
id INT AUTO_INCREMENT PRIMARY KEY,<br/>
status VARCHAR(20) NOT NULL<br/>
);</strong><br/>
-- 插入测试数据<br/>
<strong>INSERT INTO orders (status) VALUES ('pending'), ('shipped'), ('delivered');</strong></p>
</blockquote>
<h3 data-id="heading-45">2. 模拟并发事务操作</h3>
<p>开启两个事务A和B，模拟并发的修改与查询操作，隔离级别为InnoDB默认的可重复读。</p>
<blockquote>
<p>-- 事务A：开启事务，执行快照读与修改<br/>
<strong>START TRANSACTION;</strong><br/>
-- 快照读：读取事务启动时的快照版本，此时id=1的status为pending<br/>
<strong>SELECT * FROM orders;</strong><br/>
-- 当前读+修改：修改id=1的status为cancelled，加排他锁，写入Undo Log<br/>
<strong>UPDATE orders SET status = 'cancelled' WHERE id = 1;</strong></p>
<p>-- 事务B：在事务A未提交时，开启事务执行快照读<br/>
<strong>START TRANSACTION;</strong><br/>
-- 快照读：读取的是id=1修改前的历史版本，status仍为pending，不受事务A修改影响<br/>
<strong>SELECT * FROM orders WHERE id = 1;</strong></p>
</blockquote>
<h3 data-id="heading-46">3. 执行结果分析</h3>
<ul>
<li>事务A：在自身未提交时，能看到修改后的版本（cancelled），因为自身的修改对当前事务可见。</li>
<li>事务B：在事务A提交前，始终读取的是修改前的快照版本（pending），不会被事务A的写操作阻塞，实现了“写不阻塞读”。</li>
<li>事务A提交后，事务B的快照读仍为pending（可重复读特性），直到事务B提交并重新开启，才能看到最新版本。</li>
</ul>
<p>这一示例清晰体现了MVCC的核心价值：多版本数据让并发事务实现数据隔离，读写操作并行执行，互不阻塞。</p>
<h2 data-id="heading-47">十、总结：MVCC的核心本质与最佳实践</h2>
<h3 data-id="heading-48">1. 核心本质：不是锁，是多版本的可见性控制</h3>
<p>MVCC的核心并非乐观锁，也非悲观锁，而是为每行数据维护多个历史版本，通过Read View判断版本可见性，让读操作通过无锁的快照读实现高性能，写操作通过加锁+Undo Log记录历史实现原子性。它是InnoDB跳出传统锁机制框架，为读多写少场景打造的独立并发控制体系，是数据库高性能的核心基石。</p>
<h3 data-id="heading-49">2. MVCC核心组件记忆口诀</h3>
<ul>
<li>隐藏字段：给数据打版本标签，记录修改事务与历史指针；</li>
<li>Undo Log：存数据历史版本，支撑回滚与快照读；</li>
<li>Read View：做可见性裁判，为事务划定数据可见范围；</li>
<li>三大组件配合：版本打标→历史存储→可见性判断，实现多版本并发控制。</li>
</ul>
<h3 data-id="heading-50">3. 最佳实践：让MVCC发挥最大价值</h3>
<ol>
<li>使用默认的可重复读隔离级别：兼顾一致性与并发性能，InnoDB通过间隙锁额外防止幻读，满足绝大多数业务需求。</li>
<li>严格避免长事务：及时提交/回滚事务，释放Read View对Undo Log的依赖，让引擎能及时清理旧日志，避免空间膨胀与性能下降。</li>
<li>区分快照读与当前读：普通查询使用快照读追求性能，需要最新数据/原子操作时使用当前读（FOR UPDATE）。</li>
<li>优化写操作：写操作频繁的表，可适当调整索引，减少行锁的粒度，降低写操作之间的阻塞，配合MVCC提升整体性能。</li>
<li>监控Undo Log状态：关注回滚段的使用情况，及时清理无效的Undo Log，避免磁盘空间被过度占用。</li>
</ol>
<p>MVCC是InnoDB存储引擎的<strong>精髓</strong>，也是后端开发必须吃透的数据库<strong>核心技术</strong>——理解MVCC，不仅能让你在高并发业务设计中做出更合理的技术选择，还能帮助你快速定位数据库性能问题。</p>
<p>其核心设计思想值得我们借鉴：面对并发问题，并非只有“锁”这一种解决方案，通过合理的版本控制与可见性判断，从根本上减少冲突点，往往能实现更优的性能。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3的v-model如何实现表单双向绑定？]]></title>    <link>https://juejin.cn/post/7595864836360798260</link>    <guid>https://juejin.cn/post/7595864836360798260</guid>    <pubDate>2026-01-17T11:05:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595864836360798260" data-draft-id="7595896809651830824" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3的v-model如何实现表单双向绑定？"/> <meta itemprop="keywords" content="前端,Vue.js,Trae"/> <meta itemprop="datePublished" content="2026-01-17T11:05:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="kknone"/> <meta itemprop="url" content="https://juejin.cn/user/1366025597879930"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3的v-model如何实现表单双向绑定？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1366025597879930/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    kknone
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T11:05:23.000Z" title="Sat Jan 17 2026 11:05:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、为什么需要表单输入绑定？</h3>
<p>你有没有过这样的经历？做登录页时，想让用户输入的用户名实时显示在页面上；或者做设置页时，修改开关按钮的状态要同步到后台数据。这时候，如果手动监听每个输入框的事件、手动更新数据，代码会变得非常繁琐——比如：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">"updateUsername(event)"</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateUsername</span>(<span class="hljs-params">e</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;
}
</code></pre>
<p>不仅要写一堆事件监听，还要处理不同表单元素的差异（比如复选框的<code>checked</code>属性、下拉框的<code>selected</code>属性）。而Vue3的<strong>表单输入绑定</strong>就是为了解决这个问题——它帮你把“输入→数据→视图”的同步逻辑封装成了一个简单的指令：<code>v-model</code>。</p>
<h3 data-id="heading-1">二、双向绑定：Vue3的“数据-视图”同步魔法</h3>
<p>在讲<code>v-model</code>之前，我们得先搞懂<strong>双向绑定</strong>的核心逻辑。简单来说，双向绑定就是：</p>
<ul>
<li>当用户修改视图（比如输入文字、点击复选框），数据自动更新；</li>
<li>当代码修改数据（比如<code>this.username = 'admin'</code>），视图自动同步。</li>
</ul>
<h4 data-id="heading-2">双向绑定的原理流程图</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
A[用户修改视图 输入/点击] --&gt; B[触发对应事件 input/change]
B --&gt; C[更新数据如username 输入内容]
C --&gt; D[Vue响应式系统检测到数据变化]
D --&gt; E[自动更新视图显示]
</code></pre>
<p>举个例子：当你在输入框里敲“hello”，Vue会做这几件事：</p>
<ol>
<li>监听输入框的<code>input</code>事件，拿到你输入的“hello”；</li>
<li>把<code>username</code>数据更新为“hello”；</li>
<li>响应式系统发现<code>username</code>变了，立刻通知输入框显示“hello”。</li>
</ol>
<h3 data-id="heading-3">三、v-model指令：双向绑定的语法糖</h3>
<p>Vue3为双向绑定提供了<strong>语法糖</strong>——<code>v-model</code>，它把“绑定value+监听事件”的逻辑封装成了一个指令。比如：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span>&gt;</span>
</code></pre>
<p>等价于：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"username"</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">"username = $event.target.value"</span>&gt;</span>
</code></pre>
<p>是不是简洁多了？<code>v-model</code>帮你省掉了手动写事件监听的麻烦，而且适用于所有表单元素。</p>
<h3 data-id="heading-4">四、v-model在不同表单元素中的应用</h3>
<p><code>v-model</code>不是只能用在文本输入框，它支持所有常见的表单元素，我们逐个看：</p>
<h4 data-id="heading-5">1. 文本输入框（input[type="text"]）与多行文本（textarea）</h4>
<ul>
<li>文本输入框：直接绑定字符串类型的响应式数据；</li>
<li>多行文本（textarea）：<strong>不能用插值表达式</strong>（<code>{{ message }}</code>），必须用<code>v-model</code>。</li>
</ul>
<p>示例代码：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> username = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>) <span class="hljs-comment">// 字符串类型</span>
<span class="hljs-keyword">const</span> intro = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)    <span class="hljs-comment">// 多行文本内容</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>个人简介：<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"intro"</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">"3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<h4 data-id="heading-6">2. 复选框（input[type="checkbox"]）</h4>
<p>复选框分两种情况：</p>
<ul>
<li><strong>单个复选框</strong>：绑定布尔值（<code>true/false</code>），表示“是否选中”；</li>
<li><strong>多个复选框</strong>：绑定<strong>数组</strong>，数组元素是选中的<code>value</code>值。</li>
</ul>
<p>示例代码：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> rememberMe = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 单个复选框（布尔值）</span>
<span class="hljs-keyword">const</span> hobbies = <span class="hljs-title function_">ref</span>([])       <span class="hljs-comment">// 多个复选框（数组）</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 单个复选框：记住我 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"rememberMe"</span>&gt;</span> 记住我<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 多个复选框：爱好 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"reading"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span> 阅读<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"sports"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span> 运动<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"coding"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span> 编程<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<h4 data-id="heading-7">3. 单选按钮（input[type="radio"]）</h4>
<p>单选按钮绑定<strong>字符串</strong>，值为选中的<code>value</code>属性。</p>
<p>示例代码：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> gender = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'male'</span>) <span class="hljs-comment">// 默认选中“男”</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"male"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"gender"</span>&gt;</span> 男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"female"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"gender"</span>&gt;</span> 女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<h4 data-id="heading-8">4. 下拉框（select）</h4>
<p>下拉框的<code>v-model</code>绑定选中的<code>value</code>值，<code>option</code>的<code>value</code>属性对应选项值。</p>
<p>示例代码：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> city = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'beijing'</span>) <span class="hljs-comment">// 默认选中“北京”</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>城市：
      <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"city"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"beijing"</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"shanghai"</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guangzhou"</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<h3 data-id="heading-9">五、数据响应式：双向绑定的底层支撑</h3>
<p>你可能会问：“为什么数据变了，视图会自动更新？”这要归功于Vue3的<strong>响应式系统</strong>。</p>
<details>
<summary>往期文章归档</summary>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fa5c224e347f70fd63a2d8eeea20041df%2F" target="_blank" title="https://blog.cmdragon.cn/posts/a5c224e347f70fd63a2d8eeea20041df/" ref="nofollow noopener noreferrer">Vue3中如何通过事件缓存与防抖节流优化高频事件性能？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fad67c4eb6d76cf7707bdfe6a8146c34f%2F" target="_blank" title="https://blog.cmdragon.cn/posts/ad67c4eb6d76cf7707bdfe6a8146c34f/" ref="nofollow noopener noreferrer">Vue3跨组件通信中，全局事件总线与provide/inject该如何正确选择？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F1c1e80d697cca0923f29ec70ebb8ccd1%2F" target="_blank" title="https://blog.cmdragon.cn/posts/1c1e80d697cca0923f29ec70ebb8ccd1/" ref="nofollow noopener noreferrer">Vue3表单事件处理：v-model如何实现数据绑定、验证与提交？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fb990828143d70aa87f9aa52e16692e48%2F" target="_blank" title="https://blog.cmdragon.cn/posts/b990828143d70aa87f9aa52e16692e48/" ref="nofollow noopener noreferrer">Vue应用如何基于DOM事件传播机制与事件修饰符实现高效事件处理？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fb44316e0866e9f2e6aef927dbcf5152b%2F" target="_blank" title="https://blog.cmdragon.cn/posts/b44316e0866e9f2e6aef927dbcf5152b/" ref="nofollow noopener noreferrer">Vue3中如何在调用事件处理函数时同时传递自定义参数和原生DOM事件？参数顺序有哪些注意事项？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F021636c2a06f5e2d3d01977a12ddf559%2F" target="_blank" title="https://blog.cmdragon.cn/posts/021636c2a06f5e2d3d01977a12ddf559/" ref="nofollow noopener noreferrer">从捕获到冒泡：Vue事件修饰符如何重塑事件执行顺序？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fb3cddf7023ab537e623a61bc01dab6bb%2F" target="_blank" title="https://blog.cmdragon.cn/posts/b3cddf7023ab537e623a61bc01dab6bb/" ref="nofollow noopener noreferrer">Vue事件处理：内联还是方法事件处理器，该如何抉择？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fbd4d9607ce1bc34cc3bda0a1a46c40f6%2F" target="_blank" title="https://blog.cmdragon.cn/posts/bd4d9607ce1bc34cc3bda0a1a46c40f6/" ref="nofollow noopener noreferrer">Vue事件绑定中v-on与@语法如何取舍？参数传递与原生事件处理有哪些实战技巧？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fa5f2bacb74476fd7f5e02bb3f1ba6b2b%2F" target="_blank" title="https://blog.cmdragon.cn/posts/a5f2bacb74476fd7f5e02bb3f1ba6b2b/" ref="nofollow noopener noreferrer">Vue 3中列表排序时为何必须复制数组而非直接修改原始数据？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fd3b06b57fb7f126787e6ed22dce1e341%2F" target="_blank" title="https://blog.cmdragon.cn/posts/d3b06b57fb7f126787e6ed22dce1e341/" ref="nofollow noopener noreferrer">Vue虚拟滚动如何将列表DOM数量从万级降至十位数？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F3100cc5a2e16f8dac36f722594e6af32%2F" target="_blank" title="https://blog.cmdragon.cn/posts/3100cc5a2e16f8dac36f722594e6af32/" ref="nofollow noopener noreferrer">Vue3中v-if与v-for直接混用为何会报错？计算属性如何解决优先级冲突？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F455dc2d47c38d12c1cf350e490041e8b%2F" target="_blank" title="https://blog.cmdragon.cn/posts/455dc2d47c38d12c1cf350e490041e8b/" ref="nofollow noopener noreferrer">为何在Vue3递归组件中必须用v-if判断子项存在？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F3f842bbd7ba0f9c91151b983bf784c8b%2F" target="_blank" title="https://blog.cmdragon.cn/posts/3f842bbd7ba0f9c91151b983bf784c8b/" ref="nofollow noopener noreferrer">Vue3列表渲染中，如何用数组方法与计算属性优化v-for的数据处理？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F1eb3ffac668a743843b5ea1738301d40%2F" target="_blank" title="https://blog.cmdragon.cn/posts/1eb3ffac668a743843b5ea1738301d40/" ref="nofollow noopener noreferrer">Vue v-for的key：为什么它能解决列表渲染中的“玄学错误”？选错会有哪些后果？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F138b13c5341f6a1fa9015400433a3611%2F" target="_blank" title="https://blog.cmdragon.cn/posts/138b13c5341f6a1fa9015400433a3611/" ref="nofollow noopener noreferrer">Vue3中v-for与v-if为何不能直接共存于同一元素？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F0242a94dc552b93a1bc335ac4fc33db5%2F" target="_blank" title="https://blog.cmdragon.cn/posts/0242a94dc552b93a1bc335ac4fc33db5/" ref="nofollow noopener noreferrer">Vue3中v-if与v-show的本质区别及动态组件状态保持的关键策略是什么？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F97c66a18ae0e9b57c6a69b8b3a41ddf6%2F" target="_blank" title="https://blog.cmdragon.cn/posts/97c66a18ae0e9b57c6a69b8b3a41ddf6/" ref="nofollow noopener noreferrer">Vue3中v-show如何通过CSS修改display属性控制条件显示？与v-if的应用场景该如何区分？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F8a1ddfac64b25062ac56403e4c1201d2%2F" target="_blank" title="https://blog.cmdragon.cn/posts/8a1ddfac64b25062ac56403e4c1201d2/" ref="nofollow noopener noreferrer">Vue3条件渲染中v-if系列指令如何合理使用与规避错误？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F218c3a59282c3b757447ee08a01937bb%2F" target="_blank" title="https://blog.cmdragon.cn/posts/218c3a59282c3b757447ee08a01937bb/" ref="nofollow noopener noreferrer">Vue3动态样式控制：ref、reactive、watch与computed的应用场景与区别是什么？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F1bab953e41f66ac53de099fa9fe76483%2F" target="_blank" title="https://blog.cmdragon.cn/posts/1bab953e41f66ac53de099fa9fe76483/" ref="nofollow noopener noreferrer">Vue3中动态样式数组的后项覆盖规则如何与计算属性结合实现复杂状态样式管理？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fc85e1fe16a7ae45e965b4e2df4d9d2f4%2F" target="_blank" title="https://blog.cmdragon.cn/posts/c85e1fe16a7ae45e965b4e2df4d9d2f4/" ref="nofollow noopener noreferrer">Vue浅响应式如何解决深层响应式的性能问题？适用场景有哪些？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fbe04b02d2723994632de0d4ca22a3391%2F" target="_blank" title="https://blog.cmdragon.cn/posts/be04b02d2723994632de0d4ca22a3391/" ref="nofollow noopener noreferrer">Vue 3组合式API中ref与reactive的核心响应式差异及使用最佳实践是什么？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fbe04b02d2723994632de0d4ca22a3391%2F" target="_blank" title="https://blog.cmdragon.cn/posts/be04b02d2723994632de0d4ca22a3391/" ref="nofollow noopener noreferrer">Vue 3组合式API中ref与reactive的核心响应式差异及使用最佳实践是什么？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fa0af08dd60a37b9a890a9957f2cbfc9f%2F" target="_blank" title="https://blog.cmdragon.cn/posts/a0af08dd60a37b9a890a9957f2cbfc9f/" ref="nofollow noopener noreferrer">Vue3响应式系统中，对象新增属性、数组改索引、原始值代理的问题如何解决？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fbc287e1e36287afd90750fd907eca85e%2F" target="_blank" title="https://blog.cmdragon.cn/posts/bc287e1e36287afd90750fd907eca85e/" ref="nofollow noopener noreferrer">Vue 3中watch侦听器的正确使用姿势你掌握了吗？深度监听、与watchEffect的差异及常见报错解析 - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F654b9447ef1ba7ec1126a1bc26a4726d%2F" target="_blank" title="https://blog.cmdragon.cn/posts/654b9447ef1ba7ec1126a1bc26a4726d/" ref="nofollow noopener noreferrer">Vue响应式声明的API差异、底层原理与常见陷阱你都搞懂了吗 - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F654b9447ef1ba7ec1126a1bc26a4726d%2F" target="_blank" title="https://blog.cmdragon.cn/posts/654b9447ef1ba7ec1126a1bc26a4726d/" ref="nofollow noopener noreferrer">Vue响应式声明的API差异、底层原理与常见陷阱你都搞懂了吗 - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fc405a8d9950af5b7c63b56c348ac36b6%2F" target="_blank" title="https://blog.cmdragon.cn/posts/c405a8d9950af5b7c63b56c348ac36b6/" ref="nofollow noopener noreferrer">为什么Vue 3需要ref函数？它的响应式原理与正确用法是什么？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fa7e9abb9691a81e4404d9facabe0f7c3%2F" target="_blank" title="https://blog.cmdragon.cn/posts/a7e9abb9691a81e4404d9facabe0f7c3/" ref="nofollow noopener noreferrer">Vue 3中reactive函数如何通过Proxy实现响应式？使用时要避开哪些误区？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fbd995ea45161727597fb85b62566c43d%2F" target="_blank" title="https://blog.cmdragon.cn/posts/bd995ea45161727597fb85b62566c43d/" ref="nofollow noopener noreferrer">Vue3响应式系统的底层原理与实践要点你真的懂吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F53e3f270a80675df662c6857a3332c0f%2F" target="_blank" title="https://blog.cmdragon.cn/posts/53e3f270a80675df662c6857a3332c0f/" ref="nofollow noopener noreferrer">Vue 3模板如何通过编译三阶段实现从声明式语法到高效渲染的跨越 - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fddbce4f2a23aa72c96b1c0473900321e%2F" target="_blank" title="https://blog.cmdragon.cn/posts/ddbce4f2a23aa72c96b1c0473900321e/" ref="nofollow noopener noreferrer">快速入门Vue模板引用：从收DOM“快递”到调子组件方法，你玩明白了吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F23a2d5a334e15575277814c16e45df50%2F" target="_blank" title="https://blog.cmdragon.cn/posts/23a2d5a334e15575277814c16e45df50/" ref="nofollow noopener noreferrer">快速入门Vue模板里的JS表达式有啥不能碰？计算属性为啥比方法更能打？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F6be38de6382e31d282659b689c5b17f0%2F" target="_blank" title="https://blog.cmdragon.cn/posts/6be38de6382e31d282659b689c5b17f0/" ref="nofollow noopener noreferrer">快速入门Vue的v-model表单绑定：语法糖、动态值、修饰符的小技巧你都掌握了吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F60ce517684f4a418f453d66aa805606c%2F" target="_blank" title="https://blog.cmdragon.cn/posts/60ce517684f4a418f453d66aa805606c/" ref="nofollow noopener noreferrer">快速入门Vue3事件处理的挑战题：v-on、修饰符、自定义事件你能通关吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fe4ae7d5e4a9205bb11b2baccb230c637%2F" target="_blank" title="https://blog.cmdragon.cn/posts/e4ae7d5e4a9205bb11b2baccb230c637/" ref="nofollow noopener noreferrer">快速入门Vue3的v-指令：数据和DOM的“翻译官”到底有多少本事？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F999ce4fb32259ff4fbf4bf7bcb851654%2F" target="_blank" title="https://blog.cmdragon.cn/posts/999ce4fb32259ff4fbf4bf7bcb851654/" ref="nofollow noopener noreferrer">快速入门Vue3，插值、动态绑定和避坑技巧你都搞懂了吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fa6997d81b49cd232b87e1cf603888ad1%2F" target="_blank" title="https://blog.cmdragon.cn/posts/a6997d81b49cd232b87e1cf603888ad1/" ref="nofollow noopener noreferrer">想让PostgreSQL快到飞起？先找健康密码还是先换引擎？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F1fee7afbb9abd4540b8aa9c141d6845d%2F" target="_blank" title="https://blog.cmdragon.cn/posts/1fee7afbb9abd4540b8aa9c141d6845d/" ref="nofollow noopener noreferrer">想让PostgreSQL查询快到飞起？分区表、物化视图、并行查询这三招灵不灵？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F79c590fbd87ece535b11a71c9667884f%2F" target="_blank" title="https://blog.cmdragon.cn/posts/79c590fbd87ece535b11a71c9667884f/" ref="nofollow noopener noreferrer">子查询总拖慢查询？把它变成连接就能解决？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F748cdac2536008199abf8a8a2cd0ec85%2F" target="_blank" title="https://blog.cmdragon.cn/posts/748cdac2536008199abf8a8a2cd0ec85/" ref="nofollow noopener noreferrer">PostgreSQL全表扫描慢到崩溃？建索引+改查询+更统计信息三招能破？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F32ca943703226d317d4276a8fb53b0dd%2F" target="_blank" title="https://blog.cmdragon.cn/posts/32ca943703226d317d4276a8fb53b0dd/" ref="nofollow noopener noreferrer">复杂查询总拖后腿？PostgreSQL多列索引+覆盖索引的神仙技巧你get没？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fca93f1d53aa910e7ba5ffd8df611c12b%2F" target="_blank" title="https://blog.cmdragon.cn/posts/ca93f1d53aa910e7ba5ffd8df611c12b/" ref="nofollow noopener noreferrer">只给表子集建索引？用函数结果建索引？PostgreSQL这俩操作凭啥能省空间又加速？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Ff507856ebfddd592448813c510a53669%2F" target="_blank" title="https://blog.cmdragon.cn/posts/f507856ebfddd592448813c510a53669/" ref="nofollow noopener noreferrer">B-tree索引像字典查词一样工作？那哪些数据库查询它能加速，哪些不能？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fb2213bfcb5b88a862f2138404c03d596%2F" target="_blank" title="https://blog.cmdragon.cn/posts/b2213bfcb5b88a862f2138404c03d596/" ref="nofollow noopener noreferrer">想抓PostgreSQL里的慢SQL？pg_stat_statements基础黑匣子和pg_stat_monitor时间窗，谁能帮你更准揪出性能小偷？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F26614eb7da6c476dde41d367ad888d2f%2F" target="_blank" title="https://blog.cmdragon.cn/posts/26614eb7da6c476dde41d367ad888d2f/" ref="nofollow noopener noreferrer">PostgreSQL的“时光机”MVCC和锁机制是怎么搞定高并发的？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F69f99bc6972a860d559c74aad7280da4%2F" target="_blank" title="https://blog.cmdragon.cn/posts/69f99bc6972a860d559c74aad7280da4/" ref="nofollow noopener noreferrer">PostgreSQL性能暴涨的关键？内存IO并发参数居然要这么设置？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F7b7053f392147a8b3b1a16bebeb08d0a%2F" target="_blank" title="https://blog.cmdragon.cn/posts/7b7053f392147a8b3b1a16bebeb08d0a/" ref="nofollow noopener noreferrer">大表查询慢到翻遍整个书架？PostgreSQL分区表教你怎么“分类”才高效</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fc856e3cb073822349f3bf2d29995dcfc%2F" target="_blank" title="https://blog.cmdragon.cn/posts/c856e3cb073822349f3bf2d29995dcfc/" ref="nofollow noopener noreferrer">PostgreSQL 查询慢？是不是忘了优化 GROUP BY、ORDER BY 和窗口函数？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fc096347d18e67b7431faacd2c4757093%2F" target="_blank" title="https://blog.cmdragon.cn/posts/c096347d18e67b7431faacd2c4757093/" ref="nofollow noopener noreferrer">PostgreSQL里的子查询和CTE居然在性能上“掐架”？到底该站哪边？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F2eca89463454fd4250d7b66243b9fe5a%2F" target="_blank" title="https://blog.cmdragon.cn/posts/2eca89463454fd4250d7b66243b9fe5a/" ref="nofollow noopener noreferrer">PostgreSQL选Join策略有啥小九九？Nested Loop/Merge/Hash谁是它的菜？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F068ecb772a87d7df20a8c9fb4b233f8e%2F" target="_blank" title="https://blog.cmdragon.cn/posts/068ecb772a87d7df20a8c9fb4b233f8e/" ref="nofollow noopener noreferrer">PostgreSQL新手SQL总翻车？这7个性能陷阱你踩过没？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fd498f63cd0a2d5a77e445c688a8b88db%2F" target="_blank" title="https://blog.cmdragon.cn/posts/d498f63cd0a2d5a77e445c688a8b88db/" ref="nofollow noopener noreferrer">PostgreSQL索引选B-Tree还是GiST？“瑞士军刀”和“多面手”的差别你居然还不知道？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F9101b75bdec6faea9b35d54f14e37f36%2F" target="_blank" title="https://blog.cmdragon.cn/posts/9101b75bdec6faea9b35d54f14e37f36/" ref="nofollow noopener noreferrer">想知道数据库怎么给查询“算成本选路线”？EXPLAIN能帮你看明白？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fd527f8ebb6e3dae2c7dfe4c8d8979444%2F" target="_blank" title="https://blog.cmdragon.cn/posts/d527f8ebb6e3dae2c7dfe4c8d8979444/" ref="nofollow noopener noreferrer">PostgreSQL处理SQL居然像做蛋糕？解析到执行的4步里藏着多少查询优化的小心机？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F6bfdae84f313cf7ad0bb7045c4392347%2F" target="_blank" title="https://blog.cmdragon.cn/posts/6bfdae84f313cf7ad0bb7045c4392347/" ref="nofollow noopener noreferrer">PostgreSQL备份不是复制文件？物理vs逻辑咋选？误删还能精准恢复到1分钟前？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fde3672803de34dbad244d0a8d48b0eb5%2F" target="_blank" title="https://blog.cmdragon.cn/posts/de3672803de34dbad244d0a8d48b0eb5/" ref="nofollow noopener noreferrer">转账不翻车、并发不干扰，PostgreSQL的ACID特性到底有啥魔法？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fe463e8a2668abdf00a228c9b79324ded%2F" target="_blank" title="https://blog.cmdragon.cn/posts/e463e8a2668abdf00a228c9b79324ded/" ref="nofollow noopener noreferrer">银行转账不白扣钱、电商下单不超卖，PostgreSQL事务的诀窍是啥？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F5c967e595058c4a1fc4474a68e64031d%2F" target="_blank" title="https://blog.cmdragon.cn/posts/5c967e595058c4a1fc4474a68e64031d/" ref="nofollow noopener noreferrer">PostgreSQL里的PL/pgSQL到底是啥？能让SQL从“说目标”变“讲步骤”？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F325047855e3e23b5ef82f7d2db134fbd%2F" target="_blank" title="https://blog.cmdragon.cn/posts/325047855e3e23b5ef82f7d2db134fbd/" ref="nofollow noopener noreferrer">PostgreSQL视图不存数据？那它怎么简化查询还能递归生成序列和控制权限？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fd2dba50bb6e4df7b27e735245a06a2a2%2F" target="_blank" title="https://blog.cmdragon.cn/posts/d2dba50bb6e4df7b27e735245a06a2a2/" ref="nofollow noopener noreferrer">PostgreSQL索引这么玩，才能让你的查询真的“飞”起来？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F849ae5bab0f8c66e94c2f6ad1bb798e3%2F" target="_blank" title="https://blog.cmdragon.cn/posts/849ae5bab0f8c66e94c2f6ad1bb798e3/" ref="nofollow noopener noreferrer">PostgreSQL的表关系和约束，咋帮你搞定用户订单不混乱、学生选课不重复？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fef4800975ffa84f1ca51976a70a1585b%2F" target="_blank" title="https://blog.cmdragon.cn/posts/ef4800975ffa84f1ca51976a70a1585b/" ref="nofollow noopener noreferrer">PostgreSQL查询的筛子、排序、聚合、分组？你会用它们搞定数据吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fbf54711525c507c5eacfa7b0151c39d2%2F" target="_blank" title="https://blog.cmdragon.cn/posts/bf54711525c507c5eacfa7b0151c39d2/" ref="nofollow noopener noreferrer">PostgreSQL数据类型怎么选才高效不踩坑？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F887809b3e0375f5956873cd442f516d8%2F" target="_blank" title="https://blog.cmdragon.cn/posts/887809b3e0375f5956873cd442f516d8/" ref="nofollow noopener noreferrer">想解锁PostgreSQL查询从基础到进阶的核心知识点？你都get了吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F934be1203725e8be9d6f6e9104e5abcc%2F" target="_blank" title="https://blog.cmdragon.cn/posts/934be1203725e8be9d6f6e9104e5abcc/" ref="nofollow noopener noreferrer">PostgreSQL DELETE居然有这些操作？返回数据、连表删你试过没？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F0f0622e9b7402b599e618150d0596ffe%2F" target="_blank" title="https://blog.cmdragon.cn/posts/0f0622e9b7402b599e618150d0596ffe/" ref="nofollow noopener noreferrer">PostgreSQL UPDATE语句怎么玩？从改邮箱到批量更新的避坑技巧你都会吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F0e3bf7efc030b024ea67ee855a00f2de%2F" target="_blank" title="https://blog.cmdragon.cn/posts/0e3bf7efc030b024ea67ee855a00f2de/" ref="nofollow noopener noreferrer">PostgreSQL插入数据还在逐条敲？批量、冲突处理、返回自增ID的技巧你会吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fb6cd3c86da6aac26ed829e472d34078e%2F" target="_blank" title="https://blog.cmdragon.cn/posts/b6cd3c86da6aac26ed829e472d34078e/" ref="nofollow noopener noreferrer">PostgreSQL的“仓库-房间-货架”游戏，你能建出电商数据库和表吗？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fba1f545a3410144552fbdbfcf31b5265%2F" target="_blank" title="https://blog.cmdragon.cn/posts/ba1f545a3410144552fbdbfcf31b5265/" ref="nofollow noopener noreferrer">PostgreSQL 17安装总翻车？Windows/macOS/Linux避坑指南帮你搞定？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fb5474d1480509c5072085abc80b3dd9f%2F" target="_blank" title="https://blog.cmdragon.cn/posts/b5474d1480509c5072085abc80b3dd9f/" ref="nofollow noopener noreferrer">能当关系型数据库还能玩对象特性，能拆复杂查询还能自动管库存，PostgreSQL凭什么这么香？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Fcc098d8836e787baa8a4d92e4d56d5c5%2F" target="_blank" title="https://blog.cmdragon.cn/posts/cc098d8836e787baa8a4d92e4d56d5c5/" ref="nofollow noopener noreferrer">给接口加新字段又不搞崩老客户端？FastAPI的多版本API靠哪三招实现？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F46d05151c5bd31cf37a7bcf0b8f5b0b8%2F" target="_blank" title="https://blog.cmdragon.cn/posts/46d05151c5bd31cf37a7bcf0b8f5b0b8/" ref="nofollow noopener noreferrer">流量突增要搞崩FastAPI？熔断测试是怎么防系统雪崩的？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F65ce343cc5df9faf3a8e2eeaab42ae45%2F" target="_blank" title="https://blog.cmdragon.cn/posts/65ce343cc5df9faf3a8e2eeaab42ae45/" ref="nofollow noopener noreferrer">FastAPI秒杀库存总变负数？Redis分布式锁能帮你守住底线吗 - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2Feed6cd8985d9be0a4b092a7da38b3e0c%2F" target="_blank" title="https://blog.cmdragon.cn/posts/eed6cd8985d9be0a4b092a7da38b3e0c/" ref="nofollow noopener noreferrer">FastAPI的CI流水线怎么自动测端点，还能让Allure报告美到犯规？ - cmdragon's Blog</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.cmdragon.cn%2Fposts%2F6157d87338ce894d18c013c3c4777abb%2F" target="_blank" title="https://blog.cmdragon.cn/posts/6157d87338ce894d18c013c3c4777abb/" ref="nofollow noopener noreferrer">如何用GitHub Actions为FastAPI项目打造自动化测试流水线？ - cmdragon's Blog</a></li>
</ul>
</details>
<details>
<summary>免费好用的热门在线工具</summary>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ffile-converter" target="_blank" title="https://tools.cmdragon.cn/zh/apps/file-converter" ref="nofollow noopener noreferrer">文件格式转换器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fm3u8-player" target="_blank" title="https://tools.cmdragon.cn/zh/apps/m3u8-player" ref="nofollow noopener noreferrer">M3U8在线播放器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fquick-image-design" target="_blank" title="https://tools.cmdragon.cn/zh/apps/quick-image-design" ref="nofollow noopener noreferrer">快图设计 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ftext-to-image-advanced" target="_blank" title="https://tools.cmdragon.cn/zh/apps/text-to-image-advanced" ref="nofollow noopener noreferrer">高级文字转图片转换器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fraid-calculator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/raid-calculator" ref="nofollow noopener noreferrer">RAID 计算器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fphotoshop-online" target="_blank" title="https://tools.cmdragon.cn/zh/apps/photoshop-online" ref="nofollow noopener noreferrer">在线PS - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fmermaid-live-editor" target="_blank" title="https://tools.cmdragon.cn/zh/apps/mermaid-live-editor" ref="nofollow noopener noreferrer">Mermaid 在线编辑器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fmath-solver-calculator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/math-solver-calculator" ref="nofollow noopener noreferrer">数学求解计算器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fsmart-teleprompter" target="_blank" title="https://tools.cmdragon.cn/zh/apps/smart-teleprompter" ref="nofollow noopener noreferrer">智能提词器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fmagic-resume" target="_blank" title="https://tools.cmdragon.cn/zh/apps/magic-resume" ref="nofollow noopener noreferrer">魔法简历 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fimage-puzzle-tool" target="_blank" title="https://tools.cmdragon.cn/zh/apps/image-puzzle-tool" ref="nofollow noopener noreferrer">Image Puzzle Tool - 图片拼图工具 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fsubtitle-downloader" target="_blank" title="https://tools.cmdragon.cn/zh/apps/subtitle-downloader" ref="nofollow noopener noreferrer">字幕下载工具 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Flyrics-generator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/lyrics-generator" ref="nofollow noopener noreferrer">歌词生成工具 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fcloud-drive-search" target="_blank" title="https://tools.cmdragon.cn/zh/apps/cloud-drive-search" ref="nofollow noopener noreferrer">网盘资源聚合搜索 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fascii-art-generator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/ascii-art-generator" ref="nofollow noopener noreferrer">ASCII字符画生成器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fjwt-tool" target="_blank" title="https://tools.cmdragon.cn/zh/apps/jwt-tool" ref="nofollow noopener noreferrer">JSON Web Tokens 工具 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fbcrypt-tool" target="_blank" title="https://tools.cmdragon.cn/zh/apps/bcrypt-tool" ref="nofollow noopener noreferrer">Bcrypt 密码工具 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fgif-composer" target="_blank" title="https://tools.cmdragon.cn/zh/apps/gif-composer" ref="nofollow noopener noreferrer">GIF 合成器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fgif-decomposer" target="_blank" title="https://tools.cmdragon.cn/zh/apps/gif-decomposer" ref="nofollow noopener noreferrer">GIF 分解器 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ftext-steganography" target="_blank" title="https://tools.cmdragon.cn/zh/apps/text-steganography" ref="nofollow noopener noreferrer">文本隐写术 - 应用商店 | By cmdragon</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh" target="_blank" title="https://tools.cmdragon.cn/zh" ref="nofollow noopener noreferrer">CMDragon 在线工具 - 高级AI工具箱与开发者套件 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%3Fcategory%3Dtrending" target="_blank" title="https://tools.cmdragon.cn/zh/apps?category=trending" ref="nofollow noopener noreferrer">应用商店 - 发现1000+提升效率与开发的AI工具和实用程序 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fchangelog" target="_blank" title="https://tools.cmdragon.cn/zh/changelog" ref="nofollow noopener noreferrer">CMDragon 更新日志 - 最新更新、功能与改进 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fsponsor" target="_blank" title="https://tools.cmdragon.cn/zh/sponsor" ref="nofollow noopener noreferrer">支持我们 - 成为赞助者 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ftext-to-image-ai" target="_blank" title="https://tools.cmdragon.cn/zh/apps/text-to-image-ai" ref="nofollow noopener noreferrer">AI文本生成图像 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ftemp-email" target="_blank" title="https://tools.cmdragon.cn/zh/apps/temp-email" ref="nofollow noopener noreferrer">临时邮箱 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fqrcode-parser" target="_blank" title="https://tools.cmdragon.cn/zh/apps/qrcode-parser" ref="nofollow noopener noreferrer">二维码解析器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ftext-to-mindmap" target="_blank" title="https://tools.cmdragon.cn/zh/apps/text-to-mindmap" ref="nofollow noopener noreferrer">文本转思维导图 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fregex-visualizer" target="_blank" title="https://tools.cmdragon.cn/zh/apps/regex-visualizer" ref="nofollow noopener noreferrer">正则表达式可视化工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fsteganography-tool" target="_blank" title="https://tools.cmdragon.cn/zh/apps/steganography-tool" ref="nofollow noopener noreferrer">文件隐写工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fiptv-explorer" target="_blank" title="https://tools.cmdragon.cn/zh/apps/iptv-explorer" ref="nofollow noopener noreferrer">IPTV 频道探索器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fsnapdrop" target="_blank" title="https://tools.cmdragon.cn/zh/apps/snapdrop" ref="nofollow noopener noreferrer">快传 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Flucky-draw" target="_blank" title="https://tools.cmdragon.cn/zh/apps/lucky-draw" ref="nofollow noopener noreferrer">随机抽奖工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fanime-scene-finder" target="_blank" title="https://tools.cmdragon.cn/zh/apps/anime-scene-finder" ref="nofollow noopener noreferrer">动漫场景查找器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ftime-toolkit" target="_blank" title="https://tools.cmdragon.cn/zh/apps/time-toolkit" ref="nofollow noopener noreferrer">时间工具箱 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fspeed-test" target="_blank" title="https://tools.cmdragon.cn/zh/apps/speed-test" ref="nofollow noopener noreferrer">网速测试 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fbackground-remover" target="_blank" title="https://tools.cmdragon.cn/zh/apps/background-remover" ref="nofollow noopener noreferrer">AI 智能抠图工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fbackground-replacer" target="_blank" title="https://tools.cmdragon.cn/zh/apps/background-replacer" ref="nofollow noopener noreferrer">背景替换工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fartistic-qrcode" target="_blank" title="https://tools.cmdragon.cn/zh/apps/artistic-qrcode" ref="nofollow noopener noreferrer">艺术二维码生成器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fopen-graph-generator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/open-graph-generator" ref="nofollow noopener noreferrer">Open Graph 元标签生成器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fimage-comparison" target="_blank" title="https://tools.cmdragon.cn/zh/apps/image-comparison" ref="nofollow noopener noreferrer">图像对比工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fimage-compressor" target="_blank" title="https://tools.cmdragon.cn/zh/apps/image-compressor" ref="nofollow noopener noreferrer">图片压缩专业版 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fpassword-generator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/password-generator" ref="nofollow noopener noreferrer">密码生成器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fsvg-optimizer" target="_blank" title="https://tools.cmdragon.cn/zh/apps/svg-optimizer" ref="nofollow noopener noreferrer">SVG优化器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fcolor-palette" target="_blank" title="https://tools.cmdragon.cn/zh/apps/color-palette" ref="nofollow noopener noreferrer">调色板生成器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fonline-metronome" target="_blank" title="https://tools.cmdragon.cn/zh/apps/online-metronome" ref="nofollow noopener noreferrer">在线节拍器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fip-geolocation" target="_blank" title="https://tools.cmdragon.cn/zh/apps/ip-geolocation" ref="nofollow noopener noreferrer">IP归属地查询 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fcss-grid-layout" target="_blank" title="https://tools.cmdragon.cn/zh/apps/css-grid-layout" ref="nofollow noopener noreferrer">CSS网格布局生成器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Femail-validator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/email-validator" ref="nofollow noopener noreferrer">邮箱验证工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fcalligraphy-practice" target="_blank" title="https://tools.cmdragon.cn/zh/apps/calligraphy-practice" ref="nofollow noopener noreferrer">书法练习字帖 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ffinance-calculator-suite" target="_blank" title="https://tools.cmdragon.cn/zh/apps/finance-calculator-suite" ref="nofollow noopener noreferrer">金融计算器套件 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fchinese-kinship-calculator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/chinese-kinship-calculator" ref="nofollow noopener noreferrer">中国亲戚关系计算器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fprotobuf-toolkit" target="_blank" title="https://tools.cmdragon.cn/zh/apps/protobuf-toolkit" ref="nofollow noopener noreferrer">Protocol Buffer 工具箱 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fip-geolocation" target="_blank" title="https://tools.cmdragon.cn/zh/apps/ip-geolocation" ref="nofollow noopener noreferrer">IP归属地查询 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fimage-upscaler" target="_blank" title="https://tools.cmdragon.cn/zh/apps/image-upscaler" ref="nofollow noopener noreferrer">图片无损放大 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ftext-compare" target="_blank" title="https://tools.cmdragon.cn/zh/apps/text-compare" ref="nofollow noopener noreferrer">文本比较工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fip-batch-lookup" target="_blank" title="https://tools.cmdragon.cn/zh/apps/ip-batch-lookup" ref="nofollow noopener noreferrer">IP批量查询工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fdomain-finder" target="_blank" title="https://tools.cmdragon.cn/zh/apps/domain-finder" ref="nofollow noopener noreferrer">域名查询工具 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Fdns-toolkit" target="_blank" title="https://tools.cmdragon.cn/zh/apps/dns-toolkit" ref="nofollow noopener noreferrer">DNS工具箱 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fzh%2Fapps%2Ffavicon-generator" target="_blank" title="https://tools.cmdragon.cn/zh/apps/favicon-generator" ref="nofollow noopener noreferrer">网站图标生成器 - 应用商店 | 免费好用的在线工具</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.cmdragon.cn%2Fsitemap_index.xml" target="_blank" title="https://tools.cmdragon.cn/sitemap_index.xml" ref="nofollow noopener noreferrer">XML Sitemap</a></li>
</ul>
</details>
<p>Vue3用<code>ref</code>或<code>reactive</code>创建响应式数据，当数据变化时，Vue会自动追踪依赖（比如模板中用到<code>username</code>的地方），并更新对应的视图。而<code>v-model</code>正是利用了这个系统，让数据和视图双向同步。</p>
<p>比如用<code>ref</code>创建<code>username</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> username = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
</code></pre>
<p><code>ref</code>会把<code>username</code>包装成一个<strong>响应式对象</strong>，当你修改<code>username.value</code>（或通过<code>v-model</code>修改），Vue会立刻知道，并更新视图。</p>
<h3 data-id="heading-10">六、实际案例：打造一个注册表单</h3>
<p>让我们把前面的知识点整合起来，做一个<strong>注册表单</strong>，包含用户名、密码、记住我、性别、爱好、城市，提交时打印表单数据。</p>
<h4 data-id="heading-11">完整代码（带样式）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 用ref创建表单对象，包含所有字段</span>
<span class="hljs-keyword">const</span> form = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">username</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">password</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">rememberMe</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">gender</span>: <span class="hljs-string">'male'</span>,
  <span class="hljs-attr">hobbies</span>: [],
  <span class="hljs-attr">city</span>: <span class="hljs-string">'beijing'</span>
})

<span class="hljs-comment">// 提交处理函数：阻止默认刷新，打印表单数据</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {
  e.<span class="hljs-title function_">preventDefault</span>()
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'表单数据：'</span>, form.<span class="hljs-property">value</span>)
  <span class="hljs-comment">// 这里可以加发送请求到后台的逻辑，比如axios.post('/api/register', form.value)</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"register-form"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>用户注册<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">"handleSubmit"</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 用户名 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"username"</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
          <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
          <span class="hljs-attr">id</span>=<span class="hljs-string">"username"</span> 
          <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.username"</span> 
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入用户名"</span>
          <span class="hljs-attr">required</span>
        &gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!-- 密码 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"password"</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
          <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> 
          <span class="hljs-attr">id</span>=<span class="hljs-string">"password"</span> 
          <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.password"</span> 
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入密码"</span>
          <span class="hljs-attr">required</span>
        &gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!-- 记住我 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.rememberMe"</span>&gt;</span> 记住登录状态<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!-- 性别 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"male"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.gender"</span>&gt;</span> 男
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"female"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.gender"</span>&gt;</span> 女
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!-- 爱好 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>爱好：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"reading"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.hobbies"</span>&gt;</span> 阅读
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"sports"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.hobbies"</span>&gt;</span> 运动
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"coding"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.hobbies"</span>&gt;</span> 编程
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!-- 城市 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-group"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"city"</span>&gt;</span>城市：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"city"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.city"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"beijing"</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"shanghai"</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guangzhou"</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"shenzhen"</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"submit-btn"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.register-form</span> {
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> auto;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
}
<span class="hljs-selector-class">.form-group</span> {
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>;
}
<span class="hljs-selector-tag">label</span> {
  <span class="hljs-attribute">display</span>: block;
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">5px</span>;
}
<span class="hljs-selector-tag">input</span>, select {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
}
<span class="hljs-selector-class">.submit-btn</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#42b983</span>;
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
}
<span class="hljs-selector-class">.submit-btn</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3aa776</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<h4 data-id="heading-12">代码说明</h4>
<ol>
<li><strong>表单数据管理</strong>：用<code>ref</code>创建<code>form</code>对象，把所有表单字段放在一起，方便管理；</li>
<li><strong>提交处理</strong>：用<code>@submit.prevent</code>阻止表单默认的刷新行为，打印表单数据；</li>
<li><strong>响应式同步</strong>：每个字段用<code>v-model</code>绑定到<code>form</code>对象的属性，输入时自动同步。</li>
</ol>
<h3 data-id="heading-13">七、课后Quiz：巩固你的理解</h3>
<p>来做两个小练习，检验一下学习成果～</p>
<h4 data-id="heading-14">1. 问题：v-model的语法糖本质是什么？请写出等价的原生绑定代码。</h4>
<p><strong>答案解析</strong>：<br/>
v-model是<code>value</code>属性绑定 + <code>input</code>事件监听的语法糖。比如<code>&lt;input v-model="message"&gt;</code>等价于：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"message"</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">"message = $event.target.value"</span>&gt;</span>
</code></pre>
<ul>
<li><code>:value="message"</code>：把数据绑定到输入框的value属性；</li>
<li><code>@input</code>：监听输入事件，把输入内容更新到<code>message</code>。</li>
</ul>
<h4 data-id="heading-15">2. 问题：多个复选框如何用v-model实现多选？请写出示例代码。</h4>
<p><strong>答案解析</strong>：<br/>
多个复选框需要绑定到<strong>数组类型</strong>的响应式数据。每个复选框的<code>value</code>对应数组中的元素，选中时加入数组，取消时移除。示例：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> hobbies = <span class="hljs-title function_">ref</span>([]) <span class="hljs-comment">// 数组类型</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"reading"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span> 阅读<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"sports"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span> 运动<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"coding"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span> 编程<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>比如选中“阅读”和“编程”，<code>hobbies.value</code>会变成<code>['reading', 'coding']</code>。</p>
<h3 data-id="heading-16">八、常见报错与解决方案</h3>
<p>学习过程中遇到报错别慌，以下是表单绑定常见的3个错误及解决办法：</p>
<h4 data-id="heading-17">1. 报错：<code>v-model is not allowed on &lt;input type="file"&gt;</code></h4>
<ul>
<li><strong>原因</strong>：文件输入框（<code>type="file"</code>）的<code>value</code>是<strong>只读</strong>的，无法通过<code>v-model</code>修改。</li>
<li><strong>解决办法</strong>：用<code>ref</code>获取DOM元素，监听<code>change</code>事件拿文件：
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> fileInput = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFile</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">value</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>] <span class="hljs-comment">// 获取选中的文件</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件：'</span>, file)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"fileInput"</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">"handleFile"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
</li>
</ul>
<h4 data-id="heading-18">2. 报错：<code>Property "message" was accessed during render but is not defined</code></h4>
<ul>
<li><strong>原因</strong>：模板里用了<code>message</code>，但没在<code>setup</code>中定义响应式数据。</li>
<li><strong>解决办法</strong>：用<code>ref</code>或<code>reactive</code>定义<code>message</code>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>) <span class="hljs-comment">// 必须定义！</span>
</code></pre>
</li>
</ul>
<h4 data-id="heading-19">3. 报错：<code>v-model requires a valid Vue instance</code></h4>
<ul>
<li><strong>原因</strong>：可能在非Vue组件中用了<code>v-model</code>（比如纯HTML文件没挂载Vue），或组件未正确注册。</li>
<li><strong>解决办法</strong>：确保在Vue组件中使用，并正确挂载应用：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>) <span class="hljs-comment">// 挂载到#app元素</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-20">参考链接</h3>
<p>官网表单处理文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fessentials%2Fforms.html" target="_blank" title="https://vuejs.org/guide/essentials/forms.html" ref="nofollow noopener noreferrer">vuejs.org/guide/essen…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CSS Container Queries：实现响应式设计的新思路]]></title>    <link>https://juejin.cn/post/7595896809651879976</link>    <guid>https://juejin.cn/post/7595896809651879976</guid>    <pubDate>2026-01-17T11:10:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595896809651879976" data-draft-id="7595864836360814644" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CSS Container Queries：实现响应式设计的新思路"/> <meta itemprop="keywords" content="CSS"/> <meta itemprop="datePublished" content="2026-01-17T11:10:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AI产品库AIProduchHub"/> <meta itemprop="url" content="https://juejin.cn/user/2420466240993888"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CSS Container Queries：实现响应式设计的新思路
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2420466240993888/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AI产品库AIProduchHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T11:10:47.000Z" title="Sat Jan 17 2026 11:10:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">CSS Container Queries：实现响应式设计的新思路</h2>
<p>作为一名前端开发者，我相信你一定对媒体查询（Media Queries）不陌生。多年来，我们一直依赖 <code>@media</code> 规则来创建响应式设计，根据屏幕尺寸调整样式。但随着组件化开发的普及和设计复杂性的增加，我们逐渐发现了媒体查询的局限性。今天，我想和大家分享一个激动人心的新特性——CSS Container Queries，它正在改变我们思考和实现响应式设计的方式。</p>
<h3 data-id="heading-1">媒体查询的困境</h3>
<p>在深入了解 Container Queries 之前，让我们先回顾一下传统媒体查询的限制。</p>
<p>想象这样一个场景：你正在开发一个卡片组件，这个组件可能会出现在页面的不同位置——有时占据整个宽度，有时只占据侧边栏的一小部分。使用传统的媒体查询，我们只能基于整个视口的尺寸来调整样式：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.card</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">background</span>: white;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
}

<span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;
}

<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) {
  <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5rem</span>;
  }
}
</code></pre>
<p>这种方法的问题在于，即使卡片本身很小（比如在侧边栏中），但如果视口宽度超过了768px，标题仍然会使用较大的字体，这可能导致布局问题。</p>
<h3 data-id="heading-2">Container Queries 的革命性思路</h3>
<p>Container Queries 的出现解决了这个根本问题。它允许我们基于<strong>容器的尺寸</strong>而不是视口的尺寸来应用样式。这意味着组件可以根据自己的实际可用空间来调整外观，真正实现了组件级别的响应式设计。</p>
<h4 data-id="heading-3">基本语法和使用</h4>
<p>要使用 Container Queries，首先需要定义一个容器：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.card-container</span> {
  container-type: inline-size;
  <span class="hljs-comment">/* 或者使用简写 */</span>
  container: card-container / inline-size;
}
</code></pre>
<p>然后就可以使用 <code>@container</code> 规则了：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.card</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">background</span>: white;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
}

<span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5rem</span>;
  }
  
  <span class="hljs-selector-class">.card</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2rem</span>;
  }
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>) {
  <span class="hljs-selector-class">.card</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">align-items</span>: center;
  }
  
  <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.8rem</span>;
  }
}
</code></pre>
<h3 data-id="heading-4">实际应用案例</h3>
<p>让我通过一个完整的例子来展示 Container Queries 的强大之处。假设我们要创建一个产品卡片组件，它需要在不同的容器中表现出不同的布局：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main-content"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product-card"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"product.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"产品图片"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product-info"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>产品标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>产品描述文本...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product-price"</span>&gt;</span>¥199<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>立即购买<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product-card"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 相同的HTML结构 --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
</code></pre>
<p>CSS实现：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 定义容器 */</span>
<span class="hljs-selector-class">.main-content</span>,
<span class="hljs-selector-class">.sidebar</span> {
  container-type: inline-size;
}

<span class="hljs-comment">/* 基础样式 */</span>
<span class="hljs-selector-class">.product-card</span> {
  <span class="hljs-attribute">background</span>: white;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">12px</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);
  <span class="hljs-attribute">overflow</span>: hidden;
}

<span class="hljs-selector-class">.product-card</span> <span class="hljs-selector-tag">img</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">object-fit</span>: cover;
}

<span class="hljs-selector-class">.product-info</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
}

<span class="hljs-selector-class">.product-info</span> <span class="hljs-selector-tag">h3</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.1rem</span>;
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0.5rem</span>;
}

<span class="hljs-selector-class">.product-price</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;
  <span class="hljs-attribute">font-weight</span>: bold;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#e74c3c</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0.5rem</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* 中等尺寸容器 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">320px</span>) {
  <span class="hljs-selector-class">.product-card</span> {
    <span class="hljs-attribute">display</span>: flex;
  }
  
  <span class="hljs-selector-class">.product-card</span> <span class="hljs-selector-tag">img</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">120px</span>;
    <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-selector-class">.product-info</span> <span class="hljs-selector-tag">h3</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;
  }
}

<span class="hljs-comment">/* 大尺寸容器 */</span>
<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">500px</span>) {
  <span class="hljs-selector-class">.product-card</span> <span class="hljs-selector-tag">img</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
  }
  
  <span class="hljs-selector-class">.product-info</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1.5rem</span>;
  }
  
  <span class="hljs-selector-class">.product-info</span> <span class="hljs-selector-tag">h3</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;
  }
  
  <span class="hljs-selector-class">.product-price</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;
  }
}
</code></pre>
<h3 data-id="heading-5">容器类型详解</h3>
<p>Container Queries 支持几种不同的容器类型：</p>
<h4 data-id="heading-6">1. inline-size</h4>
<p>这是最常用的类型，监听容器的内联尺寸（通常是宽度）：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  container-type: inline-size;
}
</code></pre>
<h4 data-id="heading-7">2. size</h4>
<p>监听容器的所有尺寸（宽度和高度）：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  container-type: size;
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-height</span>: <span class="hljs-number">300px</span>) {
  <span class="hljs-comment">/* 样式规则 */</span>
}
</code></pre>
<h4 data-id="heading-8">3. normal</h4>
<p>默认值，不创建容器查询上下文。</p>
<h3 data-id="heading-9">命名容器查询</h3>
<p>为了更好地组织代码，我们可以给容器命名：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.sidebar</span> {
  container: sidebar-container / inline-size;
}

<span class="hljs-selector-class">.main-content</span> {
  container: main-container / inline-size;
}

<span class="hljs-keyword">@container</span> sidebar-container (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">300px</span>) {
  <span class="hljs-selector-class">.product-card</span> {
    <span class="hljs-comment">/* 侧边栏特定样式 */</span>
  }
}

<span class="hljs-keyword">@container</span> main-container (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) {
  <span class="hljs-selector-class">.product-card</span> {
    <span class="hljs-comment">/* 主内容区特定样式 */</span>
  }
}
</code></pre>
<h3 data-id="heading-10">与CSS Grid/Flexbox的完美结合</h3>
<p>Container Queries 与现代布局技术结合使用时威力更大：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.grid-container</span> {
  container-type: inline-size;
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">250px</span>, <span class="hljs-number">1</span>fr));
}

<span class="hljs-selector-class">.grid-item</span> {
  container-type: inline-size;
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">300px</span>) {
  <span class="hljs-selector-class">.grid-item</span> <span class="hljs-selector-class">.content</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: column;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">1rem</span>;
  }
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
  <span class="hljs-selector-class">.grid-item</span> <span class="hljs-selector-class">.content</span> {
    <span class="hljs-attribute">flex-direction</span>: row;
    <span class="hljs-attribute">align-items</span>: center;
  }
}
</code></pre>
<h3 data-id="heading-11">性能考量和最佳实践</h3>
<p>在使用 Container Queries 时，有几个重要的性能和使用原则：</p>
<h4 data-id="heading-12">1. 避免循环依赖</h4>
<p>确保容器的尺寸不依赖于其内容的查询结果：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 避免这样做 */</span>
<span class="hljs-selector-class">.container</span> {
  container-type: inline-size;
  <span class="hljs-attribute">width</span>: fit-content; <span class="hljs-comment">/* 可能导致循环依赖 */</span>
}
</code></pre>
<h4 data-id="heading-13">2. 合理使用容器类型</h4>
<p>只有在真正需要时才设置 <code>container-type: size</code>，因为它的性能开销比 <code>inline-size</code> 更大。</p>
<h4 data-id="heading-14">3. 渐进增强</h4>
<p>为不支持 Container Queries 的浏览器提供回退方案：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 回退样式 */</span>
<span class="hljs-selector-class">.card</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
}

<span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;
}

<span class="hljs-comment">/* 支持 Container Queries 时的增强 */</span>
<span class="hljs-keyword">@supports</span> (<span class="hljs-attribute">container-type</span>: inline-size) {
  <span class="hljs-selector-class">.card-container</span> {
    container-type: inline-size;
  }
  
  <span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) {
    <span class="hljs-selector-class">.card</span> {
      <span class="hljs-attribute">padding</span>: <span class="hljs-number">2rem</span>;
    }
    
    <span class="hljs-selector-class">.card</span> <span class="hljs-selector-tag">h2</span> {
      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5rem</span>;
    }
  }
}
</code></pre>
<h3 data-id="heading-15">浏览器兼容性和Polyfill</h3>
<p>截至2024年，Container Queries 已经在现代浏览器中得到了良好支持：</p>
<ul>
<li>Chrome 105+</li>
<li>Firefox 110+</li>
<li>Safari 16+</li>
</ul>
<p>对于需要支持旧版浏览器的项目，可以考虑使用 polyfill 或采用渐进增强的策略。</p>
<h3 data-id="heading-16">实际项目中的应用场景</h3>
<h4 data-id="heading-17">1. 组件库开发</h4>
<p>在开发可复用组件时，Container Queries 让组件真正做到了自适应：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.button-group</span> {
  container-type: inline-size;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">0.5rem</span>;
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">200px</span>) {
  <span class="hljs-selector-class">.button-group</span> {
    <span class="hljs-attribute">flex-direction</span>: column;
  }
}
</code></pre>
<h4 data-id="heading-18">2. 复杂布局系统</h4>
<p>在复杂的后台管理系统中，不同区域的组件可以根据实际空间灵活调整：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.dashboard-widget</span> {
  container-type: inline-size;
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">300px</span>) {
  <span class="hljs-selector-class">.chart-widget</span> {
    <span class="hljs-comment">/* 显示完整图表 */</span>
  }
}

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">299px</span>) {
  <span class="hljs-selector-class">.chart-widget</span> {
    <span class="hljs-comment">/* 显示简化版本 */</span>
  }
}
</code></pre>
<p>CSS Container Queries 代表了响应式设计思维的重大转变。从关注全局视口到关注局部容器，这种变化让我们能够创建更加灵活、可复用的组件。虽然它还是一个相对较新的特性，但我相信随着浏览器支持的完善和开发者认知的提升，Container Queries 将成为现代前端开发的重要工具。</p>
<p>作为前端开发者，我建议大家开始在新项目中尝试使用 Container Queries，特别是在组件化开发中。它不仅能解决传统媒体查询的局限性，更能让我们的代码更加模块化和可维护。</p>
<p>响应式设计的未来已经到来，你准备好拥抱这个变化了吗？</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【前端入门】如何用JS做侧边栏展开和关闭动画？]]></title>    <link>https://juejin.cn/post/7595842144907100210</link>    <guid>https://juejin.cn/post/7595842144907100210</guid>    <pubDate>2026-01-17T11:17:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595842144907100210" data-draft-id="7595808703074566170" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【前端入门】如何用JS做侧边栏展开和关闭动画？"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-17T11:17:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="vmiao"/> <meta itemprop="url" content="https://juejin.cn/user/2930638589534635"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【前端入门】如何用JS做侧边栏展开和关闭动画？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2930638589534635/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    vmiao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T11:17:55.000Z" title="Sat Jan 17 2026 11:17:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">摘要</h2>
<p>在很多电商的pc端网页，我们往往能看到那个再熟悉不过的侧边栏。当我们鼠标放上去时，它就会丝滑的弹出一个内容的盒子，当你离开，这个盒子又像弹簧一样收缩回去。接下来我们就要用JS做出这个简单的动画效果...</p>
<h2 data-id="heading-1">一、缓动动画原理</h2>
<p>注：以左右移动效果为例</p>
<p>1.首先获得盒子原始的位置 （盒子要有定位，因为是利用盒子的left属性移动）<br/>
2.让盒子在当前位置上移动一个距离<br/>
3.添加定时器setInterval()重复2中的操作<br/>
4.到达指定位置后清除定时器 clearInterval</p>
<h2 data-id="heading-2">二、代码实现</h2>
<p>1.首先准备一个大盒子,包含一个span和一个用来滑动的盒子</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span> = <span class="hljs-string">"slider_bar"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>展开<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span> = <span class="hljs-string">"con"</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>2.为盒子设置样式</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.slider_bar</span>{
    <span class="hljs-attribute">position</span>:absolute;
    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>:<span class="hljs-number">500px</span>;
    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;
}
<span class="hljs-selector-class">.span</span>{
    <span class="hljs-attribute">display</span>:block;
    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">background-color</span>:pink;
}
<span class="hljs-selector-class">.con</span>{
    <span class="hljs-attribute">position</span>:absolute;
    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;
    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">z-index</span>:-<span class="hljs-number">1</span>;
}
</code></pre>
<p>因为css的层叠性，要给.con设置z-index:-1,把滑动盒子放在span下面隐藏起来</p>
<p>3.写一个能够实现左右移动动画函数</p>
<pre><code class="hljs language-ini" lang="ini">function animate(obj,target,callback){
    clearInterval(obj.timer)<span class="hljs-comment">;</span>
    <span class="hljs-attr">obj.timer</span> = setInterval(function(){
        var <span class="hljs-attr">step</span> = (target - obj.<span class="hljs-literal">off</span>setLeft)/<span class="hljs-number">10</span><span class="hljs-comment">;</span>
        <span class="hljs-attr">step</span> = step &gt; <span class="hljs-number">0</span> ? Math.ceil(step) : Math.floor(step)<span class="hljs-comment">; </span>
        if(<span class="hljs-attr">obj.offsetLeft</span> == target){
            clearInterval(obj.timer)<span class="hljs-comment">;</span>
            if(callback){
                callback()<span class="hljs-comment">;</span>
            }
        }
        else{
            <span class="hljs-attr">obj.style.left</span> = obj.<span class="hljs-literal">off</span>setLeft + step + <span class="hljs-string">'px'</span><span class="hljs-comment">;</span>
        }
    },30)
}
</code></pre>
<p>4.绑定显示和隐藏事件</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">var</span> sliderbar = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".slider_bar"</span>);
    <span class="hljs-keyword">var</span> con = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".con"</span>);
    sliderbar.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"mouseenter"</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){
      <span class="hljs-title function_">animate</span>(con,-<span class="hljs-number">200</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){
          sliderbar.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">innerHTML</span> = <span class="hljs-string">'关闭'</span>;
     ) })  
    }
    sliderbar.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"mouseleave"</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){
      <span class="hljs-title function_">animate</span>(con,<span class="hljs-number">0</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){
          sliderbar.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">innerHTML</span> = <span class="hljs-string">'展开'</span>;
     ) })  
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> 
</code></pre>
<h2 data-id="heading-3">三、特别标注</h2>
<p>1.当步长(step)为正数时，要向上取整(Math.ceil());为负数时，要向下取整(Math.floor())。
2.运动速度先快后慢，缓动效果，用公式：（目标位置-现在位置）/10.
3.回调函数做参数，callback就相当于声明的函数体，所以函数调用直接写callback();</p>
<h2 data-id="heading-4">四、完整代码示例</h2>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>缓动动画原理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
      <span class="hljs-selector-class">.slider_bar</span> {
          <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
          <span class="hljs-attribute">top</span>: <span class="hljs-number">500px</span>;
          <span class="hljs-attribute">position</span>: absolute;
          <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
          <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
      }

      <span class="hljs-selector-tag">span</span> {
          <span class="hljs-attribute">display</span>: block;
          <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
          <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
          <span class="hljs-attribute">background-color</span>: pink;
      }

      <span class="hljs-selector-class">.con</span> {
          <span class="hljs-attribute">position</span>: absolute;
          <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;
          <span class="hljs-attribute">top</span>: <span class="hljs-number">0px</span>;
          <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
          <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
          <span class="hljs-attribute">background-color</span>: blueviolet;
          <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;
      }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/practice1/animate.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slider_bar"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>展开<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"con"</span>&gt;</span>问题反馈<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-keyword">var</span> sliderBar = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".slider_bar"</span>);
      <span class="hljs-keyword">var</span> con = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".con"</span>);
      sliderBar.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"mouseenter"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
          <span class="hljs-title function_">animate</span>(con, -<span class="hljs-number">200</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
              sliderBar.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">innerHTML</span> = <span class="hljs-string">'关闭'</span>;
          });
      })
      sliderBar.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"mouseleave"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
          <span class="hljs-title function_">animate</span>(con, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
              sliderBar.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">innerHTML</span> = <span class="hljs-string">'展开'</span>;
          });
      })
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>JS文件</p>
<pre><code class="hljs language-ini" lang="ini">function animate(obj, target, callback) {
    clearInterval(obj.timer)<span class="hljs-comment">;</span>
    <span class="hljs-attr">obj.timer</span> = setInterval(function () {
        var <span class="hljs-attr">step</span> = (target - obj.<span class="hljs-literal">off</span>setLeft) / <span class="hljs-number">10</span><span class="hljs-comment">;</span>
        <span class="hljs-attr">step</span> = step &gt; <span class="hljs-number">0</span> ? Math.ceil(step) : Math.floor(step)<span class="hljs-comment">;</span>
        if (<span class="hljs-attr">obj.offsetLeft</span> == target) {
            clearInterval(obj.timer)<span class="hljs-comment">;</span>
            if (callback) {
                callback()<span class="hljs-comment">;</span>
            }
        }
        else {
            <span class="hljs-attr">obj.style.left</span> = obj.<span class="hljs-literal">off</span>setLeft + step + <span class="hljs-string">'px'</span><span class="hljs-comment">;</span>
        }
    }, 30)
}
</code></pre>
<p>完整代码示例的前面纯手搓，没在编辑器里面写，如果有错误希望掘友们帮我指出我再改正！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Promise基础知识整理，看看还有你不清楚的吗]]></title>    <link>https://juejin.cn/post/7595894884957175859</link>    <guid>https://juejin.cn/post/7595894884957175859</guid>    <pubDate>2026-01-17T13:04:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595894884957175859" data-draft-id="7595858063503294498" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Promise基础知识整理，看看还有你不清楚的吗"/> <meta itemprop="keywords" content="前端,JavaScript,性能优化"/> <meta itemprop="datePublished" content="2026-01-17T13:04:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sophie旭"/> <meta itemprop="url" content="https://juejin.cn/user/2559318799692952"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Promise基础知识整理，看看还有你不清楚的吗
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2559318799692952/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sophie旭
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T13:04:53.000Z" title="Sat Jan 17 2026 13:04:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读34分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>Promise 作为 异步编程的老生常谈，这里不免俗也整理一番，以后关于 Promise基础知识看这篇就好了。整理过后，我想说一句话：<code>回调函数可以说是javascript中，所有异步编程方式的根基</code>,Promise 无非是 以更好维护更优雅的形式让我们使用回调函数，并不算是一个 全新的摆脱回调函数的解法。</p>
<h2 data-id="heading-1">Promise 构造函数</h2>
<h4 data-id="heading-2">完整代码示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 使用Promise构造函数创建一个新的Promise实例（承诺）</span>
<span class="hljs-comment">// 构造函数接收一个「兑现承诺的逻辑函数」，这个函数会被同步执行</span>
<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Promise构造函数的执行函数：同步执行'</span>);
  
  <span class="hljs-comment">// resolve和reject都是函数，用于修改Promise状态</span>
  <span class="hljs-comment">// 2. 调用resolve：将Promise状态改为fulfilled（成功），并传递结果</span>
  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 这里传入固定值100作为异步任务的操作结果</span>
  
  <span class="hljs-comment">// 3. Promise状态一旦确定就无法修改，所以下面的reject不会生效（注释掉更直观）</span>
  <span class="hljs-comment">// reject(new Error('promise rejected')); // 将状态改为rejected（失败），传递错误理由</span>
});

<span class="hljs-comment">// 4. 用then方法指定状态变更后的回调</span>
<span class="hljs-comment">// then接收两个参数：onFulfilled（成功回调）、onRejected（失败回调）</span>
promise.<span class="hljs-title function_">then</span>(
  <span class="hljs-comment">// onFulfilled：Promise状态为fulfilled时执行，接收resolve传递的结果</span>
  <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Promise成功:'</span>, value); <span class="hljs-comment">// 输出 Promise成功: 100</span>
  },
  <span class="hljs-comment">// onRejected：Promise状态为rejected时执行，接收reject传递的错误</span>
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Promise失败:'</span>, error.<span class="hljs-property">message</span>);
  }
);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'同步代码：在Promise创建后执行'</span>);
</code></pre>
<h4 data-id="heading-3">代码输出结果</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Promise</span>构造函数的执行函数：同步执行
同步代码：在<span class="hljs-title class_">Promise</span>创建后执行
<span class="hljs-title class_">Promise</span>成功: <span class="hljs-number">100</span>
</code></pre>
<h4 data-id="heading-4">逐点解读（核心解释）</h4>
<ol>
<li>
<p><strong>构造函数参数（兑现承诺的逻辑）</strong>：</p>
<ul>
<li><code>new Promise((resolve, reject) =&gt; { ... })</code> 中的箭头函数就是「兑现承诺的逻辑」。</li>
<li>这个函数<strong>同步执行</strong>：所以先输出 <code>Promise构造函数的执行函数：同步执行</code>，再执行后续的同步代码。</li>
</ul>
</li>
<li>
<p><strong>resolve 和 reject 参数</strong>：</p>
<ul>
<li><code>二者都是浏览器内置的函数，不是我们定义的。</code></li>
<li><code>resolve(100)</code>：把 Promise 状态改为 <code>fulfilled</code>（成功），并把 <code>100</code> 作为「成功结果」传递给 <code>then</code> 的第一个回调。</li>
<li><code>reject(new Error('promise rejected'))</code>：把状态改为 <code>rejected</code>（失败），并把错误对象作为「失败理由」传递给 <code>then</code> 的第二个回调。</li>
</ul>
</li>
<li>
<p><strong>状态一旦确定就不能修改</strong>：</p>
<ul>
<li>代码中先调用了 <code>resolve(100)</code>，此时 Promise 状态已经固定为成功，即便后续调用 <code>reject</code>（哪怕取消注释），也不会改变状态，<code>then</code> 的失败回调永远不会执行。</li>
</ul>
</li>
<li>
<p><strong>then 方法的回调</strong>：</p>
<ul>
<li><code>then</code> 的第一个参数：只有 Promise 状态为 <code>fulfilled</code> 时才执行，接收 <code>resolve</code> 传递的值。</li>
<li><code>then</code> 的第二个参数：只有 Promise 状态为 <code>rejected</code> 时才执行，接收 <code>reject</code> 传递的错误。</li>
<li>注意：<code>then</code> 的回调是<strong>微任务</strong>，所以会等所有同步代码执行完后才执行（先输出 <code>同步代码：在Promise创建后执行</code>，再输出 <code>Promise成功: 100</code>）。</li>
</ul>
</li>
</ol>
<h4 data-id="heading-5">总结</h4>
<ol>
<li>Promise 构造函数的执行函数是<strong>同步执行</strong>的，里面的 <code>resolve/reject</code> 用于修改 Promise 状态（成功/失败）。</li>
<li>Promise 状态一旦通过 <code>resolve</code> 或 <code>reject</code> 确定，就<strong>永久不可修改</strong>，后续调用另一个函数也无效。</li>
<li><code>then</code> 方法的两个回调分别对应「成功状态」和「失败状态」的处理逻辑，且回调是<strong>微任务</strong>（晚于同步代码执行）。</li>
</ol>
<h2 data-id="heading-6">Promise 链式调用 用起来！</h2>
<h4 data-id="heading-7">错误写法：嵌套then（回调地狱）</h4>
<p>使用Promise「常见误区」，本质和传统回调嵌套没区别，完全浪费了Promise的优势：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误：嵌套使用then，形成回调地狱</span>
<span class="hljs-title function_">ajax</span>(<span class="hljs-string">'urls.json'</span>).<span class="hljs-title function_">then</span>(
  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一步：拿到urls.json结果'</span>, res);
    <span class="hljs-comment">// 误区：在第一个then的回调里嵌套第二个then</span>
    <span class="hljs-title function_">ajax</span>(res.<span class="hljs-property">userUrl</span>).<span class="hljs-title function_">then</span>(
      <span class="hljs-function">(<span class="hljs-params">userRes</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二步：拿到用户数据'</span>, userRes);
        <span class="hljs-comment">// 如果还有第三个请求，会继续嵌套，代码越来越深</span>
      },
      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二步请求失败'</span>, err);
      }
    );
  },
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一步请求失败'</span>, err);
  }
);
</code></pre>
<p>这种写法的问题：</p>
<ul>
<li>代码层级嵌套，越往后越深，可读性差（回调地狱）</li>
<li>错误处理需要在每个嵌套的then里单独写，冗余且麻烦</li>
</ul>
<h4 data-id="heading-8">正确写法：then链式调用（扁平化）</h4>
<p>核心原理：<strong>then 方法会返回一个新的 Promise</strong>，所以可以直接链式调用，而非嵌套。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 正确：链式调用then，扁平化代码</span>
<span class="hljs-title function_">ajax</span>(<span class="hljs-string">'urls.json'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一步：拿到urls.json结果'</span>, res);
    <span class="hljs-comment">// 关键：返回下一个异步任务的Promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">ajax</span>(res.<span class="hljs-property">userUrl</span>); 
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">userRes</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二步：拿到用户数据'</span>, userRes);
    <span class="hljs-comment">// 可以继续链式调用第三个异步任务</span>
    <span class="hljs-comment">// return ajax(第三个地址);</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-comment">// 统一错误处理：任何一步失败都会走到这里</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'请求失败：'</span>, err.<span class="hljs-property">message</span>);
  });
</code></pre>
<h5 data-id="heading-9">执行结果（500ms后）</h5>
<pre><code class="hljs language-css" lang="css">第一步：拿到urls<span class="hljs-selector-class">.json</span>结果 { userUrl: <span class="hljs-string">'/user'</span> }
第二步：拿到用户数据 { name: <span class="hljs-string">'张三'</span>, age: <span class="hljs-number">20</span> }
</code></pre>
<h4 data-id="heading-10">核心逻辑拆解（为什么链式调用能避免回调地狱）</h4>
<ol>
<li><code>ajax('urls.json').then(...)</code> 执行后，返回一个<strong>新的 Promise</strong>（记为 P1）。</li>
<li>第一个 then 的回调里 <code>return ajax(res.userUrl)</code>，这个 ajax 调用会返回另一个 Promise（记为 P2）。</li>
<li>Promise 的规则：如果 then 的回调返回一个 Promise（P2），那么 then 对应的新 Promise（P1）会「继承」P2 的状态——P2 成功，P1 就成功；P2 失败，P1 就失败。</li>
<li>第二个 <code>then(...)</code> 其实是挂载在 P1 上的回调，而非嵌套在第一个 then 内部，所以代码是扁平的。</li>
</ol>
<h4 data-id="heading-11">总结</h4>
<ol>
<li>Promise 避免回调地狱的核心是 <strong>then 的链式调用</strong>，而非嵌套使用 then。</li>
<li>关键规则：<code>then</code> 会返回新 Promise，若 then 回调返回 Promise，则新 Promise 继承该 Promise 的状态。</li>
<li>链式调用+catch 可以实现<strong>扁平化代码结构</strong>和<strong>统一错误处理</strong>，这是 Promise 对比传统回调的核心优势。</li>
</ol>
<h2 data-id="heading-12">Promise 链式调用 的 特殊性</h2>
<h4 data-id="heading-13">先对比两种链式调用的本质区别</h4>
<h5 data-id="heading-14">1. 传统链式调用（返回 this）</h5>
<p>比如 jQuery 的链式调用，核心是方法内部返回 <code>this</code>（自身），所有方法都操作同一个对象：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 传统链式调用：返回this</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObj</span> {
  name = <span class="hljs-string">''</span>;
  <span class="hljs-title function_">setName</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 返回自身（同一个对象）</span>
  }
  <span class="hljs-title function_">logName</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 返回自身</span>
  }
}

<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObj</span>();
obj.<span class="hljs-title function_">setName</span>(<span class="hljs-string">'张三'</span>).<span class="hljs-title function_">logName</span>(); 
<span class="hljs-comment">// 这里 setName 和 logName 操作的是同一个 obj 对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">setName</span>(<span class="hljs-string">'张三'</span>) === obj); <span class="hljs-comment">// true（返回的是同一个对象）</span>
</code></pre>
<h5 data-id="heading-15">2. Promise 的链式调用（返回新对象）</h5>
<p>Promise 的 <code>then</code> 每调用一次，都会生成一个<strong>全新的 Promise</strong>，和原对象毫无关系：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Promise链式调用：返回新对象</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>));
<span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res + <span class="hljs-number">10</span>); <span class="hljs-comment">// p2 是全新的Promise</span>
<span class="hljs-keyword">const</span> p3 = p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res + <span class="hljs-number">10</span>); <span class="hljs-comment">// p3 是全新的Promise</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 === p2); <span class="hljs-comment">// false（不是同一个对象）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 === p3); <span class="hljs-comment">// false（不是同一个对象）</span>

<span class="hljs-comment">// 执行结果：验证每个then对应不同的Promise</span>
p3.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// 120</span>
</code></pre>
<h4 data-id="heading-16">逐句拆那段「绕口的话」</h4>
<blockquote>
<p>如果我们这里不断的链式调用then方法，然后呢这里每一个then方法，它实际上都是在为上一个then方法返回的promise对象去添加状态明确过后的回调。</p>
</blockquote>
<p>我用「分步拆解+代码标注」的方式解释：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 第一步：创建原始Promise p1（第一个承诺）</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'初始值'</span>));

<span class="hljs-comment">// 第二步：调用p1.then() → 返回新Promise p2（第二个承诺）</span>
<span class="hljs-comment">// 这个then是给p1加回调：p1成功后执行回调，然后决定p2的状态</span>
<span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p1的回调:'</span>, res); <span class="hljs-comment">// 输出：p1的回调: 初始值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'p1回调的返回值'</span>; <span class="hljs-comment">// 这个返回值会决定p2的状态（成功，值为这个字符串）</span>
});

<span class="hljs-comment">// 第三步：调用p2.then() → 返回新Promise p3（第三个承诺）</span>
<span class="hljs-comment">// 这个then是给p2加回调：p2成功后执行回调，然后决定p3的状态</span>
<span class="hljs-keyword">const</span> p3 = p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p2的回调:'</span>, res); <span class="hljs-comment">// 输出：p2的回调: p1回调的返回值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'p2回调的返回值'</span>;
});

<span class="hljs-comment">// 第四步：调用p3.then() → 返回新Promise p4（第四个承诺）</span>
<span class="hljs-comment">// 这个then是给p3加回调：p3成功后执行回调，然后决定p4的状态</span>
<span class="hljs-keyword">const</span> p4 = p3.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p3的回调:'</span>, res); <span class="hljs-comment">// 输出：p3的回调: p2回调的返回值</span>
});
</code></pre>
<h5 data-id="heading-17">拆解逻辑（对应你那段话）：</h5>
<ol>
<li>「不断链式调用 then」→ 代码中 <code>p1.then() → p2.then() → p3.then()</code> 就是链式调用。</li>
<li>「每一个 then 方法，都是为上一个 then 返回的 Promise 对象加回调」：
<ul>
<li><code>p2.then(...)</code> → 是给「p1.then() 返回的 p2」加回调；</li>
<li><code>p3.then(...)</code> → 是给「p2.then() 返回的 p3」加回调；</li>
<li>每个 then 都不是给原始的 p1 加回调，而是给「上一个 then 生成的新 Promise」加回调。</li>
</ul>
</li>
<li>「状态明确过后的回调」：只有当被绑定的 Promise（比如 p2）状态变为 fulfilled/rejected，这个 then 的回调才会执行。</li>
</ol>
<h4 data-id="heading-18">为什么要返回全新的 Promise？（核心目的）</h4>
<p>「<code>返回全新Promise的目的是实现Promise链条，一个承诺结束后返回新承诺，每个承诺负责一个异步任务，相互无影响</code>」，用例子验证：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 场景：第一个异步任务（延迟1s），第二个异步任务（延迟2s）</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第一个异步任务完成'</span>), <span class="hljs-number">1000</span>);
});

<span class="hljs-comment">// 第一个then：负责第一个异步任务的结果处理，返回新Promise（第二个异步任务）</span>
<span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 1s后输出：第一个异步任务完成</span>
  <span class="hljs-comment">// 返回新Promise（第二个异步任务），和p1完全独立</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第二个异步任务完成'</span>), <span class="hljs-number">2000</span>);
  });
});

<span class="hljs-comment">// 第二个then：只关心p2（第二个异步任务）的状态，和p1无关</span>
p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 再等2s后输出：第二个异步任务完成</span>
});

<span class="hljs-comment">// 此时操作p1，不会影响p2</span>
p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p1的另一个回调'</span>)); <span class="hljs-comment">// 1s后输出，和p2无关</span>
</code></pre>
<ul>
<li>每个 Promise（p1/p2）都是独立的，p1 完成不影响 p2 的执行逻辑，p2 延迟也不会干扰 p1 的其他回调；</li>
<li>若 then 返回 <code>this</code>（同一个对象），则无法实现「一个异步任务完成后，再启动下一个独立的异步任务」，因为所有 then 都绑定在同一个对象上，状态只能变一次。</li>
</ul>
<h4 data-id="heading-19">总结</h4>
<ol>
<li>Promise 链式调用≠传统链式调用：传统是返回 <code>this</code>（同一对象），Promise 是返回<strong>全新的 Promise 对象</strong>。</li>
<li>链式调用的本质：每个 <code>then</code> 都是给「上一个 <code>then</code> 返回的新 Promise」绑定回调，而非给原始 Promise 绑定。</li>
<li>返回新 Promise 的核心价值：<code>让每个异步任务都对应一个独立的「承诺」，任务之间相互独立、按顺序执行，实现真正的异步链条。</code></li>
</ol>
<h5 data-id="heading-20">补充：then 回调返回 Promise → 后一个 then 等待该 Promise 结束</h5>
<ul>
<li>第二个 then 回调返回 <code>delayTask(1000, ...)</code>（一个需要等待1s的 Promise）；</li>
<li>此时第三个 then 不会立即执行，而是等待这个返回的 Promise 状态变为 <code>fulfilled</code>（1s后完成）；</li>
<li>等价于：<code>第三个 then</code> 直接绑定到「第二个 then 返回的这个 delayTask Promise」上，成为它的回调。</li>
</ul>
<p>为了让你更清楚「后一个 then 等价于给返回的 Promise 注册回调」，把上面的代码拆成非链式写法，逻辑完全一致：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 拆分成非链式写法，等价于上面的链式调用</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-title function_">delayTask</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">'第一个异步任务结果'</span>);

<span class="hljs-comment">// 第一个then：返回p2</span>
<span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res1</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一个then回调执行:'</span>, res1);
  <span class="hljs-keyword">return</span> <span class="hljs-string">'第一个then的返回值（普通值）'</span>;
});

<span class="hljs-comment">// 第二个then：返回p3</span>
<span class="hljs-keyword">const</span> p3 = p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res2</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二个then回调执行:'</span>, res2);
  <span class="hljs-comment">// 返回一个新的Promise p_temp</span>
  <span class="hljs-keyword">const</span> p_temp = <span class="hljs-title function_">delayTask</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">'第二个then返回的Promise结果'</span>);
  <span class="hljs-keyword">return</span> p_temp;
});

<span class="hljs-comment">// 第三个then：等价于给p_temp注册回调（因为p3的状态由p_temp决定）</span>
<span class="hljs-keyword">const</span> p4 = p3.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res3</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第三个then回调执行:'</span>, res3);
  <span class="hljs-keyword">return</span> <span class="hljs-string">'最终结果'</span>;
});

<span class="hljs-comment">// 等价于直接给p_temp注册回调：</span>
<span class="hljs-comment">// p_temp.then((res3) =&gt; {</span>
<span class="hljs-comment">//   console.log('第三个then回调执行:', res3);</span>
<span class="hljs-comment">// });</span>
</code></pre>
<h2 data-id="heading-21">catch() 与 <code>then(成功, 失败)</code> 的失败回调 是否完全等价？</h2>
<h4 data-id="heading-22">先明确核心结论（先记重点）</h4>
<ul>
<li><code>catch()</code> 等价于 <code>then(undefined, 失败回调)</code>，但<strong>绑定的是上一个 then 返回的新 Promise</strong>；</li>
<li><code>then(成功回调, 失败回调)</code> 中的失败回调，<strong>只绑定当前 Promise</strong>，管不到后续 then 里的新 Promise 异常；</li>
<li>Promise 链条中，异常会「向后传递」，直到被某个失败回调捕获。</li>
</ul>
<h4 data-id="heading-23">对比示例：then第二个参数 vs catch（直观看差异）</h4>
<p>我们用「两步异步任务」的场景，模拟第一步成功、第二步失败的情况，对比两种写法的结果：</p>
<h5 data-id="heading-24">第一步：封装模拟异步函数</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟异步任务1：一定成功，返回"第一步结果"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">task1</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"第一步结果"</span>);
  });
}

<span class="hljs-comment">// 模拟异步任务2：一定失败，抛出异常</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">task2</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"第二步执行失败"</span>));
  });
}
</code></pre>
<h5 data-id="heading-25">场景1：用 then 的第二个参数注册失败回调（只能捕获第一步异常）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 写法1：then(成功回调, 失败回调)</span>
<span class="hljs-title function_">task1</span>()
  .<span class="hljs-title function_">then</span>(
    <span class="hljs-comment">// 成功回调：第一步成功后执行，调用task2（返回失败的Promise）</span>
    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"第一步成功："</span>, res);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">task2</span>(); <span class="hljs-comment">// 返回一个失败的新Promise（记为P2）</span>
    },
    <span class="hljs-comment">// 失败回调：只绑定task1返回的Promise（记为P1），只能捕获P1的异常</span>
    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"捕获到异常："</span>, err.<span class="hljs-property">message</span>);
    }
  );

<span class="hljs-comment">/* 输出结果：
第一步成功： 第一步结果
Uncaught (in promise) Error: 第二步执行失败
*/</span>
</code></pre>
<p><strong>关键问题</strong>：第二步的异常没被捕获！因为 then 的第二个参数只负责「task1 返回的 P1」，管不到「第一个 then 返回的 P2（task2 的 Promise）」的异常。</p>
<h5 data-id="heading-26">场景2：用 catch 注册失败回调（能捕获整个链条的异常）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 写法2：then(成功回调) + catch(失败回调)</span>
<span class="hljs-title function_">task1</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"第一步成功："</span>, res);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">task2</span>(); <span class="hljs-comment">// 返回失败的P2</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-comment">// catch绑定的是「上一个then返回的P2」，能捕获P2的异常</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"捕获到异常："</span>, err.<span class="hljs-property">message</span>);
  });

<span class="hljs-comment">/* 输出结果：
第一步成功： 第一步结果
捕获到异常： 第二步执行失败
*/</span>
</code></pre>
<p><strong>核心原因</strong>：catch 等价于 <code>then(undefined, 失败回调)</code>，这个失败回调绑定在「第一个 then 返回的 P2」上，刚好能捕获 P2 的异常。</p>
<h4 data-id="heading-27">拆解异常传递+回调绑定逻辑（为什么会这样？）</h4>
<p>我们用「Promise 链条对象关系」来拆解上面的代码：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">task1</span>() → 返回 P1（成功状态）
↓
P1<span class="hljs-selector-class">.then</span>(成功回调, 失败回调) → 返回 P2（由成功回调的返回值决定：<span class="hljs-built_in">task2</span>() 返回失败的Promise → P2 失败）
↓
P2<span class="hljs-selector-class">.catch</span>(失败回调) → 绑定在 P2 上，捕获 P2 的失败
</code></pre>
<h5 data-id="heading-28">关键细节：</h5>
<ol>
<li><code>then(成功回调, 失败回调)</code> 的失败回调 → 只绑定 <strong>P1</strong>，只能处理 P1 的异常（比如 task1 失败）；</li>
<li><code>catch()</code> → 绑定 <strong>P2</strong>，能处理 P2 的异常（包括 P2 自身失败、或 P1 未被捕获的异常向后传递过来）；</li>
<li>异常传递规则：如果一个 Promise 失败且没有对应的失败回调，异常会「顺着链条往后传」，直到被某个 catch/then 失败回调捕获。</li>
</ol>
<h4 data-id="heading-29">补充：如果第一步就失败，两种写法的表现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 改造task1：让第一步直接失败</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">task1</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"第一步执行失败"</span>));
  });
}

<span class="hljs-comment">// 写法1：then的第二个参数 → 能捕获P1的异常</span>
<span class="hljs-title function_">task1</span>().<span class="hljs-title function_">then</span>(
  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res),
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"then捕获："</span>, err.<span class="hljs-property">message</span>) <span class="hljs-comment">// 输出：then捕获：第一步执行失败</span>
);

<span class="hljs-comment">// 写法2：catch → 也能捕获（因为P1的异常传递到P2，被catch捕获）</span>
<span class="hljs-title function_">task1</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"catch捕获："</span>, err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 输出：catch捕获：第一步执行失败</span>
</code></pre>
<p>这说明：<strong>catch 能捕获整个链条中「前面所有未被处理的异常」，而 then 第二个参数只能捕获「当前 Promise」的异常</strong>。</p>
<h4 data-id="heading-30">为什么 catch 更适合链式调用？</h4>
<ul>
<li>链式调用的核心是「多个异步任务依次执行」，每个任务对应链条中的一个 Promise；</li>
<li>用 catch 可以「统一捕获整个链条的所有异常」，无需在每个 then 里写失败回调；</li>
<li>用 then 第二个参数则需要「每个 then 都写失败回调」，否则后续 Promise 的异常会逃逸（未捕获）。</li>
</ul>
<h4 data-id="heading-31">总结</h4>
<ol>
<li><code>catch()</code> 是 <code>then(undefined, 失败回调)</code> 的语法糖，但绑定的是<strong>上一个 then 返回的新 Promise</strong>，而非原始 Promise；</li>
<li><code>then(成功, 失败)</code> 的失败回调<strong>仅绑定当前 Promise</strong>，无法捕获后续 then 中返回的新 Promise 异常；</li>
<li>Promise 异常会「向后传递」，catch 因绑定在链条末端的 Promise 上，能捕获整个链条的所有未处理异常，这也是它更适合链式调用的核心原因。</li>
</ol>
<h2 data-id="heading-32">unhandledrejection 是否推荐使用</h2>
<h4 data-id="heading-33">一、先简单了解全局捕获（仅作认知，不推荐使用）</h4>
<h5 data-id="heading-34">1. 浏览器环境（window 上注册 unhandledrejection）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 浏览器中全局捕获未处理的Promise异常（仅演示，不推荐）</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-comment">// 阻止浏览器默认的错误提示（比如控制台的红色报错）</span>
  event.<span class="hljs-title function_">preventDefault</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'全局捕获未处理的Promise异常：'</span>, event.<span class="hljs-property">reason</span>.<span class="hljs-property">message</span>);
});

<span class="hljs-comment">// 测试：抛出一个未手动捕获的Promise异常</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'这是一个未被手动捕获的异常'</span>));
});
<span class="hljs-comment">// 控制台会输出：全局捕获未处理的Promise异常：这是一个未被手动捕获的异常</span>
</code></pre>
<h5 data-id="heading-35">2. Node.js 环境（process 上注册 unhandledRejection）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Node.js中全局捕获（仅演示，不推荐）</span>
process.<span class="hljs-title function_">on</span>(<span class="hljs-string">'unhandledRejection'</span>, <span class="hljs-function">(<span class="hljs-params">reason, promise</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'全局捕获未处理的Promise异常：'</span>, reason.<span class="hljs-property">message</span>);
});

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Node中未被手动捕获的异常'</span>));
});
</code></pre>
<h4 data-id="heading-36">二、为什么强烈不推荐全局捕获？（核心原因）</h4>
<p>「不推荐全局统一处理」，核心问题有这几点：</p>
<ol>
<li><strong>调试困难</strong>：全局捕获会「兜底」所有未处理的异常，但无法精准定位异常发生的位置——一个大型项目中，你无法从全局回调里快速知道是哪一行代码、哪个异步任务抛出的异常。</li>
<li><strong>掩盖问题</strong>：全局捕获会让开发者产生「反正有兜底，不用手动写 catch」的惰性，导致代码中大量异常没有被「针对性处理」（比如某个接口失败需要重试，另一个需要提示用户，全局捕获只能统一打印，无法差异化处理）。</li>
<li><strong>不可控性</strong>：全局事件是「最后一道防线」，若代码中漏写 catch，全局捕获会接住异常，但这属于「被动补救」，而非「主动处理」，容易埋下线上bug（比如异常处理逻辑不匹配场景）。</li>
</ol>
<h4 data-id="heading-37">三、更优的做法：显式捕获每一个可能的异常</h4>
<p>最佳实践是「链式调用末尾加 catch」+「针对不同场景差异化处理异常」，甚至可以给不同异步任务加「专属的异常处理」。</p>
<h5 data-id="heading-38">示例1：基础版——链式末尾统一 catch</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟两个异步任务，第二步可能失败</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">task1</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第一步成功'</span>));
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">task2</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// 模拟随机失败</span>
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> 
      ? <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'第二步成功'</span>) 
      : <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'第二步接口调用失败'</span>));
  });
}

<span class="hljs-comment">// 显式捕获：链式末尾加catch，针对性处理</span>
<span class="hljs-title function_">task1</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">task2</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-comment">// 精准处理：区分不同异常，做不同操作</span>
    <span class="hljs-keyword">if</span> (err.<span class="hljs-property">message</span> === <span class="hljs-string">'第二步接口调用失败'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理第二步失败：'</span>, <span class="hljs-string">'重试一次或提示用户'</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'其他异常：'</span>, err.<span class="hljs-property">message</span>);
    }
  });
</code></pre>
<h5 data-id="heading-39">示例2：进阶版——分阶段捕获（不同任务单独处理）</h5>
<p>如果某个异步任务的异常需要「单独处理，不中断后续流程」，可以在该任务的 then 后紧跟 catch：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">task1</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
    <span class="hljs-comment">// 第二步失败后单独处理，不影响后续流程</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">task2</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二步单独处理失败：'</span>, err.<span class="hljs-property">message</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-string">'第二步失败后的兜底值'</span>; <span class="hljs-comment">// 返回兜底值，让链条继续</span>
    });
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-comment">// `无论第二步成功/失败，都会执行这里`--- 重点！！！</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第三步：接收第二步结果'</span>, res);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-comment">// 捕获其他未处理的异常</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'全局兜底（极少触发）：'</span>, err.<span class="hljs-property">message</span>);
  });
</code></pre>
<h4 data-id="heading-40">总结</h4>
<ol>
<li>全局 <code>unhandledrejection</code>/<code>unhandledRejection</code> 是「兜底方案」，仅适合临时调试或紧急补救，<strong>不推荐作为常规异常处理方式</strong>；</li>
<li>最佳实践是「显式捕获」：在 Promise 链条末尾加 <code>catch</code>，针对不同异常做「差异化处理」（重试、兜底、提示用户等）；</li>
<li>若需要保留链条执行，可在单个异步任务后紧跟 catch，返回兜底值，避免整个链条中断。</li>
<li><strong><code>关于catch返回值：</code></strong>
<ul>
<li>如果 catch 回调<strong>返回正常值</strong>（普通值 / 成功的 Promise）→ 新 Promise 状态为 <code>fulfilled</code>（成功）；</li>
<li>如果 catch 回调<strong>抛出异常 / 返回失败的 Promise</strong> → 新 Promise 状态为 <code>rejected</code>（失败）</li>
</ul>
</li>
</ol>
<ul>
<li>如果 catch 回调<strong>抛出异常 / 返回失败的 Promise</strong> → 新 Promise 状态为 <code>rejected</code>（失败）</li>
</ul>
<h2 data-id="heading-41">Promise.reslove</h2>
<h4 data-id="heading-42">一、Promise.resolve() 基本用法</h4>
<p><code>Promise.resolve(value)</code> 是创建「已成功 Promise」的快捷方式，无需手动写 <code>new Promise</code> + <code>resolve</code>，核心逻辑就是：<strong>接收一个值，返回一个状态为 fulfilled 的 Promise，且该值会作为 Promise 的成功结果</strong>。</p>
<h5 data-id="heading-43">代码示例：Promise.resolve() 基础使用</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 用 Promise.resolve 快速创建成功的 Promise</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'foo'</span>);

<span class="hljs-comment">// 调用 then 接收结果（你提到的 unfulfilled 是笔误，正确是 fulfilled）</span>
p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'成功回调拿到的值：'</span>, res); <span class="hljs-comment">// 输出：成功回调拿到的值：foo</span>
});
</code></pre>
<h4 data-id="heading-44">二、等价逻辑：Promise.resolve() ≈ new Promise + resolve</h4>
<p>你提到「这种方式完全等价于 new Promise 然后直接 resolve 该值」，我们用代码验证这个等价性：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 方式1：Promise.resolve 快捷写法</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'foo'</span>);

<span class="hljs-comment">// 方式2：new Promise 完整写法（和方式1完全等价）</span>
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-comment">// 在执行函数中直接 resolve 'foo'，Promise 状态立即变为 fulfilled</span>
  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'foo'</span>);
});

<span class="hljs-comment">// 测试两个 Promise 的执行结果（完全一致）</span>
p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p1结果：'</span>, res)); <span class="hljs-comment">// p1结果：foo</span>
p2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p2结果：'</span>, res)); <span class="hljs-comment">// p2结果：foo</span>
</code></pre>
<h5 data-id="heading-45">核心等价点：</h5>
<ul>
<li>两者创建的 Promise 状态都是 <code>fulfilled</code>（成功）；</li>
<li>两者的成功回调拿到的参数都是传入的 <code>'foo'</code>；</li>
<li>两者的执行时机一致：<code>Promise.resolve()</code> 内部的逻辑和 <code>new Promise</code> 的执行函数一样，是<strong>同步执行</strong>的（但回调仍为微任务）。</li>
</ul>
<h4 data-id="heading-46">三、Promise.resolve() 的进阶场景（拓展理解）</h4>
<p>除了传入普通值（字符串、数字等），<code>Promise.resolve()</code> 还有两个常见场景，帮你全面掌握：</p>
<h5 data-id="heading-47">场景1：传入 Promise 对象</h5>
<p>如果传入的是一个已存在的 Promise，<code>Promise.resolve()</code> 会直接返回这个 Promise（不会创建新对象）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> originalPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'原始Promise'</span>));
<span class="hljs-keyword">const</span> wrappedPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(originalPromise);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalPromise === wrappedPromise); <span class="hljs-comment">// true（返回同一个对象）</span>
wrappedPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// 原始Promise</span>
</code></pre>
<h5 data-id="heading-48">场景2：传入「类 Promise 对象」（thenable）</h5>
<p>如果传入的是有 <code>then</code> 方法的对象（称为 thenable），<code>Promise.resolve()</code> 会执行其 <code>then</code> 方法，将其转换成标准 Promise：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 定义一个 thenable 对象（有 then 方法，但不是真正的 Promise）</span>
<span class="hljs-keyword">const</span> thenable = {
  <span class="hljs-title function_">then</span>(<span class="hljs-params">resolve</span>) {
    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'thenable 转换的结果'</span>);
  }
};

<span class="hljs-comment">// Promise.resolve 会执行 then 方法，转换成标准 Promise</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 输出：thenable 转换的结果</span>
});
</code></pre>
<h4 data-id="heading-49">四、为什么要用 Promise.resolve()？</h4>
<p>相比 <code>new Promise</code> 写法，<code>Promise.resolve()</code> 的优势在于：</p>
<ol>
<li><strong>简化代码</strong>：创建已成功的 Promise 时，少写嵌套的执行函数，代码更简洁；</li>
<li><strong>统一接口</strong>：当你不确定一个值是普通值还是 Promise 时，用 <code>Promise.resolve()</code> 可以「归一化」成 Promise，方便链式调用：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 假设 fn 可能返回普通值，也可能返回 Promise</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-string">'普通值'</span> : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Promise值'</span>);
}

<span class="hljs-comment">// 用 Promise.resolve 统一处理，无需区分类型</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'统一拿到结果：'</span>, res);
});
</code></pre>
</li>
</ol>
<h4 data-id="heading-50">总结</h4>
<ol>
<li><code>Promise.resolve(value)</code> 是创建<strong>状态为 fulfilled 的 Promise</strong> 的快捷方式，等价于 <code>new Promise((resolve) =&gt; resolve(value))</code>；</li>
<li>传入普通值时，该值会作为 Promise 的成功结果，在 <code>then</code> 的成功回调中获取；</li>
<li>传入 Promise/thenable 对象时，<code>Promise.resolve()</code> 会适配并返回标准 Promise，核心作用是「归一化」值的类型，方便异步处理。</li>
</ol>
<p>核心记住：<code>Promise.resolve()</code> 的本质是「快速生成成功的 Promise」，减少冗余代码，统一异步/同步值的处理逻辑。</p>
<h2 data-id="heading-51">Promise.reject</h2>
<h4 data-id="heading-52">Promise.reject() 快速创建失败的 Promise</h4>
<p><code>Promise.reject()</code> 是创建「状态为 rejected（失败）」Promise 的快捷方式，你提到「无论传入什么参数，都会作为失败理由」，代码验证：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 传入普通值（字符串）</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'普通错误信息'</span>);
p1.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p1失败理由：'</span>, err)); <span class="hljs-comment">// 输出：p1失败理由：普通错误信息</span>

<span class="hljs-comment">// 2. 传入 Error 对象（推荐写法，包含堆栈信息）</span>
<span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'标准错误对象'</span>));
p2.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p2失败理由：'</span>, err.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 输出：p2失败理由：标准错误对象</span>

<span class="hljs-comment">// 3. 传入 Promise 对象（和 resolve 不同，不会原样返回，而是直接作为失败理由）</span>
<span class="hljs-keyword">const</span> originalPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'成功的Promise'</span>);
<span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(originalPromise);
p3.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'p3失败理由是原Promise：'</span>, err === originalPromise); <span class="hljs-comment">// 输出：true</span>
});
</code></pre>
<h5 data-id="heading-53">关键区别（和 Promise.resolve 对比）：</h5>
<ul>
<li><code>Promise.resolve(已存在的Promise)</code> → 返回原 Promise；</li>
<li><code>Promise.reject(已存在的Promise)</code> → 不会返回原 Promise，而是把这个 Promise 对象<strong>直接作为失败理由</strong>。</li>
</ul>
<h4 data-id="heading-54">总结</h4>
<ol>
<li><code>Promise.resolve(x)</code> 规则：
<ul>
<li>x 是普通值 → 返回 fulfilled 状态的 Promise，x 为成功结果；</li>
<li>x 是 Promise → 原样返回 x；</li>
<li>x 是 thenable 对象 → 转换成原生 Promise，执行其 then 方法。</li>
</ul>
</li>
<li><code>Promise.reject(reason)</code> 规则：
<ul>
<li>无论 reason 是普通值、Error 对象、甚至 Promise 对象，都会直接作为「失败理由」，返回 rejected 状态的 Promise；</li>
<li>推荐传入 <code>Error</code> 对象（而非字符串），便于调试（包含错误堆栈）。</li>
</ul>
</li>
<li><code>Promise.resolve/reject</code> 的核心价值：简化 Promise 创建代码，统一异步值的处理逻辑（尤其是 resolve 对 thenable 的兼容）。</li>
</ol>
<h2 data-id="heading-55">为什么 Promise 的递归调用会导致浏览器卡死，而 setTimeout 的递归调用通常不会？</h2>
<h4 data-id="heading-56">先看直观对比（代码+现象）</h4>
<p>先跑两段代码，直观感受差异：</p>
<h5 data-id="heading-57">示例1：Promise 递归（卡死浏览器）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Promise 递归：同步占用主线程，无喘息机会</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseRecursion</span>(<span class="hljs-params"/>) {
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Promise 递归执行"</span>);
    <span class="hljs-title function_">promiseRecursion</span>(); <span class="hljs-comment">// 递归调用</span>
  });
}
<span class="hljs-title function_">promiseRecursion</span>();
</code></pre>
<p><strong>现象</strong>：浏览器标签页卡顿、无响应，控制台疯狂输出，但页面无法交互，甚至会触发「页面无响应」提示。</p>
<h5 data-id="heading-58">示例2：setTimeout 递归（不卡死）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// setTimeout 递归：每次执行后释放主线程</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutRecursion</span>(<span class="hljs-params"/>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"setTimeout 递归执行"</span>);
    <span class="hljs-title function_">timeoutRecursion</span>(); <span class="hljs-comment">// 递归调用</span>
  }, <span class="hljs-number">0</span>);
}
<span class="hljs-title function_">timeoutRecursion</span>();
</code></pre>
<p><strong>现象</strong>：控制台持续输出，但页面仍能点击、滚动，浏览器完全不卡顿。</p>
<h4 data-id="heading-59">核心原因拆解（事件循环+调用栈）</h4>
<p>浏览器的主线程是「单线程」，所有 JS 执行、DOM 渲染、事件响应都在这一个线程里，能否「释放主线程」是是否卡死的关键：</p>
<h5 data-id="heading-60">1. Promise 递归：微任务「抢占式」执行，调用栈永不清空</h5>
<ul>
<li><strong>Promise.then 的回调属于「微任务」</strong>：微任务的执行规则是「当前宏任务执行完毕后，立即清空所有微任务队列，再执行下一个宏任务/渲染/事件」。</li>
<li><strong>递归逻辑</strong>：
<ol>
<li>第一次调用 <code>promiseRecursion()</code>，<code>Promise.resolve()</code> 生成微任务 A；</li>
<li>当前宏任务执行完，执行微任务 A → 打印日志，调用 <code>promiseRecursion()</code> → 生成微任务 B；</li>
<li>微任务 A 执行完，立即执行微任务 B → 打印日志，生成微任务 C；</li>
<li>这个过程<strong>无限循环</strong>，微任务队列永远有新任务，主线程被微任务「占满」，没有任何时间片分配给：
<ul>
<li>DOM 渲染（页面卡死）；</li>
<li>鼠标点击/滚动等事件响应（交互失效）；</li>
<li>其他宏任务（比如 setTimeout、网络请求）。</li>
</ul>
</li>
</ol>
</li>
<li><strong>调用栈角度</strong>：虽然每次 then 回调执行完会清空当前调用栈，但微任务的「连续执行」让主线程没有「空闲期」，本质是「无限的同步执行流」。</li>
</ul>
<h5 data-id="heading-61">2. setTimeout 递归：宏任务「排队式」执行，每次释放主线程</h5>
<ul>
<li><strong>setTimeout 的回调属于「宏任务」</strong>：宏任务的执行规则是「执行完一个宏任务后，先执行所有微任务，再处理渲染，再取下一个宏任务」。</li>
<li><strong>递归逻辑</strong>：
<ol>
<li>第一次调用 <code>timeoutRecursion()</code>，<code>setTimeout</code> 把回调 A 加入「宏任务队列」；</li>
<li>当前宏任务执行完，执行微任务 → 渲染页面 → 处理事件（点击/滚动）→ 再执行宏任务 A；</li>
<li>宏任务 A 执行：打印日志，调用 <code>timeoutRecursion()</code> → 把回调 B 加入宏任务队列；</li>
<li>宏任务 A 执行完，主线程会「释放」，先处理渲染、事件响应，再执行下一个宏任务 B；</li>
<li>这个过程虽然无限，但<strong>每次宏任务执行完都会给主线程喘息机会</strong>，页面渲染、事件响应能正常进行，因此不会卡死。</li>
</ol>
</li>
</ul>
<h4 data-id="heading-62">补充：为什么 Promise 微任务要「立即执行」？</h4>
<p>微任务的设计初衷是「处理异步但需要尽快完成的逻辑」（比如 Promise 回调、async/await），优先级高于宏任务和渲染，这保证了异步逻辑的执行顺序，但无限递归的微任务会滥用这个优先级，导致主线程阻塞。</p>
<h4 data-id="heading-63">总结</h4>
<ol>
<li><strong>核心差异</strong>：Promise 递归是「微任务无限连续执行」，主线程无喘息机会；setTimeout 递归是「宏任务排队执行」，每次执行后释放主线程，允许渲染/事件响应。</li>
<li><strong>调用栈/队列</strong>：Promise 递归让微任务队列永远非空，主线程被占满；setTimeout 递归的宏任务队列虽有任务，但每次执行完会处理渲染和事件。</li>
<li><strong>本质</strong>：浏览器卡死的核心是「主线程无法处理渲染/交互」，而非「递归本身」——setTimeout 递归给了主线程处理这些的时间，而 Promise 递归没有。</li>
</ol>
<p>如果想让 Promise 递归不卡死，可在递归中加入 <code>setTimeout</code> 「让出主线程」：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 改进版 Promise 递归：不卡死</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseRecursion</span>(<span class="hljs-params"/>) {
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Promise 递归执行"</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">promiseRecursion</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 用setTimeout让出主线程</span>
  });
}
<span class="hljs-title function_">promiseRecursion</span>();
</code></pre>
<h2 data-id="heading-64">Promise 的 <code>then</code> 方法的核心实现</h2>
<h4 data-id="heading-65">先明确 then 方法的核心需求</h4>
<ol>
<li><code>then</code> 接收两个参数：<code>onFulfilled</code>（成功回调）、<code>onRejected</code>（失败回调）；</li>
<li>回调需异步执行（微任务，这里用 <code>setTimeout</code> 模拟）；</li>
<li>若 Promise 状态未确定（pending），需先存储回调；若已确定，直接执行回调；</li>
<li><code>then</code> 必须返回新的 Promise，实现链式调用；</li>
<li>上一个 <code>then</code> 的回调返回值，决定新 Promise 的状态。</li>
</ol>
<h4 data-id="heading-66">极简版 Promise + then 实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟 Promise 的核心实现（仅保留 then 方法的核心逻辑）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> {
  <span class="hljs-comment">// 定义三种状态</span>
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">'pending'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">'fulfilled'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">'rejected'</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) {
    <span class="hljs-comment">// 初始状态</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">PENDING</span>;
    <span class="hljs-comment">// 成功结果</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;
    <span class="hljs-comment">// 失败原因</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;
    <span class="hljs-comment">// 存储 pending 状态时的回调（因为此时状态未确定，需等待）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];

    <span class="hljs-comment">// resolve 函数：修改状态为成功，执行存储的成功回调</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; {
      <span class="hljs-comment">// 状态不可逆：只有 pending 时才能修改</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">PENDING</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">FULFILLED</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
        <span class="hljs-comment">// 执行所有存储的成功回调</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>());
      }
    };

    <span class="hljs-comment">// reject 函数：修改状态为失败，执行存储的失败回调</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">PENDING</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">REJECTED</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;
        <span class="hljs-comment">// 执行所有存储的失败回调</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>());
      }
    };

    <span class="hljs-comment">// 执行器函数同步执行，捕获执行过程中的异常</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-title function_">executor</span>(resolve, reject);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-title function_">reject</span>(error);
    }
  }

  <span class="hljs-comment">// 核心：实现 then 方法</span>
  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) {
    <span class="hljs-comment">// 兼容：如果没传回调，透传结果（比如 then().then() 的场景）</span>
    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;
    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> { <span class="hljs-keyword">throw</span> reason; };

    <span class="hljs-comment">// 关键：then 返回新的 Promise，实现链式调用</span>
    <span class="hljs-keyword">const</span> newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 封装回调执行逻辑（复用代码）</span>
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">executeCallback</span> = (<span class="hljs-params">callback, data</span>) =&gt; {
        <span class="hljs-comment">// 异步执行回调（用 setTimeout 模拟微任务）</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行回调，获取返回值</span>
            <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(data);
            <span class="hljs-comment">// 核心规则：回调返回值决定新 Promise 的状态</span>
            <span class="hljs-title function_">resolvePromise</span>(newPromise, result, resolve, reject);
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-comment">// 回调执行出错，新 Promise 状态为失败</span>
            <span class="hljs-title function_">reject</span>(error);
          }
        }, <span class="hljs-number">0</span>);
      };

      <span class="hljs-comment">// 1. 如果当前 Promise 已成功</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">FULFILLED</span>) {
        <span class="hljs-title function_">executeCallback</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
      }

      <span class="hljs-comment">// 2. 如果当前 Promise 已失败</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">REJECTED</span>) {
        <span class="hljs-title function_">executeCallback</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);
      }

      <span class="hljs-comment">// 3. 如果当前 Promise 还是 pending（状态未确定），存储回调</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">PENDING</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-title function_">executeCallback</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
        });
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-title function_">executeCallback</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);
        });
      }
    });

    <span class="hljs-keyword">return</span> newPromise;
  }
}

<span class="hljs-comment">// 辅助函数：处理 then 回调的返回值，决定新 Promise 的状态</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">newPromise, result, resolve, reject</span>) {
  <span class="hljs-comment">// 避免循环引用（比如回调返回 newPromise 本身）</span>
  <span class="hljs-keyword">if</span> (result === newPromise) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Chaining cycle detected for promise'</span>));
  }

  <span class="hljs-comment">// 1. 如果返回值是 Promise 实例</span>
  <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) {
    <span class="hljs-comment">// 等待该 Promise 完成，再决定新 Promise 的状态</span>
    result.<span class="hljs-title function_">then</span>(resolve, reject);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 2. 如果返回值是普通值，直接 resolve 新 Promise</span>
    <span class="hljs-title function_">resolve</span>(result);
  }
}
</code></pre>
<h4 data-id="heading-67">核心逻辑拆解（重点理解）</h4>
<h5 data-id="heading-68">1. 状态管理</h5>
<ul>
<li>初始状态为 <code>pending</code>，只有调用 <code>resolve</code>/<code>reject</code> 且状态为 <code>pending</code> 时，才能修改状态；</li>
<li>状态不可逆，一旦变为 <code>fulfilled</code>/<code>rejected</code>，无法再改。</li>
</ul>
<h5 data-id="heading-69">2. 回调存储（pending 状态）</h5>
<ul>
<li>如果调用 <code>then</code> 时，Promise 还处于 <code>pending</code>（比如异步任务没完成），会把回调存储到数组中；</li>
<li>等状态确定后（调用 <code>resolve</code>/<code>reject</code>），遍历执行存储的回调。</li>
</ul>
<h5 data-id="heading-70">3. 异步执行回调</h5>
<ul>
<li>用 <code>setTimeout</code> 模拟微任务（真实 Promise 是微任务，优先级比宏任务高，这里简化）；</li>
<li>确保回调不会同步执行，符合 Promise 规范。</li>
</ul>
<h5 data-id="heading-71">4. 链式调用的核心（返回新 Promise）</h5>
<ul>
<li><code>then</code> 必须返回新的 <code>MyPromise</code>，而非 <code>this</code>；</li>
<li>回调的返回值通过 <code>resolvePromise</code> 处理：
<ul>
<li>返回普通值 → 新 Promise 状态为 <code>fulfilled</code>；</li>
<li>返回 Promise 实例 → 等待该实例完成，继承其状态；</li>
<li>回调抛出异常 → 新 Promise 状态为 <code>rejected</code>。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-72">测试代码（验证 then 功能）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 测试1：基础使用</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);
});

p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第一次then：'</span>, res); <span class="hljs-comment">// 1s后输出：第一次then：100</span>
  <span class="hljs-keyword">return</span> res + <span class="hljs-number">10</span>; <span class="hljs-comment">// 返回普通值</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第二次then：'</span>, res); <span class="hljs-comment">// 输出：第二次then：110</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(res + <span class="hljs-number">10</span>)); <span class="hljs-comment">// 返回Promise</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'第三次then：'</span>, res); <span class="hljs-comment">// 输出：第三次then：120</span>
});

<span class="hljs-comment">// 测试2：失败场景</span>
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> {
  <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'失败了'</span>));
});

p2.<span class="hljs-title function_">then</span>(
  <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res),
  <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'失败回调：'</span>, err.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出：失败回调：失败了</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'回调里抛错'</span>);
  }
).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { <span class="hljs-comment">// 注：catch 本质是 then(undefined, onRejected)，可自行补充实现</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获回调错误：'</span>, err.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出：捕获回调错误：回调里抛错</span>
});
</code></pre>
<h4 data-id="heading-73">补充：catch 方法（可选）</h4>
<p>如果想补充 <code>catch</code> 方法，只需在 <code>MyPromise</code> 中加一行：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">catch</span>(onRejected) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);
}
</code></pre>
<h4 data-id="heading-74">总结</h4>
<ol>
<li><code>then</code> 方法的核心是「状态判断 + 回调存储/执行 + 返回新 Promise」；</li>
<li>异步执行回调、状态不可逆、链式调用（返回新 Promise）是 <code>then</code> 的三大关键特性；</li>
<li>这个极简实现去掉了复杂的边界处理（如 thenable 对象、多次调用 then 等），但保留了 <code>then</code> 最核心的逻辑，能帮你理解原生 Promise 的 <code>then</code> 是如何工作的。</li>
</ol>
<h2 data-id="heading-75">Promise 设计模式</h2>
<p>Promise 的实现并非单一设计模式，而是<strong>多个模式的组合</strong>，每个模式解决一个核心问题，先看关键模式及对应作用：</p>






























<table><thead><tr><th>设计模式</th><th>核心作用（Promise 中的体现）</th><th>对应实现代码（极简版 MyPromise）</th></tr></thead><tbody><tr><td><strong>状态模式</strong></td><td>管理 Promise 的三种状态（pending/fulfilled/rejected），且状态不可逆</td><td>1. 定义 <code>status</code> 属性，初始为 pending；<br/>2. <code>resolve/reject</code> 仅在 pending 时修改状态；<br/>3. <code>then</code> 方法根据不同状态执行不同逻辑（存储回调/直接执行）。</td></tr><tr><td><strong>观察者模式</strong></td><td>解决「状态变更后通知所有回调」的问题（比如 pending 时多次调用 then，状态确定后全部执行）</td><td>1. 定义 <code>onFulfilledCallbacks</code>/<code>onRejectedCallbacks</code> 数组（存储观察者）；<br/>2. 状态变更时（resolve/reject），遍历执行数组中的回调（通知观察者）。</td></tr><tr><td><strong>工厂模式</strong></td><td><code>then</code> 方法返回新的 Promise 实例（无需手动 new，由 then 内部创建），实现链式调用</td><td>1. <code>then</code> 内部创建 <code>newPromise</code> 并返回；<br/>2. <code>resolvePromise</code> 辅助函数根据回调返回值「生产」新 Promise 的状态。</td></tr><tr><td><strong>策略模式</strong></td><td>允许动态传入不同的回调策略（onFulfilled/onRejected），状态变更时执行对应策略</td><td>1. <code>then</code> 接收两个回调参数（不同的处理策略）；<br/>2. 成功时执行 onFulfilled，失败时执行 onRejected。</td></tr></tbody></table>
<h2 data-id="heading-76">微任务小迷思：<code>then</code> 里「push 回调到数组」和「推到微任务队列」是一回事吗</h2>
<h4 data-id="heading-77">先给核心结论</h4>
<ul>
<li><strong>push 回调到数组</strong>：解决「Promise 还在 pending 状态时，回调该存哪」的问题（存储逻辑）；</li>
<li><strong>推到微任务队列</strong>：解决「回调该什么时候执行」的问题（执行时机逻辑）；</li>
<li>二者关系：<code>push</code> 是「保存回调」，微任务队列是「调度执行」—— 先保存，再在合适的时机丢到微任务队列执行。</li>
</ul>
<h4 data-id="heading-78">一、先分清两个「队列」：回调存储数组 vs 微任务队列</h4>
<p>这是最容易混淆的点，先明确二者的定位：</p>























<table><thead><tr><th>类型</th><th>作用</th><th>时机</th><th>对应 Promise 状态</th></tr></thead><tbody><tr><td>回调存储数组（如 <code>onFulfilledCallbacks</code>）</td><td>临时保存回调，避免丢失</td><td>调用 <code>then</code> 时，Promise 是 <code>pending</code> 状态</td><td>pending（异步任务未完成）</td></tr><tr><td>微任务队列（浏览器/Node 内置）</td><td>调度回调的执行时机，保证异步</td><td>回调准备执行时（Promise 状态确定后）</td><td>fulfilled/rejected（异步任务完成）</td></tr></tbody></table>
<h4 data-id="heading-79">二、分步拆解：两个操作的配合流程（结合代码）</h4>
<p>用我们之前写的 <code>MyPromise</code> 代码，还原完整执行流程：</p>
<h5 data-id="heading-80">场景：异步 Promise + 调用 then</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 创建异步 Promise（pending 状态，1s 后 resolve）</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);
});

<span class="hljs-comment">// 2. 调用 then：此时 Promise 还是 pending，执行「push 回调到数组」</span>
p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'回调执行：'</span>, res));
</code></pre>
<h5 data-id="heading-81">步骤1：push 回调到数组（存储）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// MyPromise 的 then 方法中</span>
<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">PENDING</span>) {
  <span class="hljs-comment">// 关键：把回调逻辑包装后，push 到存储数组</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">executeCallback</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
  });
}
</code></pre>
<ul>
<li>此时 Promise 还在 <code>pending</code>（1s 后才 resolve），无法执行回调，所以先把「回调执行逻辑」push 到 <code>onFulfilledCallbacks</code> 数组里保存；</li>
<li>这一步和「微任务队列」无关，只是「临时存档」。</li>
</ul>
<h5 data-id="heading-82">步骤2：状态确定后，执行存储的回调 → 推到微任务队列（调度）</h5>
<p>1s 后，调用 <code>resolve(100)</code>，Promise 状态变为 <code>fulfilled</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// resolve 函数中</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">FULFILLED</span>;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
<span class="hljs-comment">// 遍历执行存储数组中的回调</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>());
</code></pre>
<p>执行 <code>callback()</code> 时，会调用 <code>executeCallback</code> 函数：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">executeCallback</span> = (<span class="hljs-params">callback, data</span>) =&gt; {
  <span class="hljs-comment">// 关键：用 setTimeout 模拟微任务，把回调推到微任务队列</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(data);
    <span class="hljs-title function_">resolvePromise</span>(newPromise, result, resolve, reject);
  }, <span class="hljs-number">0</span>);
};
</code></pre>
<ul>
<li>此时才把「真正的回调执行逻辑」推到微任务队列（用 setTimeout 模拟）；</li>
<li>这一步是「调度执行时机」，保证回调异步执行，而非同步阻塞。</li>
</ul>
<h4 data-id="heading-83">三、特殊场景：Promise 已完成（非 pending）</h4>
<p>如果调用 <code>then</code> 时，Promise 已经是 <code>fulfilled</code>/<code>rejected</code>，就不会 push 到存储数组，而是<strong>直接把回调推到微任务队列</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// MyPromise 的 then 方法中</span>
<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">FULFILLED</span>) {
  <span class="hljs-comment">// 直接执行 executeCallback → 推到微任务队列</span>
  <span class="hljs-title function_">executeCallback</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
}
</code></pre>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Promise 立即 resolve（状态为 fulfilled）</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>));
<span class="hljs-comment">// 调用 then 时，状态已确定，直接把回调推到微任务队列</span>
p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
</code></pre>
<h4 data-id="heading-84">四、关键区别：用生活例子类比</h4>
<p>把 Promise 比作「奶茶店」：</p>
<ul>
<li><strong>push 回调到数组</strong>：你点单时，奶茶还没做好（pending），店员把你的「取餐需求」（回调）记在小本本（存储数组）上，避免漏单；</li>
<li><strong>推到微任务队列</strong>：奶茶做好了（fulfilled），店员喊你取餐，但店里规定「先做完所有即时单（同步代码），再叫号取餐（微任务）」—— 把你的「取餐动作」排到微任务队列，按顺序执行；</li>
<li>若你到店时，奶茶已经做好了（非 pending）：店员直接把你的「取餐动作」排到微任务队列，不用记小本本。</li>
</ul>
<h4 data-id="heading-85">五、总结</h4>
<ol>
<li><strong>不是一回事</strong>：
<ul>
<li><code>push 回调到数组</code>：是「存储行为」，解决 pending 状态下回调的保存问题，和执行时机无关；</li>
<li><code>推到微任务队列</code>：是「调度行为」，解决回调的异步执行时机问题，保证符合 Promise 规范；</li>
</ul>
</li>
<li><strong>关联关系</strong>：
<ul>
<li>若 Promise 是 pending → 先 push 到存储数组，状态确定后，再从数组取出回调，推到微任务队列执行；</li>
<li>若 Promise 已完成 → 跳过存储数组，直接把回调推到微任务队列；</li>
</ul>
</li>
<li><strong>核心目的</strong>：
<ul>
<li>存储数组：保证回调不丢失；</li>
<li>微任务队列：保证回调异步执行，且执行顺序符合规范（微任务优先级 &gt; 宏任务）。</li>
</ul>
</li>
</ol>
<p>记住一句话就能分清：<strong>先存（push 数组），后调（微任务队列）</strong> —— 存储是为了不丢，微任务是为了异步。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[| ES6 | 异步 | 闭包 | 原型链 | DOM操作 | 事件处理 |]]></title>    <link>https://juejin.cn/post/7595890117866045486</link>    <guid>https://juejin.cn/post/7595890117866045486</guid>    <pubDate>2026-01-17T14:07:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595890117866045486" data-draft-id="7595808703074992154" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="| ES6 | 异步 | 闭包 | 原型链  | DOM操作 | 事件处理 |"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-01-17T14:07:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="千寻girling"/> <meta itemprop="url" content="https://juejin.cn/user/2276467567770442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            | ES6 | 异步 | 闭包 | 原型链  | DOM操作 | 事件处理 |
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2276467567770442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    千寻girling
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:07:20.000Z" title="Sat Jan 17 2026 14:07:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{margin-bottom:5px;font-size:30px;font-weight:500}.markdown-body h1:before{content:"#";margin-right:10px;color:#1976d2}.markdown-body h2{font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out}.markdown-body h2:hover{border-color:#1976d2}.markdown-body h3{font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0}.markdown-body h4{font-size:20px;font-weight:500}.markdown-body h5{font-size:16px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter{text-transform:capitalize}.markdown-body em{text-emphasis:dot;text-emphasis-position:under}.markdown-body img{display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important}.markdown-body hr{position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center}.markdown-body code{font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:0 4px}.markdown-body pre&gt;code{font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent}.markdown-body a:after{content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat}.markdown-body a:hover{border-color:#027fff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after{display:none!important}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6}.markdown-body table img{box-shadow:none!important}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body del{color:rgba(0,0,0,.6)}.markdown-body blockquote{position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out}.markdown-body blockquote:hover{border-color:#1976d2}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6}.markdown-body blockquote:before{content:"“";top:4px;left:6px}.markdown-body blockquote:after{content:"”";right:8px;bottom:-8px}.markdown-body blockquote&gt;p,.markdown-body blockquote blockquote{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body details{outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary:hover::-webkit-details-marker{color:#1976d2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="an-old-hope">.hljs-comment,.hljs-quote{color:#b6b18b}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#eb3c54}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#e7ce56}.hljs-attribute{color:#ee7c2b}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#4fb4d7}.hljs-section,.hljs-title{color:#78bb65}.hljs-keyword,.hljs-selector-tag{color:#b45ea4}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#1c1d21;color:#c0c5ce}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、ES6+ 新特性</h2>
<p>ES6（ECMAScript 2015）及后续的 ES7-ES14 被统称为 ES6+，是 JavaScript 语言的重大升级，解决了 ES5 时代的语法冗余、作用域混乱、功能缺失等问题，大幅提升了代码的可读性、可维护性和开发效率。</p>
<h3 data-id="heading-1">1. 块级作用域与变量声明</h3>
<p>ES5 中只有全局作用域和函数作用域，<code>var</code> 声明的变量存在 “变量提升” 和 “作用域穿透” 问题，极易引发 bug。ES6 新增 <code>let</code> 和 <code>const</code> 关键字，引入块级作用域（<code>{}</code> 包裹的区域）：</p>
<ul>
<li><code>let</code>：声明可变变量，仅在当前块级作用域有效，无变量提升，不允许重复声明；</li>
<li><code>const</code>：声明常量，一旦赋值不可修改（引用类型仅保证地址不变），同样遵循块级作用域规则。示例：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ES5 问题：变量提升+作用域穿透</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 10（全局作用域可访问）</span>

<span class="hljs-comment">// ES6 解决</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;
  <span class="hljs-keyword">const</span> c = <span class="hljs-number">30</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// ReferenceError: b is not defined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// ReferenceError: c is not defined</span>
</code></pre>
<h3 data-id="heading-2">2. 箭头函数</h3>
<p>简化函数声明语法，核心特性：</p>
<ul>
<li>语法简洁：单参数可省略括号，单返回语句可省略大括号和 <code>return</code>；</li>
<li>无独立 <code>this</code>：箭头函数的 <code>this</code> 继承自外层作用域，解决了 ES5 中 <code>this</code> 指向混乱的问题（如回调函数中 <code>this</code> 丢失）；</li>
<li>不能作为构造函数：无法使用 <code>new</code> 调用，无 <code>arguments</code> 对象（可改用剩余参数）。示例：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ES5 函数</span>
<span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
};

<span class="hljs-comment">// ES6 箭头函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;

<span class="hljs-comment">// this 指向示例</span>
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
  <span class="hljs-attr">fn1</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// undefined（this 指向全局）</span>
    }, <span class="hljs-number">100</span>);
  },
  <span class="hljs-attr">fn2</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 张三（this 继承自 fn2 的作用域）</span>
    }, <span class="hljs-number">100</span>);
  }
};
obj.<span class="hljs-title function_">fn1</span>();
obj.<span class="hljs-title function_">fn2</span>();
</code></pre>
<h3 data-id="heading-3">3. 解构赋值</h3>
<p>允许从数组 / 对象中提取值，赋值给变量，简化数据提取逻辑：</p>
<ul>
<li>数组解构：按索引匹配，支持默认值；</li>
<li>对象解构：按属性名匹配，支持重命名和默认值。示例：</li>
</ul>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 数组解构</span>
<span class="hljs-type">const</span> [a, b, c = <span class="hljs-number">30</span>] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>];
console.<span class="hljs-built_in">log</span>(a, b, c); <span class="hljs-comment">// 10 20 30</span>

<span class="hljs-comment">// 对象解构</span>
<span class="hljs-type">const</span> { name: userName, age = <span class="hljs-number">18</span> } = { name: <span class="hljs-string">"李四"</span> };
console.<span class="hljs-built_in">log</span>(userName, age); <span class="hljs-comment">// 李四 18</span>
</code></pre>
<h3 data-id="heading-4">4. 扩展运算符与剩余参数</h3>
<ul>
<li>扩展运算符（<code>...</code>）：将数组 / 对象展开为单个元素，用于合并数据、传递参数；</li>
<li>剩余参数（<code>...</code>）：收集剩余的参数，转为数组，替代 <code>arguments</code>。示例：</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">// 扩展运算符
const <span class="hljs-attr">arr1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">;</span>
const <span class="hljs-attr">arr2</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<span class="hljs-comment">;</span>
const <span class="hljs-attr">arr3</span> = [...arr1, ...arr2]<span class="hljs-comment">; // [1,2,3,4,5,6]</span>

const <span class="hljs-attr">obj1</span> = { a: <span class="hljs-number">1</span> }<span class="hljs-comment">;</span>
const <span class="hljs-attr">obj2</span> = { b: <span class="hljs-number">2</span> }<span class="hljs-comment">;</span>
const <span class="hljs-attr">obj3</span> = { ...obj1, ...obj2 }<span class="hljs-comment">; // {a:1, b:2}</span>

// 剩余参数
const <span class="hljs-attr">sum</span> = (...args) =&gt; args.reduce((total, cur) =&gt; total + cur, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
console.log(sum(1,2,3))<span class="hljs-comment">; // 6</span>
</code></pre>
<h3 data-id="heading-5">5. 模板字符串</h3>
<p>用反引号（<code>）包裹字符串，支持换行和变量插值（</code>${变量}`），解决 ES5 字符串拼接繁琐的问题：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">name</span> = <span class="hljs-string">"王五"</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">age</span> = <span class="hljs-number">20</span><span class="hljs-comment">;</span>
// ES5 拼接
const <span class="hljs-attr">str1</span> = <span class="hljs-string">"姓名："</span> + name + <span class="hljs-string">"，年龄："</span> + age + <span class="hljs-string">"岁"</span><span class="hljs-comment">;</span>
// ES6 模板字符串
const <span class="hljs-attr">str2</span> = `姓名：<span class="hljs-variable">${name}</span>，年龄：<span class="hljs-variable">${age}</span>岁`<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-6">6. 其他核心特性</h3>
<ul>
<li><code>Set/Map</code> 数据结构：<code>Set</code> 用于存储唯一值（数组去重），<code>Map</code> 键值对集合（键可为任意类型，替代对象）；</li>
<li><code>Class</code> 类：语法糖，简化原型链继承，提供 <code>constructor</code>、<code>extends</code>、<code>super</code> 等关键字；</li>
<li>模块化（<code>import/export</code>）：替代 CommonJS/AMD，实现按需加载，提升代码模块化程度；</li>
<li>可选链（<code>?.</code>）、空值合并（<code>??</code>）：ES2020 特性，简化空值判断，避免 <code>Cannot read property 'xxx' of undefined</code> 错误。</li>
</ul>
<p>ES6+ 新特性的核心价值在于 “语法简化” 和 “功能补全”，让 JavaScript 从 “脚本语言” 向 “工程化语言” 迈进，是现代前端开发（React/Vue/TypeScript）的基础。</p>
<h2 data-id="heading-7">二、异步（Promise, async/await）</h2>
<p>JavaScript 是单线程语言，默认同步执行代码，但网络请求、定时器、文件操作等场景需要异步处理，否则会阻塞主线程。异步编程经历了 “回调函数 → Promise → async/await” 的演进，核心目标是解决 “回调地狱”，让异步代码更易读、易维护。</p>
<h3 data-id="heading-8">1. 异步编程的核心问题：回调地狱</h3>
<p>ES5 中异步操作依赖回调函数，多个异步嵌套时会出现 “回调地狱”（代码层级深、可读性差、错误处理繁琐）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 回调地狱：获取用户信息 → 获取用户订单 → 获取订单详情</span>
$.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/user"</span>, <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {
  $.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/order?userId=<span class="hljs-subst">${user.id}</span>`</span>, <span class="hljs-function">(<span class="hljs-params">order</span>) =&gt;</span> {
    $.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/orderDetail?orderId=<span class="hljs-subst">${order.id}</span>`</span>, <span class="hljs-function">(<span class="hljs-params">detail</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(detail);
    }, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"获取订单详情失败"</span>, err);
    });
  }, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"获取订单失败"</span>, err);
  });
}, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"获取用户失败"</span>, err);
});
</code></pre>
<p>问题：层级嵌套过深，错误处理分散，代码难以调试和维护。</p>
<h3 data-id="heading-9">2. Promise：异步操作的标准化封装</h3>
<p>Promise 是 ES6 引入的异步编程解决方案，本质是一个对象，代表异步操作的 “未完成 / 成功 / 失败” 状态，核心特性：</p>
<ul>
<li>三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败），状态一旦改变不可逆转；</li>
<li>两个回调：<code>then()</code> 处理成功结果，<code>catch()</code> 处理失败结果，支持链式调用；</li>
<li>解决回调地狱：通过链式调用替代嵌套，错误可统一捕获。</li>
</ul>
<h4 data-id="heading-10">（1）Promise 基本用法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建 Promise 对象</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getPromise</span> = (<span class="hljs-params">url</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">"GET"</span>, url);
    xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
        <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)); <span class="hljs-comment">// 成功：调用 resolve</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(xhr.<span class="hljs-property">statusText</span>)); <span class="hljs-comment">// 失败：调用 reject</span>
      }
    };
    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"网络请求失败"</span>));
    };
    xhr.<span class="hljs-title function_">send</span>();
  });
};

<span class="hljs-comment">// 链式调用：解决回调地狱</span>
<span class="hljs-title function_">getPromise</span>(<span class="hljs-string">"/api/user"</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> <span class="hljs-title function_">getPromise</span>(<span class="hljs-string">`/api/order?userId=<span class="hljs-subst">${user.id}</span>`</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">order</span>) =&gt;</span> <span class="hljs-title function_">getPromise</span>(<span class="hljs-string">`/api/orderDetail?orderId=<span class="hljs-subst">${order.id}</span>`</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">detail</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(detail))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"请求失败"</span>, err)); <span class="hljs-comment">// 统一捕获所有错误</span>
</code></pre>
<h4 data-id="heading-11">（2）Promise 常用方法</h4>
<ul>
<li><code>Promise.all()</code>：接收多个 Promise 数组，全部成功才返回结果数组，一个失败则立即失败；</li>
<li><code>Promise.race()</code>：接收多个 Promise 数组，返回第一个完成的 Promise 结果（无论成功 / 失败）；</li>
<li><code>Promise.resolve()</code>/<code>Promise.reject()</code>：快速创建成功 / 失败的 Promise 对象；</li>
<li><code>Promise.allSettled()</code>：等待所有 Promise 完成（无论成功 / 失败），返回所有结果（包含状态和值）。</li>
</ul>
<p>示例（Promise.all）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 同时请求多个接口，全部完成后处理</span>
<span class="hljs-keyword">const</span> promise1 = <span class="hljs-title function_">getPromise</span>(<span class="hljs-string">"/api/user"</span>);
<span class="hljs-keyword">const</span> promise2 = <span class="hljs-title function_">getPromise</span>(<span class="hljs-string">"/api/goods"</span>);
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2])
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">[user, goods]</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"用户信息"</span>, user);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"商品信息"</span>, goods);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"某个请求失败"</span>, err));
</code></pre>
<h3 data-id="heading-12">3. async/await：异步代码同步化</h3>
<p>ES2017 引入的 <code>async/await</code> 是 Promise 的语法糖，允许用 “同步代码的写法” 处理异步操作，核心规则：</p>
<ul>
<li><code>async</code> 修饰函数：使函数返回一个 Promise 对象；</li>
<li><code>await</code> 修饰 Promise：暂停函数执行，直到 Promise 状态变为成功，返回结果；若 Promise 失败，需用 <code>try/catch</code> 捕获错误。</li>
</ul>
<h4 data-id="heading-13">（1）基本用法（解决回调地狱的终极方案）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 封装异步请求函数（返回 Promise）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUser</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-title function_">getPromise</span>(<span class="hljs-string">"/api/user"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getOrder</span> = (<span class="hljs-params">userId</span>) =&gt; <span class="hljs-title function_">getPromise</span>(<span class="hljs-string">`/api/order?userId=<span class="hljs-subst">${userId}</span>`</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getOrderDetail</span> = (<span class="hljs-params">orderId</span>) =&gt; <span class="hljs-title function_">getPromise</span>(<span class="hljs-string">`/api/orderDetail?orderId=<span class="hljs-subst">${orderId}</span>`</span>);

<span class="hljs-comment">// async/await 写法：同步风格的异步代码</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getOrderInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUser</span>(); <span class="hljs-comment">// 等待 getUser 完成</span>
    <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOrder</span>(user.<span class="hljs-property">id</span>); <span class="hljs-comment">// 等待 getOrder 完成</span>
    <span class="hljs-keyword">const</span> detail = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOrderDetail</span>(order.<span class="hljs-property">id</span>); <span class="hljs-comment">// 等待 getOrderDetail 完成</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(detail);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"请求失败"</span>, err); <span class="hljs-comment">// 统一捕获所有错误</span>
  }
};

<span class="hljs-title function_">getOrderInfo</span>();
</code></pre>
<h4 data-id="heading-14">（2）async/await 优势</h4>
<ul>
<li>代码扁平化：无嵌套，可读性接近同步代码；</li>
<li>错误处理统一：通过 <code>try/catch</code> 捕获所有异步错误，替代 Promise 的 <code>catch()</code>；</li>
<li>调试友好：可在 <code>await</code> 处打断点，调试流程与同步代码一致。</li>
</ul>
<h3 data-id="heading-15">4. 异步编程的核心原则</h3>
<ul>
<li>避免同步阻塞：异步操作始终不阻塞主线程（如定时器、网络请求由浏览器内核的线程处理）；</li>
<li>错误处理全覆盖：Promise 需加 <code>catch()</code>，async/await 需包 <code>try/catch</code>，避免未捕获的异步错误；</li>
<li>并行处理优化：多个无依赖的异步操作，用 <code>Promise.all()</code> 替代串行 <code>await</code>，提升执行效率。</li>
</ul>
<p>异步编程是前端开发的核心难点，Promise 解决了 “回调地狱” 的结构问题，async/await 则让异步代码的可读性达到了同步代码的水平，是现代前端处理网络请求、异步数据加载的标配。</p>
<h2 data-id="heading-16">三、闭包和原型链</h2>
<p>闭包和原型链是 JavaScript 的两大核心特性，也是面试高频考点。闭包关乎作用域和变量生命周期，原型链则是 JavaScript 实现继承的底层机制，理解这两个概念能帮你突破 “语法使用” 到 “原理理解” 的瓶颈。</p>
<h3 data-id="heading-17">1. 闭包（Closure）</h3>
<h4 data-id="heading-18">（1）闭包的定义</h4>
<p>闭包是指 “有权访问另一个函数作用域中变量的函数”，本质是函数作用域链的保留：当内部函数被外部引用时，其所在的作用域不会被垃圾回收机制销毁，从而可以持续访问外层函数的变量。</p>
<h4 data-id="heading-19">（2）闭包的形成条件</h4>
<ol>
<li>存在嵌套函数（内部函数 + 外部函数）；</li>
<li>内部函数引用外部函数的变量 / 参数；</li>
<li>外部函数执行后，内部函数被外部环境引用（如返回、赋值给全局变量）。</li>
</ol>
<h4 data-id="heading-20">（3）基本用法与示例</h4>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 基础闭包：外部函数执行后，内部函数仍能访问其变量</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"/>) </span>{
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">num</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 外部函数的变量</span>
  <span class="hljs-comment">// 内部函数引用外部变量</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"/>) </span>{
    console.<span class="hljs-title function_ invoke__">log</span>(num);
  }
  <span class="hljs-keyword">return</span> inner; <span class="hljs-comment">// 返回内部函数，使其被外部引用</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fn</span> = <span class="hljs-title function_ invoke__">outer</span>(); <span class="hljs-comment">// outer 执行完毕，但其作用域未被销毁</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params"/>)</span>; <span class="hljs-comment">// 10（inner 仍能访问 num）</span>
</code></pre>
<h4 data-id="heading-21">（4）闭包的核心应用场景</h4>
<ul>
<li>
<p>封装私有变量：模拟 “私有属性 / 方法”，避免全局变量污染；</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 封装计数器：count 是私有变量，只能通过方法修改</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> count++,
    <span class="hljs-attr">decrement</span>: <span class="hljs-function">() =&gt;</span> count--,
    <span class="hljs-attr">getCount</span>: <span class="hljs-function">() =&gt;</span> count
  };
}

<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();
counter.<span class="hljs-title function_">increment</span>();
counter.<span class="hljs-title function_">increment</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()); <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">count</span>); <span class="hljs-comment">// undefined（无法直接访问）</span>
</code></pre>
</li>
<li>
<p>防抖 / 节流函数：利用闭包保存定时器 ID、上次执行时间等状态；</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 防抖函数（闭包保存 timer 变量）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) {
  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 闭包保存 timer，多次调用共享同一个 timer</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-built_in">clearTimeout</span>(timer);
    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    }, delay);
  };
}
</code></pre>
</li>
<li>
<p>柯里化函数：将多参数函数转为单参数函数，利用闭包缓存已传入的参数。</p>
</li>
</ul>
<h4 data-id="heading-22">（5）闭包的注意事项</h4>
<ul>
<li>内存泄漏风险：闭包会保留外层作用域，若长期引用未释放（如赋值给全局变量），会导致变量无法被垃圾回收，占用内存；</li>
<li>解决：使用完闭包后，手动解除引用（如 <code>fn = null</code>），让作用域可以被回收。</li>
</ul>
<h3 data-id="heading-23">2. 原型链（Prototype Chain）</h3>
<p>JavaScript 是 “基于原型的面向对象语言”，没有类（ES6 Class 是语法糖），所有对象都通过 “原型” 实现属性和方法的继承，原型链是实现继承的核心机制。</p>
<h4 data-id="heading-24">（1）核心概念</h4>
<ul>
<li>原型（<code>prototype</code>）：函数特有的属性，指向一个对象，该对象是当前函数创建的所有实例的原型；</li>
<li>隐式原型（<code>__proto__</code>）：所有对象（包括函数）都有的属性，指向其构造函数的 <code>prototype</code>；</li>
<li>原型链：当访问对象的属性 / 方法时，先在自身查找，找不到则通过 <code>__proto__</code> 向上查找，直到 <code>Object.prototype</code>，这个查找链条就是原型链。</li>
</ul>
<h4 data-id="heading-25">（2）原型链的基本结构</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-comment">// 给原型添加方法</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
};

<span class="hljs-comment">// 创建实例</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"张三"</span>);

<span class="hljs-comment">// 原型链查找：p1 → Person.prototype → Object.prototype → null</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>); <span class="hljs-comment">// 自身属性，直接返回</span>
p1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// p1 自身无 sayHello，查找 p1.__proto__（Person.prototype）找到</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// p1 和 Person.prototype 无 toString，查找 Object.prototype 找到</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">xxx</span>); <span class="hljs-comment">// 原型链末端为 null，返回 undefined</span>
</code></pre>
<h4 data-id="heading-26">（3）原型链的核心应用：继承</h4>
<p>ES5 中通过修改原型链实现继承（ES6 Class 的 <code>extends</code> 底层仍是原型链）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> 吃饭`</span>);
};

<span class="hljs-comment">// 子类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 继承父类实例属性</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
<span class="hljs-comment">// 继承父类原型方法</span>
<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 修正构造函数指向</span>

<span class="hljs-comment">// 子类添加自有方法</span>
<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> 跑步，年龄 <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span>`</span>);
};

<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">10</span>);
child.<span class="hljs-title function_">eat</span>(); <span class="hljs-comment">// 继承父类方法</span>
child.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// 子类自有方法</span>
</code></pre>
<h4 data-id="heading-27">（4）原型链的关键规则</h4>
<ul>
<li>所有对象的最终原型是 <code>Object.prototype</code>，其 <code>__proto__</code> 为 <code>null</code>；</li>
<li>函数的 <code>prototype</code> 是普通对象，<code>Function.prototype</code> 是函数（特殊）；</li>
<li>修改原型会影响所有实例（原型共享特性）。</li>
</ul>
<h3 data-id="heading-28">3. 闭包与原型链的关联</h3>
<p>闭包关注 “作用域和变量保留”，原型链关注 “对象属性继承”，二者共同构成 JavaScript 的核心底层逻辑：闭包让函数可以突破作用域限制访问变量，原型链让对象可以突破自身结构继承方法，是理解 JavaScript 设计思想的关键。</p>
<h2 data-id="heading-29">四、DOM 操作和事件处理</h2>
<p>DOM（文档对象模型）是浏览器将 HTML 文档解析成的树形结构，前端开发的核心是通过 JavaScript 操作 DOM 实现页面交互，事件处理则是响应用户操作（点击、输入、滚动等）的核心机制。</p>
<h3 data-id="heading-30">1. DOM 操作</h3>
<p>DOM 操作分为 “查找节点”“创建 / 插入节点”“修改节点”“删除节点” 四类，核心是操作 DOM 树的节点（元素节点、文本节点、属性节点）。</p>
<h4 data-id="heading-31">（1）查找 DOM 节点（核心）</h4>
<p>查找是 DOM 操作的第一步，常用方法：</p>
<ul>
<li>按 ID 查找：<code>document.getElementById("id")</code> → 返回单个元素（效率最高）；</li>
<li>按类名查找：<code>document.getElementsByClassName("className")</code> → 返回 HTMLCollection（动态集合）；</li>
<li>按标签名查找：<code>document.getElementsByTagName("tagName")</code> → 返回 HTMLCollection；</li>
<li>按选择器查找：<code>document.querySelector("selector")</code>（返回第一个匹配元素）、<code>document.querySelectorAll("selector")</code>（返回 NodeList，静态集合）→ 最灵活，支持 CSS 选择器。</li>
</ul>
<p>示例：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 按 ID 查找</span>
<span class="hljs-keyword">const</span> box = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"box"</span>);

<span class="hljs-comment">// 按选择器查找</span>
<span class="hljs-keyword">const</span> item = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">".list .item"</span>);
<span class="hljs-keyword">const</span> items = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">".list .item"</span>); <span class="hljs-comment">// NodeList 可通过 forEach 遍历</span>
</code></pre>
<h4 data-id="heading-32">（2）创建与插入节点</h4>
<p>动态生成页面内容的核心，常用方法：</p>
<ul>
<li>
<p>创建元素：<code>document.createElement("tagName")</code>；</p>
</li>
<li>
<p>创建文本节点：<code>document.createTextNode("text")</code>；</p>
</li>
<li>
<p>插入节点：</p>
<ul>
<li><code>parent.appendChild(child)</code>：将子节点插入父节点末尾；</li>
<li><code>parent.insertBefore(newNode, referenceNode)</code>：将新节点插入参考节点之前；</li>
<li><code>element.innerHTML</code>：直接通过 HTML 字符串插入节点（简洁但有 XSS 风险）。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="hljs language-ini" lang="ini">// 创建元素并插入
const <span class="hljs-attr">ul</span> = document.querySelector(<span class="hljs-string">"ul"</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">li</span> = document.createElement(<span class="hljs-string">"li"</span>)<span class="hljs-comment">;</span>
<span class="hljs-attr">li.textContent</span> = <span class="hljs-string">"新列表项"</span><span class="hljs-comment">; // 设置文本内容（安全，无 XSS）</span>
ul.appendChild(li)<span class="hljs-comment">;</span>

// innerHTML 方式（慎用，避免用户输入内容）
ul.innerHTML += "&lt;li&gt;新列表项&lt;/li&gt;"<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-33">（3）修改 DOM 节点</h4>
<ul>
<li>
<p>修改属性：<code>element.setAttribute("attr", "value")</code>（设置属性）、<code>element.getAttribute("attr")</code>（获取属性）、<code>element.removeAttribute("attr")</code>（移除属性）；</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">"img"</span>);
img.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">"src"</span>, <span class="hljs-string">"new.jpg"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(img.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">"src"</span>)); <span class="hljs-comment">// new.jpg</span>
</code></pre>
</li>
<li>
<p>修改样式：</p>
<ul>
<li>行内样式：<code>element.style.cssProperty = "value"</code>（驼峰命名，如 <code>backgroundColor</code>）；</li>
<li>类名样式：<code>element.classList.add("className")</code>、<code>element.classList.remove("className")</code>、<code>element.classList.toggle("className")</code>（推荐，分离样式和逻辑）。</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">div</span> = document.querySelector(<span class="hljs-string">".box"</span>)<span class="hljs-comment">;</span>
<span class="hljs-attr">div.style.width</span> = <span class="hljs-string">"200px"</span><span class="hljs-comment">;</span>
div.classList.add("active")<span class="hljs-comment">; // 添加类名</span>
div.classList.toggle("show")<span class="hljs-comment">; // 切换类名</span>
</code></pre>
</li>
<li>
<p>修改文本 / HTML：<code>element.textContent</code>（纯文本，安全）、<code>element.innerHTML</code>（HTML 字符串，有 XSS 风险）。</p>
</li>
</ul>
<h4 data-id="heading-34">（4）删除 DOM 节点</h4>
<ul>
<li><code>parent.removeChild(child)</code>：父节点移除子节点；</li>
<li><code>element.remove()</code>：元素自身移除（ES6+ 方法，更简洁）。</li>
</ul>
<p>示例：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">li</span> = <span class="hljs-selector-tag">document</span><span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">"li"</span>);
<span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.parentElement</span><span class="hljs-selector-class">.removeChild</span>(li); <span class="hljs-comment">// 传统方式</span>
<span class="hljs-comment">// 或</span>
<span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.remove</span>(); <span class="hljs-comment">// 简洁方式</span>
</code></pre>
<h4 data-id="heading-35">（5）DOM 操作的性能优化</h4>
<p>DOM 操作是 “重操作”，频繁修改会触发浏览器重排（Reflow）/ 重绘（Repaint），导致页面卡顿，优化手段：</p>
<ul>
<li>
<p>批量操作：先将节点脱离文档流（如隐藏父节点），操作完成后再恢复；</p>
</li>
<li>
<p>使用文档碎片：<code>document.createDocumentFragment()</code>，批量插入节点仅触发一次重排；</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">fragment</span> = document.createDocumentFragment()<span class="hljs-comment">;</span>
for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 1000; i++) {</span>
  const <span class="hljs-attr">li</span> = document.createElement(<span class="hljs-string">"li"</span>)<span class="hljs-comment">;</span>
  <span class="hljs-attr">li.textContent</span> = `项 <span class="hljs-variable">${i}</span>`<span class="hljs-comment">;</span>
  fragment.appendChild(li)<span class="hljs-comment">; // 先插入碎片，无重排</span>
}
document.querySelector("ul").appendChild(fragment)<span class="hljs-comment">; // 仅一次重排</span>
</code></pre>
</li>
<li>
<p>避免频繁查询 DOM：将查询结果缓存到变量，减少 DOM 遍历。</p>
</li>
</ul>
<h3 data-id="heading-36">2. 事件处理</h3>
<p>事件是浏览器触发的 “信号”（如点击、输入、加载），事件处理是 JavaScript 响应用户操作的核心，分为 “事件绑定”“事件流”“事件对象”“事件优化” 四部分。</p>
<h4 data-id="heading-37">（1）事件绑定方式</h4>
<ul>
<li>
<p>行内绑定（不推荐）：<code>&lt;button onclick="handleClick()"&gt;点击&lt;/button&gt;</code> → 耦合度高，不利于维护；</p>
</li>
<li>
<p>DOM0 级绑定：<code>element.onclick = function() {}</code> → 简单，但一个事件只能绑定一个处理函数；</p>
</li>
<li>
<p>DOM2 级绑定：<code>element.addEventListener("eventName", handler, useCapture)</code> → 推荐，支持绑定多个处理函数，可控制事件阶段；</p>
</li>
</ul>
<blockquote>
<ul>
<li>
<p><strong>DOM0 级</strong>：浏览器原生支持，无官方规范 → <code>element.onclick = function() {}</code></p>
</li>
<li>
<p><strong>DOM1 级</strong>：仅规范 DOM 结构，未新增事件绑定方式 → 无事件相关内容</p>
</li>
<li>
<p><strong>DOM2 级</strong>：W3C 发布标准，新增 <code>addEventListener</code> → 支持多绑定、事件阶段</p>
</li>
<li>
<p><strong>DOM3 级</strong>：在 DOM2 基础上新增了更多事件类型（如键盘、鼠标滚轮事件）</p>
</li>
</ul>
</blockquote>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">"button"</span>);
<span class="hljs-comment">// DOM0 级</span>
btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"点击1"</span>);
};
btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"点击2"</span>); <span class="hljs-comment">// 覆盖上一个处理函数</span>
};

<span class="hljs-comment">// DOM2 级</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"点击1"</span>);
btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, handleClick);
btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"点击2"</span>)); <span class="hljs-comment">// 可绑定多个</span>
btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"click"</span>, handleClick); <span class="hljs-comment">// 可移除</span>
</code></pre>
<h4 data-id="heading-38">（2）事件流（事件传播机制）</h4>
<p>事件流分为三个阶段：</p>
<ol>
<li>捕获阶段：事件从 <code>document</code> 向下传播到目标元素；</li>
<li>目标阶段：事件到达目标元素；</li>
<li>冒泡阶段：事件从目标元素向上传播到 <code>document</code>。</li>
</ol>
<p><code>addEventListener</code> 的第三个参数 <code>useCapture</code>：<code>true</code> 表示在捕获阶段触发，<code>false</code>（默认）表示在冒泡阶段触发。</p>
<h4 data-id="heading-39">（3）事件对象（Event）</h4>
<p>事件处理函数的第一个参数是事件对象，包含事件的核心信息：</p>
<ul>
<li><code>event.target</code>：触发事件的原始元素（事件源）；</li>
<li><code>event.currentTarget</code>：绑定事件的元素；</li>
<li><code>event.preventDefault()</code>：阻止默认行为（如表单提交、链接跳转）；</li>
<li><code>event.stopPropagation()</code>：阻止事件传播（冒泡 / 捕获）；</li>
<li><code>event.stopImmediatePropagation()</code>：阻止事件传播，且阻止当前元素后续的事件处理函数执行。</li>
</ul>
<p>示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 阻止链接跳转</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">"a"</span>);
a.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止默认跳转</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"点击链接，不跳转"</span>);
});

<span class="hljs-comment">// 事件委托（利用事件冒泡）</span>
<span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">"ul"</span>);
ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">"LI"</span>) { <span class="hljs-comment">// 判断点击的是 li 元素</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"点击了列表项"</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);
  }
});
</code></pre>
<h4 data-id="heading-40">（4）核心优化：事件委托</h4>
<p>利用事件冒泡，将子元素的事件绑定到父元素，减少事件绑定数量，优化性能（尤其适合动态生成的元素）：</p>
<pre><code class="hljs language-ini" lang="ini">// 动态生成的 li 无需单独绑定事件，父元素 ul 委托处理
const <span class="hljs-attr">ul</span> = document.querySelector(<span class="hljs-string">"ul"</span>)<span class="hljs-comment">;</span>
ul.addEventListener("click", (e) =&gt; {
  if (e.target.classList.contains("item")) {
    console.log("点击了动态生成的列表项")<span class="hljs-comment">;</span>
  }
})<span class="hljs-comment">;</span>

// 动态添加 li
const <span class="hljs-attr">li</span> = document.createElement(<span class="hljs-string">"li"</span>)<span class="hljs-comment">;</span>
li.classList.add("item")<span class="hljs-comment">;</span>
<span class="hljs-attr">li.textContent</span> = <span class="hljs-string">"动态项"</span><span class="hljs-comment">;</span>
ul.appendChild(li)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-41">（5）常见事件类型</h4>
<ul>
<li>鼠标事件：<code>click</code>、<code>dblclick</code>、<code>mouseover</code>、<code>mouseout</code>、<code>mousedown</code>、<code>mouseup</code>；</li>
<li>键盘事件：<code>keydown</code>、<code>keyup</code>、<code>keypress</code>；</li>
<li>表单事件：<code>input</code>、<code>change</code>、<code>submit</code>、<code>focus</code>、<code>blur</code>；</li>
<li>页面事件：<code>load</code>、<code>DOMContentLoaded</code>（DOM 解析完成）、<code>scroll</code>、<code>resize</code>。</li>
</ul>
<p>DOM 操作和事件处理是前端交互的基础，核心原则是 “减少 DOM 操作次数”“合理利用事件机制”，既保证交互的流畅性，又避免性能问题。</p>
<h2 data-id="heading-42">总结</h2>
<ol>
<li>ES6+ 新特性核心是简化语法、补全功能，是现代前端开发的基础，重点掌握块级作用域、箭头函数、解构、async/await 等高频用法；</li>
<li>异步编程从回调地狱演进到 Promise/async/await，核心是让异步代码更易读、易维护，async/await 是当前最优写法；</li>
<li>闭包是作用域链的保留，用于封装私有变量、实现防抖节流，需注意内存泄漏；原型链是 JS 继承的底层机制，所有对象通过 <code>__proto__</code> 形成继承链条；</li>
<li>DOM 操作需注重性能（批量操作、文档碎片），事件处理核心是事件委托，利用冒泡减少绑定数量，提升页面性能。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS -彻底搞懂 call、apply、bind 的区别与应用]]></title>    <link>https://juejin.cn/post/7595878718172217380</link>    <guid>https://juejin.cn/post/7595878718172217380</guid>    <pubDate>2026-01-17T14:13:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595878718172217380" data-draft-id="7595878718172168228" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS -彻底搞懂 call、apply、bind 的区别与应用"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-17T14:13:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS -彻底搞懂 call、apply、bind 的区别与应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:13:04.000Z" title="Sat Jan 17 2026 14:13:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在 JavaScript 中，<code>this</code> 的指向是动态的，这虽然灵活，但也常让我们头疼。而 <code>call</code>、<code>apply</code> 和 <code>bind</code> 就是我们手中的“魔法棒”，专门用来<strong>手动控制 this 的指向</strong>。它们有什么区别？分别在什么场景下使用？本文带你一探究竟。</p>
<h2 data-id="heading-1">一、 三大方法详解</h2>
<p>这三个方法都挂载在 <code>Function.prototype</code> 上，这意味着所有的函数都可以调用它们。</p>
<h3 data-id="heading-2">1. call()</h3>
<ul>
<li>
<p><strong>作用</strong>：修改函数的 <code>this</code> 指向，并<strong>立即执行</strong>该函数。</p>
</li>
<li>
<p><strong>参数</strong>：</p>
<ol>
<li><code>thisArg</code>：<code>this</code> 需要绑定的对象。</li>
<li><code>arg1, arg2, ...</code>：<strong>参数列表</strong>，直接按顺序传入。</li>
</ol>
</li>
<li>
<p><strong>默认行为</strong>：如果不传 <code>thisArg</code> 或传 <code>null</code>/<code>undefined</code>，在非严格模式下指向 <code>window</code>。</p>
</li>
</ul>
<pre><code class="hljs language-js" lang="js">fn.<span class="hljs-title function_">call</span>(obj, agr1,agr2,arg3,arg4,.....)
</code></pre>
<h3 data-id="heading-3">2. apply()</h3>
<ul>
<li>
<p><strong>作用</strong>：修改函数的 <code>this</code> 指向，并<strong>立即执行</strong>该函数。</p>
</li>
<li>
<p><strong>参数</strong>：</p>
<ol>
<li><code>thisArg</code>：<code>this</code> 需要绑定的对象。</li>
<li><code>argsArray</code>：<strong>数组（或类数组）</strong> ，数组内的元素会被展开传入函数。</li>
</ol>
</li>
</ul>
<pre><code class="hljs language-js" lang="js">fn.<span class="hljs-title function_">apply</span>(obj, [agr1,agr2,arg3,arg4,.....])
</code></pre>
<h3 data-id="heading-4">3. bind()</h3>
<ul>
<li><strong>作用</strong>：修改函数的 <code>this</code> 指向，但<strong>不会立即执行</strong>。</li>
<li><strong>返回值</strong>：返回一个新的函数（称为绑定函数）。</li>
<li><strong>硬绑定</strong>：<code>bind</code> 返回的新函数，其 <code>this</code> 指向一旦被绑定，后续再使用 <code>call</code> 或 <code>apply</code> 都无法再次修改。</li>
<li><strong>参数</strong>：与 <code>call</code> 相同，接受参数列表。支持<strong>柯里化</strong>（预设部分参数）。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">bind</span>(thisArg, arg1, arg2, arg3, ...)
</code></pre>
<h2 data-id="heading-5">二、 核心区别对比（一张表看懂）</h2>

































<table><thead><tr><th><strong>方法</strong></th><th><strong>执行时机</strong></th><th><strong>参数格式</strong></th><th><strong>返回值</strong></th><th><strong>核心场景</strong></th></tr></thead><tbody><tr><td><strong>call</strong></td><td><strong>立即执行</strong></td><td>参数列表 (arg1, arg2)</td><td>函数执行结果</td><td>对象继承、借用方法</td></tr><tr><td><strong>apply</strong></td><td><strong>立即执行</strong></td><td><strong>数组</strong> ([arg1, arg2])</td><td>函数执行结果</td><td>数学计算、数组合并</td></tr><tr><td><strong>bind</strong></td><td><strong>稍后执行</strong></td><td>参数列表 (arg1, arg2)</td><td><strong>新函数</strong></td><td>事件绑定、回调函数</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">三、 代码实战与纠错</h2>
<p>让我们通过一个经典的例子来看它们的具体表现。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Original'</span>,
  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, a, b);
  }
}

<span class="hljs-keyword">const</span> db = { <span class="hljs-attr">name</span>: <span class="hljs-string">'DataBase'</span> };

<span class="hljs-comment">// 1. 原始调用</span>
obj.<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); 
<span class="hljs-comment">// 输出: "Original" 1 2</span>

<span class="hljs-comment">// 2. call 调用：传参列表</span>
obj.<span class="hljs-property">fn</span>.<span class="hljs-title function_">call</span>(db, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); 
<span class="hljs-comment">// 输出: "DataBase" 3 4</span>

<span class="hljs-comment">// 3. apply 调用：传参数组</span>
obj.<span class="hljs-property">fn</span>.<span class="hljs-title function_">apply</span>(db, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]); 
<span class="hljs-comment">// 输出: "DataBase" 5 6</span>

<span class="hljs-comment">// 4. bind 调用：返回新函数，手动执行</span>
<span class="hljs-keyword">const</span> boundFn = obj.<span class="hljs-property">fn</span>.<span class="hljs-title function_">bind</span>(db, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);
<span class="hljs-title function_">boundFn</span>(); 
<span class="hljs-comment">// 输出: "DataBase" 7 8</span>

<span class="hljs-comment">// 5. bind 的连续修改无效性（面试坑点）</span>
<span class="hljs-keyword">const</span> doubleBind = obj.<span class="hljs-property">fn</span>.<span class="hljs-title function_">bind</span>(db).<span class="hljs-title function_">bind</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Error'</span> });
<span class="hljs-title function_">doubleBind</span>();
<span class="hljs-comment">// 输出: "DataBase" undefined undefined (第二次 bind 无效)</span>
</code></pre>
<hr/>
<h2 data-id="heading-7">四、 常见应用场景（面试加分项）</h2>
<p>仅仅知道语法是不够的，面试官更看重你知道怎么用。</p>
<h3 data-id="heading-8">1. 数组求最大值 (apply)</h3>
<p>利用 <code>apply</code> 接受数组参数的特性，结合 <code>Math.max</code>。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, nums); <span class="hljs-comment">// 20</span>
<span class="hljs-comment">// ES6 写法: Math.max(...nums)</span>
</code></pre>
<h3 data-id="heading-9">2. 类数组转数组 (call)</h3>
<p>利用 <code>call</code> 借用数组的 <code>slice</code> 方法。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// 变成了真数组</span>
}
</code></pre>
<h3 data-id="heading-10">3. React/Vue 中的事件绑定 (bind)</h3>
<p>防止回调函数在执行时 <code>this</code> 丢失（指向 <code>undefined</code> 或 <code>window</code>）。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
</code></pre>
<hr/>
<h2 data-id="heading-11">五、 面试模拟题</h2>
<h3 data-id="heading-12">Q1：<code>call</code> 和 <code>apply</code> 的唯一区别是什么？</h3>
<p>参考回答：</p>
<p>它们的唯一区别在于传参方式。call 需要把参数按顺序一个个传进去（参数列表），而 apply 需要把参数放在一个数组（或类数组）里传进去。助记口诀："a" for array (apply), "c" for comma (call)。</p>
<h3 data-id="heading-13">Q2：为什么 <code>bind</code> 返回的函数，再次使用 <code>call</code> 无法修改 <code>this</code>？</h3>
<p>参考回答：</p>
<p>这涉及 bind 的内部实现。bind 返回的函数内部已经通过闭包锁定了 this（通常称为硬绑定）。也就是类似 <code>return function() { return originalFn.apply(that, arguments) }</code> 的结构。无论外部怎么 call，内部的 apply 永远使用的是第一次绑定的 that。</p>
<h3 data-id="heading-14">Q3：手写一个简单的 <code>bind</code>？</h3>
<pre><code class="hljs language-JavaScript" lang="JavaScript">      <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {
        <span class="hljs-comment">// 1. 保存当前的函数（this 指向原函数）</span>
        <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;
        <span class="hljs-comment">// 2. 返回一个新的函数</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...innerArgs</span>) {
          <span class="hljs-comment">// 3. 将预设参数和新参数合并，并用 apply 执行原函数</span>
          <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args.<span class="hljs-title function_">concat</span>(innerArgs));
        };
      };
      <span class="hljs-keyword">const</span> obj = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Original"</span>,
        <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, a, b);
        },
      };
      <span class="hljs-keyword">const</span> boundFn = obj.<span class="hljs-property">fn</span>.<span class="hljs-title function_">myBind</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'DataBase'</span> }, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);
      <span class="hljs-title function_">boundFn</span>();
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 Generator 到 Async/Await：彻底搞懂 JS 异步编程的终极解决方案]]></title>    <link>https://juejin.cn/post/7595886887523565608</link>    <guid>https://juejin.cn/post/7595886887523565608</guid>    <pubDate>2026-01-17T14:24:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595886887523565608" data-draft-id="7595893785907167266" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 Generator 到 Async/Await：彻底搞懂 JS 异步编程的终极解决方案"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-17T14:24:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="NEXT06"/> <meta itemprop="url" content="https://juejin.cn/user/1176918763246011"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 Generator 到 Async/Await：彻底搞懂 JS 异步编程的终极解决方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1176918763246011/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    NEXT06
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:24:21.000Z" title="Sat Jan 17 2026 14:24:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 JavaScript 的发展长河中，异步编程一直是开发者最头疼的痛点之一。从最早的回调函数，到 Promise 的链式调用，再到如今的 Async/Await，我们一直在追求一个终极目标：<strong>用同步的思维，写异步的代码。</strong></p>
<p>今天，我们不谈枯燥的 API 文档，而是深入底层，从 Generator 原理出发，彻底搞懂为什么 Async/Await 被称为 JS 异步编程的“终极解决方案”。</p>
<h2 data-id="heading-0">一、 为什么我们需要 Async/Await？</h2>
<p>要理解一项技术，必须先理解它要解决的问题。</p>
<h3 data-id="heading-1">1. 回调地狱（Callback Hell）的梦魇</h3>
<p>在 ES6 之前，异步操作严重依赖回调函数。一旦业务逻辑复杂，比如需要串行请求 A、B、C 三个接口，代码就会变成这样：</p>
<p>JavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">getData</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) {
    <span class="hljs-title function_">getMoreData</span>(a, <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) {
        <span class="hljs-title function_">getEvenMoreData</span>(b, <span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// 著名的“金字塔”代码</span>
        });
    });
});
</code></pre>
<p>这种代码<strong>可读性差、难以调试、且错误处理极其繁琐</strong>。</p>
<h3 data-id="heading-2">2. Promise 的进步与局限</h3>
<p>Promise 的出现将回调嵌套扁平化了，它通过链式调用（.then()）解决了“金字塔”问题：</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">getData()
  .then(<span class="hljs-attr">a</span> =&gt; getMoreData(a))
  .then(<span class="hljs-attr">b</span> =&gt; getEvenMoreData(b))
  .catch(<span class="hljs-attr">err</span> =&gt; console.error(err))<span class="hljs-comment">;</span>
</code></pre>
<p>这无疑是巨大的进步。但它依然不够完美：大量的 .then 破坏了代码的语义连续性，我们依然无法像写同步代码那样直观地表达逻辑。</p>
<p><strong>我们的终极诉求是</strong>：能否让异步代码看起来就像 const a = logic(); const b = logic(a); 这样符合人类线性直觉？</p>
<p>答案就是 <strong>Async/Await</strong>。</p>
<h2 data-id="heading-3">二、 核心原理：并非魔法，而是语法糖</h2>
<p>Async/Await 并没有引入全新的底层机制，它本质上是 <strong>Generator 函数 + Promise + 自动执行器</strong> 的语法糖。</p>
<p>要理解它，必须理解 <strong>Generator（生成器）</strong>  的核心能力：<strong>暂停与恢复</strong>。</p>
<h3 data-id="heading-4">1. Generator：交出执行权</h3>
<p>Generator 函数（function*）通过 yield 关键字，可以让函数在执行过程中<strong>暂停</strong>，将 CPU 控制权交还给外部，并在未来某个时刻从断点处<strong>恢复</strong>执行。</p>
<p>JavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFn</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Start'</span>);
    <span class="hljs-comment">// 1. 函数执行到这里暂停，交出控制权，并返回 'Hello'</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello'</span>; 
    <span class="hljs-comment">// 3. 外部调用 next(val) 后，函数从这里恢复，result 接收外部传入的值</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Resumed with:'</span>, result); 
}

<span class="hljs-keyword">const</span> iterator = <span class="hljs-title function_">generatorFn</span>();
<span class="hljs-keyword">const</span> first = iterator.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 输出: Start, first.value = 'Hello'</span>
<span class="hljs-comment">// 2. 这里可以做任何异步操作...</span>
iterator.<span class="hljs-title function_">next</span>(<span class="hljs-string">'World'</span>);        <span class="hljs-comment">// 输出: Resumed with: World</span>
</code></pre>
<h3 data-id="heading-5">2. Async/Await 的实现公式</h3>
<p>如果我们将 Generator 和 Promise 结合起来，就得到了 Async/Await 的雏形：</p>
<ol>
<li><strong>暂停</strong>：遇到 await (即 yield)，函数暂停执行。</li>
<li><strong>等待</strong>：await 后面通常跟着一个 Promise（异步状态容器）。</li>
<li><strong>恢复</strong>：当 Promise 状态变为 Resolved，自动执行器调用 next(data)，将结果传回函数内部，代码继续向下执行。</li>
</ol>
<blockquote>
<p><strong>公式总结</strong>：<br/>
async function ≈ function* + 自动执行器（自动处理 yield 和 next）</p>
</blockquote>
<h2 data-id="heading-6">三、 实战：从错误示范到最佳实践</h2>
<p>基于大家提供的素材，我们来看看在浏览器和 Node.js 环境下，如何正确使用 Async/Await（包含对原始素材中错误的修正）。</p>
<h3 data-id="heading-7">场景一：浏览器端 Fetch 请求</h3>
<p>原始素材中直接 console.log(res) 是拿不到数据的，因为 fetch 返回的 Response 对象解析 JSON 也是异步的。</p>
<p><strong>最佳实践：</strong></p>
<p>Html</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// ES8 async 修饰函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'开始请求...'</span>);
        
        <span class="hljs-comment">// 1. await 等待 fetch 完成，拿到响应头</span>
        <span class="hljs-comment">// 这里的 await 相当于暂停函数，直到网络请求返回</span>
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.github.com/users/shunwuyu/repos'</span>);
        
        <span class="hljs-comment">// 2. 注意！解析 JSON 也是异步操作，必须再次 await</span>
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据获取成功:'</span>, data);
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-comment">// 同步写法的最大优势：可以直接用 try-catch 捕获异步错误</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求失败:'</span>, error);
    }
}
<span class="hljs-title function_">main</span>();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">场景二：Node.js 文件读取</h3>
<p>在现代 Node.js 中，我们常用 fs/promises。</p>
<p><strong>修正后的最佳实践：</strong></p>
<p>JavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs/promises'</span>; <span class="hljs-comment">// 引入返回 Promise 的 fs 模块</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> filePath = <span class="hljs-string">'./1.html'</span>;
    
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 像写同步代码一样读取文件</span>
        <span class="hljs-comment">// 甚至不需要回调函数，也不需要 .then</span>
        <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-string">'utf-8'</span>);
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件读取成功，长度:'</span>, html.<span class="hljs-property">length</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>) + <span class="hljs-string">'...'</span>); <span class="hljs-comment">// 打印前50个字符</span>
        
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'文件读取出错:'</span>, err);
    }
}

<span class="hljs-title function_">main</span>();
</code></pre>
<h2 data-id="heading-9">四、 总结</h2>
<p>Async/Await 的出现，标志着 JavaScript 异步编程的成熟。</p>
<ol>
<li>它利用 <strong>Generator</strong> 实现了函数的暂停与恢复。</li>
<li>它利用 <strong>Promise</strong> 封装了异步操作的状态。</li>
<li>它通过 <strong>自动执行</strong> 机制，让我们能以符合直觉的线性逻辑编写复杂的异步代码。</li>
</ol>
<p>掌握了 Async/Await，不仅仅是掌握了一个关键字，更是掌握了 JavaScript 协程控制的精髓。拒绝回调地狱，从今天开始。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS-new 操作符]]></title>    <link>https://juejin.cn/post/7596025264455712804</link>    <guid>https://juejin.cn/post/7596025264455712804</guid>    <pubDate>2026-01-17T14:26:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596025264455712804" data-draft-id="7595994039108943908" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS-new 操作符"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-17T14:26:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS-new 操作符
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:26:08.000Z" title="Sat Jan 17 2026 14:26:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在 JavaScript 面向对象编程中，<code>new</code> 关键字是实例化对象的核心。面试官常常通过“手写 new”来考察你对<strong>原型链</strong>、<strong>this 绑定</strong>以及<strong>构造函数返回值</strong>的理解。本文将带你从原理到实现，彻底搞懂 <code>new</code> 背后的魔法。</p>
<h2 data-id="heading-1">一、 <code>new</code> 到底干了什么？</h2>
<p>当我们使用 <code>new Person()</code> 时，JS 引擎在背后默默执行了以下 <strong>4 个步骤</strong>：</p>
<ol>
<li>
<p><strong>创建一个新对象</strong>：在内存中创建一个新的空对象（例如 <code>obj = {}</code>）。</p>
</li>
<li>
<p><strong>链接原型</strong>：将新对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code>，从而实现原型继承（让实例能访问原型上的方法）。</p>
</li>
<li>
<p><strong>绑定 this</strong>：将构造函数内部的 <code>this</code> 绑定到这个新对象上，并执行构造函数（为新对象添加属性）。</p>
</li>
<li>
<p><strong>返回对象</strong>：</p>
<ul>
<li>如果构造函数显式返回了一个<strong>对象</strong>（或函数），则返回该结果。</li>
<li>如果构造函数没有返回对象（返回基本类型或无返回值），则返回步骤 1 创建的<strong>新对象</strong>。</li>
</ul>
</li>
</ol>
<h2 data-id="heading-2">二、 手写 <code>myNew</code> 实现</h2>
<p>根据上述原理，我们可以实现一个自己的 <code>myNew</code> 函数。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-comment">/**
 * 手写 new 操作符
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} Constructor 构造函数
 * <span class="hljs-doctag">@param</span>  {<span class="hljs-type">...any</span>} args 传递的参数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Constructor, ...args</span>) {
  <span class="hljs-comment">// 1. 创建一个新对象，并将其原型指向构造函数的 prototype</span>
  <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);

  <span class="hljs-comment">// 2. 将构造函数的 this 绑定到新对象上，并执行构造函数</span>
  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, args);

  <span class="hljs-comment">// 3. 处理返回值逻辑 (这是面试中最容易忽视的细节！)</span>
  <span class="hljs-comment">// 如果构造函数返回的是对象(不为null)或函数，则返回该结果；否则返回新创建的 obj</span>
  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> &amp;&amp; result !== <span class="hljs-literal">null</span>) || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// 4. 返回新对象</span>
  <span class="hljs-keyword">return</span> obj;
}
</code></pre>
<h3 data-id="heading-3">测试用例：</h3>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  <span class="hljs-comment">// 情况 1: 没有返回值（默认返回 this）</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-comment">// 情况 2: 返回一个对象</span>
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">'Special Student'</span>, <span class="hljs-attr">grade</span>: <span class="hljs-number">100</span> };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">NumberObj</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;
  <span class="hljs-comment">// 情况 3: 返回一个基本类型</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;
}

<span class="hljs-comment">// 测试 1：正常情况</span>
<span class="hljs-keyword">const</span> per = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">'Ouyang'</span>, <span class="hljs-number">23</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(per); <span class="hljs-comment">// Person { name: 'Ouyang', age: 23 }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(per <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 测试 2：构造函数返回对象</span>
<span class="hljs-keyword">const</span> stu = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-string">'XiaoMing'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu); <span class="hljs-comment">// { name: 'Special Student', grade: 100 } (this 被忽略了)</span>

<span class="hljs-comment">// 测试 3：构造函数返回基本类型</span>
<span class="hljs-keyword">const</span> num = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">NumberObj</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// NumberObj { a: 1 } (返回值 123 被忽略)</span>
</code></pre>
<hr/>
<h2 data-id="heading-4">三、 深度解析：返回值陷阱</h2>
<p>这是面试中最常挖的坑。</p>
<ul>
<li>
<p><strong>场景 A</strong>：构造函数内部没有 <code>return</code>，或者 <code>return</code> 一个基本数据类型（Number, String, Boolean, null, undefined）。</p>
<ul>
<li><strong>结果</strong>：<code>new</code> 操作符会忽略这个返回值，直接返回<strong>新创建的实例对象</strong>。</li>
</ul>
</li>
<li>
<p><strong>场景 B</strong>：构造函数内部 <code>return</code> 一个引用类型（Object, Array, Function）。</p>
<ul>
<li><strong>结果</strong>：<code>new</code> 操作符会直接返回这个<strong>引用类型</strong>，新创建的实例对象会被丢弃（且 <code>this</code> 上的属性赋值也会失效）。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-5">四、 面试模拟题（挑战一下）</h2>
<h3 data-id="heading-6">Q1：<code>Object.create()</code> 和 <code>new</code> 有什么区别？</h3>
<p><strong>参考回答：</strong></p>
<ul>
<li><code>new</code>：不仅创建新对象并继承原型，还会<strong>执行构造函数</strong>，进行属性初始化。</li>
<li><code>Object.create()</code>：只负责创建一个新对象并继承原型，<strong>不会执行构造函数</strong>。</li>
</ul>
<h3 data-id="heading-7">Q2：为什么代码中建议使用 <code>Object.create</code> 而不是 <code>obj.__proto__</code>？</h3>
<p><strong>参考回答：</strong> <code>__proto__</code> 是非标准属性（虽然浏览器支持），直接修改它会破坏 JS 引擎的优化，严重影响性能。<code>Object.create()</code> 是 ES5 标准方法，更规范且性能更好。</p>
<h3 data-id="heading-8">Q3：如果构造函数返回 <code>null</code>，<code>new</code> 出来的结果是什么？</h3>
<p><strong>参考回答：</strong> 结果是<strong>新创建的实例对象</strong>。 因为 <code>typeof null === 'object'</code>，但 <code>null</code> 是个特殊值。在 <code>new</code> 的规范中，如果返回的是对象类型但值为 <code>null</code>，仍然会忽略它，返回实例对象。这就是为什么在手写代码中我们要判断 <code>result !== null</code>。</p>
<hr/>
<h3 data-id="heading-9">结语</h3>
<p>手写 <code>new</code> 是前端基础能力的试金石。理解了这 4 个步骤，你不仅能轻松应对面试，还能更深刻地理解 JavaScript 的继承机制。</p>
<p><strong>如果你觉得这篇笔记对你有帮助，欢迎点赞收藏！</strong> 🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS-深度解构JS事件循环（Event Loop）]]></title>    <link>https://juejin.cn/post/7595994039109058596</link>    <guid>https://juejin.cn/post/7595994039109058596</guid>    <pubDate>2026-01-17T14:58:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595994039109058596" data-draft-id="7595878718172233764" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS-深度解构JS事件循环（Event Loop）"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-17T14:58:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS-深度解构JS事件循环（Event Loop）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T14:58:21.000Z" title="Sat Jan 17 2026 14:58:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>为什么 JavaScript 是单线程的却能处理异步 IO？为什么 <code>setTimeout</code> 并不总是准时？本文将从宏观的执行栈、任务队列，一直深入到浏览器底层的任务调度逻辑，带你彻底看透事件循环。</p>
<h2 data-id="heading-1">一、 为什么需要事件循环？</h2>
<p>JavaScript 的核心是<strong>单线程</strong>的，这意味着它只有一个主线程来处理 DOM 解析、样式计算、脚本执行等。如果某个任务耗时过长，页面就会“卡死”。为了协调同步任务与异步任务（输入事件、网络请求、定时器），浏览器引入了<strong>事件循环</strong>系统来统一调度和处理这些任务。</p>
<hr/>
<h2 data-id="heading-2">二、 核心组件：执行栈与任务队列</h2>
<h3 data-id="heading-3">1. 执行栈 (Execution Stack)</h3>
<p>当多个方法被调用的时候，因为js是单线程的，所以每次只能执行一个方法，于是这些方法被排到了一个单独的地方，这个地方就是执行栈。执行栈里面执行的都是同步的操作。</p>
<h3 data-id="heading-4">2. 事件队列 (Task Queue)</h3>
<ul>
<li>在js执行过程中如果遇到异步事件（如 Ajax、定时器），就会首先将这个异步事件交给对应的浏览器模块（如网络进程），继续执行执行栈里面的任务。</li>
<li>当异步事件返回结果后，js不会立即执行这个回调，会将事件加入到事件队列中，只有当执行栈里面的全部执行完以后，主线程才会去查找事件队列中是否有任务。</li>
<li>如果有，那么主线程会取出事件队列里面排在最前面的事件，将这个事件对应的回调加入到执行栈中，然后执行其中的同步代码。然后在继续观察执行栈里面是否有任务，依次反复...就形成了一个无限的循环。</li>
<li>这就是这个过程被称为事件循环（Event loop）的原因。</li>
</ul>
<p><strong>循环逻辑：</strong></p>
<ol>
<li>检查执行栈是否为空。</li>
<li>若为空，从事件队列头部取出一个任务推入执行栈。</li>
<li>循环往复。</li>
</ol>
<hr/>
<h2 data-id="heading-5">三、 异步任务的“等级”：宏任务与微任务</h2>
<p>并非所有的异步任务优先级都一样。在同一次循环中，<strong>微任务永远在下一次宏任务之前执行!!!</strong></p>




















<table><thead><tr><th><strong>类型</strong></th><th><strong>包含任务</strong></th><th><strong>执行时机</strong></th></tr></thead><tbody><tr><td><strong>宏任务 (MacroTask)</strong></td><td><code>setTimeout</code>, <code>setInterval</code>, <code>ajax</code>, <code>dom事件</code></td><td>每次事件循环开始时处理一个</td></tr><tr><td><strong>微任务 (MicroTask)</strong></td><td><code>Promise.then/catch</code>, <code>MutaionObserver</code>, <code>process.nextTick</code> (Node.js)</td><td>当前执行栈清空后，立即清空整个微任务队列</td></tr></tbody></table>
<blockquote>
<p><strong>注意：</strong> <code>new Promise()</code> 构造函数内部的代码是<strong>同步</strong>执行的，只有 <code>.then()</code> 或 <code>.catch()</code> 里的回调才是微任务。（后续会专门出一篇promise相关文章）</p>
</blockquote>
<hr/>
<h2 data-id="heading-6">四、 底层揭秘：定时器是如何实现的？</h2>
<p>很多开发者认为 <code>setTimeout</code> 是直接进入消息队列的，但浏览器底层其实维护了一个<strong>延迟执行队列 (Delayed Incoming Queue)</strong> 。</p>
<h3 data-id="heading-7">1. 任务数据结构</h3>
<p>当调用 <code>setTimeout</code> 时，渲染进程内部会创建一个任务结构体：</p>
<pre><code class="hljs language-C++" lang="C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DelayTask</span>{
  int64 id;
  CallBackFunction cbf;
  <span class="hljs-type">int</span> start_time;
  <span class="hljs-type">int</span> delay_time;
};
</code></pre>
<h3 data-id="heading-8">2. 执行循环模拟</h3>
<p>浏览器的主线程循环逻辑伪代码如下：</p>
<pre><code class="hljs language-C++" lang="C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainThread</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-comment">// 1. 执行普通消息队列中的一个任务 (宏任务)</span>
    Task task = task_queue.<span class="hljs-built_in">takeTask</span>();
    <span class="hljs-built_in">ProcessTask</span>(task);
    
    <span class="hljs-comment">// 2. 执行微任务队列 (本阶段由 JS 引擎控制)</span>
    <span class="hljs-comment">// ProcessMicrotasks(); </span>

    <span class="hljs-comment">// 3. 执行延迟队列中到期的任务 (定时器任务在此处理)</span>
    <span class="hljs-built_in">ProcessDelayTask</span>();

    <span class="hljs-keyword">if</span>(!keep_running) <span class="hljs-keyword">break</span>; 
  }
}
</code></pre>
<p><strong>关键点：</strong> 浏览器会在处理完一个普通宏任务后，去检查延迟队列中是否有任务到期（<code>ProcessDelayTask</code>），并依次执行它们。</p>
<hr/>
<h2 data-id="heading-9">五、 面试模拟题</h2>
<h3 data-id="heading-10">Q1：为什么 <code>setTimeout(fn, 0)</code> 并不一定是 0ms 后执行？</h3>
<p><strong>参考回答：</strong></p>
<ol>
<li><strong>浏览器最小限制</strong>：HTML5 规范规定，如果定时器嵌套超过 5 层，最小延迟为 4ms。</li>
<li><strong>Event Loop 阻塞</strong>：由于定时器任务是在 <code>ProcessDelayTask</code> 中处理的，如果当前的宏任务（比如一个复杂的计算循环）执行时间过长，主线程就无法及时跳转到延迟队列的检查步骤，导致定时器推迟执行。</li>
</ol>
<h3 data-id="heading-11">Q2：说出以下代码的打印顺序：</h3>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1'</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2'</span>), <span class="hljs-number">0</span>);
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3'</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'4'</span>);
</code></pre>
<p>参考回答：</p>
<p>1 -&gt; 4 -&gt; 3 -&gt; 2。</p>
<ul>
<li><code>1, 4</code> 是同步任务，直接输出。</li>
<li><code>3</code> 是微任务，在当前脚本（宏任务）执行完后立即执行。</li>
<li><code>2</code> 是下一次宏任务。</li>
</ul>
<h3 data-id="heading-12">Q3：<code>MutationObserver</code> 属于什么任务？它有什么应用场景？</h3>
<p>参考回答：</p>
<p>MutationObserver 属于微任务。它用于监听 DOM 树的变化。由于它是微任务，它会在 DOM 变化引起的多次修改全部完成后，在浏览器重新渲染之前异步执行，这比传统的 Mutation Events 性能更高，且不会阻塞主线程渲染。</p>
<hr/>
<h2 data-id="heading-13">六、 总结建议</h2>
<ul>
<li><strong>理解微任务的优先级</strong>：微任务是在当前宏任务结束后的“插队”行为，适合处理需要立即反馈的异步逻辑。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LeetCode 11. 盛最多水的容器]]></title>    <link>https://juejin.cn/post/7595893785907232802</link>    <guid>https://juejin.cn/post/7595893785907232802</guid>    <pubDate>2026-01-17T15:17:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595893785907232802" data-draft-id="7595886887523631144" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LeetCode 11. 盛最多水的容器"/> <meta itemprop="keywords" content="面试,算法"/> <meta itemprop="datePublished" content="2026-01-17T15:17:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="NEXT06"/> <meta itemprop="url" content="https://juejin.cn/user/1176918763246011"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LeetCode 11. 盛最多水的容器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1176918763246011/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    NEXT06
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T15:17:39.000Z" title="Sat Jan 17 2026 15:17:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">图解算法：为什么一定要移动那个短板？| LeetCode 11. 盛最多水的容器</h2>
<blockquote>
<p><strong>前言</strong>：在面试中，有一类题目看似简单，暴力解法也能做，但面试官真正想看的是你如何将 </p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">O</span>(N2)
</code></pre>
<p> 的复杂度优化到 </p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">O</span>(N)
</code></pre>
<p>。LeetCode 11 题“盛最多水的容器”就是这类题目的典范。今天我们不背代码，而是深入探讨背后的<strong>贪心策略</strong>与<strong>双指针</strong>思维。</p>
</blockquote>
<h3 data-id="heading-1">一、 题目直觉与“木桶效应”</h3>
<p>题目的目标非常直观：在一个数组中找到两条垂线，使得它们与 X 轴围成的容器能盛最多的水。</p>
<p>我们要计算的是矩形面积：</p>
<pre><code class="hljs language-css" lang="css">Area=<span class="hljs-attribute">Width</span>×HeightArea=<span class="hljs-attribute">Width</span>×<span class="hljs-attribute">Height</span>
</code></pre>
<p>这里有一个物理常识至关重要，那就是<strong>木桶效应 (Short Board Effect)</strong> ：<br/>
一个木桶能装多少水，取决于<strong>最短</strong>的那块木板。</p>
<p>映射到题目中：</p>
<ul>
<li><strong>宽度 (Width)</strong> ：两条垂线在 X 轴上的距离 right - left。</li>
<li><strong>高度 (Height)</strong> ：两条垂线中<strong>较矮</strong>的那一条，即 Math.min(height[left], height[right])。</li>
</ul>
<h3 data-id="heading-2">二、 痛点：为什么暴力解法不行？</h3>
<p>最容易想到的思路是双重循环：计算所有两两组合的面积，然后取最大值。</p>
<p>然而以我的经验，当你写下双循环的时候，你自己心中的无奈，没有人会比你更了解</p>
<p>面试官在了解到你的解题思路时，就已经将你pass掉了</p>
<p>任何算法题，写双循环的结果只有死路一条（因为他会认为你对空间与时间复杂度没有概念，或者你的实力就这么多）</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">//  暴力解法
let <span class="hljs-attr">max</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; len; i++) {</span>
    for (let <span class="hljs-attr">j</span> = i + <span class="hljs-number">1</span><span class="hljs-comment">; j &lt; len; j++) {</span>
        // 计算每一对组合...
    }
}
</code></pre>
<p><strong>这种解法的时间复杂度是</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">O</span>(N2)
</code></pre>
<p>。<br/>
题目提示中数组长度 </p>
<pre><code class="hljs">NN
</code></pre>
<p> 可达 </p>
<pre><code class="hljs">105105
</code></pre>
<p>。这意味着计算量高达 </p>
<pre><code class="hljs">10101010
</code></pre>
<p> 次。在通常的算法竞赛或面试标准中，这绝对会触发 <strong>TLE (Time Limit Exceeded)</strong>  超时错误。</p>
<p>我们需要一种更聪明的做法，将复杂度降维打击到</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">O</span>(N)
</code></pre>
<p>。</p>
<h3 data-id="heading-3">三、 核心：双指针法与贪心策略</h3>
<p>我们要优化的核心是：<strong>如何尽可能少地遍历，却能保证不漏掉最大值？</strong></p>
<h4 data-id="heading-4">1. 初始布局：拉满宽度</h4>
<p>既然面积 = 宽 × 高，我们不妨先让<strong>宽度最大</strong>。<br/>
我们在数组的头尾各放置一个指针：left 指向开头，right 指向结尾。</p>
<p>此时，容器的底宽是最大的。接下来的每一步移动，宽度必然减小。为了弥补宽度的损失，我们必须寻找<strong>更高</strong>的垂线。</p>
<h4 data-id="heading-5">2. 决策困境：移动哪一根？</h4>
<p>这是本题最难理解的点。假设现在的状况是：</p>
<ul>
<li>
<p>左边柱子高度 left_h = 2</p>
</li>
<li>
<p>右边柱子高度 right_h = 8</p>
</li>
<li>
<p>当前宽度 w = 10</p>
</li>
<li>
<p>当前面积 = </p>
<pre><code class="hljs language-ini" lang="ini">2×<span class="hljs-attr">10</span>=<span class="hljs-number">202</span>×<span class="hljs-number">10</span>=<span class="hljs-number">20</span>
</code></pre>
</li>
</ul>
<p>现在我们需要向内移动一个指针，是移左边的（矮的），还是移右边的（高的）？</p>
<h5 data-id="heading-6">假设我们移动高的那一边（右边）：</h5>
<p>宽度肯定变小了（变成 9）。<br/>
而水位高度取决于谁？依然是左边那个不动的短板（高度 2）。<br/>
无论右边新遇到的柱子是高耸入云还是矮小不堪，容器的有效高度<strong>最高只能是 2</strong>。</p>
<pre><code class="hljs language-scss" lang="scss">新面积=<span class="hljs-number">9</span>×min⁡(<span class="hljs-number">2</span>,新高度)≤<span class="hljs-number">18</span>新面积=<span class="hljs-number">9</span>×<span class="hljs-built_in">min</span>(<span class="hljs-number">2</span>,新高度)≤<span class="hljs-number">18</span>
</code></pre>
<p><strong>结论：</strong>  移动高板，宽度减小，高度受限于不动的短板（无法增加）。<strong>面积只会变小，绝对不可能变大。</strong>  这是一条死路。</p>
<h5 data-id="heading-7">贪心策略：移动矮的那一边（左边）：</h5>
<p>虽然宽度变小了（变成 9），但我们抛弃了当前的短板（高度 2）。<br/>
如果运气好，左边新遇到的柱子高度是 10，那么新的有效高度就变成了 8（受限于右边）。</p>
<pre><code class="hljs language-ini" lang="ini">新面积=9×<span class="hljs-attr">8</span>=<span class="hljs-number">72</span>新面积=<span class="hljs-number">9</span>×<span class="hljs-number">8</span>=<span class="hljs-number">72</span>
</code></pre>
<p><strong>结论：</strong>  只有移动短板，我们才<strong>有可能</strong>找到更高的柱子来弥补宽度的损失。</p>
<p><strong>这就是本题的贪心逻辑：</strong>  每一步我们都排除掉那个“导致当前高度受限”的短板，因为它已经发挥了它的最大潜力（在当前最宽的情况下），保留它没有任何意义。</p>
<h3 data-id="heading-8">四、 代码实现</h3>
<p>理解了上述逻辑，代码实现就非常简单了。</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">/**
 * @param {number<span class="hljs-section">[]</span>} height
 * @return {number}
 */
var <span class="hljs-attr">maxArea</span> = function(height) {
    // 1. 定义双指针，分别指向头尾
    let <span class="hljs-attr">left</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    let <span class="hljs-attr">right</span> = height.length - <span class="hljs-number">1</span><span class="hljs-comment">;</span>
    let <span class="hljs-attr">maxWater</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    
    // 2. 当指针未相遇时循环
    while (left &lt; right) {
        // 3. 计算当前面积
        // 高度取决于短板 (木桶效应)
        const <span class="hljs-attr">currentHeight</span> = Math.min(height[left], height[right])<span class="hljs-comment">;</span>
        const <span class="hljs-attr">currentWidth</span> = right - left<span class="hljs-comment">;</span>
        
        // 更新历史最大值
        <span class="hljs-attr">maxWater</span> = Math.max(maxWater, currentHeight * currentWidth)<span class="hljs-comment">;</span>
        
        // 4. 核心决策：移动较矮的一侧
        // 如果左边是短板，那左边这块板子在当前宽度下已经发挥了最大价值，
        // 再往里缩宽度只会变小，保留左边没意义，不如向右移试试看有没有更高的。
        if (height<span class="hljs-section">[left]</span> &lt; height<span class="hljs-section">[right]</span>) {
            left++<span class="hljs-comment">;</span>
        } else {
            right--<span class="hljs-comment">;</span>
        }
    }
    
    return maxWater<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-9">五、 复杂度分析</h3>
<ul>
<li>
<p><strong>时间复杂度：</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">O</span>(N)
</code></pre>
<p>双指针 left 和 right 总共遍历整个数组一次。相比于暴力解法的 </p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">O</span>(N2)
</code></pre>
<p>，效率提升是巨大的。</p>
</li>
<li>
<p><strong>空间复杂度：</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 
</code></pre>
<p>我们只需要存储指针索引和 maxWater 几个变量，不需要额外的数组空间。</p>
</li>
</ul>
<h3 data-id="heading-10">六、 总结</h3>
<p>所谓算法优化，往往不是代码写得有多复杂，而是<strong>思维模型的转换</strong>。</p>
<p>LeetCode 11 题通过观察“木桶效应”，让我们明白：保留长板、抛弃短板是唯一可能获得更大收益的路径。这种通过排除法将搜索空间从二维矩阵（所有组合）压缩到一维线性扫描（双指针）的过程，就是算法中的<strong>降维打击</strong>。</p>
<p>希望这篇文章能帮你彻底搞懂双指针解法！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[探索现代化 i18n 方案：从工程自动化到 AI 驱动的演进]]></title>    <link>https://juejin.cn/post/7596025264455778340</link>    <guid>https://juejin.cn/post/7596025264455778340</guid>    <pubDate>2026-01-17T15:37:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7596025264455778340" data-draft-id="7595858760133820479" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="探索现代化 i18n 方案：从工程自动化到 AI 驱动的演进"/> <meta itemprop="keywords" content="前端,人工智能"/> <meta itemprop="datePublished" content="2026-01-17T15:37:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小蜗1号"/> <meta itemprop="url" content="https://juejin.cn/user/835284568117806"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            探索现代化 i18n 方案：从工程自动化到 AI 驱动的演进
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/835284568117806/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小蜗1号
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T15:37:43.000Z" title="Sat Jan 17 2026 15:37:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在最近参与的一个中大型前端项目中，随着业务需求的快速变化和代码的频繁重构，国际化（i18n）逐渐从“基础设施”演变成了一个明显的工程负担。</p>
<p>一个非常典型的场景是：<strong>组件逻辑已经修改完成，但 <code>locales</code> 目录下的 JSON 文件却长期处于滞后状态</strong>。新增的文案没有及时补齐，删除的页面却遗留了一堆无人使用的 Key。随着项目规模扩大，这类问题会被不断放大。</p>
<p>这背后其实暴露的是一个更本质的问题：<strong>传统 i18n 的工作流，与现代前端开发节奏并不匹配</strong>。</p>
<p>在深入探讨改进方案之前，我们有必要先回顾一下当前主流 i18n 方案的设计思路及其局限。</p>
<h2 data-id="heading-0">1. 传统基石：vue-i18n 的设计取舍</h2>
<p>在 Vue 生态中，<code>vue-i18n</code> 几乎是事实标准。它成熟、稳定，并且覆盖了大多数国际化场景。</p>
<p>从实现机制上看，<code>vue-i18n</code> 的核心是 <strong>运行时（Runtime）替换</strong>：</p>
<ul>
<li>开发者在模板或脚本中通过 <code>$t('key')</code> 访问文案</li>
<li>运行时根据当前语言环境，从预先加载的 JSON 语言包中查找并返回对应字符串</li>
<li>同时支持复数规则、日期/数字格式化等高级能力</li>
</ul>
<p>从“框架插件”的角度来看，这样的设计并没有问题，但在真实工程实践中，它也带来了一些长期被忽视的成本。</p>
<p><strong>常见痛点包括：</strong></p>
<ul>
<li><strong>Key 设计成本高</strong><br/>
为每一条文案设计一个“语义清晰、层级合理、可长期维护”的 Key，本身就是一项隐性工作量。</li>
<li><strong>代码与文案强解耦</strong><br/>
Key 分散在业务代码中，真实文案却集中在 JSON 文件里，删除或重构页面时，很容易留下大量“无效翻译”。</li>
<li><strong>上下文缺失导致翻译质量不稳定</strong><br/>
无论是人工翻译还是机器翻译，单独面对一个 Key，很难准确理解其真实使用场景。<br/>
这些问题并非 <code>vue-i18n</code> 本身的缺陷，而是 <strong>“Key 驱动”这一设计范式的天然代价</strong>。</li>
</ul>
<h2 data-id="heading-1">2. 自动化方向的探索：基于 AST 的 i18n 工具</h2>
<p>为了降低 Key 维护和手工同步的成本，社区中逐渐出现了一类自动化工具，例如<br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fauto-i18n%2Fauto-i18n-translation-plugins" target="_blank" title="https://github.com/auto-i18n/auto-i18n-translation-plugins" ref="nofollow noopener noreferrer">auto-i18n-translation-plugins</a>。</p>
<p>这类方案的核心思想是：<strong>让工具理解代码，而不是让人维护映射关系</strong>。</p>
<p>其典型流程如下：</p>
<ol>
<li><strong>静态扫描</strong><br/>
基于 AST 分析源代码，提取其中的中文字符串</li>
<li><strong>自动替换</strong><br/>
将源码中的中文替换为生成的 Key（通常是 Hash 值）</li>
<li><strong>自动翻译</strong><br/>
调用 Google / 百度等翻译 API，生成多语言文案</li>
<li><strong>配置写入</strong><br/>
自动维护语言包文件<br/>
在工程效率层面，这一步已经是一次明显的跃迁：<br/>
<strong>开发者几乎可以忽略 i18n 的存在，先完成业务，再由工具兜底。</strong></li>
</ol>
<p>但当项目进入更复杂的业务领域后，新的问题也随之出现。</p>
<p><strong>主要瓶颈在于翻译质量：</strong></p>
<ul>
<li>通用翻译 API 缺乏领域上下文</li>
<li>无法区分业务语义（如金融、医疗、后台系统等）</li>
<li>仍然需要大量人工校对</li>
</ul>
<p>这类工具解决了“效率问题”，但并没有真正解决“准确性问题”。</p>
<h2 data-id="heading-2">3. 进一步演进：AI 驱动的 i18n 设计思路</h2>
<p>在当前 LLM 已经高度成熟的背景下，我认为 i18n 方案的设计目标可以进一步升级：</p>
<blockquote>
<p><strong>以 Developer Experience 为核心，尽可能贴近自然语言，并把翻译质量交给更“理解上下文”的模型。</strong></p>
</blockquote>
<h3 data-id="heading-3">3.1 语法层面的取舍：回归自然语言</h3>
<p>首先，一个关键决策是：<strong>不再强制开发者手动定义 Key</strong>。</p>
<p>代码中的国际化调用，应该尽量接近自然语言本身：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 基础用法：直接使用中文</span>
<span class="hljs-keyword">const</span> msg = t<span class="hljs-string">`你好`</span>;

<span class="hljs-comment">// 带上下文的用法</span>
<span class="hljs-keyword">const</span> status = <span class="hljs-title function_">t</span>(<span class="hljs-string">"待审核"</span>, <span class="hljs-string">"金融风控业务状态"</span>);
</code></pre>
<p>这样的语法带来几个直接收益：</p>
<ul>
<li>文案在代码中是可读的，而不是抽象的 Key</li>
<li>Code Review 时无需在 JSON 文件和业务代码之间来回切换</li>
<li>上下文信息可以显式传递给翻译系统</li>
</ul>
<h3 data-id="heading-4">3.2 更合理的 Key 生成策略</h3>
<p>在生成语言包时，我们同样可以放弃不可读的 Hash Key，而采用：</p>
<blockquote>
<p><strong>「中文原文 + 上下文注释」作为唯一标识</strong></p>
</blockquote>
<p>示例：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"待审核#金融风控业务状态"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"english"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Pending Review"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>这种设计的优势在于：</p>
<ul>
<li><strong>天然避免语义冲突</strong> 同样是“取消”，在“订单操作”和“账户注销”场景下可以通过上下文区分</li>
<li><strong>Key 本身即文档</strong> 语言包文件在人工审核时非常直观</li>
<li><strong>更适合多语言扩展</strong> 在后续生成日文、法文、韩文等语言时，可以复用同一套 Key 体系，无需额外维护映射关系</li>
</ul>
<h3 data-id="heading-5">3.3 虚拟模块：让翻译数据成为构建产物</h3>
<p>为了避免手动管理中间文件，可以利用 Vite / Rollup 的 <strong>Virtual Module（虚拟模块）</strong> 能力。</p>
<p>简单来说，插件可以在构建阶段动态生成一个模块，例如：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { t } <span class="hljs-keyword">from</span> <span class="hljs-string">"virtual:ai-i18n"</span>;
</code></pre>
<p>构建工具会拦截该导入，并返回由插件实时生成的运行时代码，其中已经包含：</p>
<ul>
<li>当前语言包</li>
<li><code>t</code>、<code>setLang</code> 等辅助函数</li>
</ul>
<p>这样一来：</p>
<ul>
<li>翻译数据成为构建流程的一部分</li>
<li>不需要关心 JSON 文件的加载和同步问题</li>
<li>工程结构更加清晰</li>
</ul>
<p><strong>虚拟模块的设计意义</strong>：</p>
<ol>
<li><strong>语言包属于构建产物，而不是源码文件</strong></li>
<li><strong>无需生成中间文件，也无需 commit</strong></li>
<li><strong>极大提升开发者体验</strong>，让文案写作像原生语言特性一样自然</li>
</ol>
<h3 data-id="heading-6">3.4 自动导入，进一步压缩心智负担</h3>
<p>配合 <code>unplugin-auto-import</code>，甚至可以省略显式的 import：</p>
<pre><code class="hljs language-ts" lang="ts">t<span class="hljs-string">`你好`</span>;
</code></pre>
<p>从开发体验上看，这已经接近“原生写文案”的感觉。</p>
<h2 data-id="heading-7">4. 插件选项：目标语言与默认语言</h2>
<p>插件提供灵活配置：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">aiI18nPlugin</span>({
  <span class="hljs-attr">targetLangs</span>: [<span class="hljs-string">"english"</span>, <span class="hljs-string">"ja"</span>, <span class="hljs-string">"fr"</span>], <span class="hljs-comment">// 所有需要生成的目标语言</span>
  <span class="hljs-attr">defaultLang</span>: <span class="hljs-string">"english"</span>, <span class="hljs-comment">// 默认翻译语言</span>
});
</code></pre>
<ul>
<li>如果未传 <code>defaultLang</code>，默认使用 <code>'english'</code></li>
<li><code>targetLangs</code> 至少包含默认语言</li>
<li>后续生成语言包的结构统一为单文件 JSON</li>
</ul>
<h2 data-id="heading-8">5. 插件输出文件：单 JSON + 可人工校准</h2>
<p>为了最大化可维护性，输出语言包为：</p>
<pre><code class="hljs language-bash" lang="bash">locales/i18n.json
</code></pre>
<p>格式示例：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"提交#表单操作"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"english"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Submit"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"ja"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"fr"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"待审核#金融风控业务状态"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"english"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Pending Review"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li><strong>单文件管理</strong>：避免多语言文件分散，方便查找与审核</li>
<li><strong>只处理未翻译 Key</strong>：插件不会覆盖已有翻译</li>
<li><strong>支持人工校准</strong>：你可以在 <code>locales/i18n.json</code> 中直接修改或补充翻译</li>
<li><strong>增量更新</strong>：每次构建只生成缺失翻译，保证历史翻译安全</li>
</ul>
<h2 data-id="heading-9">6. 为什么这里选择 LLM，而不是传统翻译 API？</h2>
<p>引入 LLM 并不是为了追逐概念，而是为了解决传统翻译 API 的结构性短板。</p>
<h3 data-id="heading-10">6.1 领域语义的理解能力</h3>
<p>通过 Prompt Engineering，可以显式告诉模型当前的业务背景，例如：</p>
<ul>
<li>金融风控系统</li>
<li>SaaS 管理后台</li>
<li>电商交易流程</li>
</ul>
<p>配合 Few-Shot 示例或术语表注入，生成的翻译在<strong>准确性和专业度</strong>上，明显优于通用 API。</p>
<h3 data-id="heading-11">6.2 成本与隐私的可控性</h3>
<p>翻译任务本身是低复杂度任务，非常适合：</p>
<ul>
<li>本地运行 4B~8B 级别模型（如 Qwen、Llama 系列）</li>
<li>通过 Ollama 等工具进行部署</li>
<li>结合 LangChain 进行批处理调用</li>
</ul>
<p>这种方式的优势包括：</p>
<ul>
<li>无网络依赖，隐私可控</li>
<li>无调用费用</li>
<li>批量翻译效率高</li>
</ul>
<p>在企业环境中，也可以直接替换为 GPT-4、DeepSeek 等商业 API，方案本身并不受限。</p>
<h2 data-id="heading-12">7. 插件实现要点（Vite Plugin）</h2>
<p>插件的核心职责可以归纳为两点：</p>
<ol>
<li><strong>收集需要翻译的文案</strong></li>
<li><strong>在合适的时机批量调用 LLM，并持久化结果到单文件 JSON</strong></li>
</ol>
<p>关键实现细节包括：</p>
<ul>
<li>翻译队列与批处理机制</li>
<li>本地缓存与持久化</li>
<li>避免重复翻译已存在 Key</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * vite-plugin-ai-i18n.ts
 *
 * 说明：
 * 这是一个用于解释 AI i18n 插件核心流程的伪代码示例。
 * 重点在于架构、数据流和设计思路，而非具体 API 或可运行实现。
 */</span>

<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-comment">// -------------------------</span>
<span class="hljs-comment">// 虚拟模块定义</span>
<span class="hljs-comment">// -------------------------</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VIRTUAL_MODULE_ID</span> = <span class="hljs-string">"virtual:ai-i18n"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RESOLVED_VIRTUAL_MODULE_ID</span> = <span class="hljs-string">"\0"</span> + <span class="hljs-variable constant_">VIRTUAL_MODULE_ID</span>;

<span class="hljs-comment">// -------------------------</span>
<span class="hljs-comment">// 输出文件与默认语言</span>
<span class="hljs-comment">// -------------------------</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LOCALES_DIR</span> = path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">"locales"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LOCALE_FILE</span> = path.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">LOCALES_DIR</span>, <span class="hljs-string">"i18n.json"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_LANG</span> = <span class="hljs-string">"english"</span>;

<span class="hljs-comment">// -------------------------</span>
<span class="hljs-comment">// 类型定义（简化）</span>
<span class="hljs-comment">// -------------------------</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Lang</span> = <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">TranslationKey</span> = <span class="hljs-built_in">string</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">PendingItem</span> {
  <span class="hljs-attr">key</span>: <span class="hljs-title class_">TranslationKey</span>; <span class="hljs-comment">// 唯一标识：原文#上下文</span>
  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 原文</span>
  context?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 可选上下文信息</span>
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">LangMessages</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Lang</span>, <span class="hljs-built_in">string</span>&gt;;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">AllMessages</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">TranslationKey</span>, <span class="hljs-title class_">LangMessages</span>&gt;;

<span class="hljs-comment">// -------------------------</span>
<span class="hljs-comment">// 工具函数（伪实现）</span>
<span class="hljs-comment">// -------------------------</span>

<span class="hljs-comment">/**
 * 读取已有 JSON 语言包
 * 如果文件不存在，返回空对象
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadLocales</span>(<span class="hljs-params"/>): <span class="hljs-title class_">AllMessages</span> {
  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-variable constant_">LOCALE_FILE</span>)) <span class="hljs-keyword">return</span> {};
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-variable constant_">LOCALE_FILE</span>, <span class="hljs-string">"utf-8"</span>));
}

<span class="hljs-comment">/**
 * 将最终语言包写入本地 JSON
 * 自动创建目录
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">saveLocales</span>(<span class="hljs-params">messages: AllMessages</span>) {
  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-variable constant_">LOCALES_DIR</span>)) fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-variable constant_">LOCALES_DIR</span>);
  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-variable constant_">LOCALE_FILE</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(messages, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));
}

<span class="hljs-comment">/**
 * 扫描源码中所有 t(...) / t`...` 的调用
 * 实际实现应使用 AST
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">scanForI18nTexts</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">PendingItem</span>[] {
  <span class="hljs-comment">// 伪逻辑示意：</span>
  <span class="hljs-comment">// 1. 遍历代码 AST</span>
  <span class="hljs-comment">// 2. 找到 t`xxx` 或 t('xxx', 'context')</span>
  <span class="hljs-comment">// 3. 返回 PendingItem 列表</span>
  <span class="hljs-keyword">return</span> [];
}

<span class="hljs-comment">// -------------------------</span>
<span class="hljs-comment">// 插件主逻辑</span>
<span class="hljs-comment">// -------------------------</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">aiI18nPlugin</span>(<span class="hljs-params">options: {
  targetLangs?: Lang[]; // 目标语言列表
  defaultLang?: Lang; // 默认语言
}</span>) {
  <span class="hljs-keyword">const</span> defaultLang = options.<span class="hljs-property">defaultLang</span> || <span class="hljs-variable constant_">DEFAULT_LANG</span>;
  <span class="hljs-keyword">const</span> targetLangs = options.<span class="hljs-property">targetLangs</span> || [defaultLang];

  <span class="hljs-comment">// 加载已有翻译（人工可校准）</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">allMessages</span>: <span class="hljs-title class_">AllMessages</span> = <span class="hljs-title function_">loadLocales</span>();

  <span class="hljs-comment">// 待翻译队列，只收集尚未存在的 Key</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">pendingQueue</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">PendingItem</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"vite-plugin-ai-i18n"</span>,

    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-comment">// 虚拟模块解析</span>
    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-title function_">resolveId</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">if</span> (id === <span class="hljs-variable constant_">VIRTUAL_MODULE_ID</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">RESOLVED_VIRTUAL_MODULE_ID</span>;
    },

    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-comment">// 虚拟模块加载</span>
    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-title function_">load</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">if</span> (id === <span class="hljs-variable constant_">RESOLVED_VIRTUAL_MODULE_ID</span>) {
        <span class="hljs-comment">// 这里返回运行时代码：</span>
        <span class="hljs-comment">// - messages: 当前语言包</span>
        <span class="hljs-comment">// - t: 翻译函数</span>
        <span class="hljs-comment">// - setLang/getCurrentLang: 语言切换函数</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`
          const messages = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(allMessages)}</span>;
          let currentLang = '<span class="hljs-subst">${defaultLang}</span>';

          export function t(text, context = '') {
            const key = context ? \`\${text}#\${context}\` : text;
            return messages[key]?.[currentLang] || text;
          }

          export function setLang(lang) { currentLang = lang; }
          export function getCurrentLang() { return currentLang; }
        `</span>;
      }
    },

    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-comment">// 源码扫描阶段</span>
    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-title function_">transform</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span>, id: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-comment">// 忽略 node_modules</span>
      <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"node_modules"</span>)) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// 扫描源码，收集 t(...) / t`...` 调用</span>
      <span class="hljs-keyword">const</span> foundItems = <span class="hljs-title function_">scanForI18nTexts</span>(code);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> foundItems) {
        <span class="hljs-comment">// key = 原文 + 可选上下文</span>
        <span class="hljs-keyword">const</span> key = item.<span class="hljs-property">context</span> ? <span class="hljs-string">`<span class="hljs-subst">${item.text}</span>#<span class="hljs-subst">${item.context}</span>`</span> : item.<span class="hljs-property">text</span>;

        <span class="hljs-comment">// 针对每个目标语言，判断是否已存在翻译</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> lang <span class="hljs-keyword">of</span> targetLangs) {
          <span class="hljs-keyword">const</span> langMessages = allMessages[key] || {};
          <span class="hljs-keyword">if</span> (!langMessages[lang]) {
            <span class="hljs-comment">// 尚未存在翻译，加入待翻译队列</span>
            pendingQueue.<span class="hljs-title function_">set</span>(<span class="hljs-string">`<span class="hljs-subst">${lang}</span>:<span class="hljs-subst">${key}</span>`</span>, { ...item, key });
          }
        }
      }

      <span class="hljs-comment">// 返回原始代码，不修改</span>
      <span class="hljs-keyword">return</span> code;
    },

    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-comment">// 构建结束 / 批量翻译</span>
    <span class="hljs-comment">// -------------------------</span>
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">buildEnd</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">if</span> (!pendingQueue.<span class="hljs-property">size</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// 按语言分组</span>
      <span class="hljs-keyword">const</span> <span class="hljs-attr">groupedByLang</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Lang</span>, <span class="hljs-title class_">PendingItem</span>[]&gt; = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [compoundKey, item] <span class="hljs-keyword">of</span> pendingQueue) {
        <span class="hljs-keyword">const</span> [lang] = compoundKey.<span class="hljs-title function_">split</span>(<span class="hljs-string">":"</span>);
        groupedByLang[lang] ||= [];
        groupedByLang[lang].<span class="hljs-title function_">push</span>(item);
      }

      <span class="hljs-comment">// 对每个目标语言调用 LLM 翻译（伪逻辑）</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> lang <span class="hljs-keyword">in</span> groupedByLang) {
        <span class="hljs-keyword">const</span> items = groupedByLang[lang];

        <span class="hljs-comment">// === 这里可以调用 LLM API ===</span>
        <span class="hljs-comment">// const results = await llm.translateBatch(items)</span>

        <span class="hljs-comment">// 伪结果示例</span>
        <span class="hljs-keyword">const</span> <span class="hljs-attr">results</span>: { <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> }[] = [];

        <span class="hljs-comment">// 将翻译结果写入内存缓存</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { key, value } <span class="hljs-keyword">of</span> results) {
          allMessages[key] ||= {};
          allMessages[key][lang] = value;
        }
      }

      <span class="hljs-comment">// 持久化到单 JSON 文件，人工可校准</span>
      <span class="hljs-title function_">saveLocales</span>(allMessages);

      <span class="hljs-comment">// 清空队列，避免重复翻译</span>
      pendingQueue.<span class="hljs-title function_">clear</span>();
    },
  };
}
</code></pre>
<h2 data-id="heading-13">8. 实际使用体验</h2>
<p>封装后，开发侧使用方式非常简单：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;div&gt;{{ t`你好` }}&lt;/div&gt;
&lt;button&gt;{{ t('提交', '表单操作') }}&lt;/button&gt;
</code></pre>
<p>切换语言：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">setLang</span>(<span class="hljs-string">"english"</span>);
</code></pre>
<p>扩展新语言（如日文、法文、韩文）时，只需调整插件配置中的 <code>targetLangs</code>，<strong>无需额外维护 Key 或复制文案文件</strong>。</p>
<h2 data-id="heading-14">9. 总结</h2>
<p>这套 i18n 方案的核心价值不在于“AI 翻译”本身，而在于：</p>
<ol>
<li><strong>文案回归自然语言，而不是 Key</strong></li>
<li><strong>翻译与维护成本前移到工具链</strong></li>
<li><strong>通过上下文 + LLM 提升翻译质量</strong></li>
<li><strong>单 JSON 文件 + 虚拟模块 + 增量翻译降低多语言长期成本</strong></li>
<li><strong>支持人工校准，只处理未翻译 Key，安全可靠</strong></li>
</ol>
<p>目前这仍是一个持续演进中的实践方案，但在复杂业务、多语言项目中，已经展现出明显的工程价值。</p>
<p>如果你对 i18n、工程自动化或 AI 在前端工具链中的应用有不同看法，欢迎一起交流和探讨。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[以逻辑门角度深入理解promise组合方法]]></title>    <link>https://juejin.cn/post/7595896809652125736</link>    <guid>https://juejin.cn/post/7595896809652125736</guid>    <pubDate>2026-01-17T15:51:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595896809652125736" data-draft-id="7595974133097168930" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="以逻辑门角度深入理解promise组合方法"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2026-01-17T15:51:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="xier123456"/> <meta itemprop="url" content="https://juejin.cn/user/546930955651113"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            以逻辑门角度深入理解promise组合方法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/546930955651113/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    xier123456
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-17T15:51:41.000Z" title="Sat Jan 17 2026 15:51:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    19
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在数字电路设计中，逻辑门是构建复杂系统的基础元件。同样，在现代 JavaScript 异步编程中，Promise 的组合方法（<code>all</code>、<code>allSettled</code>、<code>any</code>、<code>race</code>）构成了异步流程控制的基础电路。<br/>
本文将深入探讨这些方法的行为模式，通过逻辑门比喻建立直观理解，并帮助你彻底掌握 Promise 的组合方法——甚至推演出新的或者你未发现的异步控制模式。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">核心概念定义</h2>
<p>我们先建立统一的逻辑系统：</p>
<ul>
<li><strong>Promise 状态映射</strong>：
<ul>
<li><strong>Fulfilled (1)</strong>：成功，异步操作完成并返回结果</li>
<li><strong>Rejected (0)</strong>：失败，异步操作抛出错误</li>
</ul>
</li>
<li><strong>输入向量</strong>：一个 Promise 数组，每个 Promise 是一个输入信号</li>
<li><strong>输出</strong>：一个新的 Promise，其状态由输入向量的状态组合决定</li>
</ul>
<h3 data-id="heading-1">状态常量</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">"pending"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">"fulfilled"</span>;  
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">"rejected"</span>;     
</code></pre>
<hr/>
<h2 data-id="heading-2">1️.<code>Promise.all()</code>：逻辑与门（AND Gate）</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 逻辑表达式: OUTPUT = INPUT₁ ∧ INPUT₂ ∧ ... ∧ INPUTₙ</span>
<span class="hljs-comment">// 所有输入为 1 时，输出为 1；任一输入为 0 时，输出为 0</span>
</code></pre>
<h3 data-id="heading-3">逻辑门类比</h3>
<ul>
<li><strong>AND 门特性</strong>：全高电平 → 高电平；任一低电平 → 低电平</li>
<li><strong>对应行为</strong>：所有 Promise 成功才成功，任一失败立即失败</li>
<li><strong>典型场景</strong>：多个依赖接口必须全部加载成功（如用户资料 + 权限 + 配置）</li>
</ul>
<h3 data-id="heading-4">真值表</h3>



































<table><thead><tr><th>Promise₁</th><th>Promise₂</th><th><code>Promise.all</code></th><th>解释</th></tr></thead><tbody><tr><td>1 (成功)</td><td>1 (成功)</td><td>1 (成功)</td><td>全部成功</td></tr><tr><td>1 (成功)</td><td>0 (失败)</td><td>0 (失败)</td><td>快速失败</td></tr><tr><td>0 (失败)</td><td>1 (成功)</td><td>0 (失败)</td><td>快速失败</td></tr><tr><td>0 (失败)</td><td>0 (失败)</td><td>0 (失败)</td><td>快速失败</td></tr></tbody></table>
<h3 data-id="heading-5">特性</h3>
<ol>
<li><strong>快速失败</strong>：第一个 reject 立即 reject 整体</li>
<li><strong>顺序结果</strong>：成功时按输入顺序返回值数组</li>
<li><strong>短路求值</strong>：失败后不再等待其他 Promise</li>
</ol>
<h3 data-id="heading-6">实现</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myAll</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">iterable</span>) {
  <span class="hljs-keyword">if</span> (iterable == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] !== <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
  }

  <span class="hljs-keyword">const</span> promises = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iterable);
  <span class="hljs-keyword">if</span> (promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>([]);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promises.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">let</span> settledCount = <span class="hljs-number">0</span>;

    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
          result[index] = value;
          settledCount++;
          <span class="hljs-keyword">if</span> (settledCount === promises.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(result);
        })
        .<span class="hljs-title function_">catch</span>(reject); <span class="hljs-comment">// 任一失败，整体失败</span>
    });
  });
};
</code></pre>
<hr/>
<h2 data-id="heading-7">2. <code>Promise.any()</code>：逻辑或门（OR Gate）</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 逻辑表达式: OUTPUT = INPUT₁ ∨ INPUT₂ ∨ ... ∨ INPUTₙ</span>
<span class="hljs-comment">// 任一输入为 1 时，输出为 1；所有输入为 0 时，输出为 0</span>
</code></pre>
<h3 data-id="heading-8">逻辑门类比</h3>
<ul>
<li><strong>OR 门特性</strong>：任一高电平 → 高电平；全低电平 → 低电平</li>
<li><strong>对应行为</strong>：任一 Promise 成功即成功，全部失败才失败</li>
<li><strong>典型场景</strong>：多 CDN 加载资源，取最快成功的响应</li>
</ul>
<h3 data-id="heading-9">真值表</h3>



































<table><thead><tr><th>Promise₁</th><th>Promise₂</th><th><code>Promise.any</code></th><th>解释</th></tr></thead><tbody><tr><td>1 (成功)</td><td>1 (成功)</td><td>1 (成功)</td><td>任一成功即可</td></tr><tr><td>1 (成功)</td><td>0 (失败)</td><td>1 (成功)</td><td>任一成功即可</td></tr><tr><td>0 (失败)</td><td>1 (成功)</td><td>1 (成功)</td><td>任一成功即可</td></tr><tr><td>0 (失败)</td><td>0 (失败)</td><td>0 (失败)</td><td>全部失败</td></tr></tbody></table>
<h3 data-id="heading-10">特性</h3>
<ol>
<li><strong>快速成功</strong>：第一个 fulfill 立即 resolve 整体</li>
<li><strong>AggregateError</strong>：全部失败时，聚合所有错误</li>
<li><strong>乐观策略</strong>：优先寻找成功路径</li>
</ol>
<h3 data-id="heading-11">实现</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myAny</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">iterable</span>) {
  <span class="hljs-keyword">if</span> (iterable == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] !== <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
  }

  <span class="hljs-keyword">const</span> promises = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iterable);
  <span class="hljs-keyword">if</span> (promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>([], <span class="hljs-string">"All promises were rejected"</span>)
    );
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> errors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promises.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">let</span> settledCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> resolved = <span class="hljs-literal">false</span>;

    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
          <span class="hljs-keyword">if</span> (!resolved) {
            resolved = <span class="hljs-literal">true</span>;
            <span class="hljs-title function_">resolve</span>(value); <span class="hljs-comment">// 第一个成功即返回</span>
          }
        })
        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
          errors[index] = reason;
          settledCount++;
          <span class="hljs-keyword">if</span> (settledCount === promises.<span class="hljs-property">length</span> &amp;&amp; !resolved) {
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(errors, <span class="hljs-string">"All promises were rejected"</span>));
          }
        });
    });
  });
};
</code></pre>
<hr/>
<h2 data-id="heading-12">3️.<code>Promise.race()</code>：选择器 / 锁存器（Selector / Latch）</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 逻辑表达式: OUTPUT = FIRST_SETTLED(INPUT₁, INPUT₂, ..., INPUTₙ)</span>
<span class="hljs-comment">// 输出等于第一个 settled（fulfilled 或 rejected）的输入</span>
</code></pre>
<h3 data-id="heading-13">逻辑门类比</h3>
<ul>
<li><strong>选择器特性</strong>：捕获第一个变化的信号</li>
<li><strong>对应行为</strong>：谁先 settle（无论成功/失败），谁决定结果</li>
<li><strong>典型场景</strong>：超时控制、竞态请求、最快响应获取</li>
</ul>
<h3 data-id="heading-14">行为表</h3>




















<table><thead><tr><th>第一个 settled</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td>fulfilled</td><td>成功</td><td>返回其值</td></tr><tr><td>rejected</td><td>失败</td><td>抛出其错误</td></tr></tbody></table>
<h3 data-id="heading-15">特性</h3>
<ol>
<li><strong>赢家通吃</strong>：第一个 settle 的 Promise 决定一切</li>
<li><strong>忽略后续</strong>：其余 Promise 被丢弃（但仍在后台运行）</li>
<li><strong>非确定性</strong>：结果取决于执行时序</li>
</ol>
<h3 data-id="heading-16">实现</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myRace</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">iterable</span>) {
  <span class="hljs-keyword">if</span> (iterable == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] !== <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
  }

  <span class="hljs-keyword">const</span> promises = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iterable);
  <span class="hljs-comment">// 规范：Promise.race([]) 永远 pending</span>
  <span class="hljs-keyword">if</span> (promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> {}); <span class="hljs-comment">// 永不 settle</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item).<span class="hljs-title function_">then</span>(resolve, reject);
    });
  });
};
</code></pre>
<hr/>
<h2 data-id="heading-17">4️.<code>Promise.allSettled()</code>：状态收集器（State Collector）</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 逻辑表达式: OUTPUT = COLLECT(STATUS(INPUT₁), ..., STATUS(INPUTₙ))</span>
<span class="hljs-comment">// 收集所有 Promise 的最终状态，永不 reject</span>
</code></pre>
<h3 data-id="heading-18">逻辑门类比</h3>
<ul>
<li><strong>状态寄存器</strong>：记录每一位的最终状态，不做逻辑运算</li>
<li><strong>对应行为</strong>：等待所有 Promise settle，返回完整状态快照</li>
<li><strong>典型场景</strong>：批量任务日志、结果分析、容错汇总</li>
</ul>
<h3 data-id="heading-19">输出</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 成功</span>
{ <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: result }

<span class="hljs-comment">// 失败</span>
{ <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: error } 
</code></pre>
<h3 data-id="heading-20">特性</h3>
<ol>
<li><strong>永不失败</strong>：返回的 Promise 总是 fulfilled</li>
<li><strong>完整诊断</strong>：每个 Promise 的状态和数据都可追溯</li>
<li><strong>无短路</strong>：必须等所有 Promise settle</li>
</ol>
<h3 data-id="heading-21">规范</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myAllSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">iterable</span>) {
  <span class="hljs-keyword">if</span> (iterable == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] !== <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
  }

  <span class="hljs-keyword">const</span> promises = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iterable);
  <span class="hljs-keyword">if</span> (promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>([]);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promises.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">let</span> completedCount = <span class="hljs-number">0</span>;

    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(item)
        .<span class="hljs-title function_">then</span>(
          <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
            result[index] = { <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">FULFILLED</span>, value };
          },
          <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
            result[index] = { <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">REJECTED</span>, reason }; 
          }
        )
        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
          completedCount++;
          <span class="hljs-keyword">if</span> (completedCount === promises.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(result);
        });
    });
  });
};
</code></pre>
<hr/>
<h2 data-id="heading-22">四方法对比矩阵</h2>













































<table><thead><tr><th>方法</th><th>逻辑类比</th><th>成功条件</th><th>失败条件</th><th>输出类型</th><th>是否短路</th></tr></thead><tbody><tr><td><code>Promise.all</code></td><td>AND 门</td><td>全部成功</td><td>任一失败</td><td>值数组</td><td>✅（失败）</td></tr><tr><td><code>Promise.any</code></td><td>OR 门</td><td>任一成功</td><td>全部失败</td><td>单个值</td><td>✅（成功）</td></tr><tr><td><code>Promise.race</code></td><td>选择器</td><td>第一个成功</td><td>第一个失败</td><td>单个值</td><td>✅</td></tr><tr><td><code>Promise.allSettled</code></td><td>状态寄存器</td><td>总是成功</td><td>永不失败</td><td>状态对象数组</td><td>❌</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-23">高级组合模式（异步“组合电路”）</h2>
<h3 data-id="heading-24">1. 带超时的 AND 运算</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">allWithTimeout</span>(<span class="hljs-params">promises, timeoutMs</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([
    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Timeout'</span>)), timeoutMs)
    )
  ]);
}
<span class="hljs-comment">// 电路：AND 门 + 超时选择器</span>
</code></pre>
<h3 data-id="heading-25">2. 多数表决电路（Majority Vote）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">majority</span>(<span class="hljs-params">promises</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> successes = results.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">status</span> === <span class="hljs-string">'fulfilled'</span>);
    <span class="hljs-keyword">const</span> failures = results.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">status</span> === <span class="hljs-string">'rejected'</span>);

    <span class="hljs-keyword">if</span> (successes.<span class="hljs-property">length</span> &gt; failures.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">return</span> successes.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">value</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(
        failures.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f.<span class="hljs-property">reason</span>),
        <span class="hljs-string">'Majority of promises rejected'</span>
      );
    }
  });
}
<span class="hljs-comment">// 电路：状态寄存器 + 比较器 + 选择器</span>
</code></pre>
<h3 data-id="heading-26">3. 优先级仲裁器（顺序尝试）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">priorityArbitrator</span>(<span class="hljs-params">promiseFactories</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> factory <span class="hljs-keyword">of</span> promiseFactories) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">factory</span>();
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 尝试下一个</span>
    }
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'All attempts failed'</span>);
}
<span class="hljs-comment">// 电路：优先级编码器 + OR 门</span>
</code></pre>
<hr/>
<p>通过逻辑门视角理解 Promise 组合方法，我们能：</p>
<ol>
<li><strong>建立直觉模型</strong>：将抽象异步流映射到熟悉电路概念</li>
<li><strong>预测行为</strong>：像分析真值表一样推理复杂异步逻辑</li>
<li><strong>设计新模式</strong>：借鉴电路设计思想构建自定义控制流</li>
<li><strong>调试优化</strong>：识别“短路点”、“竞争条件”、“状态丢失”等问题</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>