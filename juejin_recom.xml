<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[优雅地控制Python循环：break与continue的最佳实践及底层逻辑]]></title>    <link>https://juejin.cn/post/7593252939708497956</link>    <guid>https://juejin.cn/post/7593252939708497956</guid>    <pubDate>2026-01-10T15:38:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593252939708497956" data-draft-id="7593198957985169449" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="优雅地控制Python循环：break与continue的最佳实践及底层逻辑"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-10T15:38:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="love_summer"/> <meta itemprop="url" content="https://juejin.cn/user/1462819851084228"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            优雅地控制Python循环：break与continue的最佳实践及底层逻辑
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1462819851084228/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    love_summer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:38:12.000Z" title="Sat Jan 10 2026 15:38:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:18px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:40px;margin-bottom:20px;color:#007fff;display:flex;align-items:center}.markdown-body h1:hover:before,.markdown-body h2:hover:before,.markdown-body h3:hover:before,.markdown-body h4:hover:before,.markdown-body h5:hover:before,.markdown-body h6:hover:before{transition:All .4s ease-in-out;transform:rotate(1turn)}.markdown-body h1{font-size:30px;background:linear-gradient(#fff 60%,#c6e3ff 0)}.markdown-body h1:before{content:"";display:inline-block;width:32px;height:32px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h2{font-size:24px;background:linear-gradient(#fff 60%,#cce3fb 0)}.markdown-body h2:before{content:"";display:inline-block;width:24px;height:24px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h3{font-size:20px}.markdown-body h3:before{content:"";display:inline-block;width:18px;height:18px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h4{font-size:18px}.markdown-body h4:before{content:"";display:inline-block;width:16px;height:16px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h5{font-size:16px}.markdown-body h5:before{content:"";display:inline-block;width:15px;height:15px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h6{font-size:14px}.markdown-body h6:before{content:"";display:inline-block;width:12px;height:12px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{border-bottom:2px solid #007fff;color:#007fff;padding-right:10px}.markdown-body p{letter-spacing:1px;line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:10px auto}.markdown-body hr{border:none;border-top:1px dashed #92c8ff}.markdown-body hr:before{content:"✂";display:inline-block;position:relative;top:-12px;left:40px;padding:0 3px;color:#007fff;font-size:18px}.markdown-body hr:after{content:"按虚线剪开";position:relative;top:-15px;left:84%;padding:0 3px;color:#007fff;font-size:12px}.markdown-body del{color:#f44}.markdown-body em{color:#007fff;margin:0 2px}.markdown-body strong{color:#007fff;font-weight:bolder}.markdown-body code{word-break:break-word;border-radius:4px;overflow-x:auto;background-color:#e6f3ff;color:#007fff;font-weight:600;font-size:16px;padding:.065em .4em;border:1px solid #007fff}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:5px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:18px;font-weight:400;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8;border:none}.markdown-body a{text-decoration:none;color:#007fff;border-bottom:1px solid #007fff}.markdown-body a:before{content:"¶";margin-right:5px;font-size:22px}.markdown-body a:after{content:"↷";margin-left:2px;font-size:22px;display:none}.markdown-body a:active,.markdown-body a:hover{color:#275b8c;border-bottom:1px solid #275b8c}.markdown-body a:active:after,.markdown-body a:hover:after{display:inline-block}.markdown-body table{display:inline-block!important;font-size:16px;width:auto;max-width:100%;overflow:auto;border:1px solid #a5d3ff}.markdown-body thead{background:#c6e3ff;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#eef7ff}.markdown-body tbody&gt;tr:nth-child(odd){background-color:#f8fcff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #007fff;background-color:#eef7ff}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#007fff}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="srcery">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#1c1b19;color:#fce8c3}.hljs-emphasis,.hljs-strong{color:#918175}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ff5c8f}.hljs-code,.hljs-selector-class{color:#68a8e4}.hljs-emphasis{font-style:italic}.hljs-attribute,.hljs-keyword,.hljs-section,.hljs-selector-tag,.hljs-variable{color:#ef2f27}.hljs-name,.hljs-title{color:#fbb829}.hljs-params,.hljs-type{color:#0aaeb3}.hljs-string{color:#98bc37}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-subst,.hljs-symbol,.hljs-template-tag,.hljs-template-variable{color:#c07abe}.hljs-comment,.hljs-deletion,.hljs-meta{color:#918175}</style><blockquote>
<p><strong>【引言】</strong><br/>
在编写循环逻辑时，我们经常需要根据特定条件改变程序的执行流。Python提供了<code>break</code>和<code>continue</code>两个关键字来赋予循环“判断力”。虽然它们都是控制流语句，但在底层逻辑和适用场景上有着本质的区别。本文结合实际案例（参考Python基础教程4.3），深入剖析二者的差异及最佳实践。</p>
</blockquote>
<h4 data-id="heading-0">一、break：破坏者模式</h4>
<p><code>break</code>是最常见的循环控制语句。当Python解释器在循环体中遇到<code>break</code>时，会立即终止当前的循环层，并将执行权交给循环之后的代码。</p>
<p><strong>1. 核心场景：查找与退出</strong></p>
<p><code>break</code>最常见的用法是“搜索模式”。一旦满足目标，立即停止搜索，这在性能上至关重要。</p>
<ul>
<li><strong>场景A：累加溢出监测</strong></li>
</ul>
<p>在计算累加和时，如果超过某个阈值（比如20），应该立即停止计算，防止溢出或浪费资源。</p>
<pre><code class="hljs language-python" lang="python">```python
s = <span class="hljs-number">0</span>
i = <span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">11</span>:
    s += i
    <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">20</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'累加和大于20的当前数<span class="hljs-subst">{i}</span>'</span>)
        <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 达到阈值，立即退出</span>
    i += <span class="hljs-number">1</span>
```
</code></pre>
<ul>
<li><strong>场景B：登录验证与资源释放</strong></li>
</ul>
<p>在用户认证逻辑中，一旦验证通过（<code>user_name == 'ysj' and pwd == '888888'</code>），就应该使用<code>break</code>跳出循环，避免无效的迭代尝试。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28fe9f3fd0f24f9996ae21b79d89b76c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbG92ZV9zdW1tZXI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768664292&amp;x-signature=tHcfv57Jf8E%2BV10oARUURFbqq4o%3D" alt="image.png" loading="lazy"/>
<strong>2. 与<code>for...else</code>的联动（重要）</strong></p>
<p>很多开发者容易忽略一点：<code>break</code>会阻止<code>else</code>语句块的执行。<code>else</code>块只有在循环正常遍历结束时才会执行。如果循环是被<code>break</code>终止的，<code>else</code>块将被跳过。这对于判断“循环是否被强制中断”非常有用。</p>
<h4 data-id="heading-1">二、continue：迭代器模式</h4>
<p><code>continue</code>并不是终止循环，而是跳过当前迭代的剩余部分。它的作用是将控制权直接带回循环的开头，进行下一次条件判断或取下一个元素。</p>
<p><strong>1. 核心场景：条件过滤</strong></p>
<p><code>continue</code>非常适合用于“过滤器”模式。我们需要遍历一堆数据，但只处理符合条件的一部分。</p>
<ul>
<li><strong>实战案例：计算偶数和</strong></li>
</ul>
<p>使用<code>continue</code>来过滤掉奇数，比在循环体内部写大量的<code>if...else</code>嵌套要优雅得多。</p>
<pre><code class="hljs language-ini" lang="ini">```python
<span class="hljs-attr">s</span> = <span class="hljs-number">0</span>
for i in range(1, 101):
    if i % <span class="hljs-attr">2</span> == <span class="hljs-number">1</span>:
        continue  <span class="hljs-comment"># 过滤奇数，直接进入下一次迭代</span>
    s += i
print('1-100之间的偶数和:', s)
```
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3c75420e3294cf1acc8b13312e2e7c5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbG92ZV9zdW1tZXI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768664292&amp;x-signature=eLxKVm%2BqQmwt%2FmL07ro8owy3LdI%3D" alt="image.png" loading="lazy"/>
<em>对比写法</em>：如果不使用<code>continue</code>，你可能需要写成<code>if i % 2 == 0: s += i</code>。这在逻辑上没问题，但如果<code>else</code>块里的代码很长，缩进会很深，影响可读性。<code>continue</code>能让代码保持“扁平化”。</p>
<p><strong>2. while循环中的陷阱</strong></p>
<p>在使用<code>while</code>配合<code>continue</code>时要格外小心。如果跳过了改变循环变量的代码（如<code>i += 1</code>），很容易导致<strong>死循环</strong>。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">100</span>:
    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
        i += <span class="hljs-number">1</span>  <span class="hljs-comment"># 必须在continue之前改变变量！</span>
        <span class="hljs-keyword">continue</span>
    s += i
    i += <span class="hljs-number">1</span>
</code></pre>
<h4 data-id="heading-2">三、总结与建议</h4>




















<table><thead><tr><th align="left">特性</th><th align="left"><code>break</code></th><th align="left"><code>continue</code></th></tr></thead><tbody><tr><td align="left"><strong>目标</strong></td><td align="left">退出整个循环</td><td align="left">跳过本次循环</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">避免无效计算，提升性能</td><td align="left">过滤无效数据，保持代码整洁</td></tr></tbody></table>
<p><strong>最佳实践建议</strong>：</p>
<ol>
<li>优先使用 <code>for</code> 循环来遍历集合，并在其中使用 <code>continue</code> 进行过滤。</li>
<li>在 <code>while</code> 循环中处理状态机（如登录、Socket通信）时，使用 <code>break</code> 处理“成功/失败”的退出逻辑。</li>
<li>永远不要在 <code>while</code> 循环中忘记在 <code>continue</code> 前更新循环变量。
掌握这两个语句，你就能写出更高效、更Pythonic的循环代码。</li>
</ol>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【前端性能优化】指标篇：卡顿率——如何去定义你的页面卡不卡]]></title>    <link>https://juejin.cn/post/7593262196844134452</link>    <guid>https://juejin.cn/post/7593262196844134452</guid>    <pubDate>2026-01-10T10:32:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593262196844134452" data-draft-id="7593258683750301730" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【前端性能优化】指标篇：卡顿率——如何去定义你的页面卡不卡"/> <meta itemprop="keywords" content="性能优化"/> <meta itemprop="datePublished" content="2026-01-10T10:32:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="上课摸鱼的喵酱"/> <meta itemprop="url" content="https://juejin.cn/user/4253359486547133"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【前端性能优化】指标篇：卡顿率——如何去定义你的页面卡不卡
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4253359486547133/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    上课摸鱼的喵酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T10:32:25.000Z" title="Sat Jan 10 2026 10:32:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近有大量用户反馈，使用我们的平台实在是太卡了。所以于是总监大手一挥，“咱们这个Q必须得做性能优化，如果用户用咱们的平台都卡、用户怎么可能乐意来消费呢？”</p>
<p>我大声反驳“用户用起来卡是因为用户的电脑太差了，换台性能好点的电脑就不卡了”</p>
<p align="right">———以上是我的幻想</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c836af00976491e9288dc48407d5686~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiK6K--5pG46bG855qE5Za16YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768645944&amp;x-signature=VhW21Bohpcgyf0LwUtiTAFNbd1A%3D" alt="1.jpeg" loading="lazy"/></p>
<p>于是乎在组里大佬的带领下、吭哧吭哧搞了一个Q，就有了性能优化一系列的文章；</p>
<p><strong>事先声明、作为一个刚毕业一年多的前端菜狗、这个东西肯定不是我搞出来的、这个得感谢公司里的前辈、做了完善的监控机制，打好了基础架构；才能让我在前端的海洋里不停溺水又浮起来，然后继续溺水。。。。</strong></p>
<h2 data-id="heading-0">如何去定义性能指标？</h2>
<p>首先、我们的项目是一个普普通通的web端的项目；那怎么去看一个网页它的性能呢？诶这个时候肯定有同学说了，这个我知道lighthouse来一波，常用的性能指标：FP、FCP、CLS等看一看、再看看白屏时间啥的； 在掘金里搜前端性能优化、大部分都是这个方向的内容；</p>
<p>也不能说这些东西是错的、但是有几个问题：</p>
<ol>
<li>lighthouse在不同性能的电脑上结果不一样，不能当作一个可以锚定的指标。</li>
<li>用常用的性能指标来作为标准？这么多个指标怎么去平衡这些指标呢？定一个比例？还是就选取几个？</li>
<li><strong>其实最重要的是老板可能不知道你的性能指标是什么东西，如果+1或者+2是rd/qa/pm升上去的，你对着老板说我们使用FCP首次内容绘制来定义性能；老板：“啥？你在说什么玩意？” 咱打工人 到最后都是为了满足那个okr嘛，老板都不理解你在搞什么东西，这绩效还要吗。。。</strong></li>
</ol>
<p>所以有没有办法去整一个指标，既能让非前端人员简单易懂，又能比较能表达性能呢？</p>
<p>有的，兄弟，有的。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efbd06f9424a43608edf53205b55fc5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiK6K--5pG46bG855qE5Za16YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768645944&amp;x-signature=Fs1ecuL%2BzPagR6DH5sAT%2F5WWQRE%3D" alt="2.jpeg" loading="lazy"/></p>
<h2 data-id="heading-1">卡顿率</h2>
<h3 data-id="heading-2">什么是卡顿率？</h3>
<p>先来一段文绉绉的定义：<strong>卡顿率</strong>用于衡量用户在使用页面过程中，画面无法以正常帧率持续渲染的时间占比，是一个反映页面<strong>整体流畅性体验</strong>的百分比指标。</p>
<p>一句话来概括就是：卡顿率表示用户在可感知使用页面的过程中，有多大比例的时间画面处于“卡住”的状态。</p>
<p>这下其他岗位的同学也能听懂了，就是我在使用某个页面的时间里，有多长时间的占比卡了嘛；</p>
<h3 data-id="heading-3">怎么统计卡顿率？</h3>
<h4 data-id="heading-4">卡顿率的简单分类</h4>
<p>目前卡顿率分为三种类型：</p>
<ul>
<li>时间卡顿率：卡顿时间 / 总观察时间；
<ul>
<li>卡顿率 = Long Task 总耗时 / 总时长</li>
</ul>
</li>
<li>交互卡顿率：交互的卡顿次数 / 交互总次数；
<ul>
<li>100 次点击，其中 12 次发生 Long Task，就认为卡顿率 = 12%</li>
</ul>
</li>
<li>Task卡顿率
<ul>
<li>Long Task 次数 / 总 Task 次数</li>
</ul>
</li>
</ul>
<p>目前我们使用的是时间卡顿率、也就是第一种；</p>
<h4 data-id="heading-5">卡顿时间的优化</h4>
<p>W3C 标准里提出，任何在主线程上执行时间超过 <strong>50 毫秒 (ms)</strong> 的任务都被定义为 Long Task。
也就是说：单次 task &gt; 50ms 就算长任务，就应该算入卡顿时间。</p>
<p>对吗？？？</p>
<p>从前端的角度来看，对的对的。但是从用户的感受来看，卡50ms，好像也感觉不出来？</p>
<p>现在屏幕的理想刷新率一般是60帧每秒，1000/60=16.7ms； 50/16.7约等于3帧；于是我们加上了一个前提条件：连续三帧都有长任务并且被完全阻塞，才会算做卡顿。</p>
<p>（一帧能用，两帧流畅，三帧电竞。。。。）</p>
<p><strong>注意点：</strong>  这里的有长任务不是说我只要碰到0.1ms都算，而是完全占满才算；</p>
<p>todo：补一张图，拿nano banana跑了几次出来的图都不可用，还得自己画。。 大概长这样：</p>
<p>Frame 0: [0 ----- 16.7] （ms）</p>
<p>Frame 1: [16.7 -- 33.4]</p>
<p>Frame 2: [33.4 -- 50.1]</p>
<p>Frame 3: [50.1 -- 66.8]</p>
<p>Long Task [10ms ------------------------- 61ms] 长任务耗时51ms，可能从frame0的中间开始，frmae3的中间结束</p>
<p><strong>因为我们部分占用并不代表着会影响帧渲染，当然也不一定能保证说剩下的时间就一定够渲染；比如占用6ms，剩下的10ms不能确定能不能完成渲染；目前也没有办法去统计是非完成渲染，所以我们只统计一定被占满的帧，去减少噪音；</strong></p>





















<table><thead><tr><th>情况</th><th>渲染统计</th></tr></thead><tbody><tr><td>帧完全落在 Long Task 内</td><td>100% 无法渲染</td></tr><tr><td><strong>帧部分落在 Long Task 内</strong></td><td><strong>不确定，忽略不计</strong></td></tr><tr><td>帧未落在 Long Task 内</td><td>不影响</td></tr></tbody></table>
<h4 data-id="heading-6">总观察时间</h4>
<p>为什么叫做总观察时间而不是总时间，这个也好理解；</p>
<p>如果页面处于前台、用户操作，那必须得记录；</p>
<p>如果用户失焦了、点到了别的标签，这里后台可能会开始执行一些动作比如上报埋点数据、这个时候因为用户看不到，所以就算发生了长任务也不计入；</p>
<p>又或者是进入了下一个界面，当前界面冻结了，过了一会点了回退；中间这段时间就得排除，因为实际上在这段时间里，没有做任何的交互，不做排除会导致分母变大，数据失真；</p>
<h2 data-id="heading-7">伪代码部分</h2>
<p>那么其实我们要做的就很明显了：</p>
<p>卡顿率 = 页面处于前台、用户可感知期间，画面被连续 ≥3 帧阻塞的时间 / 可感知总时间</p>
<h4 data-id="heading-8">核心常量 &amp; 状态</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FRAME_TIME</span> = <span class="hljs-number">16.7</span>;           <span class="hljs-comment">// 一帧时间</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STALL_FRAMES</span> = <span class="hljs-number">3</span>;            <span class="hljs-comment">// 连续三帧算卡顿</span>

<span class="hljs-keyword">let</span> longTasks = [];

<span class="hljs-comment">// 统计页面的可感知时间</span>
<span class="hljs-keyword">let</span> observing = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> lastActiveTime = performance.<span class="hljs-title function_">now</span>();
<span class="hljs-keyword">let</span> activeTime = <span class="hljs-number">0</span>;

<span class="hljs-comment">// 卡顿时间</span>
<span class="hljs-keyword">let</span> stallTime = <span class="hljs-number">0</span>;

<span class="hljs-comment">// 是否结束统计</span>
<span class="hljs-keyword">let</span> finalized = <span class="hljs-literal">false</span>;

</code></pre>
<h4 data-id="heading-9">Long Task的监听</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> longTaskObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!observing) <span class="hljs-keyword">return</span>;

  list.<span class="hljs-title function_">getEntries</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    longTasks.<span class="hljs-title function_">push</span>({
      <span class="hljs-attr">start</span>: entry.<span class="hljs-property">startTime</span>,
      <span class="hljs-attr">duration</span>: entry.<span class="hljs-property">duration</span>
    });
  });
});

longTaskObserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'longtask'</span>] });

</code></pre>
<h4 data-id="heading-10">用Long Task计算出完整占用帧数的时间</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBlockedFrameCount</span>(<span class="hljs-params">task</span>) {
  <span class="hljs-keyword">const</span> startFrame = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(task.<span class="hljs-property">start</span> / <span class="hljs-variable constant_">FRAME_TIME</span>);
  <span class="hljs-keyword">const</span> endFrame = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(
    (task.<span class="hljs-property">start</span> + task.<span class="hljs-property">duration</span>) / <span class="hljs-variable constant_">FRAME_TIME</span>
  );

  <span class="hljs-comment">// 只计算完整被占用的帧</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, endFrame - startFrame - <span class="hljs-number">1</span>);
}

</code></pre>
<h4 data-id="heading-11">用visibilitychange和pagehide监听，排除标签切走/最小化/页面冻结的时间</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> now = performance.<span class="hljs-title function_">now</span>();

  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">hidden</span>) {
    <span class="hljs-keyword">if</span> (observing) {
      activeTime += now - lastActiveTime;
      observing = <span class="hljs-literal">false</span>;
    }
  } <span class="hljs-keyword">else</span> {
    lastActiveTime = now;
    observing = <span class="hljs-literal">true</span>;
  }
});

<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'pagehide'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">persisted</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-title function_">finalize</span>();
});

<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'pageshow'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">persisted</span>) {
    lastActiveTime = performance.<span class="hljs-title function_">now</span>();
    observing = <span class="hljs-literal">true</span>;
  }
});

</code></pre>
<h4 data-id="heading-12">结束统计</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">finalize</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (finalized) <span class="hljs-keyword">return</span>;
  finalized = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">const</span> now = performance.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">if</span> (observing) {
    activeTime += now - lastActiveTime;
  }

  longTasks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">task</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> blockedFrames = <span class="hljs-title function_">getBlockedFrameCount</span>(task);
    <span class="hljs-keyword">if</span> (blockedFrames &gt;= <span class="hljs-variable constant_">STALL_FRAMES</span>) {
      stallTime += blockedFrames * <span class="hljs-variable constant_">FRAME_TIME</span>;
    }
  });

  <span class="hljs-keyword">const</span> stallRate = activeTime &gt; <span class="hljs-number">0</span> ? (stallTime / activeTime) * <span class="hljs-number">100</span> : <span class="hljs-number">0</span>;

  <span class="hljs-title function_">report</span>({
    activeTime,
    stallTime,
    stallRate,
    <span class="hljs-attr">stallCount</span>: longTasks.<span class="hljs-title function_">filter</span>(
        <span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> <span class="hljs-title function_">getBlockedFrameCount</span>(t) &gt;= <span class="hljs-variable constant_">STALL_FRAMES</span>
    ).<span class="hljs-property">length</span>
  });

  longTaskObserver.<span class="hljs-title function_">disconnect</span>();
}

</code></pre>
<h2 data-id="heading-13">结语</h2>
<p>其实如果要把卡顿率做一个完整商用的sdk里的某个指标，除了本文提到的内容，缺失的部分还有很多，比如什么时候执行、什么时候发送，等等…… 这里只是搜了一下掘金发现前端性能优化这块没有找到相关内容，因此把在工作中学到的知识，简单总结了一下，感谢阅读。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa1bdf22fe654a8e9a183d0260aa33fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiK6K--5pG46bG855qE5Za16YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768645944&amp;x-signature=M6CfifNCUeie0kFH7lqaj%2FbyOGI%3D" alt="3.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[lecen：一个更好的开源可视化系统搭建项目--数据、请求、寄连对象使用--全低代码|所见即所得|利用可视化设计器构建你的应用系统-做一个懂你的人]]></title>    <link>https://juejin.cn/post/7593258683751006242</link>    <guid>https://juejin.cn/post/7593258683751006242</guid>    <pubDate>2026-01-10T11:34:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593258683751006242" data-draft-id="7593262196844216372" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="lecen：一个更好的开源可视化系统搭建项目--数据、请求、寄连对象使用--全低代码|所见即所得|利用可视化设计器构建你的应用系统-做一个懂你的人"/> <meta itemprop="keywords" content="低代码,前端,后端"/> <meta itemprop="datePublished" content="2026-01-10T11:34:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="晴虹"/> <meta itemprop="url" content="https://juejin.cn/user/976022057782280"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            lecen：一个更好的开源可视化系统搭建项目--数据、请求、寄连对象使用--全低代码|所见即所得|利用可视化设计器构建你的应用系统-做一个懂你的人
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976022057782280/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    晴虹
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T11:34:08.000Z" title="Sat Jan 10 2026 11:34:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">基本定义</h2>
<p>前端系统主要由在线编写代码与可视化操作两种方式来构建。页面结构主要通过在线可视化拖拽组合生成，一些页面元素model的绑定及交互事件通过在元素属性面板编辑来操作。</p>
<p>我们提供了多个数据源来获取需要的数据，由于数据类型的不同，我们使用对象来对他们进行分类管理。</p>
<p>从功能性上主要分为下面几类：</p>
<p>属性值、预置函数、寄连、视图、元素、工具类。</p>
<p>由于细分下来属性特别多。因此我们通过不同的对象来对这些值进行访问。</p>






























<table><thead><tr><th>名称</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>B</td><td>基础对象</td><td>包含initData，collectionData等</td></tr><tr><td>G</td><td>全局对象</td><td>包含page，menu，user等</td></tr><tr><td>R</td><td>请求链接对象</td><td>包含一些链接调用的方法和属性</td></tr><tr><td>P</td><td>执行寄连对象</td><td>包含一些寄连调取的方法和属性</td></tr></tbody></table>
<p>几乎所有的变量都能够通过这四个对象访问到，每个页面都有自己的 <code>B</code>、<code>G</code>、<code>R</code>、<code>P</code> 对象，除了 <code>G</code> 之外，不同页面之间的 <code>B</code>、<code>R</code>、<code>P</code> 对象都是相互独立的</p>
<p>这四个对象既可以独立访问，也可以在某个对象中访问另一个对象</p>
<p>页面中所有的地方都能够访问这些对象，所有可以写脚本的地方都能通过 <code>this</code> 来获取这些变量</p>
<p>除了当前页面下的公共对象之外，还有两个对象是只在当前组件的事件中能访问到的属性</p>




















<table><thead><tr><th>名称</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>describe</td><td>当前组件视图配置</td><td>包含了渲染该组建所需的所有配置</td></tr><tr><td>scopeData</td><td>渲染数据</td><td>当前作用域插槽的数据</td></tr></tbody></table>
<h2 data-id="heading-1">数据对象</h2>
<h3 data-id="heading-2">initData</h3>
<p>该对象主要存储一些初始化数据，一般情况下它的属性值不会发生变化，可以通过寄连、请求的方式进行设定，我们也可以手动指定初始化的数据，供之后访问、比较等操作。</p>
<p>该对象并没有严格的限制说能够存储哪些数据，只是约定好只存储页面初始化数据，或者一些其他的信息等</p>
<p><code>initData</code> 在页面加载的时候，会默认填充两个属性：<code>formCode</code> 和 <code>serviceTable</code>，分别表示当前页面的编码和当前页面存储的数据表</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f76fe8d81ac4435d89c872f4557f1ea0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm06Jm5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649648&amp;x-signature=QR6UV9%2F6ATgoANy71BDTyD1mWzY%3D" alt="initData默认填充" loading="lazy"/></p>
<p>然后我们可以在任意其他位置对它进行设定</p>
<p>比如我们创建一个请求链接，然后在回调函数里面把接口的返回值放到 <code>initData</code> 里面</p>
<p>请求链接的回调函数里面写上 <code>this.B.setInitData(data)</code></p>
<p>先看下接口的返回值：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/398bb796fb8d45c5800d24bf105b8d99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm06Jm5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649648&amp;x-signature=JPLDGfQ9qMd%2F2TbQWZ4CnVkbwGI%3D" alt="接口返回值" loading="lazy"/></p>
<p>给页面添加该接口之后，接口调用完毕会执行回调函数，将数据填充到 <code>initData</code> 中</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f25d64e5faec430e9f087a7fe96bb36e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm06Jm5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649648&amp;x-signature=9w%2FtxF54Nyy4Fdv6lfZJtHSkp0s%3D" alt="initData赋值" loading="lazy"/></p>
<h3 data-id="heading-3">collectionData</h3>
<p>所有在视图中带有model字段的属性都会被收集到这个对象中，我们也可以给该对象赋值一些临时的其他属性，这样方便在别的地方都可以访问到。</p>
<p>详见 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Fguide%2FsystemPage%2FpageDesign.html%23model%25E7%25BB%2591%25E5%25AE%259A" target="_blank" title="http://lnsstyp.com/web/guide/systemPage/pageDesign.html#model%E7%BB%91%E5%AE%9A" ref="nofollow noopener noreferrer">collectionData收集model</a></p>
<h3 data-id="heading-4">requestData</h3>
<p>如果请求链接配置了绑定数据字段，那么通过请求返回的数据就会被存储到该对象中，它还包含了两个特殊的属性：</p>
<p><code>handle</code>：所有请求中如果设定了code，那么就会被保存在该对象中，以备之后手动触发请求。</p>
<p><code>code</code>：带有权限控制的code可以通过这个对象访问到，我们也可以手动指定code属性。</p>
<p>关于如何将请求链接返回的数据绑定到 <code>collectionData</code> 对象中，以及它们的绑定机制和手动触发请求，可参考 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Fguide%2FsystemPage%2Frequest.html%23%25E6%2596%25B0%25E5%25BB%25BA" target="_blank" title="http://lnsstyp.com/web/guide/systemPage/request.html#%E6%96%B0%E5%BB%BA" ref="nofollow noopener noreferrer">请求链接配置</a></p>
<p>关于 <code>requestData.code</code> 对象的作用和运行机制，可参考 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Freference%2Fcontrol.html%23code" target="_blank" title="http://lnsstyp.com/web/reference/control.html#code" ref="nofollow noopener noreferrer">权限控制</a></p>
<h3 data-id="heading-5">controlData</h3>
<p>页面中的所有数据视图都会以code为标识存储在该对象中，我们手动设定的dom和view也会通过它进行访问。</p>
<p>关于组件的 <code>dom</code> 和 <code>view</code> 设置规则和它们的使用方式，可参考 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Freference%2Fcontrol.html%23dom" target="_blank" title="http://lnsstyp.com/web/reference/control.html#dom" ref="nofollow noopener noreferrer">元素和视图的引用</a></p>
<h3 data-id="heading-6">setInitData(data)</h3>
<p>这是 <code>B</code> 对象暴露出来的用于设置 <code>initData</code> 对象的方法，直接传入需要设置的数据对象即可</p>
<h3 data-id="heading-7">setCollectionData(data)</h3>
<p>这是 <code>B</code> 对象暴露出来的用于设置 <code>collectionData</code> 对象的方法，直接传入需要设置的数据对象即可</p>
<h2 data-id="heading-8">请求链接对象</h2>
<p>管理页面中所有的请求链接。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6361930b23f54b22ba99cdb7293f22b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm06Jm5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649648&amp;x-signature=%2FUPhRiG7T75bTJ3fvRFrYT40qTM%3D" alt="请求链接对象" loading="lazy"/></p>
<p>每个 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Fguide%2FsystemPage%2Frequest.html" target="_blank" title="http://lnsstyp.com/web/guide/systemPage/request.html" ref="nofollow noopener noreferrer">请求链接</a> 的回调函数中的this都指向这个对象。</p>
<p>除了在请求链接中使用，在页面的其他任何地方都可以通过 <code>this.R</code> 拿到这个对象。</p>
<p>也可以通过这个对象获取到 <code>G</code>、<code>P</code>、<code>collectionData</code>、<code>controlData</code>、<code>requestData</code> 等等公共对象。</p>
<p>主要有以下方法：</p>
<ul>
<li>
<p>doCallBack：用于执行请求链接返回数据之后的回调函数</p>
</li>
<li>
<p>filterCancel：用于过滤掉被取消的请求</p>
</li>
<li>
<p>getLists：实际发起接口请求获取数据</p>
</li>
<li>
<p>initLists：根据请求链接的配置信息初始化请求</p>
</li>
<li>
<p>pitchRequest：根据请求策略拆分出不同的请求集合</p>
</li>
<li>
<p>prepare：发起实际请求之前的准备</p>
</li>
<li>
<p>request：管理一个请求从开始到结束的整个周期</p>
</li>
<li>
<p>setLists：根据请求链接的配置将返回的数据进行处理</p>
</li>
<li>
<p>trigger：根据请求编码发起请求</p>
</li>
</ul>
<p>除了 <code>prepare</code> 和 <code>trigger</code> 之外，其他方法均属于内部使用的方法，一般用不到</p>
<h3 data-id="heading-9">prepare</h3>
<p>这是一个请求预处理，主要用来在发起一个请求前做一些逻辑处理，比如设置参数等。</p>
<p>如果页面中的一个请求链接具有 <code>code</code> 值，那么通过调用 <code>prepare</code> 方法，传入对应请求的 <code>code</code>，就会对该请求进行初始化并返回一个 <code>promise</code>。</p>
<p>在then方法传递回来的参数是一个对象，其中包含两个属性：<code>request</code> 和 <code>run</code>。</p>
<p><code>request</code> 代表当前的请求，可以通过它修改参数或执行其他操作。</p>
<p><code>run</code> 是一个函数，执行之后将会发起真正的请求。</p>
<p>关于具体的使用方式可参照 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Fguide%2FsystemPage%2Frequest.html%23%25E8%25AF%25B7%25E6%25B1%2582%25E7%25BC%2596%25E7%25A0%2581" target="_blank" title="http://lnsstyp.com/web/guide/systemPage/request.html#%E8%AF%B7%E6%B1%82%E7%BC%96%E7%A0%81" ref="nofollow noopener noreferrer">请求编码</a></p>
<h3 data-id="heading-10">trigger</h3>
<p>根据传入的对应请求的 <code>code</code> 发起请求，主要是用来处理手动触发的请求。</p>
<p>具体的示例可见 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Fguide%2FsystemPage%2Frequest.html%23%25E8%25AF%25B7%25E6%25B1%2582%25E7%25BC%2596%25E7%25A0%2581" target="_blank" title="http://lnsstyp.com/web/guide/systemPage/request.html#%E8%AF%B7%E6%B1%82%E7%BC%96%E7%A0%81" ref="nofollow noopener noreferrer">请求编码</a></p>
<h2 data-id="heading-11">寄连对象</h2>
<p>用来管理页面中的执行寄连</p>

























<table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>bond</td><td>执行策略为before的寄连</td></tr><tr><td>doCallBack</td><td>自动执行指定的寄连</td></tr><tr><td>pitchBond</td><td>根据寄连策略拆分出不同的寄连集合</td></tr><tr><td>runIt</td><td>手动执行指定的寄连</td></tr></tbody></table>
<p>还有一个 <code>handle</code> 的对象属性和一个 <code>prepare</code> 的数组属性</p>
<p><code>handle</code> 主要用来存放需要手动执行的寄连</p>
<p><code>prepare</code> 存放了执行策略为before的寄连</p>
<h3 data-id="heading-12">RunIt</h3>
<p>通过它来手动执行寄连，第一个参数表示要执行的寄连 <code>code</code>，从第二个参数开始，都是要传入寄连函数的参数。</p>
<p>比如现在有一个编码为 <code>getAverage</code> 的寄连，它用来计算多个数的平均数，寄连内容如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4bcacf410870488d94837dac599eb71c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm06Jm5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649648&amp;x-signature=qBFDyU7yQnsgL4Jkz2nSjIB92Uw%3D" alt="计算平均数" loading="lazy"/></p>
<p>现在在一个按钮的点击事件里面来调用这个执行寄连</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ebc96920dd8a4661b7ea2778025471a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm06Jm5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649648&amp;x-signature=Ht9S9GmoE0VPvbMXlXxpaZUyiME%3D" alt="执行寄连" loading="lazy"/></p>
<p>点击按钮之后就会执行该寄连</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/440cbbbe468d4f2bbb2c73ecaf593367~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm06Jm5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649648&amp;x-signature=uq%2BrJx5C7C52T6LLszkd2GhzqbM%3D" alt="计算结果" loading="lazy"/></p>
<p>关于手动执行寄连的配置可参考 <a href="https://link.juejin.cn?target=http%3A%2F%2Flnsstyp.com%2Fweb%2Fguide%2FsystemPage%2FparasiticBond.html%23%25E5%25AF%2584%25E8%25BF%259E%25E6%2589%25A7%25E8%25A1%258C%25E7%25AD%2596%25E7%2595%25A5" target="_blank" title="http://lnsstyp.com/web/guide/systemPage/parasiticBond.html#%E5%AF%84%E8%BF%9E%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5" ref="nofollow noopener noreferrer">寄连执行策略</a></p>
<p>【项目体验】</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.lecen.top%2Fmanage" target="_blank" title="http://www.lecen.top/manage" ref="nofollow noopener noreferrer">系统管理端地址</a> ：<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.lecen.top%2Fmanage" target="_blank" title="http://www.lecen.top/manage" ref="nofollow noopener noreferrer">www.lecen.top/manage</a></p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.liudaxianer.com%2Fuser" target="_blank" title="http://www.liudaxianer.com/user" ref="nofollow noopener noreferrer">系统用户端地址</a> ：<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.liudaxianer.com%2Fuser" target="_blank" title="http://www.liudaxianer.com/user" ref="nofollow noopener noreferrer">www.liudaxianer.com/user</a></p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.lnsstyp.com%2Fweb" target="_blank" title="http://www.lnsstyp.com/web" ref="nofollow noopener noreferrer">系统文档地址</a> ：<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.lnsstyp.com%2Fweb" target="_blank" title="http://www.lnsstyp.com/web" ref="nofollow noopener noreferrer">www.lnsstyp.com/web</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零打造AI智能博客：一个项目带你入门全栈与大模型应用开发]]></title>    <link>https://juejin.cn/post/7593262196844249140</link>    <guid>https://juejin.cn/post/7593262196844249140</guid>    <pubDate>2026-01-10T11:58:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593262196844249140" data-draft-id="7593296804108779560" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从零打造AI智能博客：一个项目带你入门全栈与大模型应用开发"/> <meta itemprop="keywords" content="前端,AIGC"/> <meta itemprop="datePublished" content="2026-01-10T11:58:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SpringLament"/> <meta itemprop="url" content="https://juejin.cn/user/822855086907101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从零打造AI智能博客：一个项目带你入门全栈与大模型应用开发
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/822855086907101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SpringLament
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T11:58:17.000Z" title="Sat Jan 10 2026 11:58:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">写在前面</h2>
<p>最近 AI Coding 实在太火了，Cursor、Claude Code 这些工具让写代码变得越来越轻松。你可能也注意到了，这些工具都有一个共同点：在你写代码的时候，它们会实时给你补全建议，按 Tab 就能接受。这种体验太爽了，以至于我想在自己的博客编辑器里也搞一个类似的功能。</p>
<p>与此同时，「全栈开发」和「大模型应用开发」也成了很多人想要学习的方向。</p>
<p>我自己折腾了一个 Next.js 全栈 AI 博客项目，把 Prompt 工程、RAG 知识库、流式输出、AI Copilot 这些东西都实践了一遍。今天想通过这篇文章，把我在这个项目里学到的东西分享出来，希望能帮到想入门这个领域的朋友。</p>
<p><strong>GitHub 地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflawlessv%2FSpring-Broken-AI-Blog%2522" target="_blank" title="https://github.com/flawlessv/Spring-Broken-AI-Blog%22" ref="nofollow noopener noreferrer">github.com/flawlessv/S…</a></p>
<p><strong>🔗 线上地址</strong>：<a href="https://link.juejin.cn?target=http%3A%2F%2Fpowder.icu%2F" target="_blank" title="http://powder.icu/" ref="nofollow noopener noreferrer">powder.icu/</a></p>
<blockquote>
<p>本文主要讲述如何实现博客的AI相关功能，想了解基础功能如何实现的同学可以看下<a href="https://juejin.cn/post/7575112613779128354" target="_blank" title="https://juejin.cn/post/7575112613779128354">Next.js全栈开发从入门到部署实战</a></p>
</blockquote>
<p>先看看这个博客长什么样：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38591165cd3e4872b14a0458197f98bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU3ByaW5nTGFtZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652174&amp;x-signature=hkjEab%2FezuFSyeIiemwYXKf%2BZgQ%3D" alt="shouye.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/895d9a11a27a427e823e6a93fa9d00eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU3ByaW5nTGFtZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652174&amp;x-signature=pRxyOCaJohk1NPxSsh5TEGt%2B9dw%3D" alt="后台仪表盘.png" loading="lazy"/>
项目用的技术栈：</p>
<ul>
<li><strong>前端</strong>：Next.js 15 + TypeScript + shadcn/ui + Tailwind CSS</li>
<li><strong>后端</strong>：Next.js API Routes + Prisma ORM</li>
<li><strong>AI</strong>：Kimi API + Ollama + ChromaDB</li>
</ul>
<p>接下来我会从 Prompt 讲起，然后聊聊 AI Copilot、RAG、流式输出这些功能是怎么实现的。</p>
<hr/>
<h2 data-id="heading-1">一切的起点：Prompt</h2>
<p>说到大模型应用开发，绑不开的就是 Prompt。</p>
<p><strong>Prompt 是什么？</strong> 说白了就是你跟大模型说的话。你怎么问，它就怎么答。问得好，答案就靠谱；问得烂，答案就离谱。</p>
<p>我在做这个项目的时候发现，很多 AI 功能的本质都是一样的：<strong>构造一个 Prompt，然后调 LLM API</strong>。</p>
<p>比如：</p>
<ul>
<li>AI 生成文章标题？Prompt + LLM</li>
<li>AI 生成摘要？Prompt + LLM</li>
<li>AI 推荐标签？还是 Prompt + LLM</li>
</ul>
<p>所以想玩好大模型应用，Prompt 工程是必须要会的。</p>
<h3 data-id="heading-2">结构化 Prompt</h3>
<p>写 Prompt 其实跟写文章差不多，有结构会比乱写好很多。我在项目里用的是一种叫「结构化 Prompt」的写法，大概长这样：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Role: 你的角色</span>

<span class="hljs-section">## Profile</span>

<span class="hljs-bullet">-</span> Author: xxx
<span class="hljs-bullet">-</span> Version: 1.0
<span class="hljs-bullet">-</span> Language: 中文
<span class="hljs-bullet">-</span> Description: 角色描述

<span class="hljs-section">## Skills</span>

<span class="hljs-bullet">-</span> 技能1
<span class="hljs-bullet">-</span> 技能2

<span class="hljs-section">## Rules</span>

<span class="hljs-bullet">1.</span> 规则1
<span class="hljs-bullet">2.</span> 规则2

<span class="hljs-section">## Workflow</span>

<span class="hljs-bullet">1.</span> 第一步做什么
<span class="hljs-bullet">2.</span> 第二步做什么

<span class="hljs-section">## OutputFormat</span>

<span class="hljs-bullet">-</span> 输出格式要求

<span class="hljs-section">## Initialization</span>

作为 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Role</span>&gt;</span></span>，严格遵守 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Rules</span>&gt;</span></span>，按照 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Workflow</span>&gt;</span></span> 执行任务。
</code></pre>
<p>这种写法的好处是逻辑清晰，大模型更容易理解你想要什么。</p>
<p>举个实际的例子，这是我项目里用来生成文章摘要的 Prompt：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildExcerptPrompt</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`# Role: 内容摘要撰写专家

## Profile
- Author: Spring Broken AI Blog
- Version: 2.0
- Language: 中文
- Description: 你是一位专业的内容编辑，擅长从长文中提取核心信息，撰写简洁有力的摘要。

## Rules
1. 摘要长度必须严格控制在 100-200 个汉字之间
2. 必须包含文章的核心观点和主要结论
3. 使用简洁、专业的语言，避免冗余表达
4. 只返回摘要文本，不要包含任何其他内容

## Workflow
1. 仔细阅读并理解完整的文章内容
2. 识别文章的核心主题和主要论点
3. 用简洁的语言组织摘要
4. 输出纯文本摘要

## Input
文章内容：
<span class="hljs-subst">${content.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3000</span>)}</span>

## Initialization
作为 &lt;Role&gt;，严格遵守 &lt;Rules&gt;，按照 &lt;Workflow&gt; 撰写摘要。`</span>;
}
</code></pre>
<p>你看，其实就是告诉大模型：你是谁、要遵守什么规则、按什么流程做事、输出什么格式。把这些说清楚了，大模型的输出质量会好很多。</p>
<hr/>
<h2 data-id="heading-3">AI Copilot：编辑器里的智能补全</h2>
<p>这个功能是我觉得最有意思的一个，效果类似 GitHub Copilot 或者 Cursor，在你写文章的时候实时给你补全建议。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08670e6f6784457aa015edff46d14265~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU3ByaW5nTGFtZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652174&amp;x-signature=5mD3zBJ0%2FZxDFf5KeKURbqUf4sc%3D" alt="AI文章新建和编辑页.png" loading="lazy"/></p>
<h3 data-id="heading-4">实现思路</h3>
<p>说穿了也不复杂：<strong>把文章上下文 + Prompt 丢给 LLM，让它帮你续写</strong>。</p>
<p>具体流程是这样的：</p>
<ol>
<li>用户在编辑器里打字</li>
<li>我提取光标前 500 个字符作为上下文</li>
<li>构造一个 Prompt，大意是「根据上下文，续写 5-30 个字」</li>
<li>调 Kimi API 拿到补全建议</li>
<li>把建议以灰色斜体显示在光标后面</li>
<li>用户按 Tab 接受，按 Esc 取消</li>
</ol>
<h3 data-id="heading-5">技术难点</h3>
<p>这个功能看起来简单，但实际做起来有几个坑：</p>
<p><strong>1. 非侵入式显示</strong></p>
<p>补全建议不能直接写入文档，只能在视图层显示。</p>
<p>我一开始想的就是用样式来实现——在光标位置叠加一个灰色斜体的文本，看起来像是补全建议，但实际上不是文档的一部分。这个思路是对的，关键是怎么实现。</p>
<p>参考了 VSCode 的做法。VSCode 的 AI 补全（GitHub Copilot）用的是「虚拟文本」机制：<strong>补全建议只在视图层显示，不写入文档模型</strong>。只有用户按 Tab 确认后，才真正写入。</p>
<p>我用的编辑器是 Tiptap（基于 ProseMirror），刚好有类似的机制叫 Decoration。它可以在视图层叠加显示内容，不影响文档结构，正好符合我的需求。</p>
<p><strong>2. 防抖</strong></p>
<p>用户打字很快的时候，不能每敲一个字就调一次 API，那样太浪费了。我设了 500ms 的防抖，用户停下来半秒钟才触发补全请求。</p>
<p><strong>3. 异步竞态</strong></p>
<p>用户可能在 API 返回之前又继续打字了，这时候光标位置已经变了。如果直接把补全建议显示出来，位置就对不上了。</p>
<p>我的做法是双重位置校验：发请求前记录光标位置，API 返回后再校验一次，位置变了就不显示。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 第一次校验：防抖回调执行时</span>
<span class="hljs-keyword">const</span> currentState = extension.<span class="hljs-property">editor</span>.<span class="hljs-property">state</span>;
<span class="hljs-keyword">if</span> (currentSelection.<span class="hljs-property">from</span> !== currentFrom) {
  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 位置已改变，丢弃请求</span>
}

<span class="hljs-comment">// 调用 AI API...</span>

<span class="hljs-comment">// 第二次校验：API 返回后</span>
<span class="hljs-keyword">const</span> latestState = extension.<span class="hljs-property">editor</span>.<span class="hljs-property">state</span>;
<span class="hljs-keyword">if</span> (latestState.<span class="hljs-property">selection</span>.<span class="hljs-property">from</span> === currentFrom) {
  <span class="hljs-comment">// 位置仍然一致，才更新状态</span>
}
</code></pre>
<p><strong>4. ProseMirror 插件</strong></p>
<p>编辑器用的是 Tiptap（基于 ProseMirror），补全建议的显示用的是 Decoration，不会影响文档结构，只是视觉上的装饰。</p>
<p>核心代码大概长这样：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 创建补全建议的视觉装饰</span>
<span class="hljs-keyword">const</span> widget = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"span"</span>);
widget.<span class="hljs-property">className</span> = <span class="hljs-string">"ai-completion-suggestion"</span>;
widget.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> =
  <span class="hljs-string">"color: #9ca3af; "</span> + <span class="hljs-comment">// 灰色</span>
  <span class="hljs-string">"font-style: italic; "</span> + <span class="hljs-comment">// 斜体</span>
  <span class="hljs-string">"pointer-events: none; "</span> + <span class="hljs-comment">// 不拦截鼠标</span>
  <span class="hljs-string">"user-select: none;"</span>; <span class="hljs-comment">// 不可选中</span>

widget.<span class="hljs-property">textContent</span> = suggestion;

<span class="hljs-comment">// 在光标位置显示</span>
<span class="hljs-keyword">const</span> decoration = <span class="hljs-title class_">Decoration</span>.<span class="hljs-title function_">widget</span>(position, widget, {
  <span class="hljs-attr">side</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 光标后</span>
  <span class="hljs-attr">ignoreSelection</span>: <span class="hljs-literal">true</span>,
});
</code></pre>
<hr/>
<h2 data-id="heading-6">RAG：让 AI 基于你的内容回答问题</h2>
<p>RAG 是这个项目里我花时间最多的功能。</p>
<h3 data-id="heading-7">先聊聊向量数据库</h3>
<p>在讲 RAG 之前，得先说说向量数据库是什么。</p>
<p>我们平时用的数据库，比如 MySQL、MongoDB，存的都是结构化数据或文档。查询的时候用的是精确匹配或者关键词搜索。</p>
<p>但 AI 领域有个问题：怎么找到「语义相似」的内容？比如「如何写好 Prompt」和「Prompt 工程技巧」，这两句话关键词不一样，但意思很接近。传统数据库搞不定这个。</p>
<p>向量数据库就是为了解决这个问题。它的思路是：</p>
<ol>
<li>把文本转成一串数字（向量），这个过程叫 Embedding</li>
<li>语义相似的文本，转出来的向量也相似</li>
<li>查询的时候，把问题也转成向量，然后找最相似的几个</li>
</ol>
<p>常见的向量数据库有 Pinecone、Milvus、Chroma 等。我用的是 Chroma，开源免费，轻量好用。</p>
<h3 data-id="heading-8">为什么需要 RAG？</h3>
<p>大模型虽然很聪明，但它不知道你博客里写了什么。你问它「我之前写的那篇关于 Prompt 的文章讲了什么」，它只能瞎猜。</p>
<p>这是因为大模型的知识有两个问题：</p>
<ol>
<li><strong>知识不新</strong>：训练数据有截止日期，不知道最新的事</li>
<li><strong>知识不全</strong>：不知道你的私有内容</li>
</ol>
<p>RAG（Retrieval-Augmented Generation，检索增强生成）就是为了解决这个问题。简单说就是给大模型「开卷考试」：先从你的内容里检索相关信息，再让大模型基于这些信息回答。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4ff90066e064a9c8f9c9ec7737748e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU3ByaW5nTGFtZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652174&amp;x-signature=%2F5rNxF2KN8BO3o%2FhoGLG2EbdZuc%3D" alt="cover.gif" loading="lazy"/></p>
<h3 data-id="heading-9">我的实现思路</h3>
<p>整个流程分两部分：</p>
<p><strong>离线索引（把文章存起来）</strong></p>
<ol>
<li>把文章切成小块（语义分块）</li>
<li>用 Ollama 把每个块转成向量（Embedding）</li>
<li>把向量存到 ChromaDB</li>
</ol>
<p><strong>在线检索（用户提问时）</strong></p>
<ol>
<li>把用户的问题也转成向量</li>
<li>在 ChromaDB 里找最相似的几个块</li>
<li>把这些块作为上下文，构造 Prompt</li>
<li>调 Kimi API 生成回答</li>
</ol>
<h3 data-id="heading-10">分块的坑</h3>
<p>分块这一步踩了不少坑。</p>
<p>一开始我想简单点，按固定字符数切，比如每 500 字一块。结果发现很多问题：句子被截断、段落被分割、检索时匹配到不完整的片段。</p>
<p>后来改成了语义分块，按优先级：</p>
<ol>
<li>先按段落分（<code>\n\n</code>）</li>
<li>段落太长就按句子分（<code>。！？</code>）</li>
<li>实在不行才硬切</li>
</ol>
<p>还有一个坑是 Ollama 的 nomic-embed-text 模型有 800 字符的限制。超过这个长度就报错。</p>
<p>我的处理方式是：如果一个块超过 800 字符，就把它切成多个子块，每个子块单独生成向量，单独存储。这样虽然麻烦点，但不会丢信息。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 语义分块的核心逻辑</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">chunkPost</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span>, options = {}</span>) {
  <span class="hljs-keyword">const</span> maxChars = options.<span class="hljs-property">maxChars</span> || <span class="hljs-number">800</span>; <span class="hljs-comment">// Ollama 硬限制</span>
  <span class="hljs-keyword">const</span> chunks = [];

  <span class="hljs-comment">// 按段落分割</span>
  <span class="hljs-keyword">const</span> paragraphs = content.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\n\n+/</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.<span class="hljs-title function_">trim</span>());

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> para <span class="hljs-keyword">of</span> paragraphs) {
    <span class="hljs-keyword">if</span> (para.<span class="hljs-property">length</span> &gt; maxChars) {
      <span class="hljs-comment">// 段落太长，按句子分割</span>
      <span class="hljs-title function_">splitBySentence</span>(para, chunks);
    } <span class="hljs-keyword">else</span> {
      chunks.<span class="hljs-title function_">push</span>(para);
    }
  }

  <span class="hljs-keyword">return</span> chunks;
}
</code></pre>
<hr/>
<h2 data-id="heading-11">流式输出：打字机效果</h2>
<p>如果你用过 ChatGPT，应该对那个打字机效果有印象。AI 的回答不是一下子全出来，而是一个字一个字蹦出来的。</p>
<p>这个效果不只是好看，更重要的是用户体验。如果等 AI 生成完再返回，用户可能要干等好几秒，体验很差。流式输出让用户立刻看到反馈，感觉响应更快。</p>
<h3 data-id="heading-12">实现思路</h3>
<p>流式输出的核心是 <strong>SSE（Server-Sent Events）</strong>。</p>
<p>传统的 HTTP 请求是：发请求 → 等待 → 收到完整响应。</p>
<p>SSE 是：发请求 → 保持连接 → 服务器持续推送数据 → 最后关闭连接。</p>
<p><strong>一个请求，多次推送</strong>。</p>
<p>后端代码大概是这样：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 创建 SSE 流</span>
<span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableStream</span>({
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">controller</span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendEvent</span> = (<span class="hljs-params"><span class="hljs-keyword">type</span>, data</span>) =&gt; {
      <span class="hljs-keyword">const</span> message = <span class="hljs-string">`event: <span class="hljs-subst">${<span class="hljs-keyword">type</span>}</span>\ndata: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(data)}</span>\n\n`</span>;
      controller.<span class="hljs-title function_">enqueue</span>(encoder.<span class="hljs-title function_">encode</span>(message));
    };

    <span class="hljs-comment">// 调用 Kimi API，流式返回</span>
    <span class="hljs-keyword">await</span> aiClient.<span class="hljs-title function_">chatStream</span>(messages, {}, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
      <span class="hljs-comment">// 每收到一个文本块，就推送给前端</span>
      <span class="hljs-title function_">sendEvent</span>(<span class="hljs-string">"chunk"</span>, { chunk });
    });

    <span class="hljs-comment">// 完成后关闭连接</span>
    <span class="hljs-title function_">sendEvent</span>(<span class="hljs-string">"complete"</span>, { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> });
    controller.<span class="hljs-title function_">close</span>();
  },
});

<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(stream, {
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/event-stream"</span>,
    <span class="hljs-string">"Cache-Control"</span>: <span class="hljs-string">"no-cache"</span>,
    <span class="hljs-title class_">Connection</span>: <span class="hljs-string">"keep-alive"</span>,
  },
});
</code></pre>
<p>前端用 <code>fetch</code> + <code>ReadableStream</code> 读取：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/api/ai/rag/stream"</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ question }),
});

<span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();
<span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();

<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">const</span> text = decoder.<span class="hljs-title function_">decode</span>(value);
  <span class="hljs-comment">// 解析 SSE 格式，更新 UI</span>
  <span class="hljs-title function_">parseSSE</span>(text, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    <span class="hljs-title function_">setContent</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev + chunk); <span class="hljs-comment">// 追加文本，实现打字机效果</span>
  });
}
</code></pre>
<hr/>
<h2 data-id="heading-13">其他功能</h2>
<p>除了上面说的 AI 功能，项目里还有一些基础功能：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01e041ff153d48a38a3fe15c42861bc9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU3ByaW5nTGFtZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652174&amp;x-signature=cRS06Y8v%2FEfrjcoNn1fQoNv7yyQ%3D" alt="详情.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85352021003a4626aa3098ca839df6f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU3ByaW5nTGFtZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652174&amp;x-signature=7hktTiy%2FNMcPy5lDIRHvUUUAi9c%3D" alt="aboutme.png" loading="lazy"/></p>
<h3 data-id="heading-14">AI 生成标题、摘要、标签</h3>
<p>这些都是「Prompt + LLM」的套路。给大模型文章内容，让它生成标题/摘要/标签。</p>
<h3 data-id="heading-15">相关文章推荐</h3>
<p>用当前文章的标题和摘要生成向量，在 ChromaDB 里找最相似的几篇文章。比传统的「按标签匹配」更智能。</p>
<h3 data-id="heading-16">降级机制</h3>
<p>RAG 依赖 Ollama 和 ChromaDB，这两个服务挂了怎么办？</p>
<p>我做了降级处理：如果 RAG 不可用，就退化成纯 LLM 模式。虽然回答质量会差一些，但至少功能还能用。</p>
<hr/>
<h2 data-id="heading-17">如何获取 LLM API Key</h2>
<p>这个项目用的是 Kimi（Moonshot AI）的 API，申请地址：</p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.moonshot.cn%2F" target="_blank" title="https://platform.moonshot.cn/" ref="nofollow noopener noreferrer">platform.moonshot.cn/</a></strong></p>
<p>注册后会有免费额度，个人学习完全够用。</p>
<p>其他可选的 LLM 服务：</p>
<ul>
<li><strong>DeepSeek</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.deepseek.com%2F" target="_blank" title="https://platform.deepseek.com/" ref="nofollow noopener noreferrer">platform.deepseek.com/</a></li>
<li><strong>通义千问</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdashscope.aliyun.com%2F" target="_blank" title="https://dashscope.aliyun.com/" ref="nofollow noopener noreferrer">dashscope.aliyun.com/</a></li>
<li><strong>智谱 AI</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopen.bigmodel.cn%2F" target="_blank" title="https://open.bigmodel.cn/" ref="nofollow noopener noreferrer">open.bigmodel.cn/</a></li>
</ul>
<hr/>
<h2 data-id="heading-18">快速上手</h2>
<p>项目开源在 GitHub，感兴趣的话可以 clone 下来跑一跑：</p>
<p><strong>GitHub 地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflawlessv%2FSpring-Broken-AI-Blog" target="_blank" title="https://github.com/flawlessv/Spring-Broken-AI-Blog" ref="nofollow noopener noreferrer">github.com/flawlessv/S…</a></p>
<p>如果觉得有帮助，欢迎给个 ⭐️ Star！</p>
<p>详细的安装步骤在 README 里都有，这里就不展开了。简单说就是：</p>
<ol>
<li>安装 Node.js、Ollama、ChromaDB</li>
<li>配置 Kimi API Key</li>
<li><code>npm install</code> + <code>npm run dev</code></li>
</ol>
<hr/>
<h2 data-id="heading-19">总结</h2>
<p>做完这个项目，我最大的感受是：<strong>大模型应用开发没有想象中那么难</strong>。</p>
<p>很多功能的本质都是「Prompt + 调 API」，关键是把 Prompt 写好，把流程理清楚。</p>
<p>通过这个项目，你可以学到：</p>
<ul>
<li>Next.js 全栈开发（前端 + 后端 + 数据库）</li>
<li>Prompt 工程（结构化 Prompt、角色设定、规则约束）</li>
<li>RAG 实现（向量化、语义分块、相似度检索）</li>
<li>流式输出（SSE、ReadableStream）</li>
</ul>
<p>如果想继续深入，可以看看这些方向：</p>
<ul>
<li><strong>Agent</strong>：让 AI 自己规划任务、调用工具</li>
<li><strong>MCP</strong>：模型上下文协议，统一 AI 与外部系统的交互</li>
<li><strong>微调</strong>：用自己的数据训练模型</li>
</ul>
<p>希望这篇文章对你有帮助。有问题欢迎交流！</p>
<h2 data-id="heading-20">附录：参考资料</h2>
<p>本项目在开发过程中参考了以下优秀内容：</p>
<ul>
<li><strong>样式生成</strong>：<a href="https://juejin.cn/post/7569777676098814002" target="_blank" title="https://juejin.cn/post/7569777676098814002">如何用 Claude Code 生成顶级 UI</a> - 通过 STYLE_GUIDE.md 减少样式信息丢失，让 AI 生成更精准的 UI</li>
<li><strong>Prompt 设计</strong>：<a href="https://juejin.cn/post/7462691800122884136" target="_blank" title="https://juejin.cn/post/7462691800122884136">结构化 Prompt 设计指南</a> - 结构化 Prompt 的写法和最佳实践</li>
<li><strong>博客样式</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.ursb.me%2F" target="_blank" title="https://blog.ursb.me/" ref="nofollow noopener noreferrer">Ursb's Blog</a> - 博客整体风格参考</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Web 图形合成技术：Blending 与 Porter-Duff Compositing]]></title>    <link>https://juejin.cn/post/7593241698370453540</link>    <guid>https://juejin.cn/post/7593241698370453540</guid>    <pubDate>2026-01-10T13:46:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593241698370453540" data-draft-id="7593252939708317732" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Web 图形合成技术：Blending 与 Porter-Duff Compositing"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-10T13:46:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="温宇飞"/> <meta itemprop="url" content="https://juejin.cn/user/4300945219403368"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Web 图形合成技术：Blending 与 Porter-Duff Compositing
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4300945219403368/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    温宇飞
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:46:59.000Z" title="Sat Jan 10 2026 13:46:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Web 图形渲染中，当多个图层重叠时，需要将它们组合成最终显示的图像。本文基于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcompositing-1%2F" target="_blank" title="https://www.w3.org/TR/compositing-1/" ref="nofollow noopener noreferrer">W3C Compositing and Blending 规范</a>，系统讲解 Blending 和 Porter-Duff Compositing 两大核心技术。从数学原理到实际应用，深入解析 Web 图形合成的完整体系。</p>
<h2 data-id="heading-0">符号与公式约定</h2>
<p>理解图形合成的数学公式需要先明确符号约定。本章定义文中使用的核心术语和数学符号，包括颜色表示方式、Alpha 通道处理以及合成过程中的中间结果。</p>
<h3 data-id="heading-1">核心术语</h3>
<p><strong>Source</strong> 是当前要绘制的图层，通常是前景元素。它包含颜色信息和 Alpha 通道。</p>
<p><strong>Backdrop</strong> 是 Source 后面的图层内容，是 Source 要与之合成的对象。Backdrop 是之前所有图层合成的累积结果。</p>
<p><strong>Destination</strong> 是渲染目标，即画布上的像素缓冲区。合成的最终结果会写入 Destination。</p>
<p><strong>Alpha 通道</strong>表示像素的不透明度，取值范围为 [0, 1]。Alpha 为 0 表示完全透明，Alpha 为 1 表示完全不透明。</p>
<h3 data-id="heading-2">预乘 Alpha 与非预乘 Alpha</h3>
<p>颜色可以用两种形式表示：</p>
<p><strong>非预乘 Alpha (Non-premultiplied Alpha)</strong> 表示颜色分量和 Alpha 通道独立存储。例如，半透明红色表示为 <code>(R=1.0, G=0, B=0, α=0.5)</code>，颜色值不受 Alpha 影响。</p>
<p><strong>预乘 Alpha (Premultiplied Alpha)</strong> 表示颜色分量已乘以 Alpha 值。同样的半透明红色表示为 <code>(r=0.5, g=0, b=0, α=0.5)</code>，其中 <code>r = R × α</code>。预乘形式在图形硬件中更高效，简化了合成运算。</p>
<p>两种形式之间的转换：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 非预乘转预乘</span>
<span class="hljs-keyword">const</span> cs = <span class="hljs-title class_">Cs</span> * αs;
<span class="hljs-keyword">const</span> cb = <span class="hljs-title class_">Cb</span> * αb;

<span class="hljs-comment">// 预乘转非预乘（需处理 α = 0 的情况）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Cs</span> = αs &gt; <span class="hljs-number">0</span> ? cs / αs : <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Cb</span> = αb &gt; <span class="hljs-number">0</span> ? cb / αb : <span class="hljs-number">0</span>;
</code></pre>
<h3 data-id="heading-3">符号定义</h3>
<p>本文使用以下符号约定：</p>











































































<table><thead><tr><th>符号</th><th>含义</th><th>取值范围</th></tr></thead><tbody><tr><td><code>Cs</code></td><td>Source 的非预乘颜色 (R, G, B)</td><td>[0, 1]</td></tr><tr><td><code>Cb</code></td><td>Backdrop 的非预乘颜色 (R, G, B)</td><td>[0, 1]</td></tr><tr><td><code>Cr</code></td><td>Blending 后的结果颜色 (R, G, B)</td><td>[0, 1]</td></tr><tr><td><code>Co</code></td><td>最终输出的非预乘颜色 (R, G, B)</td><td>[0, 1]</td></tr><tr><td><code>cs</code></td><td>Source 的预乘颜色 (r, g, b)</td><td>[0, 1]</td></tr><tr><td><code>cb</code></td><td>Backdrop 的预乘颜色 (r, g, b)</td><td>[0, 1]</td></tr><tr><td><code>cr</code></td><td>Blending 后的预乘颜色 (r, g, b)</td><td>[0, 1]</td></tr><tr><td><code>co</code></td><td>最终输出的预乘颜色 (r, g, b)</td><td>[0, 1]</td></tr><tr><td><code>αs</code></td><td>Source 的 Alpha 值</td><td>[0, 1]</td></tr><tr><td><code>αb</code></td><td>Backdrop 的 Alpha 值</td><td>[0, 1]</td></tr><tr><td><code>αo</code></td><td>输出的 Alpha 值</td><td>[0, 1]</td></tr><tr><td><code>Fa</code></td><td>Source 的 Porter-Duff 因子</td><td>[0, 1]</td></tr><tr><td><code>Fb</code></td><td>Backdrop 的 Porter-Duff 因子</td><td>[0, 1]</td></tr></tbody></table>
<p>关键符号说明：</p>
<ul>
<li><strong>Cr (Result color)</strong>：Blending 阶段计算出的中间结果颜色。它是 Backdrop 颜色 <code>Cb</code> 和 Source 颜色 <code>Cs</code> 通过 Blending 函数混合后的结果，会在 Porter-Duff Compositing 阶段作为新的 Source 颜色使用。</li>
<li><strong>Fa 和 Fb</strong>：Porter-Duff Compositing 的控制因子，决定 Source 和 Backdrop 对最终结果的贡献程度。</li>
</ul>
<h3 data-id="heading-4">颜色值裁剪</h3>
<p>合成计算过程中，颜色值可能超出 [0, 1] 范围。需要进行裁剪 (clamp) 处理：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 裁剪到有效范围</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">clamp</span> = (<span class="hljs-params">value</span>) =&gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, value));

<span class="hljs-title class_">Co</span> = <span class="hljs-title function_">clamp</span>(<span class="hljs-title class_">Co</span>);
αo = <span class="hljs-title function_">clamp</span>(αo);
</code></pre>
<p>某些 Blending 模式（如 <code>color-dodge</code>）可能产生大于 1 的值，裁剪确保最终输出的颜色在显示设备的有效范围内。</p>
<h2 data-id="heading-5">合成模型</h2>
<p>图形合成是一个严格的两阶段流程：先进行 Blending 计算重叠区域的颜色混合，再使用 Alpha 合成公式处理 Alpha 通道的影响。本章介绍通用合成公式及其特例 Simple Alpha Compositing。</p>
<h3 data-id="heading-6">通用合成公式</h3>
<p>完整的合成流程严格按照以下顺序执行：</p>
<pre><code class="hljs language-ini" lang="ini">输入: Source (Cs, αs), Backdrop (Cb, αb)
     ↓
<span class="hljs-section">[1. Blending]</span>
     <span class="hljs-attr">Cr</span> = (<span class="hljs-number">1</span> - αb) × Cs + αb × B(Cb, Cs)
     ↓
<span class="hljs-section">[2. Alpha Compositing]</span>
     <span class="hljs-attr">co</span> = Fa × (Cr × αs) + Fb × (Cb × αb)
     α<span class="hljs-attr">o</span> = Fa × αs + Fb × αb
     ↓
输出: Result (Co, αo)
</code></pre>
<p><strong>第 1 步：Blending</strong></p>
<p>计算混合后的颜色 <code>Cr</code>，对每个颜色通道（R/G/B）应用 Blending 函数 <code>B(Cb, Cs)</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 非预乘形式</span>
<span class="hljs-title class_">Cr</span> = (<span class="hljs-number">1</span> - αb) × <span class="hljs-title class_">Cs</span> + αb × <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cs</span>);
</code></pre>
<p><code>B(Cb, Cs)</code> 定义了 Backdrop 和 Source 颜色的混合方式。不同的 Blending 模式对应不同的 <code>B</code> 函数实现：</p>
<ul>
<li><code>normal</code>：<code>B(Cb, Cs) = Cs</code>（无混合，保持 Source 原色）</li>
<li><code>multiply</code>：<code>B(Cb, Cs) = Cb × Cs</code>（正片叠底）</li>
<li><code>screen</code>：<code>B(Cb, Cs) = Cb + Cs - Cb × Cs</code>（滤色）</li>
</ul>
<p><code>αb</code> 控制 Blending 的影响程度：当 Backdrop 透明（αb=0）时保持 Source 原色，当 Backdrop 不透明（αb=1）时完全混合。</p>
<p><strong>第 2 步：Alpha Compositing</strong></p>
<p>将 <code>Cr</code> 作为新的 Source 颜色，使用因子 <code>Fa</code> 和 <code>Fb</code> 控制 Source 和 Backdrop 的贡献程度：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 预乘形式</span>
co = <span class="hljs-title class_">Fa</span> × (<span class="hljs-title class_">Cr</span> × αs) + <span class="hljs-title class_">Fb</span> × (<span class="hljs-title class_">Cb</span> × αb);
αo = <span class="hljs-title class_">Fa</span> × αs + <span class="hljs-title class_">Fb</span> × αb;
</code></pre>
<p><code>Fa</code> 和 <code>Fb</code> 是合成因子，通过不同的取值实现不同的合成效果。例如：</p>
<ul>
<li><code>Fa = 1, Fb = 1 - αs</code>：Source 覆盖 Backdrop（source-over）</li>
<li><code>Fa = αb, Fb = 0</code>：Source 裁剪到 Backdrop 形状（source-in）</li>
<li><code>Fa = 1 - αb, Fb = 1</code>：Backdrop 覆盖 Source（destination-over）</li>
</ul>
<p><strong>合并公式</strong></p>
<p>将两个步骤合并，得到完整的合成公式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 完整的合成公式（预乘形式）</span>
co = <span class="hljs-title class_">Fa</span> × <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cs</span>) × αs × αb + <span class="hljs-title class_">Fa</span> × (<span class="hljs-number">1</span> - αb) × cs + <span class="hljs-title class_">Fb</span> × cb;
αo = <span class="hljs-title class_">Fa</span> × αs + <span class="hljs-title class_">Fb</span> × αb;
</code></pre>
<p>这个公式清楚地展示了三部分的贡献：</p>
<ul>
<li><code>Fa × B(Cb, Cs) × αs × αb</code>：Blending 结果对重叠区域的贡献</li>
<li><code>Fa × (1 - αb) × cs</code>：Source 在 Backdrop 透明区域的贡献</li>
<li><code>Fb × cb</code>：Backdrop 根据合成因子的贡献</li>
</ul>
<h3 data-id="heading-7">Simple Alpha Compositing</h3>
<p>Simple Alpha Compositing 是通用公式的最常用特例，对应参数：</p>
<ul>
<li>Blending 模式：<code>normal</code>，即 <code>B(Cb, Cs) = Cs</code></li>
<li>合成因子：<code>Fa = 1, Fb = 1 - αs</code></li>
</ul>
<p>代入通用公式得到：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 预乘形式</span>
co = cs + cb × (<span class="hljs-number">1</span> - αs);
αo = αs + αb × (<span class="hljs-number">1</span> - αs);
</code></pre>
<p>这就是默认的图层叠加方式（source-over）：Source 以其不透明度覆盖在 Backdrop 上方。当 Source 完全不透明（αs = 1）时，Backdrop 完全被遮盖；当 Source 完全透明（αs = 0）时，输出就是 Backdrop。</p>
<p>关键要点：</p>
<ul>
<li>Blending 在前，Alpha Compositing 在后，顺序不可颠倒</li>
<li>Blending 通过函数 <code>B</code> 计算颜色，Alpha Compositing 通过因子 <code>Fa</code> 和 <code>Fb</code> 控制区域和 Alpha 通道</li>
<li>Simple Alpha Compositing 是 <code>B=Cs, Fa=1, Fb=1-αs</code> 的特例</li>
<li>两个阶段通过中间结果 <code>Cr</code> 连接</li>
</ul>
<h2 data-id="heading-8">Porter-Duff Compositing Operators</h2>
<p>Porter-Duff Compositing Operators 由 Thomas Porter 和 Tom Duff 在 1984 年提出，定义了通过 Alpha 通道控制图层合成区域的代数运算体系。本章介绍 Porter-Duff 操作符的数学原理、13 种标准操作符以及它们与 Compositing Groups 的交互行为。</p>
<h3 data-id="heading-9">操作符原理</h3>
<p>Porter-Duff 操作符基于 Alpha 通道的线性合成。核心思想是通过两个因子 <code>Fa</code> 和 <code>Fb</code> 控制 Source 和 Backdrop 对最终结果的贡献程度：</p>
<pre><code class="hljs language-javascript" lang="javascript">co = <span class="hljs-title class_">Fa</span> × cs + <span class="hljs-title class_">Fb</span> × cb;
αo = <span class="hljs-title class_">Fa</span> × αs + <span class="hljs-title class_">Fb</span> × αb;
</code></pre>
<p>Porter-Duff 理论将两张图像的像素空间分为四个逻辑区域：</p>
<ol>
<li><strong>Source 独占区域</strong>：Source 不透明，Backdrop 透明（αs &gt; 0, αb = 0）</li>
<li><strong>Backdrop 独占区域</strong>：Backdrop 不透明，Source 透明（αs = 0, αb &gt; 0）</li>
<li><strong>重叠区域</strong>：两者都不透明（αs &gt; 0, αb &gt; 0）</li>
<li><strong>空白区域</strong>：两者都透明（αs = 0, αb = 0）</li>
</ol>
<p>为了精确控制这四个区域，<code>Fa</code> 和 <code>Fb</code> 的取值被限制在与 Alpha 值相关的离散集合中：</p>
<pre><code class="hljs language-css" lang="css">Fa ∈ {<span class="hljs-number">0</span>, α<span class="hljs-selector-tag">b</span>, <span class="hljs-number">1</span> - α<span class="hljs-selector-tag">b</span>, <span class="hljs-number">1</span>}
Fb ∈ {<span class="hljs-number">0</span>, αs, <span class="hljs-number">1</span> - αs, <span class="hljs-number">1</span>}
</code></pre>
<p>这种限制确保了操作符具有明确的几何意义：</p>
<ul>
<li><code>Fa = 0</code>：Source 不贡献</li>
<li><code>Fa = 1</code>：Source 完全贡献</li>
<li><code>Fa = αb</code>：Source 仅在 Backdrop 存在的区域贡献</li>
<li><code>Fa = 1 - αb</code>：Source 仅在 Backdrop 不存在的区域贡献</li>
</ul>
<p><code>Fb</code> 的含义与 <code>Fa</code> 对称。</p>
<h3 data-id="heading-10">13 种 Porter-Duff 操作符</h3>
<p>从数学上看，<code>Fa</code> 和 <code>Fb</code> 的取值集合可以产生 4 × 4 = 16 种组合。W3C 规范定义了其中 13 种具有实际意义的操作符：</p>

























































































<table><thead><tr><th>操作符</th><th>Fa</th><th>Fb</th><th>效果描述</th></tr></thead><tbody><tr><td><code>clear</code></td><td>0</td><td>0</td><td>清除所有内容</td></tr><tr><td><code>copy</code></td><td>1</td><td>0</td><td>仅显示 Source</td></tr><tr><td><code>destination</code></td><td>0</td><td>1</td><td>仅显示 Backdrop</td></tr><tr><td><code>source-over</code></td><td>1</td><td>1 - αs</td><td>Source 覆盖 Backdrop（默认）</td></tr><tr><td><code>destination-over</code></td><td>1 - αb</td><td>1</td><td>Backdrop 覆盖 Source</td></tr><tr><td><code>source-in</code></td><td>αb</td><td>0</td><td>Source 裁剪到 Backdrop 形状</td></tr><tr><td><code>destination-in</code></td><td>0</td><td>αs</td><td>Backdrop 裁剪到 Source 形状</td></tr><tr><td><code>source-out</code></td><td>1 - αb</td><td>0</td><td>Source 在 Backdrop 外的部分</td></tr><tr><td><code>destination-out</code></td><td>0</td><td>1 - αs</td><td>Backdrop 在 Source 外的部分</td></tr><tr><td><code>source-atop</code></td><td>αb</td><td>1 - αs</td><td>Source 在 Backdrop 上方（限定在 Backdrop 区域）</td></tr><tr><td><code>destination-atop</code></td><td>1 - αb</td><td>αs</td><td>Backdrop 在 Source 上方（限定在 Source 区域）</td></tr><tr><td><code>xor</code></td><td>1 - αb</td><td>1 - αs</td><td>仅显示非重叠区域</td></tr><tr><td><code>lighter</code></td><td>1</td><td>1</td><td>相加（需要 clamp）</td></tr></tbody></table>
<p>未定义的 3 种组合（<code>Fa=αb, Fb=αs</code>、<code>Fa=αb, Fb=1</code>、<code>Fa=1, Fb=αs</code>）缺乏明确的语义或实际应用价值，因此被排除在规范之外。</p>
<p>W3C 选择这 13 种操作符的原则是：</p>
<ol>
<li><strong>完备性</strong>：覆盖所有常见的图像合成需求（覆盖、裁剪、遮罩、异或等）</li>
<li><strong>对称性</strong>：提供 Source 和 Destination 的对称操作（如 <code>source-in</code> 对应 <code>destination-in</code>）</li>
<li><strong>语义清晰</strong>：每个操作符都有明确的视觉效果和应用场景</li>
</ol>
<h3 data-id="heading-11">常见应用场景</h3>
<p><strong>遮罩效果</strong>：使用 <code>source-in</code> 或 <code>destination-in</code></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"myCanvas"</span>);
<span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);

<span class="hljs-comment">// 绘制遮罩形状（圆形）</span>
ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>);
ctx.<span class="hljs-title function_">fill</span>();

<span class="hljs-comment">// 使用 source-in 将图像裁剪到圆形</span>
ctx.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">"source-in"</span>;
ctx.<span class="hljs-title function_">drawImage</span>(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre>
<p><strong>擦除效果</strong>：使用 <code>destination-out</code></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 绘制底图</span>
ctx.<span class="hljs-title function_">drawImage</span>(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// 使用 destination-out 擦除</span>
ctx.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">"destination-out"</span>;
ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>);
ctx.<span class="hljs-title function_">fill</span>(); <span class="hljs-comment">// 擦除圆形区域</span>
</code></pre>
<p><strong>发光叠加</strong>：使用 <code>lighter</code></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 绘制第一个光源</span>
ctx.<span class="hljs-title function_">drawImage</span>(light1, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// 使用 lighter 叠加第二个光源</span>
ctx.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">"lighter"</span>;
ctx.<span class="hljs-title function_">drawImage</span>(light2, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
</code></pre>
<h2 data-id="heading-12">Blending 混合模式</h2>
<p>Blending 控制重叠区域的颜色如何混合。与 Porter-Duff Compositing Operators 通过 <code>Fa</code> 和 <code>Fb</code> 控制区域选择不同，Blending 通过函数 <code>B(Cb, Cs)</code> 改变颜色的计算方式。本章介绍 Blending 函数、与 Alpha Compositing 的结合、可分离和不可分离混合模式，以及 Group isolation 对 Blending 的影响。</p>
<h3 data-id="heading-13">Blending 函数</h3>
<p>Blending 的核心是 Blending 函数 <code>B(Cb, Cs)</code>，它定义了 Backdrop 颜色 <code>Cb</code> 和 Source 颜色 <code>Cs</code> 如何计算出混合后的颜色 <code>Cr</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Blending 公式（非预乘形式）</span>
<span class="hljs-title class_">Cr</span> = (<span class="hljs-number">1</span> - αb) × <span class="hljs-title class_">Cs</span> + αb × <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cs</span>);
</code></pre>
<p><code>αb</code> 控制 Blending 函数的影响程度：</p>
<ul>
<li>当 <code>αb = 0</code>（Backdrop 透明）时，<code>Cr = Cs</code>（保持 Source 原色）</li>
<li>当 <code>αb = 1</code>（Backdrop 不透明）时，<code>Cr = B(Cb, Cs)</code>（完全混合）</li>
</ul>
<p>不同的 Blending 模式对应不同的 <code>B</code> 函数实现。Blending 模式分为两大类：</p>
<ul>
<li><strong>可分离混合模式 (Separable Blend Modes)</strong>：<code>B(Cb, Cs)</code> 对 RGB 每个通道独立计算</li>
<li><strong>不可分离混合模式 (Non-separable Blend Modes)</strong>：<code>B(Cb, Cs)</code> 需要同时考虑所有颜色通道，涉及 RGB 与 HSL 色彩空间转换</li>
</ul>
<h3 data-id="heading-14">Blending 与 Alpha Compositing</h3>
<p>在完整的合成流程中，Blending 计算出 <code>Cr</code> 后，需要与 Porter-Duff Compositing 结合。最常见的简化模式是：<strong>Blending 之后进行 source-over 合成</strong>。</p>
<p>这种模式对应参数：</p>
<ul>
<li>Blending 模式：任意 <code>B(Cb, Cs)</code> 函数（如 multiply、screen 等）</li>
<li>Alpha Compositing 因子：<code>Fa = 1, Fb = 1 - αs</code>（source-over）</li>
</ul>
<p>完整公式为：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 第 1 步：Blending</span>
<span class="hljs-title class_">Cr</span> = (<span class="hljs-number">1</span> - αb) × <span class="hljs-title class_">Cs</span> + αb × <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cs</span>);

<span class="hljs-comment">// 第 2 步：source-over Alpha Compositing</span>
co = <span class="hljs-title class_">Cr</span> × αs + <span class="hljs-title class_">Cb</span> × αb × (<span class="hljs-number">1</span> - αs);
αo = αs + αb × (<span class="hljs-number">1</span> - αs);
</code></pre>
<p>合并为单一公式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Blending + source-over 合成（预乘形式）</span>
co = <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cs</span>) × αs × αb + (<span class="hljs-number">1</span> - αb) × cs + (<span class="hljs-number">1</span> - αs) × cb;
αo = αs + αb × (<span class="hljs-number">1</span> - αs);
</code></pre>
<p>这个公式清楚地展示了三部分的贡献：</p>
<ul>
<li><code>B(Cb, Cs) × αs × αb</code>：Blending 结果对重叠区域的贡献</li>
<li><code>(1 - αb) × cs</code>：Source 在 Backdrop 透明区域的贡献</li>
<li><code>(1 - αs) × cb</code>：Backdrop 在 Source 透明区域的贡献</li>
</ul>
<p>这是 Web 平台最常用的合成模式，通过 CSS 的 <code>mix-blend-mode</code> 属性或 Canvas 的 <code>globalCompositeOperation</code> 属性使用。</p>
<h3 data-id="heading-15">可分离混合模式</h3>
<p>可分离混合模式的 <code>B(Cb, Cs)</code> 函数对每个颜色通道独立应用。</p>



















































































<table><thead><tr><th>混合模式</th><th>B(Cb, Cs) 公式</th><th>效果描述</th><th>常见用途</th></tr></thead><tbody><tr><td><code>normal</code></td><td>Cs</td><td>无混合</td><td>默认</td></tr><tr><td><code>multiply</code></td><td>Cb × Cs</td><td>正片叠底</td><td>阴影、纹理叠加</td></tr><tr><td><code>screen</code></td><td>Cb + Cs - Cb × Cs</td><td>滤色</td><td>发光效果</td></tr><tr><td><code>overlay</code></td><td>Cb ≤ 0.5 ? 2×Cb×Cs : 1 - 2×(1-Cb)×(1-Cs)</td><td>叠加</td><td>图像增强</td></tr><tr><td><code>darken</code></td><td>min(Cb, Cs)</td><td>变暗</td><td>暗部合成</td></tr><tr><td><code>lighten</code></td><td>max(Cb, Cs)</td><td>变亮</td><td>亮部合成</td></tr><tr><td><code>color-dodge</code></td><td>Cs ≥ 1 ? 1 : min(1, Cb / (1 - Cs))</td><td>颜色减淡</td><td>强光效果</td></tr><tr><td><code>color-burn</code></td><td>Cs ≤ 0 ? 0 : 1 - min(1, (1 - Cb) / Cs)</td><td>颜色加深</td><td>加深效果</td></tr><tr><td><code>hard-light</code></td><td>Cs ≤ 0.5 ? 2×Cb×Cs : 1 - 2×(1-Cb)×(1-Cs)</td><td>强光</td><td>高对比度效果</td></tr><tr><td><code>soft-light</code></td><td>复杂公式（详见 W3C 规范）</td><td>柔光</td><td>柔光效果</td></tr><tr><td><code>difference</code></td><td>|Cb - Cs|</td><td>差值</td><td>差异检测</td></tr><tr><td><code>exclusion</code></td><td>Cb + Cs - 2×Cb×Cs</td><td>排除</td><td>柔和差异</td></tr></tbody></table>
<p><strong>代码示例</strong>：使用 multiply 混合模式</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"myCanvas"</span>);
<span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);

<span class="hljs-comment">// 绘制 Backdrop（蓝色矩形）</span>
ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">"blue"</span>;
ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);

<span class="hljs-comment">// 使用 multiply 混合模式绘制 Source（红色圆形）</span>
ctx.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">"multiply"</span>;
ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">"red"</span>;
ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>);
ctx.<span class="hljs-title function_">fill</span>();
<span class="hljs-comment">// 重叠区域：blue × red = 暗紫色</span>
</code></pre>
<h3 data-id="heading-16">不可分离混合模式</h3>
<p>不可分离混合模式需要在 HSL 色彩空间中操作。辅助函数：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 计算亮度 (Luminosity)</span>
<span class="hljs-title class_">Lum</span>(C) = <span class="hljs-number">0.3</span> × C.<span class="hljs-property">red</span> + <span class="hljs-number">0.59</span> × C.<span class="hljs-property">green</span> + <span class="hljs-number">0.11</span> × C.<span class="hljs-property">blue</span>;

<span class="hljs-comment">// 计算饱和度 (Saturation)</span>
<span class="hljs-title class_">Sat</span>(C) = <span class="hljs-title function_">max</span>(C.<span class="hljs-property">red</span>, C.<span class="hljs-property">green</span>, C.<span class="hljs-property">blue</span>) - <span class="hljs-title function_">min</span>(C.<span class="hljs-property">red</span>, C.<span class="hljs-property">green</span>, C.<span class="hljs-property">blue</span>);

<span class="hljs-comment">// 设置亮度：保持色相和饱和度，修改亮度</span>
<span class="hljs-title class_">SetLum</span>(C, lum);

<span class="hljs-comment">// 设置饱和度：保持色相和亮度，修改饱和度</span>
<span class="hljs-title class_">SetSat</span>(C, sat);
</code></pre>



































<table><thead><tr><th>混合模式</th><th>B(Cb, Cs) 公式</th><th>效果描述</th><th>常见用途</th></tr></thead><tbody><tr><td><code>hue</code></td><td>SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb))</td><td>使用 Source 色相</td><td>色彩调整</td></tr><tr><td><code>saturation</code></td><td>SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb))</td><td>使用 Source 饱和度</td><td>饱和度调整</td></tr><tr><td><code>color</code></td><td>SetLum(Cs, Lum(Cb))</td><td>使用 Source 色相和饱和度</td><td>着色效果</td></tr><tr><td><code>luminosity</code></td><td>SetLum(Cb, Lum(Cs))</td><td>使用 Source 亮度</td><td>亮度调整</td></tr></tbody></table>
<h2 data-id="heading-17">Compositing Groups</h2>
<p>Compositing Groups 影响元素如何与背景交互。理解 Groups 对于掌握复杂的视觉效果至关重要，它决定了子元素能否看到外部背景，以及 Group 如何作为整体与外部合成。</p>
<h3 data-id="heading-18">Group Invariance(组不变性)</h3>
<p>Group Invariance 是 Compositing Groups 的核心原则：一个 Group 作为整体与外部 Backdrop 进行合成的结果，应该与 Group 内部的具体实现细节无关。</p>
<p>具体来说，Group Invariance 要求：</p>
<ol>
<li><strong>Group 内部的元素先相互合成</strong>，生成 Group 的最终图像</li>
<li><strong>Group 作为单个图层</strong>与外部 Backdrop 进行合成</li>
<li>Group 内部元素的顺序、数量、合成方式对外部不可见</li>
</ol>
<p>这个原则确保了模块化和封装性。例如，一个包含多个子元素的 <code>&lt;div&gt;</code> 可以作为一个整体与页面其他部分进行合成，而不会因为内部结构变化而影响最终效果。</p>
<p>Group Invariance 的数学表达：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Group 内部合成</span>
<span class="hljs-keyword">let</span> groupResult = initialBackdrop;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> groupElements) {
  groupResult = <span class="hljs-title function_">composite</span>(groupResult, element);
}

<span class="hljs-comment">// Group 作为整体与外部合成</span>
<span class="hljs-keyword">const</span> finalResult = <span class="hljs-title function_">composite</span>(externalBackdrop, groupResult);
</code></pre>
<h3 data-id="heading-19">组不变性的数学基础</h3>
<p>Compositing 操作满足结合律，这是组不变性的数学基础：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 三个元素 A、B、C</span>
<span class="hljs-title function_">composite</span>(<span class="hljs-title function_">composite</span>(A, B), C) === <span class="hljs-title function_">composite</span>(A, <span class="hljs-title function_">composite</span>(B, C));
<span class="hljs-comment">// (A + B) + C = A + (B + C)</span>
</code></pre>
<p><strong>Simple Alpha Compositing 满足组不变性</strong></p>
<p>对于 Simple Alpha Compositing (<code>source-over</code>)，组不变性总是成立，因为其公式是线性的：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// source-over 是线性操作</span>
co = cs + cb × (<span class="hljs-number">1</span> - αs);
αo = αs + αb × (<span class="hljs-number">1</span> - αs);
</code></pre>
<p>这意味着：</p>
<ul>
<li>可以先把 A 和 B 合成，再与 C 合成 → <code>(A + B) + C</code></li>
<li>也可以先把 B 和 C 合成，再与 A 合成 → <code>A + (B + C)</code></li>
<li>两种方式结果相同</li>
</ul>
<p>因为满足结合律，所以可以安全地将元素分组：先在 Group 内部合成，再与外部合成，不会改变最终结果。</p>
<p><strong>Blending 打破组不变性</strong></p>
<p>某些 Blending 模式会打破组不变性，因为 Blending 函数 <code>B(Cb, Cs)</code> 是非线性的。例如 <code>multiply</code> 模式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cs</span>) = <span class="hljs-title class_">Cb</span> × <span class="hljs-title class_">Cs</span>;

<span class="hljs-comment">// 非线性导致不满足结合律</span>
<span class="hljs-title function_">B</span>(<span class="hljs-title function_">B</span>(<span class="hljs-title class_">Ca</span>, <span class="hljs-title class_">Cb</span>), <span class="hljs-title class_">Cc</span>) ≠ <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Ca</span>, <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cc</span>));
</code></pre>
<p>考虑完整的 Blending 公式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Cr</span> = (<span class="hljs-number">1</span> - αb) × <span class="hljs-title class_">Cs</span> + αb × <span class="hljs-title function_">B</span>(<span class="hljs-title class_">Cb</span>, <span class="hljs-title class_">Cs</span>);
</code></pre>
<p>由于 <code>αb</code> 和 <code>B</code> 的非线性特性，不同的分组方式会导致不同的结果：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 情况 1：B 作为 Group 先与 C 合成</span>
<span class="hljs-comment">// B 看到的 Backdrop 是 C，αb 来自 C</span>
groupResult = <span class="hljs-title function_">blend</span>(B, C);
final = <span class="hljs-title function_">blend</span>(groupResult, A);

<span class="hljs-comment">// 情况 2：B 直接与外部 A 合成</span>
<span class="hljs-comment">// B 看到的 Backdrop 是 A，αb 来自 A</span>
final = <span class="hljs-title function_">blend</span>(<span class="hljs-title function_">blend</span>(A, B), C);

<span class="hljs-comment">// 两种情况结果不同</span>
</code></pre>
<p><strong>Isolated Groups 的必要性</strong></p>
<p>为了在使用 Blending 时保持确定性，CSS 中设置 <code>mix-blend-mode</code> 会自动创建新的层叠上下文和 Compositing Group：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.element</span> {
  <span class="hljs-attribute">mix-blend-mode</span>: multiply;
  <span class="hljs-comment">/* 自动创建 Compositing Group，确保混合顺序的确定性 */</span>
}
</code></pre>
<p>通过创建 Compositing Group，系统明确定义：</p>
<ol>
<li><strong>混合顺序</strong>：Group 内的元素按文档顺序依次混合</li>
<li><strong>Backdrop 来源</strong>：Blending 函数 <code>B(Cb, Cs)</code> 中的 <code>Cb</code> 来自 Group 的 initialBackdrop</li>
<li><strong>隔离范围</strong>：如果是 Isolated Group，initialBackdrop 为透明，元素只与 Group 内部混合</li>
</ol>
<p>实际例子：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: red;"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: green; mix-blend-mode: multiply;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: blue; mix-blend-mode: multiply;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<ul>
<li>绿色层设置了 <code>multiply</code>，创建 Compositing Group</li>
<li>蓝色层在绿色层的 Group 内，先与绿色混合</li>
<li>绿色 Group 的结果再与红色背景混合</li>
<li>混合顺序：blue → green → red，确定且不可改变</li>
</ul>
<p>这就引出了 Isolated Groups 和 Non-isolated Groups 的区别：它们的 initialBackdrop 不同，决定了 Group 内元素能否看到外部背景。</p>
<h3 data-id="heading-20">Isolated 和 Non-isolated Groups</h3>
<p>Isolated Groups 和 Non-isolated Groups 的核心区别在于 <code>initialBackdrop</code> 的取值：</p>
<p><strong>Isolated Groups（隔离组）</strong></p>
<p>初始 Backdrop 为全透明黑色 <code>rgba(0, 0, 0, 0)</code>，Group 内部元素看不到外部背景：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> groupResult = { <span class="hljs-attr">r</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>, α: <span class="hljs-number">0</span> }; <span class="hljs-comment">// 透明背景</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> groupElements) {
  groupResult = <span class="hljs-title function_">composite</span>(groupResult, element);
}

<span class="hljs-comment">// Group 作为整体与外部合成</span>
<span class="hljs-keyword">const</span> finalResult = <span class="hljs-title function_">composite</span>(externalBackdrop, groupResult);
</code></pre>
<p><strong>Non-isolated Groups（非隔离组）</strong></p>
<p>初始 Backdrop 使用外部 Backdrop，Group 内部元素可以看到外部背景：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> groupResult = externalBackdrop; <span class="hljs-comment">// 使用外部背景</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> groupElements) {
  groupResult = <span class="hljs-title function_">composite</span>(groupResult, element);
}

<span class="hljs-keyword">const</span> finalResult = groupResult;
</code></pre>
<p><strong>创建 Isolated Group 的方式</strong></p>
<p>根据 W3C 规范：</p>
<ul>
<li><strong>CSS</strong>：所有创建层叠上下文 (stacking context) 的操作都会创建 Isolated Group</li>
<li><strong>SVG</strong>：opacity、filters、3D transforms、blending、masking 会创建 Isolated Group</li>
<li>显式创建：使用 <code>isolation: isolate</code> 属性</li>
</ul>
<p>默认情况下，HTML 元素形成 Non-isolated Group。</p>
<h3 data-id="heading-21">Isolated vs Non-isolated 对比</h3>
<p>假设有一个绿色圆形使用 <code>multiply</code> 混合模式叠加在红色方块和蓝色背景上：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- Non-isolated Group（默认） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: blue; padding: 50px;"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: red; width: 100px; height: 100px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
    <span class="hljs-attr">style</span>=<span class="hljs-string">"background: green; border-radius: 50%; width: 80px; height: 80px;
              margin: -60px 0 0 40px; mix-blend-mode: multiply;"</span>
  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Isolated Group --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: blue; padding: 50px;"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"isolation: isolate;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: red; width: 100px; height: 100px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">"background: green; border-radius: 50%; width: 80px; height: 80px;
                margin: -60px 0 0 40px; mix-blend-mode: multiply;"</span>
    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><strong>Non-isolated Group 的合成过程：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 初始 Backdrop 是蓝色背景</span>
<span class="hljs-keyword">let</span> result = blue;

<span class="hljs-comment">// 红色方块与蓝色背景合成</span>
result = <span class="hljs-title function_">composite</span>(result, red); <span class="hljs-comment">// → 蓝色背景上的红色方块</span>

<span class="hljs-comment">// 绿色圆形使用 multiply 模式与当前结果合成</span>
<span class="hljs-comment">// 绿色圆形会与红色方块和蓝色背景都发生混合</span>
result = <span class="hljs-title function_">composite_with_blend</span>(result, green, multiply);
<span class="hljs-comment">// 重叠红色区域：green × red = 暗红色</span>
<span class="hljs-comment">// 重叠蓝色区域：green × blue = 暗蓝色</span>
</code></pre>
<p><strong>Isolated Group 的合成过程：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Group 内部：初始 Backdrop 是透明</span>
<span class="hljs-keyword">let</span> groupResult = transparent;

<span class="hljs-comment">// 红色方块与透明背景合成</span>
groupResult = <span class="hljs-title function_">composite</span>(groupResult, red); <span class="hljs-comment">// → 红色方块（无背景）</span>

<span class="hljs-comment">// 绿色圆形使用 multiply 模式与红色方块合成</span>
<span class="hljs-comment">// 绿色圆形只能看到红色方块，看不到外部蓝色背景</span>
groupResult = <span class="hljs-title function_">composite_with_blend</span>(groupResult, green, multiply);
<span class="hljs-comment">// 重叠区域：green × red = 暗红色</span>
<span class="hljs-comment">// 非重叠区域：保持原色</span>

<span class="hljs-comment">// Group 结果与蓝色背景合成</span>
result = <span class="hljs-title function_">composite</span>(blue, groupResult);
<span class="hljs-comment">// 最终：蓝色背景 + 红色方块 + 暗红色重叠区域（绿色圆形不会与蓝色混合）</span>
</code></pre>
<p><strong>关键区别：</strong></p>
<ul>
<li><strong>Non-isolated</strong>：绿色圆形与红色方块和蓝色背景都发生 multiply 混合</li>
<li><strong>Isolated</strong>：绿色圆形只与红色方块发生 multiply 混合，看不到蓝色背景</li>
</ul>
<h2 data-id="heading-22">实际应用</h2>
<p>Compositing 和 Blending 技术在 Web 平台的三个主要领域有广泛应用：Canvas 2D API、HTML/CSS、SVG。本章介绍如何在这些平台使用这些技术，以及性能优化建议。</p>
<p><strong>平台能力对比</strong>：</p>
<ul>
<li><strong>Canvas 2D</strong>：同时支持 Porter-Duff 操作符和 Blending 模式</li>
<li><strong>CSS</strong>：仅支持 Blending 模式（通过 <code>mix-blend-mode</code>、<code>background-blend-mode</code>）</li>
<li><strong>SVG</strong>：通过滤镜元素支持 Porter-Duff 操作符（<code>feComposite</code>）和 Blending 模式（<code>feBlend</code>）</li>
</ul>
<p><strong>重要说明</strong>：在所有 Web 平台（Canvas 2D、CSS、SVG）中，Blending 模式都采用 <code>Blending + source-over</code> 的合成方式，即 Blending 计算后使用 source-over 进行 Alpha Compositing（Fa=1, Fb=1-αs）。</p>
<h3 data-id="heading-23">Canvas 2D</h3>
<p>Canvas 2D 通过 <code>globalCompositeOperation</code> 属性控制 Compositing 和 Blending。</p>
<p><strong>globalCompositeOperation 属性</strong></p>
<p>该属性接受字符串值，指定合成或混合模式。支持的值包括：</p>
<ul>
<li><strong>Porter-Duff 操作符</strong>：<code>source-over</code>（默认）, <code>source-in</code>, <code>source-out</code>, <code>source-atop</code>, <code>destination-over</code>, <code>destination-in</code>, <code>destination-out</code>, <code>destination-atop</code>, <code>lighter</code>, <code>copy</code>, <code>xor</code>, <code>destination</code></li>
<li><strong>Blending 模式</strong>：<code>multiply</code>, <code>screen</code>, <code>overlay</code>, <code>darken</code>, <code>lighten</code>, <code>color-dodge</code>, <code>color-burn</code>, <code>hard-light</code>, <code>soft-light</code>, <code>difference</code>, <code>exclusion</code>, <code>hue</code>, <code>saturation</code>, <code>color</code>, <code>luminosity</code></li>
</ul>
<h3 data-id="heading-24">CSS</h3>
<p>CSS 仅支持 Blending 模式，不支持 Porter-Duff 操作符。提供以下属性控制 Blending：</p>
<p><strong>mix-blend-mode</strong></p>
<p>控制元素与其 Backdrop 的混合方式。元素会与下方的所有内容进行混合。</p>
<ul>
<li>语法：<code>mix-blend-mode: &lt;blend-mode&gt;</code></li>
<li>支持的值：<code>normal</code>（默认）, <code>multiply</code>, <code>screen</code>, <code>overlay</code>, <code>darken</code>, <code>lighten</code>, <code>color-dodge</code>, <code>color-burn</code>, <code>hard-light</code>, <code>soft-light</code>, <code>difference</code>, <code>exclusion</code>, <code>hue</code>, <code>saturation</code>, <code>color</code>, <code>luminosity</code></li>
<li>自动创建 Compositing Group（非 <code>normal</code> 时）</li>
</ul>
<p><strong>background-blend-mode</strong></p>
<p>控制同一元素的多个背景层之间的混合。多个背景按照从上到下的顺序混合。</p>
<ul>
<li>语法：<code>background-blend-mode: &lt;blend-mode&gt;</code></li>
<li>支持的值：与 <code>mix-blend-mode</code> 相同</li>
<li>可以指定多个值，对应多个背景层</li>
</ul>
<p><strong>isolation</strong></p>
<p>显式创建 Isolated Group，隔离子元素的混合效果。</p>
<ul>
<li>语法：<code>isolation: auto | isolate</code></li>
<li><code>auto</code>：默认，不创建隔离组</li>
<li><code>isolate</code>：创建 Isolated Group，子元素的混合不会影响外部背景</li>
</ul>
<h3 data-id="heading-25">SVG</h3>
<p>SVG 通过滤镜元素实现 Compositing 和 Blending。</p>
<p><strong>feComposite 元素</strong></p>
<p>实现 Porter-Duff Compositing 操作符。</p>
<ul>
<li>属性：<code>operator</code> 指定操作符类型</li>
<li>支持的值：<code>over</code>, <code>in</code>, <code>out</code>, <code>atop</code>, <code>xor</code>, <code>lighter</code>, <code>arithmetic</code></li>
<li><code>in</code> 和 <code>in2</code> 属性指定 Source 和 Backdrop</li>
<li><code>arithmetic</code> 模式支持自定义线性组合公式</li>
</ul>
<p><strong>feBlend 元素</strong></p>
<p>实现 Blending 混合模式。</p>
<ul>
<li>属性：<code>mode</code> 指定混合模式</li>
<li>支持的值：<code>normal</code>, <code>multiply</code>, <code>screen</code>, <code>overlay</code>, <code>darken</code>, <code>lighten</code>, <code>color-dodge</code>, <code>color-burn</code>, <code>hard-light</code>, <code>soft-light</code>, <code>difference</code>, <code>exclusion</code>, <code>hue</code>, <code>saturation</code>, <code>color</code>, <code>luminosity</code></li>
<li><code>in</code> 和 <code>in2</code> 属性指定要混合的两个输入源</li>
</ul>
<h3 data-id="heading-26">Isolated Group 的性能影响</h3>
<p>Isolated Group 需要离屏渲染，带来额外的性能开销：</p>
<ul>
<li>浏览器为 Group 分配离屏缓冲区（offscreen buffer）</li>
<li>Group 内容先渲染到离屏缓冲区，再合成到主画布</li>
<li>增加内存占用和 GPU 计算负担</li>
</ul>
<p>过多或嵌套的 Isolated Group 会显著影响渲染性能。</p>
<p><strong>Canvas 2D</strong></p>
<p>Canvas 2D 是即时模式（immediate mode）绘图 API，不会自动创建 Isolated Group。如需隔离效果，需手动使用离屏 Canvas。</p>
<p><strong>HTML/CSS</strong></p>
<p>根据 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcompositing-1%2F%23csscompositingrules_CSS" target="_blank" title="https://www.w3.org/TR/compositing-1/#csscompositingrules_CSS" ref="nofollow noopener noreferrer">W3C 规范 Section 3.2</a>，HTML/CSS 中所有创建层叠上下文（Stacking Context）的属性都会创建 Isolated Group，包括 <code>opacity</code>、<code>transform</code>、<code>filter</code>、<code>mix-blend-mode</code>、<code>isolation: isolate</code> 等。</p>
<p><strong>SVG</strong></p>
<p>根据 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcompositing-1%2F%23csscompositingrules_SVG" target="_blank" title="https://www.w3.org/TR/compositing-1/#csscompositingrules_SVG" ref="nofollow noopener noreferrer">W3C 规范 Section 3.3</a>，SVG 中只有特定操作会创建 Isolated Group：</p>
<ul>
<li><code>opacity</code></li>
<li><code>filters</code>（滤镜）</li>
<li>3D transforms（2D transforms 不会创建）</li>
<li><code>blending</code>（混合模式）</li>
<li><code>masking</code>（遮罩）</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[读懂 Tailwind v4：为什么它是现代前端项目的必选项？]]></title>    <link>https://juejin.cn/post/7593310044479209481</link>    <guid>https://juejin.cn/post/7593310044479209481</guid>    <pubDate>2026-01-10T15:00:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593310044479209481" data-draft-id="7593375360553795634" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="读懂 Tailwind v4：为什么它是现代前端项目的必选项？"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2026-01-10T15:00:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="404星球的猫"/> <meta itemprop="url" content="https://juejin.cn/user/193147068224126"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            读懂 Tailwind v4：为什么它是现代前端项目的必选项？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/193147068224126/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    404星球的猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:00:22.000Z" title="Sat Jan 10 2026 15:00:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>摘要</strong>：当原子化 CSS 已经成为事实标准，Tailwind CSS 还能如何进化？答案不是更多的 Utility Class，而是彻底重构底层引擎。本文将带你深入了解 Tailwind v4 (代号 Oxy)，看它如何通过 Rust 和“去 PostCSS 化”，将开发体验提升到全新维度。</p>
</blockquote>
<hr/>
<p>在过去几年里，Tailwind CSS 几乎凭一己之力改变了前端开发者编写样式的方式。它赢得了“原子化 CSS vs 语义化 CSS”的战争，成为了现代前端项目的标配。</p>
<p>然而，随着项目规模的扩大，Tailwind v3 的局限性也逐渐显现：在包含数千个组件的大型 Monorepo 中，开发服务器的启动和 HMR（热更新）速度开始变慢。这并非 Tailwind 的设计缺陷，而是其依赖的 JavaScript 和 PostCSS 工具链的性能天花板。</p>
<p>站在 2026 年初，Tailwind CSS v4 的正式发布，标志着这个天花板被彻底击碎。这是一次**“为了速度而重写，为了简单而重构”**的革命性升级。</p>
<h2 data-id="heading-0">一、速度的质变：Rust 引擎登场</h2>
<p>Tailwind v4 最大的变化在于其内部代号为 <strong>"Oxy"</strong> 的全新引擎。</p>
<h3 data-id="heading-1">告别 JavaScript 的束缚</h3>
<p>在 v3 版本中，Tailwind 本质上是一个复杂的 PostCSS 插件。每当你保存文件，它都需要通过 JavaScript 解析你的代码，扫描类名，然后生成 CSS。</p>
<p>而在 v4 中，核心引擎完全使用 <strong>Rust</strong> 重写。</p>
<p>结果是惊人的。在大型项目中，构建速度和 HMR 速度提升了 <strong>10 倍以上</strong>。这种感觉就像是从机械硬盘升级到了 NVMe SSD，曾经需要几秒钟的重新编译现在几乎是瞬间完成的。你甚至感觉不到构建过程的存在。</p>
<h2 data-id="heading-2">二、架构的极简：再见，PostCSS</h2>
<p>对于许多开发者来说，v4 最令人兴奋的改动或许不是速度，而是<strong>它不再依赖 PostCSS</strong>。</p>
<h3 data-id="heading-3">工具链的解耦</h3>
<p>长久以来，配置 Tailwind 意味着你必须配置 PostCSS。你需要一个 <code>postcss.config.js</code>，里面塞着 <code>tailwindcss</code> 和 <code>autoprefixer</code>。如果你的项目构建链比较复杂（比如以前的 Webpack），这层依赖往往是痛苦的来源。</p>
<p>Tailwind v4 变成了一个独立的 CLI 工具（当然也提供了极其优秀的 Vite 插件）。它自带了解析和前缀添加功能。</p>
<p>这意味着什么？</p>
<ul>
<li>• 你的项目根目录少了一个配置文件。</li>
<li>• 你的 <code>package.json</code> 少了一堆依赖。</li>
<li>• 构建流程少了一个中间环节，更加健壮。</li>
</ul>
<h2 data-id="heading-4">三、配置的范式转移：CSS-First</h2>
<p>v4 带来了配置方式的重大变革。它试图摆脱对 <code>tailwind.config.js</code> 的重度依赖，转而拥抱原生的 CSS 变量。这是一个非常现代化的理念：<strong>让 CSS 的归 CSS。</strong></p>
<h3 data-id="heading-5">对比：自定义主题颜色</h3>
<p><strong>在 Tailwind v3 中</strong>，你需要修改 JavaScript 配置文件：</p>
<pre><code class="hljs language-css" lang="css">
    
    
    
  // tailwind<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span> (旧版)
module<span class="hljs-selector-class">.exports</span> = {
  theme: {
    extend: {
      colors: {
        brand: {
          DEFAULT: <span class="hljs-string">'#0070f3'</span>,
          dark: <span class="hljs-string">'#024dbc'</span>,
        },
      },
    },
  },
  // ...
}
</code></pre>
<p><strong>在 Tailwind v4 中</strong>，你可以直接在你的主 CSS 文件中定义，利用新的 <code>@theme</code> 指令：</p>
<pre><code class="hljs language-css" lang="css">
    
    
    
  <span class="hljs-comment">/* globals.css (新版 v4) */</span>
<span class="hljs-keyword">@tailwind</span> base;
<span class="hljs-keyword">@tailwind</span> components;
<span class="hljs-keyword">@tailwind</span> utilities;

<span class="hljs-keyword">@theme</span> {
  <span class="hljs-comment">/* 直接使用 CSS 变量定义主题 */</span>
  <span class="hljs-attr">--color-brand</span>: <span class="hljs-number">#0070f3</span>;
  <span class="hljs-attr">--color-brand-dark</span>: <span class="hljs-number">#024dbc</span>;

  <span class="hljs-comment">/* 甚至可以定义字体和断点 */</span>
  <span class="hljs-attr">--font-sans</span>: <span class="hljs-string">"Inter"</span>, sans-serif;
  <span class="hljs-attr">--breakpoint-3xl</span>: <span class="hljs-number">1920px</span>;
}
</code></pre>
<p>Tailwind v4 的引擎会自动读取这些 CSS 变量，并生成对应的工具类（如 <code>bg-brand</code>, <code>text-brand-dark</code>）。</p>
<p><strong>这种变化的优势在于：</strong></p>
<ol>
<li>
<ol>
<li><strong>更符合 Web 标准：</strong> 配置就在 CSS 里，而不是 JS 里。</li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>动态性：</strong> 你可以在运行时通过 JS 修改这些 CSS 变量，Tailwind 的样式会自动响应（虽然工具类名是静态的，但它们引用的值是动态的）。</li>
</ol>
</li>
<li>
<ol start="3">
<li><strong>零配置启动：</strong> 对于大多数简单项目，你甚至完全不需要 <code>tailwind.config.js</code> 文件。引擎会自动扫描你的文件并开始工作。</li>
</ol>
</li>
</ol>
<h2 data-id="heading-6">四、极其丝滑的 Vite 集成</h2>
<p>Tailwind v4 团队与 Vite 团队进行了深度合作，推出了全新的官方 Vite 插件 <code>@tailwindcss/vite</code>。</p>
<p>这个插件绕过了许多中间环节，直接介入 Vite 的构建流程。它带来的体验是：</p>
<ul>
<li>• <strong>零配置：</strong> 安装插件，在 <code>vite.config.ts</code> 中引入，结束。它会自动找到你的 CSS 入口并开始工作。</li>
<li>• <strong>瞬间 HMR：</strong> 无论你的项目多大，修改一个 class 名，浏览器里的样式几乎是立刻更新。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript">
    
    
    
  <span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> tailwindcss <span class="hljs-keyword">from</span> <span class="hljs-string">'@tailwindcss/vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">tailwindcss</span>(), <span class="hljs-comment">// 就这么简单</span>
  ],
})
</code></pre>
<h2 data-id="heading-7">五、总结：成熟的标志</h2>
<p>Tailwind CSS v4 并不是一次简单的功能叠加，而是一次成熟的标志。</p>
<p>它不再满足于仅仅改变我们写 CSS 的方式，它开始深入底层，优化整个前端工具链的性能和体验。通过拥抱 Rust，它解决了性能瓶颈；通过抛弃 PostCSS，它简化了架构；通过转向 CSS-First 配置，它拥抱了 Web 标准。</p>
<p>如果说 v3 让 Tailwind 成为了主流，那么 v4 则让它成为了**“不可替代”**的基础设施。对于任何追求极致开发体验和性能的团队来说，升级到 v4 都是一个无需犹豫的选择。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[computed、watch 与 watchEffect 的使用边界与实战指南]]></title>    <link>https://juejin.cn/post/7593262196844724276</link>    <guid>https://juejin.cn/post/7593262196844724276</guid>    <pubDate>2026-01-10T15:11:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593262196844724276" data-draft-id="7593177437081927731" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="computed、watch 与 watchEffect 的使用边界与实战指南"/> <meta itemprop="keywords" content="Vue.js,JavaScript"/> <meta itemprop="datePublished" content="2026-01-10T15:11:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="boooooooom"/> <meta itemprop="url" content="https://juejin.cn/user/3078273283917399"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            computed、watch 与 watchEffect 的使用边界与实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3078273283917399/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    boooooooom
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:11:13.000Z" title="Sat Jan 10 2026 15:11:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;color:#3c9dff}.markdown-body h1{font-size:30px;margin-bottom:5px;padding-bottom:8px;text-align:center}.markdown-body h2{font-size:24px;padding-bottom:6px}.markdown-body h2:before{content:"🍋"}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h3:before{content:"🍓"}.markdown-body h4{font-size:16px}.markdown-body h4:before{content:"🍑"}.markdown-body h5{font-size:15px}.markdown-body h5:before{content:"🍉"}.markdown-body h6{margin-top:5px}.markdown-body h6:before{content:"🍒"}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;margin:0 auto;max-width:100%;border-radius:4px;padding:1px;border:1px solid #d2e8ff}.markdown-body img:hover{box-shadow:0 1px 3px #5eaeff}.markdown-body hr{height:4px;margin:34px 0;background-size:4px 1px;background-image:linear-gradient(270deg,#5eaeff,#f3f9ff 25%,transparent 50%);border-style:none}.markdown-body code{word-break:break-word;border-radius:3px;overflow-x:auto;background-color:#d2e8ff;color:#3c9dff;font-size:.9em;padding:.1em .5em;margin:0 3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;transition:all .3s}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:1px solid #90c7ff;border-radius:4px}.markdown-body pre:hover{box-shadow:0 1px 10px #beddff}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#3c9dff;border-bottom:1px solid #90c7ff;transition:all .3s}.markdown-body a:hover{color:#007fff;border-bottom:2px solid #5eaeff}.markdown-body a[href]:not(:empty){padding-right:18px}.markdown-body a[href]:not(:empty):after{display:inline-block;width:16px;height:16px;margin-left:2px;content:"";background:url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxwYXRoIGQ9Ik0zODQgMTI4YTQ4IDQ4IDAgMDEyLjgxNiA5NS45MkwzODQgMjI0SDI1NmEzMiAzMiAwIDAwLTMxLjkyIDI5LjZMMjI0IDI1NnY1MTJhMzIgMzIgMCAwMDI5LjYgMzEuOTJsMi40LjA4aDUxMmEzMiAzMiAwIDAwMzEuOTItMjkuNmwuMDgtMi40VjY1NmE0OCA0OCAwIDAxOTUuOTItMi44MTZMODk2IDY1NnYxMTJhMTI4IDEyOCAwIDAxLTEyNCAxMjcuOTM2bC00IC4wNjRIMjU2YTEyOCAxMjggMCAwMS0xMjcuOTM2LTEyNGwtLjA2NC00VjI1NmExMjggMTI4IDAgMDExMjQtMTI3LjkzNmw0LS4wNjRoMTI4em0zODQgMGExMjggMTI4IDAgMDExMjcuOTM2IDEyNGwuMDY0IDR2MTYwYTQ4IDQ4IDAgMDEtOTUuOTIgMi44MTZMODAwIDQxNlYyOTEuODcybC0zODIuMDY0IDM4Mi4wOGE0OCA0OCAwIDAxLTcwLjAzMi02NS42bDIuMTYtMi4yODhMNzMyLjA5NiAyMjRINjA4YTQ4IDQ4IDAgMDEtMi44MTYtOTUuOTJMNjA4IDEyOGgxNjB6IiBmaWxsPSIjM2M5ZGZmIiBmaWxsLW9wYWNpdHk9Ii41NiIgZGF0YS1zcG0tYW5jaG9yLWlkPSJhMzEzeC5zZWFyY2hfaW5kZXguMC5pMC41Yzc1M2E4MTgwa2RKWCIgY2xhc3M9InNlbGVjdGVkIi8+PC9zdmc+);background-size:100%}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #3c9dff}.markdown-body thead{text-align:center}.markdown-body thead th{color:#fff;background-color:#5eaeff}.markdown-body tr{text-align:center}.markdown-body tbody tr:hover{background-color:#d2e8ff}.markdown-body tbody tr:hover code{background-color:#90c7ff}.markdown-body tr:nth-child(2n){background-color:#ecf5ff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5eaeff}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{font-weight:900;padding:0 1px;font-size:17px}.markdown-body small{color:#cbcbcb;padding:0 1px;font-size:22px;zoom:.5}.markdown-body em{padding:0 1px}.markdown-body del{padding:0 1px;text-decoration-thickness:2px}.markdown-body blockquote{color:#1a1b1c;padding:1px 20px;margin:22px 0;border-radius:4px;border-left:4px solid rgba(60,157,255,.5);background-color:rgba(190,221,255,.3)}.markdown-body blockquote blockquote{margin:8px 0}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{margin:12px 0;padding:4px 10px;border:2px solid #3c9dff;border-radius:8px;background-color:#ecf5ff;transition:all .3s}.markdown-body details summary{cursor:pointer}.markdown-body input[type=checkbox]{position:relative;appearance:none;width:16px;height:16px;border-radius:2px;vertical-align:middle;transform:translateY(-2px);box-sizing:border-box;border:1px solid #beddff}.markdown-body input[type=checkbox]:checked{border:1px solid #5eaeff;background-color:#5eaeff}.markdown-body input[type=checkbox]:checked:before{position:absolute;top:3px;left:1px;width:11px;height:6px;background-color:transparent;border-left:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(-45deg);content:"";box-sizing:border-box}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="androidstudio">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#a9b7c6;background:#282b2e}.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#6897bb}.hljs-deletion,.hljs-keyword,.hljs-selector-tag{color:#cc7832}.hljs-link,.hljs-template-variable,.hljs-variable{color:#629755}.hljs-comment,.hljs-quote{color:grey}.hljs-meta{color:#bbb529}.hljs-addition,.hljs-attribute,.hljs-string{color:#6a8759}.hljs-section,.hljs-title,.hljs-type{color:#ffc66d}.hljs-name,.hljs-selector-class,.hljs-selector-id{color:#e8bf6a}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue3 中 computed、watch 与 watchEffect 的使用边界与实战指南</h2>
<p>在 Vue3 的响应式系统中，computed、watch 和 watchEffect 是处理响应式数据依赖的核心 API。它们看似都能监听数据变化并执行相应逻辑，但各自的设计初衷、适用场景和使用边界存在显著差异。很多开发者在实际开发中容易混淆三者的用法，导致出现性能冗余、逻辑混乱甚至响应式失效的问题。本文将从“边界”视角出发，深入剖析三者的核心定位、适用场景、禁忌用法及实战技巧，帮助开发者精准把握其使用边界，写出更优雅、高效的响应式代码。</p>
<h3 data-id="heading-1">一、核心定位：明确边界的前提</h3>
<p>要掌握三者的使用边界，首先需要明确它们的核心定位——Vue 团队在设计这三个 API 时，赋予了它们截然不同的职责：</p>
<ul>
<li><strong>computed（计算属性）</strong> ：核心定位是“派生状态”，用于基于已有响应式数据生成新的响应式数据。它的本质是“数据的加工者”，专注于数据的转换与派生，而非执行副作用。</li>
<li><strong>watch（监听器）</strong> ：核心定位是“数据变化的响应器”，用于监听特定响应式数据的变化，并在变化时执行自定义逻辑（通常是副作用）。它的特点是“精准监听、主动触发”，需要明确指定监听目标。</li>
<li><strong>watchEffect（副作用监听器）</strong> ：核心定位是“隐式依赖的副作用执行器”，用于自动追踪函数内部的响应式依赖，当依赖变化时重新执行函数（副作用）。它的特点是“隐式监听、自动触发”，无需指定监听目标，依赖由函数内部使用自动收集。</li>
</ul>
<p>简单来说：computed 管“数据派生”，watch 管“精准副作用”，watchEffect 管“隐式依赖副作用”。这一定位差异，是划分它们使用边界的根本依据。</p>
<h3 data-id="heading-2">二、computed 的使用边界：只做派生，不做副作用</h3>
<p>computed 的设计初衷是为了简化“基于已有数据生成新数据”的场景，它具有缓存机制（只有依赖变化时才重新计算），能有效提升性能。但它的边界也非常明确：<strong>仅用于数据派生，禁止在其中执行副作用</strong>。</p>
<h4 data-id="heading-3">2.1 适用场景</h4>
<ul>
<li>基于多个响应式数据的组合/转换生成新数据（如拼接字符串、计算总和、过滤数组）；</li>
<li>需要对数据进行格式化处理（如日期格式化、金额千分位处理）；</li>
<li>依赖数据变化时需要自动更新的派生状态（如购物车总价、列表筛选结果）。</li>
</ul>
<p>示例：购物车总价计算（典型的派生状态场景）</p>
<pre><code class="hljs language-vue" lang="vue">import { ref, computed } from 'vue';

const cartItems = ref([
  { id: 1, name: '手机', price: 5999, quantity: 1 },
  { id: 2, name: '耳机', price: 1299, quantity: 2 }
]);

// 正确：computed 用于派生购物车总价
const totalPrice = computed(() =&gt; {
  return cartItems.value.reduce((sum, item) =&gt; {
    return sum + item.price * item.quantity;
  }, 0);
});
</code></pre>
<h4 data-id="heading-4">2.2 禁忌边界（绝对不能做的事）</h4>
<ol>
<li><strong>禁止执行副作用操作</strong>：如修改 DOM、发送网络请求、修改其他响应式数据、打印日志等。computed 的回调函数应是“纯函数”（输入不变则输出不变，无副作用），否则会导致逻辑混乱、响应式追踪异常。</li>
<li><strong>禁止依赖非响应式数据</strong>：computed 仅能追踪响应式数据（ref/reactive）的变化，依赖非响应式数据（如普通变量、全局变量）会导致计算结果无法自动更新。</li>
<li><strong>禁止过度复杂的计算逻辑</strong>：computed 适合简单的数据派生，若包含大量循环、复杂算法，会阻塞页面渲染。复杂计算应拆分到方法中，或使用防抖/节流处理。</li>
</ol>
<p>错误示例（computed 中执行副作用）：</p>
<pre><code class="hljs language-vue" lang="vue">// 错误：在 computed 中发送网络请求（副作用）
const userInfo = computed(async () =&gt; {
  const res = await fetch(`/api/user/${userId.value}`); // 副作用
  return res.json();
});

// 错误：在 computed 中修改其他响应式数据（副作用）
const count = ref(0);
const doubleCount = computed(() =&gt; {
  count.value += 1; // 修改其他响应式数据，导致死循环
  return count.value * 2;
});
</code></pre>
<h4 data-id="heading-5">2.3 实战注意点</h4>
<ul>
<li>利用缓存机制：computed 的缓存特性可以避免重复计算，但若依赖的响应式数据未变化，多次访问 computed 会直接返回缓存结果，无需重新计算。</li>
<li>避免循环依赖：两个 computed 相互依赖会导致无限循环，应重构逻辑，拆分依赖关系。</li>
<li>只读与可写 computed：默认 computed 是只读的，若需要修改 computed 的值，可通过 set 方法定义可写 computed，但需确保逻辑清晰，避免破坏派生关系。</li>
</ul>
<h3 data-id="heading-6">三、watch 的使用边界：精准监听，副作用可控</h3>
<p>watch 是 Vue 中最常用的监听 API，它的核心优势是“精准控制”——可以明确指定监听目标、深度监听、控制执行时机。其使用边界在于：<strong>仅用于监听特定数据变化并执行可控的副作用，避免过度监听或监听不明确的目标</strong>。</p>
<h4 data-id="heading-7">3.1 适用场景</h4>
<ul>
<li>监听特定响应式数据变化，执行副作用（如发送网络请求、修改 DOM、更新全局状态）；</li>
<li>需要获取数据变化前后的值（oldValue 和 newValue）；</li>
<li>需要控制监听时机（如初始执行、深度监听对象/数组内部变化）；</li>
<li>需要条件性执行副作用（如仅当数据变化满足特定条件时执行）。</li>
</ul>
<p>示例：监听用户 ID 变化，重新获取用户信息（精准监听 + 副作用）</p>
<pre><code class="hljs language-vue" lang="vue">import { ref, watch } from 'vue';

const userId = ref(1);
const userInfo = ref(null);

// 正确：watch 监听 userId 变化，发送网络请求（副作用）
watch(userId, async (newId, oldId) =&gt; {
  console.log(`用户 ID 从 ${oldId} 变为 ${newId}`);
  const res = await fetch(`/api/user/${newId}`);
  userInfo.value = res.json();
}, {
  immediate: true, // 初始执行一次（页面加载时获取默认用户信息）
  deep: false // 基本类型无需深度监听，默认 false
});
</code></pre>
<h4 data-id="heading-8">3.3 禁忌边界（绝对不能做的事）</h4>
<ol>
<li><strong>禁止监听非响应式数据</strong>：watch 无法追踪普通变量、全局变量的变化，监听这些数据会导致回调函数永远不执行。</li>
<li><strong>禁止过度深度监听</strong>：对大型对象/数组进行深度监听（deep: true）会严重影响性能，因为 Vue 会递归遍历整个数据结构。应尽量监听对象的具体属性（如 watch(() =&gt; obj.xxx)）。</li>
<li><strong>禁止在 watch 中修改监听目标本身</strong>：这会导致无限循环（数据变化 → watch 执行 → 修改数据 → 再次触发 watch）。</li>
<li><strong>禁止监听过多目标</strong>：一个 watch 监听多个不相关的目标会导致逻辑混乱，应拆分多个 watch，每个 watch 专注于一个监听目标。</li>
</ol>
<p>错误示例（过度深度监听 + 循环修改）：</p>
<pre><code class="hljs language-vue" lang="vue">const largeObj = ref({ /* 大型对象，包含几十层嵌套 */ });

// 错误：过度深度监听，严重影响性能
watch(largeObj, (newObj) =&gt; {
  console.log('大型对象变化', newObj);
}, { deep: true });

// 错误：watch 中修改监听目标，导致无限循环
const count = ref(0);
watch(count, (newVal) =&gt; {
  count.value = newVal + 1; // 修改监听目标，触发无限循环
});
</code></pre>
<h4 data-id="heading-9">3.3 实战注意点</h4>
<ul>
<li>监听对象属性：对于 reactive 对象的单个属性，应使用函数形式指定监听目标（watch(() =&gt; obj.xxx, ...)），避免直接监听 obj.xxx（无法正确追踪）。</li>
<li>清理副作用：若 watch 中包含异步操作（如定时器、网络请求），应在回调函数中返回清理函数，避免内存泄漏（如组件卸载时取消未完成的请求）。</li>
<li>控制初始执行：通过 immediate: true 控制是否在初始时执行回调，避免重复编写初始化逻辑。</li>
</ul>
<h3 data-id="heading-10">四、watchEffect 的使用边界：隐式依赖，简化副作用</h3>
<p>watchEffect 是 Vue3 新增的 API，它的核心优势是“简化”——无需指定监听目标，自动追踪函数内部的响应式依赖。其使用边界在于：<strong>仅用于副作用逻辑简单、依赖明确且无需获取旧值的场景，避免依赖模糊导致的逻辑不可控</strong>。</p>
<h4 data-id="heading-11">4.1 适用场景</h4>
<ul>
<li>副作用逻辑依赖多个响应式数据，且无需区分具体哪个数据变化；</li>
<li>无需获取数据变化前后的旧值，只需在依赖变化时重新执行副作用；</li>
<li>简单的副作用操作（如更新 DOM、打印日志、同步状态）。</li>
</ul>
<p>示例：监听搜索关键词和分页变化，重新获取列表数据（多依赖简化监听）</p>
<pre><code class="hljs language-ini" lang="ini">import { ref, watchEffect } from 'vue'<span class="hljs-comment">;</span>

const <span class="hljs-attr">keyword</span> = ref(<span class="hljs-string">''</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">page</span> = ref(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">list</span> = ref([])<span class="hljs-comment">;</span>

// 正确：watchEffect 自动追踪 keyword 和 page 的变化
watchEffect(async () =&gt; {
  const <span class="hljs-attr">res</span> = await fetch(`/api/list?keyword=<span class="hljs-variable">${keyword.value}</span>&amp;page=<span class="hljs-variable">${page.value}</span>`)<span class="hljs-comment">;</span>
  <span class="hljs-attr">list.value</span> = res.json()<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>上述场景若用 watch 实现，需要监听 [keyword, page] 两个目标，而 watchEffect 只需在函数内部使用依赖，即可自动追踪，代码更简洁。</p>
<h4 data-id="heading-12">4.2 禁忌边界（绝对不能做的事）</h4>
<ol>
<li><strong>禁止依赖模糊的逻辑</strong>：若函数内部包含大量条件判断，导致依赖关系不明确，会增加调试难度（无法直观知道哪些数据会触发副作用）。</li>
<li><strong>禁止需要获取旧值的场景</strong>：watchEffect 无法获取数据变化前后的旧值，若需要对比新旧值，必须使用 watch。</li>
<li><strong>禁止在函数内部创建未清理的长期副作用</strong>：如未清除的定时器、未取消的事件监听，会导致内存泄漏（需使用 onInvalidate 清理）。</li>
<li><strong>禁止过度复杂的逻辑</strong>：watchEffect 适合简单的副作用，复杂逻辑应拆分，避免函数体积过大、可读性差。</li>
</ol>
<p>错误示例（需要旧值却用 watchEffect）：</p>
<pre><code class="hljs language-vue" lang="vue">const count = ref(0);

// 错误：需要对比新旧值，watchEffect 无法实现
watchEffect((onInvalidate) =&gt; {
  console.log(`count 变化了，旧值：?，新值：${count.value}`); // 无法获取旧值
});

// 正确：使用 watch 获取新旧值
watch(count, (newVal, oldVal) =&gt; {
  console.log(`count 变化了，旧值：${oldVal}，新值：${newVal}`);
});
</code></pre>
<h4 data-id="heading-13">4.3 实战注意点</h4>
<ul>
<li>清理副作用：通过 onInvalidate 函数清理长期副作用（如定时器、网络请求），确保组件卸载时不会残留资源。</li>
<li>控制执行时机：默认 watchEffect 在组件渲染前执行，可通过 flush: 'post' 配置改为渲染后执行（避免修改 DOM 影响渲染）。</li>
<li>手动停止监听：watchEffect 返回一个停止函数，若需要条件性停止监听（如某个状态满足后不再监听），可调用该函数。</li>
</ul>
<h3 data-id="heading-14">五、三者核心差异对比与选择指南</h3>
<p>为了更清晰地划分使用边界，我们整理了三者的核心差异，并给出具体的选择指南：</p>
<h4 data-id="heading-15">5.1 核心差异对比</h4>









































<table><thead><tr><th>特性</th><th>computed</th><th>watch</th><th>watchEffect</th></tr></thead><tbody><tr><td>核心定位</td><td>派生状态（数据 → 数据）</td><td>精准监听（数据 → 副作用）</td><td>隐式监听（副作用 → 自动追踪数据）</td></tr><tr><td>是否需要指定目标</td><td>无需（自动追踪依赖）</td><td>需要（明确监听目标）</td><td>无需（自动追踪函数内依赖）</td></tr><tr><td>是否能获取旧值</td><td>不能</td><td>能（newVal, oldVal）</td><td>不能</td></tr><tr><td>是否执行副作用</td><td>禁止</td><td>允许（核心用途）</td><td>允许（核心用途）</td></tr><tr><td>缓存机制</td><td>有（依赖不变则缓存）</td><td>无（变化即执行）</td><td>无（依赖变化即执行）</td></tr></tbody></table>
<h4 data-id="heading-16">5.2 选择指南（一句话总结）</h4>
<ul>
<li>当需要<strong>派生新的响应式数据</strong>时，用 computed；</li>
<li>当需要<strong>精准监听特定数据变化</strong>，且可能需要<strong>新旧值对比</strong>或<strong>控制执行时机</strong>时，用 watch；</li>
<li>当需要<strong>执行副作用</strong>，且副作用依赖的响应式数据较多，无需区分具体目标、无需新旧值对比时，用 watchEffect。</li>
</ul>
<h3 data-id="heading-17">六、实战避坑：常见边界错误与修复方案</h3>
<p>结合实际开发场景，我们整理了以下常见的边界错误及对应的修复方案，帮助开发者快速避坑：</p>
<h4 data-id="heading-18">6.1 错误 1：用 computed 发送网络请求</h4>
<p>错误原因：违反 computed 禁止副作用的边界。</p>
<pre><code class="hljs language-ini" lang="ini">// 错误
const <span class="hljs-attr">userInfo</span> = computed(async () =&gt; {
  const <span class="hljs-attr">res</span> = await fetch(`/api/user/<span class="hljs-variable">${userId.value}</span>`)<span class="hljs-comment">;</span>
  return res.json()<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>修复方案：改用 watch 或 watchEffect（根据是否需要精准监听）。</p>
<pre><code class="hljs language-ini" lang="ini">// 正确（需要精准监听 userId，用 watch）
const <span class="hljs-attr">userInfo</span> = ref(null)<span class="hljs-comment">;</span>
watch(userId, async (newId) =&gt; {
  const <span class="hljs-attr">res</span> = await fetch(`/api/user/<span class="hljs-variable">${newId}</span>`)<span class="hljs-comment">;</span>
  <span class="hljs-attr">userInfo.value</span> = res.json()<span class="hljs-comment">;</span>
}, { immediate: true })<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-19">6.2 错误 2：用 watch 监听整个大对象，开启 deep: true</h4>
<p>错误原因：过度深度监听，性能损耗大。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">form</span> = <span class="hljs-title function_ invoke__">ref</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">address</span>: { <span class="hljs-attr">province</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">city</span>: <span class="hljs-string">''</span> } });
<span class="hljs-title function_ invoke__">watch</span>(form, (newForm) =&gt; {
  console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">'表单变化'</span>, newForm);
}, { deep: <span class="hljs-literal">true</span> });
</code></pre>
<p>修复方案：监听对象的具体属性，避免深度监听整个对象。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 正确（监听具体属性）</span>
<span class="hljs-title function_">watch</span>(
  <span class="hljs-function">() =&gt;</span> [form.<span class="hljs-property">value</span>.<span class="hljs-property">name</span>, form.<span class="hljs-property">value</span>.<span class="hljs-property">address</span>.<span class="hljs-property">city</span>],
  <span class="hljs-function">(<span class="hljs-params">[newName, newCity]</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'关键属性变化'</span>, newName, newCity);
  }
);
</code></pre>
<h4 data-id="heading-20">6.3 错误 3：用 watchEffect 却需要获取旧值</h4>
<p>错误原因：违反 watchEffect 无法获取旧值的边界。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count 从 <span class="hljs-subst">${?}</span> 变为 <span class="hljs-subst">${count.value}</span>`</span>); <span class="hljs-comment">// 无法获取旧值</span>
});
</code></pre>
<p>修复方案：改用 watch。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 正确</span>
<span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count 从 <span class="hljs-subst">${oldVal}</span> 变为 <span class="hljs-subst">${newVal}</span>`</span>);
});
</code></pre>
<h3 data-id="heading-21">七、总结</h3>
<p>Vue3 的 computed、watch、watchEffect 虽同属响应式依赖处理 API，但边界清晰：computed 专注“数据派生”，watch 专注“精准副作用”，watchEffect 专注“简化隐式依赖副作用”。掌握它们的使用边界，核心在于理解其设计初衷——避免“用错工具”导致的性能问题和逻辑混乱。</p>
<p>在实际开发中，应遵循“数据派生用 computed，精准监听用 watch，多依赖副作用用 watchEffect”的原则，同时避开各自的禁忌边界（如 computed 不做副作用、watch 不过度深度监听、watchEffect 不依赖模糊逻辑）。只有精准把握边界，才能充分发挥 Vue3 响应式系统的优势，写出更高效、可维护的代码。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue createRenderer 自定义渲染器从入门到实战]]></title>    <link>https://juejin.cn/post/7593528990846615603</link>    <guid>https://juejin.cn/post/7593528990846615603</guid>    <pubDate>2026-01-10T15:44:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593528990846615603" data-draft-id="7593337928307867674" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue createRenderer 自定义渲染器从入门到实战"/> <meta itemprop="keywords" content="Vue.js,前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-10T15:44:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="如果你好"/> <meta itemprop="url" content="https://juejin.cn/user/2272012281328215"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue createRenderer 自定义渲染器从入门到实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2272012281328215/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    如果你好
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:44:50.000Z" title="Sat Jan 10 2026 15:44:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue createRenderer 自定义渲染器从入门到实战</h2>
<blockquote>
<p>🔥 Vue 3它不仅能高效渲染浏览器 DOM，还能实现小程序、Native 等多端运行。而支撑这一切的核心，就是 <code>createRenderer</code> 函数。它允许我们自定义渲染逻辑，摆脱 Vue 内置 DOM 渲染的限制，打造适配任意平台的渲染器</p>
</blockquote>
<h3 data-id="heading-1">一、自定义 DOM 渲染器</h3>
<p>示例重点实现支持事件绑定的 <code>patchProp</code> 方法，还会加入虚拟节点更新案例，直观看到渲染器的更新流程。</p>
<h4 data-id="heading-2">完整可运行代码</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue 自定义渲染器入门示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 引入 Vue 3 完整版，方便浏览器直接运行 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/vue@3/dist/vue.global.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 渲染挂载容器 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// 从 Vue 中解构出 createRenderer 和 h 函数</span>
    <span class="hljs-keyword">const</span> { createRenderer, h } = <span class="hljs-title class_">Vue</span>;

    <span class="hljs-comment">// 1. 创建自定义渲染器：传入平台渲染配置对象</span>
    <span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>({
      <span class="hljs-comment">// 创建元素节点：根据标签名创建 DOM 元素</span>
      <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 创建元素节点：&lt;<span class="hljs-subst">${tag}</span>&gt;`</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag);
      },

      <span class="hljs-comment">// 更新元素属性：核心改造！支持普通属性 + 事件绑定（onXXX 格式）</span>
      <span class="hljs-title function_">patchProp</span>(<span class="hljs-params">el, key, prevValue, nextValue</span>) {
        <span class="hljs-comment">// 判断是否是事件属性（以 on 开头，且第二个字母大写，如 onClick、onInput）</span>
        <span class="hljs-keyword">const</span> isEvent = key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'on'</span>) &amp;&amp; <span class="hljs-regexp">/^on[A-Z]/</span>.<span class="hljs-title function_">test</span>(key);
        
        <span class="hljs-keyword">if</span> (isEvent) {
          <span class="hljs-comment">// 提取事件名（去掉 on 前缀，转为小写，如 onClick -&gt; click）</span>
          <span class="hljs-keyword">const</span> eventName = key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>();
          
          <span class="hljs-comment">// 移除旧的事件监听（如果有旧值）</span>
          <span class="hljs-keyword">if</span> (prevValue) {
            el.<span class="hljs-title function_">removeEventListener</span>(eventName, prevValue);
          }
          
          <span class="hljs-comment">// 绑定新的事件监听（如果有新值）</span>
          <span class="hljs-keyword">if</span> (nextValue) {
            el.<span class="hljs-title function_">addEventListener</span>(eventName, nextValue);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 绑定事件：<span class="hljs-subst">${eventName}</span>，回调函数已挂载`</span>);
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 普通属性：直接用 setAttribute 处理</span>
          <span class="hljs-keyword">if</span> (nextValue === <span class="hljs-literal">undefined</span> || nextValue === <span class="hljs-literal">null</span>) {
            el.<span class="hljs-title function_">removeAttribute</span>(key);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 移除普通属性：<span class="hljs-subst">${key}</span>`</span>);
          } <span class="hljs-keyword">else</span> {
            el.<span class="hljs-title function_">setAttribute</span>(key, nextValue);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 更新普通属性：<span class="hljs-subst">${key}</span> = <span class="hljs-subst">${nextValue}</span>`</span>);
          }
        }
      },

      <span class="hljs-comment">// 插入元素：将子元素插入到父元素的指定位置</span>
      <span class="hljs-title function_">insert</span>(<span class="hljs-params">el, parent, anchor</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 插入元素：将 &lt;<span class="hljs-subst">${el.tagName.toLowerCase()}</span>&gt; 插入到 &lt;<span class="hljs-subst">${parent.tagName.toLowerCase()}</span>&gt;`</span>);
        parent.<span class="hljs-title function_">insertBefore</span>(el, anchor || <span class="hljs-literal">null</span>);
      },

      <span class="hljs-comment">// 移除元素：从父节点中移除当前元素</span>
      <span class="hljs-title function_">remove</span>(<span class="hljs-params">el</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 移除元素：&lt;<span class="hljs-subst">${el.tagName.toLowerCase()}</span>&gt;`</span>);
        el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el);
      },

      <span class="hljs-comment">// 创建文本节点：创建 DOM 文本节点</span>
      <span class="hljs-title function_">createText</span>(<span class="hljs-params">text</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 创建文本节点：<span class="hljs-subst">${text}</span>`</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(text);
      },

      <span class="hljs-comment">// 更新文本节点：修改文本节点的内容</span>
      <span class="hljs-title function_">setText</span>(<span class="hljs-params">node, text</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[渲染步骤] 更新文本节点：<span class="hljs-subst">${node.nodeValue}</span> → <span class="hljs-subst">${text}</span>`</span>);
        node.<span class="hljs-property">nodeValue</span> = text;
      }
    });

    <span class="hljs-comment">// 2. 获取挂载容器</span>
    <span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'app'</span>);

    <span class="hljs-comment">// 3. 初始虚拟节点（无事件）</span>
    <span class="hljs-keyword">const</span> vnode1 = <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">title</span>: <span class="hljs-string">'初始节点'</span> }, <span class="hljs-string">'Hello initial vnode'</span>);

    <span class="hljs-comment">// 4. 1秒后更新的虚拟节点（带 onClick 事件）</span>
    <span class="hljs-keyword">const</span> vnode2 = <span class="hljs-title function_">h</span>(
      <span class="hljs-string">'div'</span>,
      {
        <span class="hljs-title function_">onClick</span>(<span class="hljs-params"/>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'更新了！点击事件触发成功～'</span>);
        },
        <span class="hljs-attr">title</span>: <span class="hljs-string">'更新后节点（带点击事件）'</span> <span class="hljs-comment">// 同时更新普通属性</span>
      },
      <span class="hljs-string">'hello world'</span>
    );

    <span class="hljs-comment">// 5. 先渲染初始虚拟节点</span>
    renderer.<span class="hljs-title function_">render</span>(vnode1, app);

    <span class="hljs-comment">// 6. 1秒后更新虚拟节点，触发 patchProp 处理事件和属性更新</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'==== 开始更新虚拟节点 ===='</span>);
      renderer.<span class="hljs-title function_">render</span>(vnode2, app);
    }, <span class="hljs-number">1000</span>);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 data-id="heading-3">运行效果</h4>
<ol>
<li>打开浏览器运行该 HTML 文件，页面先显示 <code>Hello initial vnode</code>，鼠标悬浮弹出「初始节点」提示；</li>
<li>1秒后，文本自动更新为 <code>hello world</code>，悬浮提示变为「更新后节点（带点击事件）」；</li>
<li>点击文本所在的 <code>div</code>，控制台打印 <code>更新了！点击事件触发成功～</code>；</li>
<li>全程控制台会清晰打印渲染、更新、事件绑定的日志，直观看到自定义渲染器的完整执行流程。</li>
</ol>
<h3 data-id="heading-4">二、核心拆解：这段代码到底在做什么？</h3>
<p>我们逐部分拆解代码，理解 <code>createRenderer</code> 的核心组成和工作逻辑，重点解析新增的虚拟节点更新案例。</p>
<h4 data-id="heading-5">1. 核心引入：<code>createRenderer</code> 和 <code>h</code> 函数</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { createRenderer, h } = <span class="hljs-title class_">Vue</span>;
</code></pre>
<p>这两个函数是实现自定义渲染的关键，各自承担核心职责：</p>
<ul>
<li><strong><code>createRenderer</code></strong>：Vue 3 提供的<strong>渲染器工厂函数</strong>，接收一套「平台渲染接口」，返回一个具备完整渲染能力的自定义渲染器实例。这个实例拥有 <code>createApp</code> 和 <code>render</code> 方法，和 Vue 默认的 DOM 渲染器功能一致，只是渲染逻辑由我们自定义。</li>
<li><strong><code>h</code> 函数</strong>：全称 <code>createVNode</code>，核心作用是<strong>构建虚拟 DOM 节点（VNode）</strong>。它接收标签名/组件、属性对象、子节点/文本内容，返回一个标准的 VNode 对象，作为渲染器的输入数据。</li>
</ul>
<h4 data-id="heading-6">2. 核心步骤：创建自定义渲染器（<code>createRenderer</code>）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>({ <span class="hljs-comment">/* 渲染配置对象 */</span> });
</code></pre>
<p><code>createRenderer</code> 接收一个<strong>配置对象</strong>作为唯一参数，这个对象必须实现 6 个核心方法，它们是渲染器与「目标平台」的交互桥梁，负责将 VNode 转换为目标平台的真实节点（这里是浏览器 DOM）。</p>
<h5 data-id="heading-7">6 个核心渲染方法详解（DOM 平台）</h5>








































<table><thead><tr><th>方法名</th><th>核心作用</th><th>入参说明</th></tr></thead><tbody><tr><td><code>createElement</code></td><td>创建元素节点</td><td><code>tag</code>：标签名（如 'div'、'p'），返回创建好的 DOM 元素</td></tr><tr><td><code>patchProp</code></td><td>更新元素属性</td><td><code>el</code>：真实 DOM 元素、<code>key</code>：属性名、<code>prevValue</code>：旧属性值、<code>nextValue</code>：新属性值</td></tr><tr><td><code>insert</code></td><td>插入元素</td><td><code>el</code>：要插入的 DOM 元素、<code>parent</code>：父 DOM 元素、<code>anchor</code>：插入参考节点（null 则插入末尾）</td></tr><tr><td><code>remove</code></td><td>移除元素</td><td><code>el</code>：要移除的 DOM 元素</td></tr><tr><td><code>createText</code></td><td>创建文本节点</td><td><code>text</code>：文本内容，返回创建好的 DOM 文本节点</td></tr><tr><td><code>setText</code></td><td>更新文本节点</td><td><code>node</code>：真实 DOM 文本节点、<code>text</code>：新的文本内容</td></tr></tbody></table>
<h5 data-id="heading-8">关键亮点：<code>patchProp</code> 支持事件绑定</h5>
<p>本次改造的核心是 <code>patchProp</code> 方法，它不仅能处理 <code>title</code> 这类普通属性，还能识别 <code>onClick</code> 这类事件属性，实现 DOM 事件的绑定与移除：</p>
<ul>
<li>先判断属性是否为 <code>onXXX</code> 格式的事件；</li>
<li>提取原生事件名（<code>onClick</code> → <code>click</code>）；</li>
<li>遵循「先清后绑」原则，避免重复绑定导致多次触发。</li>
</ul>
<h4 data-id="heading-9">3. 新增亮点：虚拟节点更新案例（核心解析）</h4>
<p>自定义渲染器如何处理 VNode 更新，这也是 Vue 响应式更新的底层缩影：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 2. 获取挂载容器</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'app'</span>);

<span class="hljs-comment">// 3. 初始虚拟节点（无事件）</span>
<span class="hljs-keyword">const</span> vnode1 = <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">title</span>: <span class="hljs-string">'初始节点'</span> }, <span class="hljs-string">'Hello initial vnode'</span>);

<span class="hljs-comment">// 4. 1秒后更新的虚拟节点（带 onClick 事件）</span>
<span class="hljs-keyword">const</span> vnode2 = <span class="hljs-title function_">h</span>(
  <span class="hljs-string">'div'</span>,
  {
    <span class="hljs-title function_">onClick</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'更新了！点击事件触发成功～'</span>);
    },
    <span class="hljs-attr">title</span>: <span class="hljs-string">'更新后节点（带点击事件）'</span> <span class="hljs-comment">// 同时更新普通属性</span>
  },
  <span class="hljs-string">'hello world'</span>
);

<span class="hljs-comment">// 5. 先渲染初始虚拟节点</span>
renderer.<span class="hljs-title function_">render</span>(vnode1, app);

<span class="hljs-comment">// 6. 1秒后更新虚拟节点，触发 patchProp 处理事件和属性更新</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'==== 开始更新虚拟节点 ===='</span>);
  renderer.<span class="hljs-title function_">render</span>(vnode2, app);
}, <span class="hljs-number">1000</span>);
</code></pre>
<h5 data-id="heading-10">这段代码的核心逻辑：</h5>
<ol>
<li><strong>初始渲染</strong>：调用 <code>renderer.render(vnode1, app)</code>，渲染器将 <code>vnode1</code> 转换为真实 DOM，插入到挂载容器中，完成首次渲染；</li>
<li><strong>延迟更新</strong>：1 秒后调用 <code>renderer.render(vnode2, app)</code>，渲染器会自动对比 <code>vnode1</code> 和 <code>vnode2</code> 的差异（属性、文本内容）；</li>
<li><strong>差异更新</strong>：
<ul>
<li>对于 <code>title</code> 属性：触发 <code>patchProp</code> 方法，将旧值「初始节点」更新为新值「更新后节点（带点击事件）」；</li>
<li>对于 <code>onClick</code> 事件：触发 <code>patchProp</code> 方法，绑定新的点击事件回调；</li>
<li>对于文本内容：触发 <code>setText</code> 方法，将「Hello initial vnode」更新为「hello world」；</li>
</ul>
</li>
<li><strong>无全量重建</strong>：整个更新过程没有删除旧 DOM 再创建新 DOM，而是只更新有差异的部分，这也是 Vue 渲染高效的核心原因。</li>
</ol>
<h4 data-id="heading-11">4. 挂载应用的两种方式</h4>
<p>案例使用 <code>renderer.render(vnode, container)</code> 直接渲染 VNode，除此之外，也可以通过 <code>renderer.createApp(component).mount(container)</code> 挂载组件，两种方式均有效：</p>
<ul>
<li>直接渲染 VNode：更灵活，适合手动控制渲染流程（如本次的延迟更新案例）；</li>
<li>通过 <code>createApp</code> 挂载：更贴近日常 Vue 开发，适合组件化开发场景。</li>
</ul>
<h3 data-id="heading-12">三、深入理解：自定义渲染器的工作流程</h3>
<p>整个渲染与更新过程可以总结为 4 个核心步骤，形成一个完整的闭环：</p>
<ol>
<li><strong>生成 VNode</strong>：通过 <code>h</code> 函数创建标准 VNode，提供渲染的数据源；</li>
<li><strong>首次渲染</strong>：渲染器调用 6 个核心方法，将 VNode 转换为真实节点，插入到挂载容器中；</li>
<li><strong>VNode 对比</strong>：更新时，渲染器对比新旧 VNode，找出属性、文本等差异；</li>
<li><strong>差异更新</strong>：针对差异部分，调用对应的 <code>patchProp</code>、<code>setText</code> 等方法，更新真实节点，无需全量重建。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从10分钟到30秒！Webpack 打包效率优化实战指南]]></title>    <link>https://juejin.cn/post/7593337928307916826</link>    <guid>https://juejin.cn/post/7593337928307916826</guid>    <pubDate>2026-01-10T15:51:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593337928307916826" data-draft-id="7593541291012079643" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从10分钟到30秒！Webpack 打包效率优化实战指南"/> <meta itemprop="keywords" content="Webpack,性能优化"/> <meta itemprop="datePublished" content="2026-01-10T15:51:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="把摸鱼做大做强"/> <meta itemprop="url" content="https://juejin.cn/user/3526889032921223"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从10分钟到30秒！Webpack 打包效率优化实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3526889032921223/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    把摸鱼做大做强
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:51:45.000Z" title="Sat Jan 10 2026 15:51:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>作为前端开发者，你是否经历过这些绝望时刻：</p>
<ul>
<li>开发时改一行代码，热更新要等半分钟；</li>
<li>生产环境打包，喝两杯咖啡回来还没结束；</li>
<li>项目越大，打包速度越慢，最后甚至影响迭代效率。</li>
</ul>
<p>Webpack 作为前端工程化的核心工具，其打包效率直接决定了开发体验和发布效率。本文结合实战经验，整理了一套“从基础到进阶”的 Webpack 打包优化方案，帮你把打包时间从“分钟级”压缩到“秒级”，亲测有效！</p>
<p>先明确核心优化思路：<strong>让 Webpack 只做必要的事，减少无效工作；让重复工作复用结果；让多核 CPU 并行干活</strong>。下面按这个思路逐步拆解。</p>
<h2 data-id="heading-1">一、基础优化：立竿见影的“减法操作”</h2>
<p>打包慢的核心原因之一是 Webpack 处理了过多不必要的文件。这一步先通过“缩小处理范围”做减法，优化成本最低，效果最明显。</p>
<h3 data-id="heading-2">1. 精准限定 loader 处理范围</h3>
<p>loader 是打包耗时的重灾区（比如 babel-loader、css-loader），很多时候我们会让 loader 处理所有符合规则的文件，但实际上只有 <code>src</code> 目录下的源码需要处理，<code>node_modules</code> 里的第三方库早已是编译好的代码，无需重复处理。</p>
<p>优化方案：用 <code>include</code> 限定处理目录，<code>exclude</code> 排除无需处理的目录（<code>exclude</code> 优先级更高）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.js$/</span>, <span class="hljs-comment">// 匹配 js 文件</span>
        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>), <span class="hljs-comment">// 只处理 src 目录下的 js</span>
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除 node_modules（第三方库无需 babel 转译）</span>
        <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>,
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,
        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>),
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>],
      }
    ],
  },
};
</code></pre>
<p>避坑提示：不要用 <code>exclude: /node_modules/</code> 同时又用 <code>include: 非 src 目录</code>，容易导致规则冲突，优先用 <code>include</code> 精准匹配。</p>
<h3 data-id="heading-3">2. 优化 resolve 配置：减少文件查找时间</h3>
<p>Webpack 解析模块时会按规则遍历查找文件，比如默认会查找 <code>.js</code>、<code>.json</code>、<code>.jsx</code> 等多种后缀，还会向上级目录查找 <code>node_modules</code>，这些都需要耗时。</p>
<p>优化方案：</p>
<ul>
<li>限定扩展名：只保留常用后缀，按使用频率排序；</li>
<li>指定模块查找目录：优先在项目本地 <code>node_modules</code> 查找，避免向上级目录遍历；</li>
<li>配置别名：缩短常用目录的查找路径，比如用<code>@</code> 代替 <code>src</code>。</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = {
  resolve: {
    <span class="hljs-comment">// 1. 限定扩展名，按使用频率排序（减少遍历次数）</span>
    extensions: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.json'</span>],
    <span class="hljs-comment">// 2. 指定模块查找目录（优先本地 node_modules）</span>
    modules: [path.resolve(__dirname, <span class="hljs-string">'node_modules'</span>)],
    <span class="hljs-comment">// 3. 配置别名（缩短路径查找，同时简化代码引入）</span>
    alias: {
      <span class="hljs-string">'@'</span>: path.resolve(__dirname, <span class="hljs-string">'src'</span>),
      <span class="hljs-string">'components'</span>: path.resolve(__dirname, <span class="hljs-string">'src/components'</span>),
      <span class="hljs-comment">// 对第三方库也可配置别名，直接指向优化后的版本</span>
      <span class="hljs-string">'react$'</span>: <span class="hljs-string">'react/dist/react.production.min.js'</span>,
      <span class="hljs-string">'react-dom$'</span>: <span class="hljs-string">'react-dom/dist/react-dom.production.min.js'</span>
    },
  },
};
</code></pre>
<p>效果：模块查找时间减少 30%+，同时代码中引入组件可以写成 <code>import Button from '@/components/Button'</code>，更简洁。</p>
<h3 data-id="heading-4">3. 用 externals 排除第三方库打包</h3>
<p>React、Vue、jQuery 这类第三方库体积大、不常变动，每次打包都要重复解析、压缩，非常耗时。我们可以把它们从打包流程中排除，改用 CDN 引入。</p>
<p>优化方案：配置 <code>externals</code>，告诉 Webpack 这些模块不需要打包，运行时从全局变量获取。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = {
  externals: {
    <span class="hljs-comment">// 键：代码中 import 的名称；值：CDN 引入后暴露的全局变量名</span>
    react: <span class="hljs-string">'React'</span>,
    <span class="hljs-string">'react-dom'</span>: <span class="hljs-string">'ReactDOM'</span>,
    vue: <span class="hljs-string">'Vue'</span>,
    jquery: <span class="hljs-string">'jQuery'</span>
  },
};
</code></pre>
<p>然后在 <code>index.html</code> 中引入 CDN 资源：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 引入 React 和 ReactDOM 的 CDN --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 引入 Vue 的 CDN --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>效果：打包体积大幅减小，打包时间直接减少 20%-50%（取决于第三方库的体积）。</p>
<h2 data-id="heading-5">二、进阶优化：复用结果，避免重复工作</h2>
<p>很多时候打包慢是因为“重复劳动”——比如每次打包都重新编译所有文件，哪怕大部分文件没变动。这一步通过“缓存”复用之前的构建结果，让 Webpack 只处理变动的文件。</p>
<h3 data-id="heading-6">1. Webpack 5 内置缓存（推荐）</h3>
<p>Webpack 5 自带了持久化缓存机制，无需额外安装插件，开启后会把构建结果缓存到文件系统，下次构建时直接复用未变动模块的缓存。</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">module</span>.exports = {
  cache: {
    type: <span class="hljs-string">'filesystem'</span>, <span class="hljs-comment">// 缓存类型：文件系统（比内存缓存更持久，重启终端不丢失）</span>
    cacheDirectory: path.<span class="hljs-built_in">resolve</span>(__dirname, <span class="hljs-string">'node_modules/.cache/webpack'</span>), <span class="hljs-comment">// 缓存存放目录</span>
    <span class="hljs-comment">// 可选：自定义缓存失效规则（默认文件内容变动则失效）</span>
    buildDependencies: {
      config: [__filename] <span class="hljs-comment">// 当 webpack 配置文件变动时，缓存失效</span>
    }
  },
};
</code></pre>
<p>效果：首次打包后，后续增量构建速度提升 60%+，比如之前改一行代码要等 20 秒，开启后可能只需要 5 秒。</p>
<h3 data-id="heading-7">2. 开启 loader 缓存（针对性优化）</h3>
<p>babel-loader 处理 JS/JSX 时耗时较高，开启它的专属缓存，能避免重复编译相同的文件。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> {
  <span class="hljs-attr">module:</span> {
    <span class="hljs-attr">rules:</span> [
      {
        <span class="hljs-attr">test:</span> <span class="hljs-string">/.js$/</span>,
        <span class="hljs-attr">exclude:</span> <span class="hljs-string">/node_modules/</span>,
        <span class="hljs-attr">use:</span> {
          <span class="hljs-attr">loader:</span> <span class="hljs-string">'babel-loader'</span>,
          <span class="hljs-attr">options:</span> {
            <span class="hljs-attr">cacheDirectory:</span> <span class="hljs-literal">true</span>, <span class="hljs-string">//</span> <span class="hljs-string">开启缓存，默认缓存到</span> <span class="hljs-string">node_modules/.cache/babel-loader</span>
            <span class="hljs-attr">cacheCompression:</span> <span class="hljs-literal">false</span>, <span class="hljs-string">//</span> <span class="hljs-string">开发环境关闭缓存压缩（提升缓存读取速度）</span>
          },
        },
      },
    ],
  },
}<span class="hljs-string">;</span>
</code></pre>
<h3 data-id="heading-8">3. 生产环境：hard-source-webpack-plugin（可选）</h3>
<p>如果需要更持久的缓存（比如跨构建过程复用），可以使用 <code>hard-source-webpack-plugin</code>，它会为每个模块生成独立的缓存，首次打包后，后续打包速度提升 50%+。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装</span>
npm install hard-source-webpack-plugin --save-dev
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hard-source-webpack-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span>(), <span class="hljs-comment">// 启用硬缓存</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span>.<span class="hljs-title class_">ExcludeModulePlugin</span>([
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/mini-css-extract-plugin[\/]dist[\/]loader/</span>, <span class="hljs-comment">// 排除部分易出错的 loader</span>
      },
    ]),
  ],
};
</code></pre>
<p>注意：开发环境优先用 Webpack 内置缓存，生产环境可根据需求选择；如果项目依赖频繁变动，硬缓存可能导致缓存失效不及时，需谨慎使用。</p>
<h2 data-id="heading-9">三、并行优化：让多核 CPU 火力全开</h2>
<p>Webpack 默认是单进程运行的，只能利用 CPU 的一个核心，而现代电脑都是多核 CPU，这就造成了资源浪费。通过多进程/多线程让多个核心同时干活，能大幅提升打包速度。</p>
<h3 data-id="heading-10">1. thread-loader：多线程处理 loader</h3>
<p>把耗时的 loader（如 babel-loader、ts-loader）放到独立的线程中处理，主线程只负责统筹，不阻塞构建流程。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.js$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-comment">// thread-loader 必须放在耗时 loader 前面</span>
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'thread-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">workers</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>).<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-comment">// 线程数 = CPU 核心数 - 1（避免占满 CPU）</span>
              <span class="hljs-attr">workerNodeArgs</span>: [<span class="hljs-string">'--max-old-space-size=1024'</span>], <span class="hljs-comment">// 给每个线程分配内存</span>
            },
          },
          <span class="hljs-string">'babel-loader'</span>, <span class="hljs-comment">// 耗时 loader 放到线程中处理</span>
        ],
      },
    ],
  },
};
</code></pre>
<p>避坑提示：thread-loader 不适合所有 loader，比如 file-loader（处理静态资源），多线程会增加文件 IO 开销，反而变慢；只对 babel-loader、ts-loader 这类 CPU 密集型 loader 生效。</p>
<h3 data-id="heading-11">2. 生产环境：多进程压缩代码</h3>
<p>生产环境需要压缩 JS、CSS，这是非常耗时的操作。默认是单进程压缩，我们可以开启多进程压缩。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>); <span class="hljs-comment">// JS 压缩插件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-minimizer-webpack-plugin'</span>); <span class="hljs-comment">// CSS 压缩插件</span>

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-comment">// 多进程压缩 JS</span>
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>({
        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 自动开启多进程（默认开启，线程数 = CPU 核心数 - 1）</span>
        <span class="hljs-attr">extractComments</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不提取注释（减少文件体积和处理时间）</span>
      }),
      <span class="hljs-comment">// 多进程压缩 CSS</span>
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>({
        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,
      }),
    ],
  },
};
</code></pre>
<h2 data-id="heading-12">四、环境专属优化：按需配置，不做无用功</h2>
<p>开发环境和生产环境的优化目标不同：开发环境追求“热更新速度”，生产环境追求“打包速度 + 产物体积”。分开配置，避免在开发环境启用生产环境的耗时插件（如压缩、代码分割）。</p>
<h3 data-id="heading-13">1. 开发环境优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.dev.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>, <span class="hljs-comment">// 开发模式默认开启：代码未压缩、tree-shaking 关闭等</span>
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'eval-cheap-module-source-map'</span>, <span class="hljs-comment">// 高效的 source map（速度快，调试体验好）</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
  },
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启热模块替换（HMR）：只更新变动模块，不刷新整个页面</span>
    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 自动打开浏览器</span>
    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,
    <span class="hljs-attr">static</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'public'</span>),
  },
  <span class="hljs-attr">cache</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'filesystem'</span>, <span class="hljs-comment">// 开启文件缓存</span>
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>(), <span class="hljs-comment">// HMR 核心插件</span>
  ],
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.js$/</span>,
        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>),
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'thread-loader'</span>, <span class="hljs-string">'babel-loader'</span>],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>], <span class="hljs-comment">// 开发环境用 style-loader 更快（无需提取 CSS）</span>
      },
    ],
  },
};
</code></pre>
<h3 data-id="heading-14">2. 生产环境优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.prod.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-minimizer-webpack-plugin'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>); <span class="hljs-comment">// 提取 CSS 为单独文件</span>

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>, <span class="hljs-comment">// 生产模式默认开启：代码压缩、tree-shaking、作用域提升等</span>
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'nosources-source-map'</span>, <span class="hljs-comment">// 不暴露源代码的 source map（兼顾调试和安全）</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[contenthash:8].js'</span>, <span class="hljs-comment">// 用 contenthash 做缓存优化</span>
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 打包前清空 dist 目录（避免旧文件残留）</span>
  },
  <span class="hljs-attr">cache</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'filesystem'</span>,
  },
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>({ <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span> }),
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>({ <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span> }),
    ],
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>, <span class="hljs-comment">// 拆分同步/异步 chunk</span>
      <span class="hljs-attr">cacheGroups</span>: {
        <span class="hljs-attr">vendor</span>: {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 把第三方库拆成单独 chunk（便于缓存）</span>
          <span class="hljs-attr">name</span>: <span class="hljs-string">'vendors'</span>,
          <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>,
        },
      },
    },
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[contenthash:8].css'</span>, <span class="hljs-comment">// 提取 CSS 并加 hash</span>
    }),
  ],
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.js$/</span>,
        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>),
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'thread-loader'</span>, <span class="hljs-string">'babel-loader'</span>],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">'css-loader'</span>], <span class="hljs-comment">// 生产环境提取 CSS（便于缓存和并行加载）</span>
      },
    ],
  },
};
</code></pre>
<h2 data-id="heading-15">五、关键工具：先分析瓶颈，再精准优化</h2>
<p>优化前一定要先找到打包慢的核心瓶颈，不要盲目加配置。推荐用 <code>webpack-bundle-analyzer</code> 分析打包体积和依赖关系，找到大文件、重复依赖等问题。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装</span>
npm install webpack-bundle-analyzer --save-dev
</code></pre>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">BundleAnalyzerPlugin</span> = require(<span class="hljs-string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin<span class="hljs-comment">;</span>

<span class="hljs-attr">module.exports</span> = {
  plugins: <span class="hljs-section">[
    new BundleAnalyzerPlugin({
      analyzerMode: 'server', // 启动服务器展示分析结果
      analyzerPort: 8888, // 端口号
    }),
  ]</span>,
}<span class="hljs-comment">;</span>
</code></pre>
<p>运行打包命令后，会自动打开浏览器，展示一个可视化的打包分析图：</p>
<ul>
<li>红色块：体积较大的文件，优先考虑拆分或替换为更小的替代方案；</li>
<li>重复依赖：比如多个组件都引入了 lodash，可以用 <code>lodash-es</code> 按需引入，或用 <code>ProvidePlugin</code> 全局引入；</li>
<li>不必要的依赖：比如把开发环境的依赖（如 mockjs）打包到生产环境，需要排除。</li>
</ul>
<h2 data-id="heading-16">六、其他优化小技巧</h2>
<ol>
<li>升级 Webpack 版本：Webpack 5 相比 4 有大幅性能提升（如持久化缓存、更好的 tree-shaking、模块联邦等），老项目优先升级；</li>
<li>避免在配置中做耗时操作：比如每次打包都读取文件、执行复杂计算，尽量提前计算好结果；</li>
<li>使用 ES 模块语法：CommonJS 模块无法被 tree-shaking 优化，尽量用 <code>import/export</code>；</li>
<li>关闭不必要的插件：比如开发环境关闭 <code>BundleAnalyzerPlugin</code>、<code>MiniCssExtractPlugin</code> 等生产环境插件。</li>
</ol>
<h2 data-id="heading-17">七、优化效果对比</h2>
<p>以一个中型 React 项目（约 50 个组件，依赖 React、Ant Design 等）为例，优化前后对比：</p>





























<table><thead><tr><th>场景</th><th>优化前</th><th>优化后</th><th>提升比例</th></tr></thead><tbody><tr><td>开发热更新（改一行代码）</td><td>25 秒</td><td>4 秒</td><td>84%</td></tr><tr><td>生产环境首次打包</td><td>8 分钟</td><td>1 分钟</td><td>87.5%</td></tr><tr><td>生产环境增量打包</td><td>3 分钟</td><td>30 秒</td><td>83.3%</td></tr></tbody></table>
<h2 data-id="heading-18">总结</h2>
<p>Webpack 打包优化的核心逻辑是“<strong>减少无效工作、复用已有成果、利用多核资源、按需环境配置</strong>”，按以下步骤逐步优化即可：</p>
<ol>
<li>基础优化：用 <code>include/exclude</code>、<code>resolve</code>、<code>externals</code> 缩小处理范围；</li>
<li>进阶优化：开启 Webpack 内置缓存、loader 缓存，减少重复构建；</li>
<li>并行优化：用 <code>thread-loader</code>、多进程压缩，利用多核 CPU；</li>
<li>环境适配：开发/生产环境分开配置，不做无用功；</li>
<li>精准优化：用 <code>webpack-bundle-analyzer</code> 找到瓶颈，针对性优化。</li>
</ol>
<p>优化不是一蹴而就的，建议逐步尝试，每加一个配置就测试一次打包速度，找到最适合自己项目的方案。如果你的项目有特殊场景（比如超大单页应用、多入口项目），欢迎在评论区留言，一起探讨优化方案！</p>
<p>最后，觉得有用的话，点赞 + 收藏，下次优化 Webpack 直接抄作业～ 🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[稳定性性能系列之十——卡顿问题分析:从掉帧到流畅体验]]></title>    <link>https://juejin.cn/post/7593310044479012873</link>    <guid>https://juejin.cn/post/7593310044479012873</guid>    <pubDate>2026-01-10T13:42:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593310044479012873" data-draft-id="7593311347292094491" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="稳定性性能系列之十——卡顿问题分析:从掉帧到流畅体验"/> <meta itemprop="keywords" content="Android,性能优化,Debug"/> <meta itemprop="datePublished" content="2026-01-10T13:42:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            稳定性性能系列之十——卡顿问题分析:从掉帧到流畅体验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:42:18.000Z" title="Sat Jan 10 2026 13:42:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>流畅度,是衡量App用户体验的核心指标。一个丝般顺滑的60fps和一个卡顿频繁的30fps,差的不仅仅是数字,更是用户的去留。本文将带你系统化地攻克卡顿问题。</p>
</blockquote>
<h2 data-id="heading-0">引言</h2>
<p>卡顿是Android应用开发中最常见的性能问题之一。当应用的帧率从流畅的60fps下降到30fps甚至更低时,用户会明显感受到操作不流畅、画面停滞,严重影响使用体验。</p>
<p><strong>卡顿的本质是掉帧</strong>。Android系统以60fps的标准刷新屏幕,即每帧必须在16.6ms内完成渲染。一旦超过这个时间阈值,就会发生掉帧,用户就能感知到卡顿。</p>
<h3 data-id="heading-1">一个典型的卡顿案例</h3>
<p>在实际开发中,我们遇到过这样一个问题:RecyclerView列表滑动时出现明显卡顿,帧率从60fps骤降到25-30fps。</p>
<p>通过Systrace分析,发现了问题根源:</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">Frame</span> <span class="hljs-comment">#245: 35ms (Dropped 2 frames) ← 超过16.6ms,掉了2帧</span>
  <span class="hljs-string">└─</span> <span class="hljs-attr">RecyclerView.onBindViewHolder:</span> <span class="hljs-string">28ms</span>
      <span class="hljs-string">├─</span> <span class="hljs-attr">BitmapFactory.decodeFile:</span> <span class="hljs-string">18ms</span>   <span class="hljs-string">←</span> <span class="hljs-string">主线程同步解码图片</span>
      <span class="hljs-string">├─</span> <span class="hljs-attr">TextView.setText:</span> <span class="hljs-string">5ms</span>
      <span class="hljs-string">└─</span> <span class="hljs-string">其他操作:</span> <span class="hljs-string">5ms</span>

<span class="hljs-string">Frame</span> <span class="hljs-comment">#246: 42ms (Dropped 3 frames) ← 又掉了3帧</span>
  <span class="hljs-string">└─</span> <span class="hljs-attr">RecyclerView.onBindViewHolder:</span> <span class="hljs-string">38ms</span>
      <span class="hljs-string">└─</span> <span class="hljs-attr">BitmapFactory.decodeFile:</span> <span class="hljs-string">32ms</span>   <span class="hljs-string">←</span> <span class="hljs-string">图片解码耗时过长</span>
</code></pre>
<p><strong>问题分析</strong>:</p>
<p>在<code>onBindViewHolder</code>中直接使用<code>BitmapFactory.decodeFile()</code>同步解码图片,每张图片耗时15-30ms。而60fps要求每帧在16.6ms内完成,单次解码就已经超时。用户滑动一次加载10个item,每个item都要解码一张图,累计耗时150-300ms,相当于<strong>9-18帧的卡顿</strong>。</p>
<p><strong>解决方案</strong>:</p>
<p>将图片解码改为异步加载,使用Glide等图片加载库:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ Before: 主线程同步解码</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">ViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
    <span class="hljs-keyword">val</span> bitmap = BitmapFactory.decodeFile(<span class="hljs-keyword">data</span>[position].imagePath) <span class="hljs-comment">// 18-32ms</span>
    holder.imageView.setImageBitmap(bitmap)
}

<span class="hljs-comment">// ✅ After: Glide异步加载+缓存</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">ViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
    Glide.with(holder.itemView.context)
        .load(<span class="hljs-keyword">data</span>[position].imagePath)
        .<span class="hljs-keyword">override</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>)  <span class="hljs-comment">// 缩放到目标尺寸</span>
        .centerCrop()
        .into(holder.imageView)
}
</code></pre>
<p>优化后,<code>onBindViewHolder</code>耗时从28ms降低到3ms,帧率恢复到58-60fps。</p>
<h3 data-id="heading-2">卡顿分析的重要性</h3>
<p>这个案例说明了<strong>精准定位问题</strong>的重要性。如果没有使用Systrace等工具进行系统化分析,可能会误判问题方向:</p>
<ul>
<li>怀疑是RecyclerView缓存策略问题,去优化缓存</li>
<li>怀疑是布局太复杂,去优化XML层级</li>
<li>怀疑是数据量太大,去做分页加载</li>
</ul>
<p>这些优化方向虽然也有价值,但都不是核心问题。<strong>只有通过工具和方法论,才能精准定位问题根源,高效解决问题。</strong></p>
<h3 data-id="heading-3">本文内容概览</h3>
<p>本文将系统化地讲解Android卡顿问题的分析与优化:</p>
<ol>
<li><strong>卡顿的本质</strong> - 掉帧机制、VSYNC信号、渲染管线流程</li>
<li><strong>分析工具链</strong> - Systrace、Perfetto、FrameMetrics、Choreographer的使用方法</li>
<li><strong>主线程优化</strong> - 异步化、布局优化、预加载等策略</li>
<li><strong>渲染优化</strong> - 过度绘制分析、硬件加速、GPU性能优化</li>
<li><strong>实战案例</strong> - RecyclerView滑动优化的完整流程</li>
</ol>
<p>通过掌握这套方法论和工具链,能够系统化地分析和解决卡顿问题,提升应用流畅度。</p>
<h2 data-id="heading-4">1. 卡顿的本质:掉帧与VSYNC机制</h2>
<h3 data-id="heading-5">1.1 什么是卡顿?</h3>
<p><strong>卡顿,本质上就是掉帧。</strong></p>
<p>我们先来理解几个核心概念:</p>
<p><strong>60fps标准</strong>: 人眼感知流畅的阈值是60帧每秒(60 frames per second),也就是说,屏幕需要每秒刷新60次画面。换算成时间,就是:</p>
<pre><code class="hljs">1秒 ÷ 60帧 = 16.67毫秒/帧
</code></pre>
<p><strong>这就是那个著名的"16.6ms"黄金时间。</strong></p>
<p>如果你的App能在每16.6ms内完成一帧画面的绘制,用户就会感觉流畅。一旦超过这个时间,就会发生<strong>掉帧(Dropped Frames)</strong>。</p>
<p><strong>掉帧的感知阈值</strong>:</p>
<ul>
<li>掉1帧: 32ms,轻微顿挫,多数用户感知不明显</li>
<li>掉2帧: 48ms,明显顿挫,敏感用户能察觉</li>
<li>掉3帧及以上: 64ms+,<strong>严重卡顿</strong>,所有用户都能明显感知</li>
</ul>
<h3 data-id="heading-6">1.2 Android渲染管线:从VSYNC到显示</h3>
<p>要理解卡顿,必须先理解Android的渲染管线(Rendering Pipeline)。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/954c3cd47c834f3c9996e2ab7e64c693~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657337&amp;x-signature=qtxxOIPU73nEsw6dg7akUxn6GeQ%3D" alt="10-01-android-rendering-pipeline.png" loading="lazy"/></p>
<p><strong>关键时间分配</strong>:</p>
<ul>
<li><strong>主线程</strong> (UI Thread): 8-10ms - measure/layout/draw</li>
<li><strong>RenderThread</strong>: 4-6ms - GPU指令提交和渲染</li>
<li><strong>SurfaceFlinger</strong>: 1-2ms - 多窗口合成</li>
<li><strong>预留Buffer</strong>: 2-3ms - 应对波动</li>
</ul>
<p><strong>总计</strong>: ≤ 16.6ms</p>
<p><strong>一旦某个环节超时,就会掉帧。</strong></p>
<h3 data-id="heading-7">1.3 Triple Buffer三缓冲机制</h3>
<p>为了提高效率,Android使用了**三缓冲(Triple Buffer)**机制:</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Buffer A:</span> <span class="hljs-string">正在显示的画面</span> <span class="hljs-string">(Display显示)</span>
<span class="hljs-attr">Buffer B:</span> <span class="hljs-string">已绘制完成,等待显示</span> <span class="hljs-string">(GPU已渲染完)</span>
<span class="hljs-attr">Buffer C:</span> <span class="hljs-string">正在绘制的画面</span> <span class="hljs-string">(CPU/GPU工作中)</span>
</code></pre>
<p><strong>正常情况下的流水线</strong>:</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">VSYNC</span> <span class="hljs-selector-id">#1</span>: <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">A</span>显示, <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">B</span>准备, <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">C</span>绘制中
<span class="hljs-selector-tag">VSYNC</span> <span class="hljs-selector-id">#2</span>: <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">B</span>显示, <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">C</span>准备, <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">A</span>绘制中
<span class="hljs-selector-tag">VSYNC</span> <span class="hljs-selector-id">#3</span>: <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">C</span>显示, <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">A</span>准备, <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">B</span>绘制中
</code></pre>
<p><strong>掉帧情况</strong>:</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">VSYNC</span> <span class="hljs-selector-id">#1</span>: <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">A</span>显示, <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">C</span>还在绘制 (超时!)
<span class="hljs-selector-tag">VSYNC</span> <span class="hljs-selector-id">#2</span>: <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">A</span>继续显示 (掉帧!), <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">C</span>完成
<span class="hljs-selector-tag">VSYNC</span> <span class="hljs-selector-id">#3</span>: <span class="hljs-selector-tag">Buffer</span> <span class="hljs-selector-tag">C</span>显示 (延迟一帧)
</code></pre>
<p><strong>这就是为什么卡顿会让画面"停滞"的原因——Buffer没准备好,只能继续显示旧画面。</strong></p>
<h3 data-id="heading-8">1.4 掉帧的三大根源</h3>
<p>通过对渲染管线的分析,我们可以总结出掉帧的三大根源:</p>
<h4 data-id="heading-9">根源1: 主线程耗时操作</h4>
<p><strong>典型场景</strong>:</p>
<ul>
<li>复杂的布局层级导致<code>measure/layout</code>耗时</li>
<li><code>onDraw()</code>中执行复杂计算或IO操作</li>
<li>主线程等待锁、同步网络请求</li>
<li>RecyclerView的<code>onBindViewHolder</code>中耗时操作</li>
</ul>
<p><strong>Systrace特征</strong>:</p>
<pre><code class="hljs language-diff" lang="diff">UI Thread: [<span class="hljs-comment">======================================] 25ms ← 超过16.6ms</span>
  └─ RecyclerView.onBindViewHolder
      └─ 同步解码图片 (罪魁祸首)
</code></pre>
<h4 data-id="heading-10">根源2: 渲染线程/GPU耗时</h4>
<p><strong>典型场景</strong>:</p>
<ul>
<li>过度绘制 (Overdraw),多层背景叠加</li>
<li>复杂的自定义View绘制 (<code>onDraw</code>中大量<code>Canvas</code>操作)</li>
<li>Shader编译和纹理上传</li>
<li>GPU频率降低 (温控降频)</li>
</ul>
<p><strong>Systrace特征</strong>:</p>
<pre><code class="hljs language-diff" lang="diff">RenderThread: [<span class="hljs-comment">======================================] 20ms</span>
  └─ GPU渲染复杂Path
</code></pre>
<h4 data-id="heading-11">根源3: 系统资源不足</h4>
<p><strong>典型场景</strong>:</p>
<ul>
<li>GC暂停 (Full GC可能暂停100ms+)</li>
<li>内存抖动频繁触发GC</li>
<li>CPU频率降低</li>
<li>Binder通信延迟 (系统服务繁忙)</li>
</ul>
<p><strong>Systrace特征</strong>:</p>
<pre><code class="hljs language-ini" lang="ini">UI Thread: <span class="hljs-section">[    ]</span><span class="hljs-section">[GC暂停 50ms]</span><span class="hljs-section">[     ]</span>  ← 多帧空白
</code></pre>
<h2 data-id="heading-12">2. 卡顿问题分析工具</h2>
<h3 data-id="heading-13">2.1 Systrace/Perfetto - 最强大的分析工具</h3>
<p><strong>Systrace是卡顿分析的核心工具</strong>,它能精确记录每一帧的耗时和调用栈。</p>
<p><strong>抓取命令</strong>:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 抓取10秒的Trace,包含渲染相关的所有信息</span>
python systrace.py -o trace.html <span class="hljs-built_in">sched</span> freq idle am wm gfx view binder_driver -t 10

<span class="hljs-comment"># 或使用Perfetto (更强大)</span>
adb shell perfetto \
  -c - --txt \
  -o /data/misc/perfetto-traces/trace \
  &lt; perfetto-config.pbtxt
</code></pre>
<p><strong>关键分析面板</strong>:</p>
<ol>
<li><strong>Frame Timeline</strong>: 查看掉帧情况</li>
</ol>

<pre><code class="hljs language-diff" lang="diff">每个小竖条代表一帧:
<span class="hljs-deletion">- 绿色: 正常 (≤16.6ms)</span>
<span class="hljs-deletion">- 黄色: 轻微掉帧 (16.6-33ms)</span>
<span class="hljs-deletion">- 橙色: 中度掉帧 (33-50ms)</span>
<span class="hljs-deletion">- 红色: 严重掉帧 (&gt;50ms)</span>
</code></pre>
<p>2.  <strong>UI Thread</strong>: 主线程耗时分析</p>

<pre><code class="hljs language-diff" lang="diff">选中一个红色帧,查看UI Thread面板:
<span class="hljs-deletion">- 找出耗时&gt;10ms的操作</span>
<span class="hljs-deletion">- 查看Wall Duration (总耗时) 和 Self Time (自身耗时)</span>
<span class="hljs-deletion">- 定位到具体函数</span>
</code></pre>
<p>3.  <strong>RenderThread</strong>: 渲染线程分析</p>

<pre><code class="hljs language-diff" lang="diff">查看GPU相关的耗时:
<span class="hljs-deletion">- DrawFrame: 提交GPU命令</span>
<span class="hljs-deletion">- eglSwapBuffers: 等待GPU完成</span>
</code></pre>
<p><strong>Systrace实战技巧</strong>:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 技巧1: 只抓取关键时刻</span>
<span class="hljs-comment"># 在代码中插入Trace标记</span>
Trace.beginSection(<span class="hljs-string">"MyExpensiveOperation"</span>)
// 耗时操作
Trace.endSection()

<span class="hljs-comment"># Systrace中就会显示这个标记,方便定位</span>
</code></pre>
<h3 data-id="heading-14">2.2 FrameMetrics API - 实时监控</h3>
<p><strong>FrameMetrics</strong>是Android 7.0引入的API,可以实时监控每一帧的耗时。</p>
<p><strong>完整代码示例</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> frameMetricsListener = Window.OnFrameMetricsAvailableListener {
        _, frameMetrics, dropCountSinceLastInvocation -&gt;

        <span class="hljs-comment">// 获取各阶段耗时 (单位:纳秒)</span>
        <span class="hljs-keyword">val</span> totalDuration = frameMetrics.getMetric(FrameMetrics.TOTAL_DURATION)
        <span class="hljs-keyword">val</span> inputDuration = frameMetrics.getMetric(FrameMetrics.INPUT_HANDLING_DURATION)
        <span class="hljs-keyword">val</span> animationDuration = frameMetrics.getMetric(FrameMetrics.ANIMATION_DURATION)
        <span class="hljs-keyword">val</span> layoutDuration = frameMetrics.getMetric(FrameMetrics.LAYOUT_MEASURE_DURATION)
        <span class="hljs-keyword">val</span> drawDuration = frameMetrics.getMetric(FrameMetrics.DRAW_DURATION)
        <span class="hljs-keyword">val</span> syncDuration = frameMetrics.getMetric(FrameMetrics.SYNC_DURATION)
        <span class="hljs-keyword">val</span> commandDuration = frameMetrics.getMetric(FrameMetrics.COMMAND_ISSUE_DURATION)
        <span class="hljs-keyword">val</span> swapDuration = frameMetrics.getMetric(FrameMetrics.SWAP_BUFFERS_DURATION)

        <span class="hljs-comment">// 转换为毫秒</span>
        <span class="hljs-keyword">val</span> totalMs = totalDuration / <span class="hljs-number">1_000_000.0</span>

        <span class="hljs-comment">// 判断是否掉帧 (超过16.6ms)</span>
        <span class="hljs-keyword">if</span> (totalMs &gt; <span class="hljs-number">16.6</span>) {
            Log.w(<span class="hljs-string">"FrameMetrics"</span>, <span class="hljs-string">"""
                ⚠️ Dropped Frame: <span class="hljs-subst">${totalMs}</span>ms (掉了 <span class="hljs-subst">${dropCountSinceLastInvocation}</span> 帧)
                  - Input: <span class="hljs-subst">${inputDuration / <span class="hljs-number">1</span>_000_000<span class="hljs-number">.0</span>}</span>ms
                  - Animation: <span class="hljs-subst">${animationDuration / <span class="hljs-number">1</span>_000_000<span class="hljs-number">.0</span>}</span>ms
                  - Layout/Measure: <span class="hljs-subst">${layoutDuration / <span class="hljs-number">1</span>_000_000<span class="hljs-number">.0</span>}</span>ms
                  - Draw: <span class="hljs-subst">${drawDuration / <span class="hljs-number">1</span>_000_000<span class="hljs-number">.0</span>}</span>ms
                  - Sync: <span class="hljs-subst">${syncDuration / <span class="hljs-number">1</span>_000_000<span class="hljs-number">.0</span>}</span>ms
                  - GPU Command: <span class="hljs-subst">${commandDuration / <span class="hljs-number">1</span>_000_000<span class="hljs-number">.0</span>}</span>ms
                  - SwapBuffers: <span class="hljs-subst">${swapDuration / <span class="hljs-number">1</span>_000_000<span class="hljs-number">.0</span>}</span>ms
            """</span>.trimIndent())

            <span class="hljs-comment">// 可以上报到监控平台</span>
            reportJankToServer(totalMs, dropCountSinceLastInvocation)
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        <span class="hljs-comment">// 注册监听器</span>
        window.addOnFrameMetricsAvailableListener(
            frameMetricsListener,
            Handler(Looper.getMainLooper())
        )
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onDestroy()
        <span class="hljs-comment">// 移除监听器</span>
        window.removeOnFrameMetricsAvailableListener(frameMetricsListener)
    }
}
</code></pre>
<p><strong>FrameMetrics的优势</strong>:</p>
<ul>
<li>✅ 实时监控,不需要手动抓Trace</li>
<li>✅ 可以在线上环境使用,收集用户数据</li>
<li>✅ 可以精确到每个阶段的耗时</li>
<li>⚠️ 缺点:无法看到调用栈,只能看耗时</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2526b42f748c4bcda111bd606bcb5951~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657337&amp;x-signature=9Wia644aRS88EG0F8jqGaeoA0BA%3D" alt="10-02-jank-analysis-tools.png" loading="lazy"/></p>
<h3 data-id="heading-15">2.3 Choreographer - 自定义监控方案</h3>
<p><strong>Choreographer</strong>是Android的"编舞者",负责调度VSYNC信号和UI更新。我们可以利用它实现更灵活的监控。</p>
<p><strong>核心代码</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChoreographerJankMonitor</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastFrameTimeNanos: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> jankThresholdMs = <span class="hljs-number">16.6</span>  <span class="hljs-comment">// 掉帧阈值</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> frameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            <span class="hljs-keyword">if</span> (lastFrameTimeNanos &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 计算两帧之间的时间差</span>
                <span class="hljs-keyword">val</span> frameIntervalMs = (frameTimeNanos - lastFrameTimeNanos) / <span class="hljs-number">1_000_000.0</span>

                <span class="hljs-keyword">if</span> (frameIntervalMs &gt; jankThresholdMs) {
                    <span class="hljs-comment">// 掉帧了!</span>
                    <span class="hljs-keyword">val</span> droppedFrames = (frameIntervalMs / <span class="hljs-number">16.6</span>).toInt()
                    onJankDetected(frameIntervalMs, droppedFrames)
                }
            }

            lastFrameTimeNanos = frameTimeNanos

            <span class="hljs-comment">// 继续监听下一帧</span>
            Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        Choreographer.getInstance().postFrameCallback(frameCallback)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> {
        Choreographer.getInstance().removeFrameCallback(frameCallback)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onJankDetected</span><span class="hljs-params">(intervalMs: <span class="hljs-type">Double</span>, droppedFrames: <span class="hljs-type">Int</span>)</span></span> {
        Log.w(<span class="hljs-string">"JankMonitor"</span>, <span class="hljs-string">"⚠️ Jank detected: <span class="hljs-subst">${intervalMs}</span>ms (dropped <span class="hljs-variable">$droppedFrames</span> frames)"</span>)

        <span class="hljs-comment">// 采集堆栈信息</span>
        <span class="hljs-keyword">val</span> stackTrace = Thread.currentThread().stackTrace

        <span class="hljs-comment">// 上报监控</span>
        reportJank(intervalMs, droppedFrames, stackTrace)
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> jankMonitor = ChoreographerJankMonitor()

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCreate()
        jankMonitor.start()
    }
}
</code></pre>
<p><strong>Choreographer方案的特点</strong>:</p>
<ul>
<li>✅ 轻量级,性能开销小</li>
<li>✅ 可以自定义阈值和监控策略</li>
<li>✅ 可以采集堆栈信息</li>
<li>⚠️ 只能监控掉帧,无法分析具体原因</li>
</ul>
<h3 data-id="heading-16">2.4 工具选择指南</h3>





















































<table><thead><tr><th align="left">工具</th><th align="center">实时性</th><th align="center">准确性</th><th align="center">详细程度</th><th align="center">性能开销</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>Systrace</strong></td><td align="center">❌ 离线</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">最详细</td><td align="center">大</td><td align="left">开发阶段深度分析</td></tr><tr><td align="left"><strong>Perfetto</strong></td><td align="center">❌ 离线</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">最详细</td><td align="center">大</td><td align="left">开发阶段深度分析</td></tr><tr><td align="left"><strong>FrameMetrics</strong></td><td align="center">✅ 实时</td><td align="center">⭐⭐⭐⭐</td><td align="center">分阶段</td><td align="center">小</td><td align="left">线上实时监控</td></tr><tr><td align="left"><strong>Choreographer</strong></td><td align="center">✅ 实时</td><td align="center">⭐⭐⭐</td><td align="center">仅掉帧</td><td align="center">极小</td><td align="left">线上轻量监控</td></tr><tr><td align="left"><strong>Profiler</strong></td><td align="center">❌ 离线</td><td align="center">⭐⭐⭐⭐</td><td align="center">详细</td><td align="center">中</td><td align="left">开发阶段分析</td></tr></tbody></table>
<p><strong>推荐组合方案</strong>:</p>
<ul>
<li><strong>开发阶段</strong>: Systrace/Perfetto深度分析 + Profiler辅助</li>
<li><strong>线上监控</strong>: FrameMetrics + Choreographer双重监控</li>
<li><strong>问题定位</strong>: 先用FrameMetrics发现问题,再用Systrace深度分析</li>
</ul>
<h2 data-id="heading-17">3. 主线程卡顿分析与优化</h2>
<p>主线程卡顿是最常见的卡顿类型,占比超过80%。</p>
<h3 data-id="heading-18">3.1 主线程耗时操作识别</h3>
<p><strong>Systrace分析步骤</strong>:</p>
<ol>
<li><strong>打开Systrace文件</strong>,定位到Frame Timeline</li>
<li><strong>找到红色/橙色的帧</strong>,查看耗时</li>
<li><strong>选中该帧</strong>,查看UI Thread面板</li>
<li><strong>展开调用栈</strong>,找出耗时&gt;10ms的操作</li>
<li><strong>查看Self Time</strong>,定位到具体函数</li>
</ol>
<p><strong>示例</strong>:</p>
<pre><code class="hljs language-ini" lang="ini">Frame <span class="hljs-comment">#245: 35ms (Dropped 2 frames)</span>
└─ UI Thread <span class="hljs-section">[====================================]</span> 32ms
    └─ RecyclerView.onBindViewHolder <span class="hljs-section">[==========================]</span> 28ms
        ├─ BitmapFactory.decodeFile <span class="hljs-section">[===================]</span> 18ms  ← 罪魁祸首!
        ├─ TextView.setText <span class="hljs-section">[====]</span> 5ms
        └─ 其他操作 <span class="hljs-section">[===]</span> 5ms
</code></pre>
<p><strong>Self Time vs Wall Duration</strong>:</p>
<ul>
<li><strong>Wall Duration</strong>: 总耗时 (包含子函数)</li>
<li><strong>Self Time</strong>: 自身耗时 (不包含子函数)</li>
</ul>
<p>优化时,优先看<strong>Self Time高</strong>的函数,这是真正的瓶颈。</p>
<h3 data-id="heading-19">3.2 常见主线程卡顿场景及优化</h3>
<h4 data-id="heading-20">场景1: 过度的measure/layout</h4>
<p><strong>问题代码</strong>:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ❌ Bad: 嵌套5层LinearLayout,每次measure都要遍历所有子View --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"0dp"</span>
            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"1"</span>
            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
                <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
                    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"0dp"</span>
                    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
                    <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"1"</span>&gt;</span>

                    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
                        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
                        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
                        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"深度嵌套的TextView"</span> /&gt;</span>

                <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<p><strong>Systrace显示</strong>:</p>
<pre><code class="hljs language-bash" lang="bash">measure/layout: 12ms  ← 过高!
</code></pre>
<p><strong>优化方案</strong>:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ✅ Good: 使用ConstraintLayout,单层布局 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/textView"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"单层布局的TextView"</span>
        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">"parent"</span>
        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">"parent"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span>
</code></pre>
<p><strong>优化效果</strong>:</p>
<pre><code class="hljs language-bash" lang="bash">measure/layout: 3ms  ← 优化75%!
</code></pre>
<p><strong>优化原则</strong>:</p>
<ul>
<li>使用<code>ConstraintLayout</code>替代嵌套的<code>LinearLayout</code>/<code>RelativeLayout</code></li>
<li>避免使用<code>layout_weight</code>,会导致两次measure</li>
<li>使用<code>ViewStub</code>延迟加载不可见的View</li>
<li>使用<code>&amp;lt;merge&amp;gt;</code>标签减少层级</li>
</ul>
<h4 data-id="heading-21">场景2: 主线程IO操作</h4>
<p><strong>问题代码</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ Bad: 主线程读取文件</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        <span class="hljs-comment">// 同步读取配置文件 (可能耗时100ms+)</span>
        <span class="hljs-keyword">val</span> config = File(filesDir, <span class="hljs-string">"config.json"</span>).readText()
        parseConfig(config)

        <span class="hljs-comment">// 同步查询数据库 (可能耗时50ms+)</span>
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = database.queryAll()
        displayData(<span class="hljs-keyword">data</span>)
    }
}
</code></pre>
<p><strong>Systrace显示</strong>:</p>
<pre><code class="hljs language-ini" lang="ini">UI Thread: <span class="hljs-section">[==IO Read 120ms==]</span><span class="hljs-section">[DB Query 60ms==]</span> ← 主线程阻塞180ms!
</code></pre>
<p><strong>优化方案</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ Good: 异步加载</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        <span class="hljs-comment">// 先显示占位UI</span>
        showLoadingUI()

        <span class="hljs-comment">// 异步加载数据</span>
        lifecycleScope.launch {
            <span class="hljs-comment">// IO线程读取配置</span>
            <span class="hljs-keyword">val</span> config = withContext(Dispatchers.IO) {
                File(filesDir, <span class="hljs-string">"config.json"</span>).readText()
            }

            <span class="hljs-comment">// 解析配置 (可能是CPU密集型,用Default线程池)</span>
            <span class="hljs-keyword">val</span> parsedConfig = withContext(Dispatchers.Default) {
                parseConfig(config)
            }

            <span class="hljs-comment">// IO线程查询数据库</span>
            <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) {
                database.queryAll()
            }

            <span class="hljs-comment">// 回到主线程更新UI</span>
            withContext(Dispatchers.Main) {
                hideLoadingUI()
                displayData(<span class="hljs-keyword">data</span>)
            }
        }
    }
}
</code></pre>
<p><strong>优化效果</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">onCreate: 5ms  ← 优化97%!</span>
<span class="hljs-section">数据加载: 后台线程,不阻塞UI</span>
</code></pre>
<h4 data-id="heading-22">场景3: RecyclerView滑动卡顿</h4>
<p>这是最常见的卡顿场景,我们在第7节会详细展开。这里先列出核心优化点:</p>
<p><strong>问题代码</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ Bad: onBindViewHolder中耗时操作</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">MyViewHolder</span>&gt;() {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">MyViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> item = dataList[position]

        <span class="hljs-comment">// 问题1: 同步解码图片 (15-30ms)</span>
        <span class="hljs-keyword">val</span> bitmap = BitmapFactory.decodeFile(item.imagePath)
        holder.imageView.setImageBitmap(bitmap)

        <span class="hljs-comment">// 问题2: 复杂的字符串拼接</span>
        holder.titleView.text = buildString {
            append(item.title)
            append(<span class="hljs-string">" - "</span>)
            append(SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>).format(item.date))
            append(<span class="hljs-string">" - "</span>)
            append(item.category)
        }

        <span class="hljs-comment">// 问题3: 动态设置View属性导致重新layout</span>
        <span class="hljs-keyword">val</span> params = holder.imageView.layoutParams
        params.height = item.height
        holder.imageView.layoutParams = params  <span class="hljs-comment">// 触发requestLayout</span>
    }
}
</code></pre>
<p><strong>Systrace显示</strong>:</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">onBindViewHolder:</span> <span class="hljs-string">45ms</span>  <span class="hljs-string">←</span> <span class="hljs-string">远超16.6ms!</span>
  <span class="hljs-string">├─</span> <span class="hljs-attr">BitmapFactory.decodeFile:</span> <span class="hljs-string">28ms</span>
  <span class="hljs-string">├─</span> <span class="hljs-string">String拼接:</span> <span class="hljs-string">10ms</span>
  <span class="hljs-string">└─</span> <span class="hljs-attr">requestLayout:</span> <span class="hljs-string">7ms</span>
</code></pre>
<p><strong>优化方案</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ Good: 优化后的Adapter</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">MyViewHolder</span>&gt;() {

    <span class="hljs-comment">// 优化1: 预处理数据</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> formattedDataList = dataList.map { item -&gt;
        FormattedItem(
            imagePath = item.imagePath,
            displayTitle = <span class="hljs-string">"<span class="hljs-subst">${item.title}</span> - <span class="hljs-subst">${dateFormat.format(item.date)}</span> - <span class="hljs-subst">${item.category}</span>"</span>,
            imageHeight = item.height
        )
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">MyViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> item = formattedDataList[position]

        <span class="hljs-comment">// 优化2: 使用Glide异步加载图片</span>
        Glide.with(holder.itemView.context)
            .load(item.imagePath)
            .<span class="hljs-keyword">override</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>)  <span class="hljs-comment">// 缩放到目标尺寸</span>
            .centerCrop()
            .placeholder(R.drawable.placeholder)  <span class="hljs-comment">// 占位图</span>
            .into(holder.imageView)

        <span class="hljs-comment">// 优化3: 直接使用预处理的字符串</span>
        holder.titleView.text = item.displayTitle

        <span class="hljs-comment">// 优化4: 在XML中使用固定高度,避免动态设置</span>
        <span class="hljs-comment">// 或者使用自定义LayoutManager处理</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>)</span></span>: MyViewHolder {
        <span class="hljs-comment">// 优化5: 使用ViewBinding减少findViewById</span>
        <span class="hljs-keyword">val</span> binding = ItemLayoutBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            <span class="hljs-literal">false</span>
        )
        <span class="hljs-keyword">return</span> MyViewHolder(binding)
    }
}

<span class="hljs-comment">// 优化6: 增加ViewHolder缓存</span>
recyclerView.setItemViewCacheSize(<span class="hljs-number">20</span>)  <span class="hljs-comment">// 默认2,增加到20</span>
recyclerView.setHasFixedSize(<span class="hljs-literal">true</span>)     <span class="hljs-comment">// 固定尺寸,避免多次measure</span>
</code></pre>
<p><strong>优化效果</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">onBindViewHolder: 3ms  ← 优化93%!</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad336c7b5a5e4112900aecdc1a3c49d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657337&amp;x-signature=sVV%2FffXRM83oxZjdCA5ahQkiPR4%3D" alt="10-03-main-thread-optimization-decision-tree.png" loading="lazy"/></p>
<h3 data-id="heading-23">3.3 主线程优化策略总结</h3>









































<table><thead><tr><th align="left">问题类型</th><th align="left">识别特征</th><th align="left">优化策略</th><th align="center">效果</th></tr></thead><tbody><tr><td align="left"><strong>复杂布局</strong></td><td align="left">measure/layout &gt;10ms</td><td align="left">ConstraintLayout, ViewStub, &lt;merge&gt;</td><td align="center">↓60-80%</td></tr><tr><td align="left"><strong>IO操作</strong></td><td align="left">文件读写, 数据库查询</td><td align="left">异步加载 (Coroutines/RxJava)</td><td align="center">↓90%+</td></tr><tr><td align="left"><strong>图片解码</strong></td><td align="left">BitmapFactory &gt;10ms</td><td align="left">Glide/Coil异步加载+缓存</td><td align="center">↓90%+</td></tr><tr><td align="left"><strong>字符串操作</strong></td><td align="left">String拼接 &gt;5ms</td><td align="left">预处理, StringBuilder</td><td align="center">↓70%</td></tr><tr><td align="left"><strong>动态设置属性</strong></td><td align="left">requestLayout频繁触发</td><td align="left">XML固定尺寸, 批量更新</td><td align="center">↓50-70%</td></tr></tbody></table>
<p><strong>核心原则</strong>:</p>
<ol>
<li><strong>异步化</strong>: 一切耗时操作都不应该在主线程</li>
<li><strong>预加载</strong>: 提前准备数据,减少等待时间</li>
<li><strong>布局优化</strong>: 减少层级,使用高效的LayoutManager</li>
<li><strong>缓存</strong>: 图片、数据、View都应该缓存</li>
<li><strong>延迟加载</strong>: ViewStub、懒加载非首屏内容</li>
</ol>
<h2 data-id="heading-24">4. 渲染线程与GPU卡顿分析</h2>
<p>当主线程优化到位后,如果仍然卡顿,问题可能出在渲染线程或GPU。</p>
<h3 data-id="heading-25">4.1 RenderThread工作原理</h3>
<p>从Android 5.0开始,Android引入了<strong>RenderThread</strong>(渲染线程),将渲染工作从主线程分离出来。</p>
<p><strong>渲染流程</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown">主线程 (UI Thread):
  └─ View.draw()
<span class="hljs-code">      └─ 录制DisplayList (记录绘制指令,不实际绘制)
          └─ 通知RenderThread
</span>
RenderThread (渲染线程):
  └─ 同步DisplayList
<span class="hljs-code">      └─ 将绘制指令转换为GPU命令
          └─ 提交到GPU
              └─ 等待GPU完成
                  └─ eglSwapBuffers (交换缓冲区)
</span></code></pre>
<p><strong>这样做的好处</strong>:</p>
<ul>
<li>✅ 主线程不用等待GPU渲染完成</li>
<li>✅ 主线程可以继续处理下一帧</li>
<li>✅ 渲染和UI更新并行</li>
</ul>
<p><strong>但也带来新问题</strong>:</p>
<ul>
<li>⚠️ RenderThread如果耗时过长,也会掉帧</li>
<li>⚠️ GPU渲染复杂内容可能成为瓶颈</li>
</ul>
<h3 data-id="heading-26">4.2 过度绘制(Overdraw)分析</h3>
<p><strong>过度绘制</strong>是指同一个像素被绘制了多次。比如:</p>
<pre><code class="hljs language-scss" lang="scss">背景<span class="hljs-number">1</span> (Activity背景) - 第<span class="hljs-number">1</span>次绘制
  └─ 背景<span class="hljs-number">2</span> (Layout背景) - 第<span class="hljs-number">2</span>次绘制
      └─ 背景<span class="hljs-number">3</span> (View背景) - 第<span class="hljs-number">3</span>次绘制
          └─ 前景 (View内容) - 第<span class="hljs-number">4</span>次绘制
</code></pre>
<p><strong>最终用户只能看到最上层的内容,下面3层完全是浪费!</strong></p>
<p><strong>开启过度绘制可视化</strong>:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 方法1: 通过adb命令</span>
adb shell setprop debug.hwui.overdraw show

<span class="hljs-comment"># 方法2: 设置 - 开发者选项 - 调试GPU过度绘制 - 显示过度绘制区域</span>
</code></pre>
<p><strong>颜色含义</strong>:</p>
<ul>
<li><strong>无色/白色</strong>: 无过度绘制 (最理想)</li>
<li><strong>蓝色</strong>: 1x过度绘制 (可接受)</li>
<li><strong>绿色</strong>: 2x过度绘制 (尚可)</li>
<li><strong>粉色</strong>: 3x过度绘制 (需要优化)</li>
<li><strong>红色</strong>: 4x+过度绘制 (严重问题!)</li>
</ul>
<p><strong>优化目标</strong>: 屏幕上大部分区域应该是无色或蓝色,绿色区域应该控制在10%以内,避免出现粉色和红色。</p>
<p><strong>实战案例:优化过度绘制</strong></p>
<p><strong>问题布局</strong>:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ❌ Bad: 3层背景叠加 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@color/white"</span>&gt;</span>  ← 背景1

    <span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@color/white"</span>&gt;</span>  ← 背景2 (重复!)

        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@drawable/bg_rounded"</span>  ← <span class="hljs-attr">背景3</span>
            <span class="hljs-attr">android:text</span>=<span class="hljs-string">"过度绘制的文本"</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<p><strong>过度绘制可视化</strong>: 文本区域显示红色! (4x过度绘制)</p>
<p><strong>优化后</strong>:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ✅ Good: 移除不必要的背景 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>&gt;</span>  ← 移除背景

    <span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>&gt;</span>  ← 移除背景

        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@drawable/bg_rounded"</span>  ← <span class="hljs-attr">只保留最上层背景</span>
            <span class="hljs-attr">android:text</span>=<span class="hljs-string">"优化后的文本"</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<p><strong>过度绘制可视化</strong>: 文本区域显示蓝色 (1x过度绘制) - 优化75%!</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7f5eac53ca54774bcedb04fc32250db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657337&amp;x-signature=GAMAb0SWbA%2BpQxVtkU0ordCDJSU%3D" alt="10-04-overdraw-optimization-comparison.png" loading="lazy"/></p>
<h3 data-id="heading-27">4.3 GPU渲染性能瓶颈</h3>
<p><strong>常见GPU瓶颈</strong>:</p>
<ol>
<li><strong>Shader编译耗时</strong></li>
</ol>

<pre><code class="hljs language-sql" lang="sql">第一次绘制自定义<span class="hljs-keyword">View</span>时,GPU需要编译Shader程序
首次耗时可能达到<span class="hljs-number">50</span><span class="hljs-number">-100</span>ms
</code></pre>
<p>2.  <strong>纹理上传带宽</strong></p>

<pre><code class="hljs">大量图片需要从内存上传到GPU显存
带宽有限,可能成为瓶颈
</code></pre>
<p>3.  <strong>复杂图形绘制</strong></p>

<pre><code class="hljs">大量的Path、Bezier曲线、阴影效果
GPU计算量大
</code></pre>
<p><strong>GPU性能分析工具</strong>:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 开启GPU渲染柱状图</span>
adb shell setprop debug.hwui.profile visual_bars

<span class="hljs-comment"># 或在设置 - 开发者选项 - GPU渲染模式分析 - 在屏幕上显示为条形图</span>
</code></pre>
<p><strong>柱状图解读</strong>:</p>
<pre><code class="hljs language-diff" lang="diff">每条柱状图代表一帧,由多个颜色段组成:
<span class="hljs-deletion">- 蓝色: Input处理</span>
<span class="hljs-deletion">- 紫色: Animation动画</span>
<span class="hljs-deletion">- 红色: measure/layout</span>
<span class="hljs-deletion">- 橙色: draw (DisplayList录制)</span>
<span class="hljs-deletion">- 黄色: RenderThread处理</span>
<span class="hljs-deletion">- 青色: GPU渲染</span>
<span class="hljs-deletion">- 绿色: Swap buffers</span>

总高度超过绿线 (16ms) = 掉帧
</code></pre>
<h3 data-id="heading-28">4.4 硬件加速优化</h3>
<p><strong>硬件加速图层</strong>(Hardware Layer)可以缓存View的绘制结果,避免重复绘制。</p>
<p><strong>适用场景</strong>:</p>
<ul>
<li>复杂的自定义View (绘制一次,缓存到GPU纹理)</li>
<li>动画过程中的View (位移、缩放、旋转等不需要重绘内容)</li>
</ul>
<p><strong>使用方法</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 对复杂View启用硬件加速图层</span>
customView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="hljs-literal">null</span>)

<span class="hljs-comment">// 动画开始时启用</span>
animator.addListener(<span class="hljs-keyword">object</span> : AnimatorListenerAdapter() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(animation: <span class="hljs-type">Animator</span>)</span></span> {
        customView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="hljs-literal">null</span>)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(animation: <span class="hljs-type">Animator</span>)</span></span> {
        <span class="hljs-comment">// 动画结束后移除图层,释放显存</span>
        customView.setLayerType(View.LAYER_TYPE_NONE, <span class="hljs-literal">null</span>)
    }
})
</code></pre>
<p><strong>注意事项</strong>:</p>
<ul>
<li>⚠️ 硬件图层会占用显存,不要滥用</li>
<li>⚠️ 如果View内容频繁变化,硬件图层反而会降低性能 (需要频繁更新纹理)</li>
<li>✅ 适合静态内容或动画过程中的View</li>
</ul>
<h2 data-id="heading-29">5. 系统级卡顿因素</h2>
<p>除了应用层的问题,系统级因素也会导致卡顿。</p>
<h3 data-id="heading-30">5.1 GC暂停</h3>
<p><strong>GC类型与暂停时间</strong>:</p>





























<table><thead><tr><th align="left">GC类型</th><th align="left">触发原因</th><th align="right">暂停时间</th><th align="left">影响</th></tr></thead><tbody><tr><td align="left"><strong>Young GC</strong></td><td align="left">Eden区满</td><td align="right">5-10ms</td><td align="left">轻微卡顿</td></tr><tr><td align="left"><strong>Full GC</strong></td><td align="left">老年代满</td><td align="right">50-200ms</td><td align="left">严重卡顿</td></tr><tr><td align="left"><strong>Concurrent GC</strong></td><td align="left">后台回收</td><td align="right">小于1ms</td><td align="left">几乎无影响</td></tr></tbody></table>
<p><strong>Systrace中的GC标记</strong>:</p>
<pre><code class="hljs language-ini" lang="ini">UI Thread: <span class="hljs-section">[    ]</span><span class="hljs-section">[GC暂停 80ms]</span><span class="hljs-section">[     ]</span>  ← Full GC导致多帧空白
</code></pre>
<p><strong>优化策略</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 避免在循环中创建大量临时对象</span>
<span class="hljs-comment">// ❌ Bad</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until <span class="hljs-number">1000</span>) {
    <span class="hljs-keyword">val</span> temp = SomeObject()  <span class="hljs-comment">// 创建1000个临时对象</span>
    doSomething(temp)
}

<span class="hljs-comment">// ✅ Good</span>
<span class="hljs-keyword">val</span> reusableObject = SomeObject()
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until <span class="hljs-number">1000</span>) {
    reusableObject.reset()  <span class="hljs-comment">// 重用对象</span>
    doSomething(reusableObject)
}

<span class="hljs-comment">// 2. 使用对象池</span>
<span class="hljs-keyword">val</span> bitmapPool = Glide.<span class="hljs-keyword">get</span>(context).bitmapPool
<span class="hljs-keyword">val</span> bitmap = bitmapPool.<span class="hljs-keyword">get</span>(width, height, Bitmap.Config.ARGB_8888)
<span class="hljs-comment">// 使用完后回收</span>
bitmapPool.put(bitmap)

<span class="hljs-comment">// 3. 及时释放不用的大对象</span>
bitmap.recycle()
</code></pre>
<h3 data-id="heading-31">5.2 Binder通信延迟</h3>
<p><strong>跨进程调用的性能开销</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">正常Binder调用: 0.5-2ms</span>
<span class="hljs-section">系统繁忙时: 5-20ms</span>
<span class="hljs-section">Binder线程池饱和: 50-100ms+</span>
</code></pre>
<p><strong>优化策略</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 减少IPC调用次数</span>
<span class="hljs-comment">// ❌ Bad: 循环调用远程服务</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until <span class="hljs-number">100</span>) {
    remoteService.getData(i)  <span class="hljs-comment">// 100次IPC</span>
}

<span class="hljs-comment">// ✅ Good: 批量获取</span>
<span class="hljs-keyword">val</span> dataList = remoteService.getBatchData(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment">// 1次IPC</span>

<span class="hljs-comment">// 2. 使用异步Binder (Android 11+)</span>
<span class="hljs-comment">// 不阻塞当前线程</span>
</code></pre>
<h3 data-id="heading-32">5.3 CPU/GPU频率调度</h3>
<p><strong>温控降频</strong>是常见的性能下降原因:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">正常: CPU 2.0GHz, GPU 600MHz</span>
<span class="hljs-section">发热后: CPU 1.2GHz (降低40%), GPU 400MHz (降低33%)</span>
<span class="hljs-section">性能下降: 30-50%</span>
</code></pre>
<p><strong>监控方法</strong>:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看CPU频率</span>
adb shell <span class="hljs-built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq

<span class="hljs-comment"># 查看GPU频率</span>
adb shell <span class="hljs-built_in">cat</span> /sys/class/kgsl/kgsl-3d0/gpuclk
</code></pre>
<p><strong>优化策略</strong>:</p>
<ul>
<li>减少不必要的计算,降低发热</li>
<li>使用电量优化API (PowerManager)</li>
<li>避免长时间高负载运行</li>
</ul>
<h2 data-id="heading-33">6. 实战案例:RecyclerView滑动优化全流程</h2>
<p>这是一个完整的真实案例,展示从问题发现到解决的全过程。</p>
<h3 data-id="heading-34">6.1 问题现象</h3>
<p><strong>用户反馈</strong>: "首页列表滑动非常卡,根本滑不动,严重影响体验!"</p>
<p><strong>测试验证</strong>:</p>
<ul>
<li>快速滑动列表,FPS从60骤降到25-30</li>
<li>明显的顿挫感,严重掉帧</li>
<li>滑动越快越卡</li>
</ul>
<h3 data-id="heading-35">6.2 问题定位</h3>
<p><strong>Step 1: 抓取Systrace</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 抓取10秒的滑动Trace</span>
python systrace.py -o scroll_trace.html <span class="hljs-built_in">sched</span> freq idle am wm gfx view -t 10
</code></pre>
<p><strong>Step 2: 分析Frame Timeline</strong></p>
<p>打开Trace文件,Frame Timeline上密密麻麻的红色和橙色标记:</p>
<pre><code class="hljs language-bash" lang="bash">Frame <span class="hljs-comment">#245: 35ms (Dropped 2 frames)</span>
Frame <span class="hljs-comment">#246: 42ms (Dropped 3 frames)</span>
Frame <span class="hljs-comment">#247: 38ms (Dropped 2 frames)</span>
Frame <span class="hljs-comment">#248: 45ms (Dropped 3 frames)</span>
...连续20帧都在掉帧!
</code></pre>
<p><strong>Step 3: 分析UI Thread</strong></p>
<p>选中Frame #245,查看UI Thread面板:</p>
<pre><code class="hljs language-ini" lang="ini">UI Thread: <span class="hljs-section">[======================================]</span> 32ms
  └─ RecyclerView.onBindViewHolder <span class="hljs-section">[==========================]</span> 28ms
      ├─ BitmapFactory.decodeFile <span class="hljs-section">[===================]</span> 18ms  ← 第一瓶颈!
      ├─ String.format <span class="hljs-section">[====]</span> 5ms
      ├─ SimpleDateFormat.format <span class="hljs-section">[===]</span> 3ms
      └─ 其他操作 <span class="hljs-section">[==]</span> 2ms
</code></pre>
<p><strong>问题明确了!</strong></p>
<ol>
<li><strong>图片同步解码</strong>: 每张图片18ms,一屏10个item就是180ms</li>
<li><strong>字符串格式化</strong>: 每次5ms,虽然不多但累积可观</li>
<li><strong>日期格式化</strong>: SimpleDateFormat非线程安全,每次创建新实例</li>
</ol>
<h3 data-id="heading-36">6.3 优化方案实施</h3>
<h4 data-id="heading-37">优化1: 图片异步加载</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Before: 同步解码图片</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">NewsViewHolder</span>&gt;() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">NewsViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> item = newsList[position]

        <span class="hljs-comment">// 🔴 主线程同步解码,耗时18ms</span>
        <span class="hljs-keyword">val</span> bitmap = BitmapFactory.decodeFile(item.imagePath)
        holder.imageView.setImageBitmap(bitmap)
    }
}

<span class="hljs-comment">// After: Glide异步加载</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">NewsViewHolder</span>&gt;() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">NewsViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> item = newsList[position]

        <span class="hljs-comment">// ✅ Glide异步加载+缓存+缩放</span>
        Glide.with(holder.itemView.context)
            .load(item.imagePath)
            .<span class="hljs-keyword">override</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>)  <span class="hljs-comment">// 缩放到目标尺寸,减少内存占用</span>
            .centerCrop()
            .placeholder(R.drawable.img_placeholder)  <span class="hljs-comment">// 占位图</span>
            .error(R.drawable.img_error)  <span class="hljs-comment">// 错误图</span>
            .into(holder.imageView)
    }
}
</code></pre>
<p><strong>优化效果</strong>: 图片解码从主线程移除,耗时从18ms降到0ms (异步加载)</p>
<h4 data-id="heading-38">优化2: 数据预处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Before: 每次bind都格式化字符串</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsAdapter</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> newsList: List&lt;NewsItem&gt;) : RecyclerView.Adapter&lt;NewsViewHolder&gt;() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dateFormat = SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm"</span>, Locale.getDefault())

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">NewsViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> item = newsList[position]

        <span class="hljs-comment">// 🔴 每次都重新格式化,耗时5ms</span>
        <span class="hljs-keyword">val</span> title = String.format(<span class="hljs-string">"%s - %s"</span>, item.title, item.category)
        holder.titleView.text = title

        <span class="hljs-comment">// 🔴 SimpleDateFormat非线程安全,每次创建新实例,耗时3ms</span>
        <span class="hljs-keyword">val</span> dateText = dateFormat.format(item.publishTime)
        holder.dateView.text = dateText
    }
}

<span class="hljs-comment">// After: 预处理数据</span>
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FormattedNewsItem</span>(
    <span class="hljs-keyword">val</span> imagePath: String,
    <span class="hljs-keyword">val</span> displayTitle: String,  <span class="hljs-comment">// 预格式化的标题</span>
    <span class="hljs-keyword">val</span> displayDate: String    <span class="hljs-comment">// 预格式化的日期</span>
)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsAdapter</span>(newsList: List&lt;NewsItem&gt;) : RecyclerView.Adapter&lt;NewsViewHolder&gt;() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> formattedList: List&lt;FormattedNewsItem&gt; = newsList.map { item -&gt;
        <span class="hljs-comment">// 在构造函数中一次性处理所有数据</span>
        FormattedNewsItem(
            imagePath = item.imagePath,
            displayTitle = <span class="hljs-string">"<span class="hljs-subst">${item.title}</span> - <span class="hljs-subst">${item.category}</span>"</span>,
            displayDate = dateFormat.format(item.publishTime)
        )
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">NewsViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> item = formattedList[position]

        <span class="hljs-comment">// ✅ 直接使用预处理的字符串,耗时小于1ms</span>
        holder.titleView.text = item.displayTitle
        holder.dateView.text = item.displayDate

        Glide.with(holder.itemView.context)
            .load(item.imagePath)
            .<span class="hljs-keyword">override</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>)
            .into(holder.imageView)
    }
}
</code></pre>
<p><strong>优化效果</strong>: 字符串格式化从每次5ms降到小于1ms</p>
<h4 data-id="heading-39">优化3: 增加ViewHolder缓存</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// RecyclerView默认只缓存2个ViewHolder,增加到20个</span>
recyclerView.setItemViewCacheSize(<span class="hljs-number">20</span>)

<span class="hljs-comment">// 如果item高度固定,设置为true避免多次measure</span>
recyclerView.setHasFixedSize(<span class="hljs-literal">true</span>)
</code></pre>
<h4 data-id="heading-40">优化4: 预加载机制</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 自定义LayoutManager,提前加载屏幕外的item</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PreloadLinearLayoutManager</span>(context: Context) : LinearLayoutManager(context) {

    <span class="hljs-comment">// 返回额外的布局空间 (像素),用于预加载</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getExtraLayoutSpace</span><span class="hljs-params">(state: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">State</span>)</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">500</span>  <span class="hljs-comment">// 预加载屏幕外500px的内容</span>
    }
}

<span class="hljs-comment">// 使用</span>
recyclerView.layoutManager = PreloadLinearLayoutManager(<span class="hljs-keyword">this</span>)
</code></pre>
<h3 data-id="heading-41">6.4 优化效果验证</h3>
<p><strong>重新抓取Systrace对比</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">Before优化:</span>
Frame <span class="hljs-comment">#245: 35ms (Dropped 2 frames)</span>
  └─ onBindViewHolder: 28ms

<span class="hljs-section">After优化:</span>
Frame <span class="hljs-comment">#245: 8ms (No dropped frames)</span>
  └─ onBindViewHolder: 3ms  ← 优化89%!
</code></pre>
<p><strong>FPS对比</strong>:</p>
<ul>
<li>Before: 25-30 FPS (严重卡顿)</li>
<li>After: 58-60 FPS (丝般顺滑)</li>
</ul>
<p><strong>用户反馈</strong>: "流畅多了,终于能正常使用了!"</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d66e0cb1eb6446a99cd78a22bbf689b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657337&amp;x-signature=cADUEN%2BBMa5fH1w0X2hxt8j%2FX0w%3D" alt="10-05-recyclerview-optimization-result.png" loading="lazy"/></p>
<h2 data-id="heading-42">7. 卡顿监控与持续优化</h2>
<p>优化不是一次性的,需要建立持续监控和优化的体系。</p>
<h3 data-id="heading-43">7.1 线上监控方案</h3>
<p><strong>方案1: 集成开源监控框架</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 集成Tencent Matrix</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> : <span class="hljs-type">Application</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCreate()

        <span class="hljs-comment">// 初始化Matrix</span>
        Matrix.Builder(<span class="hljs-keyword">this</span>)
            .patchListener(MatrixPatchListener())
            .plugin(FrameTracer())      <span class="hljs-comment">// 帧率监控</span>
            .plugin(MethodTracer())      <span class="hljs-comment">// 方法耗时监控</span>
            .plugin(MemoryLeakPlugin())  <span class="hljs-comment">// 内存泄漏监控</span>
            .build()
            .startAllPlugins()
    }
}
</code></pre>
<p><strong>方案2: 自研轻量级监控</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JankMonitor</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> jankList = mutableListOf&lt;JankInfo&gt;()

    <span class="hljs-comment">// 使用FrameMetrics监控</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startMonitor</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> {
        activity.window.addOnFrameMetricsAvailableListener { _, metrics, _ -&gt;
            <span class="hljs-keyword">val</span> totalMs = metrics.getMetric(FrameMetrics.TOTAL_DURATION) / <span class="hljs-number">1_000_000.0</span>

            <span class="hljs-keyword">if</span> (totalMs &gt; <span class="hljs-number">16.6</span>) {
                <span class="hljs-comment">// 记录卡顿信息</span>
                <span class="hljs-keyword">val</span> jankInfo = JankInfo(
                    timestamp = System.currentTimeMillis(),
                    duration = totalMs,
                    scene = getCurrentScene(),
                    stackTrace = Thread.currentThread().stackTrace
                )
                jankList.add(jankInfo)

                <span class="hljs-comment">// 达到一定数量后上报</span>
                <span class="hljs-keyword">if</span> (jankList.size &gt;= <span class="hljs-number">10</span>) {
                    reportJankToServer(jankList)
                    jankList.clear()
                }
            }
        }, Handler(Looper.getMainLooper()))
    }
}

<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JankInfo</span>(
    <span class="hljs-keyword">val</span> timestamp: <span class="hljs-built_in">Long</span>,
    <span class="hljs-keyword">val</span> duration: <span class="hljs-built_in">Double</span>,
    <span class="hljs-keyword">val</span> scene: String,
    <span class="hljs-keyword">val</span> stackTrace: Array&lt;StackTraceElement&gt;
)
</code></pre>
<h3 data-id="heading-44">7.2 关键指标定义</h3>
<p><strong>卡顿率 (Jank Rate)</strong>:</p>
<pre><code class="hljs language-erlang" lang="erlang">卡顿率 = (掉帧次数 / 总帧数) × <span class="hljs-number">100</span><span class="hljs-comment">%</span>

优秀: &lt;<span class="hljs-number">3</span><span class="hljs-comment">%</span>
良好: <span class="hljs-number">3</span>-<span class="hljs-number">5</span><span class="hljs-comment">%</span>
需优化: <span class="hljs-number">5</span>-<span class="hljs-number">10</span><span class="hljs-comment">%</span>
严重问题: &gt;<span class="hljs-number">10</span><span class="hljs-comment">%</span>
</code></pre>
<p><strong>FPS分布</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">目标: 90%以上的帧 &gt; 50fps</span>
</code></pre>
<p><strong>ANR率</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">目标: &lt;0.1% (每1000次启动,ANR少于1次)</span>
</code></pre>
<h3 data-id="heading-45">7.3 持续优化流程</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 监控数据收集
   ↓
<span class="hljs-bullet">2.</span> 问题TOP榜排序 (按影响用户数排序)
   ↓
<span class="hljs-bullet">3.</span> 定期优化迭代 (每周/每两周)
   ↓
<span class="hljs-bullet">4.</span> A/B测试验证
   ↓
<span class="hljs-bullet">5.</span> 全量发布
   ↓
回到步骤1,持续循环
</code></pre>
<h2 data-id="heading-46">8. 总结与最佳实践</h2>
<h3 data-id="heading-47">核心要点回顾</h3>
<ol>
<li>
<p><strong>卡顿的本质</strong>:</p>
<ul>
<li>掉帧 = 超过16.6ms未完成渲染</li>
<li>根源:主线程耗时、渲染线程耗时、系统资源不足</li>
</ul>
</li>
<li>
<p><strong>分析工具链</strong>:</p>
<ul>
<li><strong>Systrace/Perfetto</strong>: 开发阶段深度分析</li>
<li><strong>FrameMetrics</strong>: 线上实时监控</li>
<li><strong>Choreographer</strong>: 轻量级监控</li>
</ul>
</li>
<li>
<p><strong>主线程优化</strong>:</p>
<ul>
<li>异步化:IO、网络、图片解码</li>
<li>布局优化:ConstraintLayout、减少层级</li>
<li>预加载:提前准备数据</li>
</ul>
</li>
<li>
<p><strong>渲染优化</strong>:</p>
<ul>
<li>减少过度绘制:移除不必要的背景</li>
<li>硬件加速:复杂View和动画场景</li>
<li>GPU优化:避免复杂图形绘制</li>
</ul>
</li>
<li>
<p><strong>系统监控</strong>:</p>
<ul>
<li>建立线上监控体系</li>
<li>关注关键指标 (卡顿率、FPS、ANR)</li>
<li>持续优化迭代</li>
</ul>
</li>
</ol>
<h3 data-id="heading-48">优化优先级</h3>





















































<table><thead><tr><th align="center">优先级</th><th align="left">优化项</th><th align="center">预期效果</th><th align="center">实施难度</th></tr></thead><tbody><tr><td align="center"><strong>P0</strong></td><td align="left">主线程IO操作</td><td align="center">↓90%+</td><td align="center">⭐</td></tr><tr><td align="center"><strong>P0</strong></td><td align="left">RecyclerView图片同步解码</td><td align="center">↓90%+</td><td align="center">⭐</td></tr><tr><td align="center"><strong>P1</strong></td><td align="left">复杂布局层级</td><td align="center">↓60-80%</td><td align="center">⭐⭐</td></tr><tr><td align="center"><strong>P1</strong></td><td align="left">过度绘制</td><td align="center">↓40-60%</td><td align="center">⭐⭐</td></tr><tr><td align="center"><strong>P2</strong></td><td align="left">ViewHolder缓存</td><td align="center">↓20-40%</td><td align="center">⭐</td></tr><tr><td align="center"><strong>P2</strong></td><td align="left">硬件加速</td><td align="center">↓30-50%</td><td align="center">⭐⭐</td></tr><tr><td align="center"><strong>P3</strong></td><td align="left">GC优化</td><td align="center">↓10-20%</td><td align="center">⭐⭐⭐</td></tr></tbody></table>
<p><strong>优化建议</strong>:</p>
<ul>
<li>先解决P0级别的问题 (主线程IO、图片同步解码)</li>
<li>再优化P1级别 (布局、过度绘制)</li>
<li>最后考虑P2/P3级别</li>
</ul>
<h3 data-id="heading-49">常见误区</h3>
<p>❌ <strong>误区1</strong>: "我的布局很简单,不需要优化"</p>
<ul>
<li>即使简单布局,嵌套过深也会导致性能问题</li>
</ul>
<p>❌ <strong>误区2</strong>: "Glide会自动优化,不用管"</p>
<ul>
<li>Glide需要正确配置 (override、centerCrop等)</li>
</ul>
<p>❌ <strong>误区3</strong>: "硬件加速开启就好了"</p>
<ul>
<li>硬件加速不是万能的,需要根据场景使用</li>
</ul>
<p>❌ <strong>误区4</strong>: "线上监控会影响性能"</p>
<ul>
<li>轻量级监控 (FrameMetrics、Choreographer) 性能开销小于1%</li>
</ul>
<hr/>
<p><strong>至此,你已经掌握了卡顿问题分析与优化的完整方法论。</strong></p>
<p>记住:<strong>工具+方法论+持续迭代 = 丝般顺滑的60fps体验。</strong></p>
<h2 data-id="heading-50">参考资料</h2>
<h3 data-id="heading-51">Android官方文档</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Ftopic%2Fperformance%2Fvitals%2Frender" target="_blank" title="https://developer.android.com/topic/performance/vitals/render" ref="nofollow noopener noreferrer">Slow rendering</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Fstudio%2Fprofile" target="_blank" title="https://developer.android.com/studio/profile" ref="nofollow noopener noreferrer">Profile your app performance</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fview%2FFrameMetrics" target="_blank" title="https://developer.android.com/reference/android/view/FrameMetrics" ref="nofollow noopener noreferrer">FrameMetrics API</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fgraphics" target="_blank" title="https://source.android.com/docs/core/graphics" ref="nofollow noopener noreferrer">Android渲染机制详解</a></li>
</ul>
<h3 data-id="heading-52">AOSP源码参考</h3>
<ul>
<li><code>frameworks/base/core/java/android/view/Choreographer.java</code></li>
<li><code>frameworks/base/core/java/android/view/ViewRootImpl.java</code></li>
<li><code>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</code></li>
</ul>
<h3 data-id="heading-53">工具与库</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Ftopic%2Fperformance%2Ftracing%2Fcommand-line" target="_blank" title="https://developer.android.com/topic/performance/tracing/command-line" ref="nofollow noopener noreferrer">Systrace</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fperfetto.dev%2F" target="_blank" title="https://perfetto.dev/" ref="nofollow noopener noreferrer">Perfetto</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTencent%2Fmatrix" target="_blank" title="https://github.com/Tencent/matrix" ref="nofollow noopener noreferrer">Tencent Matrix</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbumptech%2Fglide" target="_blank" title="https://github.com/bumptech/glide" ref="nofollow noopener noreferrer">Glide</a></li>
</ul>
<hr/>
<p><strong>系列文章</strong>:</p>
<ul>
<li><a href="https://juejin.cn/post/7592432859862974498" target="_blank" title="https://juejin.cn/post/7592432859862974498">上一篇：启动性能优化:Boot、冷启动与热启动</a></li>
<li><a href="https://juejin.cn/post/7587473691170095104" target="_blank" title="https://juejin.cn/post/7587473691170095104">系列目录: Android系统稳定性与性能优化</a></li>
</ul>
<blockquote>
<p><strong>作者简介</strong>: 多年Android系统开发经验,专注于系统稳定性与性能优化领域。欢迎关注本系列,一起深入Android系统的精彩世界!</p>
</blockquote>
<hr/>
<h3 data-id="heading-54">🎉 感谢关注,让我们一起深入Android系统的精彩世界!</h3>
<h3 data-id="heading-55"><strong>找到我</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top" target="_blank" title="https://home.wonlab.top" ref="nofollow noopener noreferrer">个人主页</a></h3></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Kotlin系列01】Kotlin快速入门：环境搭建与Hello World]]></title>    <link>https://juejin.cn/post/7593541291011883035</link>    <guid>https://juejin.cn/post/7593541291011883035</guid>    <pubDate>2026-01-10T14:20:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593541291011883035" data-draft-id="7593337928307785754" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Kotlin系列01】Kotlin快速入门：环境搭建与Hello World"/> <meta itemprop="keywords" content="Android,Kotlin,Android Studio"/> <meta itemprop="datePublished" content="2026-01-10T14:20:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Kotlin系列01】Kotlin快速入门：环境搭建与Hello World
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T14:20:20.000Z" title="Sat Jan 10 2026 14:20:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>如果你是一位Android开发者，可能已经听说过Google在2017年宣布Kotlin成为Android官方开发语言的消息。如果你是后端开发者,可能注意到越来越多的团队开始用Kotlin重构Java项目。如果你对多平台开发感兴趣,Kotlin Multiplatform可能已经进入你的视野。</p>
<p><strong>Kotlin正在成为JVM生态系统中最受欢迎的现代语言之一</strong>。根据JetBrains 2024年的开发者调查,Kotlin在JVM语言中的采用率已经超过30%,并且还在快速增长。</p>
<p>那么,<strong>为什么要学习Kotlin?</strong> 让我先分享一个真实的故事:</p>
<blockquote>
<p>我的一位朋友在某互联网公司负责Android团队。2019年团队决定将核心模块从Java迁移到Kotlin。仅仅三个月后,他们发现:</p>
<ul>
<li><strong>代码量减少了约40%</strong> - 同样的功能,Kotlin代码更简洁</li>
<li><strong>NullPointerException减少了80%</strong> - Kotlin的空安全机制从根源上杜绝了空指针</li>
<li><strong>开发效率提升明显</strong> - 协程、扩展函数等特性让异步编程变得简单</li>
<li><strong>团队满意度提高</strong> - 开发者们普遍表示"再也不想回到Java了"</li>
</ul>
</blockquote>
<p>这不是个例。从Netflix到Uber,从Slack到Pinterest,越来越多的大公司选择Kotlin作为主力开发语言。</p>
<p><strong>本系列文章的目标</strong>:带你从零开始系统学习Kotlin,不仅掌握语法,更要理解设计哲学和最佳实践。无论你是完全的新手,还是有Java背景的开发者,都能在这里找到适合自己的学习路径。</p>
<p>今天这篇文章,我们将:</p>
<ul>
<li>了解Kotlin的历史和核心特性</li>
<li>对比Kotlin和Java,理解为什么要选择Kotlin</li>
<li>搭建Kotlin开发环境</li>
<li>编写第一个Kotlin程序</li>
<li>学习使用REPL快速验证代码</li>
<li>掌握Kotlin基本语法概念</li>
</ul>
<p>让我们开始这段激动人心的旅程吧!</p>
<h2 data-id="heading-1">认识Kotlin</h2>
<h3 data-id="heading-2">Kotlin的诞生与发展</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/92c99858493a4187b8e2c2335683514b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768659619&amp;x-signature=uMe5tVYzuFfWd2AC1w0IM2%2BFH2E%3D" alt="01-01-kotlin-timeline.png" loading="lazy"/></p>
<p><em>图片说明:Kotlin从2011年发布到今天的发展历程</em></p>
<p><strong>Kotlin</strong>的名字来源于俄罗斯圣彼得堡附近的Kotlin岛(Котлин),这个名字由JetBrains公司(IntelliJ IDEA的开发商)选定。让我们看看Kotlin的重要里程碑:</p>
<ul>
<li><strong>2011年7月</strong> - JetBrains公开宣布Kotlin项目</li>
<li><strong>2012年2月</strong> - 开源,采用Apache 2许可证</li>
<li><strong>2016年2月</strong> - Kotlin 1.0正式发布,标志着生产可用</li>
<li><strong>2017年5月</strong> - Google宣布Kotlin成为Android官方开发语言</li>
<li><strong>2019年5月</strong> - Google宣布Kotlin成为Android开发首选语言(Kotlin-First)</li>
<li><strong>2021年5月</strong> - Kotlin 1.5发布,JVM目标字节码升级到Java 8</li>
<li><strong>2024年11月</strong> - Kotlin 2.0发布,带来K2编译器和重大性能提升</li>
</ul>
<p>从这个发展历程可以看出,<strong>Kotlin已经从一个"小众语言"成长为主流的现代编程语言</strong>。</p>
<h3 data-id="heading-3">为什么选择Kotlin?</h3>
<p>与其听我长篇大论,不如直接看代码对比。假设我们要实现一个简单的功能:创建一个Person类,包含姓名和年龄,并能打印个人信息。</p>
<p><strong>Java实现:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"Name: "</span> + name + <span class="hljs-string">", Age: "</span> + age);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;
        <span class="hljs-keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Objects.hash(name, age);
    }
}
</code></pre>
<p><strong>Kotlin实现:</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">"Name: <span class="hljs-variable">$name</span>, Age: <span class="hljs-variable">$age</span>"</span>)
    }
}
</code></pre>
<p>看到区别了吗?<strong>同样的功能,Java需要30多行代码,Kotlin只需要5行!</strong> 而且Kotlin的<code>data class</code>自动生成了:</p>
<ul>
<li>构造函数</li>
<li>getter方法</li>
<li><code>equals()</code>和<code>hashCode()</code>方法</li>
<li><code>toString()</code>方法</li>
<li><code>copy()</code>方法(用于复制对象)</li>
</ul>
<p>这就是Kotlin的魅力:<strong>Less is More(少即是多)</strong>。</p>
<h3 data-id="heading-4">Kotlin的核心特性</h3>
<p>让我用一张图来展示Kotlin的核心特性:</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f390885d22bc4227b133ee1d343edfa4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768659619&amp;x-signature=YaK%2BUdLjaJuD9rH0%2BR6%2BzH9MElA%3D" alt="01-02-kotlin-features.png" loading="lazy"/></p>
<p><em>图片说明:Kotlin的八大核心特性</em></p>
<h4 data-id="heading-5">1. 简洁性(Conciseness)</h4>
<p>大幅减少样板代码(Boilerplate Code),让开发者专注于业务逻辑而非重复性代码。</p>
<h4 data-id="heading-6">2. 空安全(Null Safety)</h4>
<p>从语言层面区分可空类型和非空类型,编译期就能捕获绝大多数空指针错误。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">var</span> name: String = <span class="hljs-string">"Kotlin"</span>  <span class="hljs-comment">// 不可为空</span>
name = <span class="hljs-literal">null</span>  <span class="hljs-comment">// 编译错误!</span>

<span class="hljs-keyword">var</span> nullableName: String? = <span class="hljs-string">"Kotlin"</span>  <span class="hljs-comment">// 可空类型</span>
nullableName = <span class="hljs-literal">null</span>  <span class="hljs-comment">// 正确</span>
</code></pre>
<h4 data-id="heading-7">3. 互操作性(Interoperability)</h4>
<p>与Java 100%互操作,可以直接调用Java库,混合编译,平滑迁移。</p>
<h4 data-id="heading-8">4. 工具友好(Tool-Friendly)</h4>
<p>由IntelliJ IDEA背后的公司开发,工具支持一流,智能提示、重构等功能体验极佳。</p>
<h4 data-id="heading-9">5. 现代化语言特性</h4>
<ul>
<li>函数式编程支持(高阶函数、Lambda表达式)</li>
<li>协程(Coroutines)用于优雅处理异步操作</li>
<li>扩展函数(Extension Functions)无需继承即可扩展类功能</li>
<li>DSL构建能力</li>
</ul>
<h4 data-id="heading-10">6. 多平台支持</h4>
<ul>
<li>JVM平台 - Android和服务端开发</li>
<li>JavaScript平台 - 前端开发</li>
<li>Native平台 - iOS、Desktop、嵌入式系统</li>
<li>Kotlin Multiplatform - 跨平台代码共享</li>
</ul>
<h4 data-id="heading-11">7. 表达力强</h4>
<ul>
<li>操作符重载</li>
<li>中缀函数</li>
<li>字符串模板</li>
<li>when表达式</li>
</ul>
<h4 data-id="heading-12">8. 安全性</h4>
<ul>
<li>类型安全</li>
<li>编译时检查</li>
<li>不可变性优先</li>
</ul>
<h3 data-id="heading-13">Kotlin vs Java - 深度对比</h3>
<p>作为一位在Java和Kotlin都有多年经验的开发者,我整理了一个详细对比表:</p>







































































<table><thead><tr><th align="left">特性</th><th align="left">Java</th><th align="left">Kotlin</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>空安全</strong></td><td align="left">运行时检查,易NPE</td><td align="left">编译时检查</td><td align="left">Kotlin减少80%空指针错误</td></tr><tr><td align="left"><strong>代码简洁度</strong></td><td align="left">冗长</td><td align="left">简洁</td><td align="left">平均减少40%代码量</td></tr><tr><td align="left"><strong>函数式编程</strong></td><td align="left">Java 8+支持Lambda</td><td align="left">原生支持,更强大</td><td align="left">Kotlin的高阶函数更灵活</td></tr><tr><td align="left"><strong>协程</strong></td><td align="left">需要第三方库</td><td align="left">原生支持</td><td align="left">Kotlin协程轻量级高效</td></tr><tr><td align="left"><strong>扩展函数</strong></td><td align="left">不支持</td><td align="left">支持</td><td align="left">无需继承即可扩展类</td></tr><tr><td align="left"><strong>智能类型转换</strong></td><td align="left">需手动转换</td><td align="left">自动转换</td><td align="left">is检查后自动转型</td></tr><tr><td align="left"><strong>数据类</strong></td><td align="left">需大量样板代码</td><td align="left">一行搞定</td><td align="left">data class自动生成</td></tr><tr><td align="left"><strong>默认参数</strong></td><td align="left">不支持</td><td align="left">支持</td><td align="left">减少方法重载</td></tr><tr><td align="left"><strong>字符串模板</strong></td><td align="left">字符串拼接繁琐</td><td align="left">原生支持</td><td align="left"><code>"Hello $name"</code></td></tr><tr><td align="left"><strong>when表达式</strong></td><td align="left">switch语句受限</td><td align="left">功能强大</td><td align="left">支持任意表达式</td></tr></tbody></table>
<h3 data-id="heading-14">Kotlin的应用场景</h3>
<p>现在让我们看看Kotlin在实际项目中的应用场景:</p>
<h4 data-id="heading-15">Android开发(最广泛)</h4>
<ul>
<li><strong>官方首选语言</strong> - Google推荐Kotlin作为Android开发首选</li>
<li><strong>Jetpack Compose</strong> - 新一代UI框架完全基于Kotlin</li>
<li><strong>协程 + LiveData/Flow</strong> - 优雅处理异步和响应式编程</li>
</ul>
<h4 data-id="heading-16">服务端开发</h4>
<ul>
<li><strong>Spring Boot</strong> - 完美支持Kotlin</li>
<li><strong>Ktor</strong> - JetBrains开发的Kotlin原生Web框架</li>
<li><strong>Vert.x</strong> - 响应式框架Kotlin支持</li>
</ul>
<h4 data-id="heading-17">多平台开发(Kotlin Multiplatform)</h4>
<ul>
<li>在Android、iOS、Web之间共享业务逻辑代码</li>
<li>降低维护成本,提高代码复用率</li>
</ul>
<h4 data-id="heading-18">脚本和工具开发</h4>
<ul>
<li>Gradle构建脚本(Kotlin DSL)</li>
<li>数据科学和脚本任务</li>
</ul>
<h2 data-id="heading-19">搭建Kotlin开发环境</h2>
<p>好了,理论介绍够了,让我们动手搭建开发环境!我会提供详细的步骤,确保你能顺利完成。</p>
<h3 data-id="heading-20">环境需求</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76da428f4f81439c8d13a72f65c42cba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768659619&amp;x-signature=j8GP85CIX5uaouhvCkxSf45qzEM%3D" alt="01-03-dev-environment.png" loading="lazy"/></p>
<p><em>图片说明:Kotlin开发环境的组成部分</em></p>
<p>在开始之前,我们需要准备:</p>
<ol>
<li><strong>JDK(Java Development Kit)</strong> - Kotlin运行在JVM上,需要JDK</li>
<li><strong>IntelliJ IDEA</strong> - 最佳的Kotlin开发工具</li>
<li><strong>Kotlin插件</strong> - IntelliJ IDEA Community版内置Kotlin支持</li>
</ol>
<h3 data-id="heading-21">步骤1:安装JDK</h3>
<p>Kotlin可以运行在Java 8及以上版本,推荐使用Java 11或Java 17(LTS版本)。</p>
<h4 data-id="heading-22">Windows系统</h4>
<ol>
<li>
<p><strong>下载JDK</strong></p>
<ul>
<li>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fadoptium.net%2F" target="_blank" title="https://adoptium.net/" ref="nofollow noopener noreferrer">Adoptium</a> 或 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fdownloads%2F" target="_blank" title="https://www.oracle.com/java/technologies/downloads/" ref="nofollow noopener noreferrer">Oracle JDK</a></li>
<li>选择Java 17(推荐)</li>
<li>下载Windows x64 MSI安装包</li>
</ul>
</li>
<li>
<p><strong>安装JDK</strong></p>
<ul>
<li>双击MSI文件,按提示安装</li>
<li>建议安装路径:<code>C:\Program Files\Java\jdk-17</code></li>
</ul>
</li>
<li>
<p><strong>配置环境变量</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 打开"系统环境变量"设置</span>
<span class="hljs-comment"># 新建系统变量 JAVA_HOME</span>
JAVA_HOME=C:\Program Files\Java\jdk-17

<span class="hljs-comment"># 编辑Path变量,添加</span>
%JAVA_HOME%\bin
</code></pre>
</li>
<li>
<p><strong>验证安装</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 打开命令提示符,执行</span>
java -version
<span class="hljs-comment"># 应该显示: openjdk version "17.0.x"</span>
</code></pre>
</li>
</ol>
<h4 data-id="heading-23">macOS系统</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用Homebrew安装(推荐)</span>
brew install openjdk@17

<span class="hljs-comment"># 创建符号链接</span>
sudo <span class="hljs-built_in">ln</span> -sfn /opt/homebrew/opt/openjdk@17/libexec/openjdk.jdk \
    /Library/Java/JavaVirtualMachines/openjdk-17.jdk

<span class="hljs-comment"># 添加到PATH(添加到 ~/.zshrc 或 ~/.bash_profile)</span>
<span class="hljs-built_in">export</span> PATH=<span class="hljs-string">"/opt/homebrew/opt/openjdk@17/bin:<span class="hljs-variable">$PATH</span>"</span>

<span class="hljs-comment"># 验证安装</span>
java -version
</code></pre>
<h4 data-id="heading-24">Linux系统(Ubuntu/Debian)</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 更新包列表</span>
sudo apt update

<span class="hljs-comment"># 安装OpenJDK 17</span>
sudo apt install openjdk-17-jdk

<span class="hljs-comment"># 验证安装</span>
java -version
</code></pre>

**推荐**: 如果你需要管理多个JDK版本,可以使用:
- Windows: [Jabba](https://github.com/shyiko/jabba) 或 [SDKMAN!](https://sdkman.io/)
- macOS/Linux: [SDKMAN!](https://sdkman.io/) 或 [jEnv](https://www.jenv.be/)

<h3 data-id="heading-25">步骤2:安装IntelliJ IDEA</h3>
<p><strong>IntelliJ IDEA</strong>是由JetBrains开发的IDE,对Kotlin支持最好。有两个版本:</p>
<ul>
<li><strong>Community Edition</strong>(免费) - 对于学习Kotlin已经足够</li>
<li><strong>Ultimate Edition</strong>(收费) - 提供更多企业级功能</li>
</ul>
<p>我们使用免费的Community版本即可。</p>
<h4 data-id="heading-26">下载与安装</h4>
<ol>
<li>
<p><strong>访问官网</strong></p>
<ul>
<li>打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2Fidea%2Fdownload%2F" target="_blank" title="https://www.jetbrains.com/idea/download/" ref="nofollow noopener noreferrer">JetBrains官网</a></li>
<li>选择你的操作系统</li>
<li>下载<strong>Community Edition</strong></li>
</ul>
</li>
<li>
<p><strong>安装IDEA</strong></p>
<ul>
<li>Windows: 运行.exe安装包,按提示安装</li>
<li>macOS: 打开.dmg文件,拖拽IDEA到Applications</li>
<li>Linux: 解压.tar.gz,运行bin/idea.sh</li>
</ul>
</li>
<li>
<p><strong>首次启动配置</strong></p>
<ul>
<li>选择UI主题(Darcula深色主题或Light浅色主题)</li>
<li>选择键盘映射(默认或类似IDE)</li>
<li><strong>重要</strong>: 确认Kotlin插件已安装(Community版自带)</li>
</ul>
</li>
</ol>

**学生福利**: 如果你是学生,可以申请免费的Ultimate版本教育许可。访问 [JetBrains学生计划](https://www.jetbrains.com/student/) 了解详情。

<h3 data-id="heading-27">步骤3:创建第一个Kotlin项目</h3>
<p>现在让我们在IntelliJ IDEA中创建第一个Kotlin项目!</p>
<ol>
<li>
<p><strong>启动IDEA</strong>,点击<strong>New Project</strong></p>
</li>
<li>
<p><strong>配置项目</strong></p>
<ul>
<li><strong>Name</strong>: HelloKotlin</li>
<li><strong>Location</strong>: 选择你的项目目录</li>
<li><strong>Language</strong>: Kotlin</li>
<li><strong>Build System</strong>: IntelliJ(对于学习最简单)</li>
<li><strong>JDK</strong>: 选择刚才安装的JDK 17</li>
<li><strong>Add sample code</strong>: 勾选(会自动创建Main.kt)</li>
</ul>
</li>
<li>
<p><strong>点击Create</strong>,等待项目创建完成</p>
</li>
</ol>
<h3 data-id="heading-28">项目结构解析</h3>
<p>创建完成后,你会看到这样的项目结构:</p>
<pre><code class="hljs language-csharp" lang="csharp">HelloKotlin/
├── .idea/                 <span class="hljs-meta"># IDEA配置文件目录</span>
├── src/                   <span class="hljs-meta"># 源代码目录</span>
│   └── main/
│       └── kotlin/
│           └── Main.kt    <span class="hljs-meta"># 主程序文件</span>
├── <span class="hljs-keyword">out</span>/                   <span class="hljs-meta"># 编译输出目录</span>
└── HelloKotlin.iml       <span class="hljs-meta"># 模块配置文件</span>
</code></pre>
<p><strong>目录说明:</strong></p>
<ul>
<li><code>src/main/kotlin/</code> - 存放Kotlin源代码</li>
<li><code>out/</code> - 编译后的字节码文件(<code>.class</code>)</li>
<li><code>.idea/</code> - IntelliJ IDEA的项目配置</li>
</ul>
<h2 data-id="heading-29">第一个Kotlin程序:Hello World</h2>
<p>让我们看看IDEA自动创建的<code>Main.kt</code>文件:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    println(<span class="hljs-string">"Hello World!"</span>)
}
</code></pre>
<p>就这么简单!仅仅3行代码,我们就完成了第一个Kotlin程序。让我们逐行解析:</p>
<h3 data-id="heading-30">代码解析</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {                <span class="hljs-comment">// 1. 声明main函数</span>
    println(<span class="hljs-string">"Hello World!"</span>) <span class="hljs-comment">// 2. 打印文本</span>
}                           <span class="hljs-comment">// 3. 函数结束</span>
</code></pre>
<p><strong>详细说明:</strong></p>
<ol>
<li>
<p><strong><code>fun main()</code></strong> - 程序入口点</p>
<ul>
<li><code>fun</code> 是Kotlin的关键字,用于声明函数(function)</li>
<li><code>main</code> 是特殊的函数名,程序从这里开始执行</li>
<li><code>()</code> 表示这个函数不接受参数</li>
<li>没有指定返回类型,表示返回<code>Unit</code>(相当于Java的void)</li>
</ul>
</li>
<li>
<p><strong><code>println("Hello World!")</code></strong> - 打印输出</p>
<ul>
<li><code>println</code>是Kotlin标准库提供的函数</li>
<li>功能:打印文本并换行</li>
<li><code>"Hello World!"</code>是字符串字面量</li>
</ul>
</li>
<li>
<p><strong>注意没有分号!</strong></p>
<ul>
<li>Kotlin中分号是可选的</li>
<li>虽然加了也不报错,但约定俗成不加</li>
</ul>
</li>
</ol>
<h3 data-id="heading-31">运行程序</h3>
<p>有三种方式运行程序:</p>
<p><strong>方式1:点击行号旁的绿色箭头</strong></p>
<ul>
<li>在<code>fun main()</code>这一行,会出现绿色的▶️图标</li>
<li>点击图标,选择<strong>Run 'MainKt'</strong></li>
</ul>
<p><strong>方式2:使用菜单</strong></p>
<ul>
<li>点击顶部菜单 <strong>Run</strong> → <strong>Run 'MainKt'</strong></li>
</ul>
<p><strong>方式3:使用快捷键</strong></p>
<ul>
<li>Windows/Linux: <code>Ctrl + Shift + F10</code></li>
<li>macOS: <code>Ctrl + Shift + R</code></li>
</ul>
<p>运行后,你会在底部的<strong>Run窗口</strong>看到输出:</p>
<pre><code class="hljs language-vbnet" lang="vbnet">Hello World!

Process finished <span class="hljs-keyword">with</span> <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span>
</code></pre>
<p><strong>恭喜你!你已经成功运行了第一个Kotlin程序!</strong> 🎉</p>
<h3 data-id="heading-32">让我们稍微改进一下</h3>
<p>现在让我们让程序更有趣一点:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> name = <span class="hljs-string">"Kotlin"</span>
    <span class="hljs-keyword">val</span> version = <span class="hljs-string">"2.0"</span>
    println(<span class="hljs-string">"Hello <span class="hljs-variable">$name</span> <span class="hljs-variable">$version</span>!"</span>)
    println(<span class="hljs-string">"欢迎来到Kotlin的世界!"</span>)
}
</code></pre>
<p><strong>新概念:</strong></p>
<ul>
<li><code>val</code> - 声明一个只读变量(类似Java的final)</li>
<li><code>$name</code> - 字符串模板,直接在字符串中插入变量值</li>
</ul>
<p>运行输出:</p>
<pre><code class="hljs">Hello Kotlin 2.0!
欢迎来到Kotlin的世界!
</code></pre>
<p>看到了吗?字符串模板让代码更简洁,不需要Java那样繁琐的<code>+</code>拼接。</p>
<h2 data-id="heading-33">使用Kotlin REPL</h2>
<p><strong>REPL</strong>(Read-Eval-Print Loop,读取-求值-输出循环)是一个交互式编程环境,非常适合快速验证代码片段和学习新语法。</p>
<h3 data-id="heading-34">启动REPL</h3>
<p>在IntelliJ IDEA中:</p>
<ol>
<li>点击顶部菜单 <strong>Tools</strong> → <strong>Kotlin</strong> → <strong>Kotlin REPL</strong></li>
<li>底部会出现<strong>Kotlin REPL</strong>窗口</li>
</ol>
<p>你也可以使用命令行REPL(需要先安装Kotlin compiler):</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># macOS/Linux用户可以用SDKMAN安装</span>
sdk install kotlin

<span class="hljs-comment"># 启动REPL</span>
kotlinc-jvm
</code></pre>
<h3 data-id="heading-35">REPL基本使用</h3>
<p>让我们在REPL中尝试一些代码:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 输入表达式,按Ctrl+Enter执行</span>
&gt;&gt;&gt; <span class="hljs-number">2</span> + <span class="hljs-number">3</span>
<span class="hljs-number">5</span>

&gt;&gt;&gt; <span class="hljs-string">"Hello"</span> + <span class="hljs-string">" "</span> + <span class="hljs-string">"REPL"</span>
Hello REPL

&gt;&gt;&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-number">10</span>
&gt;&gt;&gt; <span class="hljs-keyword">val</span> y = <span class="hljs-number">20</span>
&gt;&gt;&gt; x + y
<span class="hljs-number">30</span>

&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greet</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-string">"Hello, <span class="hljs-variable">$name</span>!"</span>
&gt;&gt;&gt; greet(<span class="hljs-string">"Kotlin"</span>)
Hello, Kotlin!

&gt;&gt;&gt; (<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).filter { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }
[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]
</code></pre>
<p><strong>REPL的优势:</strong></p>
<ul>
<li>✅ 立即看到结果,无需编译</li>
<li>✅ 快速验证语法和API</li>
<li>✅ 学习新特性的最佳工具</li>
<li>✅ 调试代码片段</li>
</ul>

**学习建议**: 在学习Kotlin的过程中,遇到不确定的语法,先在REPL中试一试,比查文档更快!

<h3 data-id="heading-36">REPL实战:快速计算器</h3>
<p>让我们用REPL实现一个简单的计算器:</p>
<pre><code class="hljs language-kotlin" lang="kotlin">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculate</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>, op: <span class="hljs-type">Char</span>)</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (op) {
            <span class="hljs-string">'+'</span> -&gt; a + b
            <span class="hljs-string">'-'</span> -&gt; a - b
            <span class="hljs-string">'*'</span> -&gt; a * b
            <span class="hljs-string">'/'</span> -&gt; a / b
            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span>
        }
    }

&gt;&gt;&gt; calculate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'+'</span>)
<span class="hljs-number">15</span>

&gt;&gt;&gt; calculate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'*'</span>)
<span class="hljs-number">50</span>
</code></pre>
<h2 data-id="heading-37">Kotlin基本语法概览</h2>
<p>在结束本文之前,让我们快速浏览一下Kotlin的基本语法,为后续学习打下基础。</p>
<h3 data-id="heading-38">包声明和导入</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.myapp  <span class="hljs-comment">// 声明包名</span>

<span class="hljs-keyword">import</span> kotlin.math.*       <span class="hljs-comment">// 导入kotlin.math包的所有内容</span>
<span class="hljs-keyword">import</span> java.util.Date      <span class="hljs-comment">// 导入Java类</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    println(sqrt(<span class="hljs-number">16.0</span>))  <span class="hljs-comment">// 使用导入的函数</span>
    println(Date())      <span class="hljs-comment">// 使用导入的Java类</span>
}
</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>包名通常与文件路径对应,但不强制</li>
<li>可以使用<code>import</code>导入Kotlin和Java的类和函数</li>
<li><code>*</code>表示导入包中的所有内容</li>
</ul>
<h3 data-id="heading-39">语句 vs 表达式</h3>
<p>这是Kotlin的一个重要概念:<strong>几乎一切都是表达式</strong>。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Java中if是语句(statement)</span>
String result;
<span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) {
    result = <span class="hljs-string">"positive"</span>;
} <span class="hljs-keyword">else</span> {
    result = <span class="hljs-string">"negative"</span>;
}

<span class="hljs-comment">// Kotlin中if是表达式(expression),有返回值</span>
<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-string">"positive"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"negative"</span>
</code></pre>
<p><strong>表达式与语句的区别:</strong></p>
<ul>
<li><strong>语句(Statement)</strong>: 执行操作,无返回值</li>
<li><strong>表达式(Expression)</strong>: 执行操作,有返回值</li>
</ul>
<p>Kotlin中,<code>if</code>、<code>when</code>、<code>try</code>都是表达式,可以直接赋值给变量。</p>
<h3 data-id="heading-40">分号可选</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 不需要分号</span>
<span class="hljs-keyword">val</span> x = <span class="hljs-number">10</span>
<span class="hljs-keyword">val</span> y = <span class="hljs-number">20</span>
println(x + y)

<span class="hljs-comment">// 加分号也可以,但不推荐</span>
<span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">val</span> b = <span class="hljs-number">20</span>;
</code></pre>
<h3 data-id="heading-41">注释</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 这是单行注释</span>

<span class="hljs-comment">/*
 这是
 多行注释
 */</span>

<span class="hljs-comment">/**
 * 这是文档注释(KDoc)
 * <span class="hljs-doctag">@param</span> name 参数说明
 * <span class="hljs-doctag">@return</span> 返回值说明
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greet</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, <span class="hljs-variable">$name</span>!"</span>
}
</code></pre>
<h3 data-id="heading-42">代码风格约定</h3>
<p>Kotlin有一套官方的<a href="https://link.juejin.cn?target=https%3A%2F%2Fkotlinlang.org%2Fdocs%2Fcoding-conventions.html" target="_blank" title="https://kotlinlang.org/docs/coding-conventions.html" ref="nofollow noopener noreferrer">代码风格指南</a>,主要约定:</p>
<ul>
<li>
<p><strong>命名风格:</strong></p>
<ul>
<li>类名:PascalCase (大驼峰) - <code>PersonInfo</code></li>
<li>函数名/变量名:camelCase (小驼峰) - <code>userName</code></li>
<li>常量:SCREAMING_SNAKE_CASE - <code>MAX_COUNT</code></li>
</ul>
</li>
<li>
<p><strong>缩进</strong>: 使用4个空格,不使用Tab</p>
</li>
<li>
<p><strong>花括号</strong>: 开花括号不换行(K&amp;R风格)</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">()</span></span> {  <span class="hljs-comment">// 开花括号紧跟函数声明</span>
    <span class="hljs-comment">// 代码</span>
}
</code></pre>
</li>
<li>
<p><strong>空格使用:</strong></p>
<ul>
<li>操作符两侧加空格:<code>a + b</code></li>
<li>逗号后加空格:<code>fun foo(a: Int, b: Int)</code></li>
<li>冒号前不加,后加:<code>val name: String</code></li>
</ul>
</li>
</ul>
<h2 data-id="heading-43">Kotlin Playground:在线体验</h2>
<p>如果你暂时不想安装环境,可以使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fplay.kotlinlang.org%2F" target="_blank" title="https://play.kotlinlang.org/" ref="nofollow noopener noreferrer">Kotlin Playground</a>:</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/86ef2b87fbb741d5b73ed5d1ad5c519f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768659619&amp;x-signature=vJ1yxJxVmQFtoX7stcww7Fhy67o%3D" alt="01-04-kotlin-playground.png" loading="lazy"/></p>
<p><em>图片说明:Kotlin Playground在线编程环境</em></p>
<p><strong>特点:</strong></p>
<ul>
<li>无需安装,浏览器直接运行</li>
<li>支持切换Kotlin版本和运行平台(JVM/JS/Native)</li>
<li>可以分享代码链接</li>
<li>内置大量示例</li>
</ul>
<p><strong>访问方式:</strong></p>
<ol>
<li>打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplay.kotlinlang.org%2F" target="_blank" title="https://play.kotlinlang.org/" ref="nofollow noopener noreferrer">play.kotlinlang.org/</a></li>
<li>在编辑器中输入代码</li>
<li>点击<strong>Run</strong>按钮</li>
<li>在右侧查看输出结果</li>
</ol>
<p>这对于快速分享代码和在线演示非常有用。</p>
<h2 data-id="heading-44">常见问题解答</h2>
<h3 data-id="heading-45">Q1: Kotlin和Java可以混合使用吗?</h3>
<p><strong>答:</strong> 完全可以!Kotlin与Java 100%互操作。你可以:</p>
<ul>
<li>在Kotlin项目中调用Java代码</li>
<li>在Java项目中调用Kotlin代码</li>
<li>同一项目中既有<code>.kt</code>文件又有<code>.java</code>文件</li>
</ul>
<p>实际项目中,很多团队都是渐进式迁移,先写新功能用Kotlin,老代码保持Java,两者和平共处。</p>
<h3 data-id="heading-46">Q2: 学习Kotlin需要先学Java吗?</h3>
<p><strong>答:</strong> 不需要。Kotlin语法更现代、更简洁,直接学习Kotlin反而更容易。但是:</p>
<ul>
<li>如果你<strong>已经会Java</strong>,学Kotlin会非常快(1-2周即可上手)</li>
<li>如果你<strong>完全没有编程经验</strong>,建议先学习编程基础概念</li>
<li>如果你<strong>会其他语言</strong>(如Python/JavaScript),学Kotlin很轻松</li>
</ul>
<h3 data-id="heading-47">Q3: IntelliJ IDEA和Android Studio有什么区别?</h3>
<p><strong>答:</strong></p>
<ul>
<li><strong>Android Studio</strong>基于IntelliJ IDEA,专为Android开发定制</li>
<li><strong>IntelliJ IDEA</strong>是通用IDE,支持多种语言和框架</li>
</ul>
<p>如果你是Android开发者,使用Android Studio;如果是后端或多平台开发,使用IntelliJ IDEA。两者的Kotlin支持几乎一致。</p>
<h3 data-id="heading-48">Q4: Kotlin的性能如何?</h3>
<p><strong>答:</strong></p>
<ul>
<li>Kotlin编译成JVM字节码,<strong>运行时性能与Java相同</strong></li>
<li>某些特性(如inline函数)甚至可以优化性能</li>
<li>协程比Java线程更轻量级,性能更好</li>
<li>唯一需要注意的是编译速度,Kotlin编译比Java稍慢,但Kotlin 2.0的K2编译器已大幅改进</li>
</ul>
<h3 data-id="heading-49">Q5: 学习Kotlin需要多长时间?</h3>
<p><strong>答:</strong> 取决于你的背景:</p>
<ul>
<li><strong>有Java经验</strong>: 1-2周掌握基础,1-2个月熟练</li>
<li><strong>有其他语言经验</strong>: 2-4周掌握基础,2-3个月熟练</li>
<li><strong>零基础</strong>: 1-2个月掌握基础,3-6个月熟练</li>
</ul>
<p>本系列文章会带你系统学习,跟着练习,进步会很快!</p>
<h2 data-id="heading-50">总结</h2>
<p>恭喜你完成了Kotlin学习的第一步!让我们回顾一下今天学到的内容:</p>
<h3 data-id="heading-51">核心要点</h3>
<ol>
<li>
<p><strong>Kotlin是什么:</strong></p>
<ul>
<li>JetBrains开发的现代化JVM语言</li>
<li>Android官方首选语言</li>
<li>简洁、安全、富有表现力</li>
<li>与Java 100%互操作</li>
</ul>
</li>
<li>
<p><strong>为什么选择Kotlin:</strong></p>
<ul>
<li>代码量减少40%</li>
<li>编译期空安全,减少80%空指针错误</li>
<li>现代化语言特性(协程、扩展函数、DSL等)</li>
<li>多平台支持</li>
</ul>
</li>
<li>
<p><strong>开发环境:</strong></p>
<ul>
<li>JDK 17+ (推荐)</li>
<li>IntelliJ IDEA Community Edition</li>
<li>Kotlin插件(IDEA自带)</li>
</ul>
</li>
<li>
<p><strong>Hello World程序:</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    println(<span class="hljs-string">"Hello World!"</span>)
}
</code></pre>
</li>
<li>
<p><strong>REPL工具:</strong></p>
<ul>
<li>快速验证代码的交互式环境</li>
<li>学习新语法的最佳工具</li>
</ul>
</li>
<li>
<p><strong>基本语法:</strong></p>
<ul>
<li>分号可选</li>
<li>几乎一切都是表达式</li>
<li>字符串模板 <code>"Hello $name"</code></li>
<li>简洁的函数声明</li>
</ul>
</li>
</ol>
<h3 data-id="heading-52">下一步学习计划</h3>
<p>现在你已经搭建好环境并运行了第一个程序,接下来我们将深入学习:</p>
<ul>
<li><code>val</code> vs <code>var</code> 的区别</li>
<li>Kotlin的基本数据类型</li>
<li>字符串操作和模板</li>
<li>数组和集合</li>
<li>空安全机制详解</li>
</ul>
<p><strong>练习建议:</strong></p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 在IntelliJ IDEA中创建一个新项目</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 修改Hello World程序,输出你的姓名和学习Kotlin的目标</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 在REPL中尝试本文的所有代码示例</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 探索Kotlin Playground的在线示例</li>
</ul>

**学习小贴士**: 学习编程最重要的是**多练习**。不要只是看代码,一定要亲手敲一遍,运行一遍,甚至故意改错看看会发生什么。只有通过实践,才能真正理解和记住知识!

<h2 data-id="heading-53">相关资源</h2>
<h3 data-id="heading-54">官方资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fkotlinlang.org%2Fdocs%2Fhome.html" target="_blank" title="https://kotlinlang.org/docs/home.html" ref="nofollow noopener noreferrer">Kotlin官方文档</a> - 最权威的学习资料</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fplay.kotlinlang.org%2Fkoans" target="_blank" title="https://play.kotlinlang.org/koans" ref="nofollow noopener noreferrer">Kotlin Koans</a> - 互动式编程练习</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fplay.kotlinlang.org%2F" target="_blank" title="https://play.kotlinlang.org/" ref="nofollow noopener noreferrer">Kotlin Playground</a> - 在线编程环境</li>
</ul>
<h3 data-id="heading-55">社区资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.kotlincn.net%2F" target="_blank" title="https://www.kotlincn.net/" ref="nofollow noopener noreferrer">Kotlin中文社区</a> - 中文文档和社区</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsurveys.jetbrains.com%2Fs3%2Fkotlin-slack-sign-up" target="_blank" title="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up" ref="nofollow noopener noreferrer">Kotlin Slack</a> - 官方Slack频道</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.reddit.com%2Fr%2FKotlin%2F" target="_blank" title="https://www.reddit.com/r/Kotlin/" ref="nofollow noopener noreferrer">Reddit /r/Kotlin</a> - Reddit讨论区</li>
</ul>
<h3 data-id="heading-56">学习路径</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fplay.kotlinlang.org%2FbyExample%2Foverview" target="_blank" title="https://play.kotlinlang.org/byExample/overview" ref="nofollow noopener noreferrer">Kotlin By Example</a> - 通过示例学习</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhyperskill.org%2Ftracks%2F18" target="_blank" title="https://hyperskill.org/tracks/18" ref="nofollow noopener noreferrer">JetBrains Academy - Kotlin Track</a> - 系统化课程</li>
</ul>
<hr/>
<p><strong>系列文章导航:</strong></p>
<ul>
<li>👉 下一篇: [变量、数据类型与基本操作]--马上就来</li>
</ul>
<hr/>
<p><em>如果这篇文章对你有帮助,欢迎点赞、收藏、分享!有任何问题或建议,欢迎在评论区留言讨论。让我们一起学习,一起成长!</em></p>
<p><em>也欢迎访问我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top" target="_blank" title="https://home.wonlab.top" ref="nofollow noopener noreferrer">个人主页</a>发现更多宝藏资源</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude Code 中的子 Agent 派生实现：Task Tool 完全指南]]></title>    <link>https://juejin.cn/post/7593292445299933203</link>    <guid>https://juejin.cn/post/7593292445299933203</guid>    <pubDate>2026-01-10T13:32:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593292445299933203" data-draft-id="7593232758127607814" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude Code 中的子 Agent 派生实现：Task Tool 完全指南"/> <meta itemprop="keywords" content="人工智能,Python"/> <meta itemprop="datePublished" content="2026-01-10T13:32:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="两万五千个小时"/> <meta itemprop="url" content="https://juejin.cn/user/3966693682971870"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude Code 中的子 Agent 派生实现：Task Tool 完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3966693682971870/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    两万五千个小时
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:32:39.000Z" title="Sat Jan 10 2026 13:32:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读32分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Claude Code 中的子 Agent 派生实现：Task Tool 完全指南</h2>
<h3 data-id="heading-1">📍 导航指南</h3>
<p>根据你的需求，选择合适的阅读路径：</p>
<ul>
<li>🎯 <strong>想了解 Task tool？</strong> → <a href="#task-tool-core" title="#task-tool-core">Task Tool 核心机制</a> - Claude Code 的实际实现</li>
<li>🔧 <strong>想看代码实现？</strong> → <a href="#code-implementation" title="#code-implementation">完整代码示例</a> - 从零构建派生系统</li>
<li>⚡ <strong>关注性能优化？</strong> → <a href="#parallel-execution" title="#parallel-execution">并行执行机制</a> - 获得 2-3x 加速</li>
<li>📚 <strong>深入理解原理？</strong> → <a href="#architecture-design" title="#architecture-design">架构设计解析</a> - 设计思想和权衡</li>
</ul>
<hr/>
<h3 data-id="heading-2">目录</h3>
<h4 data-id="heading-3">第一部分：核心概念 🎯</h4>
<ul>
<li><a href="#what-is-delegation" title="#what-is-delegation">什么是子 Agent 派生</a></li>
<li><a href="#why-not-hardcode" title="#why-not-hardcode">为什么需要派生而非硬编码</a></li>
<li><a href="#claude-code-implementation" title="#claude-code-implementation">Claude Code 中的实现方式</a></li>
</ul>
<h4 data-id="heading-4">第二部分：Task Tool 详解 🔧</h4>
<ul>
<li><a href="#task-tool-core" title="#task-tool-core">Task Tool 核心机制</a></li>
<li><a href="#subagent-types" title="#subagent-types">6 种 SubAgent Type 设计</a></li>
<li><a href="#state-management" title="#state-management">状态管理与上下文传递</a></li>
<li><a href="#dependency-resolution" title="#dependency-resolution">依赖解析与执行顺序</a></li>
</ul>
<h4 data-id="heading-5">第三部分：代码实现 💻</h4>
<ul>
<li><a href="#setup" title="#setup">环境准备</a></li>
<li><a href="#data-models" title="#data-models">数据模型设计</a></li>
<li><a href="#subagent-implementation" title="#subagent-implementation">SubAgent 实现</a></li>
<li><a href="#langgraph-workflow" title="#langgraph-workflow">LangGraph 工作流</a></li>
<li><a href="#complete-example" title="#complete-example">完整示例</a></li>
</ul>
<hr/>
<p><a id="user-content-what-is-delegation" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-6">什么是子 Agent 派生？</h3>
<p><strong>子 Agent 派生（Sub-Agent Delegation）</strong> 是一种高效的架构模式，旨在通过分而治之的策略处理复杂任务。在此模式中，<strong>主 Agent (Controller)</strong> 扮演指挥官角色，负责解析用户需求并动态生成子任务计划；随后，系统会<strong>采用半动态机制（固定角色模板 + 动态任务内容）来激活对应的子 Agent</strong>，这些 Agent 接收定制化的任务参数后独立执行。这种机制既保证了执行的稳定性（通过预设模板），又兼顾了任务的灵活性（通过动态内容），最后由主 Agent 汇总所有结果。</p>
<h4 data-id="heading-7">核心工作流程</h4>
<pre><code class="hljs language-arduino" lang="arduino">用户复杂请求（如：<span class="hljs-string">"写一篇技术博客"</span>）
    ↓
主 Agent 动态制定委派计划
    ↓
任务分解为专业化子任务
    ├─ Research Agent：研究主题
    ├─ Writing Agent：撰写内容
    └─ QA Agent：质量审核
    ↓
主 Agent 聚合结果生成最终报告
</code></pre>
<h4 data-id="heading-8">一个真实的例子</h4>
<p>假设用户请求："帮我写一篇关于 Python 装饰器的技术博客"</p>
<p><strong>硬编码方式（传统）</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_blog_hardcoded</span>(<span class="hljs-params">topic</span>):
    <span class="hljs-comment"># 固定流程：研究 → 写作 → 审核</span>
    research = research_agent.run(topic)
    article = writing_agent.run(research)
    final = qa_agent.run(article)
    <span class="hljs-keyword">return</span> final
</code></pre>
<p><strong>问题</strong>：</p>
<ul>
<li>❌ 简单任务也走完整流程（浪费资源）</li>
<li>❌ 复杂任务可能流程不够（输出质量差）</li>
<li>❌ 所有任务用相同参数（无法专业化）</li>
</ul>
<p><strong>派生方式（Claude Code）</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 主 Agent 动态决定需要哪些步骤</span>
plan = main_agent.create_plan(user_request)

<span class="hljs-comment"># 可能的计划 1：简单任务</span>
<span class="hljs-comment"># [writing_agent]  # 直接写作，跳过研究</span>

<span class="hljs-comment"># 可能的计划 2：标准任务</span>
<span class="hljs-comment"># [research_agent, writing_agent, qa_agent]</span>

<span class="hljs-comment"># 可能的计划 3：深度任务</span>
<span class="hljs-comment"># [research_agent, analysis_agent, code_examples_agent,</span>
<span class="hljs-comment">#  writing_agent, seo_agent, qa_agent]</span>

results = execute_dynamic_plan(plan)
<span class="hljs-keyword">return</span> aggregate(results)
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>✅ <strong>智能适应</strong>：根据任务复杂度自动调整</li>
<li>✅ <strong>专业化</strong>：每个 Agent 针对性优化（温度、工具、提示词）</li>
<li>✅ <strong>高质量</strong>：复杂任务得到充分处理</li>
<li>✅ <strong>高效率</strong>：简单任务快速响应</li>
</ul>
<hr/>
<p><a id="user-content-why-not-hardcode" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-9">为什么需要派生而非硬编码？</h3>
<p>很多开发者会问："我知道任务需要研究、写作、审核三步，为什么不直接写死流程？"</p>
<h4 data-id="heading-10">硬编码的三大失败场景</h4>
<h5 data-id="heading-11">场景 1：任务复杂度差异巨大</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 硬编码方案</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">write_blog_hardcoded</span>(<span class="hljs-params">topic</span>):
    research = research_agent.execute(topic)  <span class="hljs-comment"># 固定调用</span>
    article = writing_agent.execute(research)
    <span class="hljs-keyword">return</span> qa_agent.execute(article)

<span class="hljs-comment"># ❌ 问题 1：简单任务浪费资源</span>
user_input = <span class="hljs-string">"总结一下 Python 装饰器是什么（50字）"</span>
<span class="hljs-comment"># → 不需要研究，但仍会执行完整流程</span>
<span class="hljs-comment"># → 浪费时间 + token，用户体验差</span>

<span class="hljs-comment"># ❌ 问题 2：复杂任务处理不足</span>
user_input = <span class="hljs-string">"写一篇关于量子计算在密码学应用的综述论文"</span>
<span class="hljs-comment"># → 需要：文献调研 → 理论分析 → 算法研究 → 安全分析 → 撰写 → 学术审核</span>
<span class="hljs-comment"># → 硬编码的 3 步流程根本不够用</span>
</code></pre>
<h5 data-id="heading-12">场景 2：领域专业化需求</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 硬编码：所有任务用同一套 Agent</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_hardcoded</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">return</span> general_agent.analyze(data)  <span class="hljs-comment"># 通用 Agent</span>

<span class="hljs-comment"># ❌ 数据分析：需要统计方法、可视化</span>
<span class="hljs-comment"># ❌ 法律分析：需要法规检索、风险评估</span>
<span class="hljs-comment"># ❌ 代码分析：需要性能分析、算法优化</span>
<span class="hljs-comment"># → 通用 Agent 什么都会一点，但什么都不精通</span>
</code></pre>
<p><strong>动态派生的专业化</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 数据分析请求 → 数据专家团队</span>
plan_data = [data_cleaning_agent, statistical_analysis_agent,
             visualization_agent, insight_generation_agent]

<span class="hljs-comment"># 法律分析请求 → 法律专家团队</span>
plan_legal = [legal_research_agent, risk_identification_agent,
              compliance_check_agent, recommendation_agent]

<span class="hljs-comment"># 每个领域都有专门的 Agent，输出质量远超通用 Agent</span>
</code></pre>
<h5 data-id="heading-13">场景 3：动态依赖变化</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 硬编码：固定的执行顺序</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_marketing</span>(<span class="hljs-params">product</span>):
    research = research_agent.execute(product)      <span class="hljs-comment"># 步骤 1</span>
    analysis = analysis_agent.execute(research)     <span class="hljs-comment"># 步骤 2</span>
    copy = writing_agent.execute(analysis)          <span class="hljs-comment"># 步骤 3</span>
    seo = seo_agent.execute(copy)                  <span class="hljs-comment"># 步骤 4</span>
    <span class="hljs-keyword">return</span> seo

<span class="hljs-comment"># ❌ 用户已经有研究报告怎么办？</span>
<span class="hljs-comment"># → 仍会重复执行研究步骤，浪费资源</span>

<span class="hljs-comment"># ❌ 用户不需要 SEO 优化怎么办？</span>
<span class="hljs-comment"># → 无法跳过，必须执行完整流程</span>
</code></pre>
<p><strong>动态派生的灵活性</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 场景 1：用户提供了研究报告</span>
user_request = <span class="hljs-string">"我已经有了市场研究报告（见附件），请帮我写营销文案"</span>
<span class="hljs-comment"># → 主 Agent 识别后跳过研究，直接从写作开始</span>
plan = [copywriting_agent, seo_agent, review_agent]

<span class="hljs-comment"># 场景 2：用户只要快速文案</span>
user_request = <span class="hljs-string">"快速写一个产品介绍（100字）"</span>
<span class="hljs-comment"># → 主 Agent 识别简单任务，跳过所有分析环节</span>
plan = [quick_writing_agent]

<span class="hljs-comment"># 场景 3：完整营销方案</span>
user_request = <span class="hljs-string">"为新产品制定完整营销策略"</span>
<span class="hljs-comment"># → 主 Agent 生成完整流程</span>
plan = [market_research_agent, competitor_analysis_agent,
        positioning_agent, copywriting_agent, seo_agent,
        social_media_agent, review_agent]
</code></pre>
<h4 data-id="heading-14">核心差异总结</h4>








































<table><thead><tr><th>维度</th><th>硬编码方案 ❌</th><th>动态派生 ✅</th></tr></thead><tbody><tr><td><strong>适应性</strong></td><td>一套流程应对所有场景</td><td>根据任务动态调整</td></tr><tr><td><strong>效率</strong></td><td>简单任务也走完整流程</td><td>简单任务快速响应</td></tr><tr><td><strong>专业性</strong></td><td>通用 Agent 什么都不精</td><td>专门 Agent 输出高质量</td></tr><tr><td><strong>可扩展</strong></td><td>新需求需要修改代码</td><td>无需修改，自动适配</td></tr><tr><td><strong>维护成本</strong></td><td>需求越多，代码越乱</td><td>核心逻辑不变，易维护</td></tr><tr><td><strong>用户体验</strong></td><td>无法个性化响应</td><td>智能理解用户意图</td></tr></tbody></table>
<h4 data-id="heading-15">何时可以硬编码？</h4>
<p>也不是完全不能硬编码，以下场景可以使用：</p>
<p><strong>✅ 适合硬编码的场景</strong>：</p>
<ol>
<li><strong>流程极其固定</strong>：如发票生成（步骤永远不变）</li>
<li><strong>性能要求极高</strong>：如实时推荐系统（毫秒级响应，无法承受动态规划开销）</li>
<li><strong>合规性要求</strong>：如金融交易流程（必须严格按规定顺序）</li>
</ol>
<p><strong>但对于 AI Agent 场景，几乎都不满足以上条件！</strong></p>
<hr/>
<p><a id="user-content-claude-code-implementation" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-16">Claude Code 中的实现方式</h3>
<p>Claude Code 实现了一套完整的子 Agent 派生框架，核心是 <strong>Task Tool</strong>。</p>
<h4 data-id="heading-17">Task Tool 的设计理念</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Task Tool 的核心接口（简化版）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">task_tool</span>(<span class="hljs-params">
    description: <span class="hljs-built_in">str</span>,        <span class="hljs-comment"># 任务描述（3-5 词）</span>
    prompt: <span class="hljs-built_in">str</span>,            <span class="hljs-comment"># 详细任务说明</span>
    subagent_type: <span class="hljs-built_in">str</span>,     <span class="hljs-comment"># Agent 类型</span>
    model: <span class="hljs-built_in">str</span> = <span class="hljs-string">"sonnet"</span>,  <span class="hljs-comment"># 可选模型</span>
    run_in_background: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,  <span class="hljs-comment"># 是否后台运行</span>
    resume: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span>      <span class="hljs-comment"># 恢复之前的 Agent</span>
</span>):
    <span class="hljs-string">"""
    启动一个专门化的子 Agent 来处理特定任务

    核心特点：
    1. 动态派生：根据需求创建专业 Agent
    2. 后台运行：支持并行执行
    3. 可恢复：支持从中断点继续
    4. 隔离执行：失败不影响其他 Agent
    """</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
<h4 data-id="heading-18">可用的 SubAgent Types</h4>
<p>Claude Code 预定义了多种专业化的 Agent 类型：</p>






















































<table><thead><tr><th>SubAgent Type</th><th>专长领域</th><th>温度</th><th>工具</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>general-purpose</strong></td><td>通用任务</td><td>0.5</td><td>All</td><td>复杂多步骤任务</td></tr><tr><td><strong>Explore</strong></td><td>代码探索</td><td>0.3</td><td>Glob, Grep, Read</td><td>代码库搜索、结构分析</td></tr><tr><td><strong>Plan</strong></td><td>方案设计</td><td>0.4</td><td>All</td><td>实现规划、架构设计</td></tr><tr><td><strong>claude-code-guide</strong></td><td>Claude Code 文档</td><td>0.5</td><td>WebFetch, WebSearch</td><td>Claude Code 使用指南</td></tr><tr><td><strong>ollama-code-analyzer</strong></td><td>代码审查</td><td>0.2</td><td>Code analysis</td><td>Bug、性能、安全分析</td></tr><tr><td><strong>ollama-architect</strong></td><td>架构设计</td><td>0.6</td><td>Design tools</td><td>技术选型、方案对比</td></tr></tbody></table>
<h4 data-id="heading-19">一个真实的使用示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 场景：分析代码库并生成优化建议</span>

<span class="hljs-comment"># Step 1: 使用 Explore Agent 探索代码结构</span>
explore_result = task_tool(
    description=<span class="hljs-string">"探索代码库结构"</span>,
    prompt=<span class="hljs-string">"""
    探索这个 Python 项目的代码结构：
    1. 找到所有 Python 文件
    2. 识别主要模块和依赖关系
    3. 标记潜在的性能瓶颈
    """</span>,
    subagent_type=<span class="hljs-string">"Explore"</span>
)

<span class="hljs-comment"># Step 2: 使用 Code Analyzer Agent 深度分析</span>
analyze_result = task_tool(
    description=<span class="hljs-string">"深度代码分析"</span>,
    prompt=<span class="hljs-string">f"""
    基于以下代码结构进行深度分析：
    <span class="hljs-subst">{explore_result}</span>

    请识别：
    1. 性能问题
    2. 安全漏洞
    3. 代码异味
    """</span>,
    subagent_type=<span class="hljs-string">"ollama-code-analyzer"</span>,
    run_in_background=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 后台运行，不阻塞</span>
)

<span class="hljs-comment"># Step 3: 使用 Architect Agent 设计优化方案</span>
plan_result = task_tool(
    description=<span class="hljs-string">"设计优化方案"</span>,
    prompt=<span class="hljs-string">f"""
    基于分析结果设计优化方案：
    <span class="hljs-subst">{analyze_result}</span>

    请提供：
    1. 优化策略
    2. 技术选型
    3. 实施步骤
    """</span>,
    subagent_type=<span class="hljs-string">"ollama-architect"</span>
)
</code></pre>
<hr/>
<p><a id="user-content-task-tool-core" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-20">Task Tool 核心机制</h3>
<p>让我们深入了解 Claude Code Task Tool 的实现原理。</p>
<h4 data-id="heading-21">数据模型设计</h4>
<h5 data-id="heading-22">1. SubTask 模型</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Literal</span>, <span class="hljs-type">Optional</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubTask</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-string">"""
    子任务数据模型

    定义了从复杂用户请求中拆解出来的独立工作单元。
    每个子任务都被分配给特定类型的专家 Agent 执行。
    """</span>
    task_id: <span class="hljs-built_in">str</span>  <span class="hljs-comment"># 任务唯一标识符 (例如: "task_01")</span>
    description: <span class="hljs-built_in">str</span>  <span class="hljs-comment"># 任务的详细执行说明和目标</span>
    agent_type: <span class="hljs-type">Literal</span>[
        <span class="hljs-string">"research"</span>,   <span class="hljs-comment"># 信息调研与收集</span>
        <span class="hljs-string">"analysis"</span>,   <span class="hljs-comment"># 数据分析与处理</span>
        <span class="hljs-string">"writing"</span>,    <span class="hljs-comment"># 内容创作与撰写</span>
        <span class="hljs-string">"coding"</span>,     <span class="hljs-comment"># 代码开发与实现</span>
        <span class="hljs-string">"planning"</span>,   <span class="hljs-comment"># 计划制定与设计</span>
        <span class="hljs-string">"qa"</span>          <span class="hljs-comment"># 质量检查与审核</span>
    ]
    priority: <span class="hljs-built_in">int</span> = Field(ge=<span class="hljs-number">1</span>, le=<span class="hljs-number">5</span>, default=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 优先级（1最低，5最高）</span>
    dependencies: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = Field(default_factory=<span class="hljs-built_in">list</span>)  <span class="hljs-comment"># 前置依赖任务 ID</span>

    <span class="hljs-comment"># 执行配置</span>
    temperature: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 覆盖默认温度</span>
    tools: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span>    <span class="hljs-comment"># 指定可用工具</span>
</code></pre>
<p><strong>设计亮点</strong>：</p>
<ul>
<li>✅ 使用 <code>Literal</code> 限制 agent_type，避免拼写错误</li>
<li>✅ 使用 <code>Field</code> 添加验证规则（优先级 1-5）</li>
<li>✅ 支持温度和工具的细粒度控制</li>
<li>✅ 默认值和工厂函数确保安全性</li>
</ul>
<h5 data-id="heading-23">2. SubAgentResult 模型</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubAgentResult</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-string">"""子 Agent 执行结果"""</span>
    task_id: <span class="hljs-built_in">str</span>                    <span class="hljs-comment"># 对应的任务 ID</span>
    agent_type: <span class="hljs-built_in">str</span>                 <span class="hljs-comment"># 执行的 Agent 类型</span>
    success: <span class="hljs-built_in">bool</span>                   <span class="hljs-comment"># 执行是否成功</span>
    output: <span class="hljs-built_in">str</span>                     <span class="hljs-comment"># 执行结果内容</span>
    error_message: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 错误信息（如果失败）</span>
    execution_time: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>     <span class="hljs-comment"># 执行耗时（秒）</span>
    timestamp: <span class="hljs-built_in">str</span> = Field(
        default_factory=<span class="hljs-keyword">lambda</span>: datetime.now().isoformat()
    )

    <span class="hljs-comment"># 元数据</span>
    model_used: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>     <span class="hljs-comment"># 使用的模型</span>
    tokens_used: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>    <span class="hljs-comment"># 消耗的 tokens</span>
    confidence: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span>   <span class="hljs-comment"># 结果置信度（0-1）</span>
</code></pre>
<h5 data-id="heading-24">3. DelegationPlan 模型</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegationPlan</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-string">"""委派计划"""</span>
    sub_tasks: <span class="hljs-type">List</span>[SubTask]          <span class="hljs-comment"># 子任务列表</span>
    execution_order: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]        <span class="hljs-comment"># 任务 ID 的执行顺序（拓扑排序后）</span>
    rationale: <span class="hljs-built_in">str</span>                    <span class="hljs-comment"># 计划制定的理由</span>

    <span class="hljs-comment"># 执行策略</span>
    parallel_groups: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 可并行执行的任务组</span>
    estimated_time: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span>             <span class="hljs-comment"># 预估总耗时</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_dependencies</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""验证依赖关系是否有效"""</span>
        task_ids = {t.task_id <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.sub_tasks}
        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> self.sub_tasks:
            <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> task.dependencies:
                <span class="hljs-keyword">if</span> dep <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> task_ids:
                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"任务 <span class="hljs-subst">{task.task_id}</span> 依赖的 <span class="hljs-subst">{dep}</span> 不存在"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_circular_dependency</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:
        <span class="hljs-string">"""检测循环依赖"""</span>
        <span class="hljs-comment"># DFS 实现</span>
        visited = <span class="hljs-built_in">set</span>()
        rec_stack = <span class="hljs-built_in">set</span>()

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">has_cycle</span>(<span class="hljs-params">task_id: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
            visited.add(task_id)
            rec_stack.add(task_id)

            task = <span class="hljs-built_in">next</span>(t <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.sub_tasks <span class="hljs-keyword">if</span> t.task_id == task_id)
            <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> task.dependencies:
                <span class="hljs-keyword">if</span> dep <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
                    <span class="hljs-keyword">if</span> has_cycle(dep):
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
                <span class="hljs-keyword">elif</span> dep <span class="hljs-keyword">in</span> rec_stack:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

            rec_stack.remove(task_id)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> self.sub_tasks:
            <span class="hljs-keyword">if</span> task.task_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
                <span class="hljs-keyword">if</span> has_cycle(task.task_id):
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(rec_stack)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>
<h5 data-id="heading-25">4. DelegationState 模型</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegationState</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-string">"""全局状态对象，在工作流的所有节点间传递"""</span>

    <span class="hljs-comment"># 输入</span>
    user_request: <span class="hljs-built_in">str</span>                <span class="hljs-comment"># 用户原始需求（只读）</span>

    <span class="hljs-comment"># 规划阶段</span>
    delegation_plan: <span class="hljs-type">Optional</span>[DelegationPlan] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 委派计划</span>

    <span class="hljs-comment"># 执行阶段</span>
    sub_agent_results: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, SubAgentResult] = Field(
        default_factory=<span class="hljs-built_in">dict</span>
    )  <span class="hljs-comment"># 执行结果（task_id -&gt; result）</span>
    completed_tasks: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = Field(
        default_factory=<span class="hljs-built_in">list</span>
    )  <span class="hljs-comment"># 已完成任务 ID 列表</span>
    failed_tasks: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = Field(
        default_factory=<span class="hljs-built_in">list</span>
    )  <span class="hljs-comment"># 失败任务 ID 列表</span>

    <span class="hljs-comment"># 聚合阶段</span>
    final_report: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 最终整合报告</span>

    <span class="hljs-comment"># 元数据</span>
    workflow_start_time: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
    workflow_end_time: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
    total_tokens_used: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>
</code></pre>
<hr/>
<p><a id="user-content-subagent-types" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-26">6 种 SubAgent Type 详解</h3>
<p>每种 SubAgent 类型都经过专门优化，针对特定领域。</p>
<h4 data-id="heading-27">1. Research Agent - 信息调研专家</h4>
<p><strong>配置</strong>：</p>
<pre><code class="hljs language-python" lang="python">RESEARCH_AGENT_CONFIG = {
    <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.5</span>,  <span class="hljs-comment"># 平衡精确性和多样性</span>
    <span class="hljs-string">"tools"</span>: [<span class="hljs-string">"web_search"</span>, <span class="hljs-string">"arxiv_search"</span>, <span class="hljs-string">"file_read"</span>],
    <span class="hljs-string">"system_prompt"</span>: <span class="hljs-string">"""
你是一位专业的研究员，擅长信息收集和整理。

你的职责：
1. 深入研究给定主题
2. 收集权威来源的信息
3. 整理关键发现
4. 提供引用来源

研究方法：
- 使用 web_search 查找最新信息
- 使用 arxiv_search 查找学术论文
- 使用 file_read 阅读本地文档
- 交叉验证多个来源
- 标注信息的可信度

输出格式：
## 研究主题
[主题描述]

## 关键发现
1. [发现 1]
   - 来源：[URL/文献]
   - 可信度：[高/中/低]

2. [发现 2]
   ...

## 参考资料
- [来源 1]
- [来源 2]
"""</span>
}
</code></pre>
<p><strong>使用场景</strong>：</p>
<ul>
<li>技术调研（"研究 Python 装饰器的最佳实践"）</li>
<li>市场分析（"调研 AI Agent 市场现状"）</li>
<li>文献综述（"总结量子计算最新进展"）</li>
<li>竞品分析（"分析主要 LLM 框架的特点"）</li>
</ul>
<p><strong>实际示例</strong>：</p>
<pre><code class="hljs language-python" lang="python">research_task = SubTask(
    task_id=<span class="hljs-string">"task_research_1"</span>,
    description=<span class="hljs-string">"研究 LangGraph 的核心概念和最佳实践"</span>,
    agent_type=<span class="hljs-string">"research"</span>,
    priority=<span class="hljs-number">5</span>,
    dependencies=[]
)

<span class="hljs-comment"># Research Agent 的输出示例</span>
result = <span class="hljs-string">"""
## 研究主题
LangGraph 的核心概念和最佳实践

## 关键发现
1. **StateGraph 是核心抽象**
   - 来源：https://langchain-ai.github.io/langgraph/
   - 可信度：高（官方文档）
   - StateGraph 通过节点和边定义工作流
   - 每个节点是一个函数，接收和返回状态

2. **状态管理机制**
   - 来源：LangGraph Tutorial
   - 可信度：高
   - 使用 TypedDict 或 Pydantic Model 定义状态
   - 状态在节点间传递，支持增量更新

3. **最佳实践**
   - 来源：社区实践总结
   - 可信度：中
   - 使用 Pydantic Model 获得更好的类型检查
   - 节点函数保持纯函数特性
   - 使用条件边实现动态路由

## 参考资料
- https://langchain-ai.github.io/langgraph/
- https://github.com/langchain-ai/langgraph/examples
"""</span>
</code></pre>
<h4 data-id="heading-28">2. Analysis Agent - 数据分析专家</h4>
<p><strong>配置</strong>：</p>
<pre><code class="hljs language-python" lang="python">ANALYSIS_AGENT_CONFIG = {
    <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.3</span>,  <span class="hljs-comment"># 更低温度，强调精确性</span>
    <span class="hljs-string">"tools"</span>: [<span class="hljs-string">"python_repl"</span>, <span class="hljs-string">"data_visualization"</span>, <span class="hljs-string">"statistical_analysis"</span>],
    <span class="hljs-string">"system_prompt"</span>: <span class="hljs-string">"""
你是一位专业的数据分析师，擅长数据处理和洞察提炼。

你的职责：
1. 分析给定数据或信息
2. 识别模式和趋势
3. 进行统计计算
4. 提供数据支持的洞察

分析方法：
- 使用 python_repl 进行数据处理
- 使用 pandas 处理结构化数据
- 使用 numpy 进行数值计算
- 使用 matplotlib/seaborn 可视化
- 应用统计方法验证假设

输出格式：
## 分析目标
[目标描述]

## 数据概览
- 数据来源：[...]
- 样本量：[N]
- 时间范围：[...]

## 关键指标
1. [指标 1]：[值] (同比 +X%)
2. [指标 2]：[值] (环比 -Y%)

## 深度分析
### [分析维度 1]
[发现和解释]

### [分析维度 2]
[发现和解释]

## 洞察与建议
1. [洞察 1] → [建议 1]
2. [洞察 2] → [建议 2]
"""</span>
}
</code></pre>
<p><strong>使用场景</strong>：</p>
<ul>
<li>用户行为分析（"分析用户留存率下降的原因"）</li>
<li>性能分析（"分析系统性能瓶颈"）</li>
<li>代码分析（"分析代码复杂度和可维护性"）</li>
<li>趋势预测（"预测下季度的增长趋势"）</li>
</ul>
<h4 data-id="heading-29">3. Writing Agent - 内容创作专家</h4>
<p><strong>配置</strong>：</p>
<pre><code class="hljs language-python" lang="python">WRITING_AGENT_CONFIG = {
    <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.7</span>,  <span class="hljs-comment"># 更高温度，强调创造性</span>
    <span class="hljs-string">"tools"</span>: [<span class="hljs-string">"grammar_check"</span>, <span class="hljs-string">"readability_score"</span>, <span class="hljs-string">"style_guide"</span>],
    <span class="hljs-string">"system_prompt"</span>: <span class="hljs-string">"""
你是一位资深作家，擅长内容创作和表达。

你的职责：
1. 撰写高质量的内容
2. 确保逻辑清晰、表达流畅
3. 适配目标受众
4. 保持一致的风格和语气

写作原则：
- 清晰：简洁明了，避免冗余
- 连贯：逻辑流畅，过渡自然
- 准确：事实正确，引用可靠
- 吸引：开头引人，结尾有力
- 适配：符合受众背景和需求

输出格式：
根据内容类型调整格式：
- 技术博客：标题 → 引言 → 正文（多级标题） → 总结
- 技术文档：概述 → 详细说明 → 示例 → 注意事项
- 营销文案：痛点 → 方案 → 优势 → 行动号召
"""</span>
}
</code></pre>
<p><strong>使用场景</strong>：</p>
<ul>
<li>技术博客（"撰写关于 React Hooks 的教程"）</li>
<li>技术文档（"编写 API 使用文档"）</li>
<li>营销文案（"撰写产品介绍"）</li>
<li>报告撰写（"生成季度业务报告"）</li>
</ul>
<h4 data-id="heading-30">4. Coding Agent - 代码开发专家</h4>
<p><strong>配置</strong>：</p>
<pre><code class="hljs language-python" lang="python">CODING_AGENT_CONFIG = {
    <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.2</span>,  <span class="hljs-comment"># 极低温度，确保代码准确</span>
    <span class="hljs-string">"tools"</span>: [<span class="hljs-string">"code_executor"</span>, <span class="hljs-string">"linter"</span>, <span class="hljs-string">"formatter"</span>, <span class="hljs-string">"test_runner"</span>],
    <span class="hljs-string">"system_prompt"</span>: <span class="hljs-string">"""
你是一位高级软件工程师，擅长编写高质量代码。

你的职责：
1. 实现给定的功能需求
2. 编写清晰、可维护的代码
3. 遵循最佳实践和编码规范
4. 编写必要的注释和文档

编码原则：
- DRY (Don't Repeat Yourself)
- SOLID 原则
- 清晰命名
- 适当注释
- 错误处理
- 性能考虑
- 安全意识

输出格式：
## 功能说明
[功能描述]

## 代码实现
```python
[代码]
</span></code></pre>
<h3 data-id="heading-31">使用示例</h3>
<pre><code class="hljs language-python" lang="python">[示例代码]
</code></pre>
<h3 data-id="heading-32">注意事项</h3>
<ul>
<li>[注意点 1]</li>
<li>[注意点 2]
"""
}</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">
**使用场景**：
- 功能实现（"实现用户登录功能"）
- Bug 修复（"修复内存泄漏问题"）
- 代码重构（"重构这段代码提升可读性"）
- 脚本编写（"编写数据迁移脚本"）

<span class="hljs-comment">### 5. Planning Agent - 计划制定专家</span>

**配置**：
```python
<span class="hljs-attr">PLANNING_AGENT_CONFIG</span> = {
    "temperature": 0.4,  <span class="hljs-comment"># 平衡创造性和结构性</span>
    "tools": <span class="hljs-section">["diagram_generator", "timeline_creator"]</span>,
    "system_prompt": """
你是一位项目规划专家，擅长任务分解和计划制定。

你的职责：
1. 分析复杂需求
2. 分解为可执行的子任务
3. 识别任务间的依赖关系
4. 制定合理的执行计划

规划原则：
- MECE 原则（相互独立，完全穷尽）
- 由粗到细，逐步细化
- 明确依赖关系
- 考虑风险因素
- 预留缓冲时间

输出格式：
<span class="hljs-comment">## 需求分析</span>
<span class="hljs-section">[需求概述]</span>

<span class="hljs-comment">## 任务分解</span>
1. <span class="hljs-section">[任务 1]</span>
   - 目标：<span class="hljs-section">[...]</span>
   - 产出：<span class="hljs-section">[...]</span>
   - 依赖：<span class="hljs-section">[...]</span>

2. <span class="hljs-section">[任务 2]</span>
   ...

<span class="hljs-comment">## 执行计划</span>
阶段 1：<span class="hljs-section">[名称]</span>
├─ 任务 A
├─ 任务 B
└─ 任务 C

阶段 2：<span class="hljs-section">[名称]</span>
...

<span class="hljs-comment">## 风险评估</span>
- <span class="hljs-section">[风险 1]</span> → <span class="hljs-section">[应对措施]</span>
- <span class="hljs-section">[风险 2]</span> → <span class="hljs-section">[应对措施]</span>
"""
}
</code></pre>
<p><strong>使用场景</strong>：</p>
<ul>
<li>项目规划（"规划新功能的开发计划"）</li>
<li>学习计划（"制定 Python 学习路线"）</li>
<li>迁移计划（"规划系统架构迁移步骤"）</li>
<li>优化计划（"制定性能优化方案"）</li>
</ul>
<h4 data-id="heading-33">6. QA Agent - 质量审核专家</h4>
<p><strong>配置</strong>：</p>
<pre><code class="hljs language-python" lang="python">QA_AGENT_CONFIG = {
    <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.3</span>,  <span class="hljs-comment"># 低温度，确保严格审核</span>
    <span class="hljs-string">"tools"</span>: [<span class="hljs-string">"grammar_check"</span>, <span class="hljs-string">"fact_check"</span>, <span class="hljs-string">"plagiarism_check"</span>, <span class="hljs-string">"code_review"</span>],
    <span class="hljs-string">"system_prompt"</span>: <span class="hljs-string">"""
你是一位质量审核专家，擅长发现问题和提出改进建议。

你的职责：
1. 审核内容质量
2. 识别错误和问题
3. 评估符合度
4. 提供改进建议

审核维度：
- 准确性：事实是否正确
- 完整性：是否遗漏重要内容
- 一致性：风格和术语是否统一
- 可读性：是否清晰易懂
- 合规性：是否符合要求

输出格式：
## 审核摘要
- 审核对象：[...]
- 审核标准：[...]
- 总体评分：[X/10]

## 发现的问题
### 严重问题（Must Fix）
1. [问题描述]
   - 位置：[...]
   - 影响：[...]
   - 建议：[...]

### 一般问题（Should Fix）
...

### 优化建议（Nice to Have）
...

## 修改后的版本
[修改后的完整内容]
"""</span>
}
</code></pre>
<p><strong>使用场景</strong>：</p>
<ul>
<li>内容审核（"审核技术博客的质量"）</li>
<li>代码审查（"审查代码的安全性和性能"）</li>
<li>文档审核（"审核 API 文档的完整性"）</li>
<li>合规检查（"检查内容是否符合规范"）</li>
</ul>
<hr/>
<h4 data-id="heading-34">Agent 配置对比表</h4>






















































<table><thead><tr><th>Agent 类型</th><th>温度</th><th>主要工具</th><th>输出特点</th><th>典型耗时</th></tr></thead><tbody><tr><td><strong>Research</strong></td><td>0.5</td><td>web_search, arxiv</td><td>信息丰富，来源可靠</td><td>20-40s</td></tr><tr><td><strong>Analysis</strong></td><td>0.3</td><td>python_repl, visualization</td><td>数据驱动，洞察深刻</td><td>15-30s</td></tr><tr><td><strong>Writing</strong></td><td>0.7</td><td>grammar_check, style_guide</td><td>流畅易读，结构清晰</td><td>10-25s</td></tr><tr><td><strong>Coding</strong></td><td>0.2</td><td>code_executor, linter</td><td>准确可靠，规范标准</td><td>15-35s</td></tr><tr><td><strong>Planning</strong></td><td>0.4</td><td>diagram_generator</td><td>结构完整，逻辑清晰</td><td>10-20s</td></tr><tr><td><strong>QA</strong></td><td>0.3</td><td>fact_check, plagiarism</td><td>严格细致，建议具体</td><td>10-20s</td></tr></tbody></table>
<p><strong>温度设置的原理</strong>：</p>
<ul>
<li><strong>低温度（0.2-0.3）</strong>：输出更确定、更一致，适合代码、分析、审核</li>
<li><strong>中温度（0.4-0.5）</strong>：平衡创造性和准确性，适合研究、规划</li>
<li><strong>高温度（0.6-0.7）</strong>：输出更多样、更创造性，适合写作、头脑风暴</li>
</ul>
<hr/>
<p><a id="user-content-state-management" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-35">状态管理与上下文传递</h3>
<p>子 Agent 派生系统通过 <code>DelegationState</code> 对象管理全局状态。</p>
<h4 data-id="heading-36">状态演进时间线</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># t0: 初始化</span>
state = DelegationState(
    user_request=<span class="hljs-string">"写一篇关于 Python 装饰器的技术博客"</span>,
    delegation_plan=<span class="hljs-literal">None</span>,
    sub_agent_results={},
    completed_tasks=[],
    final_report=<span class="hljs-literal">None</span>
)

<span class="hljs-comment"># t1: 规划阶段完成</span>
state.delegation_plan = DelegationPlan(
    sub_tasks=[
        SubTask(task_id=<span class="hljs-string">"task_1"</span>, agent_type=<span class="hljs-string">"research"</span>, ...),
        SubTask(task_id=<span class="hljs-string">"task_2"</span>, agent_type=<span class="hljs-string">"writing"</span>, ...),
        SubTask(task_id=<span class="hljs-string">"task_3"</span>, agent_type=<span class="hljs-string">"qa"</span>, ...)
    ],
    execution_order=[<span class="hljs-string">"task_1"</span>, <span class="hljs-string">"task_2"</span>, <span class="hljs-string">"task_3"</span>],
    rationale=<span class="hljs-string">"先研究收集信息，再基于研究结果撰写内容，最后进行质量审核"</span>
)

<span class="hljs-comment"># t2: 第一个子任务完成</span>
state.sub_agent_results[<span class="hljs-string">"task_1"</span>] = SubAgentResult(
    task_id=<span class="hljs-string">"task_1"</span>,
    agent_type=<span class="hljs-string">"research"</span>,
    success=<span class="hljs-literal">True</span>,
    output=<span class="hljs-string">"[研究结果：装饰器的原理、用法、最佳实践...]"</span>,
    execution_time=<span class="hljs-number">25.3</span>
)
state.completed_tasks = [<span class="hljs-string">"task_1"</span>]

<span class="hljs-comment"># t3: 第二个子任务完成</span>
state.sub_agent_results[<span class="hljs-string">"task_2"</span>] = SubAgentResult(
    task_id=<span class="hljs-string">"task_2"</span>,
    agent_type=<span class="hljs-string">"writing"</span>,
    success=<span class="hljs-literal">True</span>,
    output=<span class="hljs-string">"[文章内容：# Python 装饰器完全指南\n\n...]"</span>,
    execution_time=<span class="hljs-number">18.7</span>
)
state.completed_tasks = [<span class="hljs-string">"task_1"</span>, <span class="hljs-string">"task_2"</span>]

<span class="hljs-comment"># t4: 第三个子任务完成</span>
state.sub_agent_results[<span class="hljs-string">"task_3"</span>] = SubAgentResult(
    task_id=<span class="hljs-string">"task_3"</span>,
    agent_type=<span class="hljs-string">"qa"</span>,
    success=<span class="hljs-literal">True</span>,
    output=<span class="hljs-string">"[审核结果：发现 2 处问题，已修正...]"</span>,
    execution_time=<span class="hljs-number">12.5</span>
)
state.completed_tasks = [<span class="hljs-string">"task_1"</span>, <span class="hljs-string">"task_2"</span>, <span class="hljs-string">"task_3"</span>]

<span class="hljs-comment"># t5: 聚合阶段完成</span>
state.final_report = <span class="hljs-string">"""
# Python 装饰器完全指南

[整合了研究、写作、审核的最终高质量内容...]
"""</span>
</code></pre>
<h4 data-id="heading-37">上下文传递机制</h4>
<h5 data-id="heading-38">方式 1：通过状态对象传递</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_sub_agents_node</span>(<span class="hljs-params">state: DelegationState</span>) -&gt; DelegationState:
    <span class="hljs-string">"""执行子 Agent 节点"""</span>

    <span class="hljs-keyword">for</span> task_id <span class="hljs-keyword">in</span> state.delegation_plan.execution_order:
        task = find_task_by_id(task_id, state.delegation_plan.sub_tasks)

        <span class="hljs-comment"># 构建上下文：包含前置任务的结果</span>
        context = {
            <span class="hljs-string">"user_request"</span>: state.user_request,
            <span class="hljs-string">"previous_results"</span>: {}
        }

        <span class="hljs-comment"># 添加依赖任务的结果</span>
        <span class="hljs-keyword">for</span> dep_id <span class="hljs-keyword">in</span> task.dependencies:
            dep_result = state.sub_agent_results.get(dep_id)
            <span class="hljs-keyword">if</span> dep_result <span class="hljs-keyword">and</span> dep_result.success:
                context[<span class="hljs-string">"previous_results"</span>][dep_id] = dep_result.output

        <span class="hljs-comment"># 执行任务，传入上下文</span>
        agent = get_agent(task.agent_type)
        result = agent.execute(task, context)

        <span class="hljs-comment"># 更新状态</span>
        state.sub_agent_results[task_id] = result
        <span class="hljs-keyword">if</span> result.success:
            state.completed_tasks.append(task_id)

    <span class="hljs-keyword">return</span> state
</code></pre>
<h5 data-id="heading-39">方式 2：在提示词中嵌入上下文</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WritingAgent</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; SubAgentResult:
        <span class="hljs-comment"># 提取前置任务的结果</span>
        research_result = context[<span class="hljs-string">"previous_results"</span>].get(<span class="hljs-string">"task_research_1"</span>, <span class="hljs-string">""</span>)

        <span class="hljs-comment"># 构建提示词，包含上下文</span>
        prompt = <span class="hljs-string">f"""
你是一位资深技术作家。

用户需求：
<span class="hljs-subst">{context[<span class="hljs-string">"user_request"</span>]}</span>

当前任务：
<span class="hljs-subst">{task.description}</span>

研究成果（来自 Research Agent）：
<span class="hljs-subst">{research_result}</span>

请基于以上研究成果，撰写一篇高质量的技术博客文章。

要求：
1. 结构清晰，逻辑流畅
2. 包含代码示例
3. 适合中级开发者阅读
4. 长度 2000-3000 字
"""</span>

        response = self.llm.invoke([HumanMessage(content=prompt)])

        <span class="hljs-keyword">return</span> SubAgentResult(
            task_id=task.task_id,
            agent_type=<span class="hljs-string">"writing"</span>,
            success=<span class="hljs-literal">True</span>,
            output=response.content.strip()
        )
</code></pre>
<hr/>
<p><a id="user-content-dependency-resolution" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-40">依赖解析与执行顺序</h3>
<p>子 Agent 派生系统使用 <strong>拓扑排序</strong> 算法自动计算任务的执行顺序。</p>
<h4 data-id="heading-41">依赖解析引擎</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict, deque
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyEngine</span>:
    <span class="hljs-string">"""依赖解析引擎"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">resolve_execution_order</span>(<span class="hljs-params">
        self,
        tasks: <span class="hljs-type">List</span>[SubTask]
    </span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:
        <span class="hljs-string">"""
        基于任务依赖关系计算执行顺序
        使用拓扑排序算法（Kahn's Algorithm）

        算法步骤：
        1. 构建依赖图和入度表
        2. 找到所有入度为 0 的任务（无依赖）
        3. 依次处理这些任务，更新依赖它们的任务的入度
        4. 重复直到所有任务都被处理

        Returns:
            List[str]: 任务 ID 的执行顺序

        Raises:
            ValueError: 如果检测到循环依赖
        """</span>
        <span class="hljs-comment"># 构建依赖图</span>
        graph = defaultdict(<span class="hljs-built_in">list</span>)  <span class="hljs-comment"># task_id -&gt; [dependent_task_ids]</span>
        in_degree = defaultdict(<span class="hljs-built_in">int</span>)  <span class="hljs-comment"># task_id -&gt; 入度（依赖数量）</span>

        <span class="hljs-comment"># 初始化</span>
        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:
            <span class="hljs-keyword">if</span> task.task_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> in_degree:
                in_degree[task.task_id] = <span class="hljs-number">0</span>

            in_degree[task.task_id] += <span class="hljs-built_in">len</span>(task.dependencies)

            <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> task.dependencies:
                graph[dep].append(task.task_id)

        <span class="hljs-comment"># 拓扑排序</span>
        queue = deque([
            task.task_id
            <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks
            <span class="hljs-keyword">if</span> in_degree[task.task_id] == <span class="hljs-number">0</span>
        ])
        execution_order = []

        <span class="hljs-keyword">while</span> queue:
            current = queue.popleft()
            execution_order.append(current)

            <span class="hljs-comment"># 更新依赖当前任务的所有任务</span>
            <span class="hljs-keyword">for</span> next_task <span class="hljs-keyword">in</span> graph[current]:
                in_degree[next_task] -= <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> in_degree[next_task] == <span class="hljs-number">0</span>:
                    queue.append(next_task)

        <span class="hljs-comment"># 检测循环依赖</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(execution_order) != <span class="hljs-built_in">len</span>(tasks):
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"检测到循环依赖，无法执行"</span>)

        <span class="hljs-keyword">return</span> execution_order

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_parallel_groups</span>(<span class="hljs-params">
        self,
        tasks: <span class="hljs-type">List</span>[SubTask]
    </span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:
        <span class="hljs-string">"""
        分析哪些任务可以并行执行

        算法：
        1. 按执行顺序分组
        2. 同一组内的任务可以并行

        Returns:
            List[List[str]]: 任务组列表，每组内的任务可并行
        """</span>
        execution_order = self.resolve_execution_order(tasks)
        task_map = {t.task_id: t <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tasks}

        groups = []
        processed = <span class="hljs-built_in">set</span>()

        <span class="hljs-keyword">for</span> task_id <span class="hljs-keyword">in</span> execution_order:
            <span class="hljs-keyword">if</span> task_id <span class="hljs-keyword">in</span> processed:
                <span class="hljs-keyword">continue</span>

            <span class="hljs-comment"># 找到所有依赖已满足且未处理的任务</span>
            current_group = []
            <span class="hljs-keyword">for</span> tid <span class="hljs-keyword">in</span> execution_order:
                <span class="hljs-keyword">if</span> tid <span class="hljs-keyword">in</span> processed:
                    <span class="hljs-keyword">continue</span>

                task = task_map[tid]
                <span class="hljs-comment"># 检查依赖是否都已完成</span>
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(dep <span class="hljs-keyword">in</span> processed <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> task.dependencies):
                    current_group.append(tid)

            <span class="hljs-keyword">if</span> current_group:
                groups.append(current_group)
                processed.update(current_group)

        <span class="hljs-keyword">return</span> groups
</code></pre>
<h4 data-id="heading-42">依赖解析示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 定义任务</span>
tasks = [
    SubTask(
        task_id=<span class="hljs-string">"task_1"</span>,
        description=<span class="hljs-string">"研究 Python 装饰器的基本概念"</span>,
        agent_type=<span class="hljs-string">"research"</span>,
        dependencies=[]  <span class="hljs-comment"># 无依赖</span>
    ),
    SubTask(
        task_id=<span class="hljs-string">"task_2"</span>,
        description=<span class="hljs-string">"分析装饰器的高级用法"</span>,
        agent_type=<span class="hljs-string">"analysis"</span>,
        dependencies=[<span class="hljs-string">"task_1"</span>]  <span class="hljs-comment"># 依赖 task_1</span>
    ),
    SubTask(
        task_id=<span class="hljs-string">"task_3"</span>,
        description=<span class="hljs-string">"编写装饰器的代码示例"</span>,
        agent_type=<span class="hljs-string">"coding"</span>,
        dependencies=[<span class="hljs-string">"task_1"</span>]  <span class="hljs-comment"># 依赖 task_1</span>
    ),
    SubTask(
        task_id=<span class="hljs-string">"task_4"</span>,
        description=<span class="hljs-string">"撰写技术博客"</span>,
        agent_type=<span class="hljs-string">"writing"</span>,
        dependencies=[<span class="hljs-string">"task_2"</span>, <span class="hljs-string">"task_3"</span>]  <span class="hljs-comment"># 依赖 task_2 和 task_3</span>
    ),
    SubTask(
        task_id=<span class="hljs-string">"task_5"</span>,
        description=<span class="hljs-string">"质量审核"</span>,
        agent_type=<span class="hljs-string">"qa"</span>,
        dependencies=[<span class="hljs-string">"task_4"</span>]  <span class="hljs-comment"># 依赖 task_4</span>
    )
]

<span class="hljs-comment"># 解析执行顺序</span>
engine = DependencyEngine()
execution_order = engine.resolve(tasks)
<span class="hljs-comment"># 结果: ["task_1", "task_2", "task_3", "task_4", "task_5"]</span>

<span class="hljs-comment"># 分析并行组</span>
parallel_groups = engine.analyze_parallel_groups(tasks)
<span class="hljs-comment"># 结果: [</span>
<span class="hljs-comment">#     ["task_1"],           # 第一批：无依赖</span>
<span class="hljs-comment">#     ["task_2", "task_3"], # 第二批：依赖 task_1，可并行</span>
<span class="hljs-comment">#     ["task_4"],           # 第三批：依赖 task_2 和 task_3</span>
<span class="hljs-comment">#     ["task_5"]            # 第四批：依赖 task_4</span>
<span class="hljs-comment"># ]</span>
</code></pre>
<h4 data-id="heading-43">可视化依赖关系</h4>
<pre><code class="hljs language-erlang" lang="erlang"><span class="hljs-function"><span class="hljs-title">task_1</span> <span class="hljs-params">(research)</span> ──────┐
   │                     │
   ├─→ <span class="hljs-title">task_2</span> <span class="hljs-params">(analysis)</span> ┤
   │                     ├─→ <span class="hljs-title">task_4</span> <span class="hljs-params">(writing)</span> ──→ <span class="hljs-title">task_5</span> <span class="hljs-params">(qa)</span>
   └─→ <span class="hljs-title">task_3</span> <span class="hljs-params">(coding)</span> ──┘

执行策略：
批次 1: <span class="hljs-title">task_1</span>              <span class="hljs-params">(<span class="hljs-number">1</span> 个任务)</span>
批次 2: <span class="hljs-title">task_2</span>, <span class="hljs-title">task_3</span>      <span class="hljs-params">(<span class="hljs-number">2</span> 个任务并行)</span>
批次 3: <span class="hljs-title">task_4</span>              <span class="hljs-params">(<span class="hljs-number">1</span> 个任务)</span>
批次 4: <span class="hljs-title">task_5</span>              <span class="hljs-params">(<span class="hljs-number">1</span> 个任务)</span>

总耗时（串行）: T1 + T2 + T3 + T4 + T5
总耗时（并行）: T1 + <span class="hljs-title">max</span><span class="hljs-params">(T2, T3)</span> + T4 + T5
加速比: ~1.5<span class="hljs-title">x</span> <span class="hljs-params">(假设 T2 ≈ T3)</span>
</span></code></pre>
<h4 data-id="heading-44">循环依赖检测</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 错误示例：循环依赖</span>
bad_tasks = [
    SubTask(task_id=<span class="hljs-string">"A"</span>, agent_type=<span class="hljs-string">"research"</span>, dependencies=[<span class="hljs-string">"B"</span>]),
    SubTask(task_id=<span class="hljs-string">"B"</span>, agent_type=<span class="hljs-string">"analysis"</span>, dependencies=[<span class="hljs-string">"C"</span>]),
    SubTask(task_id=<span class="hljs-string">"C"</span>, agent_type=<span class="hljs-string">"writing"</span>, dependencies=[<span class="hljs-string">"A"</span>])  <span class="hljs-comment"># 循环！</span>
]

<span class="hljs-keyword">try</span>:
    engine.resolve_execution_order(bad_tasks)
<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误: <span class="hljs-subst">{e}</span>"</span>)
    <span class="hljs-comment"># 输出: "错误: 检测到循环依赖，无法执行"</span>
</code></pre>
<hr/>
<p><a id="user-content-code-implementation" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h2 data-id="heading-45">第三部分：代码实现 💻</h2>
<p>现在让我们动手实现一个完整的子 Agent 派生系统。</p>
<p><a id="user-content-setup" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-46">环境准备</h3>
<h4 data-id="heading-47">安装依赖</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建虚拟环境</span>
python -m venv venv
<span class="hljs-built_in">source</span> venv/bin/activate  <span class="hljs-comment"># Windows: venv\Scripts\activate</span>

<span class="hljs-comment"># 安装核心依赖</span>
pip install langchain-core langchain-openai langchain-ollama
pip install langgraph pydantic python-dotenv
</code></pre>
<h4 data-id="heading-48">配置环境变量</h4>
<p>创建 <code>.env</code> 文件：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用 OpenAI</span>
LLM_PROVIDER=openai
OPENAI_API_KEY=your_api_key_here
OPENAI_MODEL=gpt-4o-mini

<span class="hljs-comment"># 或使用 Ollama（本地）</span>
<span class="hljs-comment"># LLM_PROVIDER=ollama</span>
<span class="hljs-comment"># OLLAMA_MODEL=llama3.1:8b</span>
<span class="hljs-comment"># OLLAMA_BASE_URL=http://localhost:11434</span>
</code></pre>
<h4 data-id="heading-49">LLM 初始化工具函数</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># utils/llm_helper.py</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> langchain_ollama <span class="hljs-keyword">import</span> ChatOllama
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_llm</span>(<span class="hljs-params">temperature: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.3</span></span>):
    <span class="hljs-string">"""
    获取 LLM 实例（支持 OpenAI 和 Ollama）

    Args:
        temperature: 温度参数（0-1）

    Returns:
        LLM 实例
    """</span>
    load_dotenv()
    provider = os.getenv(<span class="hljs-string">"LLM_PROVIDER"</span>, <span class="hljs-string">""</span>).lower()

    <span class="hljs-keyword">if</span> provider == <span class="hljs-string">"ollama"</span>:
        <span class="hljs-keyword">return</span> ChatOllama(
            model=os.getenv(<span class="hljs-string">"OLLAMA_MODEL"</span>, <span class="hljs-string">"llama3.1:8b"</span>),
            base_url=os.getenv(<span class="hljs-string">"OLLAMA_BASE_URL"</span>, <span class="hljs-string">"http://localhost:11434"</span>),
            temperature=temperature
        )
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> ChatOpenAI(
            model=os.getenv(<span class="hljs-string">"OPENAI_MODEL"</span>, <span class="hljs-string">"gpt-4o-mini"</span>),
            api_key=os.getenv(<span class="hljs-string">"OPENAI_API_KEY"</span>),
            temperature=temperature
        )
</code></pre>
<hr/>
<p><a id="user-content-subagent-implementation" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-50">SubAgent 实现</h3>
<h4 data-id="heading-51">基础 SubAgent 类</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># agents/base_agent.py</span>
<span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span>, <span class="hljs-type">Optional</span>
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel
<span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> HumanMessage, SystemMessage
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubAgent</span>(<span class="hljs-title class_ inherited__">ABC</span>):
    <span class="hljs-string">"""SubAgent 基类"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, agent_type: <span class="hljs-built_in">str</span>, temperature: <span class="hljs-built_in">float</span>, system_prompt: <span class="hljs-built_in">str</span></span>):
        self.agent_type = agent_type
        self.temperature = temperature
        self.system_prompt = system_prompt
        self.llm = get_llm(temperature)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; SubAgentResult:
        <span class="hljs-string">"""
        执行任务的标准化方法

        Args:
            task: 子任务对象
            context: 上下文信息（包含前置任务结果）

        Returns:
            SubAgentResult: 执行结果
        """</span>
        start_time = time.time()

        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># 构建提示词</span>
            prompt = self._build_prompt(task, context)

            <span class="hljs-comment"># 调用 LLM</span>
            messages = [
                SystemMessage(content=self.system_prompt),
                HumanMessage(content=prompt)
            ]
            response = self.llm.invoke(messages)

            <span class="hljs-comment"># 计算耗时</span>
            execution_time = time.time() - start_time

            <span class="hljs-keyword">return</span> SubAgentResult(
                task_id=task.task_id,
                agent_type=self.agent_type,
                success=<span class="hljs-literal">True</span>,
                output=response.content.strip(),
                execution_time=execution_time,
                model_used=self.llm.model_name <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self.llm, <span class="hljs-string">'model_name'</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">"unknown"</span>
            )

        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            execution_time = time.time() - start_time
            <span class="hljs-keyword">return</span> SubAgentResult(
                task_id=task.task_id,
                agent_type=self.agent_type,
                success=<span class="hljs-literal">False</span>,
                output=<span class="hljs-string">""</span>,
                error_message=<span class="hljs-built_in">str</span>(e),
                execution_time=execution_time
            )

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_prompt</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""构建针对性的提示词（子类实现）"""</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
<h4 data-id="heading-52">6 种具体 Agent 实现</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># agents/research_agent.py</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ResearchAgent</span>(<span class="hljs-title class_ inherited__">SubAgent</span>):
    <span class="hljs-string">"""研究型 Agent"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__(
            agent_type=<span class="hljs-string">"research"</span>,
            temperature=<span class="hljs-number">0.5</span>,
            system_prompt=<span class="hljs-string">"""你是一位专业的研究员，擅长信息收集和整理。

你的职责：
1. 深入研究给定主题
2. 收集权威来源的信息
3. 整理关键发现
4. 提供引用来源

输出格式：
## 研究主题
[主题描述]

## 关键发现
1. [发现 1]
   - 来源：[URL/文献]
   - 可信度：[高/中/低]

## 参考资料
- [来源 1]
"""</span>
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_prompt</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        prompt = <span class="hljs-string">f"""
用户需求：<span class="hljs-subst">{context[<span class="hljs-string">'user_request'</span>]}</span>

当前任务：<span class="hljs-subst">{task.description}</span>

请进行深入研究，提供详细、可靠的信息。
"""</span>
        <span class="hljs-keyword">return</span> prompt


<span class="hljs-comment"># agents/analysis_agent.py</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnalysisAgent</span>(<span class="hljs-title class_ inherited__">SubAgent</span>):
    <span class="hljs-string">"""分析型 Agent"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__(
            agent_type=<span class="hljs-string">"analysis"</span>,
            temperature=<span class="hljs-number">0.3</span>,
            system_prompt=<span class="hljs-string">"""你是一位专业的数据分析师，擅长数据处理和洞察提炼。

输出格式：
## 分析目标
[目标描述]

## 关键指标
1. [指标 1]：[值]

## 深度分析
[分析内容]

## 洞察与建议
1. [洞察] → [建议]
"""</span>
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_prompt</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-comment"># 获取前置任务结果</span>
        previous_results = context.get(<span class="hljs-string">"previous_results"</span>, {})
        context_text = <span class="hljs-string">"\n\n"</span>.join([
            <span class="hljs-string">f"## <span class="hljs-subst">{task_id}</span> 的结果：\n<span class="hljs-subst">{result}</span>"</span>
            <span class="hljs-keyword">for</span> task_id, result <span class="hljs-keyword">in</span> previous_results.items()
        ])

        prompt = <span class="hljs-string">f"""
用户需求：<span class="hljs-subst">{context[<span class="hljs-string">'user_request'</span>]}</span>

当前任务：<span class="hljs-subst">{task.description}</span>

前置信息：
<span class="hljs-subst">{context_text}</span>

请基于以上信息进行深度分析。
"""</span>
        <span class="hljs-keyword">return</span> prompt


<span class="hljs-comment"># agents/writing_agent.py</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WritingAgent</span>(<span class="hljs-title class_ inherited__">SubAgent</span>):
    <span class="hljs-string">"""写作型 Agent"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__(
            agent_type=<span class="hljs-string">"writing"</span>,
            temperature=<span class="hljs-number">0.7</span>,
            system_prompt=<span class="hljs-string">"""你是一位资深作家，擅长内容创作和表达。

写作原则：
- 清晰：简洁明了，避免冗余
- 连贯：逻辑流畅，过渡自然
- 准确：事实正确，引用可靠
- 吸引：开头引人，结尾有力

输出格式：
# [标题]

## [章节 1]
[内容]

## [章节 2]
[内容]
"""</span>
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_prompt</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        previous_results = context.get(<span class="hljs-string">"previous_results"</span>, {})
        context_text = <span class="hljs-string">"\n\n"</span>.join([
            <span class="hljs-string">f"## 参考材料 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>：\n<span class="hljs-subst">{result}</span>"</span>
            <span class="hljs-keyword">for</span> i, (task_id, result) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(previous_results.items())
        ])

        prompt = <span class="hljs-string">f"""
用户需求：<span class="hljs-subst">{context[<span class="hljs-string">'user_request'</span>]}</span>

当前任务：<span class="hljs-subst">{task.description}</span>

参考材料：
<span class="hljs-subst">{context_text}</span>

请基于以上材料，撰写高质量的内容。
"""</span>
        <span class="hljs-keyword">return</span> prompt


<span class="hljs-comment"># agents/coding_agent.py</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CodingAgent</span>(<span class="hljs-title class_ inherited__">SubAgent</span>):
    <span class="hljs-string">"""编码型 Agent"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__(
            agent_type=<span class="hljs-string">"coding"</span>,
            temperature=<span class="hljs-number">0.2</span>,
            system_prompt=<span class="hljs-string">"""你是一位高级软件工程师，擅长编写高质量代码。

编码原则：
- DRY (Don't Repeat Yourself)
- SOLID 原则
- 清晰命名
- 适当注释
- 错误处理

输出格式：
## 功能说明
[功能描述]

## 代码实现
```python
[代码]
</span></code></pre>
<h3 data-id="heading-53">使用示例</h3>
<pre><code class="hljs language-python" lang="python">[示例]
</code></pre>
<p>"""
)</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_prompt</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    previous_results = context.get(<span class="hljs-string">"previous_results"</span>, {})
    context_text = <span class="hljs-string">"\n\n"</span>.join([
        <span class="hljs-string">f"## <span class="hljs-subst">{task_id}</span> 的输出：\n<span class="hljs-subst">{result}</span>"</span>
        <span class="hljs-keyword">for</span> task_id, result <span class="hljs-keyword">in</span> previous_results.items()
    ])

    prompt = <span class="hljs-string">f"""
</span></code></pre>
<p>用户需求：{context['user_request']}</p>
<p>当前任务：{task.description}</p>
<p>相关信息：
{context_text}</p>
<p>请实现高质量的代码。
"""
return prompt</p>
<h2 data-id="heading-54">agents/planning_agent.py</h2>
<p>class PlanningAgent(SubAgent):
"""规划型 Agent"""</p>
<pre><code class="hljs language-ini" lang="ini">def __init__(self):
    super().__init__(
        <span class="hljs-attr">agent_type</span>=<span class="hljs-string">"planning"</span>,
        <span class="hljs-attr">temperature</span>=<span class="hljs-number">0.4</span>,
        <span class="hljs-attr">system_prompt</span>=<span class="hljs-string">"""你是一位项目规划专家，擅长任务分解和计划制定。
</span></code></pre>
<p>规划原则：</p>
<ul>
<li>MECE 原则（相互独立，完全穷尽）</li>
<li>由粗到细，逐步细化</li>
<li>明确依赖关系</li>
</ul>
<p>输出格式：</p>
<h3 data-id="heading-55">需求分析</h3>
<p>[需求概述]</p>
<h3 data-id="heading-56">任务分解</h3>
<ol>
<li>[任务 1]
<ul>
<li>目标：[...]</li>
<li>依赖：[...]</li>
</ul>
</li>
</ol>
<h3 data-id="heading-57">执行计划</h3>
<p>[计划详情]
"""
)</p>
<pre><code class="hljs language-php" lang="php">def <span class="hljs-title function_ invoke__">_build_prompt</span>(<span class="hljs-built_in">self</span>, <span class="hljs-attr">task</span>: SubTask, <span class="hljs-attr">context</span>: Dict) -&gt; str:
    prompt = f<span class="hljs-string">""</span><span class="hljs-string">"
</span></code></pre>
<p>用户需求：{context['user_request']}</p>
<p>当前任务：{task.description}</p>
<p>请制定详细的执行计划。
"""
return prompt</p>
<h2 data-id="heading-58">agents/qa_agent.py</h2>
<p>class QAAgent(SubAgent):
"""质量审核 Agent"""</p>
<pre><code class="hljs language-ini" lang="ini">def __init__(self):
    super().__init__(
        <span class="hljs-attr">agent_type</span>=<span class="hljs-string">"qa"</span>,
        <span class="hljs-attr">temperature</span>=<span class="hljs-number">0.3</span>,
        <span class="hljs-attr">system_prompt</span>=<span class="hljs-string">"""你是一位质量审核专家，擅长发现问题和提出改进建议。
</span></code></pre>
<p>审核维度：</p>
<ul>
<li>准确性：事实是否正确</li>
<li>完整性：是否遗漏重要内容</li>
<li>一致性：风格和术语是否统一</li>
<li>可读性：是否清晰易懂</li>
</ul>
<p>输出格式：</p>
<h3 data-id="heading-59">审核摘要</h3>
<ul>
<li>总体评分：[X/10]</li>
</ul>
<h3 data-id="heading-60">发现的问题</h3>
<h4 data-id="heading-61">严重问题（Must Fix）</h4>
<ol>
<li>[问题]</li>
</ol>
<h4 data-id="heading-62">一般问题（Should Fix）</h4>
<ol>
<li>[问题]</li>
</ol>
<h3 data-id="heading-63">修改后的版本</h3>
<p>[修改后的完整内容]
"""
)</p>
<pre><code class="hljs language-ini" lang="ini">def _build_prompt(self, task: SubTask, context: Dict) -&gt; str:
    <span class="hljs-comment"># QA Agent 需要审核前一个任务的输出</span>
    <span class="hljs-attr">previous_results</span> = context.get(<span class="hljs-string">"previous_results"</span>, {})

    <span class="hljs-comment"># 找到最近的一个任务结果</span>
    <span class="hljs-attr">content_to_review</span> = <span class="hljs-string">""</span>
    if task.dependencies:
        <span class="hljs-attr">last_dep</span> = task.dependencies[-<span class="hljs-number">1</span>]
        <span class="hljs-attr">content_to_review</span> = previous_results.get(last_dep, <span class="hljs-string">""</span>)

    <span class="hljs-attr">prompt</span> = f<span class="hljs-string">"""
</span></code></pre>
<p>用户需求：{context['user_request']}</p>
<p>当前任务：{task.description}</p>
<p>需要审核的内容：
{content_to_review}</p>
<p>请进行全面审核并提供修改后的版本。
"""
return prompt</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-comment">### SubAgent 管理器</span>

```python
<span class="hljs-comment"># agents/subagent_manager.py</span>
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubAgentManager</span>:
    <span class="hljs-string">"""SubAgent 管理器"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 注册所有 Agent</span>
        self.agents: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, SubAgent] = {
            <span class="hljs-string">"research"</span>: ResearchAgent(),
            <span class="hljs-string">"analysis"</span>: AnalysisAgent(),
            <span class="hljs-string">"writing"</span>: WritingAgent(),
            <span class="hljs-string">"coding"</span>: CodingAgent(),
            <span class="hljs-string">"planning"</span>: PlanningAgent(),
            <span class="hljs-string">"qa"</span>: QAAgent()
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_agent</span>(<span class="hljs-params">self, agent_type: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[SubAgent]:
        <span class="hljs-string">"""获取指定类型的 Agent"""</span>
        <span class="hljs-keyword">return</span> self.agents.get(agent_type)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_task</span>(<span class="hljs-params">self, task: SubTask, context: <span class="hljs-type">Dict</span></span>) -&gt; SubAgentResult:
        <span class="hljs-string">"""执行单个任务"""</span>
        agent = self.get_agent(task.agent_type)

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> agent:
            <span class="hljs-keyword">return</span> SubAgentResult(
                task_id=task.task_id,
                agent_type=task.agent_type,
                success=<span class="hljs-literal">False</span>,
                output=<span class="hljs-string">""</span>,
                error_message=<span class="hljs-string">f"未找到类型为 <span class="hljs-subst">{task.agent_type}</span> 的 Agent"</span>
            )

        <span class="hljs-keyword">return</span> agent.execute(task, context)
</code></pre>
<hr/>
<p><a id="user-content-langgraph-workflow" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-64">LangGraph 工作流</h3>
<h4 data-id="heading-65">工作流节点实现</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># workflow/nodes.py</span>
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> HumanMessage

<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_delegation_plan_node</span>(<span class="hljs-params">state: DelegationState</span>) -&gt; DelegationState:
    <span class="hljs-string">"""
    节点 1：创建委派计划

    主 Agent 分析用户请求，动态生成任务分解计划
    """</span>
    llm = get_llm(temperature=<span class="hljs-number">0.4</span>)

    prompt = <span class="hljs-string">f"""
用户需求：<span class="hljs-subst">{state.user_request}</span>

请将这个需求分解为多个子任务，并制定执行计划。

可用的子 Agent 类型：
- research: 信息调研与收集
- analysis: 数据分析与处理
- writing: 内容创作与撰写
- coding: 代码开发与实现
- planning: 计划制定与设计
- qa: 质量检查与审核

请输出 JSON 格式的计划：
{{
  "sub_tasks": [
    {{
      "task_id": "task_1",
      "description": "任务描述",
      "agent_type": "research",
      "priority": 5,
      "dependencies": []
    }},
    ...
  ],
  "execution_order": ["task_1", "task_2", ...],
  "rationale": "计划理由"
}}

要求：
1. 任务要具体、可执行
2. 正确设置任务间的依赖关系
3. 避免循环依赖
4. 优先级 1-5，5 最高
"""</span>

    response = llm.invoke([HumanMessage(content=prompt)])

    <span class="hljs-comment"># 提取 JSON</span>
    json_match = re.search(<span class="hljs-string">r'\{[\s\S]*\}'</span>, response.content)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> json_match:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"LLM 未返回有效的 JSON 格式"</span>)

    plan_data = json.loads(json_match.group())

    <span class="hljs-comment"># 构建 DelegationPlan</span>
    sub_tasks = [SubTask(**task) <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> plan_data[<span class="hljs-string">"sub_tasks"</span>]]
    plan = DelegationPlan(
        sub_tasks=sub_tasks,
        execution_order=plan_data[<span class="hljs-string">"execution_order"</span>],
        rationale=plan_data.get(<span class="hljs-string">"rationale"</span>, <span class="hljs-string">""</span>)
    )

    <span class="hljs-comment"># 验证依赖关系</span>
    plan.validate_dependencies()

    <span class="hljs-comment"># 检测循环依赖</span>
    circular = plan.detect_circular_dependency()
    <span class="hljs-keyword">if</span> circular:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"检测到循环依赖: <span class="hljs-subst">{circular}</span>"</span>)

    state.delegation_plan = plan
    <span class="hljs-keyword">return</span> state


<span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_sub_agents_node</span>(<span class="hljs-params">state: DelegationState</span>) -&gt; DelegationState:
    <span class="hljs-string">"""
    节点 2：执行子 Agent

    按照执行顺序，依次执行每个子任务
    """</span>
    manager = SubAgentManager()

    <span class="hljs-keyword">for</span> task_id <span class="hljs-keyword">in</span> state.delegation_plan.execution_order:
        <span class="hljs-comment"># 查找任务</span>
        task = <span class="hljs-built_in">next</span>(
            (t <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> state.delegation_plan.sub_tasks <span class="hljs-keyword">if</span> t.task_id == task_id),
            <span class="hljs-literal">None</span>
        )

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> task:
            <span class="hljs-keyword">continue</span>

        <span class="hljs-comment"># 检查依赖是否已完成</span>
        <span class="hljs-keyword">if</span> task.dependencies:
            pending_deps = [
                dep <span class="hljs-keyword">for</span> dep <span class="hljs-keyword">in</span> task.dependencies
                <span class="hljs-keyword">if</span> dep <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> state.completed_tasks
            ]
            <span class="hljs-keyword">if</span> pending_deps:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"⏸️  任务 <span class="hljs-subst">{task_id}</span> 的依赖 <span class="hljs-subst">{pending_deps}</span> 尚未完成，跳过"</span>)
                <span class="hljs-keyword">continue</span>

        <span class="hljs-comment"># 构建上下文</span>
        context = {
            <span class="hljs-string">"user_request"</span>: state.user_request,
            <span class="hljs-string">"previous_results"</span>: {}
        }

        <span class="hljs-comment"># 添加依赖任务的结果</span>
        <span class="hljs-keyword">for</span> dep_id <span class="hljs-keyword">in</span> task.dependencies:
            dep_result = state.sub_agent_results.get(dep_id)
            <span class="hljs-keyword">if</span> dep_result <span class="hljs-keyword">and</span> dep_result.success:
                context[<span class="hljs-string">"previous_results"</span>][dep_id] = dep_result.output

        <span class="hljs-comment"># 执行任务</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🚀 执行任务 <span class="hljs-subst">{task_id}</span>: <span class="hljs-subst">{task.description}</span>"</span>)
        result = manager.execute_task(task, context)

        <span class="hljs-comment"># 更新状态</span>
        state.sub_agent_results[task_id] = result

        <span class="hljs-keyword">if</span> result.success:
            state.completed_tasks.append(task_id)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ 任务 <span class="hljs-subst">{task_id}</span> 完成 (耗时: <span class="hljs-subst">{result.execution_time:<span class="hljs-number">.2</span>f}</span>s)"</span>)
        <span class="hljs-keyword">else</span>:
            state.failed_tasks.append(task_id)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 任务 <span class="hljs-subst">{task_id}</span> 失败: <span class="hljs-subst">{result.error_message}</span>"</span>)

    <span class="hljs-keyword">return</span> state


<span class="hljs-keyword">def</span> <span class="hljs-title function_">aggregate_results_node</span>(<span class="hljs-params">state: DelegationState</span>) -&gt; DelegationState:
    <span class="hljs-string">"""
    节点 3：聚合结果

    主 Agent 整合所有子 Agent 的输出，生成最终报告
    """</span>
    llm = get_llm(temperature=<span class="hljs-number">0.5</span>)

    <span class="hljs-comment"># 提取成功的任务结果</span>
    successful_results = []
    <span class="hljs-keyword">for</span> task_id <span class="hljs-keyword">in</span> state.completed_tasks:
        result = state.sub_agent_results.get(task_id)
        <span class="hljs-keyword">if</span> result <span class="hljs-keyword">and</span> result.success:
            task = <span class="hljs-built_in">next</span>(
                (t <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> state.delegation_plan.sub_tasks <span class="hljs-keyword">if</span> t.task_id == task_id),
                <span class="hljs-literal">None</span>
            )
            successful_results.append({
                <span class="hljs-string">"task_id"</span>: task_id,
                <span class="hljs-string">"task_description"</span>: task.description <span class="hljs-keyword">if</span> task <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,
                <span class="hljs-string">"agent_type"</span>: result.agent_type,
                <span class="hljs-string">"output"</span>: result.output
            })

    <span class="hljs-comment"># 构建聚合提示词</span>
    results_text = <span class="hljs-string">"\n\n"</span>.join([
        <span class="hljs-string">f"### 任务 <span class="hljs-subst">{r[<span class="hljs-string">'task_id'</span>]}</span> - <span class="hljs-subst">{r[<span class="hljs-string">'task_description'</span>]}</span>\n"</span>
        <span class="hljs-string">f"**Agent 类型**: <span class="hljs-subst">{r[<span class="hljs-string">'agent_type'</span>]}</span>\n"</span>
        <span class="hljs-string">f"**输出**:\n<span class="hljs-subst">{r[<span class="hljs-string">'output'</span>]}</span>"</span>
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> successful_results
    ])

    prompt = <span class="hljs-string">f"""
用户原始需求：<span class="hljs-subst">{state.user_request}</span>

以下是各个专业 Agent 的执行结果：

<span class="hljs-subst">{results_text}</span>

请将这些结果整合成一个连贯、完整的最终报告。

要求：
1. 保留所有关键信息
2. 确保逻辑流畅
3. 适当调整结构
4. 突出重点内容
"""</span>

    response = llm.invoke([HumanMessage(content=prompt)])
    state.final_report = response.content.strip()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n📊 聚合完成，共整合 <span class="hljs-subst">{<span class="hljs-built_in">len</span>(successful_results)}</span> 个任务的结果"</span>)

    <span class="hljs-keyword">return</span> state
</code></pre>
<h4 data-id="heading-66">创建工作流</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># workflow/graph.py</span>
<span class="hljs-keyword">from</span> langgraph.graph <span class="hljs-keyword">import</span> StateGraph, END

<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_delegation_workflow</span>():
    <span class="hljs-string">"""创建子 Agent 派生工作流"""</span>

    <span class="hljs-comment"># 创建状态图</span>
    graph = StateGraph(DelegationState)

    <span class="hljs-comment"># 添加节点</span>
    graph.add_node(<span class="hljs-string">"plan"</span>, create_delegation_plan_node)
    graph.add_node(<span class="hljs-string">"execute"</span>, execute_sub_agents_node)
    graph.add_node(<span class="hljs-string">"aggregate"</span>, aggregate_results_node)

    <span class="hljs-comment"># 定义边</span>
    graph.set_entry_point(<span class="hljs-string">"plan"</span>)
    graph.add_edge(<span class="hljs-string">"plan"</span>, <span class="hljs-string">"execute"</span>)
    graph.add_edge(<span class="hljs-string">"execute"</span>, <span class="hljs-string">"aggregate"</span>)
    graph.add_edge(<span class="hljs-string">"aggregate"</span>, END)

    <span class="hljs-comment"># 编译</span>
    <span class="hljs-keyword">return</span> graph.<span class="hljs-built_in">compile</span>()
</code></pre>
<hr/>
<p><a id="user-content-complete-example" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></p>
<h3 data-id="heading-67">完整示例</h3>
<h4 data-id="heading-68">主程序</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># main.py</span>
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-string">"""主函数：演示完整的子 Agent 派生流程"""</span>

    <span class="hljs-comment"># 用户请求</span>
    user_request = <span class="hljs-string">"写一篇关于 Python 装饰器的技术博客，包括基本概念、高级用法和代码示例"</span>

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🎯 用户请求: <span class="hljs-subst">{user_request}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>\n"</span>)

    <span class="hljs-comment"># 创建工作流</span>
    workflow = create_delegation_workflow()

    <span class="hljs-comment"># 初始化状态</span>
    initial_state = DelegationState(
        user_request=user_request,
        workflow_start_time=datetime.now().isoformat()
    )

    <span class="hljs-comment"># 执行工作流</span>
    <span class="hljs-keyword">try</span>:
        final_state = workflow.invoke(initial_state)

        <span class="hljs-comment"># 输出结果</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📝 最终报告"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>\n"</span>)
        <span class="hljs-built_in">print</span>(final_state.final_report)

        <span class="hljs-comment"># 统计信息</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📊 执行统计"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">'='</span>*<span class="hljs-number">60</span>}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"总任务数: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(final_state.delegation_plan.sub_tasks)}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"成功任务: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(final_state.completed_tasks)}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"失败任务: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(final_state.failed_tasks)}</span>"</span>)

        total_time = <span class="hljs-built_in">sum</span>(
            r.execution_time
            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> final_state.sub_agent_results.values()
        )
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"总耗时: <span class="hljs-subst">{total_time:<span class="hljs-number">.2</span>f}</span>s"</span>)

    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n❌ 执行失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">import</span> traceback
        traceback.print_exc()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
<h4 data-id="heading-69">运行示例</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 运行程序</span>
python main.py
</code></pre>
<p><strong>输出示例</strong>：</p>
<pre><code class="hljs language-markdown" lang="markdown">============================================================
<span class="hljs-section">🎯 用户请求: 写一篇关于 Python 装饰器的技术博客，包括基本概念、高级用法和代码示例
============================================================</span>

🚀 执行任务 task<span class="hljs-emphasis">_1: 研究 Python 装饰器的基本概念和原理
✅ 任务 task_</span>1 完成 (耗时: 8.32s)

🚀 执行任务 task<span class="hljs-emphasis">_2: 分析装饰器的高级用法和设计模式
✅ 任务 task_</span>2 完成 (耗时: 6.78s)

🚀 执行任务 task<span class="hljs-emphasis">_3: 编写装饰器的代码示例
✅ 任务 task_</span>3 完成 (耗时: 7.45s)

🚀 执行任务 task<span class="hljs-emphasis">_4: 基于研究和代码示例撰写技术博客
✅ 任务 task_</span>4 完成 (耗时: 12.34s)

🚀 执行任务 task<span class="hljs-emphasis">_5: 审核博客质量并优化
✅ 任务 task_</span>5 完成 (耗时: 8.91s)

📊 聚合完成，共整合 5 个任务的结果

============================================================
<span class="hljs-section">📝 最终报告
============================================================</span>

<span class="hljs-section"># Python 装饰器完全指南</span>

<span class="hljs-section">## 1. 什么是装饰器？</span>

装饰器是 Python 中一种强大的设计模式，允许我们在不修改原函数代码的情况下，为函数添加额外的功能...

[完整的技术博客内容...]

============================================================
<span class="hljs-section">📊 执行统计
============================================================</span>
总任务数: 5
成功任务: 5
失败任务: 0
总耗时: 43.80s
</code></pre>
<hr/>
<h3 data-id="heading-70">总结</h3>
<p>本文深入介绍了 Claude Code 中子 Agent 派生的实现：</p>
<p><strong>核心要点</strong>：</p>
<ol>
<li>✅ <strong>动态派生</strong> vs 硬编码：根据任务自动调整流程</li>
<li>✅ <strong>专业化分工</strong>：6 种 Agent 类型，各有专长</li>
<li>✅ <strong>依赖解析</strong>：自动计算执行顺序，支持并行</li>
<li>✅ <strong>状态管理</strong>：结构化的上下文传递机制</li>
<li>✅ <strong>性能优化</strong>：并行执行获得 1.5-2x 加速</li>
</ol>
<p><strong>关键收获</strong>：</p>
<ul>
<li>🎯 理解了为什么需要动态派生而非硬编码</li>
<li>🔧 掌握了完整的实现方法和代码</li>
<li>⚡ 学会了并行优化提升性能</li>
<li>🚀 了解了实际应用场景和最佳实践</li>
</ul>
<p><strong>下一步</strong>：</p>
<ol>
<li>尝试运行示例代码</li>
<li>根据自己的需求定制 Agent 类型</li>
<li>实现更复杂的工作流</li>
<li>探索 Lead Researcher 等高级模式</li>
</ol>
<hr/>
<h3 data-id="heading-71">参考资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Flangchain-ai.github.io%2Flanggraph%2F" target="_blank" title="https://langchain-ai.github.io/langgraph/" ref="nofollow noopener noreferrer">LangGraph 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FkakaCat%2Flangchain-learn%2Ftree%2Fmain%2F10-agent-examples" target="_blank" title="https://github.com/kakaCat/langchain-learn/tree/main/10-agent-examples" ref="nofollow noopener noreferrer">完整示例代码</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fclaude-code" target="_blank" title="https://github.com/anthropics/claude-code" ref="nofollow noopener noreferrer">Claude Code 文档</a></li>
</ul>
<hr/>
<p><strong>📧 反馈与讨论</strong></p>
<p>如有问题或建议，欢迎在项目 GitHub 提 Issue：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FkakaCat%2Flangchain-learn%2Fissues" target="_blank" title="https://github.com/kakaCat/langchain-learn/issues" ref="nofollow noopener noreferrer">langchain-learn/issues</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[服务端架构的演进与设计]]></title>    <link>https://juejin.cn/post/7593292445300670483</link>    <guid>https://juejin.cn/post/7593292445300670483</guid>    <pubDate>2026-01-11T02:33:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593292445300670483" data-draft-id="7593296804108943400" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="服务端架构的演进与设计"/> <meta itemprop="keywords" content="后端,架构,设计"/> <meta itemprop="datePublished" content="2026-01-11T02:33:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一线大码"/> <meta itemprop="url" content="https://juejin.cn/user/3280598429340984"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            服务端架构的演进与设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3280598429340984/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一线大码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-11T02:33:19.000Z" title="Sun Jan 11 2026 02:33:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-11
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读29分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">1. 基本概念</h2>
<p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍。</p>
<p><strong>1）什么是分布式？</strong></p>
<p>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如 Tomcat 和数据库分别部署在不同的服务器上，或两个相同功能的 Tomcat 分别部署在不同服务器上。</p>
<p><strong>2）什么是高可用？</strong></p>
<p>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性。</p>
<p><strong>3）什么是集群？</strong></p>
<p>一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。</p>
<p>如 Zookeeper 中的 Master 和 Slave 分别部署在多台服务器上，共同组成一个整体提供集中配置服务。</p>
<p>在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性。</p>
<p><strong>4）什么是负载均衡？</strong></p>
<p>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的。</p>
<p><strong>5）什么是正向代理和反向代理？</strong></p>
<p>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。</p>
<p>简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</p>
<h2 data-id="heading-1">2. 架构演进</h2>
<p>服务架构的演进是一个从简单到复杂、再从复杂回归简单（但内涵不同）的历程。其核心驱动力始终是：<strong>如何更高效地应对业务规模的增长、团队的扩张以及技术的变革</strong>。</p>
<p>以下是服务架构演进的主要阶段和核心理念：</p>
<h3 data-id="heading-2">2.1. 单体架构</h3>
<p>这是最传统的架构模式。</p>
<ul>
<li><strong>特点</strong>：所有功能模块（如用户管理、订单处理、支付等）都打包在一个单一的应用程序中，共享同一个数据库。</li>
<li><strong>优点</strong>：
<ul>
<li><strong>开发简单</strong>：初期项目搭建快，IDE支持好，易于调试和部署。</li>
<li><strong>测试容易</strong>：端到端测试单一。</li>
<li><strong>部署方便</strong>：只需打包一个WAR/JAR文件，放到一个服务器上即可运行。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>维护成本高</strong>：代码膨胀后，逻辑复杂，可读性差。</li>
<li><strong>技术栈僵化</strong>：难以引入新的技术或框架。</li>
<li><strong>扩展性差</strong>：无法按需扩展某个模块，只能整体扩展，资源浪费。</li>
<li><strong>可靠性低</strong>：一个微小bug可能导致整个系统崩溃。</li>
<li><strong>阻碍持续交付</strong>：牵一发而动全身，任何修改都需要全量回归测试和部署。</li>
</ul>
</li>
<li><strong>适用场景</strong>：创业初期、小型项目、内部工具。</li>
</ul>
<pre><code class="hljs language-java" lang="java">+---------------------------------------------------+
|                      单体应用                      |
|  +--------+  +--------+  +--------+  +--------+   |
|  | 模块A  |  | 模块B   |  | 模块C  |  | 模块D   |  |
|  +--------+  +--------+  +--------+  +--------+   |
|                                                   |
|             +----------------------+              |
|             |      共享数据库       |              |
|             +----------------------+              |
+---------------------------------------------------+
</code></pre>
<h3 data-id="heading-3">2.2. 垂直架构（也称“烟囱式架构”）</h3>
<p>为了解决单体的扩展问题，开始按业务进行切割。</p>
<ul>
<li><strong>特点</strong>：将一个大的单体应用拆分成几个互不相干的独立应用。例如分为电商前台、商家后台、运营后台。</li>
<li><strong>优点</strong>：
<ul>
<li><strong>系统拆分</strong>：实现了一定程度的解耦。</li>
<li><strong>可针对性扩展</strong>：可以针对访问量大的应用（如前台）独立增加服务器。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>功能重复</strong>：每个应用可能都包含一套自己的用户认证、日志等通用逻辑，造成重复开发。</li>
<li><strong>数据孤岛</strong>：应用间数据不互通，可能形成冗余和数据不一致。</li>
</ul>
</li>
<li><strong>演进</strong>：这是从单体走向分布式的一个过渡形态。</li>
</ul>
<pre><code class="hljs language-java" lang="java">+-------------------+      +-------------------+      +-------------------+
|     垂直应用<span class="hljs-number">1</span>      |      |     垂直应用<span class="hljs-number">2</span>     |      |     垂直应用<span class="hljs-number">3</span>      |
|  +--------------+ |      |  +--------------+ |      |  +--------------+ |
|  |  功能模块     | |      |  |  功能模块    | |      |  |  功能模块     | |
|  +--------------+ |      |  +--------------+ |      |  +--------------+ |
|         |         |      |         |         |      |         |         |
|  +--------------+ |      |  +--------------+ |      |  +--------------+ |
|  |  数据库<span class="hljs-number">1</span>      | |      | |   数据库<span class="hljs-number">2</span>     | |      |  |  数据库<span class="hljs-number">3</span>      | |
|  +--------------+ |      |  +--------------+ |      |  +--------------+ |
+-------------------+      +-------------------+      +-------------------+
</code></pre>
<h3 data-id="heading-4">2.3. SOA 架构</h3>
<p>为了解决“重复造轮子”和数据孤岛问题，提出了<strong>面向服务的架构</strong>(SOA，Service Oriented Architecture)思想。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li><strong>服务化</strong>：将共同的、可复用的功能抽取成独立的“服务”，如上文提到的用户服务、订单服务。</li>
<li><strong>企业服务总线</strong>：核心是<strong>ESB</strong>，所有服务都通过ESB进行通信和集成。ESB负责消息路由、协议转换、服务编排等。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li><strong>系统集成</strong>：有效解决了企业内部异构系统之间的互通问题。</li>
<li><strong>服务复用</strong>：提高了功能复用性。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>中心化瓶颈</strong>：ESB成为中心节点，容易造成性能瓶颈和单点故障。</li>
<li><strong>复杂度高</strong>：ESB本身非常重，协议和标准复杂（如SOAP/WS-*），开发测试困难。</li>
</ul>
</li>
<li><strong>理念贡献</strong>：首次明确了“服务”作为基本组件的概念。</li>
</ul>
<pre><code class="hljs language-java" lang="java">+----------+      +----------+      +----------+
|  服务A   |      |  服务B    |      |  服务C   |
+----------+      +----------+      +----------+
      |                |                |
      +----------------+----------------+
                       |
               +----------------+
               |      ESB       |
               |  (企业服务总线) |
               +----------------+
                       |
      +----------------+----------------+
      |                |                |
+----------+      +----------+      +----------+
| 数据库A   |      | 数据库B  |      | 数据库C   |
+----------+      +----------+      +----------+
</code></pre>
<h3 data-id="heading-5">2.4. 微服务架构</h3>
<p>这是当前的主流架构范式，可以看作是SOA的去中心化、精细化演进。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li><strong>彻底的服务化与自治</strong>：一个服务就是一个独立的、可部署的业务单元，拥有自己的独立数据库（数据库也完成拆分）。</li>
<li><strong>去中心化治理</strong>：没有ESB，服务间通过轻量级通信机制（如HTTP/REST, gRPC）直接调用。服务注册与发现（如Eureka, Nacos）取代了中心化的路由。</li>
<li><strong>技术多样性</strong>：每个服务可以根据自身需求选择最合适的技术栈（Polyglot）。</li>
<li><strong>围绕业务能力组织团队</strong>（康威定律的体现）。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li><strong>高内聚、低耦合</strong>：服务边界清晰，独立开发、部署、扩展。</li>
<li><strong>弹性与容错</strong>：单个服务故障不会导致整个系统瘫痪。</li>
<li><strong>技术选型灵活</strong>。</li>
<li><strong>更适合持续交付和DevOps</strong>。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>分布式系统复杂性</strong>：引入了网络延迟、服务发现、负载均衡、配置管理、分布式事务、链路追踪等一系列挑战。</li>
<li><strong>运维和监控复杂度陡增</strong>。</li>
<li><strong>测试难度大</strong>。</li>
</ul>
</li>
<li><strong>技术生态</strong>：Spring Cloud, Dubbo, Kubernetes (作为部署和编排平台) 等。</li>
</ul>
<pre><code class="hljs language-java" lang="java">+-------------+    +-------------+    +-------------+
|  微服务A     |   |  微服务B     |    |  微服务C     |
|  +--------+ |    |  +--------+ |    |  +--------+ |
|  | 业务逻辑| |   |  | 业务逻辑| |    |  | 业务逻辑| |
|  +--------+ |    |  +--------+ |    |  +--------+ |
|       |     |    |       |     |    |       |     |
|  +--------+ |    |  +--------+ |    |  +--------+ |
|  | 数据库A | |    | | 数据库B | |    |  | 数据库C | |
|  +--------+ |    |  +--------+ |    |  +--------+ |
+-------------+    +-------------+    +-------------+
       |                  |                  |
       +------------------+------------------+
                          |
                  +-----------------+
                  |  服务注册与发现  |
                  | (如Eureka/Nacos)|
                  +-----------------+
                          |
       +------------------+------------------+
       |                  |                  |
+-------------+    +-------------+    +-------------+
|    API网关  |    |  负载均衡器  |    |  配置中心    |
+-------------+    +-------------+    +-------------+
</code></pre>
<h3 data-id="heading-6">2.5. 云原生与服务网格架构</h3>
<p>这是微服务架构在云环境下的自然演进和“升华”。</p>
<ul>
<li><strong>核心思想</strong>：<strong>将微服务架构中与业务无关的通用能力（如服务通信、可观测性、安全性、流量治理）下沉到基础设施层</strong>。</li>
<li><strong>特点</strong>：
<ul>
<li><strong>服务网格</strong>：在应用旁部署一个轻量级网络代理（Sidecar，如Envoy），所有服务间的通信都经由Sidecar代理。由控制平面（如Istio, Linkerd）统一管理这些Sidecar。实现了 <strong>“业务逻辑与网络通信的解耦”</strong>。</li>
<li><strong>声明式API与不可变基础设施</strong>：以Kubernetes为代表，通过YAML文件描述“期望的状态”，由系统自动实现和维护。</li>
<li><strong>DevOps与GitOps</strong>：将基础设施即代码、持续部署流程化。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li><strong>极大简化了微服务开发</strong>：开发者几乎只需关注业务逻辑。</li>
<li><strong>提供了强大的、统一的流量控制能力</strong>（如金丝雀发布、熔断、故障注入）。</li>
<li><strong>基础设施标准化、自动化</strong>。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>学习曲线非常陡峭</strong>。</li>
<li><strong>组件繁多，体系复杂</strong>。</li>
<li><strong>对运维团队要求极高</strong>。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-java" lang="java">+---------------------------------------------------------+
|                   服务网格控制平面                       |
|                  (如Istio, Linkerd)                     |
+---------------------------------------------------------+
                             |
+--------------------------------------------------------------------+
|                    数据平面（由Sidecar代理组成）                     |
|                                                                    |
|  +-------------+        +-------------+        +-------------+     |
|  |   微服务A    |        |   微服务B   |        |   微服务C   |      |
|  |  +--------+ |        |  +--------+ |        |  +--------+ |     |
|  |  | 业务逻辑| |        | | 业务逻辑| |         | | 业务逻辑| |     |
|  |  +--------+ |        |  +--------+ |        |  +--------+ |     |
|  |       |     |        |       |     |        |       |     |     |
|  |  +--------+ |        |  +--------+ |        |  +--------+ |     |
|  |  | Sidecar| |        |  | Sidecar| |        |  | Sidecar| |     |
|  |  | (Envoy)| |        |  | (Envoy)| |        |  | (Envoy)| |     |
|  |  +--------+ |        |  +--------+ |        |  +--------+ |     |
|  +-------------+        +-------------+        +-------------+     |
|         |                    |                    |                |
|  +--------+             +--------+             +--------+          |
|  | 数据库A |            | 数据库B |             | 数据库C |          |
|  +--------+             +--------+             +--------+          |
+--------------------------------------------------------------------+
</code></pre>
<h3 data-id="heading-7">2.6. 无服务器与函数计算</h3>
<p>将“解耦”和“下沉”的思想推向极致，让开发者完全不用关心服务器。</p>
<ul>
<li><strong>特点</strong>：
<ul>
<li><strong>函数即服务</strong>：以函数为最小部署和计费单位。开发者只编写一个个独立的函数，由云平台负责其触发、运行、扩缩容（甚至缩到零）和运维。</li>
<li><strong>后端即服务</strong>：直接使用云数据库、云存储、云认证等托管服务。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li><strong>极致的开发效率与运维成本</strong>：完全无需管理服务器。</li>
<li><strong>极致的弹性与成本</strong>：按实际调用次数和资源消耗计费，空闲时成本为零。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>冷启动延迟</strong>。</li>
<li><strong>状态管理困难</strong>，函数应为无状态的。</li>
<li><strong>供应商锁定风险</strong>。</li>
<li><strong>调试和监控有特殊挑战</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>：事件驱动型、突发流量、异步处理（如图片处理、消息清洗、定时任务）。</li>
</ul>
<pre><code class="hljs language-java" lang="java">+-----------------------------------------------------------+
|                   云平台（如AWS Lambda）                   |
|                                                           |
|  +----------------+  +----------------+  +----------------+
|  |    函数A       |  |    函数B        |  |    函数C       |
|  |  +----------+  |  |  +----------+  |  |  +----------+  |
|  |  | 代码逻辑  |  |  |  | 代码逻辑  |  |  |  | 代码逻辑 |  |
|  |  +----------+  |  |  +----------+  |  |  +----------+  |
|  +----------------+  +----------------+  +----------------+
|          |                  |                  |          |
|  +----------------+  +----------------+  +------ -----+   |
|  |   事件源<span class="hljs-number">1</span>      |  |   事件源<span class="hljs-number">2</span>       |  |   事件源<span class="hljs-number">3</span>   |   |
|  | (如API网关)    |  | (如消息队列)    |  | (如对象存储) |   |
|  +----------------+  +----------------+  +----------------+
|                                                           |
+-----------------------------------------------------------+

+-----------------------------------------------------------+
|                   后端即服务（BaaS）                       |
|   +-----------------------------------------------+       |
|   |        云数据库      云存储      云身份认证     |       |
|   +-----------------------------------------------+       |
+-----------------------------------------------------------+
</code></pre>
<h2 data-id="heading-8">3. 分布式架构</h2>
<p><strong>分布式架构不是一个与单体、SOA、微服务等并列的“架构风格”，而是一个更上层的、描述系统部署和运行状态的“属性”或“模式”。</strong></p>
<p><strong>概念层级不同</strong></p>
<ul>
<li><strong>单体架构、微服务架构</strong> 等描述的是<strong>应用代码的组织方式、模块的边界和职责划分</strong>。它们回答的是“如何切割我的代码和功能”。</li>
<li><strong>分布式架构</strong> 描述的是<strong>系统组件部署和运行的物理（或逻辑）位置关系</strong>。它回答的是“我的组件是否运行在多个独立的、需要网络通信的进程/机器上”。</li>
</ul>
<p><strong>简单类比：</strong></p>
<ul>
<li>单体/微服务架构就像是<strong>房屋的结构设计</strong>（是打通的大开间，还是分成卧室、客厅、厨房等多个功能房间）。</li>
<li>分布式架构则是指<strong>这个房子是建在一块地基上，还是由多个建在不同地方、通过道路连接的小屋组成</strong>。</li>
</ul>
<p><strong>分布式是多个阶段的共同特征</strong></p>
<p><strong>演进主线（架构风格）：</strong> <strong>单体 → 垂直 → SOA → 微服务 → 服务网格/云原生 → 无服务器</strong></p>
<p>在演进历程中，<strong>从垂直架构开始，后续的架构几乎都具备“分布式”的特性</strong>。</p>
<ul>
<li><strong>垂直架构</strong>：如果“电商前台”和“商家后台”部署在不同的服务器上，并通过网络（如HTTP）调用，那么它就是一个简单的分布式系统。</li>
<li><strong>SOA架构</strong>：其核心ESB和服务提供者通常就是分布式部署的。</li>
<li><strong>微服务架构</strong>：<strong>是分布式架构的极致体现</strong>。每个服务都是独立的进程，部署上天然就是分布式的。</li>
<li><strong>云原生/无服务器架构</strong>：更是构建在遍布全球数据中心的分布式云基础设施之上。</li>
</ul>
<p><strong>分布式特性：</strong></p>
<ul>
<li><strong>单体架构</strong>：通常是非分布式的（所有模块在一个进程内）。</li>
<li><strong>垂直架构及以后</strong>：<strong>都具备分布式架构的属性</strong>。分布式程度和复杂度逐渐增加，在微服务时达到高峰，在云原生时代通过基础设施（服务网格）将复杂度下沉管理。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2561a3f5e6004e0c92d99fddc89aa587~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=W9TkUiA%2BY7wdH5JGV7ZTjW2Kito%3D" alt="deepseek_mermaid_20260110_f91ff9.png" loading="lazy"/></p>
<h2 data-id="heading-9">4. 演进总结</h2>
<h3 data-id="heading-10">4.1. 演进趋势总结</h3>






















































<table><thead><tr><th align="left">架构</th><th align="left">核心单元</th><th align="left">通信/集成</th><th align="left">数据库</th><th align="left">关键目标</th></tr></thead><tbody><tr><td align="left"><strong>单体</strong></td><td align="left">应用</td><td align="left">进程内调用</td><td align="left">单一共享数据库</td><td align="left">快速启动</td></tr><tr><td align="left"><strong>垂直</strong></td><td align="left">独立应用</td><td align="left">简单RPC/HTTP</td><td align="left">分库</td><td align="left">按业务扩展</td></tr><tr><td align="left"><strong>SOA</strong></td><td align="left">粗粒度服务</td><td align="left"><strong>中心化ESB</strong></td><td align="left">分库</td><td align="left">服务复用，系统集成</td></tr><tr><td align="left"><strong>微服务</strong></td><td align="left">细粒度服务</td><td align="left"><strong>去中心化，直接调用</strong></td><td align="left"><strong>一服务一库</strong></td><td align="left">敏捷、独立、灵活</td></tr><tr><td align="left"><strong>云原生</strong></td><td align="left">微服务+Sidecar</td><td align="left"><strong>服务网格</strong></td><td align="left">一服务一库</td><td align="left">基础设施能力下沉</td></tr><tr><td align="left"><strong>无服务器</strong></td><td align="left">函数/事件</td><td align="left">事件/消息</td><td align="left">托管BaaS</td><td align="left"><strong>零运维、极致弹性</strong></td></tr></tbody></table>
<h3 data-id="heading-11">4.2. 演进关系总览</h3>
<pre><code class="hljs language-java" lang="java">┌─────────────────────────────────────────────────────────────┐
│                   演进时间线                                 │
│                                                             │
│  单体 → 垂直 → SOA → 微服务 → 服务网格 → 无服务器              │
│                                                             │
│  ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐        │
│  │集中 │    │ 简单 │   │ 中心 │    │去中 │    │基础  │        │
│  │化   │    │ 分布 │   │ 化   │    │心化 │    │设施 │        │
│  └─────┘    └─────┘    └─────┘    └─────┘    └─────┘        │
│                                                             │
│  ┌───────────────────────────────────────────────────────┐  │
│  │           分布式系统复杂度逐渐增加                      │  │
│  │           运维关注点逐渐上移/抽象化                     │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-12">4.3. 核心思想演进</h3>
<ol>
<li><strong>从“大而全”到“小而专”</strong>：功能单元不断细化和独立。</li>
<li><strong>从“智能端点，笨管道”到“笨端点，智能管道”</strong>：通信的智能性从应用内部（ESB）转移到网络基础设施（服务网格）。</li>
<li><strong>从“关注服务器”到“关注代码”再到“关注业务逻辑”</strong>：运维负担被层层剥离。</li>
<li><strong>从“技术驱动拆分”到“业务驱动拆分”</strong>：康威定律日益凸显。</li>
</ol>
<h3 data-id="heading-13">4.4. 关键变化维度</h3>





























<table><thead><tr><th>架构维度</th><th>单体 → 垂直 → SOA → 微服务 → 服务网格 → 无服务器</th></tr></thead><tbody><tr><td><strong>部署单元</strong></td><td>应用 → 应用 → 服务 → 容器 → 服务+Sidecar → 函数</td></tr><tr><td><strong>通信方式</strong></td><td>函数调用 → RPC → ESB → REST/gRPC → 服务网格 → 事件</td></tr><tr><td><strong>数据管理</strong></td><td>共享库 → 独立库 → 分库 → 一服务一库 → 一服务一库 → BaaS</td></tr><tr><td><strong>团队结构</strong></td><td>功能型 → 项目型 → 服务型 → 产品型 → 平台型 → 无运维</td></tr><tr><td><strong>扩展方式</strong></td><td>垂直扩展 → 垂直扩展 → 服务扩展 → 服务扩展 → 自动扩展 → 自动扩展</td></tr></tbody></table>
<h3 data-id="heading-14">4.5. 架构选择建议</h3>
<ol>
<li><strong>初创阶段</strong>：单体或垂直架构，快速验证业务</li>
<li><strong>快速发展期</strong>：微服务架构，支持团队并行开发</li>
<li><strong>平台化阶段</strong>：服务网格/云原生，标准化基础设施</li>
<li><strong>事件驱动场景</strong>：无服务器，处理突发流量和异步任务</li>
<li><strong>遗留系统集成</strong>：SOA或API网关方式</li>
</ol>
<p><strong>没有最好的架构，只有最合适的架构。</strong> 架构演进的选择必须与团队规模、业务阶段、技术储备和运维能力相匹配。许多现代大型系统实际上是多种架构模式的混合体（如核心业务采用微服务，边缘计算或事件处理采用Serverless）。</p>
<h2 data-id="heading-15">5. 演进示例</h2>
<p>参考地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FsVwpJIAuvtLwIPFxTIPZuw" target="_blank" title="https://mp.weixin.qq.com/s/sVwpJIAuvtLwIPFxTIPZuw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/sVwpJIAuv…</a></p>
<p>下面以淘宝项目的架构演进进行示例。</p>
<h3 data-id="heading-16">5.1. 单机架构</h3>
<p>在网站最初时，应用数量与用户数都较少，可以把 Tomcat 和数据库部署在同一台服务器上。浏览器往 <code>www.taobao.com</code> 发起请求时，首先经过 DNS 服务器（域名系统）把域名转换为实际 IP 地址 10.102.4.1，浏览器转而访问该 IP 对应的 Tomcat。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83906bb5c4634bed9278678329b397bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=NeVxyT0sdcer68BsKIKbn%2BSTboM%3D" alt="18a8991b8ad538e9c37f6de020ce2255_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=1.webp" loading="lazy"/></p>
<p>架构瓶颈：随着用户数的增长，Tomcat 和数据库之间竞争资源，单机性能不足以支撑业务。</p>
<h3 data-id="heading-17">5.2. 第一次演进</h3>
<p><strong>Tomcat 与数据库分开部署</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2df1a88146cf464fb374e34b6f293137~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=CyRwBvqvn7tmgV3sQIPOmyhCcqQ%3D" alt="a5aca3e8b130cbd7085ca035c2f058ae_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=2.webp" loading="lazy"/></p>
<p>Tomcat 和数据库分别独占服务器资源，显著提高两者各自性能。</p>
<p>架构瓶颈：随着用户数的增长，并发读写数据库成为瓶颈。</p>
<h3 data-id="heading-18">5.3. 第二次演进</h3>
<p><strong>引入本地缓存和分布式缓存</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2dea6812ed44c398d920d9ffa0a6cd9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=Ye9Kap5kqhhowIhV5%2BOGrlQ9Vms%3D" alt="53b8dd22bfe95628d146d5207634fd1c_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=3.webp" loading="lazy"/></p>
<p>在 Tomcat 同服务器上或同 JVM 中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的 html 页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。</p>
<p>其中涉及的技术包括：使用 memcached 作为本地缓存，使用 Redis 作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p>
<p>架构瓶颈：缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的 Tomcat 上，响应逐渐变慢。</p>
<h3 data-id="heading-19">5.4. 第三次演进</h3>
<p><strong>引入反向代理实现负载均衡</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6a4912d4fd94595b7f7ae2099dc0e15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=hBE0HVA32gLqjkkbCrDzEwhSOSY%3D" alt="03f88af23ead3c3ac8a3064c812b710a_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=4.webp" loading="lazy"/></p>
<p>在多台服务器上分别部署 Tomcat，使用反向代理软件 Nginx 把请求均匀分发到每个 Tomcat 中。此处假设 Tomcat 最多支持 100 个并发，Nginx 最多支持 50000 个并发，那么理论上 Nginx 把请求分发到 500 个 Tomcat 上，就能抗住 50000 个并发。</p>
<p>其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持 http 协议，还会涉及 session 共享、文件上传下载的问题。</p>
<p>架构瓶颈：反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈。</p>
<h3 data-id="heading-20">5.5. 第四次演进</h3>
<p><strong>数据库读写分离</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eaf73f96f45a44049aa3336896772f1c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=o992rAUXrtApT%2BWiVXv1VJqs2j8%3D" alt="b54bdfa1ba22ffd757c9b7fd9f5f96b7_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=5.webp" loading="lazy"/></p>
<p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。</p>
<p>其中涉及的技术包括：MyCat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p>
<p>架构瓶颈：业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能。</p>
<h3 data-id="heading-21">5.6. 第五次演进</h3>
<p><strong>数据库按业务分库</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7005fab27ffa4951bf4a14e2dc15eeca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=rkckPROrZAu%2B%2F%2FUrTGNoo37qnkE%3D" alt="ed0c1667e0ab6769dea9ba85fbc03e7c_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=6.webp" loading="lazy"/></p>
<p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p>
<p>架构瓶颈：随着用户数的增长，单机的写库会逐渐会达到性能瓶颈。</p>
<h3 data-id="heading-22">5.7. 第六次演进</h3>
<p><strong>把大表拆分为小表</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d071e1a1cc23454cb950d9c8f324394b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=QaxXkHNDvWzT2575gnq8D%2BlfFKo%3D" alt="f5e299e75bf2b3fef72c209b423d97b4_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=7.webp" loading="lazy"/></p>
<p>比如针对评论数据，可按照商品 ID 进行 hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户 ID 或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的 MyCat 也支持在大表拆分为小表情况下的访问控制。</p>
<p>这种做法显著的增加了数据库运维的难度，对 DBA 的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由 MyCat 实现，SQL 的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是 MPP（大规模并行处理）架构的一类实现。</p>
<p>目前开源和商用都已经有不少 MPP 数据库，开源中比较流行的有 Greenplum、TiDB、Postgresql XC、HAWQ 等，商用的如南大通用的 GBase、睿帆科技的雪球 DB、华为的 LibrA 等等，不同的 MPP 数据库的侧重点也不一样，如 TiDB 更侧重于分布式 OLTP 场景，Greenplum 更侧重于分布式 OLAP 场景，这些 MPP 数据库基本都提供了类似 Postgresql、Oracle、MySQL 那样的 SQL 标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持 100 个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p>
<p>架构瓶颈：数据库和 Tomcat 都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的 Nginx 会成为瓶颈。</p>
<h3 data-id="heading-23">5.8. 第七次演进</h3>
<p><strong>使用 LVS 或 F5 来使多个 Nginx 负载均衡</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/673d9d340d634187b7fc8332c3533d1b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=xiNxo4p3r2eVkrMBARxncmJ32LE%3D" alt="ec133500f8437e4495e0cceeb0803c0f_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=8.webp" loading="lazy"/></p>
<p>由于瓶颈在 Nginx，因此无法通过两层的 Nginx 来实现多个 Nginx 的负载均衡。图中的 LVS 和 F5 是工作在网络第四层的负载均衡解决方案，其中 LVS 是软件，运行在操作系统内核态，可对 TCP 请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于 Nginx，可假设单机的 LVS 可支持几十万个并发的请求转发；F5 是一种负载均衡硬件，与 LVS 提供的能力类似，性能比 LVS 更高，但价格昂贵。由于 LVS 是单机版的软件，若 LVS 所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用 keepalived 软件模拟出虚拟 IP，然后把虚拟 IP 绑定到多台 LVS 服务器上，浏览器访问虚拟 IP 时，会被路由器重定向到真实的 LVS 服务器，当主 LVS 服务器宕机时，keepalived 软件会自动更新路由器中的路由表，把虚拟 IP 重定向到另外一台正常的 LVS 服务器，从而达到 LVS 服务器高可用的效果。</p>
<p>此处需要注意的是，上图中从 Nginx 层到 Tomcat 层这样画并不代表全部 Nginx 都转发请求到全部的 Tomcat，在实际使用时，可能会是几个 Nginx 下面接一部分的 Tomcat，这些 Nginx 之间通过 keepalived 实现高可用，其他的 Nginx 接另外的 Tomcat，这样可接入的 Tomcat 数量就能成倍的增加。</p>
<p>架构瓶颈：由于 LVS 也是单机的，随着并发数增长到几十万时，LVS 服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同。</p>
<h3 data-id="heading-24">5.9. 第八次演进</h3>
<p><strong>通过 DNS 轮询实现机房间的负载均衡</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b0aed386dd2d4eb28c3187f24e5fbe96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=DKAcB9nZaIU5vk8e8bUngjQKlZ4%3D" alt="26ac93ab7d73fa971319946eee6d2193_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=9.webp" loading="lazy"/></p>
<p>在 DNS 服务器中可配置一个域名对应多个 IP 地址，每个 IP 地址对应到不同的机房里的虚拟 IP。当用户访问 <code>www.taobao.com</code> 时，DNS 服务器会使用轮询策略或其他策略，来选择某个 IP 供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，<strong>系统入口处的请求并发量不再是问题</strong>。</p>
<p>架构瓶颈：随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求。</p>
<h3 data-id="heading-25">5.10. 第九次演进</h3>
<p><strong>引入 NoSQL 数据库和搜索引擎等技术</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4bf801fb23e472991c0fcee91bd920d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=oqCS8txzR0FuFRV9MdxN66hKPKQ%3D" alt="8a0c0696cbb736fc8ec8f090cb0fb17e_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=10.webp" loading="lazy"/></p>
<p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统 HDFS 解决，对于 key value 类型的数据，可通过 HBase 和 Redis 等方案解决，对于全文检索场景，可通过搜索引擎如 ElasticSearch 解决，对于多维分析场景，可通过 Kylin 或 Druid 等方案解决。</p>
<p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p>
<p>架构瓶颈：引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难。</p>
<h3 data-id="heading-26">5.11. 第十次演进</h3>
<p><strong>大应用拆分为小应用</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d00da37d8ac4deea8fc4f4585c3ceb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=AZqfUaYHTifU%2BGQQ04if36tFSZ0%3D" alt="5681d61143c73f79c14a97088c554762_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=11.webp" loading="lazy"/></p>
<p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心 Zookeeper 来解决。</p>
<p>架构瓶颈：不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级。</p>
<h3 data-id="heading-27">5.12. 第十一次演进</h3>
<p><strong>复用的功能抽离成微服务</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23a534cb934c4b209af4a56499482376~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=EveK8JBZPKuiC70wZW%2BALalDqVw%3D" alt="acfdf3b69e1f01099bf338647ef9b4ca_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=12.webp" loading="lazy"/></p>
<p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过 HTTP、TCP 或 RPC 请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过 Dubbo、SpringClou 等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p>
<p>架构瓶颈：不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱。</p>
<h3 data-id="heading-28">5.13. 第十二次演进（SOA）</h3>
<p><strong>引入企业服务总线(ESB，Enterprise Service Bus)屏蔽服务接口的访问差异</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4c4992985554f5babc5efb4a4a57c47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=LdFV842wTWe4hXY8RT7C%2BQYifdY%3D" alt="6af19fe8244134e3a4389b83516bfc51_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=13.webp" loading="lazy"/></p>
<p>通过 ESB 统一进行访问协议转换，应用统一通过 ESB 来访问后端服务，服务与服务之间也通过 ESB 来相互调用，以此降低系统的耦合程度。</p>
<p>这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的 SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。</p>
<p><strong>个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而 SOA 架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA 架构中包含了微服务的思想。</strong></p>
<p>架构瓶颈：业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难。</p>
<h3 data-id="heading-29">5.14. 第十三次演进</h3>
<p><strong>引入容器化技术实现运行环境隔离与动态服务管理</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/725b9820dfdb43c78580fdd1ab193da1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=dlkHQHWxR%2Bl5fBCsIAs0ZKY%2BRAI%3D" alt="7401f25b7ba14c38c7a69b006b94fd69_640_wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=14.webp" loading="lazy"/></p>
<p>目前最流行的容器化技术是 Docker，最流行的容器管理服务是 Kubernetes(K8S)，应用/服务可以打包为 Docker 镜像，通过 K8S 来动态分发和部署镜像。Docker 镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动 Docker 镜像就可以把服务起起来，使服务的部署和运维变得简单。</p>
<p>在大促的之前，可以在现有的机器集群上划分出服务器来启动 Docker 镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响。</p>
<p>架构瓶颈：使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低。</p>
<h3 data-id="heading-30">5.15. 第十四次演进</h3>
<p><strong>以云平台承载系统</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dd07bc684c584e228d3105eff161d67c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA57q_5aSn56CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768703932&amp;x-signature=y4ghwmLrpbCaxJ%2FDlXGJERU5uBQ%3D" alt="5c963715366c2d30271663e37847eea3_640_wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=15.webp" loading="lazy"/></p>
<p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合 Docker 和 K8S 来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p>
<p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如 CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如 Hadoop 技术栈，MPP 数据库等）供用户使用，甚至提供开发好的应用，用户不需要关心应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p>
<ol>
<li>
<p>IaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</p>
</li>
<li>
<p>PaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</p>
</li>
<li>
<p>SaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</p>
</li>
</ol>
<h2 data-id="heading-31">6. 架构设计经验小结</h2>
<p><strong>1）架构的调整是否必须按照上述演变路径进行？</strong></p>
<p>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</p>
<p><strong>2）对于将要实施的系统，架构应该设计到什么程度？</strong></p>
<p>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以备不时之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</p>
<p><strong>3）服务端架构和大数据架构有什么区别？</strong></p>
<p>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有 Flume、Sqoop、Kettle 等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL 数据库 HBase、MongoDB 等，数据分析有 Spark 技术栈、机器学习算法等。</p>
<p>总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</p>
<p><strong>4）有没有一些架构设计的原则？</strong></p>
<p>a. N+1 设计：系统中的每个组件都应做到没有单点故障；</p>
<p>b. 回滚设计：确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</p>
<p>c. 禁用设计：应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</p>
<p>d. 监控设计：在设计阶段就要考虑监控的手段；</p>
<p>e. 多活数据中心设计：若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</p>
<p>f. 采用成熟的技术：刚开发的或开源的技术往往存在很多隐藏的 bug，出了问题没有商业支持可能会是一个灾难；</p>
<p>g. 资源隔离设计：应避免单一业务占用全部资源；</p>
<p>h. 架构应能水平扩展：系统只有做到能水平扩展，才能有效避免瓶颈问题；</p>
<p>i. 非核心则购买：非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</p>
<p>j. 使用商用硬件：商用硬件能有效降低硬件故障的机率；</p>
<p>k. 快速迭代：系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</p>
<p>l. 无状态设计：服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Token 经济学：AI 工程师必修的 Token 治理实战]]></title>    <link>https://juejin.cn/post/7593337928307736602</link>    <guid>https://juejin.cn/post/7593337928307736602</guid>    <pubDate>2026-01-10T13:34:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593337928307736602" data-draft-id="7593261984190660658" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Token 经济学：AI 工程师必修的 Token 治理实战"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-10T13:34:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AI工程化实验室"/> <meta itemprop="url" content="https://juejin.cn/user/2612095357040989"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Token 经济学：AI 工程师必修的 Token 治理实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612095357040989/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AI工程化实验室
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:34:23.000Z" title="Sat Jan 10 2026 13:34:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9d019b9a80514df4b0e42217039a96d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlt6XnqIvljJblrp7pqozlrqQ=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768656862&amp;x-signature=IYj2iCfWTZ%2BNZ8KfEHWNSb0Z4Qk%3D" alt="cover.webp" loading="lazy"/></p>
<h3 data-id="heading-0">引言：当“金科玉律”变成“剧毒药丸”</h3>
<p><strong>“过早优化是万恶之源。”</strong></p>
<p>这是计算机科学泰斗 Donald Knuth 在《计算机编程艺术》中留下的名言。在 Web 开发的黄金时代，这句话是无数工程师的护身符。如果你在项目初期就为了省几 KB 内存、少几次 CPU 循环而绞尽脑汁，通常会被嘲笑为不懂工程。因为服务器资源是廉价的、固定的，代码多跑一圈循环的边际成本，几乎为零。</p>
<p>然而，当你踏入 AI Engineering 的领域，这句话却成了最危险的毒药。</p>
<p>AI 开发与传统开发之间，横亘着一道巨大的鸿沟——<strong>“算力成本”的计算逻辑彻底变了。</strong></p>
<ul>
<li>在传统开发中：你多打印一行 Log，多返回一个冗余的 JSON 字段，多写一个 if-else，对成本的影响微乎其微，基本可以忽略不计。</li>
<li>在 AI 开发中：每一次 API 调用，每一个你塞进 Context 的字符，甚至每一次模型输出的换行符，<strong>都是直接的、实时的、按量计费的真金白银。</strong></li>
</ul>
<p>这意味着，<strong>Token 不再是单纯的技术参数，它是你的“财务账本”。</strong></p>
<p>如果你依然带着传统开发的惯性——“先把功能跑通，上线后再考虑优化”——那么在 LLM 系统规模化扩展的那一刻，你将面临灾难性的后果：系统的边际成本不会随着规模效应降低，反而会因为架构设计的粗糙而呈指数级爆炸。</p>
<p><strong>在 AI 时代，成本控制不再是上线后的运维工作，而是写第一行代码前的架构设计。</strong></p>
<h2 data-id="heading-1">一｜为什么 Token 治理不能留到“上线前夕”？</h2>
<p>这是 AI Engineer 必须跨越的一道认知分水岭：<strong>告别“先跑通，再优化”的传统软件思维。</strong></p>
<p>在传统软件开发中，我们习惯将性能优化放在项目收尾阶段甚至上线以后。因为将一段 Python 代码的执行效率提升 20%，通常只是让程序跑得更快，而不会改变核心功能。但在 LLM 的世界里，这是一个致命的陷阱。</p>
<p><strong>因为 Token 不仅仅是计费单位，它是承载推理能力的“逻辑算力”。</strong></p>
<h3 data-id="heading-2">1. 微观陷阱：Token 调优 = 破坏性重构</h3>
<p>AI Engineer 需要达成一个底层共识：大模型看不见你的业务逻辑，它只看见 Token 序列。模型所有的推理，本质上都是基于这串序列的概率预测。</p>
<p>当你为了省钱或提速而在<strong>上线前夕</strong>临时“压缩 Token”（比如精简 Prompt、截断上下文）时，你改变的不仅仅是字符长度，你改变了模型的“注意力分布（Attention Distribution）”。</p>
<p>在传统代码中，我们删掉注释、优化循环，程序的输出结果是确定的。但在 Prompt 中，删掉几个看似无关紧要的形容词，或者压缩一段背景描述，可能会导致模型对关键指令的“注意力权重”降低，直接导致幻觉或指令遵循失败。</p>
<p>这也就意味着： 如果你等到功能开发完再做“Token 降本”，你会发现，你的每一次为了节省成本的调优，都需要重新进行全量的回归测试。后置的 Token 优化，本质上是在项目发布前夜，推翻核心代码重写。</p>
<h3 data-id="heading-3">2. 架构陷阱：不可逆的“成本乘数”</h3>
<p>真正让 AI 工程师必须在 Day 1 就考虑 Token 的原因，在于架构层面的成本乘数效应（Cost Multiplier）。</p>
<p>在传统软件中，一个 API 调用的成本往往是固定的。但在 AI 系统（特别是 Agent 或复杂的 RAG 系统）中，你的架构设计决定了“一次用户请求”背后会分裂出多少“Token 消耗”。</p>
<p><strong>这种隐形分裂往往是惊人的。</strong></p>
<p>以 Agent 开发为例：如果你在架构层没有设计严格的“思考步数限制”和“Token 熔断机制”，那么在真实环境中，一个简单的用户请求可能会让 Agent 陷入“思考-搜索-再思考”的死循环。这不仅导致响应超时，更在后台悄无声息地消耗了数万 Token——最终无论任务成功与否，这笔账单都必须由系统支付。</p>
<p>同样的陷阱也存在于 RAG（检索增强） 系统中：为了追求所谓的“高召回率”，很多工程师倾向于在架构上设定每次检索大量的文档片段。这实际上是在架构层面锁死了系统的“基础代谢率”：每一次用户提问，无论简单与否，起步成本都被锚定在了一个高位。</p>
<p>为什么必须前置考虑？</p>
<p>因为一旦这些流程被写进代码逻辑（Workflow），它们就构成了系统的成本基座。如果你等到上线前夕才去审视这些问题，你面对的已经不是简单的“参数调整”，而是要推翻整个 Agent 的思考链路，或者重写向量数据库的检索策略。</p>
<p>这不叫优化，这叫架构重构。所以，Token 经济学告诉我们：所有的成本失控，本质上都是架构设计的失职。</p>
<h2 data-id="heading-4">二｜成本黑洞：常见的Token 浪费模式</h2>
<p>在理解了 Token 优化的重要性后，我们来看看在真实的工程现场，Token 到底是怎么被烧掉的。</p>
<p>在软件工程中，我们有“内存泄漏（Memory Leak）”的概念。在 AI 工程中，同样存在“<strong>Token 泄漏（Token Leak）</strong>”。</p>
<p>这种泄漏通常不是一次性的爆发，而是像水龙头滴水一样：每一次调用多一点，每一个 Prompt 啰嗦一点。直到月底账单出来，你才发现这些不起眼的滴漏汇聚成了惊人的成本黑洞。</p>
<p>以下是6种最典型的“工程反模式（Anti-Patterns）”，请对照你的系统检查一下，是否正在踩坑。</p>
<h3 data-id="heading-5">1. 囤积癖反模式： “多给点上下文，总没坏处”</h3>
<p>这是 Token 浪费的第一大源头，源于工程师的一种“防御性心理”。</p>
<p>当模型回答不准确时，直觉告诉我们要“喂更多数据”：多贴几轮历史对话，多塞几段业务背景，多加几个 Edge Case 说明。</p>
<p>而工程真相是：</p>
<p>模型没有“自动忽略垃圾信息”的能力。在 Transformer 架构中：</p>
<ul>
<li>每一个输入的 Token 都会占用显存；</li>
<li>每一个 Token 都会参与 Attention 矩阵的复杂计算；</li>
<li>每一个 Token 都在稀释关键信息的权重（信噪比下降）。</li>
</ul>
<p>你以为你在“兜底”，实际上你是在花钱买噪音。这不仅增加了成本，更导致了“迷失中间（Lost in the Middle）”效应，让模型变笨。</p>
<h3 data-id="heading-6">2. 静态资产税反模式： System Prompt 的重复支付</h3>
<p>这是最容易被忽视的“隐形税”。</p>
<p>想象一下，你的 System Prompt 是一份 500 Token 的“角色设定书”。</p>
<ul>
<li>单次看：几分钱，不贵。</li>
<li>放进 High QPS 接口：每天调用 10 万次。后果是，你每天在为这 完全相同 的 500 个 Token，重复支付 10 万次。</li>
</ul>
<p>很多系统把 Prompt 当成静态的“配置文件”写在代码里，却忘了 API 是按次计费的。模型看不见你的代码结构，它只看得见你每次传给它的 Payload。</p>
<h3 data-id="heading-7">3. RAG 注水反模式： 检索 ≠ 可用</h3>
<p>RAG（检索增强生成）本应是让模型更精准，但现在却成了 Token 滥用的重灾区。</p>
<p>常见做法是：检索出 Top-5 文档 —&gt;  直接拼接 —&gt; 塞进 Context —&gt; 祈祷模型自己挑重点。</p>
<p>而工程真相是：</p>
<p>召回（Retrieval）和 使用（Usage）是两码事。</p>
<ul>
<li>文档里的页眉、页脚、免责声明、HTML 标签，全是无效 Token。</li>
<li>召回了 5000 字，可能只有 200 字与问题相关。</li>
</ul>
<p>把 RAG 做成“垃圾倾倒场”，模型不仅会帮你把垃圾读一遍并收费，还会因为干扰信息太多而产生幻觉。</p>
<h3 data-id="heading-8">4. 话痨反模式： 为“废话”买单</h3>
<p>很多工程师只盯着 Input Token（输入），却忽略了 Output Token（输出）。</p>
<p>但在计费逻辑中，Output Token 的单价通常比Input Token更贵。</p>
<p>如果你的 Prompt 里没有明确对outout 限制：</p>
<ul>
<li>限制长度（<code>Max Tokens</code>）；</li>
<li>规定格式（<code>JSON</code> / <code>Bullet Points</code>）；</li>
<li>禁止寒暄（<code>Do not say "Here is the result"</code>）；</li>
</ul>
<p>那么模型就会按照它“话痨”的本性，先复述一遍你的问题，再写一段客套话，最后才给出答案。这些多出来的废话，都是你在为模型的“礼貌”买单。</p>
<h3 data-id="heading-9">5. 说明书反模式： 给机器写文档</h3>
<p>这是典型的“对象错位”。很多 Prompt 被写成了给人类看的“操作手册”：</p>
<blockquote>
<p>“请你作为一个专业的助手，非常仔细地阅读下面的内容，这对我非常重要，请不要遗漏...”</p>
</blockquote>
<p>工程真相：</p>
<p>LLM 不需要被“说服”，也不需要情感铺垫, 它只需要高密度的指令信号。</p>
<p>Prompt 里的每一个形容词、每一个副词、每一个礼貌用语，如果不能显著降低“信息熵”，那就是纯粹的 Token 浪费。</p>
<h3 data-id="heading-10">6. 状态爆炸反模式： Agent 链路的复利效应</h3>
<p>当你开始构建 Agent 或 Workflow 时，Token 浪费会呈指数级放大。</p>
<ul>
<li>Step 1 的输出，变成了 Step 2 的输入；</li>
<li>Step 2 的输出，又叠加之前的历史，变成了 Step 3 的输入...</li>
</ul>
<p>如果在 Agent 传递过程中，没有做“状态清洗（State Flushing）”**，**保留了每一次中间思考过程（Chain of Thought），那么整条链路的成本将不是线性的，而是滚雪球式增长。</p>
<p>单次 Debug 看不出问题，一旦系统跑起来，这就是财务灾难。</p>
<p>总结这 6 种反模式，我们可以得出一个残酷的结论：</p>
<p><strong>Token 浪费，从来不是因为“不小心”，而是因为“没设计”。</strong></p>
<p>如果你没有把 Token 当作和 CPU、内存、带宽同等重要的工程资源去规划，那么它就会以最昂贵的方式消耗自己。</p>
<h2 data-id="heading-11">三｜顶层设计： 建立Token资产的系统级视角</h2>
<p>上面的对token 管理失策的问题表面上看是“写 Prompt 不严谨”，</p>
<p>但如果站在更高的视角，会发现一个共同的根因：</p>
<p><strong>Token 从未被当作一种需要被“设计和治理”的工程资产。</strong></p>
<p>在架构设计阶段，我们可以将 Token 拆解为三类性质完全不同的“工程资产”。</p>
<p>因为它们的失控方式不同，治理手段也完全不同。我们将从静态（Static）、动态（Dynamic）、生成（Generation）三个维度考虑Token 作为工程资产的拆分和治理策略。</p>
<h3 data-id="heading-12">1. 静态资产（Static Context）：</h3>
<p>主要包括： System Prompt、Few-Shot 示例、固定业务规则。</p>
<p>这一类token消耗对应的内容万年不变，但每一次 API 请求都会被完整传输、完整计费。</p>
<p>这是高 QPS 场景下最大的成本黑洞。</p>
<p>很多工程师把 System Prompt 写死在代码里，认为这是“一次性配置”。但是在模型眼里，每次请求传过来的 System Prompt 都是全新的输入，都会重新计费；</p>
<p>如果你每天调用 10 万次，你就为这完全相同的 500 Token 重复付费了 10 万次。</p>
<p>治理策略主要考虑 <strong>Context Caching（上下文缓存）， 即</strong>不要把 Prompt 零散地拼接。而是将所有静态内容独立封装成一个 Context Block，利用模型厂商（如 Anthropic, DeepSeek, Google）提供的 Prompt Caching 功能进行缓存后使用。 这样这部分的成本将下降 70%–90%，且首字延迟（TTFT）显著降低。</p>
<h3 data-id="heading-13">2. 动态资产（Dynamic Context）</h3>
<p>主要包括用户 Query、RAG 检索回来的文档、历史对话记录， 等在系统运行过程中动态产生的内容；主要的特点是，每次都不一样，无法缓存，且随着系统使用时间增长，体积呈线性甚至指数级膨胀。</p>
<p>而“多给点上下文，模型会更聪明”——这是工程上最大的谎言。</p>
<p>无节制的 RAG 召回和无限的历史记录，不仅会让成本垂直起飞，还会导致“迷失中间（Lost in the Middle）”效应，降低模型准确率。</p>
<p>治理原则不是“省”，而是**“熔断”。**你必须在代码层对动态内容执行硬性截断。</p>
<ul>
<li>
<p>RAG 熔断逻辑（伪代码）<strong>：</strong></p>
<pre><code class="hljs language-python" lang="python">context = <span class="hljs-string">""</span>
<span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> retrieved_docs:
    <span class="hljs-comment"># 如果加了这篇文档会超预算，直接丢弃，而不是截断文档</span>
    <span class="hljs-keyword">if</span> count_tokens(context + doc) &gt; MAX_RAG_BUDGET:
        <span class="hljs-keyword">break</span> 
    context += doc
</code></pre>
</li>
<li>
<p>历史记录策略：</p>
<p>放弃“全量继承”。使用 滑动窗口（Sliding Window） 或 关键信息摘要（Summary） 替代。</p>
</li>
</ul>
<p>治理后这部分的收益预期是，将不可控的变量成本转化为<strong>可预测</strong>的固定成本。</p>
<h3 data-id="heading-14">3. 生成资产（Generation Context）</h3>
<p>这部分token消耗主要来源于模型最终输出、CoT（思维链）、Agent 中间思考过程。</p>
<p>主要的特点是单价最贵，且直接阻塞用户，也决定了 API 的响应延迟。</p>
<p>如果不加控制，模型一旦开始废话（过度寒暄、过度解释），你不仅要为这些废话付费，应用的输出时间也会被拖长，用户要盯着屏幕傻等， <strong>生成 Token 失控 的同时， 用户体验也变得不好。</strong></p>
<p>这一部分资产的治理，可以从几个维度考虑</p>
<ul>
<li>
<p>不要单纯用数量限制，要用“用户能等多久”来反推。比如假设模型生成速度为 20 Token/s，用户最大忍受等待时间为 10s。那么 max_tokens 的硬限制绝对不能超过 200。</p>
</li>
<li>
<p>输出格式的协议降级（Protocol Downgrade）：对于用户不可见的 Agent 内部通信，严禁使用 JSON（格式税太高）。</p>
<ul>
<li>❌ JSON: <code>{"status": "success", "reason": "ok"}</code> (10+ Tokens)</li>
<li>✅ CSV: <code>success,ok</code> (3 Tokens)</li>
</ul>
</li>
<li>
<p>在多步 Agent 系统中，最致命的设计是“全量继承”——即 Step 2 继承 Step 1 的所有输入输出。这会导致 Token 呈指数级爆炸。</p>
<p>在这部分的治理上， 需要让Agent 的每一次状态流转，都必须经过一次“信息清洗（State Washing）”。</p>
<p>即只传 Result，不传 Reason：下游 Agent 通常只需要上一步的“结果”，不需要知道上一步的“思考过程”。</p>
<p>如果必须传递历史，请先调用一个廉价的小模型（如 GPT-3.5-Turbo 或 Haiku），把上一步的 2000 Token 执行记录压缩成 100 Token 的摘要，再传给下一步。</p>
</li>
</ul>
<p>这部分资产的治理收益预期是，响应时间稳定，不再为模型的“废话”买单。</p>
<p>最后，我们将这套治理逻辑浓缩为一张架构速查表：</p>





























<table><thead><tr><th>资产类型</th><th>核心痛点</th><th>治理逻辑</th><th>关键技术手段</th></tr></thead><tbody><tr><td>静态资产</td><td>重复付费</td><td>复用</td><td>Context Caching / 静态封装</td></tr><tr><td>动态资产</td><td>无限膨胀</td><td>截断</td><td>预算熔断 (Circuit Breaker)</td></tr><tr><td>生成资产</td><td>延迟过高</td><td>反推</td><td>协议降级 / 时间预算控制/Agent 状态清洗</td></tr></tbody></table>
<p><strong>记住：Token 预算的本质，不是财务算账，而是系统架构治理。</strong></p>
<h2 data-id="heading-15">结语：从“调包侠”到“架构师”</h2>
<p>到这里，我们关于 Token 经济学的探讨就告一段落了。</p>
<p>作为 AI Engineer，请记住：<strong>在 AI 时代，代码效率不仅体现在算法复杂度（O(n)）上，更体现在 Token 消耗量上。</strong></p>
<p>以前我们优化的是 CPU Cycle，现在我们优化的是 Token Budget。</p>
<p>当你开始为一个 AI 系统建立 Dashboard，监控每一个 Request 的 Token/Response 效率比 时，你就真正从一名“调包侠”，进阶为了一名合格的 AI 架构师。</p>
<hr/>
<p>阅读更多 <a href="https://link.juejin.cn?target=https%3A%2F%2Faienglab.net" target="_blank" title="https://aienglab.net" ref="nofollow noopener noreferrer">AI 工程化实验室</a>系列文章 或关注公众号 <strong>AI工程化实验室</strong>，深入探索 RAG优化、Agent编排硬核技术干货。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[BPE 算法原理与训练实现]]></title>    <link>https://juejin.cn/post/7593541291011784731</link>    <guid>https://juejin.cn/post/7593541291011784731</guid>    <pubDate>2026-01-10T13:47:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593541291011784731" data-draft-id="7593310044479029257" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="BPE 算法原理与训练实现"/> <meta itemprop="keywords" content="算法,LLM"/> <meta itemprop="datePublished" content="2026-01-10T13:47:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小小宫城狮"/> <meta itemprop="url" content="https://juejin.cn/user/3931509310620071"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            BPE 算法原理与训练实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3931509310620071/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小小宫城狮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:47:32.000Z" title="Sat Jan 10 2026 13:47:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、BPE 算法核心原理</h2>
<h3 data-id="heading-1">1. 核心思想</h3>
<p>BPE 的核心思想是<strong>从基础词汇单元（字符 / 字节）出发，反复迭代地合并出现频率最高的相邻字符对（字节对），将其作为新的子词单元</strong>，直到达到预设的词汇表大小或没有可合并的字符对为止。</p>
<p>这种思想既保留了字符级别的细粒度（解决 OOV 问题），又能通过合并高频子词形成更具语义的单元（如 "un-"、"happy"、"ing"），提升编码效率。</p>
<h3 data-id="heading-2">2. 关键概念铺垫</h3>
<ul>
<li>
<p>基础单元：初始为文本中的单个字符（通常会在词尾添加特殊标记<code>&lt;/w&gt;</code>，用于区分词内子词和词尾子词，如 "low"和"lower"）；</p>
</li>
<li>
<p>频率统计：以 “词 - 出现次数” 的形式统计语料中所有词的频率；</p>
</li>
<li>
<p>相邻字符对：单个词内的连续两个基础单元（或已合并的子词单元）；</p>
</li>
<li>
<p>合并停止条件：两种常见条件（满足其一即可）：</p>
<ol>
<li>词汇表大小达到预设阈值（如 30000、50000）；</li>
<li>语料中不存在出现频率 &gt; 1 的相邻字符对。</li>
</ol>
</li>
</ul>
<h3 data-id="heading-3">3. 算法执行步骤（原理层面）</h3>
<ol>
<li>
<p><strong>数据预处理与初始化</strong>：</p>
<ul>
<li>对原始语料进行分词、清洗，为每个词添加词尾标记<code>&lt;/w&gt;</code>；</li>
<li>统计每个词的出现频率，形成「词：频率」字典；</li>
<li>将每个词拆分为单个字符的序列，作为初始子词单元（如 "low" 拆分为<code>l o w &lt;/w&gt;</code>）。</li>
</ul>
</li>
<li>
<p><strong>统计相邻字符对频率</strong>：</p>
<ul>
<li>遍历所有词的字符序列，统计所有相邻字符对的全局出现频率；</li>
<li>例如语料中有 "low":5、"lower":3，会统计到<code>(l,o):8</code>、<code>(o,w):8</code>、<code>(w,&lt;/w&gt;):5</code>等。</li>
</ul>
</li>
<li>
<p><strong>合并最高频字符对</strong>：</p>
<ul>
<li>找到全局频率最高的相邻字符对，将其合并为一个新的子词单元；</li>
<li>遍历所有词的字符序列，将该字符对替换为新子词（如合并<code>w &lt;/w&gt;</code>为<code>w&lt;/w&gt;</code>，则 "low" 变为<code>l o w&lt;/w&gt;</code>）。</li>
</ul>
</li>
<li>
<p><strong>迭代合并</strong>：</p>
<ul>
<li>重复步骤 2 和步骤 3，每次合并后都会生成新的子词单元，词汇表不断扩大；</li>
<li>每次合并都会记录「合并规则」（即哪两个单元合并为新单元），用于后续的编码和解码。</li>
</ul>
</li>
<li>
<p><strong>停止迭代，生成最终词汇表</strong>：</p>
<ul>
<li>当词汇表大小达到预设值或无高频字符对可合并时，停止迭代；</li>
<li>最终词汇表包含初始字符单元和所有迭代过程中生成的合并子词单元。</li>
</ul>
</li>
</ol>
<h2 data-id="heading-4">二、BPE 算法训练实现（Python 手动实现）</h2>
<p>下面通过一个极简示例，手动实现 BPE 的训练过程，清晰展示其核心逻辑（无第三方库依赖）。</p>
<h3 data-id="heading-5">步骤 1：准备初始数据（带频率的语料）</h3>
<p>我们选用一个简单的模拟语料，包含 4 个词及其出现频率，方便观察合并过程：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 步骤1：初始化带频率的词表（已添加词尾标记&lt;/w&gt;）</span>
word_freqs = {
    <span class="hljs-string">"low&lt;/w&gt;"</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">"lower&lt;/w&gt;"</span>: <span class="hljs-number">3</span>,
    <span class="hljs-string">"newest&lt;/w&gt;"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"widest&lt;/w&gt;"</span>: <span class="hljs-number">2</span>
}

<span class="hljs-comment"># 将每个词拆分为字符列表，形成初始的「词序列: 频率」字典</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">init_word_sequences</span>(<span class="hljs-params">word_freqs</span>):
    word_seqs = {}
    <span class="hljs-keyword">for</span> word, freq <span class="hljs-keyword">in</span> word_freqs.items():
        <span class="hljs-comment"># 拆分为单个字符（如"low&lt;/w&gt;" -&gt; ["l", "o", "w", "&lt;/w&gt;"]）</span>
        char_seq = <span class="hljs-built_in">list</span>(word)
        word_seqs[<span class="hljs-built_in">tuple</span>(char_seq)] = freq  <span class="hljs-comment"># 用tuple作为key（list不可哈希）</span>
    <span class="hljs-keyword">return</span> word_seqs

word_sequences = init_word_sequences(word_freqs)
</code></pre>
<h3 data-id="heading-6">步骤 2：定义核心辅助函数</h3>
<p>包括「统计相邻字符对频率」、「合并最高频字符对」两个核心函数：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pair_freqs</span>(<span class="hljs-params">word_sequences</span>):
    <span class="hljs-string">"""
    步骤2：统计所有相邻字符对的全局频率
    """</span>
    pair_freqs = defaultdict(<span class="hljs-built_in">int</span>)
    <span class="hljs-keyword">for</span> char_seq, freq <span class="hljs-keyword">in</span> word_sequences.items():
        <span class="hljs-comment"># 遍历单个词的字符序列，统计相邻对</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(char_seq) - <span class="hljs-number">1</span>):
            pair = (char_seq[i], char_seq[i+<span class="hljs-number">1</span>])
            pair_freqs[pair] += freq
    <span class="hljs-keyword">return</span> pair_freqs

<span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_highest_freq_pair</span>(<span class="hljs-params">word_sequences, best_pair</span>):
    <span class="hljs-string">"""
    步骤3：合并全局频率最高的字符对（best_pair）
    """</span>
    new_word_sequences = {}
    <span class="hljs-keyword">for</span> char_seq, freq <span class="hljs-keyword">in</span> word_sequences.items():
        new_char_seq = []
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(char_seq):
            <span class="hljs-comment"># 找到可合并的对，合并后跳过下一个字符</span>
            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(char_seq) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (char_seq[i], char_seq[i+<span class="hljs-number">1</span>]) == best_pair:
                merged_token = char_seq[i] + char_seq[i+<span class="hljs-number">1</span>]
                new_char_seq.append(merged_token)
                i += <span class="hljs-number">2</span>  <span class="hljs-comment"># 跳过已合并的下一个字符</span>
            <span class="hljs-keyword">else</span>:
                new_char_seq.append(char_seq[i])
                i += <span class="hljs-number">1</span>
        <span class="hljs-comment"># 更新新的词序列字典</span>
        new_word_sequences[<span class="hljs-built_in">tuple</span>(new_char_seq)] = freq
    <span class="hljs-keyword">return</span> new_word_sequences
</code></pre>
<h3 data-id="heading-7">步骤 3：执行迭代合并（完整训练流程）</h3>
<p>设置预设词汇表大小，执行迭代合并，记录合并规则和最终词汇表：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_bpe</span>(<span class="hljs-params">word_freqs, vocab_size=<span class="hljs-number">10</span></span>):
    <span class="hljs-string">"""
    完整BPE训练流程
    :param word_freqs: 初始词频字典
    :param vocab_size: 预设词汇表大小（需大于初始字符数）
    :return: 合并规则列表、最终词汇表
    """</span>
    <span class="hljs-comment"># 初始化</span>
    word_sequences = init_word_sequences(word_freqs)
    merge_rules = []  <span class="hljs-comment"># 记录所有合并规则（[(a,b), (c,d), ...]）</span>
    <span class="hljs-comment"># 提取初始字符词汇表（去重）</span>
    vocab = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> word_freqs.keys():
        vocab.update(<span class="hljs-built_in">list</span>(word))
    vocab = <span class="hljs-built_in">list</span>(vocab)
    
    <span class="hljs-comment"># 迭代合并，直到达到词汇表大小</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(vocab) &lt; vocab_size:
        <span class="hljs-comment"># 步骤1：统计相邻对频率</span>
        pair_freqs = get_pair_freqs(word_sequences)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pair_freqs:  <span class="hljs-comment"># 无可用合并对，提前终止</span>
            <span class="hljs-keyword">break</span>
        
        <span class="hljs-comment"># 步骤2：找到频率最高的字符对</span>
        best_pair = <span class="hljs-built_in">max</span>(pair_freqs.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]
        
        <span class="hljs-comment"># 步骤3：合并最高频字符对</span>
        word_sequences = merge_highest_freq_pair(word_sequences, best_pair)
        
        <span class="hljs-comment"># 步骤4：记录合并规则，更新词汇表</span>
        merge_rules.append(best_pair)
        new_token = best_pair[<span class="hljs-number">0</span>] + best_pair[<span class="hljs-number">1</span>]
        vocab.append(new_token)
        
        <span class="hljs-comment"># 打印中间过程（可选，方便观察）</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"合并 <span class="hljs-subst">{best_pair}</span> -&gt; <span class="hljs-subst">{new_token}</span> | 当前词汇表大小：<span class="hljs-subst">{<span class="hljs-built_in">len</span>(vocab)}</span>"</span>)
    
    <span class="hljs-keyword">return</span> merge_rules, vocab, word_sequences

<span class="hljs-comment"># 执行BPE训练，预设词汇表大小为15</span>
merge_rules, final_vocab, final_word_sequences = train_bpe(word_freqs, vocab_size=<span class="hljs-number">15</span>)
</code></pre>
<h3 data-id="heading-8">步骤 4：查看训练结果</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 打印最终结果</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n=== 训练完成 ==="</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"合并规则列表（共<span class="hljs-subst">{<span class="hljs-built_in">len</span>(merge_rules)}</span>条）："</span>)
<span class="hljs-keyword">for</span> idx, rule <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(merge_rules):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  <span class="hljs-subst">{idx+<span class="hljs-number">1</span>}</span>: <span class="hljs-subst">{rule}</span> -&gt; <span class="hljs-subst">{rule[<span class="hljs-number">0</span>]+rule[<span class="hljs-number">1</span>]}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n最终词汇表（共<span class="hljs-subst">{<span class="hljs-built_in">len</span>(final_vocab)}</span>个单元）："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(final_vocab))

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n最终词序列（合并后）："</span>)
<span class="hljs-keyword">for</span> seq, freq <span class="hljs-keyword">in</span> final_word_sequences.items():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  <span class="hljs-subst">{seq}</span>: <span class="hljs-subst">{freq}</span>"</span>)
</code></pre>
<h3 data-id="heading-9">运行结果解读</h3>
<p>运行上述代码后，会看到迭代合并的过程（部分输出如下）：</p>
<pre><code class="hljs language-plaintext" lang="plaintext">合并 ('e', 's') -&gt; es | 当前词汇表大小：9
合并 ('s', 't') -&gt; st | 当前词汇表大小：10
合并 ('e', 'st') -&gt; est | 当前词汇表大小：11
...
</code></pre>
<ol>
<li>合并规则按迭代顺序记录，后续编码时需严格按照该顺序进行子词分割；</li>
<li>最终词汇表包含初始字符（<code>l</code>、<code>o</code>、<code>w</code>等）和合并生成的子词（<code>es</code>、<code>st</code>、<code>est</code>等）；</li>
<li>最终词序列已被合并为更粗粒度的子词单元，减少了冗余，提升了编码效率。</li>
</ol>
<h2 data-id="heading-10">三、关键补充说明</h2>
<ol>
<li>
<p><strong>BPE 的优势</strong>：</p>
<ul>
<li>无监督训练，无需人工标注子词；</li>
<li>有效解决未登录词（OOV）问题，即使遇到新词，也能拆分为基础字符单元；</li>
<li>词汇表大小可控，平衡编码效率和模型复杂度。</li>
</ul>
</li>
<li>
<p><strong>实际应用中的优化</strong>：</p>
<ul>
<li>上述实现为极简版本，实际工业界（如 Hugging Face）的 BPE 实现会优化存储和计算（如用哈希表加速查找）；</li>
<li>通常以「字节」而非「字符」作为初始单元（尤其针对多语言场景），避免字符编码（如 UTF-8）带来的问题；</li>
<li>会添加特殊标记（如<code>&lt;unk&gt;</code>）处理罕见字符。</li>
</ul>
</li>
<li>
<p><strong>解码过程</strong>：</p>
<ul>
<li>解码时只需反向应用合并规则，或将子词单元直接拼接（注意<code>&lt;/w&gt;</code>标记需替换为空格或直接删除）。</li>
</ul>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入浅出 TinyEditor 富文本编辑器系列2：快速开始]]></title>    <link>https://juejin.cn/post/7593600903249625114</link>    <guid>https://juejin.cn/post/7593600903249625114</guid>    <pubDate>2026-01-11T02:46:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593600903249625114" data-draft-id="7593541291012849691" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入浅出 TinyEditor 富文本编辑器系列2：快速开始"/> <meta itemprop="keywords" content="前端,开源,TypeScript"/> <meta itemprop="datePublished" content="2026-01-11T02:46:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端开源星球"/> <meta itemprop="url" content="https://juejin.cn/user/1504599026445150"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入浅出 TinyEditor 富文本编辑器系列2：快速开始
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1504599026445150/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端开源星球
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-11T02:46:32.000Z" title="Sun Jan 11 2026 02:46:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-11
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>你好，我是 Kagol，个人公众号：<code>前端开源星球</code>。</p>
<p>这是《深入浅出 TinyEditor 富文本编辑器系列》的第2篇，完整的系列文章：</p>
<ul>
<li><a href="https://juejin.cn/spost/7593261984189218866" target="_blank" title="https://juejin.cn/spost/7593261984189218866">深入浅出 TinyEditor 富文本编辑器系列1：TinyEditor 是什么</a></li>
</ul>
<p>欢迎使用 TinyEditor - 一款基于 Quill 2.0 构建的强大富文本编辑器，提供了开箱即用的丰富模块和格式。本指南将帮助你快速高效地开始使用 TinyEditor。</p>
<h2 data-id="heading-0">架构概述</h2>
<p>TinyEditor 采用模块化架构，通过自定义模块、格式和主题扩展了 Quill 的功能。核心结构包括：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca43520a29de41f1835c6cb5af8b2f8e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5byA5rqQ5pif55CD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768704391&amp;x-signature=0ohennCTn6eohe%2FPVXXsdulJwDg%3D" alt="模块架构.png" loading="lazy"/></p>
<h2 data-id="heading-1">安装</h2>
<h3 data-id="heading-2">基础设置</h3>
<p>使用 npm 安装 TinyEditor：</p>
<pre><code class="hljs language-bash" lang="bash">npm install @opentiny/fluent-editor
</code></pre>
<p>该包以 ES 模块形式提供，包含所有必要的依赖，包括作为基础的 Quill 2.0。</p>
<h3 data-id="heading-3">项目结构</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e4182b8e8514d0b881f88d81e5ada6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5byA5rqQ5pif55CD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768704391&amp;x-signature=7iEKccb5mhd8rDoVZldu266U79I%3D" alt="项目结构.png" loading="lazy"/></p>
<h2 data-id="heading-4">基本用法</h2>
<h3 data-id="heading-5">最小示例</h3>
<p>创建一个具有最小配置的基础编辑器实例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">FluentEditor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@opentiny/fluent-editor'</span>
 
<span class="hljs-keyword">const</span> editor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FluentEditor</span>(<span class="hljs-string">'#editor'</span>, {
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
})
</code></pre>
<h3 data-id="heading-6">包含多个模块的示例</h3>
<p>这是一个展示配置多个模块的综合设置：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">FluentEditor</span>, { <span class="hljs-title class_">CollaborationModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@opentiny/fluent-editor'</span>

<span class="hljs-comment">// 引入协同编辑相关依赖</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Y <span class="hljs-keyword">from</span> <span class="hljs-string">'yjs'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Awareness</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'y-protocols/awareness'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">QuillBinding</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'y-quill'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">WebsocketProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'y-websocket'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">IndexeddbPersistence</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'y-indexeddb'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">QuillCursors</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'quill-cursors'</span>

<span class="hljs-comment">// 注册协同编辑模块</span>
<span class="hljs-title class_">FluentEditor</span>.<span class="hljs-title function_">register</span>(
  <span class="hljs-string">'modules/collaborative-editing'</span>,
  <span class="hljs-title class_">CollaborationModule</span>,
  <span class="hljs-literal">true</span>,
)

<span class="hljs-keyword">const</span> editor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FluentEditor</span>(<span class="hljs-string">'#editor'</span>, {
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>,
  <span class="hljs-attr">modules</span>: {
    <span class="hljs-attr">toolbar</span>: [
      [{ <span class="hljs-string">'header'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">false</span>] }],
      [<span class="hljs-string">'bold'</span>, <span class="hljs-string">'italic'</span>, <span class="hljs-string">'underline'</span>, <span class="hljs-string">'strike'</span>],
      [{ <span class="hljs-string">'color'</span>: [] }, { <span class="hljs-string">'background'</span>: [] }],
      [{ <span class="hljs-string">'list'</span>: <span class="hljs-string">'ordered'</span>}, { <span class="hljs-string">'list'</span>: <span class="hljs-string">'bullet'</span> }],
      [<span class="hljs-string">'link'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-string">'video'</span>],
      [<span class="hljs-string">'clean'</span>]
    ],
    <span class="hljs-comment">// 配置协同编辑模块</span>
    <span class="hljs-string">'collaborative-editing'</span>: {
        <span class="hljs-attr">deps</span>: {
          Y,
          <span class="hljs-title class_">Awareness</span>,
          <span class="hljs-title class_">QuillBinding</span>,
          <span class="hljs-title class_">QuillCursors</span>,
          <span class="hljs-title class_">WebsocketProvider</span>,
          <span class="hljs-title class_">IndexeddbPersistence</span>,
        },
        <span class="hljs-attr">provider</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'websocket'</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">serverUrl</span>: <span class="hljs-string">'wss://ai.opentiny.design/tiny-editor/'</span>,
            <span class="hljs-attr">roomName</span>: <span class="hljs-string">'tiny-editor-document-demo-roomName'</span>,
          },
        },
        <span class="hljs-attr">awareness</span>: {
          <span class="hljs-attr">state</span>: {
            <span class="hljs-attr">name</span>: <span class="hljs-string">`userId:<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substring(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>)}</span>`</span>,
            <span class="hljs-attr">color</span>: <span class="hljs-string">`rgb(<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">255</span>)}</span>,<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">255</span>)}</span>,<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">255</span>)}</span>)`</span>,
          },
        },
    },
    <span class="hljs-string">'mathlive'</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 需要引入 mathlive 相关依赖</span>
    <span class="hljs-string">'syntax'</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 需要引入 highlight.js 相关依赖</span>
  }
})
</code></pre>
<p>详细配置请参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopentiny.github.io%2Ftiny-editor%2Fdocs%2Fdemo%2Fcollaborative-editing" target="_blank" title="https://opentiny.github.io/tiny-editor/docs/demo/collaborative-editing" ref="nofollow noopener noreferrer">opentiny.github.io/tiny-editor…</a></p>
<h2 data-id="heading-7">可用模块</h2>
<p>TinyEditor 提供了丰富的预注册模块集：</p>













































<table><thead><tr><th>模块</th><th>描述</th><th>用法</th></tr></thead><tbody><tr><td><strong>toolbar</strong></td><td>带有自定义处理器的增强工具栏</td><td><code>toolbar: { container: TOOLBAR_CONFIG }</code></td></tr><tr><td><strong>image</strong></td><td>支持格式化的高级图片处理</td><td><code>image: true</code></td></tr><tr><td><strong>collaborative-editing</strong></td><td>实时协作</td><td>参见上面的协作示例</td></tr><tr><td><strong>mathlive</strong></td><td>LaTeX 数学公式</td><td><code>mathlive: true</code></td></tr><tr><td><strong>syntax</strong></td><td>代码语法高亮</td><td><code>syntax: true</code></td></tr><tr><td><strong>emoji</strong></td><td>表情选择器和支持</td><td><code>emoji: true</code></td></tr><tr><td><strong>mention</strong></td><td>@提及功能</td><td><code>mention: true</code></td></tr></tbody></table>
<h2 data-id="heading-8">配置选项</h2>
<p>编辑器接受扩展了 Quill 选项的综合配置对象：</p>









































<table><thead><tr><th>选项</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>modules</code></td><td><code>IEditorModules</code></td><td><code>{}</code></td><td>模块配置</td></tr><tr><td><code>scrollingContainer</code></td><td><code>HTMLElement</code> | <code>string</code> | <code>null</code></td><td><code>body</code></td><td>自定义滚动容器</td></tr><tr><td><code>autoProtocol</code></td><td><code>boolean</code> | <code>string</code></td><td><code>false</code></td><td>自动为链接添加协议</td></tr><tr><td><code>editorPaste</code></td><td><code>any</code></td><td><code>undefined</code></td><td>自定义粘贴处理</td></tr><tr><td><code>screenshot</code></td><td><code>Partial&lt;ScreenShotOptions&gt;</code></td><td><code>undefined</code></td><td>截图配置</td></tr></tbody></table>
<h2 data-id="heading-9">快速开始模板</h2>
<p>这是一个可用于快速原型设计的即用型 HTML 模板（可直接复制到 HTML 文件中运行）：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>TinyEditor Quick Start<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-id">#editor</span> { 
      <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>; 
      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;
      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 引入 @opentiny/fluent-editor --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"importmap"</span>&gt;</span><span class="javascript">
    {
      <span class="hljs-string">"imports"</span>: {
        <span class="hljs-string">"@opentiny/fluent-editor"</span>: <span class="hljs-string">"https://unpkg.com/@opentiny/fluent-editor@3.18.3/index.es.js"</span>
      }
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 引入 @opentiny/fluent-editor 样式 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unpkg.com/@opentiny/fluent-editor@3.18.3/style.css"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"editor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">import</span> <span class="hljs-title class_">FluentEditor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@opentiny/fluent-editor'</span>
    
    <span class="hljs-keyword">const</span> editor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FluentEditor</span>(<span class="hljs-string">'#editor'</span>, {
      <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>,
      <span class="hljs-attr">modules</span>: {
        <span class="hljs-attr">toolbar</span>: [
          [<span class="hljs-string">'bold'</span>, <span class="hljs-string">'italic'</span>, <span class="hljs-string">'underline'</span>],
          [{ <span class="hljs-string">'list'</span>: <span class="hljs-string">'ordered'</span>}, { <span class="hljs-string">'list'</span>: <span class="hljs-string">'bullet'</span> }],
          [<span class="hljs-string">'link'</span>, <span class="hljs-string">'image'</span>],
          [<span class="hljs-string">'clean'</span>]
        ]
      }
    })
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>效果图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c54419305d3484c910df28726116c7b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5byA5rqQ5pif55CD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768704391&amp;x-signature=R09cn%2FxUXM5BcmqZA5jxwdicIzs%3D" alt="项目效果图.png" loading="lazy"/></p>
<p>TinyEditor 类扩展了 Quill 的核心功能，同时保持与现有 Quill 配置的兼容性。这确保了现有 Quill 用户的平滑迁移路径，同时提供了对 TinyEditor 增强功能集的访问。</p>
<p>后续将全面介绍 TinyEditor 如何使用、设计架构、实现原理、二次开发等内容，点个关注，不迷路。</p>
<h2 data-id="heading-10">联系我们</h2>
<p>GitHub：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-editor" target="_blank" title="https://github.com/opentiny/tiny-editor" ref="nofollow noopener noreferrer">github.com/opentiny/ti…</a>（欢迎 Star ⭐）</p>
<p>官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopentiny.github.io%2Ftiny-editor" target="_blank" title="https://opentiny.github.io/tiny-editor" ref="nofollow noopener noreferrer">opentiny.github.io/tiny-editor</a></p>
<p>个人博客：<a href="https://link.juejin.cn?target=https%3A%2F%2Fkagol.github.io%2Fblogs%2F" target="_blank" title="https://kagol.github.io/blogs/" ref="nofollow noopener noreferrer">kagol.github.io/blogs/</a></p>
<p>小助手微信：opentiny-official</p>
<p>公众号：OpenTiny</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI最大的改变可能不是写代码而是搜索]]></title>    <link>https://juejin.cn/post/7593241698370945060</link>    <guid>https://juejin.cn/post/7593241698370945060</guid>    <pubDate>2026-01-11T02:54:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593241698370945060" data-draft-id="7593292445300686867" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI最大的改变可能不是写代码而是搜索"/> <meta itemprop="keywords" content="后端,Java,人工智能"/> <meta itemprop="datePublished" content="2026-01-11T02:54:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="9号达人"/> <meta itemprop="url" content="https://juejin.cn/user/2450136052270077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI最大的改变可能不是写代码而是搜索
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2450136052270077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    9号达人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-11T02:54:38.000Z" title="Sun Jan 11 2026 02:54:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-11
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>又到了一年一度的年终总结季。现在应该叫去年了，相信大家或多或少都会带上ai这个关键词。</p>
<p>如果让我选今年最大的改变，不是写代码，不是生图，而是搜索。</p>
<p>AI让搜索这个能力，彻底平权了。</p>
<h2 data-id="heading-0">以前，搜索质量取决于你的知识面</h2>
<p>做程序员这些年，我们会明白很多时候</p>
<p><strong>搜索的好坏，取决于你的知识面。</strong></p>
<p>什么是搜索？</p>
<p>不是在Google或bing（我是真不太想提百度）输入几个关键词。</p>
<p><strong>搜索是对一个问题，多角度收集信息，最终找到能解决问题的方案，或者能推导出解法的方案。</strong></p>
<p>问题是，多角度收集信息，前提是你得知道有哪些角度。</p>
<p>你知识面广，知道从哪些角度切入，知道去哪些网站找（Stack Overflow、GitHub、官方文档），会用搜索指令（<code>site:</code>、<code>filetype:</code>、<code>-</code>排除关键词），能根据一个相似的解法举一反三。</p>
<p>那你搜索质量就高。</p>
<p>你知识面窄，搜索角度单一，只知道百度，只会输入几个关键词，结果不对又换几个词试。</p>
<p>那你很多时候越搜越偏，找不到方向。</p>
<p><strong>知识面决定了搜索的上限。</strong></p>
<p>你的信息圈子有多大，你能搜到的信息就有多全。你不知道的东西，你连搜都不知道怎么搜。</p>
<p>但今年用AI用多了，发现这个逻辑变了。</p>
<h2 data-id="heading-1">AI出现后，搜索方式变了</h2>
<p>今年我用AI搜索的频率明显变高了。</p>
<p>遇到问题，第一反应不是打开Google，而是问ChatGPT、Claude、Perplexity。</p>
<p>为什么？</p>
<p><strong>因为AI的知识面比任何人都广，渠道也比任何人都多。</strong></p>
<p>举个例子。有一次我想在阿里云服务器上下一个Docker镜像。</p>
<p>先是按老路径搜：</p>
<ol>
<li>Google搜"阿里云 Docker 镜像下载慢"</li>
<li>找到几篇教程，说配置国内镜像源</li>
<li>按教程配好了，还是下不下来</li>
<li>换关键词"Docker 镜像源 配置"，又试了几个源</li>
<li>还是不行，想说在本机Docker Desktop先下好再上传</li>
<li>结果Docker Desktop突然打不开了</li>
<li>继续搜"Docker Desktop 打不开"，试了几个方法</li>
<li>死磕了半天，还是卡在这</li>
</ol>
<p>这时候我已经不知道该搜什么了。我能想到的方法都试过了。</p>
<p>用AI呢？</p>
<p>我直接把情况描述给AI：</p>
<blockquote>
<p>"我在阿里云上下Docker镜像，配了国内源还是下不下来。本机Docker Desktop又打不开，没法先下好再上传。有没有其他办法？"</p>
</blockquote>
<p>AI几秒钟给出了一个方案：</p>
<ul>
<li>GitHub支持在线打开VSCode（Codespaces）</li>
<li>这是个云端的开发环境，可以直接运行Docker</li>
<li>在那里下载镜像到本地</li>
<li>再从本地传到阿里云上</li>
</ul>
<p>这个方案我<strong>压根不知道</strong>。</p>
<p>我根本不知道GitHub还能直接打开VSCode，还能当云服务器用。以前搜索，我只会搜"Docker镜像下载"、"镜像源配置"，怎么也搜不到这个方向。</p>
<p><strong>因为我不知道，所以我连搜都不知道怎么搜。</strong></p>
<p>但AI知道。它给出的方案，直接跳出了我的知识圈子。</p>
<h2 data-id="heading-2">为什么差这么多？</h2>
<h3 data-id="heading-3">1. 知识面</h3>
<p>以前：</p>
<ul>
<li>你知道什么关键词,就搜什么</li>
<li>你知道哪些网站，就去哪些网站找</li>
<li>知识面决定了搜索的广度</li>
</ul>
<p>AI：</p>
<ul>
<li>知道所有可能相关的概念</li>
<li>能从多个角度分析问题</li>
<li>知识面远超任何人</li>
</ul>
<h3 data-id="heading-4">2. 搜索渠道</h3>
<p>以前：</p>
<ul>
<li>Google、Stack Overflow、GitHub、官方文档</li>
<li>每个渠道单独搜，信息分散</li>
<li>要自己整合</li>
</ul>
<p>AI：</p>
<ul>
<li>已经"读过"这些网站</li>
<li>直接给出综合答案</li>
<li>不用跳转多个网站</li>
</ul>
<h3 data-id="heading-5">3. 理解能力</h3>
<p>以前：</p>
<ul>
<li>只能匹配关键词</li>
<li>"Docker镜像下载"、"镜像源配置"，搜不到"GitHub云服务器"</li>
<li>你得自己想各种关键词组合</li>
<li><strong>你不知道的方案，你连关键词都想不出来</strong></li>
</ul>
<p>AI：</p>
<ul>
<li>理解你的困境</li>
<li>能跳出你的知识圈子，给出你可能不知道的方案</li>
</ul>
<h2 data-id="heading-6">现在，搜索质量取决于你的描述能力</h2>
<p>AI搜索最大的改变不是快。</p>
<p>是<strong>决定因素变了</strong>。</p>
<p>以前，搜索质量取决于你的知识面。知识面窄，搜索就受限。</p>
<p>现在，搜索质量取决于你的描述能力。</p>
<p>只要会描述问题，AI几次对话就能给出方案。不需要知道专业术语，不需要知道搜索指令，不需要知道去哪个网站。</p>
<p><strong>从"知识面"到"描述能力"，这是搜索的平权。</strong></p>
<p>更重要的是，AI还能反过来扩充你的知识面。</p>
<p>以前，你不知道的东西，你连搜都不知道怎么搜。你的信息圈子就那么大，很难突破。</p>
<p>就像这次下Docker镜像。我的知识圈子里只有"配置镜像源"、"本地下载再上传"这些方法。我压根不知道GitHub能直接打开VSCode当云服务器用，自然也搜不到这个方案。</p>
<p>现在不一样了。</p>
<p>你问AI一个问题，AI的回答里可能会带出一些你不知道的概念、不知道的工具、不知道的方法。</p>
<p>那次之后，我知道了GitHub Codespaces，知道了可以用云服务器中转下载，知道了镜像仓库的另一种用法。</p>
<p>你顺着这些线索继续问，知识面就被拓宽了。</p>
<p><strong>AI在帮你搜索的同时，也在打破你的信息圈子。</strong></p>
<p>这才是最大的价值。这样的例子很多很多。</p>
<p>当然AI也不是万能的。特别偏门的问题，它也答不上来。但常见问题，已经够用了。</p>
<h2 data-id="heading-7">写在最后</h2>
<p>今年最大的感受：<strong>AI让搜索变简单了。</strong></p>
<p>不是说传统搜索不重要。是门槛降低了，不会搜索的人也能快速找到答案。</p>
<p>这是好事。</p>
<p>技术的价值不在于制造门槛，而在于降低门槛。而AI搜索做到了。</p>
<p>但是现在我相信只是一个过渡，未来的搜索又是什么样的，我也不知道。但我知道目前ai让搜索变简单了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI 时代的减法生活：我为什么不再追逐新工具了]]></title>    <link>https://juejin.cn/post/7593528990846369843</link>    <guid>https://juejin.cn/post/7593528990846369843</guid>    <pubDate>2026-01-10T14:48:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593528990846369843" data-draft-id="7593311347292307483" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI 时代的减法生活：我为什么不再追逐新工具了"/> <meta itemprop="keywords" content="AI编程,AIGC"/> <meta itemprop="datePublished" content="2026-01-10T14:48:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿衡Eve"/> <meta itemprop="url" content="https://juejin.cn/user/254742428393310"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI 时代的减法生活：我为什么不再追逐新工具了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/254742428393310/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿衡Eve
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T14:48:10.000Z" title="Sat Jan 10 2026 14:48:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">AI 时代的减法生活：我为什么不再追逐新工具了</h2>
<p>🐒 大家好，我是阿衡，一年经验用了十次的游戏后端开发，辞职后成为自由职业、独立游戏开发者。
非专业 AI 玩家，日常关注 AI 编程方向的内容。</p>
<hr/>
<p>昨天晚上整理电脑的时候，我突然意识到一个问题。</p>
<p>打开微信收藏、cubox，里面躺着 100 多个「稍后阅读」的 AI 相关文章。点开桌面，十几个刚下载没两天的 AI 应用图标静静地待在那里。再看看我的笔记软件，密密麻麻记录着各种工具的使用方法，但每一条笔记都只有标题，内容区空空如也。</p>
<p>我好像得了一种病，叫 <strong>「AI 工具收集癖」</strong> 。</p>
<hr/>
<h3 data-id="heading-1">拿着锤子找钉子</h3>
<p>这两年 AI 发展太快了。几乎每周都有新工具发布，每个月都有重大突破。我像所有关注 AI 的人一样，生怕错过什么重要的东西，于是疯狂地订阅、收藏、下载。</p>
<p>ChatGPT、Claude、Gemini 都得试试。Cursor、Claude Code、GitHub Copilot 一个都不能少。Midjourney、Stable Diffusion、ComfyUI 也要了解一下。还有各种 Chrome 插件、VS Code 扩展、命令行工具……
<strong>我以为自己在学习，其实只是在收集。</strong></p>
<p>每次看到有人分享新工具，我都会想「这个好像很有用」，然后马上加入收藏夹。可真要用的时候，我却发现自己根本不知道该在什么场景下使用它。<strong>就像拿着一把锤子，到处找钉子。</strong> 找到钉子了吗？没有。钉子本来就不存在，是我硬生生想象出来的需求。</p>
<p>更可怕的是，这种状态让我越来越焦虑。看到别人用某个工具做出了很酷的东西，我就会想「我是不是也应该学一学」。可学来学去，每个工具都只是浅尝辄止，一个都没真正掌握。</p>
<p><strong>我开始怀疑自己是不是跟不上时代了。</strong></p>
<hr/>
<h3 data-id="heading-2">转折点</h3>
<p>那天我准备写一篇项目提纲， 打开电脑，我习惯性地开始纠结：「用 ChatGPT 帮我起草大纲吧，还是用 Claude 更好？ Gemini 写文档还挺强的呢！要不要试试新出的那个写作Skill？对了，我收藏的那个 AI 文章生成工具还没用过……」</p>
<p>纠结了半个小时，我一个字都没写出来。</p>
<p>那一刻我突然意识到，我已经完全本末倒置了。写提纲的目的是为了梳理项目脉络，而不是研究哪个 AI 工具更适合写作。<strong>我在「选工具」上花的时间，已经远远超过了「做事情」本身。</strong></p>
<p>我关掉了所有的 AI 工具，开始自己写。写完之后，我用最熟悉的 Claude 帮我润色了一下语言。整个过程行云流水，文章质量也比我预期的要好。</p>
<p>这件事让我开始反思：<strong>我真的需要这么多工具吗？</strong></p>
<hr/>
<h3 data-id="heading-3">做减法</h3>
<p>反思之后，我做了一个决定：开始做减法。</p>
<p>不再关注每天有什么新工具发布，不再收藏任何「以后可能会用到」的文章。我要先搞清楚自己到底需要什么，然后只选择一个工具，把它用到极致。</p>
<p><strong>第一步是列出我真实的痛点。</strong> 不看什么工具火，也不管别人在用什么，就问自己一个问题：我每天的工作生活中，到底哪里最痛？</p>
<p>想了很久，我发现其实痛点没那么多。写技术文章确实费时间，Debug 效率确实不够高，整理学习笔记确实很麻烦。但仔细想想，这些问题其实都可以用一个工具解决，那就是 Claude Code。</p>
<p>我决定就用它。不试别的了，就专注研究怎么用 Claude Code 解决我的实际问题。</p>
<p><strong>第二步是给自己设定规则：一个痛点，一个工具，深度使用一个月。</strong></p>
<p>这一个月里，我不再追新工具，不再看什么「XX 工具全面测评」。我只做一件事：把 Claude Code 用到极致。怎么用它帮我生成文章框架？怎么让它理解我的代码上下文？怎么用它快速定位 Bug？怎么让它生成更符合我风格的文字？</p>
<p>这些问题，以前我都是浅尝辄止的。但当我沉下心来，真正花时间去研究一个工具的时候，我发现它能做的事情远比我想象的要多。</p>
<hr/>
<h3 data-id="heading-4">状态变化</h3>
<p>从我做出这个决定起，我的状态发生了明显的变化。</p>
<p>焦虑感少了很多。不再每天刷工具榜单，不再看到新东西就慌张。我知道我手上这个工具已经够用了，甚至我还没完全挖掘出它的潜力。</p>
<p>效率提升了不少。Claude Code 用得越来越顺手，很多以前需要手动处理的事情，现在几句话就能搞定。写文章的时间从两小时缩短到了一小时，Debug 的速度也快了一倍。</p>
<p>最重要的是，成就感回来了。我真正解决了实际问题，而不是在表面功夫上浪费时间。我开始感觉到，<strong>我是在「用」AI 工具，而不是被工具「用」。</strong></p>
<p>这让我想起了一句话：
<strong>深度，永远比广度更有价值。</strong></p>
<hr/>
<h3 data-id="heading-5">需求驱动，而不是工具驱动</h3>
<p>这段经历让我明白了一个道理：<strong>我们应该用需求驱动工具选择，而不是用工具驱动需求创造。</strong></p>
<p>以前我是这样的：看到一个新工具，先收藏，然后想「我能用它做什么」。这是工具驱动的思维方式，本质上是在为工具找应用场景，而不是为问题找解决方案。</p>
<p>现在我变成了这样：遇到一个问题，先思考「我需要什么能力来解决它」，然后去找对应的工具。如果现有的工具已经够用，就不再添加新的。这是需求驱动的思维方式，更加务实，也更加高效。</p>
<p>说实话，这个转变不容易。因为我们生活在一个信息爆炸的时代，每天都有无数的新东西在诱惑我们。「不学就会落后」的焦虑感一直在驱使着我们不停地追逐新事物。</p>
<p>但我现在明白了，真正的落后不是不知道最新的工具，而是连手上的工具都没用明白。</p>
<p><strong>❗️AI 时代最大的陷阱，不是学得慢，而是学得太杂。</strong></p>
<hr/>
<h3 data-id="heading-6">聚焦自己的场景</h3>
<p>还有一个很重要的感悟：<strong>要聚焦自己的场景，而不是盲目跟风。</strong></p>
<p>每个人的工作场景、生活方式、思维习惯都不一样。别人觉得好用的工具，不一定适合你。别人需要解决的问题，也不一定是你的痛点。</p>
<p>我是独立游戏开发者，我的主要需求是写代码、Debug、写文章、整理笔记。所以对我来说，Claude Code 已经足够了。</p>
<p>关键是要搞清楚自己真正需要什么，而不是看别人用什么就跟着用什么。</p>
<p>我见过太多人，收藏夹里装着上百个工具，却连一个都没用好。他们不是不努力，而是太分散了。精力是有限的，你不可能把每个工具都研究透。</p>
<p>与其这样，不如聚焦一个场景，选一个工具，深度使用。把它用到极致，解决你 80% 的问题。这比你浅尝辄止地试 100 个工具要有效得多。</p>
<hr/>
<h3 data-id="heading-7">实践，而不是收藏</h3>
<p>最后一个感悟：<strong>要立刻实践，而不是先收藏。</strong></p>
<p>以前看到一篇好文章，我的第一反应是「先收藏，以后再看」。结果收藏夹里积累了几百篇文章，真正看的不到十分之一。</p>
<p>现在我改变了策略：看到一篇文章，要么立刻实践，要么直接放弃。没有中间状态，没有「以后再说」。</p>
<p>这个方法看起来很激进，但实际上非常有效。因为大部分时候，「以后」永远不会来。你收藏的东西，90% 都不会再打开。与其让它们静静地躺在收藏夹里制造焦虑，不如一开始就做个决定：这个东西对我有用吗？有用就马上试，没用就直接跳过。</p>
<p>同样的道理也适用于工具。看到一个新工具，不要急着下载安装。先问自己：它能解决我现在遇到的什么问题？如果答案是「说不清」或者「以后可能会用到」，那就先别碰它。等你真正遇到了对应的问题，再去研究也不迟。</p>
<p>GPT-5 出了？先别急着试。问问自己：我现在用的工具够不够用？如果够用，就没必要换。如果不够用，先搞清楚哪里不够用，再判断新工具能不能解决这个问题。</p>
<hr/>
<h3 data-id="heading-8">写在最后</h3>
<p>从「工具收集狂」到「减法生活」，这个转变让我重新找回了对 AI 工具的掌控感。</p>
<p>AI 工具是用来解决问题的，不是用来制造焦虑的。你不需要掌握所有工具，你只需要解决自己的问题。</p>
<p><strong>与其拿着锤子到处找钉子，不如先看清自己的钉子在哪里。
少即是多，聚焦才是王道。</strong></p>
<p>如果你也有 AI 焦虑，不妨试试做减法。列出三个你最痛的实际问题，每个问题只选一个工具，深度使用一个月。解决了，再换下一个。</p>
<p><strong>💡慢慢来，比较快</strong></p>
<hr/>
<p>💬 你平时是怎么选择和使用 AI 工具的？欢迎在评论区分享你的方法和感悟。</p>
<p>👍 觉得有用的话，记得点赞收藏，让更多人看到这篇文章。</p>
<p>我们下期见。</p>
<hr/>
<ul>
<li>#公众号：阿衡的AI日常</li>
<li>小红书：阿衡的AI日常</li>
<li>#CSDN：DebugEve</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[机器学习核心算法全景解析：从原理到实战]]></title>    <link>https://juejin.cn/post/7593600903249379354</link>    <guid>https://juejin.cn/post/7593600903249379354</guid>    <pubDate>2026-01-11T01:32:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593600903249379354" data-draft-id="7593375360554795058" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="机器学习核心算法全景解析：从原理到实战"/> <meta itemprop="keywords" content="机器学习"/> <meta itemprop="datePublished" content="2026-01-11T01:32:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            机器学习核心算法全景解析：从原理到实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-11T01:32:56.000Z" title="Sun Jan 11 2026 01:32:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-11
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言：走进智能时代的核心引擎</h2>
<p>各位读者朋友，大家好！在这个数据爆炸的时代，机器学习已经悄然渗透到我们生活的方方面面——从手机的人脸识别、电商的推荐系统，到自动驾驶、医疗诊断，无不闪耀着机器学习算法的智慧光芒。今天，我将带大家深入探索机器学习的核心算法世界，不仅详细解析原理，还会附上实际代码示例和流程图，让你真正掌握这些改变世界的技术！</p>
<h2 data-id="heading-1">一、机器学习算法分类全景图</h2>
<pre><code class="hljs">机器学习算法监督学习无监督学习半监督学习强化学习分类算法回归算法逻辑回归决策树随机森林支持向量机朴素贝叶斯神经网络聚类算法降维算法K-means层次聚类DBSCANPCAt-SNE
</code></pre>
<h2 data-id="heading-2">二、监督学习：有导师的智能训练</h2>
<h3 data-id="heading-3">1. 线性回归：预测的基础支柱</h3>
<p><strong>算法原理</strong>：寻找特征与目标之间的线性关系</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error, r2_score

<span class="hljs-comment"># 生成示例数据</span>
np.random.seed(<span class="hljs-number">42</span>)
X = <span class="hljs-number">2</span> * np.random.rand(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)
y = <span class="hljs-number">4</span> + <span class="hljs-number">3</span> * X + np.random.randn(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)

<span class="hljs-comment"># 划分数据集</span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 创建模型并训练</span>
model = LinearRegression()
model.fit(X_train, y_train)

<span class="hljs-comment"># 预测</span>
y_pred = model.predict(X_test)

<span class="hljs-comment"># 评估模型</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"截距: <span class="hljs-subst">{model.intercept_}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"系数: <span class="hljs-subst">{model.coef_}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"均方误差: <span class="hljs-subst">{mean_squared_error(y_test, y_pred):<span class="hljs-number">.2</span>f}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"R²分数: <span class="hljs-subst">{r2_score(y_test, y_pred):<span class="hljs-number">.2</span>f}</span>"</span>)

<span class="hljs-comment"># 可视化结果</span>
plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.scatter(X_test, y_test, color=<span class="hljs-string">'blue'</span>, label=<span class="hljs-string">'实际值'</span>)
plt.plot(X_test, y_pred, color=<span class="hljs-string">'red'</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">'预测值'</span>)
plt.xlabel(<span class="hljs-string">'特征X'</span>)
plt.ylabel(<span class="hljs-string">'目标y'</span>)
plt.title(<span class="hljs-string">'线性回归预测结果'</span>)
plt.legend()
plt.show()
</code></pre>
<p><strong>流程图解</strong>：</p>
<pre><code class="hljs">数据准备 → 计算损失函数 → 梯度下降优化 → 更新权重参数 → 重复直到收敛 → 得到最佳拟合直线
</code></pre>
<h3 data-id="heading-4">2. 逻辑回归：分类的经典算法</h3>
<p>虽然名字中有"回归"，但逻辑回归实际上是处理二分类问题的利器。</p>
<pre><code class="hljs language-ini" lang="ini">import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc

<span class="hljs-comment"># 创建分类数据集</span>
X, <span class="hljs-attr">y</span> = make_classification(n_samples=<span class="hljs-number">1000</span>, n_features=<span class="hljs-number">2</span>, n_informative=<span class="hljs-number">2</span>,
                           <span class="hljs-attr">n_redundant</span>=<span class="hljs-number">0</span>, n_clusters_per_class=<span class="hljs-number">1</span>,
                           <span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 划分数据集</span>
X_train, X_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(X, y, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 创建逻辑回归模型</span>
<span class="hljs-attr">log_reg</span> = LogisticRegression()
log_reg.fit(X_train, y_train)

<span class="hljs-comment"># 预测</span>
<span class="hljs-attr">y_pred</span> = log_reg.predict(X_test)
<span class="hljs-attr">y_pred_proba</span> = log_reg.predict_proba(X_test)[:, <span class="hljs-number">1</span>]

<span class="hljs-comment"># 评估模型</span>
print("分类报告:")
print(classification_report(y_test, y_pred))

print("\n混淆矩阵:")
print(confusion_matrix(y_test, y_pred))

<span class="hljs-comment"># ROC曲线</span>
fpr, tpr, <span class="hljs-attr">thresholds</span> = roc_curve(y_test, y_pred_proba)
<span class="hljs-attr">roc_auc</span> = auc(fpr, tpr)

plt.figure(<span class="hljs-attr">figsize</span>=(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>))
plt.subplot(1, 2, 1)
plt.scatter(X_test<span class="hljs-section">[:, 0]</span>, X_test<span class="hljs-section">[:, 1]</span>, <span class="hljs-attr">c</span>=y_test, cmap=<span class="hljs-string">'coolwarm'</span>, alpha=<span class="hljs-number">0.6</span>)
plt.title('测试集数据分布')

plt.subplot(1, 2, 2)
plt.plot(fpr, tpr, <span class="hljs-attr">color</span>=<span class="hljs-string">'darkorange'</span>, lw=<span class="hljs-number">2</span>, label=f<span class="hljs-string">'ROC曲线 (AUC = {roc_auc:.2f})'</span>)
plt.plot(<span class="hljs-section">[0, 1]</span>, <span class="hljs-section">[0, 1]</span>, <span class="hljs-attr">color</span>=<span class="hljs-string">'navy'</span>, lw=<span class="hljs-number">2</span>, linestyle=<span class="hljs-string">'--'</span>)
plt.xlabel('假正率')
plt.ylabel('真正率')
plt.title('ROC曲线')
plt.legend()
plt.tight_layout()
plt.show()
</code></pre>
<h3 data-id="heading-5">3. 决策树：直观的可解释模型</h3>
<p>决策树通过一系列规则对数据进行分类，非常直观易懂。</p>
<pre><code class="hljs language-ini" lang="ini">from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

<span class="hljs-comment"># 加载鸢尾花数据集</span>
<span class="hljs-attr">iris</span> = load_iris()
<span class="hljs-attr">X</span> = iris.data
<span class="hljs-attr">y</span> = iris.target
<span class="hljs-attr">feature_names</span> = iris.feature_names
<span class="hljs-attr">class_names</span> = iris.target_names

<span class="hljs-comment"># 划分数据集</span>
X_train, X_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(X, y, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 创建决策树模型</span>
<span class="hljs-attr">tree_clf</span> = DecisionTreeClassifier(max_depth=<span class="hljs-number">3</span>, random_state=<span class="hljs-number">42</span>)
tree_clf.fit(X_train, y_train)

<span class="hljs-comment"># 评估模型</span>
<span class="hljs-attr">train_score</span> = tree_clf.score(X_train, y_train)
<span class="hljs-attr">test_score</span> = tree_clf.score(X_test, y_test)

print(f"训练集准确率: {train_score:.2f}")
print(f"测试集准确率: {test_score:.2f}")

<span class="hljs-comment"># 可视化决策树</span>
plt.figure(<span class="hljs-attr">figsize</span>=(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>))
plot_tree(tree_clf, 
          <span class="hljs-attr">feature_names</span>=feature_names,
          <span class="hljs-attr">class_names</span>=class_names,
          <span class="hljs-attr">filled</span>=<span class="hljs-literal">True</span>,
          <span class="hljs-attr">rounded</span>=<span class="hljs-literal">True</span>)
plt.title("决策树可视化")
plt.show()
</code></pre>
<p><strong>决策树构建流程</strong>：</p>
<pre><code class="hljs">开始
    ↓
选择最佳分裂特征（使用基尼指数或信息增益）
    ↓
根据特征阈值分割数据
    ↓
对每个子集重复上述过程
    ↓
达到停止条件（深度限制、样本数最小等）
    ↓
生成叶节点，确定类别
    ↓
结束
</code></pre>
<h3 data-id="heading-6">4. 随机森林：集体的智慧</h3>
<p>随机森林通过构建多个决策树并综合它们的预测结果，显著提升了模型的准确性和稳定性。</p>
<pre><code class="hljs language-ini" lang="ini">from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split, cross_val_score
import numpy as np
import matplotlib.pyplot as plt

<span class="hljs-comment"># 创建复杂数据集</span>
X, <span class="hljs-attr">y</span> = make_classification(n_samples=<span class="hljs-number">1000</span>, n_features=<span class="hljs-number">20</span>, n_informative=<span class="hljs-number">15</span>,
                           <span class="hljs-attr">n_classes</span>=<span class="hljs-number">3</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 划分数据集</span>
X_train, X_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(X, y, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 创建随机森林模型</span>
<span class="hljs-attr">rf_clf</span> = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>,  <span class="hljs-comment"># 树的数量</span>
                                <span class="hljs-attr">max_depth</span>=<span class="hljs-number">10</span>,      <span class="hljs-comment"># 最大深度</span>
                                <span class="hljs-attr">min_samples_split</span>=<span class="hljs-number">5</span>, <span class="hljs-comment"># 最小分裂样本数</span>
                                <span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 训练模型</span>
rf_clf.fit(X_train, y_train)

<span class="hljs-comment"># 评估模型</span>
<span class="hljs-attr">accuracy</span> = rf_clf.score(X_test, y_test)
print(f"随机森林测试集准确率: {accuracy:.2f}")

<span class="hljs-comment"># 交叉验证</span>
<span class="hljs-attr">cv_scores</span> = cross_val_score(rf_clf, X, y, cv=<span class="hljs-number">5</span>)
print(f"交叉验证平均得分: {cv_scores.mean():.2f} (+/- {cv_scores.std() * 2:.2f})")

<span class="hljs-comment"># 特征重要性分析</span>
<span class="hljs-attr">feature_importance</span> = rf_clf.feature_importances_
<span class="hljs-attr">indices</span> = np.argsort(feature_importance)[::-<span class="hljs-number">1</span>]

plt.figure(<span class="hljs-attr">figsize</span>=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))
plt.title("特征重要性排序")
plt.bar(range(X.shape<span class="hljs-section">[1]</span>), feature_importance<span class="hljs-section">[indices]</span>)
plt.xlabel("特征索引")
plt.ylabel("重要性得分")
plt.xticks(range(X.shape<span class="hljs-section">[1]</span>), indices)
plt.show()
</code></pre>
<h3 data-id="heading-7">5. 支持向量机（SVM）：寻找最优边界</h3>
<p>SVM通过寻找最大化类别间隔的超平面来进行分类，特别适合高维空间。</p>
<pre><code class="hljs language-ini" lang="ini">import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm
from sklearn.datasets import make_moons
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score

<span class="hljs-comment"># 创建非线性可分数据</span>
X, <span class="hljs-attr">y</span> = make_moons(n_samples=<span class="hljs-number">300</span>, noise=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 数据标准化</span>
<span class="hljs-attr">scaler</span> = StandardScaler()
<span class="hljs-attr">X_scaled</span> = scaler.fit_transform(X)

<span class="hljs-comment"># 划分数据集</span>
X_train, X_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(X_scaled, y, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 创建SVM模型（使用RBF核处理非线性问题）</span>
<span class="hljs-attr">svm_clf</span> = svm.SVC(kernel=<span class="hljs-string">'rbf'</span>,  <span class="hljs-comment"># 径向基函数核</span>
                  <span class="hljs-attr">C</span>=<span class="hljs-number">1.0</span>,         <span class="hljs-comment"># 正则化参数</span>
                  <span class="hljs-attr">gamma</span>=<span class="hljs-string">'scale'</span>, <span class="hljs-comment"># 核系数</span>
                  <span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 训练模型</span>
svm_clf.fit(X_train, y_train)

<span class="hljs-comment"># 预测</span>
<span class="hljs-attr">y_pred</span> = svm_clf.predict(X_test)
<span class="hljs-attr">accuracy</span> = accuracy_score(y_test, y_pred)
print(f"SVM测试集准确率: {accuracy:.2f}")

<span class="hljs-comment"># 可视化决策边界</span>
def plot_decision_boundary(clf, X, y):
    <span class="hljs-attr">h</span> = <span class="hljs-number">0.02</span>  <span class="hljs-comment"># 网格步长</span>
    x_min, <span class="hljs-attr">x_max</span> = X[:, <span class="hljs-number">0</span>].min() - <span class="hljs-number">1</span>, X[:, <span class="hljs-number">0</span>].max() + <span class="hljs-number">1</span>
    y_min, <span class="hljs-attr">y_max</span> = X[:, <span class="hljs-number">1</span>].min() - <span class="hljs-number">1</span>, X[:, <span class="hljs-number">1</span>].max() + <span class="hljs-number">1</span>
    xx, <span class="hljs-attr">yy</span> = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
    
    <span class="hljs-attr">Z</span> = clf.predict(np.c_[xx.ravel(), yy.ravel()])
    <span class="hljs-attr">Z</span> = Z.reshape(xx.shape)
    
    plt.figure(<span class="hljs-attr">figsize</span>=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))
    plt.contourf(xx, yy, Z, <span class="hljs-attr">alpha</span>=<span class="hljs-number">0.3</span>, cmap=<span class="hljs-string">'coolwarm'</span>)
    plt.scatter(X<span class="hljs-section">[:, 0]</span>, X<span class="hljs-section">[:, 1]</span>, <span class="hljs-attr">c</span>=y, cmap=<span class="hljs-string">'coolwarm'</span>, edgecolors=<span class="hljs-string">'k'</span>)
    plt.xlabel('特征1')
    plt.ylabel('特征2')
    plt.title('SVM决策边界可视化')
    plt.show()

plot_decision_boundary(svm_clf, X_train, y_train)
</code></pre>
<h2 data-id="heading-8">三、无监督学习：发现数据的隐藏结构</h2>
<h3 data-id="heading-9">1. K-means聚类：数据分组利器</h3>
<pre><code class="hljs language-ini" lang="ini">import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import StandardScaler

<span class="hljs-comment"># 生成模拟数据</span>
X, <span class="hljs-attr">y_true</span> = make_blobs(n_samples=<span class="hljs-number">300</span>, centers=<span class="hljs-number">4</span>, cluster_std=<span class="hljs-number">0.60</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 数据标准化</span>
<span class="hljs-attr">scaler</span> = StandardScaler()
<span class="hljs-attr">X_scaled</span> = scaler.fit_transform(X)

<span class="hljs-comment"># 使用肘部方法确定最佳K值</span>
<span class="hljs-attr">inertia</span> = []
<span class="hljs-attr">silhouette_scores</span> = []
<span class="hljs-attr">K_range</span> = range(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)

for k in K_range:
    <span class="hljs-attr">kmeans</span> = KMeans(n_clusters=k, random_state=<span class="hljs-number">42</span>, n_init=<span class="hljs-number">10</span>)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_)
    
    if len(set(kmeans.labels_)) &gt; 1:  <span class="hljs-comment"># 确保有多个簇</span>
        silhouette_scores.append(silhouette_score(X_scaled, kmeans.labels_))
    else:
        silhouette_scores.append(0)

<span class="hljs-comment"># 可视化结果</span>
fig, <span class="hljs-attr">axes</span> = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>))

<span class="hljs-comment"># 原始数据</span>
axes<span class="hljs-section">[0]</span>.scatter(X_scaled<span class="hljs-section">[:, 0]</span>, X_scaled<span class="hljs-section">[:, 1]</span>, <span class="hljs-attr">s</span>=<span class="hljs-number">50</span>)
axes<span class="hljs-section">[0]</span>.set_title('原始数据分布')

<span class="hljs-comment"># 肘部法则图</span>
axes<span class="hljs-section">[1]</span>.plot(K_range, inertia, 'bo-')
axes<span class="hljs-section">[1]</span>.set_xlabel('簇数量 K')
axes<span class="hljs-section">[1]</span>.set_ylabel('误差平方和')
axes<span class="hljs-section">[1]</span>.set_title('肘部法则')

<span class="hljs-comment"># 轮廓系数图</span>
axes<span class="hljs-section">[2]</span>.plot(K_range<span class="hljs-section">[:len(silhouette_scores)]</span>, silhouette_scores, 'ro-')
axes<span class="hljs-section">[2]</span>.set_xlabel('簇数量 K')
axes<span class="hljs-section">[2]</span>.set_ylabel('轮廓系数')
axes<span class="hljs-section">[2]</span>.set_title('轮廓系数法')

plt.tight_layout()
plt.show()

<span class="hljs-comment"># 使用最佳K值进行聚类</span>
<span class="hljs-attr">best_k</span> = <span class="hljs-number">4</span>  <span class="hljs-comment"># 根据上图确定</span>
<span class="hljs-attr">kmeans</span> = KMeans(n_clusters=best_k, random_state=<span class="hljs-number">42</span>, n_init=<span class="hljs-number">10</span>)
<span class="hljs-attr">y_pred</span> = kmeans.fit_predict(X_scaled)

<span class="hljs-comment"># 可视化聚类结果</span>
plt.figure(<span class="hljs-attr">figsize</span>=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))
<span class="hljs-attr">colors</span> = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'purple'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'brown'</span>]
for i in range(best_k):
    plt.scatter(X_scaled<span class="hljs-section">[y_pred == i, 0]</span>, 
                X_scaled<span class="hljs-section">[y_pred == i, 1]</span>, 
                <span class="hljs-attr">s</span>=<span class="hljs-number">50</span>, c=colors[i], 
                <span class="hljs-attr">label</span>=f<span class="hljs-string">'簇 {i+1}'</span>)

<span class="hljs-comment"># 绘制聚类中心</span>
plt.scatter(kmeans.cluster_centers_<span class="hljs-section">[:, 0]</span>, 
            kmeans.cluster_centers_<span class="hljs-section">[:, 1]</span>, 
            <span class="hljs-attr">s</span>=<span class="hljs-number">200</span>, c=<span class="hljs-string">'yellow'</span>, marker=<span class="hljs-string">'*'</span>, 
            <span class="hljs-attr">label</span>=<span class="hljs-string">'聚类中心'</span>, edgecolors=<span class="hljs-string">'black'</span>)

plt.xlabel('特征1')
plt.ylabel('特征2')
plt.title('K-means聚类结果')
plt.legend()
plt.show()
</code></pre>
<p><strong>K-means算法流程</strong>：</p>
<pre><code class="hljs">初始化：随机选择K个中心点
    ↓
循环直到收敛：
    ↓
分配阶段：将每个点分配到最近的中心点
    ↓
更新阶段：重新计算每个簇的中心点
    ↓
判断是否收敛（中心点不再变化或达到最大迭代次数）
    ↓
输出：K个簇及其中心点
</code></pre>
<h3 data-id="heading-10">2. 主成分分析（PCA）：数据降维神器</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_digits
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler

<span class="hljs-comment"># 加载手写数字数据集</span>
digits = load_digits()
X = digits.data
y = digits.target

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"原始数据维度: <span class="hljs-subst">{X.shape}</span>"</span>)

<span class="hljs-comment"># 数据标准化</span>
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

<span class="hljs-comment"># 计算主成分</span>
pca = PCA()
X_pca = pca.fit_transform(X_scaled)

<span class="hljs-comment"># 可视化累计方差解释率</span>
plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))
cumulative_variance = np.cumsum(pca.explained_variance_ratio_)

plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)
plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>), pca.explained_variance_ratio_[:<span class="hljs-number">10</span>])
plt.xlabel(<span class="hljs-string">'主成分'</span>)
plt.ylabel(<span class="hljs-string">'方差解释率'</span>)
plt.title(<span class="hljs-string">'前10个主成分的方差解释率'</span>)

plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(cumulative_variance) + <span class="hljs-number">1</span>), cumulative_variance, <span class="hljs-string">'b-'</span>)
plt.xlabel(<span class="hljs-string">'主成分数量'</span>)
plt.ylabel(<span class="hljs-string">'累计方差解释率'</span>)
plt.axhline(y=<span class="hljs-number">0.95</span>, color=<span class="hljs-string">'r'</span>, linestyle=<span class="hljs-string">'--'</span>, label=<span class="hljs-string">'95%方差'</span>)
plt.legend()
plt.title(<span class="hljs-string">'累计方差解释率'</span>)

<span class="hljs-comment"># 使用前两个主成分可视化数据</span>
plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
scatter = plt.scatter(X_pca[:, <span class="hljs-number">0</span>], X_pca[:, <span class="hljs-number">1</span>], c=y, cmap=<span class="hljs-string">'tab10'</span>, alpha=<span class="hljs-number">0.6</span>)
plt.xlabel(<span class="hljs-string">'第一主成分'</span>)
plt.ylabel(<span class="hljs-string">'第二主成分'</span>)
plt.title(<span class="hljs-string">'PCA降维可视化 (2D)'</span>)
plt.colorbar(scatter, label=<span class="hljs-string">'数字标签'</span>)

<span class="hljs-comment"># 使用前三个主成分可视化（3D）</span>
<span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D
ax = plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, projection=<span class="hljs-string">'3d'</span>)
scatter = ax.scatter(X_pca[:, <span class="hljs-number">0</span>], X_pca[:, <span class="hljs-number">1</span>], X_pca[:, <span class="hljs-number">2</span>], c=y, cmap=<span class="hljs-string">'tab10'</span>, alpha=<span class="hljs-number">0.6</span>)
ax.set_xlabel(<span class="hljs-string">'PC1'</span>)
ax.set_ylabel(<span class="hljs-string">'PC2'</span>)
ax.set_zlabel(<span class="hljs-string">'PC3'</span>)
ax.set_title(<span class="hljs-string">'PCA降维可视化 (3D)'</span>)

plt.tight_layout()
plt.show()

<span class="hljs-comment"># 查看降维后的数据信息</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"第一个主成分解释的方差比例: <span class="hljs-subst">{pca.explained_variance_ratio_[<span class="hljs-number">0</span>]:<span class="hljs-number">.2</span>%}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"前两个主成分累计解释的方差比例: <span class="hljs-subst">{cumulative_variance[<span class="hljs-number">1</span>]:<span class="hljs-number">.2</span>%}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"保留95%方差所需的主成分数量: <span class="hljs-subst">{np.argmax(cumulative_variance &gt;= <span class="hljs-number">0.95</span>) + <span class="hljs-number">1</span>}</span>"</span>)
</code></pre>
<h2 data-id="heading-11">四、神经网络：深度学习的基石</h2>
<h3 data-id="heading-12">多层感知机（MLP）：基础神经网络</h3>
<pre><code class="hljs language-ini" lang="ini">import numpy as np
import matplotlib.pyplot as plt
from sklearn.neural_network import MLPClassifier
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, confusion_matrix
import seaborn as sns

<span class="hljs-comment"># 创建复杂数据集</span>
X, <span class="hljs-attr">y</span> = make_classification(n_samples=<span class="hljs-number">1000</span>, n_features=<span class="hljs-number">20</span>, n_informative=<span class="hljs-number">15</span>,
                           <span class="hljs-attr">n_redundant</span>=<span class="hljs-number">2</span>, n_classes=<span class="hljs-number">3</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 数据标准化</span>
<span class="hljs-attr">scaler</span> = StandardScaler()
<span class="hljs-attr">X_scaled</span> = scaler.fit_transform(X)

<span class="hljs-comment"># 划分数据集</span>
X_train, X_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(X_scaled, y, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 创建MLP模型</span>
<span class="hljs-attr">mlp</span> = MLPClassifier(hidden_layer_sizes=(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>),  <span class="hljs-comment"># 两个隐藏层，分别有100和50个神经元</span>
                    <span class="hljs-attr">activation</span>=<span class="hljs-string">'relu'</span>,             <span class="hljs-comment"># 激活函数</span>
                    <span class="hljs-attr">solver</span>=<span class="hljs-string">'adam'</span>,                 <span class="hljs-comment"># 优化算法</span>
                    <span class="hljs-attr">alpha</span>=<span class="hljs-number">0.0001</span>,                  <span class="hljs-comment"># L2正则化参数</span>
                    <span class="hljs-attr">batch_size</span>=<span class="hljs-number">32</span>,                 <span class="hljs-comment"># 批大小</span>
                    <span class="hljs-attr">learning_rate_init</span>=<span class="hljs-number">0.001</span>,      <span class="hljs-comment"># 学习率</span>
                    <span class="hljs-attr">max_iter</span>=<span class="hljs-number">500</span>,                  <span class="hljs-comment"># 最大迭代次数</span>
                    <span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>,
                    <span class="hljs-attr">verbose</span>=<span class="hljs-literal">False</span>)

<span class="hljs-comment"># 训练模型</span>
mlp.fit(X_train, y_train)

<span class="hljs-comment"># 预测</span>
<span class="hljs-attr">y_pred</span> = mlp.predict(X_test)
<span class="hljs-attr">accuracy</span> = accuracy_score(y_test, y_pred)
print(f"MLP测试集准确率: {accuracy:.2f}")

<span class="hljs-comment"># 绘制训练损失曲线</span>
plt.figure(<span class="hljs-attr">figsize</span>=(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>))

plt.subplot(1, 2, 1)
plt.plot(mlp.loss_curve_)
plt.xlabel('迭代次数')
plt.ylabel('损失值')
plt.title('训练损失曲线')

<span class="hljs-comment"># 绘制混淆矩阵</span>
plt.subplot(1, 2, 2)
<span class="hljs-attr">cm</span> = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, <span class="hljs-attr">annot</span>=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">'d'</span>, cmap=<span class="hljs-string">'Blues'</span>)
plt.xlabel('预测标签')
plt.ylabel('真实标签')
plt.title('混淆矩阵')

plt.tight_layout()
plt.show()

<span class="hljs-comment"># 查看模型结构信息</span>
print(f"模型层数: {mlp.n_layers_}")
print(f"模型参数数量: {mlp.coefs_<span class="hljs-section">[0]</span>.shape<span class="hljs-section">[0]</span> * mlp.coefs_<span class="hljs-section">[0]</span>.shape<span class="hljs-section">[1]</span> + mlp.coefs_<span class="hljs-section">[1]</span>.shape<span class="hljs-section">[0]</span> * mlp.coefs_<span class="hljs-section">[1]</span>.shape<span class="hljs-section">[1]</span>}")
</code></pre>
<h2 data-id="heading-13">五、算法选择指南：如何为你的问题选择合适算法</h2>
<h3 data-id="heading-14">算法选择流程图</h3>
<pre><code class="hljs language-ruby" lang="ruby">是

否

连续值

类别

发现结构

降维

是

否

是

否

小量数据

大量数据

是

否

是

否

开始选择算法是否有标签数据<span class="hljs-string">?预</span>测连续值还是类别<span class="hljs-string">?目</span>标是发现结构还是降维<span class="hljs-string">?回</span>归算法分类算法聚类算法降维算法数据线性<span class="hljs-string">?线</span>性回归多项式回归或树模型需要可解释性<span class="hljs-string">?决</span>策树/随机森林数据量大小<span class="hljs-string">?支</span>持向量机神经网络已知簇数量<span class="hljs-string">?K</span>-means聚类层次聚类或<span class="hljs-variable constant_">DBSCAN</span>需要可视化<span class="hljs-string">?t</span>-<span class="hljs-variable constant_">SNE</span>主成分分析
</code></pre>
<h3 data-id="heading-15">各算法关键特点总结表</h3>




































































<table><thead><tr><th>算法</th><th>类型</th><th>主要优势</th><th>适用场景</th><th>注意事项</th></tr></thead><tbody><tr><td><strong>线性回归</strong></td><td>监督/回归</td><td>简单、可解释性强</td><td>预测连续值，特征与目标呈线性关系</td><td>对异常值敏感，假设线性关系</td></tr><tr><td><strong>逻辑回归</strong></td><td>监督/分类</td><td>概率输出，可解释性好</td><td>二分类问题，需要概率估计</td><td>只能处理线性可分问题（核技巧可扩展）</td></tr><tr><td><strong>决策树</strong></td><td>监督/分类</td><td>直观易懂，无需特征缩放</td><td>分类和回归，需要可解释性</td><td>容易过拟合，需要剪枝</td></tr><tr><td><strong>随机森林</strong></td><td>监督/分类</td><td>高准确性，抗过拟合</td><td>复杂分类/回归问题</td><td>计算成本较高，可解释性较差</td></tr><tr><td><strong>SVM</strong></td><td>监督/分类</td><td>高维空间有效，泛化能力强</td><td>小样本、非线性问题</td><td>大规模数据效率低，参数调优重要</td></tr><tr><td><strong>K-means</strong></td><td>无监督/聚类</td><td>简单高效，可扩展性好</td><td>客户分群，图像分割</td><td>需要指定K值，对异常值敏感</td></tr><tr><td><strong>PCA</strong></td><td>无监督/降维</td><td>去除相关性，降低维度</td><td>数据可视化，特征提取</td><td>线性方法，可能丢失非线性结构</td></tr><tr><td><strong>神经网络</strong></td><td>监督/分类回归</td><td>强大拟合能力，特征自动学习</td><td>图像、语音、自然语言处理</td><td>需要大量数据，调参复杂</td></tr></tbody></table>
<h2 data-id="heading-16">六、实战案例：综合应用示例</h2>
<h3 data-id="heading-17">电商用户分群与购买预测系统</h3>
<pre><code class="hljs language-ini" lang="ini">import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

<span class="hljs-comment"># 生成模拟电商数据</span>
np.random.seed(42)
<span class="hljs-attr">n_samples</span> = <span class="hljs-number">1000</span>

<span class="hljs-comment"># 用户特征：年龄、收入、网站访问频率、平均会话时长、购买次数</span>
<span class="hljs-attr">data</span> = {
    '年龄': np.random.randint(18, 70, n_samples),
    '月收入': np.random.randint(2000, 20000, n_samples),
    '访问频率': np.random.poisson(5, n_samples),
    '会话时长': np.random.exponential(10, n_samples),
    '购买次数': np.random.poisson(3, n_samples),
    '平均订单金额': np.random.uniform(20, 500, n_samples),
    '最后购买距今天数': np.random.randint(1, 180, n_samples)
}

<span class="hljs-attr">df</span> = pd.DataFrame(data)

<span class="hljs-comment"># 创建目标变量：是否会再次购买（0/1）</span>
df<span class="hljs-section">['是否再购']</span> = np.where((df<span class="hljs-section">['最后购买距今天数']</span> &lt; 30) &amp; 
                        (df<span class="hljs-section">['购买次数']</span> &gt; 2) &amp; 
                        (df<span class="hljs-section">['平均订单金额']</span> &gt; 100), 1, 0)

print("数据概览:")
print(df.head())
print(f"\n数据形状: {df.shape}")
print(f"\n目标变量分布:\n{df<span class="hljs-section">['是否再购']</span>.value_counts()}")

<span class="hljs-comment"># 1. 用户分群（无监督学习）</span>
<span class="hljs-attr">cluster_features</span> = [<span class="hljs-string">'年龄'</span>, <span class="hljs-string">'月收入'</span>, <span class="hljs-string">'访问频率'</span>, <span class="hljs-string">'会话时长'</span>, <span class="hljs-string">'购买次数'</span>, <span class="hljs-string">'平均订单金额'</span>]
<span class="hljs-attr">X_cluster</span> = df[cluster_features]

<span class="hljs-comment"># 标准化</span>
<span class="hljs-attr">scaler</span> = StandardScaler()
<span class="hljs-attr">X_cluster_scaled</span> = scaler.fit_transform(X_cluster)

<span class="hljs-comment"># 使用K-means分群</span>
<span class="hljs-attr">kmeans</span> = KMeans(n_clusters=<span class="hljs-number">4</span>, random_state=<span class="hljs-number">42</span>, n_init=<span class="hljs-number">10</span>)
df<span class="hljs-section">['用户分群']</span> = kmeans.fit_predict(X_cluster_scaled)

<span class="hljs-comment"># 2. 购买预测（监督学习）</span>
<span class="hljs-attr">predict_features</span> = [<span class="hljs-string">'年龄'</span>, <span class="hljs-string">'月收入'</span>, <span class="hljs-string">'访问频率'</span>, <span class="hljs-string">'会话时长'</span>, 
                    <span class="hljs-string">'购买次数'</span>, <span class="hljs-string">'平均订单金额'</span>, <span class="hljs-string">'最后购买距今天数'</span>, <span class="hljs-string">'用户分群'</span>]
<span class="hljs-attr">X_predict</span> = df[predict_features]
<span class="hljs-attr">y_predict</span> = df[<span class="hljs-string">'是否再购'</span>]

<span class="hljs-comment"># 划分数据集</span>
X_train, X_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(
    X_predict, y_predict, <span class="hljs-attr">test_size</span>=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>
)

<span class="hljs-comment"># 使用随机森林进行预测</span>
<span class="hljs-attr">rf_clf</span> = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>, random_state=<span class="hljs-number">42</span>)

<span class="hljs-comment"># 参数网格搜索</span>
<span class="hljs-attr">param_grid</span> = {
    'max_depth': <span class="hljs-section">[5, 10, 15]</span>,
    'min_samples_split': <span class="hljs-section">[2, 5, 10]</span>,
    'min_samples_leaf': <span class="hljs-section">[1, 2, 4]</span>
}

<span class="hljs-attr">grid_search</span> = GridSearchCV(rf_clf, param_grid, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">'accuracy'</span>, n_jobs=-<span class="hljs-number">1</span>)
grid_search.fit(X_train, y_train)

<span class="hljs-comment"># 最佳模型</span>
<span class="hljs-attr">best_rf</span> = grid_search.best_estimator_

<span class="hljs-comment"># 预测</span>
<span class="hljs-attr">y_pred</span> = best_rf.predict(X_test)

print(f"\n最佳参数: {grid_search.best_params_}")
print(f"最佳交叉验证准确率: {grid_search.best_score_:.2f}")
print(f"测试集准确率: {best_rf.score(X_test, y_test):.2f}")

print("\n分类报告:")
print(classification_report(y_test, y_pred))

<span class="hljs-comment"># 可视化结果</span>
fig, <span class="hljs-attr">axes</span> = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>))

<span class="hljs-comment"># 用户分群可视化</span>
for i in range(4):
    <span class="hljs-attr">cluster_data</span> = df[df[<span class="hljs-string">'用户分群'</span>] == i]
    axes<span class="hljs-section">[0, 0]</span>.scatter(cluster_data<span class="hljs-section">['月收入']</span>, cluster_data<span class="hljs-section">['平均订单金额']</span>, 
                      <span class="hljs-attr">label</span>=f<span class="hljs-string">'分群{i}'</span>, alpha=<span class="hljs-number">0.6</span>)
axes<span class="hljs-section">[0, 0]</span>.set_xlabel('月收入')
axes<span class="hljs-section">[0, 0]</span>.set_ylabel('平均订单金额')
axes<span class="hljs-section">[0, 0]</span>.set_title('用户分群可视化')
axes<span class="hljs-section">[0, 0]</span>.legend()

<span class="hljs-comment"># 特征重要性</span>
<span class="hljs-attr">feature_importance</span> = pd.DataFrame({
    '特征': predict_features,
    '重要性': best_rf.feature_importances_
}).sort_values('重要性', <span class="hljs-attr">ascending</span>=<span class="hljs-literal">False</span>)

axes<span class="hljs-section">[0, 1]</span>.barh(feature_importance<span class="hljs-section">['特征']</span>, feature_importance<span class="hljs-section">['重要性']</span>)
axes<span class="hljs-section">[0, 1]</span>.set_xlabel('重要性')
axes<span class="hljs-section">[0, 1]</span>.set_title('特征重要性排序')

<span class="hljs-comment"># 混淆矩阵</span>
<span class="hljs-attr">cm</span> = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, <span class="hljs-attr">annot</span>=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">'d'</span>, cmap=<span class="hljs-string">'Blues'</span>, ax=axes[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>])
axes<span class="hljs-section">[0, 2]</span>.set_xlabel('预测标签')
axes<span class="hljs-section">[0, 2]</span>.set_ylabel('真实标签')
axes<span class="hljs-section">[0, 2]</span>.set_title('混淆矩阵')

<span class="hljs-comment"># 各分群购买率</span>
<span class="hljs-attr">cluster_purchase_rate</span> = df.groupby(<span class="hljs-string">'用户分群'</span>)[<span class="hljs-string">'是否再购'</span>].mean()
axes<span class="hljs-section">[1, 0]</span>.bar(cluster_purchase_rate.index, cluster_purchase_rate.values)
axes<span class="hljs-section">[1, 0]</span>.set_xlabel('用户分群')
axes<span class="hljs-section">[1, 0]</span>.set_ylabel('再购率')
axes<span class="hljs-section">[1, 0]</span>.set_title('各用户分群的再购率')

<span class="hljs-comment"># ROC曲线</span>
from sklearn.metrics import roc_curve, auc
<span class="hljs-attr">y_pred_proba</span> = best_rf.predict_proba(X_test)[:, <span class="hljs-number">1</span>]
fpr, tpr, <span class="hljs-attr">thresholds</span> = roc_curve(y_test, y_pred_proba)
<span class="hljs-attr">roc_auc</span> = auc(fpr, tpr)

axes<span class="hljs-section">[1, 1]</span>.plot(fpr, tpr, <span class="hljs-attr">color</span>=<span class="hljs-string">'darkorange'</span>, lw=<span class="hljs-number">2</span>, 
                <span class="hljs-attr">label</span>=f<span class="hljs-string">'ROC曲线 (AUC = {roc_auc:.2f})'</span>)
axes<span class="hljs-section">[1, 1]</span>.plot(<span class="hljs-section">[0, 1]</span>, <span class="hljs-section">[0, 1]</span>, <span class="hljs-attr">color</span>=<span class="hljs-string">'navy'</span>, lw=<span class="hljs-number">2</span>, linestyle=<span class="hljs-string">'--'</span>)
axes<span class="hljs-section">[1, 1]</span>.set_xlabel('假正率')
axes<span class="hljs-section">[1, 1]</span>.set_ylabel('真正率')
axes<span class="hljs-section">[1, 1]</span>.set_title('ROC曲线')
axes<span class="hljs-section">[1, 1]</span>.legend()

<span class="hljs-comment"># 学习曲线</span>
from sklearn.model_selection import learning_curve
train_sizes, train_scores, <span class="hljs-attr">test_scores</span> = learning_curve(
    best_rf, X_predict, y_predict, <span class="hljs-attr">cv</span>=<span class="hljs-number">5</span>, n_jobs=-<span class="hljs-number">1</span>,
    <span class="hljs-attr">train_sizes</span>=np.linspace(<span class="hljs-number">0.1</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">10</span>)
)

<span class="hljs-attr">train_scores_mean</span> = np.mean(train_scores, axis=<span class="hljs-number">1</span>)
<span class="hljs-attr">test_scores_mean</span> = np.mean(test_scores, axis=<span class="hljs-number">1</span>)

axes<span class="hljs-section">[1, 2]</span>.plot(train_sizes, train_scores_mean, 'o-', <span class="hljs-attr">color</span>=<span class="hljs-string">'r'</span>, label=<span class="hljs-string">'训练得分'</span>)
axes<span class="hljs-section">[1, 2]</span>.plot(train_sizes, test_scores_mean, 'o-', <span class="hljs-attr">color</span>=<span class="hljs-string">'g'</span>, label=<span class="hljs-string">'交叉验证得分'</span>)
axes<span class="hljs-section">[1, 2]</span>.set_xlabel('训练样本数')
axes<span class="hljs-section">[1, 2]</span>.set_ylabel('准确率')
axes<span class="hljs-section">[1, 2]</span>.set_title('学习曲线')
axes<span class="hljs-section">[1, 2]</span>.legend()

plt.tight_layout()
plt.show()

<span class="hljs-comment"># 输出业务洞察</span>
print("\<span class="hljs-attr">n</span>=== 业务洞察 ===<span class="hljs-string">")
print("</span><span class="hljs-number">1</span>. 用户分群特征:<span class="hljs-string">")
for i in range(4):
    cluster_stats = df[df['用户分群'] == i].describe().loc[['mean']]
    print(f"</span>\n分群 {i} (共{len(df[df[<span class="hljs-string">'用户分群'</span>] == i])}人):<span class="hljs-string">")
    print(f"</span>  平均年龄: {cluster_stats[<span class="hljs-string">'年龄'</span>].values[<span class="hljs-number">0</span>]:.<span class="hljs-number">1</span>f}岁<span class="hljs-string">")
    print(f"</span>  平均月收入: {cluster_stats[<span class="hljs-string">'月收入'</span>].values[<span class="hljs-number">0</span>]:.<span class="hljs-number">0</span>f}元<span class="hljs-string">")
    print(f"</span>  平均购买次数: {cluster_stats[<span class="hljs-string">'购买次数'</span>].values[<span class="hljs-number">0</span>]:.<span class="hljs-number">1</span>f}次<span class="hljs-string">")
    print(f"</span>  再购率: {cluster_purchase_rate[i]:.<span class="hljs-number">1</span>%}<span class="hljs-string">")

print("</span>\n2. 关键发现:<span class="hljs-string">")
print(f"</span>  最重要的预测特征: {feature_importance.iloc[<span class="hljs-number">0</span>][<span class="hljs-string">'特征'</span>]}<span class="hljs-string">")
print(f"</span>  高价值用户识别: 分群{cluster_purchase_rate.idxmax()}具有最高的再购率<span class="hljs-string">")
print(f"</span>  营销建议: 针对分群{cluster_purchase_rate.idxmin()}制定复购激励策略<span class="hljs-string">")
</span></code></pre>
<h2 data-id="heading-18">七、算法性能优化技巧</h2>
<h3 data-id="heading-19">1. 数据预处理最佳实践</h3>
<pre><code class="hljs language-ini" lang="ini">from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestClassifier

<span class="hljs-comment"># 创建完整的数据预处理和建模管道</span>
<span class="hljs-attr">numeric_features</span> = [<span class="hljs-string">'年龄'</span>, <span class="hljs-string">'收入'</span>, <span class="hljs-string">'消费金额'</span>]
<span class="hljs-attr">categorical_features</span> = [<span class="hljs-string">'性别'</span>, <span class="hljs-string">'城市'</span>, <span class="hljs-string">'会员等级'</span>]

<span class="hljs-comment"># 数值型特征处理</span>
<span class="hljs-attr">numeric_transformer</span> = Pipeline(steps=[
    (<span class="hljs-string">'imputer'</span>, SimpleImputer(strategy=<span class="hljs-string">'median'</span>)),  <span class="hljs-comment"># 缺失值处理</span>
    (<span class="hljs-string">'scaler'</span>, StandardScaler())                     <span class="hljs-comment"># 标准化</span>
])

<span class="hljs-comment"># 类别型特征处理</span>
<span class="hljs-attr">categorical_transformer</span> = Pipeline(steps=[
    (<span class="hljs-string">'imputer'</span>, SimpleImputer(strategy=<span class="hljs-string">'most_frequent'</span>)),  <span class="hljs-comment"># 缺失值处理</span>
    (<span class="hljs-string">'onehot'</span>, <span class="hljs-literal">On</span>eHotEncoder(handle_unknown=<span class="hljs-string">'ignore'</span>))     <span class="hljs-comment"># 独热编码</span>
])

<span class="hljs-comment"># 合并预处理步骤</span>
<span class="hljs-attr">preprocessor</span> = ColumnTransformer(
    <span class="hljs-attr">transformers</span>=[
        (<span class="hljs-string">'num'</span>, numeric_transformer, numeric_features),
        (<span class="hljs-string">'cat'</span>, categorical_transformer, categorical_features)
    ])

<span class="hljs-comment"># 创建完整管道</span>
<span class="hljs-attr">full_pipeline</span> = Pipeline(steps=[
    (<span class="hljs-string">'preprocessor'</span>, preprocessor),
    (<span class="hljs-string">'classifier'</span>, RandomForestClassifier(random_state=<span class="hljs-number">42</span>))
])

<span class="hljs-comment"># 使用管道进行训练和预测（代码简洁且不易出错）</span>
<span class="hljs-comment"># full_pipeline.fit(X_train, y_train)</span>
<span class="hljs-comment"># y_pred = full_pipeline.predict(X_test)</span>
</code></pre>
<h3 data-id="heading-20">2. 超参数调优方法</h3>
<pre><code class="hljs language-ini" lang="ini">from sklearn.model_selection import RandomizedSearchCV
from scipy.stats import randint, uniform

<span class="hljs-comment"># 定义参数分布</span>
<span class="hljs-attr">param_dist</span> = {
    'n_estimators': randint(100, 500),
    'max_depth': <span class="hljs-section">[5, 10, 15, 20, None]</span>,
    'min_samples_split': randint(2, 20),
    'min_samples_leaf': randint(1, 10),
    'max_features': <span class="hljs-section">['sqrt', 'log2', None]</span>
}

<span class="hljs-comment"># 随机搜索</span>
<span class="hljs-attr">random_search</span> = RandomizedSearchCV(
    RandomForestClassifier(<span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>),
    <span class="hljs-attr">param_distributions</span>=param_dist,
    <span class="hljs-attr">n_iter</span>=<span class="hljs-number">50</span>,  <span class="hljs-comment"># 随机尝试的参数组合数</span>
    <span class="hljs-attr">cv</span>=<span class="hljs-number">5</span>,
    <span class="hljs-attr">scoring</span>=<span class="hljs-string">'accuracy'</span>,
    <span class="hljs-attr">random_state</span>=<span class="hljs-number">42</span>,
    <span class="hljs-attr">n_jobs</span>=-<span class="hljs-number">1</span>
)

<span class="hljs-comment"># random_search.fit(X_train, y_train)</span>
<span class="hljs-comment"># print(f"最佳参数: {random_search.best_params_}")</span>
<span class="hljs-comment"># print(f"最佳得分: {random_search.best_score_:.2f}")</span>
</code></pre>
<h2 data-id="heading-21">结语：机器学习的发展与未来</h2>
<p>通过本文的详细讲解，我们已经系统了解了机器学习的主要算法及其应用。从基础的线性回归到复杂的神经网络，从监督学习到无监督学习，每种算法都有其独特的优势和适用场景。</p>
<p>机器学习的未来发展趋势包括：</p>
<ol>
<li>1. <strong>自动化机器学习（AutoML）</strong> ：让算法选择、特征工程、超参数调优等过程自动化</li>
<li>2. <strong>可解释性AI</strong>：提高复杂模型的可解释性，建立用户信任</li>
<li>3. <strong>联邦学习</strong>：在保护数据隐私的前提下进行分布式模型训练</li>
<li>4. <strong>强化学习应用扩展</strong>：从游戏领域扩展到更多实际应用场景</li>
</ol>
<p>无论你是刚刚入门的新手，还是有一定经验的数据科学家，掌握这些核心算法都是构建机器学习解决方案的基础。建议读者在学习理论的同时，多动手实践，通过项目实战加深理解。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[个人开发者系列-上线即“爆火”？那些掏空你 Cloudflare 额度的虚假繁荣]]></title>    <link>https://juejin.cn/post/7593337928307703834</link>    <guid>https://juejin.cn/post/7593337928307703834</guid>    <pubDate>2026-01-10T13:31:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593337928307703834" data-draft-id="7593310044478898185" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="个人开发者系列-上线即“爆火”？那些掏空你 Cloudflare 额度的虚假繁荣"/> <meta itemprop="keywords" content="前端,Nuxt.js"/> <meta itemprop="datePublished" content="2026-01-10T13:31:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="vueTmp"/> <meta itemprop="url" content="https://juejin.cn/user/254742426814798"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            个人开发者系列-上线即“爆火”？那些掏空你 Cloudflare 额度的虚假繁荣
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/254742426814798/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    vueTmp
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:31:32.000Z" title="Sat Jan 10 2026 13:31:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本系列专为个人开发者打造，核心理念是以最小成本实现最佳效果，主要侧重于免费或低成本的解决方案。旨在为早期独立开发者提供实用参考，助力其在资源有限的情况下开启创业之旅。
下面的内容是对2025年10月的内容记录，希望我趟过的坑，你不再踩。</p>
</blockquote>
<h2 data-id="heading-0">01 意外的“惊喜”：我的插件网站火了？</h2>
<p>我最近用 <strong>Nuxt v4</strong> 开发了一个网站：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdevworld.top%2F" target="_blank" title="https://devworld.top/" ref="nofollow noopener noreferrer">VSCode Plugin Toolkit - Professional Plugin Offline Download</a>，主要提供 VS Code 插件的搜索和下载，并将其部署在 <strong>Cloudflare Workers</strong> 上。这个选择很符合我们一直讨论的“低成本启动”理念——Cloudflare Workers提供每天10万次请求的免费额度，对于早期项目来说应该绰绰有余。</p>
<blockquote>
<p>Cloudflare Workers 和 Pages Functions 免费额度：</p>
<ul>
<li>每个请求最多占用 10 毫秒 CPU 时间；</li>
<li>每天最多 100,000 (UTC+0)。</li>
</ul>
</blockquote>
<p>就在网站上线不久后，我连续收到了三封来自 Cloudflare 的邮件。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5085bcfdc84749238aa9ab2921213257~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdnVlVG1w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657274&amp;x-signature=pCBnkTHGzFBiyFiR2mA%2Bk8us%2BBw%3D" alt="邮件预警.png" loading="lazy"/></p>
<p>第一眼看到“您的账户已超过每日请求限制”时，我内心的第一反应竟然是： <strong>“天呐，难道我这网站上线即火，流量爆了？”</strong></p>
<p>3 秒过后想想网站没做任何 SEO，也没做过推广的新站能火个 Der ，这么大的自然流量，这显然不正常。难道被挂片了？我拉跨，Cloudflare 也不拉库呀。</p>
<h2 data-id="heading-1">2 案发现场：谁在掏空我的免费额度？</h2>
<p>Cloudflare Workers 免费版虽然慷慨，但也有严格的限制：<strong>每天 10 万次请求 (UTC+0)</strong> 。如果请求被透传到后端 Server，每一次都会扣减这个额度。</p>
<p>我赶紧打开日志进行排查，结果让我大跌眼镜。</p>
<h3 data-id="heading-2">罪魁祸首一：消失的占位图</h3>
<p>在开发插件搜索功能时，我设计了一个逻辑：图片加载中或查询失败时显示一张默认占位图。然而，由于粗心，我忘记将这张图放到 <code>public</code> 静态资源目录中了，导致请求路径不存在。</p>
<p>更糟糕的是，作为 Nuxt 新手，我当时没有配置 <code>error.vue</code> 页面。</p>
<p>在 Nuxt 的机制下，如果一个静态资源请求（如 <code>.png</code>）在静态目录找不到，且没有错误拦截，这个请求就会<strong>回源到服务器（Server）</strong> 。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2060f8685da3401d8bb765048baabf70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdnVlVG1w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657274&amp;x-signature=r13qOZhCO1OIVC2s%2FsV27bSPZ%2Bo%3D" alt="默认图片请求.png" loading="lazy"/></p>
<p>从日志中可以看到，大量的 404 请求涌向了那个并不存在的图片。由于没有缓存，每一次 404 都在实打实地消耗我的 Workers 额度。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fa48792e43d44fea19056131a4d1b37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdnVlVG1w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657274&amp;x-signature=gdVElLS0Ykqev31gJey2dtBGRSM%3D" alt="图片请求详情.png" loading="lazy"/></p>
<h3 data-id="heading-3">罪魁祸首二：勤奋的“不速之客”</h3>
<p>除了自己留下的坑，我还发现了一些“不怀好意”的访客。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e26eafe4e0e1465799c3c368243474fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdnVlVG1w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657274&amp;x-signature=KCmp74OGis4si367VDpnO3qed2g%3D" alt="异常访问信息截图.png" loading="lazy"/></p>
<p>通过日志分析，我发现大量针对 <code>.env</code>、<code>phpinfo.php</code>、<code>wp-admin</code> 等路径的扫描请求。这些典型的恶意扫描和爬虫行为，因为我缺少全局错误拦截，导致所有的异常请求全部走到了 Nuxt 的服务器端处理逻辑里。</p>
<p><strong>漏风的窗户（没占位图）+ 敞开的大门（没错误页面）+ 门外的路人（扫描器）</strong> ，最终导致我的 10 万次额度在短短几个小时内被彻底掏空。</p>
<h2 data-id="heading-4">03 止损方案：最小成本的修复</h2>
<p>针对上面两个做了如下修复：</p>
<ol>
<li><strong>补全静态资源</strong>：将丢失的占位图重新放回 <code>public</code> 文件夹。这样 Cloudflare CDN 会直接拦截并返回静态资源，不再消耗 Workers 的 CPU 计算配额。</li>
<li><strong>增加 <code>error.vue</code></strong>：这是最关键的一步。在 Nuxt 中增加一个简单的自定义错误页，确保所有非预期路径的访问在前端就被拦截处理，而不是交给后端逻辑去消耗资源。</li>
</ol>
<h2 data-id="heading-5">04 复盘：给个人开发者的避坑指南</h2>
<p>这次“虚假繁荣”让我深刻意识到，在利用 Serverless 云服务享受“零成本”部署的同时，必须要注意资源的防御性管理。</p>
<ul>
<li><strong>不要信任开发环境的“丝滑”</strong> ：本地开发时，由于网络延迟低，图片缺失可能只是一闪而过，容易被忽略。</li>
<li><strong>路由兜底是刚需</strong>：无论是 Nuxt 还是其他框架，上线前请务必确认是否有处理 404 和 500 错误的兜底方案。</li>
<li><strong>监控优于直觉</strong>：当看到流量暴涨时，先别急着庆祝，去分析一下日志。</li>
</ul>
<p>修复这些问题后，网站的请求量迅速回归到了正常水平（周末使用的人相对较少）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3b3b04467b24c4b99905464990b1c6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdnVlVG1w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657274&amp;x-signature=ROD46JdJnanvqWDYfErltRpwagc%3D" alt="修改后访问流量.png" loading="lazy"/></p>
<h3 data-id="heading-6">结语</h3>
<p>独立开发的路上，我们不仅要学会构建，更要学会如何“防守”。Cloudflare 是个人开发者的神兵利器，但如果不注意细节，它也会因为额度超限而变得“钝重”。</p>
<p><strong>如果你也正在使用 Nuxt ，记得检查一下你的 404 逻辑！</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[24.Axon框架-事件（二）]]></title>    <link>https://juejin.cn/post/7593262196844167220</link>    <guid>https://juejin.cn/post/7593262196844167220</guid>    <pubDate>2026-01-10T10:38:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593262196844167220" data-draft-id="7593262196844150836" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="24.Axon框架-事件（二）"/> <meta itemprop="keywords" content="后端,领域驱动设计"/> <meta itemprop="datePublished" content="2026-01-10T10:38:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="季风1132"/> <meta itemprop="url" content="https://juejin.cn/user/2799777150149710"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            24.Axon框架-事件（二）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2799777150149710/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    季风1132
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T10:38:35.000Z" title="Sat Jan 10 2026 10:38:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Axon框架-事件（二）</h2>
<h3 data-id="heading-1">1.什么是事件处理器</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f97c4d97b77647e68d631484793b364d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=W%2Bbhm9tLX40lPYOOmjUBXEpPJTY%3D" alt="1768035329540.png" loading="lazy"/></p>
<h3 data-id="heading-2">2.明确概念</h3>
<ul>
<li>EventProcessor：事件处理器</li>
<li>ProcessingGroup：处理组</li>
<li>EventHandler：事件处理程序</li>
</ul>
<h3 data-id="heading-3">3.事件处理器分层结构</h3>
<h4 data-id="heading-4">介绍</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a93169fefe645be80df9ec924d0cbda~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=FbvcqnIEXoBPpiBs%2FLdi8Os06tE%3D" alt="1768035465950.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38b8fcdedcf94db3a5430fe19b11b4e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=%2BpvxQoPB4ydjQiQCTrR9apHZGk4%3D" alt="asdasdcccccCCCAawio.png" loading="lazy"/></p>
<ol>
<li>事件处理程序（EventHandler）：接收事件时需执行的业务逻辑</li>
<li>事件处理器（EventProcessor）：则是负责处理事件处理过程中技术层面工作的组件。它会启动一个工作单元，可能还会开启事务；此外，它还需确保事件处理期间创建的所有消息能正确附加关联数据，同时满足其他非功能需求（如性能、容错等）</li>
<li>处理组（Processing Group）：每个EventHandler仅属于一个处理组。处理组为事件处理提供了可配置的非功能需求能力，例如错误处理、排序策略等</li>
</ol>
<h4 data-id="heading-5">为EventHandler分配ProcessingGroup</h4>
<h5 data-id="heading-6">介绍</h5>
<p>所有EventProcessor都有一个名称，该名称在多个JVM实例间唯一标识一个EventProcessor实例，两个名称相同的EventProcessor会被视为同一EventProcessor的不同实例</p>
<p>所有EventHandler默认会附加到名称为其类所在包名的事件处理器上。此外，Axon默认使用的EventProcessor实现是TrackingEventProcessor（跟踪式事件处理器）</p>
<p>EventHandler大致分为两类：常规EventHandler，Saga的EventHandler，这里介绍常规EventHandler的流程</p>
<h5 data-id="heading-7">两种分配方式</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10f99302d5484653bbc891ab1223a402~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=YZ7lnFSSTdHvUFfpnk5rNOqHSRc%3D" alt="1768036737757.png" loading="lazy"/></p>
<h4 data-id="heading-8">更精细的分配方式</h4>
<h5 data-id="heading-9">介绍</h5>
<p>Axon的配置API允许自定义的更精细的分配方式，这些规则可分为两大类：</p>
<ul>
<li>EventHandler → ProcessingGroup</li>
<li>ProcessingGroup → EventProcessor</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7eab752c085a48e2838eeb29e26020ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=HWsHCCfagMgogrWMOEiJ%2BC8HpfI%3D" alt="1768037088706.png" loading="lazy"/></p>
<h5 data-id="heading-10">事件处理程序到处理组</h5>
<ol>
<li>byDefaultAssignTo(String)：定义EventHandler的默认ProcessingGroup名称。仅在无更具体规则且未标注@ProcessingGroup注解时生效</li>
<li>byDefaultAssignHandlerInstancesTo(Function&lt;Object, String&gt;)：通过Lambda表达式为EventHandler实例分配ProcessingGroup（返回ProcessingGroup名称）。仅在无更具体规则且未标注@ProcessingGroup注解时生效</li>
<li>byDefaultAssignHandlerTypesTo(Function&lt;Class&lt;?&gt;, String&gt;)：通过Lambda表达式为EventHandler类型分配ProcessingGroup（返回ProcessingGroup名称）。仅在无更具体规则且未标注@ProcessingGroup注解时生效</li>
<li>assignHandlerInstancesMatching(String, Predicate&lt;Object&gt;)：根据EventHandler实例是否匹配Predicate条件，将其分配到指定ProcessingGroup。默认优先级为0；若一个实例匹配多个条件，结果未定义</li>
<li>assignHandlerTypesMatching(String, Predicate&lt;Class&lt;?&gt;&gt;)：根据EventHandler类型是否匹配Predicate条件，将其分配到指定ProcessingGroup。默认优先级为0；若一个类型匹配多个条件，结果未定义</li>
<li>assignHandlerInstancesMatching(String, int, Predicate&lt;Object&gt;)：功能与第4点类似，但可自定义优先级（数值越高，规则优先级越高）</li>
<li>assignHandlerTypesMatching(String, int, Predicate&lt;Class&lt;?&gt;&gt;)：功能与第5点类似，但可自定义优先级（数值越高，规则优先级越高）</li>
</ol>
<h5 data-id="heading-11">处理组到事件处理器</h5>
<ol>
<li>assignProcessingGroup(String, String)：将指定名称的ProcessingGroup，分配给指定名称的EventProcessor</li>
<li>assignProcessingGroup(Function&lt;String, String&gt;)：通过Lambda表达式为ProcessingGroup分配EventProcessor（输入ProcessingGroup，名称，返回EventProcessor名称）</li>
</ol>
<h4 data-id="heading-12">EventProcessor内部的EventHandler顺序问题</h4>
<h5 data-id="heading-13">介绍</h5>
<p>默认顺序就是它们在配置API中的注册顺序一致</p>
<h5 data-id="heading-14">Spring环境下的显式排序</h5>
<p>若使用Spring进行依赖注入，可通过@Order注解显式指定事件处理程序的排序。该注解标注在事件处理程序类上，通过整数参数指定优先级（数值越小，优先级越高）</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@ProcessingGroup("my-handlers")</span>
<span class="hljs-meta">@Order(1)</span> <span class="hljs-comment">// 优先级高于 @Order(2) 的组件</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HighPriorityHandler</span> {
    <span class="hljs-meta">@EventHandler</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">(ImportantEvent event)</span> {
        <span class="hljs-comment">// 高优先级逻辑</span>
    }
}

<span class="hljs-meta">@ProcessingGroup("my-handlers")</span>
<span class="hljs-meta">@Order(2)</span> <span class="hljs-comment">// 优先级低于 @Order(1) 的组件</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LowPriorityHandler</span> {
    <span class="hljs-meta">@EventHandler</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">(ImportantEvent event)</span> {
        <span class="hljs-comment">// 低优先级逻辑（在 HighPriorityHandler 之后执行）</span>
    }
}
</code></pre>
<h5 data-id="heading-15">注意事项</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cea64b880290460685e34a9ea28fd539~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=pQTQYkunTP4Buly4LrNFMICLbRs%3D" alt="1768038172709.png" loading="lazy"/></p>
<h3 data-id="heading-16">4.事件错误处理</h3>
<h4 data-id="heading-17">介绍</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb91f194cb0947a1b75b4c4afb816cbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=4z6rTKTmGZP%2BGC5F3zLN3B%2BveEE%3D" alt="1768038674466.png" loading="lazy"/></p>
<h4 data-id="heading-18">ProcessingGroup层级（ListenerInvocationErrorHandler）</h4>
<h5 data-id="heading-19">介绍</h5>
<p>ListenerInvocationErrorHandler负责处理事件处理程序方法抛出的异常。默认实现为LoggingErrorHandler，记录异常日志后，继续处理下一个处理程序或事件</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03aed535c87941c9815f9be50096cb35~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=7liyGYulCEY8icwem3pGVAhZcJA%3D" alt="1768038773748.png" loading="lazy"/></p>
<h5 data-id="heading-20">原生API配置</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-comment">// 省略其他配置方法...</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureProcessingGroupErrorHandling</span><span class="hljs-params">(EventProcessingConfigurer processingConfigurer)</span> {
        <span class="hljs-comment">// 1. 配置所有处理组的默认错误处理器</span>
        processingConfigurer
            .registerDefaultListenerInvocationErrorHandler(conf -&gt; {
                <span class="hljs-comment">// 示例：返回自定义 ListenerInvocationErrorHandler 实例</span>
                <span class="hljs-keyword">return</span> (exception, event, eventHandler) -&gt; {
                    <span class="hljs-comment">// 自定义逻辑：如重试、忽略、死信队列投递等</span>
                    log.error(<span class="hljs-string">"EventHandler [{}] failed to process event [{}]"</span>, 
                              eventHandler.getClass().getSimpleName(), 
                              event.getPayloadType().getSimpleName(), 
                              exception);
                    <span class="hljs-comment">// 若需向上传播异常，直接抛出即可</span>
                    <span class="hljs-comment">// throw new RuntimeException("Propagate error", exception);</span>
                };
            })
            <span class="hljs-comment">// 2. 为特定处理组配置专属错误处理器</span>
            .registerListenerInvocationErrorHandler(<span class="hljs-string">"my-processing-group"</span>, conf -&gt; {
                <span class="hljs-comment">// 为 "my-processing-group" 处理组配置自定义错误处理器</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomMyGroupErrorHandler</span>();
            });
    }
}
</code></pre>
<h5 data-id="heading-21">SpringBoot配置</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-comment">// 省略其他配置方法...</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ConfigurerModule <span class="hljs-title function_">processingGroupErrorHandlingConfigurerModule</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> configurer -&gt; configurer.eventProcessing(processingConfigurer -&gt;
            processingConfigurer
                <span class="hljs-comment">// 配置默认错误处理器</span>
                .registerDefaultListenerInvocationErrorHandler(conf -&gt; {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingErrorHandler</span>(); <span class="hljs-comment">// 也可使用自定义实现</span>
                })
                <span class="hljs-comment">// 为特定处理组配置错误处理器</span>
                .registerListenerInvocationErrorHandler(
                        <span class="hljs-string">"my-processing-group"</span>,
                        conf -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomMyGroupErrorHandler</span>()
                )
        );
    }
}
</code></pre>
<h5 data-id="heading-22">自定义ListenerInvocationErrorHandler</h5>
<p>实现ListenerInvocationErrorHandler接口即可自定义错误处理逻辑，接口提供以下参数：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListenerInvocationErrorHandler</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception exception,
                 EventMessage&lt;?&gt; event,
                 EventMessageHandler eventHandler)</span> <span class="hljs-keyword">throws</span> Exception;
}
</code></pre>
<ol>
<li>exception：EventHandler抛出的异常</li>
<li>event：待处理的事件</li>
<li>eventHandler：抛出异常的EventHandler</li>
</ol>
<p>可根据需求选择重试忽略或向上传播异常；若向上传播，异常会进入EventProcessor</p>
<h4 data-id="heading-23">EventProcessor层级（ErrorHandler）</h4>
<h5 data-id="heading-24">介绍</h5>
<p>EventHandler方法外抛出的异常或从EventHandler层级传播上来的异常，由ErrorHandler处理。默认实现为PropagatingErrorHandler，直接重新抛出所有捕获的异常</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/141ac9b246fc49ab9de7501c72ff428f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=4%2BLLctG8gTHhsXRmLkB2oLp%2FRvA%3D" alt="1768038951834.png" loading="lazy"/></p>
<h5 data-id="heading-25">不同事件处理器类型的异常传播行为</h5>
<ol>
<li>订阅式事件处理器（SubscribingEventProcessor）：异常会传播给事件发布者</li>
<li>流处理式事件处理器（StreamingEventProcessor）：进入错误模式，重试失败后暂停处理</li>
</ol>
<h5 data-id="heading-26">原生API配置</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(EventProcessingConfigurer configurer)</span> {
        configurer
            <span class="hljs-comment">// 1. 配置所有事件处理器的默认错误处理器</span>
            .registerDefaultErrorHandler(conf -&gt; {
                <span class="hljs-comment">// 示例：自定义 ErrorHandler，支持重试</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryingErrorHandler</span>(
                        IntervalRetryScheduler.builder()
                                             .retryCount(<span class="hljs-number">3</span>)
                                             .interval(Duration.ofSeconds(<span class="hljs-number">1</span>))
                                             .build()
                );
            })
            <span class="hljs-comment">// 2. 为特定事件处理器配置专属错误处理器</span>
            .registerErrorHandler(<span class="hljs-string">"my-processor"</span>, conf -&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomProcessorErrorHandler</span>();
            });
    }
}
</code></pre>
<h5 data-id="heading-27">SpringBoot配置</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ConfigurerModule <span class="hljs-title function_">processorErrorHandlingConfigurerModule</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> configurer -&gt; configurer.eventProcessing(processing -&gt;
            processing
                <span class="hljs-comment">// 配置全局默认错误处理器</span>
                .registerDefaultErrorHandler(conf -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryingErrorHandler</span>())
                <span class="hljs-comment">// 为特定事件处理器配置错误处理器</span>
                .registerErrorHandler(<span class="hljs-string">"my-processor"</span>, conf -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomProcessorErrorHandler</span>())
        );
    }
}
</code></pre>
<h5 data-id="heading-28">自定义ErrorHandler</h5>
<p>实现ErrorHandler接口，通过ErrorContext获取错误上下文信息，自定义处理逻辑（如忽略、重试、死信队列投递等）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ErrorHandler</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleError</span><span class="hljs-params">(ErrorContext errorContext)</span> <span class="hljs-keyword">throws</span> Exception;
}

<span class="hljs-comment">// 示例：自定义 ErrorHandler</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomErrorHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ErrorHandler</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleError</span><span class="hljs-params">(ErrorContext errorContext)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">Exception</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> errorContext.getCause();
        EventMessage&lt;?&gt; event = errorContext.getEvent();
        <span class="hljs-comment">// 自定义逻辑：如判断异常类型，决定是否投递到死信队列</span>
        <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> NonTransientException) {
            <span class="hljs-comment">// 非暂时性异常：投递到死信队列</span>
            deadLetterQueue.send(event, cause);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 暂时性异常：重试</span>
            <span class="hljs-keyword">throw</span> cause; <span class="hljs-comment">// 向上传播，触发重试</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-29">死信队列</h4>
<p>这一部分内容，还专门有一章，这里理解为一个持续失败的事件会产生不好的影响，需要死信队列来参与解决</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c017998568a04d0f8c2620f6025c0006~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=3O3wJXoK7hV5wRHyv5vx2hmekZE%3D" alt="1768039221811.png" loading="lazy"/></p>
<h3 data-id="heading-30">5.EventProcessor通用配置</h3>
<h4 data-id="heading-31">介绍</h4>
<p>除了处理EventHandler分配和错误处理，EventProcessor还支持其他组件的配置。订阅式和流处理式事件处理器的专属配置以后说，这里是通用配置</p>
<h4 data-id="heading-32">EventProcessorBuilder</h4>
<h5 data-id="heading-33">介绍</h5>
<p>EventProcessingConfigurer提供了大量EventProcessor的可配置组件，但有时直接提供构建EventProcessor的完整逻辑会更便捷。此时可通过EventProcessorBuilder自定义构建逻辑</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa8b220ed1584fcaa59077a2f5360c02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=ARt6Tgt8sFg0lVMjRistbMIBWPA%3D" alt="1768040215878.png" loading="lazy"/></p>
<h5 data-id="heading-34">配置方式</h5>
<p>EventProcessingConfigurer提供两种配置EventProcessorBuilder的方法：</p>
<ol>
<li>registerEventProcessorFactory(EventProcessorBuilder)：为未配置专属构建器的EventProcessor，配置默认构建工厂</li>
<li>registerEventProcessor(String, EventProcessorBuilder)：为指定名称的EventProcessor，配置专属构建器</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureEventProcessorBuilder</span><span class="hljs-params">(EventProcessingConfigurer processingConfigurer)</span> {
        <span class="hljs-comment">// 1. 配置默认构建器：所有未指定专属构建器的处理器使用此逻辑</span>
        processingConfigurer.registerEventProcessorFactory((name, config, invoker) -&gt; {
            <span class="hljs-comment">// 示例：根据处理器名称，选择构建 Subscribing 或 Tracking 处理器</span>
            <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">"subscribing-"</span>)) {
                <span class="hljs-keyword">return</span> SubscribingEventProcessor.builder()
                                                .name(name)
                                                .eventHandlerInvoker(invoker)
                                                .messageSource(config.eventBus())
                                                .build();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> TrackingEventProcessor.builder()
                                             .name(name)
                                             .eventHandlerInvoker(invoker)
                                             .tokenStore(config.tokenStore())
                                             .build();
            }
        });

        <span class="hljs-comment">// 2. 为 "custom-processor" 配置专属构建器</span>
        processingConfigurer.registerEventProcessor(<span class="hljs-string">"custom-processor"</span>, 
            (name, config, invoker) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEventProcessor</span>(name, invoker, config.eventStore())
        );
    }
}
</code></pre>
<h4 data-id="heading-35">EventHandler拦截器</h4>
<h5 data-id="heading-36">介绍</h5>
<p>EventProcessor是EventHandler的调用者，因此也是配置EventHandler拦截器的合适位置。由于EventProcessor专门处理事件，此处的拦截器需针对EventMessage，即EventHandlerInterceptor</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ab7c8a23fae4db79bd45f4da794d94b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=WQxW4iWPP7WhM5g6E7e4S2Et7L0%3D" alt="1768040791381.png" loading="lazy"/></p>
<h5 data-id="heading-37">配置方式</h5>
<p>EventProcessingConfigurer提供两种配置拦截器的方法：</p>
<ol>
<li>registerDefaultHandlerInterceptor(BiFunction&lt;Configuration, String, MessageHandlerInterceptor&lt;? super EventMessage&lt;?&gt;&gt;&gt;)：为所有EventProcessor配置默认拦截器（输入全局配置和EventProcessor名称，返回拦截器实例）</li>
<li>registerHandlerInterceptor(String, Function&lt;Configuration, MessageHandlerInterceptor&lt;? super EventMessage&lt;?&gt;&gt;&gt;)：为指定名称的EventProcessor配置专属拦截器</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureInterceptors</span><span class="hljs-params">(EventProcessingConfigurer processingConfigurer)</span> {
        <span class="hljs-comment">// 1. 配置全局默认拦截器：为所有处理器添加关联数据拦截</span>
        processingConfigurer.registerDefaultHandlerInterceptor((config, processorName) -&gt; 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationDataInterceptor</span>&lt;&gt;(config.correlationDataProviders())
        );

        <span class="hljs-comment">// 2. 为 "audit-processor" 配置专属审计拦截器</span>
        processingConfigurer.registerHandlerInterceptor(<span class="hljs-string">"audit-processor"</span>, config -&gt; 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuditLoggingInterceptor</span>() <span class="hljs-comment">// 自定义审计拦截器，记录事件处理日志</span>
        );
    }
}
</code></pre>
<h4 data-id="heading-38">消息监控</h4>
<h5 data-id="heading-39">介绍</h5>
<p>所有EventProcessor实例都支持配置MessageMonitor。MessageMonitor用于监控Axon应用中消息的流转过程，对于EvnetProcessor而言，它会专门监控从EventProcessor流向EventHandler的事件</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcde9e4cdc454c458ece83589f002930~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=Qg7LqcxCH5F2iADYgg6w5FQh3%2F4%3D" alt="1768041065242.png" loading="lazy"/></p>
<h5 data-id="heading-40">配置方式</h5>
<p>MessageMonitorFactory是Axon配置API中通用的监控器构建接口，支持更灵活的监控器创建逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageMonitorFactory</span> {
    <span class="hljs-comment">// 参数说明：</span>
    <span class="hljs-comment">// - configuration：全局配置（可获取依赖组件）</span>
    <span class="hljs-comment">// - componentType：组件类型（事件处理器场景下为 EventProcessor 实现类）</span>
    <span class="hljs-comment">// - componentName：组件名称（事件处理器名称）</span>
    MessageMonitor&lt;Message&lt;?&gt;&gt; create(Configuration configuration,
                                      Class&lt;?&gt; componentType,
                                      String componentName);
}
</code></pre>
<p>示例：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureMessageMonitor</span><span class="hljs-params">(EventProcessingConfigurer processingConfigurer)</span> {
        <span class="hljs-comment">// 使用工厂为 "metrics-processor" 配置监控器</span>
        processingConfigurer.registerMessageMonitorFactory(<span class="hljs-string">"metrics-processor"</span>, 
            (config, componentType, componentName) -&gt; {
                <span class="hljs-comment">// 示例：基于 Micrometer 实现事件处理指标监控</span>
                <span class="hljs-keyword">return</span> MicrometerMessageMonitor.builder(componentName)
                                              .meterRegistry(config.getComponent(MeterRegistry.class))
                                              .build();
            }
        );
    }
}
</code></pre>
<h4 data-id="heading-41">事务管理</h4>
<h5 data-id="heading-42">介绍</h5>
<p>EventProcessor负责事件处理，因此也是配置事务的合理位置。大多数场景下，默认配置已足够，本节仅介绍可调整的选项</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34f672f908c34574a840e61e2299a744~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2j6aOOMTEzMg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646315&amp;x-signature=zicwto9UNgVnoQ3isYmxqSH9EJo%3D" alt="1768041132884.png" loading="lazy"/></p>
<h5 data-id="heading-43">TransactionManager</h5>
<p>Axon使用TransactionManager为每个工作单元附加事务：</p>
<ol>
<li>Spring环境：默认使用SpringTransactionManager，底层依赖Spring的PlatformTransactionManager</li>
<li>非Spring环境：若需事务管理，需自定义TransactionManager实现，仅需实现TransactionManager#startTransaction()方法</li>
</ol>
<h5 data-id="heading-44">配置方式</h5>
<p>通过EventProcessingConfigurer的registerTransactionManager方法配置：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureTransactionManager</span><span class="hljs-params">(EventProcessingConfigurer processingConfigurer)</span> {
        <span class="hljs-comment">// 为 "transactional-processor" 配置自定义事务管理器</span>
        processingConfigurer.registerTransactionManager(<span class="hljs-string">"transactional-processor"</span>, 
            config -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomTransactionManager</span>()
        );
    }
}
</code></pre>
<h5 data-id="heading-45">回滚配置</h5>
<p>RollbackConfiguration用于决定工作单元何时需要回滚事务。默认配置为任何Throwable都会触发回滚，其他可选配置可参考工作单元</p>
<p>通过EventProcessingConfigurer的registerRollbackConfiguration方法配置：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AxonConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureRollback</span><span class="hljs-params">(EventProcessingConfigurer processingConfigurer)</span> {
        <span class="hljs-comment">// 为 "custom-rollback-processor" 配置自定义回滚策略：仅 RuntimeException 触发回滚</span>
        processingConfigurer.registerRollbackConfiguration(<span class="hljs-string">"custom-rollback-processor"</span>, 
            config -&gt; RollbackConfigurationType.ANY_RUNTIME_EXCEPTION
        );
    }
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Pywebview进阶：基于Python直接操作前端元素]]></title>    <link>https://juejin.cn/post/7593311347291930651</link>    <guid>https://juejin.cn/post/7593311347291930651</guid>    <pubDate>2026-01-10T12:17:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593311347291930651" data-draft-id="7593251491937189934" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Pywebview进阶：基于Python直接操作前端元素"/> <meta itemprop="keywords" content="后端,Python"/> <meta itemprop="datePublished" content="2026-01-10T12:17:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="唐叔在学习"/> <meta itemprop="url" content="https://juejin.cn/user/4009253326568761"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Pywebview进阶：基于Python直接操作前端元素
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4009253326568761/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    唐叔在学习
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T12:17:34.000Z" title="Sat Jan 10 2026 12:17:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="arduino-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff}.hljs-subst,.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#434f54}.hljs-attribute,.hljs-doctag,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#00979d}.hljs-addition,.hljs-built_in,.hljs-bullet,.hljs-code,.hljs-literal{color:#d35400}.hljs-link,.hljs-regexp,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#00979d}.hljs-deletion,.hljs-quote,.hljs-selector-class,.hljs-selector-id,.hljs-string,.hljs-template-tag,.hljs-type{color:#005c5f}.hljs-section,.hljs-title{color:#800;font-weight:700}.hljs-comment{color:rgba(149,165,166,.8)}.hljs-meta-keyword{color:#728e00}.hljs-meta{color:#434f54}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-function{color:#728e00}.hljs-number{color:#8a7b52}</style><blockquote>
<p>这篇文章是此前 <code>pywebview</code> 系列文章的进阶篇 - 基于 <code>pywebview</code> 操作前端界面元素。</p>
</blockquote>
<p>系列文章：<br/>
<a href="https://juejin.cn/post/7557921840552820777" target="_blank" title="https://juejin.cn/post/7557921840552820777">Pywebview：Web技术构建桌面应用的最佳选择</a><br/>
<a href="https://juejin.cn/post/7589475497001238543" target="_blank" title="https://juejin.cn/post/7589475497001238543">PyWebView 移动端适配踩坑实录</a></p>
<h2 data-id="heading-0">使用场景说明</h2>
<p>为什么会有这个场景呢，因为有些使用场景下，使用 <code>pywebview</code> 开发时，前端无法调用到后端的 <code>API</code>，而这个时候只能由后端直接来操作前端页面。解释起来有点难，下面结合我实际的开发经验来解释吧。</p>
<p>基于官方文档 - <a href="https://link.juejin.cn?target=https%3A%2F%2Fpywebview.idepy.com%2Fguide%2Finterdomain.html" target="_blank" title="https://pywebview.idepy.com/guide/interdomain.html" ref="nofollow noopener noreferrer">Javascript–Python桥梁 | pywebview中文文档</a>，我们可以知道：在 <code>pywebview</code> 框架中，实现 <code>Javascript</code> 和 <code>Python</code> 间交互，主要依赖于 <code>window</code> 对象。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># python调用js-api方式：window.evaluate_js(code, callback=None) </span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_js</span>(<span class="hljs-params">window</span>):
    <span class="hljs-keyword">try</span>:
        result = window.evaluate_js(<span class="hljs-string">'syntaxerror#$%#$'</span>)
    <span class="hljs-keyword">except</span> JavascriptException <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'JavaScript 异常发生: '</span>, e)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    window = webview.create_window(<span class="hljs-string">'Evaluate JavaScript'</span>, html=<span class="hljs-string">'&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'</span>)
    webview.start(evaluate_js, window)

<span class="hljs-comment"># python封装成js-api方式：pywebview.api.method_name</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    api = Api()
    window = webview.create_window(<span class="hljs-string">'JS 接口 示例'</span>, html=html, js_api=api)
    webview.start()
</code></pre>
<p>但是这里有个问题，<strong>你很难通过这两种方式在前端构建监听事件来直接操作 <code>window</code> 对象或其他 <code>pywebview</code> 框架本身的 <code>api</code></strong>。</p>
<h2 data-id="heading-1">使用场景示例</h2>
<p>以我最近开发 <code>todo-list</code> 应用为例，有个场景：实现应用窗口在桌面置顶功能。\</p>
<p>而目前查询 <code>pywebview</code> 框架官网的 <code>api</code>，可以使用 <code>window.on_top</code> 设置 <code>True</code> 或 <code>False</code> 来实现。最初想的很简单，就前端触发点击「置顶按钮」事件后，调用 <code>window.on_top</code> 就实现置顶了，再次调用就取消执行。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c2b7682547441a8ba8ca16cb2512190~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZSQ5Y-U5Zyo5a2m5Lmg:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652384&amp;x-signature=1GXBUjyy4UnUHt%2BBuPnimHciY5U%3D" alt="image.png" loading="lazy"/></p>
<p>而实践发现：基于上述两种方式，操作不了。</p>
<ul>
<li>
<p>通过方式一是 <code>Python</code> 操作前端 <code>Javascript</code>，你没法在 <code>Javascript</code> 中调用 <code>pywebview</code> 的 <code>api</code>；</p>
</li>
<li>
<p>通过方式二是 <code>Python</code> 封装成 <code>js-api</code> ，但问题是封装的 <code>js-api</code> 是调用 <code>webview.create_window</code> 方法传入的，这个方法执行完才会创建 <code>window</code> 对象，也就是你创建 <code>window</code> 的时候，就必须初始化所有的 <code>api</code> 。所以你做不到封装的 <code>js-api</code> 中去调用 <code>window</code> 对象，因为还没创建。</p>
</li>
</ul>
<p>因为这个问题，昨天苦恼了一整天。尝试用 <code>AI</code> 实现，直接循环调用 <code>window</code> 对象，页面都响应不了了。</p>
<p>好在 <code>pywebview</code> 官方文档很全，今早查阅发现 <code>pywebview</code> 本身也可以操作前端 <code>dom</code> 对象，而不需要依赖 <code>Javascript</code> - <a href="https://link.juejin.cn?target=https%3A%2F%2Fpywebview.idepy.com%2Fexamples%2Fdom_manipulation.html" target="_blank" title="https://pywebview.idepy.com/examples/dom_manipulation.html" ref="nofollow noopener noreferrer">DOM 操作示例 | pywebview中文文档</a> 。</p>
<p>也就是置顶功能，可以这样玩：通过 <code>python</code> 监听前端「置顶按钮」的点击事件，如果点击了，直接通过 <code>python</code> 调用 <code>window.on_top</code> 就可以了，完全不依赖前端 <code>Javascript</code> 。事实证明确实可行，下述是简化的代码示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> webview

<span class="hljs-keyword">from</span> backend.api.todo_api <span class="hljs-keyword">import</span> TodoApi

window = <span class="hljs-literal">None</span>
window_on_top = <span class="hljs-literal">False</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">start_app</span>(<span class="hljs-params">window</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">window</span>):
        <span class="hljs-comment"># 直接获取「置顶按钮」</span>
        button = window.dom.get_element(<span class="hljs-string">'#pin-top-btn'</span>)
        button.events.click += click_handler

    <span class="hljs-comment"># 「置顶按钮」点击事件</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click_handler</span>(<span class="hljs-params">e</span>):
        <span class="hljs-keyword">global</span> window_on_top
        window_on_top = <span class="hljs-keyword">not</span> window_on_top
        app_logger.info(<span class="hljs-string">"TodoList 应用当前是否设置置顶："</span> + <span class="hljs-built_in">str</span>(window_on_top))
        window.on_top = window_on_top

    <span class="hljs-comment"># 创建API实例</span>
    api = TodoApi()

    <span class="hljs-comment"># 获取前端文件路径</span>
    frontend_path = get_resource_path(<span class="hljs-string">'frontend/index.html'</span>)

    window = webview.create_window(
        <span class="hljs-string">'Todo List App'</span>,
        frontend_path,
        js_api=api,
        width=<span class="hljs-number">1000</span>,
        height=<span class="hljs-number">700</span>,
        resizable=<span class="hljs-literal">True</span>
    )
    webview.start(bind, window, ssl=<span class="hljs-literal">True</span>, debug=<span class="hljs-literal">True</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_app(window)
</code></pre>
<hr/>
<p>好啦，今天的技术分享就到这里了，更多有关 <code>python</code> 直接操作前端页面元素的，可以查看官网相关 <code>API</code>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpywebview.idepy.com%2Fguide%2Fapi.html%23webview-dom" target="_blank" title="https://pywebview.idepy.com/guide/api.html#webview-dom" ref="nofollow noopener noreferrer">API | pywebview中文文档</a></p>
<p>如果觉得本文对你有所帮助，欢迎三连哦！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[外链的两个指标，DR 和 UR 一次性讲清楚]]></title>    <link>https://juejin.cn/post/7593311347292045339</link>    <guid>https://juejin.cn/post/7593311347292045339</guid>    <pubDate>2026-01-10T12:48:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593311347292045339" data-draft-id="7593311347292028955" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="外链的两个指标，DR 和 UR 一次性讲清楚"/> <meta itemprop="keywords" content="SEO"/> <meta itemprop="datePublished" content="2026-01-10T12:48:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="和平hepingfly"/> <meta itemprop="url" content="https://juejin.cn/user/4100516930912747"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            外链的两个指标，DR 和 UR 一次性讲清楚
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4100516930912747/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    和平hepingfly
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T12:48:43.000Z" title="Sat Jan 10 2026 12:48:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>想要在搜索引擎获得一个比较高的排名，外链是 Google 最重要的排名因素之一。</p>
<p>那怎么样去衡量外链的质量呢？</p>
<p>其中有一个非常重要的因素就是，<strong>权重</strong></p>
<p>如果有一个高权威页面，在这个页面里面有一条你网站的链接，那么对你网站的排名会有非常大的积极影响。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90f1999913504aa7829d4786df655f57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZKM5bmzaGVwaW5nZmx5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768654123&amp;x-signature=32uamK0b9JplnlOYqJTYThfdYdw%3D" alt="img" loading="lazy"/></p>
<p>那么通过什么样的指标去衡量页面的权威度呢？总得有一个量化的指标。</p>
<p>SEO 工具 Ahrefs 发明了两个指标，用来模拟 Google 怎么看待一个网站或一个页面的权威度。</p>
<p>也就是我们常说的 DR 和 UR。</p>
<ul>
<li><strong>网站评分（Domain Rating）</strong> : 网站的权重指标，范围为0–100。</li>
<li><strong>网址评分 （URL Rating）</strong> : 页面的权重指标，范围为0–100。</li>
</ul>
<h3 data-id="heading-0">DR 和 UR 有什么区别？为什么用两个指标来衡量？</h3>
<p>如果把 SEO 想象成一场投票游戏，别的网站给你链接（外链），就相当于投了你一票。</p>
<ul>
<li>DR (Domain Rating) = 整个网站有多牛逼</li>
<li>UR (URL Rating) = 单个网页有多牛逼</li>
</ul>
<h3 data-id="heading-1">什么是 Domain Rating (DR)？</h3>
<p>类比：奥运会衡量某个国家整体的体育实力，这个国家总共拿了多少块金牌？在金牌排行榜上多少名？</p>
<p>DR 衡量的是<strong>整个网站</strong>的外链强度。如果很多厉害的网站都链接到你的网站，你的 DR 就会高。</p>
<p><strong>具体有什么用？</strong></p>
<p>当你想找别的网站交换链接时，先看对方的 DR。如果对方 DR 很高（比如 80+），说明这个网站很牛逼。它的链接对你很有价值。</p>
<p>如果 DR 很低（比如 5），说明它是个小透明，对你的帮助很小。</p>
<p><strong>举例：</strong></p>
<p>假如你想做一个球鞋评测的网站，你发现竞争对手的网站 DR 是 70，而你是 20。这就代表，对方是一个在这个领域深耕已久的大站，你想在整体流量上超越他，还需要长期的积累。</p>
<h3 data-id="heading-2">什么是 URL Rating (UR)？</h3>
<p>类比：在奥运会中，某一个国家在某一项具体运动上的实力。比如说跳水运动拿了多少块金牌，在金牌榜上排行多少？</p>
<p>UR 衡量的是某一个具体页面（网址）的外链强度。哪怕是一个不知名网站（低 DR），如果有一篇爆款文章被无数大媒体转发链接，这篇文章的 UR 也会非常高。</p>
<p><strong>具体有什么用？</strong></p>
<p>可以帮我们去判断排名难度（能不能打赢）。</p>
<p><strong>举例：</strong></p>
<p>当你想写一篇关于iPhone 15 评测的文章去抢 Google 排名时，你可以去搜索一下现在的搜索结果第一名。</p>
<ul>
<li>如果第一名的页面 UR 是 80：说明这个页面被很多大佬引用过，你想把通过写文章把它挤下去，非常难。</li>
<li>如果第一名的页面 UR 是 10：说明这个页面虽然排第一，但根基不稳，你写一篇更好的文章并做一点推广，很有机会取而代之。</li>
</ul>
<p><strong>另外一个用处：</strong></p>
<p>你网站首页的 UR 通常最高。如果你新写了一篇文章 UR 很低，你可以从首页放一个链接指向新文章，把首页的权重（UR）分一点给新文章。</p>
<p><strong>一句话总结：</strong></p>
<p>帮你判断我要在某个具体关键词上抢排名，对手强不强，我有多大胜算。</p>
<h3 data-id="heading-3">为什么有的网站 DR 很高，但排名却输给了 DR 低的网站？</h3>
<p>如果你的对手是一个大网站（DR 80），但他排名的那个页面很边缘、没人引用（UR 5），而你的网站虽然小（DR 20），但你的那篇文章写得好、被很多人转发（UR 30）。</p>
<p><strong>你的 UR 30 &gt; 他的 UR 5，你完全有机会在排名上打败这个大网站。</strong></p>
<p>这就好比中国国家队的综合体育实力非常高，但是在 football 这项运动上，可以被很多国家按在地上摩擦。</p>
<p>回到网站上来，当你在 Google 搜东西时，Google 展现的是具体的页面，而不是整个网站。</p>
<p>Google 排名主要看具体的页面（UR） <strong>，</strong>  搜索结果是把一个个具体的<strong>页面</strong>拿出来比拼。</p>
<p>所以，<strong>UR 与 Google 排名的相关性比 DR 更高。</strong></p>
<p>虽然排名看 UR，但如果你的网站整体 DR 很高，你发布的新页面通常更容易获得较高的初始 UR，因为Google信任你的整个域名。</p>
<p>就好像中国综合体育实力很高，当谈到某一项运动时，别人第一反应都会觉得中国实力应该不错，因为大家对你的第一印象就是你们奥运会上成绩不错，体育实力应该都挺强的。</p>
<h3 data-id="heading-4">针对这两个指标，我们在实际操作中应该怎么样去对待？</h3>
<p>1）如果你在做外链建设</p>
<p>看 <strong>DR</strong>。你要努力争取来自高 DR 网站的链接。</p>
<p>2）如果你在做关键词研究</p>
<p>看 <strong>UR</strong>。分析搜索结果前几名的 UR，如果普遍很低，那就是你的机会（软柿子，可以捏）；如果普遍很高，建议换个词做（硬骨头，咬不动）。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[007-spring cloud alibaba之Sentinel限流]]></title>    <link>https://juejin.cn/post/7593338828217663503</link>    <guid>https://juejin.cn/post/7593338828217663503</guid>    <pubDate>2026-01-10T13:43:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593338828217663503" data-draft-id="7593338828216942607" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="007-spring cloud alibaba之Sentinel限流"/> <meta itemprop="keywords" content="微服务"/> <meta itemprop="datePublished" content="2026-01-10T13:43:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="超级小猪"/> <meta itemprop="url" content="https://juejin.cn/user/3702810891008525"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            007-spring cloud alibaba之Sentinel限流
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3702810891008525/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    超级小猪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:43:34.000Z" title="Sat Jan 10 2026 13:43:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">sentinel环境搭建</h2>
<h3 data-id="heading-1">sentinel-dashboard搭建</h3>
<p>限流中间件。启动默认接口8080</p>
<ul>
<li>启动命令：java -jar sentinel-dashboard-1.8.2.jar</li>
<li>访问地址：localhost:8080</li>
<li>访问密码：sentinel/sentinel
如果端口占用，可以在启动命令中增加端口：<code>java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</code></li>
</ul>
<h3 data-id="heading-2">应用接入sentinel</h3>
<h4 data-id="heading-3">增加依赖</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h4 data-id="heading-4">增加配置</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">discovery:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span>
    <span class="hljs-attr">sentinel:</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span>
        <span class="hljs-attr">port:</span> <span class="hljs-number">8720</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoint:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-string">include:'*'</span>
</code></pre>
<h3 data-id="heading-5">流控</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4adceff393364f26b1a05eea2450c0a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657414&amp;x-signature=v8tiQV7vgVa2NxYezyvSTGol8V8%3D" alt="image.png" loading="lazy"/>
簇点链路-&gt;选择需要流控的接口-&gt;+流控</p>
<ul>
<li>资源名：路径，eg：/hello</li>
<li>针对来源：default，默认</li>
<li>阈值类型：QPS/并发线程数。
<ul>
<li>QPS：一秒内请求路径次数</li>
<li>并发线程数：线程数</li>
</ul>
</li>
<li>单机阈值：次数</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30318d026bf9485cbfc5b8e874629194~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657414&amp;x-signature=AGksMMwVdov5n9PXyKsIeSGYWBQ%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>流控模式：
<ul>
<li>直接：API达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己</li>
<li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）(API级别的针对来源)</li>
</ul>
</li>
<li>流控效果：
<ul>
<li>快速失败：直接失败，抛异常</li>
<li>Wam Up：根据codeFactor（冷加载因子，默认3）的值，从阈值/codeFacotor，经过预热时长，才达到设置的QPS阈值</li>
<li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效</li>
</ul>
</li>
</ul>
<h4 data-id="heading-6">流控模式：直接/关联</h4>
<p>这两种流控比较简单。直接就是当达到阈值，当前接口不能访问。关联是关联的资源达到阈值就限流自己。举一个关联的例子：下单和支付的关系。下单资源：<code>/createOrder</code>；支付资源：<code>/payOrder</code>。如果要配置关联可以在<code>/payOrder</code>配置一个关联<code>/createOrder</code>的限流。当<code>/createOrder</code>到达阈值，限制<code>/payOrder</code>的接口访问。</p>
<h4 data-id="heading-7">流控模式：链路</h4>
<p>链路是比较细粒度的限流模式。比如接口A需要调用接口B，接口C需要调用接口B，我们将接口B做为资源。然后配置接口A限流，限流的方式是链路。那么当到达接口B的限流上限，接口A就无法访问，但是接口C还可以继续访问不受影响。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
接口A --&gt; 接口B
接口C --&gt; 接口B
</code></pre>
<h5 data-id="heading-8">接口B</h5>
<p>定义资源使用<code>@SentinelResource</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {

    <span class="hljs-meta">@SentinelResource("userName")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"sentinel"</span>;
    }
}
</code></pre>
<h5 data-id="heading-9">调用接口B</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@ApiOperation("s1")</span>
<span class="hljs-meta">@GetMapping("/s1")</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">s1</span><span class="hljs-params">(HttpServletRequest request)</span>{
    System.out.println(<span class="hljs-string">"s1"</span>);
    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserName();
    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello s1 "</span>+user+<span class="hljs-string">" ...9001"</span>;
}
</code></pre>
<h5 data-id="heading-10">调用接口A</h5>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">"s2"</span>)
<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/s2"</span>)
public String <span class="hljs-built_in">s2</span>(HttpServletRequest request){
    <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">"s2"</span>);
    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">user</span> = <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.getUserName</span>();
    <span class="hljs-selector-tag">return</span> "<span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">s2</span>"+<span class="hljs-selector-tag">user</span>+" ..<span class="hljs-selector-class">.9001</span>";
}
</code></pre>
<h5 data-id="heading-11">增加配置</h5>
<p>新增：<code>web-context-unify: false</code></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">discovery:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span>
    <span class="hljs-attr">sentinel:</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span>
        <span class="hljs-attr">port:</span> <span class="hljs-number">8720</span>
      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoint:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-string">include:'*'</span>

<span class="hljs-attr">swagger:</span>
  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
</code></pre>
<h5 data-id="heading-12">sentinel注册信息</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1eccb470431b490688e02925b6f085f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657414&amp;x-signature=8F2nO4udDfGrgFDbsaOVfSlvYcw%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-13">验证</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be083dd8a7084c4081e669110d11fbe3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657414&amp;x-signature=SxNv0WHZL0pnoV%2BMRZZN8NjlBT0%3D" alt="image.png" loading="lazy"/>
被拒绝的请求如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/09a186a2f75549969324bbac56f85631~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LaF57qn5bCP54yq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768657414&amp;x-signature=thLWOo49xWU%2FWq%2BLzNWaX%2BQFLws%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-14">流控效果：Warm Up</h4>
<p>Warm Up使用场景：预热/冷启动方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Mysql：简单易懂了解MVCC]]></title>    <link>https://juejin.cn/post/7593292445300064275</link>    <guid>https://juejin.cn/post/7593292445300064275</guid>    <pubDate>2026-01-10T14:31:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593292445300064275" data-draft-id="7593232758127902726" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Mysql：简单易懂了解MVCC"/> <meta itemprop="keywords" content="MySQL"/> <meta itemprop="datePublished" content="2026-01-10T14:31:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户887625560622"/> <meta itemprop="url" content="https://juejin.cn/user/4408380841266377"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Mysql：简单易懂了解MVCC
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4408380841266377/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户887625560622
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T14:31:57.000Z" title="Sat Jan 10 2026 14:31:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一句话说清楚</h3>
<p>MVCC = 多版本并发控制 = 每个事务看到的是数据库在某个时间点的"快照"，而不是实时数据。</p>
<h2 data-id="heading-1">用一个生活中的例子理解</h2>
<h3 data-id="heading-2">场景：银行账户余额查询</h3>
<p>想象你在银行查询余额：</p>
<h4 data-id="heading-3">没有 MVCC 的情况（加锁）</h4>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 你开始查询余额：1000元
<span class="hljs-bullet">2.</span> 同时，你老婆在转账：-500元
<span class="hljs-bullet">3.</span> 银行说："等等！你老婆正在操作，你等会儿再查"
<span class="hljs-bullet">4.</span> 你被阻塞，直到转账完成
</code></pre>
<p>问题：读操作被写操作阻塞</p>
<h4 data-id="heading-4">有 MVCC 的情况</h4>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 你开始查询余额：1000元
<span class="hljs-bullet">2.</span> 同时，你老婆在转账：-500元
<span class="hljs-bullet">3.</span> 银行说："你查你的，她转她的，互不影响"
<span class="hljs-bullet">4.</span> 你看到的是查询开始时的余额：1000元
<span class="hljs-bullet">5.</span> 你老婆转账完成后，余额变成500元
<span class="hljs-bullet">6.</span> 你下次查询才会看到500元
</code></pre>
<p>优点：读写不冲突，读操作看到的是一致性快照</p>
<h2 data-id="heading-5">技术原理（核心概念）</h2>
<p>MVCC 主要依赖以下三个关键技术来实现：</p>
<h4 data-id="heading-6">1. 数据的三个隐藏字段</h4>
<p>InnoDB 引擎会为每一行数据自动添加三个我们看不见的隐藏字段：</p>
<ul>
<li>DB_TRX_ID（6字节）：最近修改/创建本行数据的事务ID。记录是哪个事务生成了这个数据版本。</li>
<li>DB_ROLL_PTR（7字节）：回滚指针。指向这条数据的上一个版本的地址（存储在 Undo Log 中）。它就像一条链表的指针，把同一个数据的多个版本串联起来。</li>
<li>DB_ROW_ID（6字节）：行ID。如果表没有主键，InnoDB 会用它生成聚簇索引。</li>
</ul>
<h4 data-id="heading-7">2. Undo Log（回滚日志）</h4>
<ul>
<li>作用：存储数据旧版本的“档案馆”。</li>
<li>当一行数据被更新时，旧版本的数据不会立刻删除，而是会被拷贝到 Undo Log 中，并通过 DB_ROLL_PTR 指针形成一个版本链。</li>
<li>这个版本链使得事务可以根据需要找到任何历史版本的数据。</li>
</ul>
<h4 data-id="heading-8">3. Read View（读视图）</h4>
<ul>
<li>作用：决定当前事务应该看到哪个版本数据的“筛选规则”。</li>
<li>当一个事务执行快照读（普通的 SELECT 语句）时，会生成一个 Read View。这个 Read View 主要包含：</li>
<li>
<ul>
<li>m_ids：生成 Read View 时，系统中活跃的（未提交的）事务ID列表。</li>
<li>min_trx_id：m_ids 中的最小值。</li>
<li>max_trx_id：生成 Read View 时，系统应该分配给下一个事务的 ID。</li>
<li>creator_trx_id：创建这个 Read View 的事务自己的 ID。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-9">MVCC 版本链的形成过程</h2>
<h5 data-id="heading-10">示例：三次更新操作</h5>
<pre><code class="hljs language-ini" lang="ini">-- 初始状态
INSERT INTO users (id, name) VALUES (1, '张三')<span class="hljs-comment">;</span>
-- 版本V1: <span class="hljs-attr">name</span>=<span class="hljs-string">'张三'</span>, trx_id=<span class="hljs-number">100</span>, roll_ptr=NULL

-- 事务200更新
BEGIN<span class="hljs-comment">;</span>
UPDATE users SET <span class="hljs-attr">name</span> = <span class="hljs-string">'李四'</span> WHERE id = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
-- 版本V2: <span class="hljs-attr">name</span>=<span class="hljs-string">'李四'</span>, trx_id=<span class="hljs-number">200</span>, roll_ptr→V1
COMMIT<span class="hljs-comment">;</span>

-- 事务300更新
BEGIN<span class="hljs-comment">;</span>
UPDATE users SET <span class="hljs-attr">name</span> = <span class="hljs-string">'王五'</span> WHERE id = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
-- 版本V3: <span class="hljs-attr">name</span>=<span class="hljs-string">'王五'</span>, trx_id=<span class="hljs-number">300</span>, roll_ptr→V2
COMMIT<span class="hljs-comment">;</span>
</code></pre>
<p>形成的版本链：</p>
<pre><code class="hljs language-ini" lang="ini">最新版本 ← 当前查询从这里开始
    ↓
V3: <span class="hljs-attr">name</span>=<span class="hljs-string">'王五'</span>, trx_id=<span class="hljs-number">300</span>, roll_ptr → V2
                          ↓
V2: <span class="hljs-attr">name</span>=<span class="hljs-string">'李四'</span>, trx_id=<span class="hljs-number">200</span>, roll_ptr → V1
                          ↓
V1: <span class="hljs-attr">name</span>=<span class="hljs-string">'张三'</span>, trx_id=<span class="hljs-number">100</span>, roll_ptr = NULL
</code></pre>
<h2 data-id="heading-11">MVCC 如何工作（四步判断）</h2>
<p>当事务要读取一行数据时，会沿着版本链，从最新版本开始往回找，判断哪个版本对当前事务可见：</p>
<h3 data-id="heading-12">判断规则（核心！）</h3>
<p>对于版本链中的每个版本，检查其事务ID（DB_TRX_ID）：</p>
<ol>
<li>如果 DB_TRX_ID = creator_trx_id：
<ul>
<li>说明这个版本是当前事务自己修改的 ✅ 可见</li>
</ul>
</li>
<li>如果 DB_TRX_ID &lt; min_trx_id：
<ul>
<li>说明这个版本在 ReadView 创建前已提交 ✅ 可见</li>
</ul>
</li>
<li>如果 DB_TRX_ID &gt; max_trx_id：
<ul>
<li>说明这个版本在 ReadView 创建后才开始 ❌ 不可见</li>
</ul>
</li>
<li>如果 min_trx_id &lt; DB_TRX_ID &lt; max_trx_id
<ul>
<li>不在 m_ids 中：说明这个版本的事务已提交 ✅ 可见</li>
<li>在 m_ids 中：说明这个版本的事务还在活跃（未提交） ❌ 不可见</li>
</ul>
</li>
</ol>
<p>如果当前版本不可见，就沿着回滚指针找上一个版本，直到找到可见的版本或版本链结束。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a16ad20011dc418fb8df97ec23a72afd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODg3NjI1NTYwNjIy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768660316&amp;x-signature=%2B%2BSltkEyvYViUCLdAWKvtP2ATLA%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-13">实战例子演示</h2>
<h3 data-id="heading-14">场景：两个事务并发操作</h3>
<p>初始数据：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">id</span>=<span class="hljs-number">1</span>, name=<span class="hljs-string">'张三'</span>, age=<span class="hljs-number">20</span>, DB_TRX_ID=<span class="hljs-number">50</span>, DB_ROLL_PTR=NULL
</code></pre>
<p>事务时间线：</p>
<pre><code class="hljs language-ini" lang="ini">时间点1：事务100开始，修改 <span class="hljs-attr">age</span>=<span class="hljs-number">21</span>
时间点2：事务200开始，创建 ReadView
时间点3：事务100提交
时间点4：事务200查询数据
</code></pre>
<h3 data-id="heading-15">版本链形成</h3>
<pre><code class="hljs language-ini" lang="ini">当前版本：<span class="hljs-attr">age</span>=<span class="hljs-number">21</span>, DB_TRX_ID=<span class="hljs-number">100</span>, DB_ROLL_PTR→
          ↓
旧版本：<span class="hljs-attr">age</span>=<span class="hljs-number">20</span>, DB_TRX_ID=<span class="hljs-number">50</span>, DB_ROLL_PTR=NULL
</code></pre>
<h3 data-id="heading-16">事务200的 ReadView</h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">m_ids</span> = [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>]   // 活跃事务列表
<span class="hljs-attr">min_trx_id</span> = <span class="hljs-number">100</span>     // 最小活跃事务ID
<span class="hljs-attr">max_trx_id</span> = <span class="hljs-number">201</span>     // 下一个事务ID
<span class="hljs-attr">creator_trx_id</span> = <span class="hljs-number">200</span> // 当前事务ID
</code></pre>
<h3 data-id="heading-17">事务200查询过程</h3>
<ol>
<li>找到当前版本：age=21, DB_TRX_ID=100</li>
<li>判断：DB_TRX_ID=100 在 m_ids 中（事务100还在活跃）</li>
<li>❌ 不可见，继续找上一个版本</li>
<li>找到旧版本：age=20, DB_TRX_ID=50</li>
<li>判断：DB_TRX_ID=50 &lt; min_trx_id(100)</li>
<li>✅ 可见，返回 age=20</li>
</ol>
<p>结果：事务200看到的是 age=20，而不是最新的 age=21</p>
<h2 data-id="heading-18">隔离级别与 MVCC</h2>






























<table><thead><tr><th align="left"><strong>隔离级别</strong></th><th align="left"><strong>MVCC 行为</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">读未提交</td><td align="left">不使用 MVCC</td><td align="left">直接读最新数据，可能读到脏数据</td></tr><tr><td align="left">读已提交</td><td align="left">每次读时都创建新 ReadView</td><td align="left">每次查询看到已提交的最新数据</td></tr><tr><td align="left">可重复读</td><td align="left">第一次读时创建 ReadView</td><td align="left">整个事务看到同一个快照</td></tr><tr><td align="left">串行化</td><td align="left">不使用 MVCC</td><td align="left">加锁，完全串行执行</td></tr></tbody></table>
<h2 data-id="heading-19">底层实现细节</h2>
<h3 data-id="heading-20">1. Undo Log（回滚日志）</h3>
<ul>
<li>记录数据修改前的旧值</li>
<li>用于回滚事务和构建版本链</li>
<li>当事务提交后，undo log 不会立即删除，因为可能还有其他事务需要读旧版本</li>
</ul>
<h3 data-id="heading-21">2. 版本链清理</h3>
<ul>
<li>当没有事务需要读旧版本时，undo log 会被清理</li>
<li>通过 purge 线程定期清理</li>
<li>清理条件：所有 ReadView 的 min_trx_id 都大于某个版本的事务ID</li>
</ul>
<h3 data-id="heading-22">3. 当前读 vs 快照读</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 快照读（使用MVCC）</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;  <span class="hljs-comment">-- 看到快照</span>

<span class="hljs-comment">-- 当前读（加锁，读最新）</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  <span class="hljs-comment">-- 加写锁</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> LOCK <span class="hljs-keyword">IN</span> SHARE MODE;  <span class="hljs-comment">-- 加读锁</span>
</code></pre>
<h2 data-id="heading-23">一句话总结</h2>
<p>MVCC 就是：每个事务看到的是数据库在某个时间点的"快照"，而不是实时数据。通过版本链和 ReadView 机制，实现读写不冲突和高并发。</p>
<p>记住这个核心：</p>
<ul>
<li>版本链：每次修改都记录旧版本，形成链表</li>
<li>ReadView：事务开始时创建，决定哪些版本可见</li>
<li>判断规则：沿着版本链找，找到第一个对当前事务可见的版本</li>
<li>隔离级别：读已提交 vs 可重复读的区别在于 ReadView 的创建时机</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java异常体系结构]]></title>    <link>https://juejin.cn/post/7593292445300097043</link>    <guid>https://juejin.cn/post/7593292445300097043</guid>    <pubDate>2026-01-10T14:36:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593292445300097043" data-draft-id="7593198957985021993" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java异常体系结构"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-01-10T14:36:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Assby"/> <meta itemprop="url" content="https://juejin.cn/user/2496307079162410"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java异常体系结构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2496307079162410/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Assby
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T14:36:14.000Z" title="Sat Jan 10 2026 14:36:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Java 异常体系结构详解</h2>
<p>Java 的异常处理机制是其健壮性的重要保证。理解异常的层次结构和处理原则，是写出高质量 Java 代码的基础。本文将系统梳理 Java 异常体系的核心概念与最佳实践。</p>
<hr/>
<h3 data-id="heading-1">一、Java 异常体系总览</h3>
<p>Java 的异常体系是一个单根继承树，所有异常都继承自 <code>Throwable</code> 类：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a42a78707e094f53baff7fc98b1964c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQXNzYnk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768660574&amp;x-signature=ASl3pQ88NSdhzIq%2B2pnKbG0f7ys%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-2">二、Error vs Exception：根本区别</h3>
<h4 data-id="heading-3">2.1 Error：系统级灾难</h4>
<p><strong>Error 表示系统级的严重错误</strong>，通常由 JVM 或底层系统抛出，程序<strong>无法恢复</strong>，只能终止运行。</p>
<p><strong>典型场景</strong>：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>StackOverflowError</code>：栈溢出（无限递归）</li>
<li><code>VirtualMachineError</code>：JVM 内部错误</li>
</ul>
<p><strong>处理原则</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 不要捕获 Error</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 业务代码</span>
} <span class="hljs-keyword">catch</span> (Error e) {  <span class="hljs-comment">// 错误示范！</span>
    <span class="hljs-comment">// 无法真正恢复</span>
}

<span class="hljs-comment">// ✅ 让进程优雅退出</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 应用启动</span>
        startApplication();
    } <span class="hljs-keyword">catch</span> (OutOfMemoryError e) {
        <span class="hljs-comment">// 记录日志、释放资源、报警</span>
        logger.error(<span class="hljs-string">"系统内存耗尽，即将退出"</span>, e);
        System.exit(-<span class="hljs-number">1</span>);
    }
}
</code></pre>
<h4 data-id="heading-4">2.2 Exception：程序级业务异常</h4>
<p><strong>Exception 表示程序运行中可以预料、可以恢复的异常</strong>，属于业务范畴，<strong>必须被处理</strong>。</p>
<p><strong>核心特征</strong>：</p>
<ul>
<li>代表程序逻辑缺陷或外部条件不满足</li>
<li>可以通过合理的异常处理机制恢复</li>
<li>是程序健壮性的体现</li>
</ul>
<hr/>
<h3 data-id="heading-5">三、Exception 的两大分支</h3>
<h4 data-id="heading-6">3.1 Checked Exception（受检异常）</h4>
<p><strong>定义</strong>：继承自 <code>Exception</code> 但不继承 <code>RuntimeException</code>。</p>
<p><strong>编译器强制检查</strong>：必须在代码中显式处理（try-catch 或 throws 声明），否则<strong>编译不通过</strong>。</p>
<p><strong>典型代表</strong>：</p>
<ul>
<li><code>IOException</code>：文件读写失败</li>
<li><code>SQLException</code>：数据库操作异常</li>
<li><code>ClassNotFoundException</code>：类未找到</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 编译失败：Unhandled exception: java.io.IOException</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> {
    <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"data.txt"</span>);
}

<span class="hljs-comment">// ✅ 正确：try-catch 处理</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"data.txt"</span>);
        <span class="hljs-comment">// 读取逻辑</span>
    } <span class="hljs-keyword">catch</span> (IOException e) {
        logger.error(<span class="hljs-string">"文件读取失败"</span>, e);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"配置文件读取失败，请联系管理员"</span>);
    }
}

<span class="hljs-comment">// ✅ 正确：throws 声明抛出</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"data.txt"</span>);
    <span class="hljs-comment">// 让调用者处理</span>
}
</code></pre>
<h4 data-id="heading-7">3.2 Unchecked Exception（非受检异常）</h4>
<p><strong>定义</strong>：继承自 <code>RuntimeException</code>。</p>
<p><strong>编译器不检查</strong>：无需显式捕获，运行时才会抛出。</p>
<p><strong>典型代表</strong>：</p>
<ul>
<li><code>NullPointerException</code>：空指针访问</li>
<li><code>IndexOutOfBoundsException</code>：数组越界</li>
<li><code>IllegalArgumentException</code>：非法参数</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 编译通过（无需强制处理）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    str.length();  <span class="hljs-comment">// 可能抛出 NullPointerException</span>
}
</code></pre>
<p><strong>处理原则</strong>：Unchecked Exception 通常代表<strong>程序逻辑缺陷</strong>，应该通过<strong>代码优化</strong>避免，而不是 捕获后忽略。</p>
<hr/>
<h3 data-id="heading-8">四、异常处理四大黄金法则</h3>
<h4 data-id="heading-9">1. <strong>优先捕获特定异常，避免捕获通用 Exception</strong></h4>
<p><strong>反模式</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 会掩盖具体错误，难以定位问题</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 业务代码</span>
} <span class="hljs-keyword">catch</span> (Exception e) {  <span class="hljs-comment">// 捕获范围太广</span>
    logger.error(<span class="hljs-string">"出错了"</span>, e);
}
</code></pre>
<p><strong>最佳实践</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 精确捕获，针对性处理</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 文件操作</span>
} <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"配置文件不存在"</span>);
} <span class="hljs-keyword">catch</span> (IOException e) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"文件读取失败"</span>);
} <span class="hljs-keyword">catch</span> (SQLException e) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"数据库操作异常"</span>);
}
</code></pre>
<h4 data-id="heading-10">2. <strong>捕获后必须处理：记录日志 + 抛出业务异常</strong></h4>
<p><strong>反模式</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 吞掉异常，上层无法感知</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 数据库操作</span>
} <span class="hljs-keyword">catch</span> (SQLException e) {
    <span class="hljs-comment">// 什么都不做！异常被静默吞掉</span>
}
</code></pre>
<p><strong>最佳实践</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 记录日志 + 转换为业务异常</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 数据库操作</span>
} <span class="hljs-keyword">catch</span> (SQLException e) {
    logger.error(<span class="hljs-string">"用户ID={} 注册失败，SQL状态={}"</span>, userId, e.getSQLState(), e);
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserRegistrationException</span>(<span class="hljs-string">"用户注册失败，请稍后重试"</span>);
}
</code></pre>
<h4 data-id="heading-11">3. <strong>不要延迟处理异常</strong></h4>
<p><strong>反模式</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 捕获后存储，后续再处理（难以理解）</span>
<span class="hljs-keyword">private</span> Exception cachedException;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 业务代码</span>
    } <span class="hljs-keyword">catch</span> (IOException e) {
        <span class="hljs-built_in">this</span>.cachedException = e;  <span class="hljs-comment">// 错误示范！</span>
    }
}
</code></pre>
<p><strong>最佳实践</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 立即处理或抛出</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 业务代码</span>
}

<span class="hljs-comment">// 或者在调用处处理</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
        doWork();
    } <span class="hljs-keyword">catch</span> (IOException e) {
        handleError(e);  <span class="hljs-comment">// 立即处理</span>
    }
}
</code></pre>
<h4 data-id="heading-12">4. <strong>严禁在 finally 中 return</strong></h4>
<p><strong>致命后果</strong>：</p>
<ul>
<li><strong>覆盖</strong> try 或 catch 中的返回值</li>
<li><strong>吞掉</strong> try 中抛出的异常</li>
</ul>
<p><strong>反模式</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 最终返回 2，异常被吞掉</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;  <span class="hljs-comment">// 抛出异常</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 异常消失，返回 2</span>
    }
}
</code></pre>
<p><strong>最佳实践</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ finally 只做资源清理</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> riskyOperation();  <span class="hljs-comment">// 成功时返回</span>
    } <span class="hljs-keyword">catch</span> (Exception e) {
        logger.error(<span class="hljs-string">"操作失败"</span>, e);
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 失败时返回</span>
    } <span class="hljs-keyword">finally</span> {
        cleanup();  <span class="hljs-comment">// 只清理资源，不干预返回值</span>
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-13">五、总结</h3>
<p>Java 异常体系是一个精心设计的分层结构：</p>
<ul>
<li><strong>Error</strong>：系统级灾难，无法恢复，应优雅退出</li>
<li><strong>Exception</strong>：程序级异常，可处理，必须显式应对
<ul>
<li><strong>Checked Exception</strong>：编译器强制检查，代表可预测的外部风险</li>
<li><strong>Unchecked Exception</strong>：运行时异常，代表程序逻辑缺陷</li>
</ul>
</li>
</ul>
<p><strong>异常处理的核心原则</strong>：<strong>快速失败、清晰记录、业务转换、绝不隐瞒</strong>。良好的异常处理不是隐藏错误，而是让错误信息更透明、更易于理解和修复。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 方法派发深度解析：从 Swizzling 到派发机制]]></title>    <link>https://juejin.cn/post/7593292445300359187</link>    <guid>https://juejin.cn/post/7593292445300359187</guid>    <pubDate>2026-01-10T16:32:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593292445300359187" data-draft-id="7590104561476042804" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Swift 方法派发深度解析：从 Swizzling 到派发机制"/> <meta itemprop="keywords" content="性能优化"/> <meta itemprop="datePublished" content="2026-01-10T16:32:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sweet丶"/> <meta itemprop="url" content="https://juejin.cn/user/3227821869921646"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Swift 方法派发深度解析：从 Swizzling 到派发机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3227821869921646/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sweet丶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T16:32:43.000Z" title="Sat Jan 10 2026 16:32:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言：一个危险的实验</h2>
<p>想象一下，你正在调试一个复杂的 iOS 应用，想要在不修改源码的情况下监控所有 <code>UIViewController</code> 的 <code>viewDidAppear</code> 调用；还有如果要支持热修复，该如何？你可能会想到使用 <strong>Method Swizzling</strong>：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">UIViewController</span> {
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzled_viewDidAppear</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">animated</span>: <span class="hljs-type">Bool</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"🎯 [AOP] <span class="hljs-subst">\(<span class="hljs-built_in">type</span>(of: <span class="hljs-keyword">self</span>))</span> 显示"</span>)
        swizzled_viewDidAppear(animated) <span class="hljs-comment">// 调用原始实现</span>
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzleViewDidAppear</span>() {
        <span class="hljs-keyword">let</span> original <span class="hljs-operator">=</span> <span class="hljs-keyword">#selector</span>(viewDidAppear(<span class="hljs-keyword">_</span>:))
        <span class="hljs-keyword">let</span> swizzled <span class="hljs-operator">=</span> <span class="hljs-keyword">#selector</span>(swizzled_viewDidAppear(<span class="hljs-keyword">_</span>:))
        
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> originalMethod <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, original),
              <span class="hljs-keyword">let</span> swizzledMethod <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, swizzled) <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span>
        }
        
        method_exchangeImplementations(originalMethod, swizzledMethod)
    }
}
</code></pre>
<p>看起来完美，对吧？但这里隐藏着一个 Swift 的重要秘密：<strong>为什么必须使用 <code>@objc dynamic</code>？</strong> 如果去掉 <code>dynamic</code> 会发生什么？</p>
<h2 data-id="heading-1">Part 1: 为什么 Swizzling 需要动态派发？</h2>
<h3 data-id="heading-2">1.1 Swizzling 的工作原理</h3>
<p>Method Swizzling 本质上是<strong>在运行时交换两个方法的实现</strong>。它依赖 Objective-C 运行时的消息派发机制：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// Objective-C 运行时的工作方式</span>
objc_msgSend(object, selector, ...)
</code></pre>
<p>当调用 <code>[object method]</code> 时，运行时：</p>
<ol>
<li>根据对象的类查找方法列表</li>
<li>找到对应 selector 的实现（IMP）</li>
<li>执行该实现</li>
</ol>
<p>Swizzling 就是修改了第 2 步的映射关系。</p>
<h3 data-id="heading-3">1.2 Swift 与 Objective-C 的冲突</h3>
<p>问题在于：<strong>Swift 默认不使用消息派发</strong>！</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">normalMethod</span>() { }     <span class="hljs-comment">// Swift 默认派发</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">exposedMethod</span>() { }  <span class="hljs-comment">// 对 OC 可见，但仍不是消息派发</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">dynamicMethod</span>() { }  <span class="hljs-comment">// 这才是消息派发</span>
}
</code></pre>
<p>如果你尝试 Swizzle 一个非 <code>dynamic</code> 的方法：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSwizzle</span>: <span class="hljs-title class_">NSObject</span> {
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">original</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Original"</span>) }
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzled</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Swizzled"</span>) }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">attemptSwizzle</span>() {
        <span class="hljs-keyword">let</span> original <span class="hljs-operator">=</span> <span class="hljs-keyword">#selector</span>(original)
        <span class="hljs-keyword">let</span> swizzled <span class="hljs-operator">=</span> <span class="hljs-keyword">#selector</span>(swizzled)
        
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> origMethod <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, original),
              <span class="hljs-keyword">let</span> swizMethod <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, swizzled) <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span>
        }
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"交换前："</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"original IMP: <span class="hljs-subst">\(method_getImplementation(origMethod))</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"swizzled IMP: <span class="hljs-subst">\(method_getImplementation(swizMethod))</span>"</span>)
        
        method_exchangeImplementations(origMethod, swizMethod)
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"交换后："</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"original IMP: <span class="hljs-subst">\(method_getImplementation(origMethod))</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"swizzled IMP: <span class="hljs-subst">\(method_getImplementation(swizMethod))</span>"</span>)
        
        <span class="hljs-keyword">let</span> test <span class="hljs-operator">=</span> <span class="hljs-type">TestSwizzle</span>()
        test.original()  <span class="hljs-comment">// 输出什么？</span>
    }
}
</code></pre>
<p><strong>运行结果可能让你困惑：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">交换前：</span>
<span class="hljs-attr">original IMP:</span> <span class="hljs-number">0x0000000102f7fbc0</span>
<span class="hljs-attr">swizzled IMP:</span> <span class="hljs-number">0x0000000102f7fcc0</span>

<span class="hljs-string">交换后：</span>
<span class="hljs-attr">original IMP:</span> <span class="hljs-number">0x0000000102f7fcc0</span>
<span class="hljs-attr">swizzled IMP:</span> <span class="hljs-number">0x0000000102f7fbc0</span>

<span class="hljs-string">Original</span>   <span class="hljs-string">//❓</span> <span class="hljs-string">调用结果还是</span> <span class="hljs-string">"Original"</span><span class="hljs-string">！</span>
</code></pre>
<p>为什么 IMP 发生交换后，但行为没变？</p>
<h2 data-id="heading-4">Part 2: Swift 的三种派发方式</h2>
<h3 data-id="heading-5">2.1 派发方式对比</h3>
<p>假设大家已有概念，为了方便快速浏览，我把这些汇总到了一个表格：</p>













































































<table><thead><tr><th>特性</th><th>直接派发 (Direct Dispatch)</th><th>表派发 (Table Dispatch)</th><th>消息派发 (Message Dispatch)</th></tr></thead><tbody><tr><td><strong>Swift 写法</strong></td><td><code>final func</code><br/><code>struct 的方法</code><br/><code>extension 中的方法</code><br/><code>private/fileprivate func</code></td><td><code>class func</code> (默认)<br/><code>@objc func</code> (仅 Swift 内)</td><td><code>@objc dynamic func</code><br/><code>@objc dynamic var</code></td></tr><tr><td><strong>调用方式</strong></td><td>编译时确定地址，直接跳转</td><td>通过在类对象虚函数表查找</td><td>Objective-C 运行时 <code>objc_msgSend</code></td></tr><tr><td><strong>性能</strong></td><td>⚡️ <strong>最快</strong> (几乎无开销)</td><td>⚡ <strong>较快</strong> (一次指针查找)</td><td>🐌 <strong>最慢</strong> (哈希查找+缓存)</td></tr><tr><td><strong>灵活性</strong></td><td>❌ 最低 (无法重写)</td><td>✅ 中等 (支持继承重写)</td><td>✅✅ 最高 (支持运行时修改)</td></tr><tr><td><strong>内存占用</strong></td><td>无额外开销</td><td>每个类一个虚函数表</td><td>每个类方法列表 + 缓存</td></tr><tr><td><strong>重写支持</strong></td><td>❌ 不支持</td><td>✅ 支持</td><td>✅ 支持</td></tr><tr><td><strong>运行时修改</strong></td><td>❌ 不可能</td><td>❌ 不可能 (Swift 5+)</td><td>✅ 可能 (Method Swizzling)</td></tr><tr><td><strong>KVO 支持</strong></td><td>❌ 不支持</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td><strong>典型应用</strong></td><td>工具方法、性能关键代码</td><td>普通业务逻辑、可继承的类</td><td>需要动态特性的代码</td></tr><tr><td><strong>二进制影响</strong></td><td>最小</td><td>中等</td><td>最大 (生成 OC 元数据)</td></tr><tr><td><strong>调试难度</strong></td><td>简单</td><td>中等</td><td>困难 (调用栈复杂)</td></tr></tbody></table>
<h3 data-id="heading-6">2.2 方法派发特别注意点</h3>
<h4 data-id="heading-7"><strong>extension 中的方法特别说明：</strong></h4>
<p>extension 中的方法<strong>默认</strong>是静态派发，不能被子类重写，编译器可以在编译时确定具体实现。
这样设计的原因有下面几点：</p>
<ul>
<li><strong>明确性</strong>: extension表示添加新功能，override表示修改现有功能，两者分离，避免混淆。</li>
<li><strong>安全性</strong>：不允许重写 → 保证 extension 方法的稳定性。</li>
<li><strong>模块化</strong>：不用担心用户重写了自己模块extension中方法导致异常。</li>
<li>良好实践：使用 extension 分离关注点。</li>
</ul>
<pre><code class="hljs language-Swift" lang="Swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseClass</span> {
    <span class="hljs-comment">// 进入类的虚函数表</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">original</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Base original"</span>) }
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">BaseClass</span> {
    <span class="hljs-comment">// 不在虚函数表中！相当于直接是函数地址</span>
    <span class="hljs-comment">// 编译后的伪代码: 是生成一个全局函数</span>
    <span class="hljs-comment">// void String_extension_customMethod(String *self) {</span>
    <span class="hljs-comment">//     // 函数体</span>
    <span class="hljs-comment">// }</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">extensionMethod</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"extension method"</span>) }
    
    <span class="hljs-comment">// ❌ 不能在 extension 中重写原类方法</span>
    <span class="hljs-comment">// override func original() { }  // 编译错误</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span>: <span class="hljs-title class_">BaseClass</span> {
    <span class="hljs-comment">// ✅ 可以重写原类方法</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">original</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"SubClass original"</span>) }
    
    <span class="hljs-comment">// ❌ 不能重写 extension 中的方法</span>
    <span class="hljs-comment">// override func extensionMethod() { }  // 编译错误</span>
}
</code></pre>
<h4 data-id="heading-8"><strong>对 Objective-C 类的 extension</strong></h4>
<pre><code class="hljs language-Swift" lang="Swift"><span class="hljs-comment">// Objective-C 类（如 UIView）</span>
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">UIView</span> {
    <span class="hljs-comment">// 仍然是直接派发（在 Swift 中调用时）</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">swiftExtensionMethod</span>() { }
    
    <span class="hljs-comment">// 但通过 @objc 暴露给 Objective-C 时</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">objcExposedMethod</span>() { }  
    <span class="hljs-comment">// Swift 内：直接派发</span>
    <span class="hljs-comment">// Objective-C 内：通过桥接，底层是消息派发</span>
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">NSObject</span> {
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">specialMethod</span>() { }
    <span class="hljs-comment">// 这会强制使用消息派发</span>
    <span class="hljs-comment">// 可以被重写（因为是消息派发）</span>
    <span class="hljs-comment">// 但这是特殊情况，利用了 Objective-C 运行时</span>
}
</code></pre>
<h4 data-id="heading-9"><strong>协议扩展extension</strong></h4>
<pre><code class="hljs language-Swift" lang="Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drawable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()  <span class="hljs-comment">// 协议要求</span>
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Drawable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() {  <span class="hljs-comment">// 默认实现</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"默认绘制"</span>)
    }
    <span class="hljs-comment">// 这是直接派发，但可以通过协议类型动态派发</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-title class_">Drawable</span> { }

<span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>()
circle.draw()  <span class="hljs-comment">// 直接派发：调用默认实现</span>

<span class="hljs-keyword">let</span> drawable: <span class="hljs-type">Drawable</span> <span class="hljs-operator">=</span> circle
drawable.draw()  <span class="hljs-comment">// 协议派发：通过协议见证表PWT（Protocol Witness Table）</span>
<span class="hljs-comment">// 内存布局</span>
<span class="hljs-type">Circle</span> 实例：
<span class="hljs-operator">┌──────────┐</span>
<span class="hljs-operator">│</span> 数据字段  <span class="hljs-operator">│</span>
<span class="hljs-operator">├──────────┤</span>
<span class="hljs-operator">│</span> <span class="hljs-type">PWT</span> 指针 <span class="hljs-operator">│</span> <span class="hljs-operator">→</span> 指向 <span class="hljs-type">Circle</span> 的协议见证表
<span class="hljs-operator">└──────────┘</span>

<span class="hljs-type">Circle</span> 的 <span class="hljs-type">PWT：</span>
<span class="hljs-operator">┌──────────┐</span>
<span class="hljs-operator">│</span> draw()   <span class="hljs-operator">│</span> <span class="hljs-operator">←</span> 索引 <span class="hljs-number">0</span>
<span class="hljs-operator">├──────────┤</span>
<span class="hljs-operator">│</span> resize() <span class="hljs-operator">│</span> <span class="hljs-operator">←</span> 索引 <span class="hljs-number">1</span>
<span class="hljs-operator">└──────────┘</span>
</code></pre>
<h3 data-id="heading-10"><strong>2.3 Swift 类的虚函数表</strong></h3>
<pre><code class="hljs language-scss" lang="scss">对象实例内存布局：
┌───────────────────┐
│    对象头 (<span class="hljs-number">16</span>字节)  │ ← 包含指向类对象的指针
├───────────────────┤
│  引用计数 (<span class="hljs-number">8</span>字节)   │
├───────────────────┤
│  属性 name (<span class="hljs-number">8</span>字节) │
├───────────────────┤
│  属性 age (<span class="hljs-number">8</span>字节)  │
└───────────────────┘

类对象内存布局：
┌───────────────────┐
│   类信息 (元数据)   │
├───────────────────┤
│  虚函数表指针      │ → 指向虚函数表数组
├───────────────────┤
│  其他元数据...     │
└───────────────────┘

虚函数表结构：
┌───────────────────┐
│    <span class="hljs-built_in">makeSound</span>()    │ ← 函数指针 <span class="hljs-selector-attr">[0]</span>
├───────────────────┤
│       <span class="hljs-built_in">eat</span>()       │ ← 函数指针 <span class="hljs-selector-attr">[1]</span>
├───────────────────┤
│      <span class="hljs-built_in">sleep</span>()      │ ← 函数指针 <span class="hljs-selector-attr">[2]</span>
└───────────────────┘
</code></pre>
<p><strong>虚函数表（V-Table）工作原理：</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">Dog 类的虚函数表（编译时根据顺序确定索引）：
[<span class="hljs-symbol">0</span>]: <span class="hljs-link">Dog.makeSound() 地址</span>
[<span class="hljs-symbol">1</span>]: <span class="hljs-link">Dog.otherMethod() 地址</span>
...

调用 animal.makeSound()：
<span class="hljs-bullet">1.</span> 获取 animal 的虚函数表指针
<span class="hljs-bullet">2.</span> 根据索引得到 makeSound 在表中的地址（编译时确定）
<span class="hljs-bullet">3.</span> 跳转到对应地址执行
</code></pre>
<h3 data-id="heading-11"><strong>2.4 Swift 类方法的派发</strong></h3>
<p>类元数据结构：</p>
<pre><code class="hljs language-css" lang="css">┌─────────────────────┐
│    类型描述符        │ ← Metadata <span class="hljs-selector-tag">header</span>
├─────────────────────┤
│    父类指针          │
├─────────────────────┤
│    实例变量偏移      │
├─────────────────────┤
│  ↓ 实例方法表指针    │ → 指向实例方法的虚函数表
├─────────────────────┤
│  ↓ 类方法表指针      │ → 指向类方法的独立表
├─────────────────────┤
│    协议列表指针      │
├─────────────────────┤
│    泛型信息...       │
└─────────────────────┘

实例方法表（虚函数表）：
┌─────────────────────┐
│    instanceMethod1   │ ← 索引 <span class="hljs-number">0</span>
├─────────────────────┤
│    instanceMethod2   │ ← 索引 <span class="hljs-number">1</span>
└─────────────────────┘

类方法表：
┌─────────────────────┐
│     classMethod1     │ ← 索引 <span class="hljs-number">0</span>  
├─────────────────────┤
│     classMethod2     │ ← 索引 <span class="hljs-number">1</span>
└─────────────────────┘
</code></pre>
<p>派发方式</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    
    <span class="hljs-comment">// 默认的表派发类方法</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">classMethod</span>() {  <span class="hljs-comment">// 通过类的元数据进行派发</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"类方法 - 表派发"</span>)
    }
    
    <span class="hljs-comment">// 直接派发，不能被重写</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">staticMethod</span>() {  
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"静态方法 - 直接派发"</span>)
    }
    
    <span class="hljs-comment">// final class func 等价于 static func</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">alsoCannotOverride</span>() { }
    
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">dynamicClassMethod</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"类方法 - 消息派发"</span>)
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> {
    <span class="hljs-comment">// 存储在全局数据段</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> appName <span class="hljs-operator">=</span> <span class="hljs-string">"MyApp"</span>        <span class="hljs-comment">// __TEXT 段（只读）</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> launchCount <span class="hljs-operator">=</span> <span class="hljs-number">0</span>          <span class="hljs-comment">// __DATA 段（读写）</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">AppConfig</span>()     <span class="hljs-comment">// 引用存储在全局，对象在堆上</span>
    
    <span class="hljs-comment">// 惰性静态属性</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> heavyResource <span class="hljs-operator">=</span> createHeavyResource()
}

<span class="hljs-comment">/*
内存位置：
- appName: 编译时常量 → 代码段
- launchCount: 全局变量 → 数据段  
- shared: 引用在数据段，对象在堆上
- heavyResource: 第一次访问时初始化
*/</span>
</code></pre>
<h2 data-id="heading-12">Part 3: 混合派发的危险实验</h2>
<h3 data-id="heading-13">3.1 当 Swift 遇到 Swizzling</h3>
<p>让我们看一个更完整的例子：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MixedClass</span> {
    <span class="hljs-comment">// 情况1：纯 Swift</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">swiftMethod</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Swift Method"</span>) }
    
    <span class="hljs-comment">// 情况2：暴露给 OC，但 Swift 内使用表派发</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">exposedMethod</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Exposed Method"</span>) }
    
    <span class="hljs-comment">// 情况3：完全动态</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">dynamicMethod</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Dynamic Method"</span>) }
}

<span class="hljs-comment">// 尝试 Swizzle</span>
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">MixedClass</span> {
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzled_swiftMethod</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Swizzled Swift"</span>)
        swizzled_swiftMethod()
    }
    
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzled_exposedMethod</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Swizzled Exposed"</span>)
        swizzled_exposedMethod()
    }
    
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzled_dynamicMethod</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Swizzled Dynamic"</span>)
        swizzled_dynamicMethod()
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">testAll</span>() {
        <span class="hljs-keyword">let</span> instance <span class="hljs-operator">=</span> <span class="hljs-type">MixedClass</span>()
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 原始调用 ==="</span>)
        instance.swiftMethod()      <span class="hljs-comment">// Swift Method</span>
        instance.exposedMethod()    <span class="hljs-comment">// Exposed Method</span>
        instance.dynamicMethod()    <span class="hljs-comment">// Dynamic Method</span>
        
        <span class="hljs-comment">// 尝试 Swizzle swiftMethod（缺少 dynamic）</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> orig <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">#selector</span>(swiftMethod)),
           <span class="hljs-keyword">let</span> swiz <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">#selector</span>(swizzled_swiftMethod)) {
            method_exchangeImplementations(orig, swiz)
        }
        
        <span class="hljs-comment">// 尝试 Swizzle exposedMethod（只有 @objc）</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> orig <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">#selector</span>(exposedMethod)),
           <span class="hljs-keyword">let</span> swiz <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">#selector</span>(swizzled_exposedMethod)) {
            method_exchangeImplementations(orig, swiz)
        }
        
        <span class="hljs-comment">// Swizzle dynamicMethod（正确方式）</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> orig <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">#selector</span>(dynamicMethod)),
           <span class="hljs-keyword">let</span> swiz <span class="hljs-operator">=</span> class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">#selector</span>(swizzled_dynamicMethod)) {
            method_exchangeImplementations(orig, swiz)
        }
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\n</span>=== Swizzle 后调用 ==="</span>)
        instance.swiftMethod()      <span class="hljs-comment">// 还是 Swift Method ❌</span>
        instance.exposedMethod()    <span class="hljs-comment">// 还是 Exposed Method ❌  </span>
        instance.dynamicMethod()    <span class="hljs-comment">// Swizzled Dynamic ✅</span>
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\n</span>=== 通过 OC 运行时调用 ==="</span>)
        <span class="hljs-comment">// 通过 performSelector 调用</span>
        instance.perform(<span class="hljs-keyword">#selector</span>(swiftMethod))      <span class="hljs-comment">// 可能崩溃 💥</span>
        instance.perform(<span class="hljs-keyword">#selector</span>(exposedMethod))    <span class="hljs-comment">// Swizzled Exposed ✅</span>
        instance.perform(<span class="hljs-keyword">#selector</span>(dynamicMethod))    <span class="hljs-comment">// Swizzled Dynamic ✅</span>
    }
}
</code></pre>
<h3 data-id="heading-14">3.2 为什么会这样？</h3>
<p><strong>内存布局解释：</strong></p>
<p>当 Swift 编译一个类时：</p>
<ul>
<li>纯 Swift 方法 → 放入虚函数表</li>
<li><code>@objc</code> 方法 → 生成桥接方法，同时放入虚函数表和 OC 方法列表（在Swift中调用未交换，OC中调用时已交换）</li>
<li><code>@objc dynamic</code> 方法 → 直接放入 OC 方法列表</li>
</ul>
<p>Swizzling 只影响 OC 方法列表，不影响虚函数表！</p>
<h2 data-id="heading-15">Part 4: 属性的 <code>@objc dynamic</code></h2>
<h3 data-id="heading-16">4.1 Swift中使用KVO</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span>: <span class="hljs-title class_">NSObject</span> {
    <span class="hljs-comment">// 普通属性，不支持 KVO</span>
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
    
    <span class="hljs-comment">// @objc dynamic 属性，支持 KVO</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    
    <span class="hljs-comment">// 只有 @objc，不支持 KVO</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>
}

<span class="hljs-keyword">let</span> obj <span class="hljs-operator">=</span> <span class="hljs-type">Observable</span>()

<span class="hljs-comment">// 尝试观察</span>
<span class="hljs-comment">// 运行时错误**Fatal error: Could not extract a String from KeyPath Swift.ReferenceWritableKeyPath&lt;XXX.Observable, Swift.String&gt;**</span>
obj.observe(\.name, options: .new) { <span class="hljs-keyword">_</span>, change <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"name changed: <span class="hljs-subst">\(change.newValue <span class="hljs-operator">??</span> <span class="hljs-string">"nil"</span>)</span>"</span>)
}  

obj.observe(\.age, options: .new) { <span class="hljs-keyword">_</span>, change <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"age changed: <span class="hljs-subst">\(change.newValue <span class="hljs-operator">??</span> <span class="hljs-number">0</span>)</span>"</span>)
}  <span class="hljs-comment">// ✅ 正常工作</span>

obj.observe(\.height, options: .new) { <span class="hljs-keyword">_</span>, change <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"height changed: <span class="hljs-subst">\(change.newValue <span class="hljs-operator">??</span> <span class="hljs-number">0</span>)</span>"</span>)
}  <span class="hljs-comment">// 无法观察到变化</span>
</code></pre>
<h3 data-id="heading-17">4.2 属性访问的派发方式</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertyTest</span> {
    <span class="hljs-comment">// 直接派发（编译时展开），会被内联</span>
    <span class="hljs-keyword">var</span> directProperty: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _storage }
        <span class="hljs-keyword">set</span> { _storage <span class="hljs-operator">=</span> newValue }
    }
    
    <span class="hljs-comment">// 表派发（通过方法）</span>
    <span class="hljs-keyword">var</span> tableProperty: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"getter 调用"</span>)
            <span class="hljs-keyword">return</span> _storage
        }
        <span class="hljs-keyword">set</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setter 调用"</span>)
            _storage <span class="hljs-operator">=</span> newValue
        }
    }
    
    <span class="hljs-comment">// 消息派发（支持 KVO）</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> messageProperty: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _storage }
        <span class="hljs-keyword">set</span> { _storage <span class="hljs-operator">=</span> newValue }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _storage: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
}

<span class="hljs-comment">// @objc dynamic 属性会生成：</span>
<span class="hljs-comment">// - (NSInteger)messageProperty;</span>
<span class="hljs-comment">// - (void)setMessageProperty:(NSInteger)value;</span>
<span class="hljs-comment">// 这些是真正的 Objective-C 方法</span>
</code></pre>
<h3 data-id="heading-18">4.3 属性观察器的有趣现象</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observed</span>: <span class="hljs-title class_">NSObject</span> {
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> {
        <span class="hljs-keyword">didSet</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"value 从 <span class="hljs-subst">\(oldValue)</span> 变为 <span class="hljs-subst">\(value)</span>"</span>)
        }
    }
    
    <span class="hljs-comment">// 测试 KVO 和 didSet 的交互</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>() {
        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> <span class="hljs-number">10</span>  <span class="hljs-comment">// 触发 didSet</span>
        
        <span class="hljs-comment">// 通过 KVC 设置</span>
        <span class="hljs-keyword">self</span>.setValue(<span class="hljs-number">20</span>, forKey: <span class="hljs-string">"value"</span>)  <span class="hljs-comment">// 也会触发 didSet ✅</span>
    }
}

<span class="hljs-comment">// 为什么能工作？</span>
<span class="hljs-comment">// @objc dynamic 属性生成的 setter 会：</span>
<span class="hljs-comment">// 1. 调用 willChangeValueForKey</span>
<span class="hljs-comment">// 2. 设置新值</span>
<span class="hljs-comment">// 3. 调用 didSet（Swift 注入的代码）</span>
<span class="hljs-comment">// 4. 调用 didChangeValueForKey（触发 KVO）</span>
</code></pre>
<h2 data-id="heading-19">Part 5: 派发方式的确定规则</h2>
<h3 data-id="heading-20">5.1 决策树</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// Swift 编译器决定派发方式的逻辑：</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">determineDispatch</span>(<span class="hljs-params">for</span> <span class="hljs-params">method</span>: <span class="hljs-type">Method</span>) -&gt; <span class="hljs-type">DispatchType</span> {
    <span class="hljs-keyword">if</span> method.isFinal <span class="hljs-operator">||</span> type.isFinal <span class="hljs-operator">||</span> type.isStruct {
        <span class="hljs-keyword">return</span> .direct      <span class="hljs-comment">// 1. final 或 struct → 直接派发</span>
    }
    
    <span class="hljs-keyword">if</span> method.isDynamic {
        <span class="hljs-keyword">return</span> .message     <span class="hljs-comment">// 2. dynamic → 消息派发</span>
    }
    
    <span class="hljs-keyword">if</span> method.isObjC {
        <span class="hljs-comment">// @objc 但不 dynamic：桥接方法</span>
        <span class="hljs-keyword">return</span> .table       <span class="hljs-comment">// 3. 在 Swift 内使用表派发</span>
    }
    
    <span class="hljs-keyword">if</span> method.isInExtension <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-operator">!</span>type.isObjCClass {
        <span class="hljs-keyword">return</span> .direct      <span class="hljs-comment">// 4. 非 OC 类的扩展 → 直接派发</span>
    }
    
    <span class="hljs-keyword">return</span> .table           <span class="hljs-comment">// 5. 默认 → 表派发</span>
}
</code></pre>
<h3 data-id="heading-21">5.2 特殊情况</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 1. 协议要求</span>
<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MyProtocol</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">requiredMethod</span>()   <span class="hljs-comment">// 表派发（通过协议见证表）</span>
}

<span class="hljs-comment">// 2. 泛型约束</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">genericFunc</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">MyProtocol</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">obj</span>: <span class="hljs-type">T</span>) {
    obj.requiredMethod()    <span class="hljs-comment">// 静态派发（编译时特化）</span>
}

<span class="hljs-comment">// 3. @_dynamicReplacement</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Replaceable</span> {
    <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">original</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Original"</span>) }
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Replaceable</span> {
    <span class="hljs-meta">@_dynamicReplacement</span>(for: original)
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">replacement</span>() { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Replacement"</span>) }
}
<span class="hljs-comment">// Swift 5 引入的官方 "Swizzling"</span>
</code></pre>
<h2 data-id="heading-22">Part 6: 性能影响与优化</h2>
<p>优化建议</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// ❌ 避免在性能关键路径使用 dynamic</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cache</span> {
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> data: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] <span class="hljs-operator">=</span> [:]  <span class="hljs-comment">// 每次访问都有消息派发开销</span>
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">expensiveOperation</span>() {
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">10000</span> {
            <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> data[<span class="hljs-string">"key"</span>]  <span class="hljs-comment">// 慢！</span>
        }
    }
}

<span class="hljs-comment">// ✅ 优化方案</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedCache</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _data: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] <span class="hljs-operator">=</span> [:]
    
    <span class="hljs-keyword">var</span> data: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _data }
        <span class="hljs-keyword">set</span> { _data <span class="hljs-operator">=</span> newValue }
    }
    
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> observableData: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _data }
        <span class="hljs-keyword">set</span> { _data <span class="hljs-operator">=</span> newValue }
    }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">expensiveOperation</span>() {
        <span class="hljs-keyword">let</span> localData <span class="hljs-operator">=</span> data  <span class="hljs-comment">// 一次读取</span>
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">10000</span> {
            <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> localData[<span class="hljs-string">"key"</span>]  <span class="hljs-comment">// 快！</span>
        }
    }
}
</code></pre>
<h2 data-id="heading-23">Part 7: 实际应用指南</h2>
<h3 data-id="heading-24">7.1 何时使用何种派发？</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 指南：</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-comment">// ✅ 使用直接派发：</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">utilityMethod</span>() { }  <span class="hljs-comment">// 工具方法，不重写</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">helper</span>() { }       <span class="hljs-comment">// 私有方法</span>
    
    <span class="hljs-comment">// ✅ 使用表派发（默认）：</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">businessLogic</span>() { }        <span class="hljs-comment">// 业务逻辑，可能被重写</span>
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">publicAPI</span>() { }       <span class="hljs-comment">// 公开 API</span>
    
    <span class="hljs-comment">// ⚠️ 谨慎使用消息派发：</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">kvoProperty</span>() { }  <span class="hljs-comment">// 需要 KVO</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzleMe</span>() { }    <span class="hljs-comment">// 需要 Method Swizzling</span>
    
    <span class="hljs-comment">// ❌ 避免混用：</span>
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">confusingMethod</span>() { }  <span class="hljs-comment">// 既不是鱼也不是熊掌</span>
    <span class="hljs-comment">// 在 Swift 中是表派发，在 OC 中是消息派发</span>
    <span class="hljs-comment">// 可能导致不一致的行为</span>
}
</code></pre>
<h3 data-id="heading-25">7.2 安全 Swizzling 的最佳实践</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeSwizzler</span> {
    <span class="hljs-comment">/// 安全的 Method Swizzling</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swizzle</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">type</span>: <span class="hljs-type">AnyClass</span>,
                       <span class="hljs-params">original</span>: <span class="hljs-type">Selector</span>,
                       <span class="hljs-params">swizzled</span>: <span class="hljs-type">Selector</span>,
                       <span class="hljs-params">isClassMethod</span>: <span class="hljs-type">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>) <span class="hljs-keyword">throws</span> {
        
        <span class="hljs-comment">// 1. 获取方法</span>
        <span class="hljs-keyword">let</span> getMethod <span class="hljs-operator">=</span> isClassMethod <span class="hljs-operator">?</span> class_getClassMethod : class_getInstanceMethod
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> originalMethod <span class="hljs-operator">=</span> getMethod(type, original),
              <span class="hljs-keyword">let</span> swizzledMethod <span class="hljs-operator">=</span> getMethod(type, swizzled) <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-type">SwizzleError</span>.methodNotFound
        }
        
        <span class="hljs-comment">// 2. 检查是否已经是消息派发</span>
        <span class="hljs-keyword">let</span> originalEncoding <span class="hljs-operator">=</span> method_getTypeEncoding(originalMethod)
        <span class="hljs-keyword">if</span> originalEncoding <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-type">SwizzleError</span>.notMessageDispatch
        }
        
        <span class="hljs-comment">// 3. 检查是否已经 Swizzled</span>
        <span class="hljs-keyword">if</span> alreadySwizzled {
            <span class="hljs-keyword">throw</span> <span class="hljs-type">SwizzleError</span>.alreadySwizzled
        }
        
        <span class="hljs-comment">// 4. 执行交换</span>
        method_exchangeImplementations(originalMethod, swizzledMethod)
    }
    
    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SwizzleError</span>: <span class="hljs-title class_">Error</span> {
        <span class="hljs-keyword">case</span> methodNotFound
        <span class="hljs-keyword">case</span> notMessageDispatch
        <span class="hljs-keyword">case</span> alreadySwizzled
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">UIViewController</span> {
    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">safe_viewDidLoad</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Safe tracking"</span>)
        safe_viewDidLoad()
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">enableSafeTracking</span>() {
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">try</span> <span class="hljs-type">SafeSwizzler</span>.swizzle(
                <span class="hljs-type">UIViewController</span>.<span class="hljs-keyword">self</span>,
                original: <span class="hljs-keyword">#selector</span>(viewDidLoad),
                swizzled: <span class="hljs-keyword">#selector</span>(safe_viewDidLoad)
            )
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ Safe swizzling 成功"</span>)
        } <span class="hljs-keyword">catch</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ Swizzling 失败: <span class="hljs-subst">\(error)</span>"</span>)
        }
    }
}
</code></pre>
<h2 data-id="heading-26">总结</h2>
<h3 data-id="heading-27">关键要点</h3>
<ol>
<li>
<p><strong>Swift 有三种派发方式</strong>：</p>
<ul>
<li>直接派发：最快，用于 <code>final</code>、结构体等</li>
<li>表派发：默认，通过虚函数表</li>
<li>消息派发：最慢，但支持运行时特性</li>
</ul>
</li>
<li>
<p><strong><code>@objc</code> vs <code>dynamic</code></strong>：</p>
<ul>
<li><code>@objc</code>：让 Swift 方法对 OC 可见，但 Swift 内仍用表派发</li>
<li><code>dynamic</code>：强制使用消息派发</li>
<li><code>@objc dynamic</code>：OC 可见 + 消息派发</li>
</ul>
</li>
<li>
<p><strong>Swizzling 的真相</strong>：</p>
<ul>
<li>只能交换消息派发的方法</li>
<li>交换表派发方法会导致 Swift 和 OC 行为不一致</li>
<li>这是很多 Swizzling bug 的根源</li>
</ul>
</li>
<li>
<p><strong>性能影响</strong>：</p>
<ul>
<li>消息派发比直接派发慢 4-5 倍</li>
<li>避免在性能关键路径使用 <code>dynamic</code></li>
<li>合理使用 <code>final</code> 优化性能</li>
</ul>
</li>
</ol>
<h3 data-id="heading-28">哲学思考</h3>
<p>Swift 的派发机制体现了语言设计的平衡艺术：</p>
<ul>
<li><strong>安全 vs 灵活</strong>：表派发保证安全，消息派发提供灵活</li>
<li><strong>性能 vs 功能</strong>：直接派发优化性能，动态派发启用高级功能</li>
<li><strong>Swift vs Objective-C</strong>：两种运行时模型的巧妙融合</li>
</ul>
<p>理解这些机制，你就能：</p>
<ul>
<li>写出更高效的 Swift 代码</li>
<li>安全地使用运行时特性</li>
<li>避免诡异的 Swizzling bug</li>
<li>更好地理解 Swift 的设计哲学</li>
</ul>
<p>记住：<strong>强大的能力伴随着巨大的责任</strong>。动态派发给了你 hook 系统方法的能力，但也可能带来难以调试的问题。使用时务必谨慎！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2024年JavaScript开发者必备的10个ES13新特性实战指南]]></title>    <link>https://juejin.cn/post/7593262196844855348</link>    <guid>https://juejin.cn/post/7593262196844855348</guid>    <pubDate>2026-01-11T00:16:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593262196844855348" data-draft-id="7593262196844838964" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2024年JavaScript开发者必备的10个ES13新特性实战指南"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2026-01-11T00:16:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿橙的百宝箱"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2024年JavaScript开发者必备的10个ES13新特性实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿橙的百宝箱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-11T00:16:52.000Z" title="Sun Jan 11 2026 00:16:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-11
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>2024年JavaScript开发者必备的10个ES13新特性实战指南</strong></h2>
<h2 data-id="heading-1">引言</h2>
<p>JavaScript作为前端开发的基石语言，每年都会通过ECMAScript标准引入新特性。ES13（ECMAScript 2022）虽然已经发布了一段时间，但其中的许多特性在2024年仍然是现代JavaScript开发者的必备技能。本文将深入探讨ES13中最具价值的10个新特性，并结合实际代码示例展示如何在项目中高效应用这些功能。无论你是资深开发者还是刚刚入门，掌握这些特性都将显著提升你的开发效率和代码质量。</p>
<hr/>
<h2 data-id="heading-2">主体</h2>
<h3 data-id="heading-3">1. Top-Level Await</h3>
<p>ES13正式支持了顶级<code>await</code>，允许开发者在模块的顶层直接使用<code>await</code>关键字，而无需包裹在<code>async</code>函数中。这对于模块初始化、动态导入和配置加载非常有用。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ES13之前</span>
(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
})();

<span class="hljs-comment">// ES13之后</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
</code></pre>
<p><strong>实战场景</strong>：</p>
<ul>
<li>动态加载配置或依赖项。</li>
<li>简化模块初始化逻辑。</li>
</ul>
<hr/>
<h3 data-id="heading-4">2. Error Cause</h3>
<p>ES13为<code>Error</code>对象新增了<code>cause</code>属性，允许开发者传递错误的根本原因。这在调试链式错误时尤其有用。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Root error'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'High-level error'</span>, { <span class="hljs-attr">cause</span>: err });
  }
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// "High-level error"</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">cause</span>);   <span class="hljs-comment">// Error: Root error</span>
}
</code></pre>
<p><strong>实战场景</strong>：</p>
<ul>
<li>嵌套错误的追踪和调试。</li>
<li>API调用失败时的详细错误信息传递。</li>
</ul>
<hr/>
<h3 data-id="heading-5">3. Array.prototype.at()</h3>
<p><code>at()</code>方法允许开发者通过索引（支持负数）访问数组元素，解决了传统方括号语法无法直接访问负索引的问题。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">at</span>(-<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span>
</code></pre>
<p><strong>实战场景</strong>：</p>
<ul>
<li>简化数组末尾元素的访问逻辑。</li>
<li>替代冗长的<code>arr[arr.length - N]</code>写法。</li>
</ul>
<hr/>
<h3 data-id="heading-6">4. Object.hasOwn()</h3>
<p><code>Object.hasOwn()</code>是<code>Object.prototype.hasOwnProperty()</code>的更安全替代方案，避免了原型链污染问题。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">'foo'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">'toString'</span>)); <span class="hljs-comment">// false</span>
</code></pre>
<p><strong>实战场景</strong>：</p>
<ul>
<li>检查对象是否拥有某个属性（不继承自原型链）。</li>
<li><code>null</code>或未定义对象的兼容性处理（不会抛出错误）。</li>
</ul>
<hr/>
<h3 data-id="heading-7">5. Class Static Initialization Blocks</h3>
<p>ES13引入了类的静态初始化块（Static Initialization Blocks），允许开发者在类定义时执行复杂的静态属性初始化逻辑。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> {
 <span class="hljs-keyword">static</span> host;
 <span class="hljs-keyword">static</span> port;

 <span class="hljs-keyword">static</span> {
   <span class="hljs-variable language_">this</span>.<span class="hljs-property">host</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">HOST</span> || <span class="hljs-string">'localhost'</span>;
   <span class="hljs-variable language_">this</span>.<span class="hljs-property">port</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-string">'8080'</span>;
 }
}
</code></pre>
<p><strong>实战场景</strong>：</p>
<ul>
<li><strong>环境变量配置的动态加载</strong></li>
<li><strong>静态属性的复杂计算</strong></li>
</ul>
<hr/>
<h3 data-id="heading-8">#6. Private Slot Checks with <code>in</code></h3>
<p>ES13扩展了私有字段的支持，允许使用 <code>in</code>运算符检查对象是否拥有某个私有字段：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> { 
 #name; 

 <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) { 
 <span class="hljs-variable language_">this</span>.#name = name; 
 } 

 <span class="hljs-keyword">static</span> <span class="hljs-title function_">checkName</span>(<span class="hljs-params">obj</span>) { 
 <span class="hljs-keyword">return</span> #name <span class="hljs-keyword">in</span> obj; 
 } 
} 

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'John'</span>); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">User</span>.<span class="hljs-title function_">checkName</span>(user)); <span class="hljs-comment">// true</span>

</code></pre>
<p><strong>优势</strong>
•更安全的私有字段检查机制 •避免try-catch实现方式</p>
<hr/>
<h3 data-id="heading-9">#7.RegExp Match Indices</h3>
<p>通过正则表达式的d标志获取匹配项的起始和结束索引：</p>
<pre><code class="hljs language-js" lang="js">
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/test/</span>d; 
<span class="hljs-keyword">const</span> result = regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">"test"</span>); 

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">indices</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// [0,4]</span>

</code></pre>
<p><strong>应用场景</strong>
•高级文本编辑器功能 •语法高亮实现</p>
<hr/>
<h3 data-id="heading-10">#8.AggregateError</h3>
<p>组合多个错误为一个聚合错误：</p>
<pre><code class="hljs language-js" lang="js">
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([ 
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Error1"</span>)), 
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Error2"</span>)) 
]).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { 

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">AggregateError</span>); <span class="hljs-comment">// true </span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">errors</span>); <span class="hljs-comment">// [Error1, Error2] });</span>

</code></pre>
<p><strong>典型用例</strong>
•批量操作错误收集 •Promise组合操作的统一错误处理</p>
<hr/>
<p>####9.Atomics.waitAsync</p>
<p>非阻塞版本的Atomics.wait：</p>
<pre><code class="hljs language-js" lang="js">
<span class="hljs-keyword">const</span> sharedArray= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedArrayBuffer</span>(<span class="hljs-number">1024</span>); 

<span class="hljs-title class_">Atomics</span>.<span class="hljs-title function_">waitAsync</span>(sharedArray,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>).<span class="hljs-property">value</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>{ <span class="hljs-comment">/*回调*/</span> });

</code></pre>
<p><strong>性能优势</strong>
•不阻塞主线程 •更适合异步编程模型</p>
<hr/>
<p>####10.WeakRefs与FinalizationRegistry增强</p>
<p>改进的内存管理API：</p>
<pre><code class="hljs language-js" lang="js">
<span class="hljs-keyword">const</span> registry= <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizationRegistry</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>{ <span class="hljs-comment">/*清理回调*/</span> }); registry.<span class="hljs-title function_">register</span>(target,<span class="hljs-string">"some value"</span>);

</code></pre>
<p><strong>最佳实践</strong>
•缓存系统实现 •资源释放监听</p>
<hr/>
<p>##总结</p>
<p>ES2022的这些创新特性标志着JavaScript语言的持续成熟。
从Top-Level Await到Private Slot Checks，
每一项改进都针对实际开发痛点。
建议开发者：
1．在生产环境中逐步尝试这些特性，
2．关注浏览器/Node.js的兼容性支持，
3．优先解决团队最迫切的需求点。
要记住，
掌握这些新技术的关键不在于简单的语法记忆，
而是理解其设计哲学和应用边界。
随着JavaScript生态系统的不断演进，
保持对新特性的敏感度将成为区分优秀开发者的重要标准。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（35）什么是Hibernate的聚合函数？]]></title>    <link>https://juejin.cn/post/7593241698370764836</link>    <guid>https://juejin.cn/post/7593241698370764836</guid>    <pubDate>2026-01-11T00:27:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593241698370764836" data-draft-id="7593232758128132102" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（35）什么是Hibernate的聚合函数？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-11T00:27:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（35）什么是Hibernate的聚合函数？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-11T00:27:32.000Z" title="Sun Jan 11 2026 00:27:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-11
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">Hibernate的聚合函数</h3>
<p>在Hibernate中，聚合函数（Aggregate Functions）用于对一组值进行计算并返回单一值。这些函数在执行统计分析、数据汇总和报告时非常有用。常见的聚合函数包括：</p>
<ul>
<li><code>count</code>：计数</li>
<li><code>avg</code>：平均值</li>
<li><code>sum</code>：求和</li>
<li><code>min</code>：最小值</li>
<li><code>max</code>：最大值</li>
</ul>
<p>Hibernate支持在Criteria API和HQL（Hibernate Query Language）中使用聚合函数。</p>
<h3 data-id="heading-1">使用聚合函数的示例代码</h3>
<h4 data-id="heading-2">实体类定义</h4>
<p>我们继续使用之前定义的<code>Person</code>和<code>Address</code>实体类。</p>
<h5 data-id="heading-3">Person类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "person")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Column(name = "age")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>

    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
}
</code></pre>
<h5 data-id="heading-4">Address类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "address")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "street")</span>
    <span class="hljs-keyword">private</span> String street;

    <span class="hljs-meta">@ManyToOne</span>
    <span class="hljs-meta">@JoinColumn(name = "person_id", nullable = false)</span>
    <span class="hljs-keyword">private</span> Person person;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String street, Person person)</span> {
        <span class="hljs-built_in">this</span>.street = street;
        <span class="hljs-built_in">this</span>.person = person;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>

    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStreet</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> street;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStreet</span><span class="hljs-params">(String street)</span> {
        <span class="hljs-built_in">this</span>.street = street;
    }

    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">getPerson</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> person;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPerson</span><span class="hljs-params">(Person person)</span> {
        <span class="hljs-built_in">this</span>.person = person;
    }
}
</code></pre>
<h4 data-id="heading-5">Hibernate配置文件 <code>hibernate.cfg.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span>
        <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>
        <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 数据库连接配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/your_database<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>your_username<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>your_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Hibernate 属性配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.format_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 映射类 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Person"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Address"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-6">HibernateUtil类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateUtil</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SessionFactory sessionFactory;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 从配置文件创建SessionFactory</span>
            sessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>).buildSessionFactory();
        } <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-comment">// 记录启动失败的错误</span>
            System.err.println(<span class="hljs-string">"Initial SessionFactory creation failed."</span> + ex);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionInInitializerError</span>(ex);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SessionFactory <span class="hljs-title function_">getSessionFactory</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> sessionFactory;
    }
}
</code></pre>
<h3 data-id="heading-7">使用聚合函数的示例</h3>
<h4 data-id="heading-8">插入示例数据</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateInsertData</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 插入示例数据</span>
        insertSampleData(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSampleData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">30</span>);
            <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Jane Doe"</span>, <span class="hljs-number">28</span>);
            <span class="hljs-type">Person</span> <span class="hljs-variable">person3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">35</span>);

            session.save(person1);
            session.save(person2);
            session.save(person3);

            <span class="hljs-type">Address</span> <span class="hljs-variable">address1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"123 Main St"</span>, person1);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"456 Oak St"</span>, person2);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"789 Pine St"</span>, person3);

            session.save(address1);
            session.save(address2);
            session.save(address3);

            transaction.commit();
            System.out.println(<span class="hljs-string">"Inserted sample data"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-9">使用聚合函数查询</h4>
<h5 data-id="heading-10">查询Person的平均年龄</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.query.criteria.HibernateCriteriaBuilder;
<span class="hljs-keyword">import</span> org.hibernate.query.criteria.JpaCriteriaQuery;
<span class="hljs-keyword">import</span> javax.persistence.criteria.CriteriaBuilder;
<span class="hljs-keyword">import</span> javax.persistence.criteria.CriteriaQuery;
<span class="hljs-keyword">import</span> javax.persistence.criteria.Root;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateAggregateQueryExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 使用聚合函数查询Person的平均年龄</span>
        queryAverageAge(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryAverageAge</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">CriteriaBuilder</span> <span class="hljs-variable">criteriaBuilder</span> <span class="hljs-operator">=</span> session.getCriteriaBuilder();
            CriteriaQuery&lt;Double&gt; criteriaQuery = criteriaBuilder.createQuery(Double.class);
            Root&lt;Person&gt; root = criteriaQuery.from(Person.class);

            criteriaQuery.select(criteriaBuilder.avg(root.get(<span class="hljs-string">"age"</span>)));

            <span class="hljs-type">Double</span> <span class="hljs-variable">averageAge</span> <span class="hljs-operator">=</span> session.createQuery(criteriaQuery).getSingleResult();
            System.out.println(<span class="hljs-string">"Average age of persons: "</span> + averageAge);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h5 data-id="heading-11">查询Person的总数</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.query.criteria.HibernateCriteriaBuilder;
<span class="hljs-keyword">import</span> org.hibernate.query.criteria.JpaCriteriaQuery;
<span class="hljs-keyword">import</span> javax.persistence.criteria.CriteriaBuilder;
<span class="hljs-keyword">import</span> javax.persistence.criteria.CriteriaQuery;
<span class="hljs-keyword">import</span> javax.persistence.criteria.Root;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateCountQueryExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 使用聚合函数查询Person的总数</span>
        queryPersonCount(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryPersonCount</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">CriteriaBuilder</span> <span class="hljs-variable">criteriaBuilder</span> <span class="hljs-operator">=</span> session.getCriteriaBuilder();
            CriteriaQuery&lt;Long&gt; criteriaQuery = criteriaBuilder.createQuery(Long.class);
            Root&lt;Person&gt; root = criteriaQuery.from(Person.class);

            criteriaQuery.select(criteriaBuilder.count(root));

            <span class="hljs-type">Long</span> <span class="hljs-variable">personCount</span> <span class="hljs-operator">=</span> session.createQuery(criteriaQuery).getSingleResult();
            System.out.println(<span class="hljs-string">"Total number of persons: "</span> + personCount);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h5 data-id="heading-12">查询年龄最小和最大的Person</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.query.criteria.HibernateCriteriaBuilder;
<span class="hljs-keyword">import</span> org.hibernate.query.criteria.JpaCriteriaQuery;
<span class="hljs-keyword">import</span> javax.persistence.criteria.CriteriaBuilder;
<span class="hljs-keyword">import</span> javax.persistence.criteria.CriteriaQuery;
<span class="hljs-keyword">import</span> javax.persistence.criteria.Root;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateMinMaxQueryExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 使用聚合函数查询年龄最小和最大的Person</span>
        queryMinMaxAge(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryMinMaxAge</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">CriteriaBuilder</span> <span class="hljs-variable">criteriaBuilder</span> <span class="hljs-operator">=</span> session.getCriteriaBuilder();

            <span class="hljs-comment">// 查询最小年龄</span>
            CriteriaQuery&lt;Integer&gt; minCriteriaQuery = criteriaBuilder.createQuery(Integer.class);
            
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（36）Hibernate如何处理多对多关系？]]></title>    <link>https://juejin.cn/post/7593241698370781220</link>    <guid>https://juejin.cn/post/7593241698370781220</guid>    <pubDate>2026-01-11T00:28:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593241698370781220" data-draft-id="7593292445300539411" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（36）Hibernate如何处理多对多关系？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-11T00:28:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（36）Hibernate如何处理多对多关系？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-11T00:28:13.000Z" title="Sun Jan 11 2026 00:28:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-11
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">Hibernate中的多对多关系</h3>
<p>在Hibernate中，多对多关系指的是一个实体可以与多个另一个实体实例相关联，反之亦然。为了实现这种关系，通常需要一个中间表来存储两者之间的关联信息。</p>
<h3 data-id="heading-1">多对多关系的示例代码</h3>
<h4 data-id="heading-2">实体类定义</h4>
<p>假设我们有两个实体：<code>Student</code> 和 <code>Course</code>，一个学生可以选修多门课程，一门课程也可以有多个学生。</p>
<h4 data-id="heading-3">Student类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "student")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@ManyToMany(cascade = { CascadeType.ALL })</span>
    <span class="hljs-meta">@JoinTable(
        name = "student_course", 
        joinColumns = { @JoinColumn(name = "student_id") }, 
        inverseJoinColumns = { @JoinColumn(name = "course_id") }
    )</span>
    <span class="hljs-keyword">private</span> Set&lt;Course&gt; courses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>

    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Set&lt;Course&gt; <span class="hljs-title function_">getCourses</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> courses;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCourses</span><span class="hljs-params">(Set&lt;Course&gt; courses)</span> {
        <span class="hljs-built_in">this</span>.courses = courses;
    }
}
</code></pre>
<h4 data-id="heading-4">Course类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "course")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Course</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@ManyToMany(mappedBy = "courses")</span>
    <span class="hljs-keyword">private</span> Set&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Course</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Course</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>

    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Set&lt;Student&gt; <span class="hljs-title function_">getStudents</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> students;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStudents</span><span class="hljs-params">(Set&lt;Student&gt; students)</span> {
        <span class="hljs-built_in">this</span>.students = students;
    }
}
</code></pre>
<h4 data-id="heading-5">Hibernate配置文件 <code>hibernate.cfg.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span>
        <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>
        <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 数据库连接配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/your_database<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>your_username<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>your_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Hibernate 属性配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.format_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 映射类 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Student"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Course"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-6">HibernateUtil类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateUtil</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SessionFactory sessionFactory;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 从配置文件创建SessionFactory</span>
            sessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>).buildSessionFactory();
        } <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-comment">// 记录启动失败的错误</span>
            System.err.println(<span class="hljs-string">"Initial SessionFactory creation failed."</span> + ex);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionInInitializerError</span>(ex);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SessionFactory <span class="hljs-title function_">getSessionFactory</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> sessionFactory;
    }
}
</code></pre>
<h4 data-id="heading-7">插入示例数据</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateInsertData</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 插入示例数据</span>
        insertSampleData(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSampleData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 创建学生</span>
            <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"John Doe"</span>);
            <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"Jane Doe"</span>);

            <span class="hljs-comment">// 创建课程</span>
            <span class="hljs-type">Course</span> <span class="hljs-variable">course1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Course</span>(<span class="hljs-string">"Mathematics"</span>);
            <span class="hljs-type">Course</span> <span class="hljs-variable">course2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Course</span>(<span class="hljs-string">"History"</span>);

            <span class="hljs-comment">// 建立多对多关系</span>
            student1.getCourses().add(course1);
            student1.getCourses().add(course2);

            student2.getCourses().add(course1);
            student2.getCourses().add(course2);

            course1.getStudents().add(student1);
            course1.getStudents().add(student2);

            course2.getStudents().add(student1);
            course2.getStudents().add(student2);

            <span class="hljs-comment">// 保存数据</span>
            session.save(student1);
            session.save(student2);

            transaction.commit();
            System.out.println(<span class="hljs-string">"Inserted sample data"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-8">查询示例数据</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateQueryExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 查询示例数据</span>
        querySampleData(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">querySampleData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 查询所有学生</span>
            List&lt;Student&gt; students = session.createQuery(<span class="hljs-string">"from Student"</span>, Student.class).list();
            <span class="hljs-keyword">for</span> (Student student : students) {
                System.out.println(<span class="hljs-string">"Student Name: "</span> + student.getName());
                <span class="hljs-keyword">for</span> (Course course : student.getCourses()) {
                    System.out.println(<span class="hljs-string">"  Enrolled in: "</span> + course.getName());
                }
            }

            <span class="hljs-comment">// 查询所有课程</span>
            List&lt;Course&gt; courses = session.createQuery(<span class="hljs-string">"from Course"</span>, Course.class).list();
            <span class="hljs-keyword">for</span> (Course course : courses) {
                System.out.println(<span class="hljs-string">"Course Name: "</span> + course.getName());
                <span class="hljs-keyword">for</span> (Student student : course.getStudents()) {
                    System.out.println(<span class="hljs-string">"  Student: "</span> + student.getName());
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-9">多对多关系的详细解释</h3>
<ol>
<li>
<p><strong>实体类定义</strong>：</p>
<ul>
<li><code>Student</code> 类和 <code>Course</code> 类通过 <code>@ManyToMany</code> 注解来定义多对多的关系。</li>
<li><code>Student</code> 类中使用 <code>@JoinTable</code> 注解来定义中间表，指定了关联的学生和课程的外键。</li>
<li><code>Course</code> 类中使用 <code>mappedBy</code> 属性来指定关系维护由 <code>Student</code> 类中的 <code>courses</code> 属性来负责。</li>
</ul>
</li>
<li>
<p><strong>Hibernate配置文件</strong>：</p>
<ul>
<li>标准的Hibernate配置文件，用于数据库连接和映射类的配置。</li>
</ul>
</li>
<li>
<p><strong>HibernateUtil类</strong>：</p>
<ul>
<li>一个实用类，用来创建和返回 <code>SessionFactory</code> 实例。</li>
</ul>
</li>
<li>
<p><strong>插入示例数据</strong>：</p>
<ul>
<li>创建 <code>Student</code> 和 <code>Course</code> 对象，并建立多对多关系。</li>
<li>保存数据到数据库中。</li>
</ul>
</li>
<li>
<p><strong>查询示例数据</strong>：</p>
<ul>
<li>查询所有学生和他们所选修的课程，以及所有课程和选修这些课程的学生。</li>
</ul>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Incremark Solid 版本上线：Vue/React/Svelte/Solid 四大框架，统一体验]]></title>    <link>https://juejin.cn/post/7593232758128050182</link>    <guid>https://juejin.cn/post/7593232758128050182</guid>    <pubDate>2026-01-10T19:17:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593232758128050182" data-draft-id="7593232758128033798" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Incremark Solid 版本上线：Vue/React/Svelte/Solid 四大框架，统一体验"/> <meta itemprop="keywords" content="前端,JavaScript,人工智能"/> <meta itemprop="datePublished" content="2026-01-10T19:17:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="king王一帅"/> <meta itemprop="url" content="https://juejin.cn/user/395479917018408"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Incremark Solid 版本上线：Vue/React/Svelte/Solid 四大框架，统一体验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/395479917018408/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    king王一帅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T19:17:18.000Z" title="Sat Jan 10 2026 19:17:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Incremark 现已支持 Solid，至此完成了对 Vue、React、Svelte、Solid 四大主流前端框架的全面覆盖。</p>
<h2 data-id="heading-0">为什么要做框架无关</h2>
<p>市面上大多数 Markdown 渲染库都是针对特定框架开发的。这带来几个问题：</p>
<ol>
<li><strong>重复造轮子</strong>：每个框架社区都在独立实现相似的功能</li>
<li><strong>能力不一致</strong>：不同框架的实现质量参差不齐</li>
<li><strong>团队切换成本</strong>：换框架意味着重新学习新的 API</li>
</ol>
<p>Incremark 采用不同的思路：<strong>核心逻辑与 UI 框架完全解耦</strong>。</p>
<p><code>@incremark/core</code> 负责所有解析、转换、增量更新的工作，输出的是框架无关的数据结构。各框架包（<code>@incremark/vue</code>、<code>@incremark/react</code>、<code>@incremark/svelte</code>、<code>@incremark/solid</code>）只需要把这些数据渲染成对应框架的组件即可。</p>
<p>这意味着：</p>
<ul>
<li>核心能力一次实现，四个框架同时受益</li>
<li>Bug 修复和性能优化自动同步到所有框架</li>
<li>API 设计保持高度一致，切换框架几乎零学习成本</li>
</ul>
<h2 data-id="heading-1">包结构</h2>
<pre><code class="hljs language-less" lang="less">┌───────────────────────────────┐
│       <span class="hljs-variable">@incremark</span>/core         │
│                               │
│  增量解析 · 双引擎 · 插件系统  │
└───────────────┬───────────────┘
                │
                ▼
┌───────────────────────────────┐
│  <span class="hljs-variable">@incremark</span>/vue               │
│  <span class="hljs-variable">@incremark</span>/react             │
│  <span class="hljs-variable">@incremark</span>/svelte            │
│  <span class="hljs-variable">@incremark</span>/solid  ← NEW      │
└───────────────┬───────────────┘
                │
                ▼
┌───────────────────────────────┐
│       <span class="hljs-variable">@incremark</span>/theme        │
│                               │
│     样式 · 主题 · 代码高亮     │
└───────────────────────────────┘
</code></pre>
<h2 data-id="heading-2">增量解析</h2>
<p>传统 Markdown 渲染器在流式场景下存在性能问题：每次新内容到达都要重新解析整个文档，复杂度是 O(n²)。</p>
<p>Incremark 只处理新增内容，已解析的块不再重复处理，复杂度降至 O(n)。</p>
<h2 data-id="heading-3">四个框架的用法对比</h2>
<p>四个框架的组件 API 完全一致，只是语法风格不同：</p>
<p><strong>Vue</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;script setup&gt;
import { IncremarkContent } from '@incremark/vue'
// ...
&lt;/script&gt;

&lt;template&gt;
  &lt;IncremarkContent :content="content" :is-finished="isFinished" /&gt;
&lt;/template&gt;
</code></pre>
<p><strong>React</strong></p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IncremarkContent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@incremark/react'</span>
<span class="hljs-comment">// ...</span>

&lt;<span class="hljs-title class_">IncremarkContent</span> content={content} isFinished={isFinished} /&gt;
</code></pre>
<p><strong>Svelte</strong></p>
<pre><code class="hljs language-svelte" lang="svelte">&lt;script&gt;
import { IncremarkContent } from '@incremark/svelte'
// ...
&lt;/script&gt;

&lt;IncremarkContent content={content} isFinished={isFinished} /&gt;
</code></pre>
<p><strong>Solid</strong></p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IncremarkContent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@incremark/solid'</span>
<span class="hljs-comment">// ...</span>

&lt;<span class="hljs-title class_">IncremarkContent</span> content={<span class="hljs-title function_">content</span>()} isFinished={<span class="hljs-title function_">isFinished</span>()} /&gt;
</code></pre>
<p>可以看到，除了各框架本身的响应式语法差异（Vue 的 <code>ref</code>、React 的 <code>useState</code>、Svelte 的 <code>$state</code>、Solid 的 <code>createSignal</code>），组件的使用方式完全统一。</p>
<h2 data-id="heading-4">在线演示</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsolid.incremark.com%2F" target="_blank" title="https://solid.incremark.com/" ref="nofollow noopener noreferrer">Solid Demo</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fvue.incremark.com%2F" target="_blank" title="https://vue.incremark.com/" ref="nofollow noopener noreferrer">Vue Demo</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Freact.incremark.com%2F" target="_blank" title="https://react.incremark.com/" ref="nofollow noopener noreferrer">React Demo</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsvelte.incremark.com%2F" target="_blank" title="https://svelte.incremark.com/" ref="nofollow noopener noreferrer">Svelte Demo</a></li>
</ul>
<h2 data-id="heading-5">链接</h2>
<ul>
<li>npm: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40incremark%2Fcore" target="_blank" title="https://www.npmjs.com/package/@incremark/core" ref="nofollow noopener noreferrer">@incremark/core</a></li>
<li>文档: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.incremark.com" target="_blank" title="https://www.incremark.com" ref="nofollow noopener noreferrer">incremark.com</a></li>
<li>GitHub: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fincremark" target="_blank" title="https://github.com/anthropics/incremark" ref="nofollow noopener noreferrer">github.com/anthropics/…</a></li>
</ul>
<p>MIT 许可证。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[软件工程师应该关注的几种 UML 图]]></title>    <link>https://juejin.cn/post/7593528990846943283</link>    <guid>https://juejin.cn/post/7593528990846943283</guid>    <pubDate>2026-01-10T17:22:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593528990846943283" data-draft-id="7593337928308162586" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="软件工程师应该关注的几种 UML 图"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-10T17:22:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="uzong"/> <meta itemprop="url" content="https://juejin.cn/user/372082495985181"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            软件工程师应该关注的几种 UML 图
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/372082495985181/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    uzong
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T17:22:08.000Z" title="Sat Jan 10 2026 17:22:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>UML 的真正价值在于：它并非一套僵化的规范，而是一种用于结构化思考与团队沟通的通用语言。掌握 UML 是软件设计的必备技能，也是高阶开发者的核心能力之一。</p>
<h2 data-id="heading-0">1. 类图 class diagram</h2>
<p>类图不同于 ER 图——后者用于描述关系型数据库中的实体及其关系，而类图则是面向对象开发的核心工具。一份设计良好的类图，几乎等同于系统的代码骨架。</p>
<h3 data-id="heading-1">1.1. 认识类图</h3>
<p>接口、类、实现关系、泛化关系、关联关系、依赖关系； 同时可以包含约束、注解 和 包等。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6f9f5644cac4ef4b5544055fbaf2de4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=TwWXg8UkEu1cY2z7qmHxPVrQhBg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-2">1.1.1 类</h4>
<p><strong>类是面向对象系统中组织结构的核心，是对具有相同属性、行为、关系和语义对象的抽象。</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa6c2fec85904c5391aeea8a661cff89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=9fFXJICoJNnu5y0mUwfLOwsOOEQ%3D" alt="" loading="lazy"/></p>
<p>包括名称（name）、属性(attribute)和操作(operation)。</p>
<h4 data-id="heading-3">1.1.2 接口</h4>
<p>接口是一种特殊的类，所有接口在 UML 中都带有 «interface» 构造型。</p>
<p>在 UML 中，接口使用一个带有名称的小圆圈来进行表示，并且可以通过一条Realize（实现关系）线与实现它的类相连接。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f3bddf8dd0e45fe86c34ddbb1f3f4f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=2GNouduLmpPco1%2Fm94V4QQZ9Trk%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">1.2 类之间的关系</h3>
<ul>
<li>实现关系（realization ;接口实现）</li>
<li>泛化关系 (generalization)</li>
<li>依赖关系 (dependency)</li>
<li>关联关系（association; 特殊的聚合、组合）</li>
</ul>
<h4 data-id="heading-5">1.2.1. 依赖关系</h4>
<p>依赖表示一个模型元素（客户方）需要另一个模型元素（供应方）来达到某种目的，<strong>供应方的修改会影响客户方的执行结果</strong>。 依赖关系暗示着一个客户方如果没有供应方的支持是不完整的。例如，当给一个雇员计算工资的时候，需要使用计算器。UML中，依赖关系用一个从使用者指向提供者的虚箭头表示</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d64f40e437cd41f89e9e692aaeb68027~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=7ZeQxlKsR4fGJk08mLeVNFwwerQ%3D" alt="" loading="lazy"/></p>
<p>提示：依赖关系应从语义层面理解——客户方依赖提供方以实现某项功能，若提供方发生变更，可能影响客户方的行为。</p>
<p>在 Java 中，方法的入参可视为该类对其的依赖。</p>
<h4 data-id="heading-6">1.2.2 泛化关系</h4>
<p>泛化（继承）关系用来描述类的一般和具体之间的关系——is a kind of。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0bb9912c9ed4413aac6fcee968791c5b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=oxeMH%2Fgs8gprdhjvT1ekmANoXvo%3D" alt="" loading="lazy"/></p>
<p>在 UML 中，使用一条带空心三角箭头的实线表示，箭头指向父类。</p>
<h4 data-id="heading-7">1.2.3 关联关系</h4>
<p>关联关系是一种结构关系，指出了一个事物的对象与另一个事物的对象之间的连接。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E7%25B1%25BB%25E5%259B%25BE%2F%25E5%2585%25B3%25E8%2581%2594%25E5%2585%25B3%25E7%25B3%25BB.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E7%B1%BB%E5%9B%BE/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cec2598584743f29a93cb96451c8e70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=GPdPCWc6DH7M5ugACdRcW3NvpkU%3D" alt="" loading="lazy"/></p>
<p>导航性：若A指向B（导航性） 则B为A的成员变量</p>
<p>提示：关联关系中有1对n，也有1对1。如果带有箭头，则表明是一种单方向的。</p>
<h4 data-id="heading-8">1.2.4. 聚合(Aggregation)关系和组合关系（Composition）</h4>
<p>关联关系有两种非常重要的形式，分别是聚合（Aggregation）关系和组合（Composition）关系。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/15b8601eedb9494abc46e7368e26b0c4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=Kh0b9sSRTLfjS6DeLlwzPdZSbPs%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E7%25B1%25BB%25E5%259B%25BE%2F%25E8%2581%259A%25E5%2590%2588%25E5%2592%258C%25E7%25BB%2584%25E5%2590%2588.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E7%B1%BB%E5%9B%BE/%E8%81%9A%E5%90%88%E5%92%8C%E7%BB%84%E5%90%88.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a></p>
<p>聚合和组合都是关联关系的一种特殊情况，如何区别他们，则需要从语义的角度去理解</p>
<ul>
<li>组合 composition：缺一不可。如果其中一个不存在，则整体也无法存在。</li>
</ul>
<p>例如，CPU 和主板是台式主机的核心组成部分，缺一不可。</p>
<ul>
<li>聚合 aggregation: 一个和一群的关系。一个缺少，并不会影响整体。例如大雁和雁群</li>
</ul>
<h4 data-id="heading-9">1.2.5. 实现关系</h4>
<p>大多数情况下，实现关系用来规定接口和实现接口的类或者组件之间的关系。</p>
<p>在 UML 中，实现关系的表示形式和泛化关系的表示符号很相似，使用一条带封闭空箭头的虚线来表示。实现关系还有一种省略的表示法：将接口表示为一个小圆圈并和实现它的类之间用一条线相连</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f964124bd4d942b8a31883db0c91c900~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=%2F96pUBXXGix0KZ0SgJPKfFNLL5E%3D" alt="" loading="lazy"/></p>
<p>提示：在不同的UML工具中，有不同的展现形式。</p>
<h3 data-id="heading-10">1.3. 综合的类图实例</h3>
<ol>
<li>接口使用 «interface» 进行标注，是对一组对象行为的抽象，<strong>不包含具体实现</strong>。例如接口飞翔，需要实现其飞的动作行为</li>
<li>类：抽象类，需要斜体。类包括：类名称、特性 和操作。</li>
<li>实现：大雁实现飞翔</li>
<li>依赖关系：如动物依赖氧气，水。 语义表示。</li>
<li>泛化（继承），鸟继承动物</li>
<li>聚合关系，大雁和雁群的关系。</li>
<li>组合关系： 鸟和翅膀</li>
<li>关联关系：企鹅和气候</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a92ba75d4964408c9591465285d0ef41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=JnvCbFRq1H71dQpLbgzNs8JYge8%3D" alt="" loading="lazy"/></p>
<p>面向对象设计的核心在于分析与抽象，UML 仅是辅助这一过程的可视化工具</p>
<h2 data-id="heading-11">2. <strong>用例图（Use Case Diagram）</strong></h2>
<p>用例描述了用户如何通过系统实现特定目标。用例图由系统边界、参与者（Actor）和用例（Use Case）三者构成，用于回答三个关键问题：</p>
<ul>
<li>系统是什么？</li>
<li>谁在使用系统？</li>
<li>用户希望通过系统完成什么？</li>
</ul>
<p><strong>用例图向用户展示了其捕获的系统、子系统、类或者组件的行为</strong>。简单而言，谁使用这个系统能做什么。</p>
<h3 data-id="heading-12">2.1. 认识用例图</h3>
<p>描述参与者与用例之间通信。可以以不同的视角展现系统的功能性需求。外部用户能够观察到的系统功能、对客户来讲，用例视图是他们业务领域的逻辑化表达；对于开发者，用例图是系统蓝图、开发依据。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c077a382c4c4bf6846f5b467dc1ad36~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=mZpg7EvIZv8fv6WBRXGKRCYo7GA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">2.2. 认识元素</h3>
<h4 data-id="heading-14">2.2.1. 参与者/执行者（actor）</h4>
<p>执行者是系统、子系统或类发生交互作用的外部用户、进程或者其他系统理想化角色。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e685b16db6f4625ae3650beddbeef24~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=Z7lCqVaAMyZSq23i2XajTmOipVc%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-15">2.2.2. 用例</h4>
<p>用例是一个外部可见的系统内聚功能单元，功能单元由一种被称为主体(subject)的类所提供。用例的目的是在不揭示主体内部结构的情况下定义一个连贯行为。例如：产品维护。产品维护包括增删改查。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c8e5b60412348a2b9e5c4092b6d1834~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=9MEd7UNlWit9rO4VlFrzST%2Bq8ho%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-16">2.2.3. 关系</h4>
<p>用例图中涉及的关系有：关联、泛化、包含、扩展。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bfbfc82c12d485696652dc616b2e87a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=5tFwv9E%2B6JD9TRABmVSn8s%2FgJtM%3D" alt="" loading="lazy"/></p>
<p>包含：一个用例包含其他用例、并把它作为自身的片段、这被称为包含关系。</p>
<p>扩展：一个用例可以被定义为基用例的增量扩展、这叫做扩展关系。扩展关系箭头指向被扩展的用例。</p>
<p>泛化：一个用例可以被细化分为一个或多个子用例。任何子用例都可以用于其父用例能够应用的场合。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5089313fdbe9498f952febd2567e5c6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=KJnasPVUNE5rMusmKksjQtiess4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-17">2.3. 案例</h3>
<p>简单的购物系统中部分功能用例图。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0da6b9e06b9d47a49c6120d09263f90d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=olp%2Bcp8jMXnvkoxHAaK%2Bbq8LGyE%3D" alt="" loading="lazy"/></p>
<p>[购买者会员]、[系统管理员] 可以看做是参与者/执行者。（一个实际用户可以是多个参与者，参与者类似于角色，一个人可以有多个角色一样）</p>
<p>[购买者会员]和【商品查询】用例交互。</p>
<p>【电子产品查询】用例继承【商品查询】，是一种泛化关系。</p>
<p>【商品信息维护】包含了【产品信息修改】用例和【商品查询】用例</p>
<p>对[系统管理员]参与者进行说明</p>
<p>“导出电子产品查询”是对“电子产品查询”的扩展——它在基础用例的特定扩展点插入附加行为，而基础用例本身对此无感知。<br/>
若将“导出”视为“查询”流程中不可或缺的一部分，则也可建模为包含（include）关系。两种建模方式各有适用场景，需根据业务语义判断。</p>
<p><strong>用例图的颗粒度一定要有度，防止粒度过细，导致出现滥用。</strong></p>
<hr/>
<h2 data-id="heading-18">3. <strong>序列图（Sequence Diagram）</strong></h2>
<p>按时间顺序展示对象间的消息交互。强调“谁在什么时候调用了谁”。<strong>用途</strong>：API调用链分析、分布式事务协调、性能瓶颈定位（如过多远程调用）。<strong>实战技巧</strong>：在微服务调试中，序列图可清晰展示跨服务调用链，比日志更直观。</p>
<h3 data-id="heading-19">3.1. 认识时序图</h3>
<ol>
<li>序列图强调消息传递的时间顺序，即对象之间发送与接收消息的先后次序。</li>
<li>序列图用来表现用例中的<strong>行为顺序</strong>，描述了如何一步步完成系统的某项功能</li>
<li>序列图揭示了一个<strong>特定场景</strong>的交互，即系统执行期间发生在某个时间点的对象之间的特定交互</li>
</ol>
<p>在UML的表示中，序列图将交互关系表示为一个二维图。其中，纵轴是时间轴，时间沿竖线向下延伸。横轴代表了在交互中各独立的对象</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b127660152c3441bb3dfc942390bccb7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=ryYt8C4N9ds7ZCdrobw7ls%2F4K2I%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-20">3.2. 元素组成</h3>
<p>对象、生命线、激活、消息。</p>
<h4 data-id="heading-21">3.2.1. 对象</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37eb6dc28ed24113bbab3ff3bde316b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=%2FTOkke8g43Hzov1D61YUiEg89iw%3D" alt="" loading="lazy"/></p>
<ul>
<li>序列图中的对象可以是系统的参与者或者任何有效的系统对象。</li>
<li>序列图中对象的符号和对象图中对象所用的符号一样——矩形符号。</li>
<li>对象及其类的名称带有下划线，二者用冒号隔开，使用“对象名 ：类名”的形式。</li>
</ul>

<ul>
<li>通常，将一个交互的发起者称为主角，将其置于序列图的顶部</li>
</ul>
<h4 data-id="heading-22">3.2.2. <strong>生命线</strong></h4>
<p>生命线（Lifeline）是一条垂直的虚线，表示序列图中的对象在一段时间内的存在</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/200867bc6814451191788cc2ff2daf6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=Q%2FMyKkPPEzQIvHzopYmNxD5qawM%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E6%2597%25B6%25E5%25BA%258F%25E5%259B%25BE%2F%25E7%2594%259F%25E5%2591%25BD%25E7%25BA%25BF.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E6%97%B6%E5%BA%8F%E5%9B%BE/%E7%94%9F%E5%91%BD%E7%BA%BF.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a></p>
<ul>
<li>每个对象的底部中心的位置都带有生命线。</li>
<li>生命线是一个时间线，从序列图的顶部一直延伸到底部，所用的时间取决于交互持续的时间。</li>
</ul>
<h4 data-id="heading-23">3.2.3. <strong>激活</strong></h4>
<ul>
<li>序列图可以描述对象的激活（Activation），<strong>激活是对象操作的执行</strong>，它表示一个对象直接地或通过从属操作完成操作的过程。它对执行的持续时间和执行与其调用者之间的控制关系进行建模。</li>
<li>简单地说，<strong>激活表示该对象被占用以完成某个任务</strong>，去激活指的则是对象处于空闲状态、在等待消息。</li>
<li>激活在序列图中用一个细长的矩形框表示，矩形框称为激活条或控制期</li>
</ul>

<ul>
<li>矩形框的顶端与激活时间对齐，而底端与完成时间对齐。即，对象在激活条的顶部被激活，对象在完成自己的工作后被去激活</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99043ccdf01842718c42a48969d7e508~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=w67kK9AEu3PSe1is7JmLQ9dOjWI%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-24">3.2.4. 消息</h4>
<ul>
<li>消息（Messages）是从一个对象（发送者）向另一个或几个其他对象（接收者）发送信号，或由一个对象（发送者或调用者）调用另一个对象（接收者）的操作。</li>
<li>消息定义的是<strong>对象之间某种形式的通信</strong>，它可以激发某个操作、唤起信号或导致目标对象的创建或撤销。</li>
<li>消息有三部分组成：发送者、接收者和活动。消息的表示形式为从发送者对象的生命线指向接收者对象生命线的箭头，箭头的类型表示了消息的类型</li>
</ul>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E6%2597%25B6%25E5%25BA%258F%25E5%259B%25BE%2F%25E6%25B6%2588%25E6%2581%25AF.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E6%97%B6%E5%BA%8F%E5%9B%BE/%E6%B6%88%E6%81%AF.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a5d2130862b4f58a5875b4847e62097~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=2s5ghq%2Fd%2FuXekOgV8zinFBp7D%2BM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-25">3.3. 案例</h3>
<p>下面将以“教师查看学生成绩”为例，介绍如何去创建系统的序列图</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fabee0461071482ca904b345161bf164~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=D29YW8X9r8vm2SqpS%2FWZvFklmZw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-26">4. <strong>活动图（Activity Diagram）</strong></h2>
<p>类似流程图，但支持并行、分支、泳道（Swimlane）。用于描述业务流程或算法逻辑。活动是某件事情正在进行的状态，它既可以是现实生活中正在进行的某一项工作，也可以是软件系统某个类对象的一个操作<br/>
<strong>用途</strong>：审批流设计、复杂业务规则可视化、跨角色协作流程梳理。</p>
<h3 data-id="heading-27">4.1. 认识活动图</h3>
<p>在 UML 中活动图中的活动既可以是手动执行的任务，也可以是自动执行的任务。用圆角矩形表示。活动强调的是动作，所以圆角矩形中的文字应该是动作。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2de8514356e0474b93c6c35569445ec0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=VrnBPXa%2Bpohm%2B9cQEDfK%2BbHsqgc%3D" alt="" loading="lazy"/></p>
<p>用户首先提交订单，随后流程分叉：一方面系统自动生成送货单，另一方面用户选择支付方式……）</p>
<h3 data-id="heading-28">4.2. 活动图与流程图的区别</h3>
<p>活动图描述系统使用的<strong>活动、判定点和分支</strong>，看起来和流程图没什么两样，并且传统的流程图所能表示的内容，大多数情况下也可以使用活动图表示，但是两者是有区别的，不能将两个概念混淆</p>
<p><strong>流程图</strong>着重描述处理过程，它的主要控制结构是顺序、分支和循环，各个处理过程之间有严格的顺序和时间关系</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b60958b9ba45426f818c6328560b0e5b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=xmodjjeBuK9%2FN3KmXhv2QYL5e2w%3D" alt="" loading="lazy"/></p>
<p><strong>活动图</strong>描述的是活动的顺序关系，它着重表现的是系统的<strong>行为</strong>，而非系统的处理过程</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35e87cf91817484bbad168bdef4274dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=mSXh2cZL1P9MYXT%2F4VPqi%2BY2Nvw%3D" alt="" loading="lazy"/></p>
<p><strong>活动图</strong>能够表示并发活动的情形，而<strong>流程图</strong>不能。</p>
<p><strong>活动图</strong>是面向对象的，而<strong>流程图</strong>是面向过程的。</p>
<h3 data-id="heading-29">4.3. 为什么要用活动图</h3>
<ol>
<li>描述一个操作执行过程中所完成的工作。说明角色、工作流、组织和对象是<strong>如何工作</strong>的。</li>
<li>活动图对<strong>用例描述</strong>尤其有用，它可建模用例的工作流，显示用例内部和用例之间的路径。它可以说明用例的实例是如何执行动作以及如何改变对象状态。</li>
<li>显示如何执行一组相关的动作，以及这些动作如何影响它们周围的对象。</li>
<li>活动图对<strong>理解业务处理</strong>过程十分有用。活动图可以画出工作流用以描述业务，有利于与领域专家进行交流。通过活动图可以明确业务处理操作是如何进行的，以及可能产生的变化。</li>
<li>描述<strong>复杂过程</strong>的算法，在这种情况下使用的活动图和传统的程序流程图的功能是差不多</li>
</ol>
<h3 data-id="heading-30">4.4. 组成活动图的图形元素</h3>
<ul>
<li>动作状态（Action State）</li>
<li>活动状态（Activity State）</li>
<li>动作流（Action Flow）</li>
<li>分支（Branch）与合并（Merge）</li>
<li>分叉（Fork）与汇合（Join）</li>
<li>泳道（Swimlane）</li>
<li>对象流（Object Flow）</li>
</ul>
<h4 data-id="heading-31">4.4.1. 动作状态</h4>
<ol>
<li>动作状态是指执行原子的、不可中断的动作，并在此动作完成后通过完成转换转向另一个状态。</li>
<li>在 UML 中动作状态使用平滑的圆角矩形表示，动作状态所表示的动作写在平滑的圆角矩形内部。</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d6bc9511eee46a1951886919a544c4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=JcisCsFKVy7pB0LnQy5TuExeIVc%3D" alt="" loading="lazy"/></p>
<p>动作状态。语法结构：动宾</p>
<h4 data-id="heading-32">4.4.2. 活动状态</h4>
<ol>
<li>活动状态用于表达状态机中的非原子的运行。</li>
<li>活动状态的表示图标也是平滑的圆角矩形，并可以在图标中给出入口动作和出口动作等信息</li>
</ol>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E6%25B4%25BB%25E5%258A%25A8%25E5%259B%25BE%2F%25E6%25B4%25BB%25E5%258A%25A8%25E7%258A%25B6%25E6%2580%2581.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E6%B4%BB%E5%8A%A8%E5%9B%BE/%E6%B4%BB%E5%8A%A8%E7%8A%B6%E6%80%81.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3448934a645c49c18ddbcc3417a49ca4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=amedhcecqFwEuHEuj%2FAZAXlO4Ig%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-33">4.4.3. 动作流</h4>
<ol>
<li>所有动作状态之间的转换流称之为动作流。</li>
<li>与状态图的转换相同，活动图的转换也用带箭头的直线表示，箭头的方向指向转入的方向</li>
</ol>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E6%25B4%25BB%25E5%258A%25A8%25E5%259B%25BE%2F%25E5%258A%25A8%25E4%25BD%259C%25E6%25B5%2581.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E6%B4%BB%E5%8A%A8%E5%9B%BE/%E5%8A%A8%E4%BD%9C%E6%B5%81.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/218e8d3b3d07444482fde6c022cf7b61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=pP3qWLKuakDqJC0NiEQYKebtIlY%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-34">4.4.4. 分支与合并</h4>
<ul>
<li>分支是用菱形表示的，它有一个进入转换（箭头从外指向分支符号），一个或多个出转换（箭头从分支符号指向外）。而每个出转换上都会有一个监护条件，用来表示满足什么条件的时候执行该转换。</li>
<li><strong>出转换的条件应当是互斥的，这样可以保证只有一条出转换能够被触发。</strong></li>
</ul>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E6%25B4%25BB%25E5%258A%25A8%25E5%259B%25BE%2F%25E8%25BD%25AC%25E6%258D%25A2.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E6%B4%BB%E5%8A%A8%E5%9B%BE/%E8%BD%AC%E6%8D%A2.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2592eeaf0a614a6682a319bdf108cebb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=vC%2FaTPQozj7oK97CrZPdVowrzJo%3D" alt="" loading="lazy"/></p>
<p>合并指的是两个或者多个控制路径在此汇合的情况。合并表示从对应的分支开始的条件行为的结束。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E6%25B4%25BB%25E5%258A%25A8%25E5%259B%25BE%2F%25E5%2590%2588%25E5%25B9%25B6%25E5%2592%258C%25E5%2588%2586%25E6%2594%25AF.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E6%B4%BB%E5%8A%A8%E5%9B%BE/%E5%90%88%E5%B9%B6%E5%92%8C%E5%88%86%E6%94%AF.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/71e0c5de406047c9937a5c4c374e4bc2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=aZL44a9IZ6Qkv1a%2F9Q9i2TWjPMk%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-35">4.4.5. 分叉与汇合</h4>
<ol>
<li>分叉和汇合都使用加粗的水平（或者竖直）线段表示</li>
</ol>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E6%25B4%25BB%25E5%258A%25A8%25E5%259B%25BE%2F%25E5%2588%2586%25E5%258F%2589%25E4%25B8%258E%25E6%25B1%2587%25E5%2590%2588.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E6%B4%BB%E5%8A%A8%E5%9B%BE/%E5%88%86%E5%8F%89%E4%B8%8E%E6%B1%87%E5%90%88.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9aaa8d12f50489ca1eb276b0e93f16d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=e6tjkwP9LS1lmWPBQD97vo%2BBK5g%3D" alt="" loading="lazy"/></p>
<ol>
<li><strong>分叉用于将动作流分为两个或者多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。</strong></li>
</ol>
<p>注意：分叉与汇合的特性。分叉并行，汇合等待同步</p>
<ol>
<li><strong>分叉可以用来描述并发线程，每个分叉可以有一个输入转换和两个或多个输出转换，每个转换都可以是独立的控制流。</strong></li>
<li>汇合代表两个或多个并发控制流同步发生，<strong>当所有的控制流都达到汇合点后，控制才能继续往下进行</strong>。</li>
<li><strong>如果一个处理在其他处理之前到达了</strong> <strong>汇合</strong> <strong>，它将会等待，直到所有的处理都准备好之后才会向联结传递控制权</strong>。</li>
</ol>
<p>每个汇合可以有两个或多个输入转换和一个输出转换</p>
<h4 data-id="heading-36">4.4.6. 区分合并与汇合</h4>
<ul>
<li>合并结合了两个以上的控制路径，在任何执行中每次只走一条，不同路径之间是互斥关系。</li>
<li>汇合结合了两条或者两条以上的<strong>并行</strong>控制路径，在执行过程中，所有路径都要走过，先到的控制流要<strong>等</strong>其他路径的控制流到达后才能继续运行</li>
</ul>
<h3 data-id="heading-37">4.5. 泳道</h3>
<ol>
<li>泳道将活动图中的<strong>活动按职责化分为若干组</strong>，<strong>并把每一组指定给负责这组活动的业务组织</strong></li>
<li>在活动图中，泳道用垂直实线绘出，垂直线分隔的区域就是泳道。</li>
<li>在泳道上方可以给出泳道的名字，负责泳道内的全部活动。</li>
<li>在包含泳道的活动图中，每个活动只能明确地属于一个泳道</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5aff0f40b81241efa0ad1e6a3a823f36~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=0nYUIcWjf0BjjBZJ06hqUS%2Bpw7I%3D" alt="" loading="lazy"/></p>
<ol>
<li>泳道中，按<strong>职责</strong>划分为若干个组。属于职责划分，可以分为：客户、系统、供应商。各司其职，互不干涉。例如：系统负责生成送货单和收款</li>
<li>分叉和汇合是成对出现的。分叉是并行，汇合时等待。直到所有分支都走完后才往下一个活动。</li>
<li>活动图<strong>描述的是活动的顺序关系，它着重表现的是系统的行为</strong>，而非系统的处理过程</li>
<li>分支和合并是只有每次只能走一条，不同路径之间是互斥的。</li>
</ol>
<h2 data-id="heading-38">5. <strong>状态机图（State Machine Diagram）</strong></h2>
<p>描述对象在其生命周期内响应事件所经历的状态变迁。<strong>用途</strong>：订单状态流转（待支付→已支付→已发货→已完成）、设备控制逻辑、游戏AI行为树。<strong>深度价值</strong>：强制你考虑所有可能的状态和转换条件，避免“状态遗漏”导致的Bug。</p>
<h3 data-id="heading-39">5.1. 认识状态机</h3>
<p>面向对象分析与设计中，对象的状态、状态的转换、触发状态转换的事件、对象对事件的响应(即事件的行为)等都可以用状态图来描述。</p>
<p>状态图通过建立<strong>类对象的生命周期模型</strong>来描述<strong>对象随时间变化的动态行为</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ad6d6bb41034255938d4eb380f0af3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=H6hzTg7MngSKqTKWRjQ%2B2N1k7ug%3D" alt="" loading="lazy"/></p>
<p>它用于描述某个特定对象在其生命周期中所有可能的状态，以及由于各种事件的发生而引起状态之间的转移和变化</p>
<h3 data-id="heading-40">5.2. 状态图组成</h3>
<p><strong>状态图由初始状态、终止状态、状态、转换、判定等组成</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/376521cfe87c4e198e30fce49dcdd946~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=UW0TM060uGwrphk%2B%2FvFeQOn3L1U%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-41">5.3. 案例</h3>
<p>创建一个状态图来描述银行卡从最初制造到顾客使用的各种状态过程</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae8309af75ce4f059d00f8ad7c9ec548~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=wij9VJYe1RPXgzSu7KoV7PmKltQ%3D" alt="" loading="lazy"/></p>
<p>状态图创建步骤：1. 选中建模实体 2. 对各种状态进行建模 3. 找相关事件和转换。 <strong>需要在转换的箭头上添加事件行为。</strong></p>
<hr/>
<h2 data-id="heading-42">6. 协作图 (UML 2.x 通信图)</h2>
<p>文档中 “协作图” 是 UML 1.x 的旧称，UML 2.x 已统一更名为 “通信图”</p>
<p><strong>协作图</strong>强调发送和接收消息的对象之间的结构组织的交互图，<strong>显示对象、对象之间的链接以及对象之间的消息。</strong></p>
<h3 data-id="heading-43">6.1. 认识协作图</h3>
<p><strong>协作图就是表现对象协作关系的图，它表示了协作中作为各种类元角色的对象所处的位置</strong>，在图中主要显示了类元角色（Classifier Roles）和关联角色（Association Roles）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/606d19729c244d56925695f35e237aaf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=zVP%2Ff5q0obHTwSePkq34mHA2Ps8%3D" alt="" loading="lazy"/></p>
<p><strong>类元角色和关联角色描述了对象的配置和当一个协作的实例执行时可能出现的连接</strong>;<strong>当协作被实例化时，对象受限于类元角色，连接受限于关联角色。</strong></p>
<hr/>
<h3 data-id="heading-44">6.2. 组成元素</h3>
<p>协作图（Collaboration Diagram）是由对象（Object）、消息（Messages）和链（Link）等构成的</p>
<h4 data-id="heading-45">6.2.1. 对象</h4>
<p>协作图中对象也是类的实例,其表示形式使用包围名称的<strong>矩形框来标记</strong>、所显示的<strong>对象及其类的名称带有下划线、二者用冒号隔开</strong>、使用“<strong>对象名:类名</strong>”的形式等</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E5%258D%258F%25E4%25BD%259C%25E5%259B%25BE%2F%25E5%25AF%25B9%25E8%25B1%25A1.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E5%8D%8F%E4%BD%9C%E5%9B%BE/%E5%AF%B9%E8%B1%A1.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41dbe0a501fb44e584ad57c4b5a4b3a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=5oskL3BJbX%2FGuv%2BqYH6M2lvrjz4%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-46">6.2.2. 消息</h4>
<ol>
<li>在协作图中，可以通过一系列的消息（Messages）来<strong>描述系统的动态行为</strong>。</li>
<li>每个消息包括一个<strong>顺序号以及消息的名称</strong>。为了说明交互过程中消息的<strong>时间顺序，需要给消息添加顺序号</strong>。</li>
<li>顺序号是消息的一个数字前缀，是一个整数，由1开始递增，每个消息都必须由唯一的顺序号。<strong>嵌套消息使用点表示法</strong></li>
</ol>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuzong%2Fuml%2Fblob%2Fmaster%2F%25E5%258D%258F%25E4%25BD%259C%25E5%259B%25BE%2F%25E6%25B6%2588%25E6%2581%25AF.png" target="_blank" title="https://github.com/uzong/uml/blob/master/%E5%8D%8F%E4%BD%9C%E5%9B%BE/%E6%B6%88%E6%81%AF.png" ref="nofollow noopener noreferrer"><img src="" alt="" loading="lazy"/></a><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3325d2ff0e6c46c29ad079bef4aca5f7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=i5VHXXwdUA2NdVJQ0G2maEGlXYY%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-47">6.2.3. 链</h4>
<p>在协作图中的链是用<strong>连接各个对象之间的实线表示</strong>。</p>
<ul>
<li>链是关联的实例，当一个类与另一个类之间有关联时，<strong>这两个类的实例之间就有链，一个对象就能向另一个对象发送消息。所以链是对象间的发送消息的路径</strong>。</li>
<li>为了说明一个对象如何与另一个对象连接，可以在链的末路上附上一个路径构造型。如构造型&lt;&gt;，表示指定对象对发送方而言是局部的</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/660bdaa937c0434aaffa0643e04aed7a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=PffgCVeJd0rlCnJMNEHQRCgKExo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-48">6.3. <strong>协作图与序列图的区别与联系</strong></h3>
<h4 data-id="heading-49">6.3.1. 时序图</h4>
<p>取100元人民币的时序图</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f90b34021aca42dcb0b3ae4b59a1c31d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=ANOdgiPHDUW%2BWhCh0tb4yVpdME4%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-50">6.3.2. 协作图</h4>
<p>取100元人民币的协作图</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28855bc4917749bca10cadc6c6088abd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=n71jzZZM6oQOTATZXvKZu23h%2Bx0%3D" alt="" loading="lazy"/></p>
<ul>
<li>都是<strong>交互图</strong>，<strong>描述对象之间的交互</strong></li>
<li>都包含一系列<strong>消息集合</strong></li>
<li>时序图强调消息传送的时间<strong>先后顺序</strong></li>
<li>协作图中描述了该协作所有对象组成的网络结构以及相互发送消息的<strong>整体行为</strong></li>
</ul>
<h3 data-id="heading-51">6.4. 案例</h3>
<p>协作图强调整体行为，时序图强调时间顺序。</p>
<p>以下以“学生信息管理系统”的一个简单用例“教师查看学生成绩”为例，介绍如何创建系统的协作图。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a08fb22977474671b3be4072a42e3232~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=cIsS9lDXI%2BCdn31X6QHyUIer%2BZg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-52">7. 组件图</h2>
<p>用于可视化系统组件的组织和关系。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed4cd921284140b1aa1656637e93c6d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=t5FAbUmmFf2OedD%2F00%2Fn2Pe7pHA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-53">7.1. 认识组件图</h3>
<p>这些图有助于将复杂的系统分解成易于管理的组件，展示它们之间的相互依存关系，确保高效的系统设计和架构。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a989273759ee4e8d99108903f3e8d7c5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=JDQWWE0vXzXizi4SyKvRDmaE0RY%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-54">7.2. 案例</h3>
<p>组件图用于展示系统内部各模块（组件）的组织方式及其依赖关系，体现“小模块如何组装成大系统”的架构逻辑</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e002306209e441bfa8d0b0a7966d98b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=ihXgLpCMPacVdgd62cqKC7dL9Yw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-55">8. 部署图</h2>
<p><strong>部署</strong>图是一种可视化系统架构的图表，展示软件组件如何部署到硬件上。它能清晰地显示组件在服务器、工作站和设备等不同节点上的分布情况。例如计算机和设备，以及它们之间是如何连接的。<a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E9%2583%25A8%25E7%25BD%25B2%25E5%259B%25BE%2F0%3FfromModule%3Dlemma_inlink" target="_blank" title="https://baike.baidu.com/item/%E9%83%A8%E7%BD%B2%E5%9B%BE/0?fromModule=lemma_inlink" ref="nofollow noopener noreferrer">部署图</a>的使用者是开发人员、系统集成人员和测试人员。部署图用于表示一组物理结点的集合及结点间的相互关系，从而建立了系统<a href="https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E7%2589%25A9%25E7%2590%2586%25E5%25B1%2582%2F0%3FfromModule%3Dlemma_inlink" target="_blank" title="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82/0?fromModule=lemma_inlink" ref="nofollow noopener noreferrer">物理层</a>面的模型。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9217d0c9ac94552adcd39406c127b1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=to2s5eH5dVIrikfaO0IkoOcPagk%3D" alt="" loading="lazy"/></p>
<p>部署图在实际开发中<strong>应用广泛。</strong></p>
<h3 data-id="heading-56">8.1. 案例</h3>
<p>使用 UML 部署图为软件组件的物理部署建模。在部署图中，硬件组件（例如，web服务器、邮件服务器、应用服务器）被呈现为节点，其中在硬件组件内运行的软件组件呈现为工件。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c9e1effc27343e6a082bc22ad28ebc4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=QWHu5wXgwGVgKi3TzSfQvnEruKI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-57">9. 对象图</h2>
<p><strong>对象图是</strong>一种图形表示法，展示对象及其在特定时刻的关系。它提供了系统结构的快照，捕捉了存在的实例及其关联的静态视图。</p>
<p>对象之间的关系是用以下符号定义的</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27cb416d728240ed83ecd3c08e65481f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=ibNXyju6ghkaWMXz86NdVW1Cl3c%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c0fdd9948eb47de82f98efc412ff82d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=jkwYp%2Ft9kosd7ETFj%2FI7I9IssqQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-58">10. 包图</h2>
<p>使用包图管理大型项目的模型。包图也可用于呈现子系统或模块之间的结构和依赖性。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2589ed1dd52f4fd1904d465a76afca58~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdXpvbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768670528&amp;x-signature=BteQSG29DUAGKtcgoAULPo1fKvw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-59">11. 总结</h2>
<p><strong>UML 是否过时？</strong><br/>
当前开发者更倾向于使用白板、Draw.io 或 Excalidraw 等工具绘制“类 UML 风格”的草图，而非严格遵循 UML 规范。这并非否定 UML 的价值，而是强调<strong>沟通效率优先于形式合规</strong>。</p>
<p>无需精通所有 UML 图，但应掌握类图、序列图、状态机图、用例图和部署图等 UML 图。</p>
<p>一些参考资料和网站：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fplantuml.com%2Fzh%2Fcomponent-diagram" target="_blank" title="https://plantuml.com/zh/component-diagram" ref="nofollow noopener noreferrer">plantuml.com/zh/componen…</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.visual-paradigm.com%2Ftutorials%2F" target="_blank" title="https://www.visual-paradigm.com/tutorials/" ref="nofollow noopener noreferrer">www.visual-paradigm.com/tutorials/</a></p>
<p>《大象 Thinking in UML 》第二版</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[后端线上发布计划模板]]></title>    <link>https://juejin.cn/post/7593541291012358171</link>    <guid>https://juejin.cn/post/7593541291012358171</guid>    <pubDate>2026-01-10T18:00:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593541291012358171" data-draft-id="7593541291012341787" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="后端线上发布计划模板"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-10T18:00:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="uzong"/> <meta itemprop="url" content="https://juejin.cn/user/372082495985181"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            后端线上发布计划模板
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/372082495985181/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    uzong
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T18:00:51.000Z" title="Sat Jan 10 2026 18:00:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252b3a}.markdown-body ::selection{color:#fff;background-color:#ed7373}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-bottom:.6em;margin-top:1.5em;padding-bottom:4px;color:#ed7373}.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px;padding-bottom:12px;border-bottom:1px solid #dfe1e6}.markdown-body h3{font-size:18px}.markdown-body h4{font-size:16px}.markdown-body h5,.markdown-body h6{font-size:14px}.markdown-body p{line-height:inherit;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border-top:1px solid #dfe1e6;margin:33px 0}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:rgba(239,198,221,.2666666667);color:#7b164f;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==") 10px 10px no-repeat;background-size:40px;background-color:#fdf8f8}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#252b3a;background:#fdf8f8}.markdown-body a{position:relative;text-decoration:underline;text-decoration-color:#ffd4d4;color:#ed7373;padding-right:18px;padding-bottom:4px}.markdown-body a[href^=http]:after{position:absolute;display:inline-block;width:16px;height:16px;margin-left:2px;margin-top:6px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAAXNSR0IArs4c6QAAD1lJREFUeF7tnV122zgShQHJG5gT9/OkV2J7JR3voI/U707eI5/eQeyVRFlJa56nc2YDFjkHEulWHP3g5xZYAK5eku6QYOFWfSwUAJLW8EcFqMBJBSy1oQJU4LQCBITRQQXOKEBAGB5UgIAwBqhAnALMIHG68axGFCAgjTia3YxTgIDE6cazGlGAgDTiaHYzTgECEqcbz2pEAQLSiKPZzTgFCEicbjyrEQUISCOOZjfjFCAgcbrxrEYUICCNOJrdjFOAgMTpxrMaUYCANOJodjNOAQISpxvPakQBAtKIo9nNOAUISJxuPKsRBQhII45GdfN/v//+/l9//rlBtae9HQKi3UOZ7ft7sfhgjfm3sfa9u3RvzHtrjPv77r8PfpvemB0o1v3Z95tuNvt29fKyqQkgApI5ADVebgeFtTfGmA8I+3pj1rbv17Ouey4dFgKCiIgC2/i+WDwYax0QbzMDtDcjLC67/PL58xraeIbGCEgGkTVd4vty+QWVKUL75WCZb7f3JWUVAhLq5UKPHzLGRyXmP822208lgEJAlESMlBlDfeGyhsafelAIiMawAdjkpmO38/kXa8wtoDnRJvq+v79+fHwSvUhk4wQkUjjNp/33jz9uZ33/VbONP9nW9x/fPT5+0mYzAdHmkUR7lNUaob1RN+QiIKEuVHz838vl1xKGVOck1DbTRUAUB7yvaSXVG5592sy22zsNs1wExNNjWg+rEI5XqWfb7a9TQ0JAtEa+h101wzF0f/JMQkA8AlHjIQ3AMco+KSQERGP0X7CpITj2Skw4BUxACgOkOThG/0wECQEpCJBm4Rh81Fl7l3tHMAEpBJCJ4Hjq+/7bvOt229THGSVny8vV1W6b/Kzrbnprb088VAVXN/fMFgGBuxDfYE443L4oB0TM9OqwxcVtjJR7xiTzUIuA4OMZ2mI2OICBN+wgfpACJWcWISDQcMY2lgMOt7XjerW6w1q+b03sqUUgzJf6TUAuKTTRv+eAI8f0qdSwK1cWISATAXDusjngyDkj5PrTzedu+z2uNsmURQiIMkBqg2OUVwKSHFmEgCgCpFY4xCDJkEUIiBJAaodjlBlZuEtOMIz2EhAFgLQCxxtIIG9YkR5mEZCJAWkNjldIlsu/EEW79AsfCMiEgLQKx8EaCSKLPL1bre6l3EhApJS90G7LcKCziOQwi4BMAAjh+GGlPTmLSK7pEJDMgBCOfwRHvb9Lsg4hIBkBIRw/i/0dUawLrocQkEyAEI7jQoPeNi9WqBOQDIAQjtMig16uTUAyxLHIJQjHeVkRdYjkijoziAgW+0YJx2VxEYAYYzbvVqtfL18t/AgCEq6Z1xmEw0um3U2km8/dqnrS791qJRLLIo0m9bSCkwmHvxNBgDCD+Es+7ZGEI0x/DrHC9Cr6aMIR7j7ELBaL9HDds59BOOIkB33wh9O8cfLnOYtwxOsM+egPV9LjHSB9JuFIU/j7ctmntSD7cmvOYiV6B3IHPGOD5E7VxK4nnw4q0A03Kya7QqYBwpGmK6j+MFJrIK53zCCRPgZtsjt59Zozh+s0aP3DNSW2BkJAIuFATE2eu3TtcLi+w24wggU6AYkABDVuPnXpFuAAZg8jrReHWAGQIB177LLSzg7oqtih4Dcsig6vmEECw0CyKG8BDic3VEPh4RUBCQAENePSaubY1R2LxYOxNvklDa8aEpCACBY+FLKgdcTGZjLHYvHBWuu+PoX6iQ+vmEE8XQW/8w3XJRyeDjhymOTi4OHlWKRf8JFUYU444uGQXvsgIAG+kcgesXAM6y83/fAhGtv36242+5b708i+8kmtF+XKHhxiTZA9YuDwCLSn2Xb7KebLtL7BHnqch82hTY7HZ6k9xotxiHXGTejsEQXHcvnVGnPrEU2b2XZ7pwESQTjEFwbf6kxAzgGCeOvf2H7ElGQMoDmHH8ekk4RD8snBU2FAQE4oAy7Og594S7p+BIweGeriIZJw5CzMWaRfdDV0UStqzByTPX7oVt9/nHXdc64hV41wsEjPMLyKqTucWZAtGZkyiTAc2esOZpBMs1cpY2bIW89dP4UhkYZj6pqKNcgRWFBb2lO+fAQDxBiTYse5e4k0HMaY4NrNY/QcdAgBOSJX8vjf3biNWV+vVndB3jg4GPZA0b5N+BSwNByp+sXqzmleD+UQgMTWHqN5AgEIg0TAtrdemTxzjAYxgxzLIMul23X6wYOlU4dEzVy9bQw5zNq1DahHpOGYuuZgBvGI+uQZJEAgOjOHWsjB+t7DbK9DUgIQkVnPGZmadb0ECDyIGeR4Bkl6mRnS0WhIYsf2LcLhQoOACACCfk8T+Dnu4BetJa3qe9yxkTcUj8sFHUJAjgPiPugSO6yB1B9vzUJCEppFBLPHprP2Xut2fWaQE/eSxOJYBJDR1ETbXnscUosk12THdVYPBwE5AUhiQIgCAswk3tO+As/ji2oUNIa6cDCHWOBp3tDhS4wzUZD4ZhEkIDn0idH01DkEBAyIaw5dpB9zHqgu8FqQgw3rEncXIAPft60qAXF32JRt3qnBJ7X36a1TUwPX926O2Pbiey3fwM11XBWADGsFv5n9o6m72SfnkJ2Iff98/fj4FCJo6mpxrmnLVJCdJj4wp+pRKhxVFOmeBXXwSw2S7s6glXQfqJPs3N0/+nufG0jCdbyGcT59neKYYjNIxKfPvGdtnCM8wTvpM587M8LhgOGPVwDHTAz4wofQQaqNIgGJgGOvX8CdPXVYEXKtFOcm2+k5zHI2hmx7yTXMTNHO59ziAEne9uAJCeChqaCM5eOsY8cA7PSqQw6vPWSt13rvjV1PnbXPmlfHQ7QuChBEMIQUjAnj7uCMFeI09GxW7N1+54+uuxkmRf4z77p1yuxhigZS5xYDCAKOUUTfdQrELFGOoVZqvRQLiFRQamq3CECQcPhObY5OSs4iATNFsYGRamMNxXSsdpfOUw8IGg4nSMgdE5JFhCEhIJfCPP7fVQOCmKE5Ik3wRrnUABxtkLpTJ9vnOXERH2blnqkWECE4ot42gsoiodnLN6wAmwm91kJ87anpOJWAABa/Tvso8m6ZfJf+xyLo9G/ytPduCqr/+O7x8VNNgY3qizpAROEwJnh4NQodskh20TnAgITUaEB7Lva9sANUAZI6XXlB++Q7N3KohdqKgrApZNKisPhONlcNIMJwBM1cnVMVEZDIWgShGwrW5GhU2IAKQBBOPqct+g4JqUcAwxpI/ZHpAS+Fse9l0qSARG869Ora/iA0HK7NmJ2tP5kMAASUzaLrsgA3FHvopICUljkOvZwKCQJcRCYL2ZtWbJQnGD4ZICXDMeo93MHdO3yD36Hlux/slG8hs1ec4r2IziSAgIYGJzuHuDtfVG44IGr6FzG8An1gNKdWvppqOi47ILA73wkVp3B4ICTJY37gDSbZFk3BLGFLVkBQsy6nhJgCjtEWn5oEMd6HagjIZBJBqanNbIBAHXtEwSnhODRn2EP2MPy/sTaBPWWHrN20aKYJiLe2ZANEcguJVkenvp/rrbOQcEz13XHNMByzLQsgktlDKxzoQADWHXvTOLzyclEWQMB3vteOtQKHxNZ/bi/x4kP+AzpS2YNw+Dn46FHMHt7iiWcQiexBOLz9e+xATu0GyCcKiMSaB+EI8O6xQ5k9ggQUBQSxV+iwN4QjyLfMHslyCX7EE157NHLnkyjIxziRemkEIA7VNiGWQcDTkk28VEAUjgI/XqOBGjFAgMV5E0WlJBxcFIxHTQQQ5PCqhbpDGo7ZdntX2ztz40M+7EwRQICzV9VnD2E4RJ6oDAuxso8WAQRVf9S+2isNB4vydDhlAFku+3TT4t9hBbi2eBPScBhjmpjYkHaUXkAqntaVhgPx3Il04JXSPhwQVIFe6/CKcJSCxt5OrYBUWZwTjrLgEAEEMYNV4xCBcJQHhwggoECoqsAEaXIywmq8oWjBCT7EgkzxVlSgEw4toR5nBwGJ083rLMLhJZPqg/CALJdfjDHubYPxvwoyCOGId7+mM+GAgAKj6BoEpAFrDgWkqASk5KKTcCiIaqAJcEBanuYlHMDIVNIUHJBWV9IJh5KIBpsBB8TZB/gssSlpJyrhAEelouakAPkr5psZb3QpolAnHIqiWcAUEUBQj9tq37BIOAQiUlmTMoAsFh+stW49JO2neD2EcKS5tpSzRQBBzGSNAmrMIoSjlPBOt1MEkKFQR9Qh6t5CTjjSg66kFiQBSd9yMiqpZKhFOEoKbYytYoAgh1muq1MPtQgHJuBKa0UMEOgwa6/qZqr3OxGO0sIaZ68sIIvFg7H2I87c/JBAnm85I0DJ+86AflXblCggAlkkayZBreec8j7hUMvFq2HygOCzyM54ya0obj/Zdj7/Yo25lXIh4ZBSFtuuOCBCWWQPiTHr+XZ7j3zvrHS9Mdp9vVrdYV3J1iQUyAOIUBY5EORptt1+SgFlAMN933z8trmE3juoCYeItCKNZgFEMoscquKCz/b9etZ1zz6wDFDcmP1QShQMZg6R+BVvNBsgw7qIWzwUD8RBtU1vzMb93Q5/DkH63u5tyGXH63CQmUM8nuEXyAbILovID7XgAiEa5LAKoeI0bWQFpEVICMc0gY26anZActUjKIFS2iEcKerpOHcSQIbn1r/mrgNySk44cqotd61JAHHdqRkSwiEXsLlbngwQ19EJZrbE9SUc4hJnvcCkgFQHiZLnVrJGUOUXmxyQUV/pjYHSfmzhc9XSGmpsXw0gBU8Bbzpr73/5/Hmt0cG0KU0BVYAcQOLeDp91pTtGRtYbMaqVdY46QMa6xPb9g+R282Q3sd5IlrCEBlQCMgqndJariDc+lhB8JdioGpDXAn7/IjrxregXHJa8pb6EgKCNPypQBCATg0IwGqamKEB+GHp13U1v7a3Q1vWnvu+/XT8+PjUcG+z6/lGJ8n+uVhmK+nHmK2QGzD0zsnZAzLtu7fOgVfmKsQe+ClQByLHOur1eL1dXO1Bs170C089mm6uXl92DVITBN0zaPa5aQNp1KXuOVICAINVkW9UpQECqcyk7hFSAgCDVZFvVKUBAqnMpO4RUgIAg1WRb1SlAQKpzKTuEVICAINVkW9UpQECqcyk7hFSAgCDVZFvVKUBAqnMpO4RUgIAg1WRb1SlAQKpzKTuEVICAINVkW9UpQECqcyk7hFSAgCDVZFvVKUBAqnMpO4RUgIAg1WRb1SlAQKpzKTuEVICAINVkW9UpQECqcyk7hFTg//8JNVC78ovQAAAAAElFTkSuQmCC");background-size:100%}.markdown-body a:active,.markdown-body a:hover{opacity:.66}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #ed7373;border-spacing:0}.markdown-body thead{color:#fff;text-align:left}.markdown-body thead tr{background:#ed7373}.markdown-body thead th{border-bottom:1px solid #dfe1e6}.markdown-body tr{background-color:#fff}.markdown-body tr:nth-child(2n){background-color:#fdf2f2}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#252b3a;padding:1px 23px;margin:22px 0;border-left:4px solid #ed7373;background-color:#fdf2f2}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{padding-left:10px;margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#ed7373}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body input[type=checkbox]{appearance:none;-webkit-appearance:none;-moz-appearance:none;outline:none;width:16px;height:16px;border-radius:2px;background-color:transparent;box-shadow:inset 0 0 0 1px rgba(28,31,35,.3490196078);vertical-align:middle;margin:0;transform:translateY(-2px)}.markdown-body input[type=checkbox]:checked{background-color:#ed7373;background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjFlbSIgaGVpZ2h0PSIxZW0iIGFyaWEtaGlkZGVuPSJ0cnVlIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3LjQxMSA3LjMwOGExLjUgMS41IDAgMDEuMjggMi4xMDNsLTYuNSA4LjVhMS41IDEuNSAwIDAxLTIuMzc1LjAxbC0zLjUtNC41YTEuNSAxLjUgMCAxMTIuMzY4LTEuODQybDIuMzA2IDIuOTY1IDUuMzE4LTYuOTU1YTEuNSAxLjUgMCAwMTIuMTAzLS4yOHoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=");box-shadow:inset 0 0 0 1px #ed7373}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p><strong>敬畏每一行代码，敬畏每一次变更。</strong><br/>
本模板旨在通过结构化、可验证、可回溯的方式，降低发布风险，保障系统稳定。</p>
<h2 data-id="heading-0">一、📅 发布基本信息</h2>

































<table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td><strong>发布名称</strong></td><td>示例：用户中心 v2.3.0 上线</td></tr><tr><td><strong>发布时间</strong></td><td>2026-01-15 01:00 – 02:30</td></tr><tr><td><strong>发布负责人</strong></td><td>xxx</td></tr><tr><td><strong>协同人员</strong></td><td>xxx</td></tr><tr><td><strong>发布类型</strong></td><td>✅ 功能上线 / 🔁 配置变更 / 🐞 紧急修复 / ⚙️ 架构调整</td></tr><tr><td><strong>是否灰度发布</strong></td><td>是 / 否（若“是”，说明策略：如 5% → 20% → 100%）</td></tr></tbody></table>
<h2 data-id="heading-1">二、🧩 发布依赖清单（必须全部完成并验证）</h2>
<p>✅ 每项依赖需明确负责人、完成状态、验证方式，避免“我以为你做了”。</p>




































































<table><thead><tr><th>依赖项</th><th>描述与范围</th><th>负责人</th><th>完成状态</th><th>验证方式</th></tr></thead><tbody><tr><td>DB 变更（DDL/DML）</td><td>新增 <code>user_profile</code> 表，添加索引 <code>idx_mobile</code></td><td>xxx</td><td>✅</td><td><code>DESC user_profile</code>+ 执行计划验证</td></tr><tr><td>Nacos 配置更新</td><td>新增 <code>user-center.feature.new-login=true</code></td><td>xxx</td><td>✅</td><td>配置中心截图 + 应用启动日志</td></tr><tr><td>MQ Topic 创建</td><td>新建 <code>user-event-v2</code>，Consumer 已部署</td><td>xxx</td><td>✅</td><td>RocketMQ 控制台确认</td></tr><tr><td>下游服务兼容</td><td>通知订单服务适配新用户字段</td><td>xxx</td><td>✅</td><td>邮件/群聊记录 + 接口 Mock 测试</td></tr><tr><td>网关路由配置</td><td><code>/api/v2/user/**</code>路由至新服务集群</td><td>xxx</td><td>⏳</td><td>待发布后验证</td></tr><tr><td>Restful 白名单</td><td>添加 IP <code>10.10.5.x/24</code>到白名单</td><td>xxx</td><td>✅</td><td>网关日志抽样验证</td></tr><tr><td>SQL 脚本地址</td><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fsql-audit.spotter.ink%2Fsubmitsql%2Fabc123" target="_blank" title="https://sql-audit.spotter.ink/submitsql/abc123" ref="nofollow noopener noreferrer">sql-audit.spotter.ink/submitsql/a…</a></td><td>—</td><td>—</td><td>脚本 ID: <code>SQL-20260115-001</code></td></tr><tr><td>......</td><td>......</td><td>......</td><td>......</td><td/></tr></tbody></table>
<p>💡 <strong>SQL 规范提醒</strong>：</p>
<ul>
<li>所有 DDL/DML 必须经过 <strong>至少一人 Review</strong></li>
<li>DML 操作必须带 <code>WHERE</code> + <code>LIMIT</code>（如适用）+ 事务包裹</li>
<li><strong>不可逆操作</strong>（如 DROP COLUMN）需单独评估并提供数据备份</li>
</ul>
<hr/>
<h2 data-id="heading-2">三、⚠️ 影响与风险评估</h2>








































<table><thead><tr><th>影响维度</th><th>具体描述</th><th>风险规避措施</th><th>负责人</th><th>是否已确认</th></tr></thead><tbody><tr><td>API 兼容性</td><td>新增字段 <code>nick_name</code>，旧客户端可能忽略</td><td>提前通知下游，接口保持向后兼容</td><td>......</td><td>✅</td></tr><tr><td>性能影响</td><td>新增索引可能短暂锁表（&lt;2s）</td><td>在低峰期执行，监控慢 SQL</td><td>......</td><td>✅</td></tr><tr><td>用户体验</td><td>登录流程变更，首次加载略慢</td><td>增加 loading 提示，前端兜底</td><td>......</td><td>✅</td></tr><tr><td>监控覆盖</td><td>新增埋点 <code>login_v2_success</code></td><td>已在 Grafana 配置告警看板</td><td>......</td><td>✅</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-3">四、↩️ 回滚策略（失败时快速止损）</h2>
<p><strong>原则：任何变更必须可回滚，不可逆操作需提前报备！</strong></p>















































<table><thead><tr><th>回滚项</th><th>回滚方案</th><th>触发条件</th><th>执行人</th><th>可行性</th></tr></thead><tbody><tr><td>应用代码</td><td>回滚至 Git Tag <code>v2.2.1</code>（Commit: a1b2c3d）</td><td>错误率 &gt; 5% 持续5分钟</td><td>张三</td><td>✅ 高</td></tr><tr><td>Nacos 配置</td><td>切换回 <code>user-center.feature.new-login=false</code></td><td>功能异常</td><td>王五</td><td>✅ 高</td></tr><tr><td>DB 结构</td><td><strong>不可回滚</strong>（仅新增字段）</td><td>—</td><td>—</td><td>⚠️ 仅支持补偿</td></tr><tr><td>DB 数据</td><td>若 DML 出错，使用备份快照 <code>backup_20260114</code>恢复</td><td>数据污染</td><td>李四</td><td>✅ 中（需30min）</td></tr><tr><td>网关路由</td><td>切回旧路由规则</td><td>服务不可用</td><td>运维</td><td>✅ 高</td></tr></tbody></table>
<p>📌 <strong>回滚后动作</strong>：</p>
<ul>
<li>通知所有相关方</li>
<li>记录故障时间线</li>
<li>24 小时内提交复盘报告</li>
</ul>
<hr/>
<h2 data-id="heading-4">五、📋 发布执行步骤</h2>
<h3 data-id="heading-5">🕒 发布窗口：2026-01-15 01:00 – 02:30</h3>
<h4 data-id="heading-6">▶️ Pre-Release（发布前）</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 所有 CR 完成并通过（PR #1234）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 预发环境全链路回归测试通过</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 建立发布沟通群，@ 所有关键人员</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> ......</li>
</ul>
<h4 data-id="heading-7">▶️ Release（发布中）</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> <strong>01:00</strong> – 执行 DB 变更（李四）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>  <strong>01:10</strong> – 更新 Nacos 配置（王五）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>  <strong>01:15</strong> – 滚动发布应用（张三，按 20% → 50% → 100%）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>  <strong>01:40</strong> – 验证网关路由 &amp; 白名单（运维）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>  <strong>01:50</strong> – 触发核心链路自动化回归（测试）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> ......</li>
</ul>
<h4 data-id="heading-8">▶️ Post-Release（发布后）</h4>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input type="checkbox" disabled="disabled"/>   <strong>02:00–02:30</strong>：密切观察监控（错误率、延迟、CPU、GC）</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="disabled"/>   验证关键业务指标（如登录成功率 ≥ 99.9%）</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="disabled"/>    通知产品/运营/下游团队发布完成</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="disabled"/>    归档发布记录至 Wiki：[链接]</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="disabled"/>   .....</p>
</li>
</ul>
<h2 data-id="heading-9">六、✅ 发布成功标准</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>    核心功能可用（登录、查询、修改）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>   监控无异常告警（持续 30 分钟）</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>   日志无 ERROR/WARN 堆积</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>   下游服务调用正常</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/>   ......</li>
</ul>
<blockquote>
<p>预祝发布成功！</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我学习到的A2UI概念]]></title>    <link>https://juejin.cn/post/7593262196844740660</link>    <guid>https://juejin.cn/post/7593262196844740660</guid>    <pubDate>2026-01-10T15:16:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593262196844740660" data-draft-id="7592893391572746266" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我学习到的A2UI概念"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-10T15:16:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端工作日常"/> <meta itemprop="url" content="https://juejin.cn/user/4371313961207838"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我学习到的A2UI概念
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4371313961207838/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端工作日常
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:16:09.000Z" title="Sat Jan 10 2026 15:16:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>生成式AI在生成文本、图像和代码方面表现出色。现在，是时候将其用于生成上下文相关的<strong>界面</strong>了。A2UI 是谷歌开源的<strong>大模型生成式 UI 协议</strong>，聚焦解决多代理网络下 UI 响应的互操作性、跨平台、安全渲染等核心问题；通过<strong>声明式 JSON 数据格式</strong>让代理生成上下文相关的界面描述，由客户端调用原生组件渲染，实现了安全、可增量更新、框架无关的生成式 UI 交互</p>
<h4 data-id="heading-0"><strong>1. 旧范式：对话式交互的核心痛点（大模型交互的三年困局：被 “聊天框” 束缚）</strong></h4>
<p>2022 年 ChatGPT 问世后，大模型在能力、参数上持续升级，但交互方式始终未变，存在四大核心痛点：</p>
<ol>
<li><strong>操作效率低</strong>：点几下可完成的操作，需通过多轮文字对话实现；</li>
<li><strong>能力隐藏化</strong>：无法像 GUI 一样直观展示功能，需用户主动想到才能调用；</li>
<li><strong>用户习惯相悖</strong>：GUI 已普及十几年，聊天式交互迁移成本高，易打断用户思路；</li>
<li><strong>复杂操作难表达</strong>：文字无法清晰描述操作的先后顺序与依赖关系。</li>
</ol>
<p>简言之，大模型用 2025 年的先进能力，搭配了 1970 年代的终端界面。</p>
<h4 data-id="heading-1"><strong>2. 新范式：A2UI的定义与本质</strong></h4>
<ul>
<li><strong>定义</strong>：<strong>AI生成式主动用户界面</strong>。AI的输出从“一段文字回复”变为  <strong>“个性化App与文字的混合体”</strong>  。</li>
<li><strong>本质</strong>：AI根据<strong>当前用户、时间、场景</strong>的实时需求，从预定义的组件库中动态组合并生成交互界面（如卡片、表单、图表）。</li>
<li><strong>类比</strong>：相当于大模型的  <strong>“触屏革命”</strong>  ，AI 从 “回复文字的对话伙伴” 转变为 “即时生成界面的设计师”。</li>
<li><strong>角色转变</strong>：AI从一个需要被“对话”的伙伴，转变为一个为你即时“构建体验”的界面设计师。</li>
</ul>
<h4 data-id="heading-2"><strong>3. 为什么A2UI是“范式转移”？</strong></h4>
<ul>
<li>
<p><strong>解决的问题不同</strong>：</p>
<ul>
<li>
<p><strong>过往大模型更新方向</strong>：聚焦 “如何让 AI 更聪明”，如提升上下文长度、推理能力、多模态感知、工具调用能力，均为<strong>线性的能力提升</strong>；</p>
</li>
<li>
<p><strong>A2UI 的更新方向</strong>：聚焦 “如何让 AI 更好用”，通过交互方式的改变实现<strong>指数级的体验提升</strong>，是大模型产品的核心范式转移。</p>
</li>
</ul>
</li>
</ul>
<h4 data-id="heading-3"><strong>4. 典型场景验证：订餐厅的体验差距</strong></h4>

























<table><thead><tr><th>维度</th><th>传统聊天式 AI</th><th>A2UI 方式</th></tr></thead><tbody><tr><td>交互形式</td><td>多轮文字对话</td><td>可视化界面操作</td></tr><tr><td>交互成本</td><td>8 轮对话，耗时约 2 分钟</td><td>3 次点击，耗时约 10 秒</td></tr><tr><td>用户体验</td><td>流程繁琐，易产生负面情绪</td><td>操作简洁，即时完成</td></tr></tbody></table>
<h4 data-id="heading-4"><strong>5. 跨信任边界渲染的关键挑战</strong></h4>
<p>进入多代理网络时代（A2A 协议支撑跨机构代理协作），远程代理无法直接操作宿主应用的 UI 层，只能通过消息传输；传统解决方案（发送 HTML/JS 并在 iframe 沙盒化）存在<strong>体积大、样式脱节、安全复杂</strong>三大问题，亟需一种 “像数据一样安全，像代码一样富有表现力” 的 UI 传输方式。</p>
<h4 data-id="heading-5"><strong>6. A2UI 核心定义与定位</strong></h4>
<ol>
<li>
<p><strong>项目属性</strong>：开源项目（Apache 2 协议），处于早期阶段（v0.8），旨在联合社区完善规范、拓展传输方式与渲染器集成。</p>
</li>
<li>
<p><strong>核心构成</strong>：</p>
<ul>
<li>一套针对<strong>可更新、代理生成的 UI</strong>优化的声明式数据格式；</li>
<li>一组初始渲染器，支持 Lit、Angular、Flutter 等 UI 框架（未来将拓展更多）。</li>
</ul>
</li>
<li>
<p><strong>核心功能</strong>：代理可生成 / 填充适配当前对话的丰富 UI 布局，以<strong>消息（非可执行代码）</strong> 形式传递给前端，由客户端自主渲染，兼顾品牌风格与安全性。</p>
</li>
<li>
<p><strong>适用主体</strong>：编排器代理、远程 A2A 子代理均可生成 A2UI 布局，支持多代理协作场景。</p>
</li>
</ol>
<h2 data-id="heading-6"/>













<table><thead><tr><th>核心挑战</th><th>解决方案（A2UI 核心设计）</th></tr></thead><tbody><tr><td>跨信任边界的 UI 渲染（远程代理无法操作宿主 UI，传统 iframe 方式缺陷明显）</td><td>将 UI 规范封装为<strong>JSON 格式的消息序列</strong>，作为结构化输出即时生成或模板填充后传输；客户端使用原生 UI 组件渲染，保留对样式和安全的完全控制权。</td></tr></tbody></table>
<h4 data-id="heading-7"><strong>7. 关键技术突破：“三个不可能三角”的解法</strong></h4>

























<table><thead><tr><th>矛盾三角</th><th>A2UI的解决方案</th><th>形象比喻</th></tr></thead><tbody><tr><td><strong>安全性与灵活性</strong></td><td>AI只能从<strong>经审核的组件库</strong>中“组合”界面（点菜），不能编写任意前端代码（做菜）。</td><td><strong>乐高模式</strong>：AI自由拼接，但积木块是安全、预制的。</td></tr><tr><td><strong>一次生成与全平台可用</strong></td><td>AI生成一份<strong>平台无关的UI描述（如JSON蓝图）</strong> ，各平台客户端将其渲染为原生组件。同一响应可在网页（React）、iOS（SwiftUI）、Android（Flutter）上分别渲染，实现 “一次编写，全平台渲染”。</td><td><strong>“Write once, render everywhere”</strong> ：一份蓝图，多端适配。</td></tr><tr><td><strong>即时响应与复杂界面</strong></td><td>支持<strong>流式渲染</strong>，界面边生成边展示，用户无需等待全部完成即可交互。</td><td><strong>“边想边画”</strong> ：解决了复杂界面生成耗时超过用户耐心（3 秒）的问题，实现复杂界面的即时反馈。</td></tr></tbody></table>
<h4 data-id="heading-8"><strong>8. A2UI 的多元应用场景想象</strong></h4>
<ol>
<li><strong>照片定制化处理</strong>：用户上传照片后，AI 生成个性化交互表单（如选择保留元素、预算范围、风格偏好），而非纯文字分析；</li>
<li><strong>数据分析可视化</strong>：用户询问数据问题后，AI 直接生成<strong>交互式仪表盘</strong>（柱状图、折线图、饼图，支持下钻查看详情），而非大段文字分析；</li>
<li><strong>多代理协作统一化</strong>：不同 AI 代理协作完成任务时，通过 A2UI 的标准化 “UI 语言” 生成风格统一的界面，避免回复割裂，提升体验。</li>
</ol>
<h4 data-id="heading-9"><strong>9. 未来影响与行动启示</strong></h4>

























<table><thead><tr><th>角色</th><th>核心启示</th></tr></thead><tbody><tr><td>普通用户</td><td>无需学习提示词技巧，无需忍受多轮确认，体验 “好用 10 倍” 的 AI，获取 “结果 + 工具” 而非单纯 “答案”；</td></tr><tr><td>产品经理</td><td>重新思考 AI 产品形态，聊天界面不再是最优解，可设计组件库让 AI 组合成无限种界面；</td></tr><tr><td>开发者</td><td>前端开发工作从 “实现设计稿” 转变为 “设计 AI 可调用的组件库”，组件的可组合性、语义化成为核心竞争力；</td></tr><tr><td>创业者</td><td>迎来窗口期，率先拥抱 “生成式界面” 的产品，可获得代际优势。</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nacos - 服务发现]]></title>    <link>https://juejin.cn/post/7593338828217909263</link>    <guid>https://juejin.cn/post/7593338828217909263</guid>    <pubDate>2026-01-10T15:22:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593338828217909263" data-draft-id="7593296804109254696" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nacos - 服务发现"/> <meta itemprop="keywords" content="微服务,Java"/> <meta itemprop="datePublished" content="2026-01-10T15:22:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="元Y亨H"/> <meta itemprop="url" content="https://juejin.cn/user/2839351584888617"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nacos - 服务发现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2839351584888617/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    元Y亨H
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:22:27.000Z" title="Sat Jan 10 2026 15:22:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Nacos 的服务发现（Service Discovery）是指服务消费者（Consumer）如何获取服务提供者（Provider）地址列表的过程。</p>
<p>Nacos 采用了 <strong>“主动拉取 + 被动推送”</strong> 相结合的机制，确保了服务发现的<strong>实时性</strong>和<strong>高可用性</strong>。</p>
<hr/>
<h3 data-id="heading-0">一、 服务发现的整体架构</h3>
<p>服务发现主要涉及三个角色：</p>
<ol>
<li><strong>服务提供者 (Provider)</strong>：注册自己的 IP/端口到 Nacos。</li>
<li><strong>Nacos Server</strong>：保存服务注册表，并感知实例状态变化。</li>
<li><strong>服务消费者 (Consumer)</strong>：从 Nacos 获取地址列表，并监听变化。</li>
</ol>
<hr/>
<h3 data-id="heading-1">二、 详细流程详解</h3>
<h4 data-id="heading-2">1. 消费者初始化与订阅 (Subscription)</h4>
<p>当一个微服务启动并需要调用其他服务时：</p>
<ul>
<li><strong>查询缓存</strong>：消费者首先会检查本地内存中是否有目标服务的实例列表。</li>
<li><strong>发起订阅</strong>：如果没有或需要更新，消费者会向 Nacos Server 发起订阅请求（Subscribe）。</li>
<li><strong>版本差异</strong>：
<ul>
<li><strong>Nacos 1.x</strong>：通过 HTTP 轮询定时拉取，并开启一个 UDP 端口接收服务端的推送。</li>
<li><strong>Nacos 2.x</strong>：通过 <strong>gRPC 双向流</strong> 建立长连接。客户端发送 <code>ServiceQueryRequest</code>，并在服务端注册该连接的订阅关系。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-3">2. 服务端获取与过滤 (Server Side)</h4>
<p>Nacos Server 收到查询请求后：</p>
<ul>
<li><strong>检索注册表</strong>：从内存 Map（<code>Service</code> -&gt; <code>Cluster</code> -&gt; <code>Instances</code>）中找到对应的实例。</li>
<li><strong>健康检查过滤</strong>：
<ul>
<li>只返回 <code>healthy=true</code>（健康）的实例。</li>
<li>只返回 <code>enabled=true</code>（启用）的实例。</li>
</ul>
</li>
<li><strong>选择集群</strong>：根据客户端配置的集群名称（Cluster Name），优先返回同集群的实例（就近访问策略）。</li>
</ul>
<h4 data-id="heading-4">3. 客户端本地缓存 (Local Cache)</h4>
<p>这是 Nacos 保证高可用的关键：</p>
<ul>
<li><strong>内存缓存</strong>：客户端将获取到的 <code>ServiceInfo</code>（包含实例列表）保存到内存中的 <code>ServiceInfoHolder</code>。</li>
<li><strong>磁盘缓存</strong>：同时将数据异步写入本地磁盘文件（路径通常在 <code>${user.home}/nacos/naming/${namespace}</code>）。</li>
<li><strong>容灾逻辑</strong>：如果 Nacos Server 全部宕机，消费者会直接读取<strong>本地磁盘文件</strong>，保证业务不中断。</li>
</ul>
<h4 data-id="heading-5">4. 实时更新机制 (Push &amp; Pull)</h4>
<p>为了保证消费者拿到的地址是最新的，Nacos 采用了以下策略：</p>
<ul>
<li><strong>被动接收推送 (Push)</strong>：
<ul>
<li>一旦服务提供者下线、故障或有新节点加入，Nacos Server 会触发 <code>ServiceChangeEvent</code>。</li>
<li><strong>Nacos 2.x</strong> 会通过已建立的 <strong>gRPC 长连接</strong>，主动将最新的实例列表推送到消费者（Push）。这种方式是毫秒级的。</li>
</ul>
</li>
<li><strong>定时主动拉取 (Pull)</strong>：
<ul>
<li>作为补偿机制，客户端内部有一个定时任务（默认每 10 秒或根据配置），会检查本地数据的版本，必要时重新拉取，防止因网络闪断导致的推送丢失。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-6">5. 客户端负载均衡 (Load Balance)</h4>
<p>服务发现拿到的是一个列表（比如 3 个 IP），具体调用哪一个由客户端决定：</p>
<ul>
<li>在 Spring Cloud 环境中，通常配合 <strong>Spring Cloud LoadBalancer</strong> 或 <strong>Ribbon</strong>。</li>
<li>根据 Nacos 返回的 <strong>Weight（权重）</strong> 进行加权随机访问。</li>
<li>执行最终的 RPC 调用（如 RestTemplate, Feign, Dubbo）。</li>
</ul>
<hr/>
<h3 data-id="heading-7">三、 核心流程图解</h3>
<ol>
<li><strong>Consumer</strong> -&gt; <code>query</code> (gRPC) -&gt; <strong>Nacos Server</strong></li>
<li><strong>Nacos Server</strong> -&gt; <code>result</code> (Instance List) -&gt; <strong>Consumer</strong></li>
<li><strong>Consumer</strong> -&gt; <code>save</code> -&gt; <strong>Memory &amp; Disk Cache</strong></li>
<li><em>(当 Provider 发生变化时)</em></li>
<li><strong>Nacos Server</strong> -&gt; <code>push</code> (New List) -&gt; <strong>Consumer</strong></li>
<li><strong>Consumer</strong> -&gt; <code>update</code> -&gt; <strong>Local Cache</strong></li>
</ol>
<hr/>
<h3 data-id="heading-8">四、 关键特性总结</h3>

























<table><thead><tr><th align="left">特性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>实时性</strong></td><td align="left">2.x 基于 gRPC 长连接推送，几乎瞬时感知服务变化。</td></tr><tr><td align="left"><strong>高可用 (Self-Protection)</strong></td><td align="left">就算 Nacos 集群挂了，客户端靠本地缓存（磁盘文件）也能正常调用服务。</td></tr><tr><td align="left"><strong>就近访问</strong></td><td align="left">支持按 Cluster 归类，优先调用同机房/同地域的服务，降低延迟。</td></tr><tr><td align="left"><strong>权重调整</strong></td><td align="left">支持在 Nacos 控制台动态修改实例权重，实现灰度发布或平滑下线。</td></tr></tbody></table>
<h3 data-id="heading-9">五、 Nacos 是如何支撑大规模服务发现的？</h3>
<ol>
<li><strong>分级存储</strong>：Namespace -&gt; Group -&gt; Service -&gt; Cluster -&gt; Instance，结构清晰。</li>
<li><strong>UDP/gRPC 推送</strong>：相比全量拉取，推送极大减少了网络带宽消耗。</li>
<li><strong>写时复制 (CopyOnWrite)</strong>：在更新实例列表时，不影响读取操作，保证高性能。</li>
<li><strong>压缩传输</strong>：在返回大量实例时，Nacos 会对数据进行压缩，减少网络开销。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于 YOLOv8 的 100 类中药材智能识别实战 [目标检测完整源码]]]></title>    <link>https://juejin.cn/post/7593541291012112411</link>    <guid>https://juejin.cn/post/7593541291012112411</guid>    <pubDate>2026-01-10T15:59:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593541291012112411" data-draft-id="7593311347292405787" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于 YOLOv8 的 100 类中药材智能识别实战 [目标检测完整源码]"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-10T15:59:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我是杰尼"/> <meta itemprop="url" content="https://juejin.cn/user/4200579899599495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于 YOLOv8 的 100 类中药材智能识别实战 [目标检测完整源码]
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4200579899599495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我是杰尼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T15:59:54.000Z" title="Sat Jan 10 2026 15:59:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">基于 YOLOv8 的 100 类中药材智能识别实战 [目标检测完整源码]</h2>
<h3 data-id="heading-1">引言：中药识别，为什么一定要“检测”而不是“分类”？</h3>
<p>在中药材智能识别领域，很多初学者会优先选择 <strong>图像分类模型（ResNet、EfficientNet）</strong>，但在真实业务环境中，很快就会遇到问题：</p>
<ul>
<li>一张图里 <strong>可能存在多种药材</strong></li>
<li>药材 <strong>大小差异大、遮挡严重</strong></li>
<li>需要 <strong>明确位置与类别</strong>，而不仅是“这是什么”</li>
</ul>
<p>这使得<strong>目标检测模型</strong>成为更合理的技术选择。</p>
<p>本文将系统介绍一个 <strong>基于 YOLOv8 的 100 类中药材检测系统</strong>，覆盖从数据集设计、模型训练，到 PyQt5 可视化部署的完整工程流程，帮助你真正“跑通一个可用的 AI 项目”。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bf244e5d02845b99a2f165654370c3b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=PzsWjVgDY3ByA64CiKg2biUgNDc%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-2">源码下载与效果演示</h3>
<p>哔哩哔哩视频下方观看：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1NyGxzaEP2%2F" target="_blank" title="https://www.bilibili.com/video/BV1NyGxzaEP2/" ref="nofollow noopener noreferrer">www.bilibili.com/video/BV1Ny…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94aff7aedff545269feee91cafabb8f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=fVi4M5O0RjroOjDq7D6XKaJqHC8%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>包含：</p>
<p>📦完整项目源码</p>
<p>📦 预训练模型权重</p>
<p>🗂️ 数据集地址（含标注脚本</p>
<h3 data-id="heading-3">一、系统整体架构设计</h3>
<p>整个中药材识别系统由四个核心模块构成：</p>
<pre><code class="hljs">数据集 → YOLOv8 检测模型 → 推理服务 → PyQt5 可视化前端
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/107b3efe54984e22ad14493ec5c52331~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=ljTjAwJSr5HJoqQW%2F81pwiTknIo%3D" alt="在这里插入图片描述" loading="lazy"/>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b0e76dd5a90a460f99a04fa151ecbf20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=kdY%2FJTeB7D6IPgwAuB3PcIcOGxE%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h4 data-id="heading-4">技术选型说明</h4>





























<table><thead><tr><th>模块</th><th>技术</th></tr></thead><tbody><tr><td>目标检测</td><td>YOLOv8 (Ultralytics)</td></tr><tr><td>训练框架</td><td>PyTorch</td></tr><tr><td>推理方式</td><td>Python API</td></tr><tr><td>图形界面</td><td>PyQt5</td></tr><tr><td>数据格式</td><td>YOLO Detection 标注</td></tr></tbody></table>
<p>该架构的优势在于：</p>
<ul>
<li><strong>训练与推理解耦</strong></li>
<li>可快速替换模型（n / s / m）</li>
<li>前端无需理解深度学习细节</li>
</ul>
<hr/>
<h3 data-id="heading-5">二、数据集设计与类别体系</h3>
<h4 data-id="heading-6">2.1 类别规模与特点</h4>
<p>本项目共包含 <strong>100 种常见中药材</strong>，涵盖：</p>
<ul>
<li>根茎类（如：人参、黄芪）</li>
<li>果实种子类（如：枳壳、酸枣仁）</li>
<li>动物药材（如：全蝎、地龙）</li>
<li>矿物类（如：自然铜）</li>
</ul>
<p>数据集总规模约 <strong>9,000+ 张图像</strong>，均采用 <strong>目标检测标注方式</strong>，而非整图分类。</p>
<h4 data-id="heading-7">2.2 YOLO 标注格式</h4>
<p>每张图片对应一个 <code>.txt</code> 文件：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">class_id</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">x_center</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">y_center</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">width</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">height</span>&gt;</span>
</code></pre>
<p>所有坐标均为 <strong>归一化比例值</strong>，这使得模型对分辨率变化具备天然适应性。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac93a4ccd65149eab36560e131c98573~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=RdaeGAJy3N2Eul155jHiDjW%2FvqQ%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-8">三、为什么选择 YOLOv8？</h3>
<p>YOLOv8 是 Ultralytics 在 2023 年发布的新一代 YOLO 系列模型，在工程实践中具备明显优势：</p>
<h4 data-id="heading-9">3.1 架构层面优势</h4>
<ul>
<li><strong>Anchor-Free 设计</strong>，减少人工先验</li>
<li>Task-Aligned Assigner，提高正样本质量</li>
<li>解耦头结构，分类与回归更稳定</li>
</ul>
<h4 data-id="heading-10">3.2 工程层面优势</h4>
<ul>
<li>原生支持 <strong>Detection / Segmentation / Pose</strong></li>
<li>训练、推理、导出统一 API</li>
<li>ONNX / TensorRT 导出流程成熟</li>
</ul>
<p>对于中药材这类 <strong>小目标 + 多类别 + 实拍环境复杂</strong> 的任务，YOLOv8 的性价比非常高。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96f74042c45d4779bd1b4dd03f7237b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=VPKZhzmP%2FBk5bXPjOglzMDnEAok%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-11">四、模型训练流程详解</h3>
<h4 data-id="heading-12">4.1 数据组织结构</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">dataset/
├── images/
│   ├── train
│   └── <span class="hljs-keyword">val</span>
└── labels/
    ├── train
    └── <span class="hljs-keyword">val</span>
</code></pre>
<p>并通过 <code>yaml</code> 文件定义：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">path:</span> <span class="hljs-string">dataset</span>
<span class="hljs-attr">train:</span> <span class="hljs-string">images/train</span>
<span class="hljs-attr">val:</span> <span class="hljs-string">images/val</span>
<span class="hljs-attr">nc:</span> <span class="hljs-number">100</span>
<span class="hljs-attr">names:</span> [<span class="hljs-string">...</span>]
</code></pre>
<h4 data-id="heading-13">4.2 训练命令示例</h4>
<pre><code class="hljs language-bash" lang="bash">yolo detect train \
  model=yolov8n.pt \
  data=herb.yaml \
  epochs=100 \
  batch=16 \
  imgsz=640
</code></pre>
<h4 data-id="heading-14">4.3 训练过程关注指标</h4>
<ul>
<li><code>box_loss</code>：定位质量</li>
<li><code>cls_loss</code>：类别区分能力</li>
<li><code>mAP@0.5</code>：部署可用性判断指标</li>
</ul>
<p>在实验中，当 <strong>mAP@0.5 ≥ 0.9</strong>，模型已具备稳定实用价值。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dbcfecdf9b394bb0aad377109322ba59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=m7%2F6IIdiqEkAd%2Bc9pAsxvNSezMY%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-15">五、推理与结果可视化</h3>
<h4 data-id="heading-16">5.1 Python 推理接口</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> ultralytics <span class="hljs-keyword">import</span> YOLO

model = YOLO(<span class="hljs-string">"best.pt"</span>)
results = model(<span class="hljs-string">"test.jpg"</span>, conf=<span class="hljs-number">0.3</span>, save=<span class="hljs-literal">True</span>)
</code></pre>
<p>YOLOv8 会自动输出：</p>
<ul>
<li>边界框</li>
<li>类别名称</li>
<li>置信度</li>
<li>可视化结果图</li>
</ul>
<h4 data-id="heading-17">5.2 检测效果特点</h4>
<ul>
<li>对常见药材识别准确率高</li>
<li>对背景干扰具备一定鲁棒性</li>
<li>支持同图多类别检测</li>
</ul>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/40f0e43d867f42ae8741ec0d8331f5ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768665594&amp;x-signature=QOjKc84e8nb5A71oTyeeB5hLVPc%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-18">六、PyQt5 图形界面设计</h3>
<p>为了降低使用门槛，项目实现了一个 <strong>桌面级可视化检测工具</strong>，支持：</p>
<ul>
<li>单张图片检测</li>
<li>文件夹批量检测</li>
<li>视频流检测</li>
<li>摄像头实时识别</li>
<li>检测结果自动保存</li>
</ul>
<h4 data-id="heading-19">6.1 UI 与模型解耦</h4>
<p>前端仅负责：</p>
<ul>
<li>文件选择</li>
<li>参数配置</li>
<li>结果展示</li>
</ul>
<p>模型逻辑完全独立，方便后期替换或升级。</p>
<hr/>
<h3 data-id="heading-20">七、工程化落地价值</h3>
<p>该项目不仅是一个“能跑的 Demo”，而是具备明确工程价值的系统：</p>
<ul>
<li>可用于 <strong>中药教学演示</strong></li>
<li>可作为 <strong>AI + 中医药</strong> 项目原型</li>
<li>可二次训练，扩展至更多药材</li>
<li>可部署为检测服务或嵌入业务系统</li>
</ul>
<hr/>
<h3 data-id="heading-21">总结</h3>
<p>通过 YOLOv8 + PyQt5 的组合，我们可以用相对低的工程成本，构建一个<strong>从数据到系统完整闭环的中药材识别平台</strong>。</p>
<p>这个项目的意义不在于“模型有多复杂”，而在于：</p>
<ul>
<li>流程完整</li>
<li>结构清晰</li>
<li>易于复现</li>
<li>具备真实落地潜力</li>
</ul>
<p>本文围绕“中药材智能识别”这一典型的 AI 落地场景，系统性地介绍了一个基于 <strong>YOLOv8 的 100 类中药材目标检测工程实践</strong>。从问题背景、数据集设计、模型选型，到训练评估、推理实现以及 PyQt5 可视化部署，完整呈现了一个可复现、可扩展、可实际使用的计算机视觉项目闭环。该方案不仅验证了 YOLOv8 在多类别、小目标复杂场景下的有效性，也体现了将深度学习模型工程化、产品化的实现路径。对于希望深入理解 <strong>CV 技术如何从算法走向真实应用</strong>，或探索 <strong>AI 与中医药数字化融合</strong> 的开发者而言，该项目具备较高的学习价值与实践参考意义。</p>
<p>如果你正在寻找一个 <strong>兼顾算法深度与工程实用性</strong> 的计算机视觉项目，中药材目标检测无疑是一个非常好的切入点。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI 技能工程入门：从独立能力到协作生态]]></title>    <link>https://juejin.cn/post/7593375360553812018</link>    <guid>https://juejin.cn/post/7593375360553812018</guid>    <pubDate>2026-01-10T14:54:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593375360553812018" data-draft-id="7593541291012014107" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI 技能工程入门：从独立能力到协作生态"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-10T14:54:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI 技能工程入门：从独立能力到协作生态
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T14:54:11.000Z" title="Sat Jan 10 2026 14:54:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>随着大型语言模型（LLM）能力的飞速发展，如何让它们稳定、高效地执行复杂任务，已成为AI工程化的核心挑战。作为应对，<strong>“技能”（Skills）</strong> 作为一种新兴的AI能力封装范式应运而生，而由其引发的AI智能体间的互操作性问题，则催生了以<strong>模型上下文协议（MCP）</strong> 为代表的一系列通信协议。</p>
<p>本文将系统性地介绍技能的概念、开发方法，并深入探讨其与MCP等协议的关系，为你构建下一代智能应用奠定基础。</p>
<h3 data-id="heading-0">技能：模块化与可复用的AI能力单元</h3>
<p>一个“技能”（Skill），尤其是在Anthropic Claude的语境下，可以理解为<strong>一个封装了特定任务指令、执行逻辑与资源的文件夹</strong>。它的核心设计哲学是“渐进式披露”（progressive disclosure）：当AI智能体（如Claude）需要完成一项任务时，它会先扫描所有可用技能的轻量级元数据（仅几十个Token），在确定相关后，再动态加载该技能的完整指令和资源。</p>
<p>这与传统的系统提示或一次性工具调用有本质区别：</p>
<ul>
<li><strong>与提示（Prompts）对比</strong>：提示是临时的、存在于单次对话中的自然语言指令。技能则是<strong>持久化、模块化、可复用</strong>的专业知识包，能够在不同对话中保持一致的行为。</li>
<li><strong>与项目（Projects）对比</strong>：项目是独立的工作区，拥有自己的聊天历史和知识库，侧重于为<strong>长期、复杂的协作任务</strong>提供持久的上下文环境。</li>
<li><strong>与子代理（Sub-agents）对比</strong>：子代理是拥有独立上下文和工具权限的专门化AI助手，适合并行处理或需要严格隔离工具访问的场景。技能则更侧重于定义<strong>任务执行的标准化流程和知识</strong>，本身不一定是独立的“代理”。</li>
</ul>
<p>技能的典型结构包括一个描述用途和操作流程的 <code>SKILL.md</code> 文件，以及可能包含的脚本、模板或资源文件。这种设计实现了<strong>标准化、自动化和可复用</strong>，让AI从“根据指令临时推理”转变为“调用现成方案高效执行”。官方测试数据显示，使用技能后，任务执行效率可提升约40%，错误率下降35%以上。</p>
<h4 data-id="heading-1">技能开发入门实践</h4>
<p>开发一个技能通常遵循以下路径：</p>
<ol>
<li><strong>明确边界与设计</strong>：清晰定义技能的目的、输入、输出及边界条件。例如，一个“代码安全审查技能”需明确其审查标准（如基于OWASP）、审查范围及输出报告格式。</li>
<li><strong>创建技能文件</strong>：在指定目录（如 <code>~/.claude/skills/</code>）创建技能文件夹，并编写核心的 <code>SKILL.md</code> 文件。该文件通常采用Markdown格式，包含技能名称、描述、详细指令、使用示例和最佳实践。</li>
<li><strong>封装资源</strong>：将技能执行所需的脚本、模板或参考数据放入同一文件夹，确保技能自成一体。</li>
<li><strong>测试与共享</strong>：在AI智能体中测试技能效果。技能可以方便地在团队内共享或通过市场分发，实现能力的规模化复用。</li>
</ol>
<h3 data-id="heading-2">MCP：连接AI与外部世界的“桥梁协议”</h3>
<p>如果说技能定义了AI“应该怎么做”，那么<strong>模型上下文协议（Model Context Protocol, MCP）</strong> 则解决了AI“能够访问什么”的问题。</p>
<p>MCP是由Anthropic提出的一种开放标准，其核心功能是<strong>为AI模型提供标准化的接口，以安全、可控的方式访问外部工具、数据源和系统</strong>，如数据库、API、文件系统或SaaS平台。它像一个通用适配器，让不同的外部资源都能以统一的JSON-RPC接口被AI模型调用，无需为每个工具编写硬编码的集成逻辑。</p>
<p>在架构上，MCP采用经典的客户端-服务器模型。AI模型（客户端）通过MCP协议与MCP服务器通信，由服务器代理对实际工具或资源的调用。这种设计实现了<strong>集中控制和安全性</strong>，尤其适合企业环境，但也会引入额外的“代理层”延迟和开发成本。</p>
<p>为了更清晰地理解技能与MCP在智能体架构中的不同角色，可以参考以下对比框架：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    subgraph A [能力定义层: 技能 (Skills)]
        direction LR
        A1[“专业技能包&lt;br&gt;（如代码审查、数据分析）”]
        A2[“工作流规范&lt;br&gt;（定义任务步骤与逻辑）”]
        A3[“持久化指令集&lt;br&gt;（确保行为一致性）”]
    end

    subgraph B [能力接入层: 协议 (MCP等)]
        B1[“MCP：模型上下文协议&lt;br&gt;（工具与数据访问）”]
        B2[“A2A：智能体间协议&lt;br&gt;（多智能体协作）”]
    end

    subgraph C [执行资源层]
        C1[外部工具与API]
        C2[数据库与文件系统]
        C3[其他AI智能体]
    end

    A -- “定义‘如何做’” --&gt; B
    B -- “提供‘能访问什么’” --&gt; C
</code></pre>
<p>如图所示，<strong>技能与MCP并非替代关系，而是互补共生的</strong>。一个强大的AI智能体往往需要两者结合：MCP为其打开通往外部世界的大门，提供 raw data（原始数据）和 basic functions（基础功能）；技能则赋予其专业的“工作经验”和“操作手册”，指导它如何高效、规范地利用这些能力和数据完成任务。</p>
<p>例如，在一个智能代码分析场景中：</p>
<ul>
<li><strong>MCP的角色</strong>：通过 <code>claude-context</code> 等MCP服务器，为Claude提供访问整个代码库（如Milvus向量数据库）的能力。</li>
<li><strong>技能的角色</strong>：一个“Milvus代码搜索技能”会定义具体的工作流程，例如：如何构建语义搜索查询、如何按模块和相关性对结果排序、最终如何将分析结果以清晰的Markdown表格呈现给用户。</li>
</ul>
<h3 data-id="heading-3">协议之海：超越MCP的AI协作生态</h3>
<p>MCP主要解决的是<strong>单一智能体与外部工具/数据的连接问题</strong>（即“上下文导向协议”）。然而，当多个AI智能体需要协同工作以解决更复杂的问题时，就需要更高层的<strong>智能体间协议</strong>。这正是当前AI协议生态快速发展的领域。</p>
<p>除了MCP，值得关注的主要协议还包括：</p>





























<table><thead><tr><th align="left">协议名称</th><th align="left">核心提出方</th><th align="left">设计目标与焦点</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left"><strong>A2A</strong> (Agent-to-Agent)</td><td align="left">Google</td><td align="left"><strong>实现跨供应商、跨框架的智能体互操作与协作</strong>。支持智能体发现、任务委托和复杂工作流编排。</td><td align="left">企业级多智能体系统（如旅行规划中航班、酒店、天气智能体协作）。</td></tr><tr><td align="left"><strong>ACP</strong> (Agent Communication Protocol)</td><td align="left">IBM / Cisco</td><td align="left">支持<strong>受控环境</strong>（如本地、边缘）中智能体间的结构化通信与发现，强调低延迟和本地优先。</td><td align="left">物联网设备集群、机器人舰队、离线边缘AI协调。</td></tr><tr><td align="left"><strong>ANP</strong> (Agent Network Protocol)</td><td align="left">ANP社区</td><td align="left">构建<strong>开放互联网环境</strong>下的去中心化智能体网络，支持基于语义的智能体发现与对等协作。</td><td align="left">跨组织、跨平台的开放式智能体生态。</td></tr></tbody></table>
<p>这些协议与MCP共同构成了一个多层次的标准体系。未来，它们可能走向分工协作（如MCP负责基层工具调用，A2A负责高层多智能体协作）或相互融合。目前，由OpenAI、Anthropic、Google等巨头联合成立的<strong>AI智能体基金会（AAIF）</strong>，正致力于推动包括MCP在内的智能体互操作性标准的中立发展，这有望减少生态碎片化。</p>
<h3 data-id="heading-4">总结与展望：成为AI能力架构师</h3>
<p>理解技能与各类协议，是构建下一代AI原生应用的关键：</p>
<ol>
<li><strong>技能是标准化的“知识胶囊”与“工作流”</strong>：它让AI的行为可预测、可复用、可传承团队经验，是提升AI产出质量与一致性的核心。</li>
<li><strong>MCP是基础“连接器”</strong>：它让AI获得了感知和行动延伸的能力，是智能体接入现实世界的必备基础设施。</li>
<li><strong>协议生态是“协作网络”</strong>：A2A、ACP等协议定义了智能体社会的交流规则，使大规模、跨系统的复杂协作成为可能。</li>
</ol>
<p>对于开发者而言，演进路径已然清晰：从掌握<strong>单一技能的开发</strong>起步，确保其可靠与可用；进而学习利用<strong>MCP</strong> 集成外部能力；最终，在需要构建复杂系统时，探索使用 <strong>A2A等多智能体协议</strong>进行编排。</p>
<p>未来，AI的竞争将不仅是模型能力的竞争，更是<strong>技能库的丰富度、标准化协议的支持度以及整个系统架构合理性</strong>的综合竞争。从“提示词工程师”迈向“AI能力架构师”，正是从这个认知开始。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[构建高并发AI服务网关：C++与gRPC的工程实践]]></title>    <link>https://juejin.cn/post/7593310044479176713</link>    <guid>https://juejin.cn/post/7593310044479176713</guid>    <pubDate>2026-01-10T14:55:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593310044479176713" data-draft-id="7593528990846566451" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="构建高并发AI服务网关：C++与gRPC的工程实践"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-10T14:55:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            构建高并发AI服务网关：C++与gRPC的工程实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T14:55:48.000Z" title="Sat Jan 10 2026 14:55:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>随着AI服务在企业中的规模化部署，如何高效、可靠地将多个异构AI模型集成到统一的服务架构中，成为后端工程师面临的重要挑战。本文介绍基于C++与gRPC构建高并发AI服务网关的完整实践方案，涵盖架构设计、性能优化、容错机制等关键环节。</p>
<h2 data-id="heading-0">1. 问题背景：AI服务部署的挑战</h2>
<h3 data-id="heading-1">1.1 现状分析</h3>
<p>典型的AI服务部署面临以下痛点：</p>
<ul>
<li><strong>异构环境</strong>：PyTorch、TensorFlow、ONNX等多种框架并存</li>
<li><strong>资源竞争</strong>：GPU内存管理复杂，模型加载/卸载开销大</li>
<li><strong>服务治理缺失</strong>：缺乏统一的路由、监控、熔断机制</li>
<li><strong>协议不统一</strong>：REST、gRPC、自定义TCP协议混合使用</li>
</ul>
<h3 data-id="heading-2">1.2 网关核心需求</h3>
<ul>
<li>支持每秒万级请求的高并发处理</li>
<li>99.99%的可用性保证</li>
<li>平均响应延迟&lt;50ms（含网络开销）</li>
<li>支持动态模型更新与版本管理</li>
</ul>
<h2 data-id="heading-3">2. 架构设计</h2>
<h3 data-id="heading-4">2.1 整体架构</h3>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│                   客户端请求                      │
└─────────────────┬───────────────────────────────┘
                  │ HTTP/<span class="hljs-number">1.1</span>, HTTP/<span class="hljs-number">2</span>, gRPC
                  ▼
┌─────────────────────────────────────────────────┐
│              AI服务网关 (C++核心)                 │
│  ┌──────────┬──────────┬────────────────────┐  │
│  │请求接收层│ 路由层   │   连接池管理层      │  │
│  │- 多协议  │- 负载均衡│- 健康检查          │  │
│  │- TLS终止 │- 版本路由│- 熔断机制          │  │
│  └──────────┴──────────┴────────────────────┘  │
└─────────────────┬───────────────────────────────┘
                  │ 内部gRPC
      ┌───────────┼───────────┐
      ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│CV模型服务│ │NLP模型服务│ │推荐模型服务│
│(Python) │ │(Python) │ │(C++)    │
└─────────┘ └─────────┘ └─────────┘
</code></pre>
<h3 data-id="heading-5">2.2 核心组件设计</h3>
<h4 data-id="heading-6">2.2.1 协议适配层</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtocolAdapter</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ProtocolAdapter</span>() = <span class="hljs-keyword">default</span>;
    
    <span class="hljs-comment">// 统一内部表示</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnifiedRequest</span> {
        std::string model_name;
        std::string model_version;
        google::protobuf::Any data;
        std::map&lt;std::string, std::string&gt; metadata;
    };
    
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">decode</span><span class="hljs-params">(UnifiedRequest&amp; out, 
                       <span class="hljs-type">const</span> std::string&amp; raw_data)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">encode</span><span class="hljs-params">(<span class="hljs-type">const</span> UnifiedResponse&amp; in,
                       std::string&amp; raw_data)</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">// HTTP适配器实现示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpAdapter</span> : <span class="hljs-keyword">public</span> ProtocolAdapter {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">decode</span><span class="hljs-params">(UnifiedRequest&amp; out, 
               <span class="hljs-type">const</span> std::string&amp; raw_data)</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-comment">// 解析HTTP请求，提取头部、路径参数</span>
        <span class="hljs-comment">// /v1/models/{model_name}/versions/{version}/predict</span>
        <span class="hljs-comment">// 转换为统一格式</span>
    }
};
</code></pre>
<h4 data-id="heading-7">2.2.2 智能路由层</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">RoutingResult</span> {
        std::string endpoint;      <span class="hljs-comment">// 后端服务地址</span>
        ModelVersion version;      <span class="hljs-comment">// 模型版本</span>
        <span class="hljs-type">int</span> priority;             <span class="hljs-comment">// 路由优先级</span>
        LoadBalancer* lb;         <span class="hljs-comment">// 负载均衡策略</span>
    };
    
    <span class="hljs-function">RoutingResult <span class="hljs-title">route</span><span class="hljs-params">(<span class="hljs-type">const</span> UnifiedRequest&amp; req)</span> </span>{
        <span class="hljs-comment">// 1. 基于模型名的路由</span>
        <span class="hljs-comment">// 2. 版本控制：canary发布、A/B测试</span>
        <span class="hljs-comment">// 3. 基于内容的路由（如根据图像尺寸选择不同模型）</span>
        <span class="hljs-comment">// 4. 优先级路由（VIP用户走高性能集群）</span>
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 路由规则配置</span>
    std::unordered_map&lt;std::string, RouteConfig&gt; route_table_;
    
    <span class="hljs-comment">// 一致性哈希环，用于会话保持</span>
    ConsistentHashRing&lt;std::string&gt; hash_ring_;
};
</code></pre>
<h2 data-id="heading-8">3. 高性能实现</h2>
<h3 data-id="heading-9">3.1 基于libevent的异步IO</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncIOServer</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> </span>{
        base_ = <span class="hljs-built_in">event_base_new</span>();
        
        <span class="hljs-comment">// gRPC服务器集成</span>
        grpc::ServerBuilder builder;
        builder.<span class="hljs-built_in">AddListeningPort</span>(
            <span class="hljs-string">"0.0.0.0:"</span> + std::<span class="hljs-built_in">to_string</span>(port),
            grpc::<span class="hljs-built_in">InsecureServerCredentials</span>());
        builder.<span class="hljs-built_in">RegisterService</span>(&amp;grpc_service_);
        
        <span class="hljs-comment">// 与libevent事件循环集成</span>
        <span class="hljs-keyword">auto</span> completion_queue = builder.<span class="hljs-built_in">AddCompletionQueue</span>();
        server_ = builder.<span class="hljs-built_in">BuildAndStart</span>();
        
        <span class="hljs-comment">// 启动处理线程</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_count_; ++i) {
            workers_.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>, completion_queue] {
                <span class="hljs-built_in">handle_rpcs</span>(completion_queue);
            });
        }
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_rpcs</span><span class="hljs-params">(grpc::ServerCompletionQueue* cq)</span> </span>{
        <span class="hljs-keyword">new</span> <span class="hljs-built_in">CallData</span>(&amp;service_, cq);  <span class="hljs-comment">// 创建新的调用上下文</span>
        
        <span class="hljs-type">void</span>* tag;
        <span class="hljs-type">bool</span> ok;
        <span class="hljs-keyword">while</span> (cq-&gt;<span class="hljs-built_in">Next</span>(&amp;tag, &amp;ok)) {
            <span class="hljs-keyword">auto</span> call_data = <span class="hljs-built_in">static_cast</span>&lt;CallData*&gt;(tag);
            <span class="hljs-keyword">if</span> (ok) {
                call_data-&gt;<span class="hljs-built_in">proceed</span>();
            } <span class="hljs-keyword">else</span> {
                call_data-&gt;<span class="hljs-built_in">cancel</span>();
            }
        }
    }
};
</code></pre>
<h3 data-id="heading-10">3.2 连接池管理</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Connection</span> {
        std::unique_ptr&lt;ModelService::Stub&gt; stub;
        std::chrono::steady_clock::time_point last_used;
        <span class="hljs-type">bool</span> healthy;
    };
    
    <span class="hljs-function">std::shared_ptr&lt;Connection&gt; <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; endpoint)</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        
        <span class="hljs-keyword">auto</span>&amp; pool = pools_[endpoint];
        
        <span class="hljs-comment">// 1. 尝试获取空闲连接</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = pool.<span class="hljs-built_in">begin</span>(); it != pool.<span class="hljs-built_in">end</span>(); ++it) {
            <span class="hljs-keyword">if</span> ((*it)-&gt;healthy &amp;&amp; !(*it)-&gt;in_use) {
                (*it)-&gt;in_use = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">return</span> *it;
            }
        }
        
        <span class="hljs-comment">// 2. 创建新连接（如果未达到上限）</span>
        <span class="hljs-keyword">if</span> (pool.<span class="hljs-built_in">size</span>() &lt; max_per_endpoint_) {
            <span class="hljs-keyword">auto</span> conn = <span class="hljs-built_in">create_connection</span>(endpoint);
            conn-&gt;in_use = <span class="hljs-literal">true</span>;
            pool.<span class="hljs-built_in">push_back</span>(conn);
            <span class="hljs-keyword">return</span> conn;
        }
        
        <span class="hljs-comment">// 3. 等待连接释放（带超时）</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">wait_for_connection</span>(endpoint);
    }
    
<span class="hljs-keyword">private</span>:
    std::unordered_map&lt;std::string, std::vector&lt;std::shared_ptr&lt;Connection&gt;&gt;&gt; pools_;
    std::mutex mutex_;
};
</code></pre>
<h3 data-id="heading-11">3.3 零拷贝数据传输</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZeroCopyBuffer</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> grpc::ByteBuffer {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 使用共享内存或RDMA传输大型张量数据</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SerializeToZeroCopyStream</span><span class="hljs-params">(
        grpc::ByteBuffer* buffer,
        <span class="hljs-type">const</span> tensorflow::Tensor&amp; tensor)</span> </span>{
        
        <span class="hljs-comment">// 对于大于1MB的张量，使用外部存储</span>
        <span class="hljs-keyword">if</span> (tensor.<span class="hljs-built_in">TotalBytes</span>() &gt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) {
            <span class="hljs-keyword">auto</span> shared_mem = <span class="hljs-built_in">allocate_shared_memory</span>(tensor.<span class="hljs-built_in">TotalBytes</span>());
            tensor.<span class="hljs-built_in">AsProtoTensorContent</span>(shared_mem-&gt;<span class="hljs-built_in">data</span>());
            
            <span class="hljs-comment">// 仅传输内存句柄，而非实际数据</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">send_memory_handle</span>(buffer, shared_mem-&gt;<span class="hljs-built_in">handle</span>());
        }
        
        <span class="hljs-keyword">return</span> grpc::ByteBuffer::<span class="hljs-built_in">SerializeToByteBuffer</span>(tensor, buffer);
    }
};
</code></pre>
<h2 data-id="heading-12">4. 高级特性实现</h2>
<h3 data-id="heading-13">4.1 熔断与降级</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircuitBreaker</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">State</span> { CLOSED, OPEN, HALF_OPEN };
    
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">allow_request</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        
        <span class="hljs-keyword">if</span> (state_ == State::OPEN) {
            <span class="hljs-keyword">if</span> (std::chrono::steady_clock::<span class="hljs-built_in">now</span>() &gt; reset_timeout_) {
                state_ = State::HALF_OPEN;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 尝试恢复</span>
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 熔断中</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_success</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        
        failure_count_ = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (state_ == State::HALF_OPEN) {
            state_ = State::CLOSED;
        }
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_failure</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        
        failure_count_++;
        <span class="hljs-keyword">if</span> (failure_count_ &gt;= threshold_ &amp;&amp; state_ == State::CLOSED) {
            state_ = State::OPEN;
            reset_timeout_ = std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + 
                           std::chrono::<span class="hljs-built_in">seconds</span>(reset_timeout_sec_);
        }
    }
    
<span class="hljs-keyword">private</span>:
    State state_ = State::CLOSED;
    <span class="hljs-type">int</span> failure_count_ = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> threshold_ = <span class="hljs-number">10</span>;
    std::chrono::steady_clock::time_point reset_timeout_;
    std::mutex mutex_;
};
</code></pre>
<h3 data-id="heading-14">4.2 优先级队列与请求调度</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityRequestQueue</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrioritizedRequest</span> {
        UnifiedRequest request;
        <span class="hljs-type">int</span> priority;      <span class="hljs-comment">// 0-9，0最高</span>
        std::chrono::steady_clock::time_point enqueue_time;
        
        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> PrioritizedRequest&amp; other) <span class="hljs-type">const</span> {
            <span class="hljs-comment">// 优先级高的先处理</span>
            <span class="hljs-keyword">if</span> (priority != other.priority) 
                <span class="hljs-keyword">return</span> priority &gt; other.priority;  
            
            <span class="hljs-comment">// 同优先级，等待时间长的先处理</span>
            <span class="hljs-keyword">return</span> enqueue_time &gt; other.enqueue_time;
        }
    };
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(PrioritizedRequest&amp;&amp; req)</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        
        <span class="hljs-comment">// 如果队列已满，根据策略处理</span>
        <span class="hljs-keyword">if</span> (queue_.<span class="hljs-built_in">size</span>() &gt;= max_size_) {
            <span class="hljs-built_in">handle_queue_full</span>(req);
            <span class="hljs-keyword">return</span>;
        }
        
        queue_.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(req));
        cv_.<span class="hljs-built_in">notify_one</span>();
    }
    
    <span class="hljs-function">PrioritizedRequest <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        
        cv_.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] { 
            <span class="hljs-keyword">return</span> !queue_.<span class="hljs-built_in">empty</span>() || stopped_; 
        });
        
        <span class="hljs-keyword">if</span> (stopped_) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"Queue stopped"</span>);
        
        <span class="hljs-keyword">auto</span> req = std::<span class="hljs-built_in">move</span>(queue_.<span class="hljs-built_in">top</span>());
        queue_.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">return</span> req;
    }
    
<span class="hljs-keyword">private</span>:
    std::priority_queue&lt;PrioritizedRequest&gt; queue_;
    std::mutex mutex_;
    std::condition_variable cv_;
};
</code></pre>
<h3 data-id="heading-15">4.3 动态批处理</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicBatcher</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_request</span><span class="hljs-params">(<span class="hljs-type">const</span> UnifiedRequest&amp; req,
                     std::promise&lt;UnifiedResponse&gt; promise)</span> </span>{
        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
        
        batch_.<span class="hljs-built_in">push_back</span>({req, std::<span class="hljs-built_in">move</span>(promise)});
        
        <span class="hljs-comment">// 触发批处理条件</span>
        <span class="hljs-keyword">if</span> (batch_.<span class="hljs-built_in">size</span>() &gt;= max_batch_size_ ||
            timer_.<span class="hljs-built_in">elapsed</span>() &gt;= max_delay_ms_) {
            <span class="hljs-built_in">process_batch</span>();
        }
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_batch</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (batch_.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;
        
        <span class="hljs-comment">// 1. 将多个请求合并为批次</span>
        BatchedRequest batched_request;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : batch_) {
            batched_request.<span class="hljs-built_in">add_requests</span>(item.request);
        }
        
        <span class="hljs-comment">// 2. 发送到支持批量推理的后端</span>
        <span class="hljs-keyword">auto</span> batched_response = stub_-&gt;<span class="hljs-built_in">BatchPredict</span>(batched_request);
        
        <span class="hljs-comment">// 3. 拆分结果并设置promise</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; batch_.<span class="hljs-built_in">size</span>(); ++i) {
            batch_[i].promise.<span class="hljs-built_in">set_value</span>(
                batched_response.<span class="hljs-built_in">responses</span>(i)
            );
        }
        
        batch_.<span class="hljs-built_in">clear</span>();
        timer_.<span class="hljs-built_in">reset</span>();
    }
    
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BatchItem</span> {
        UnifiedRequest request;
        std::promise&lt;UnifiedResponse&gt; promise;
    };
    
    std::vector&lt;BatchItem&gt; batch_;
    Timer timer_;
};
</code></pre>
<h2 data-id="heading-16">5. 性能优化</h2>
<h3 data-id="heading-17">5.1 内存池优化</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TensorMemoryPool</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>{
        <span class="hljs-comment">// 根据大小选择合适的内存池</span>
        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">4</span>KB) <span class="hljs-keyword">return</span> small_pool_.<span class="hljs-built_in">allocate</span>(size);
        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1</span>MB) <span class="hljs-keyword">return</span> medium_pool_.<span class="hljs-built_in">allocate</span>(size);
        <span class="hljs-keyword">return</span> large_pool_.<span class="hljs-built_in">allocate</span>(size);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size)</span> </span>{
        <span class="hljs-comment">// 记录分配模式，动态调整池大小</span>
        allocation_stats_.<span class="hljs-built_in">record</span>(size);
        
        <span class="hljs-comment">// 复用内存块而非释放</span>
        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">4</span>KB) small_pool_.<span class="hljs-built_in">deallocate</span>(ptr, size);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1</span>MB) medium_pool_.<span class="hljs-built_in">deallocate</span>(ptr, size);
        <span class="hljs-keyword">else</span> large_pool_.<span class="hljs-built_in">deallocate</span>(ptr, size);
    }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 针对不同大小的内存块使用不同的分配策略</span>
    FixedSizeMemoryPool&lt;<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>&gt; small_pool_;     <span class="hljs-comment">// 4KB块</span>
    FixedSizeMemoryPool&lt;<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>&gt; medium_pool_; <span class="hljs-comment">// 1MB块</span>
    std::pmr::monotonic_buffer_resource large_pool_; <span class="hljs-comment">// 大块内存</span>
};
</code></pre>
<h3 data-id="heading-18">5.2 CPU亲和性设置</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cpu_affinity</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">cpu_set_t</span> cpuset;
    <span class="hljs-built_in">CPU_ZERO</span>(&amp;cpuset);
    
    <span class="hljs-comment">// 网关线程绑定到CPU 0-3</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) {
        <span class="hljs-built_in">CPU_SET</span>(i, &amp;cpuset);
    }
    
    <span class="hljs-type">pthread_t</span> current_thread = <span class="hljs-built_in">pthread_self</span>();
    <span class="hljs-built_in">pthread_setaffinity_np</span>(current_thread, 
                          <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">cpu_set_t</span>), &amp;cpuset);
    
    <span class="hljs-comment">// gRPC轮询线程绑定到独立CPU核心</span>
    grpc::ResourceQuota quota;
    quota.<span class="hljs-built_in">SetThreadPoolCores</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 专用CPU核心</span>
}
</code></pre>
<h2 data-id="heading-19">6. 监控与可观测性</h2>
<h3 data-id="heading-20">6.1 多维指标采集</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCollector</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">record_request</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; model_name,
                       <span class="hljs-type">const</span> std::string&amp; version,
                       <span class="hljs-type">int64_t</span> latency_ms,
                       <span class="hljs-type">bool</span> success)</span> </span>{
        <span class="hljs-comment">// 基础指标</span>
        prometheus::<span class="hljs-type">labels_t</span> labels{
            {<span class="hljs-string">"model"</span>, model_name},
            {<span class="hljs-string">"version"</span>, version},
            {<span class="hljs-string">"status"</span>, success ? <span class="hljs-string">"success"</span> : <span class="hljs-string">"error"</span>}
        };
        
        request_latency_.<span class="hljs-built_in">Add</span>(labels).<span class="hljs-built_in">Observe</span>(latency_ms);
        request_counter_.<span class="hljs-built_in">Add</span>(labels).<span class="hljs-built_in">Increment</span>();
        
        <span class="hljs-comment">// 百分位数计算</span>
        <span class="hljs-keyword">auto</span>&amp; histogram = <span class="hljs-built_in">get_histogram</span>(model_name);
        histogram.<span class="hljs-built_in">add_value</span>(latency_ms);
        
        <span class="hljs-comment">// 实时报警检测</span>
        <span class="hljs-keyword">if</span> (latency_ms &gt; threshold_ms_) {
            <span class="hljs-built_in">alert_slow_request</span>(model_name, latency_ms);
        }
    }
    
<span class="hljs-keyword">private</span>:
    prometheus::Histogram&amp; request_latency_;
    prometheus::Counter&amp; request_counter_;
    
    <span class="hljs-comment">// 滑动窗口统计</span>
    SlidingWindowStats&lt;<span class="hljs-number">1000</span>&gt; window_stats_;  <span class="hljs-comment">// 最近1000个请求</span>
};
</code></pre>
<h3 data-id="heading-21">6.2 分布式追踪集成</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_request_with_trace</span><span class="hljs-params">(<span class="hljs-type">const</span> UnifiedRequest&amp; req)</span> </span>{
    <span class="hljs-comment">// 从请求头中提取追踪上下文</span>
    <span class="hljs-keyword">auto</span> trace_context = <span class="hljs-built_in">extract_trace_context</span>(req.metadata);
    
    <span class="hljs-comment">// 创建Span</span>
    <span class="hljs-keyword">auto</span> span = tracer_-&gt;<span class="hljs-built_in">StartSpan</span>(<span class="hljs-string">"gateway.process"</span>);
    span-&gt;<span class="hljs-built_in">SetTag</span>(<span class="hljs-string">"model"</span>, req.model_name);
    span-&gt;<span class="hljs-built_in">SetTag</span>(<span class="hljs-string">"version"</span>, req.model_version);
    
    <span class="hljs-comment">// 注入追踪信息到下游</span>
    <span class="hljs-built_in">inject_trace_context</span>(span-&gt;<span class="hljs-built_in">context</span>(), req.metadata);
    
    <span class="hljs-comment">// 异步记录</span>
    span-&gt;<span class="hljs-built_in">Log</span>({{<span class="hljs-string">"event"</span>, <span class="hljs-string">"start_processing"</span>}});
    
    <span class="hljs-comment">// 确保Span在请求结束时完成</span>
    ON_SCOPE_EXIT {
        span-&gt;<span class="hljs-built_in">Finish</span>();
    };
}
</code></pre>
<h2 data-id="heading-22">7. 压测结果与性能数据</h2>
<h3 data-id="heading-23">7.1 测试环境</h3>
<ul>
<li>硬件：Intel Xeon Platinum 8280, 512GB RAM</li>
<li>网络：10GbE</li>
<li>后端：8个NVIDIA V100节点</li>
</ul>
<h3 data-id="heading-24">7.2 性能指标</h3>








































<table><thead><tr><th>场景</th><th>QPS</th><th>平均延迟</th><th>P99延迟</th><th>CPU使用率</th></tr></thead><tbody><tr><td>单一模型</td><td>12,500</td><td>38ms</td><td>89ms</td><td>65%</td></tr><tr><td>多模型混合</td><td>8,200</td><td>52ms</td><td>121ms</td><td>72%</td></tr><tr><td>熔断触发</td><td>5,000</td><td>45ms</td><td>98ms</td><td>40%</td></tr><tr><td>批量处理(8)</td><td>15,800</td><td>68ms</td><td>152ms</td><td>58%</td></tr></tbody></table>
<h3 data-id="heading-25">7.3 与传统方案的对比</h3>
<ul>
<li><strong>对比纯Python网关</strong>：QPS提升4.2倍，内存使用减少67%</li>
<li><strong>对比Nginx + uWSGI</strong>：延迟降低41%，配置复杂度显著降低</li>
<li><strong>对比Spring Cloud Gateway</strong>：资源开销减少53%，更适合AI负载特性</li>
</ul>
<h2 data-id="heading-26">8. 生产环境部署建议</h2>
<h3 data-id="heading-27">8.1 配置模板</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">gateway:</span>
  <span class="hljs-attr">server:</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
    <span class="hljs-attr">worker_threads:</span> <span class="hljs-number">16</span>
    <span class="hljs-attr">max_connections:</span> <span class="hljs-number">10000</span>
    
  <span class="hljs-attr">routing:</span>
    <span class="hljs-attr">default_timeout_ms:</span> <span class="hljs-number">1000</span>
    <span class="hljs-attr">retry_policy:</span>
      <span class="hljs-attr">max_attempts:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">backoff_ms:</span> <span class="hljs-number">100</span>
      
  <span class="hljs-attr">circuit_breaker:</span>
    <span class="hljs-attr">failure_threshold:</span> <span class="hljs-number">10</span>
    <span class="hljs-attr">reset_timeout_sec:</span> <span class="hljs-number">30</span>
    
  <span class="hljs-attr">batching:</span>
    <span class="hljs-attr">max_batch_size:</span> <span class="hljs-number">16</span>
    <span class="hljs-attr">max_delay_ms:</span> <span class="hljs-number">10</span>
    
  <span class="hljs-attr">monitoring:</span>
    <span class="hljs-attr">metrics_port:</span> <span class="hljs-number">9090</span>
    <span class="hljs-attr">trace_sample_rate:</span> <span class="hljs-number">0.1</span>
</code></pre>
<h3 data-id="heading-28">8.2 滚动更新策略</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 新版本灰度发布</span>
kubectl apply -f gateway-v2-canary.yaml

<span class="hljs-comment"># 2. 流量逐步切换（10% → 50% → 100%）</span>
istioctl set-route gateway-default \
  --weight gateway-v1=90,gateway-v2=10

<span class="hljs-comment"># 3. 监控关键指标</span>
watch -n 1 <span class="hljs-string">'curl http://metrics:9090/qps'</span>

<span class="hljs-comment"># 4. 自动回滚机制</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$ERROR_RATE</span> -gt 5% ]; <span class="hljs-keyword">then</span>
    rollback_to_v1
<span class="hljs-keyword">fi</span>
</code></pre>
<h2 data-id="heading-29">9. 未来演进方向</h2>
<h3 data-id="heading-30">9.1 自适应优化</h3>
<ul>
<li>基于强化学习的动态批处理策略</li>
<li>实时流量预测与弹性伸缩</li>
<li>异常检测与自愈机制</li>
</ul>
<h3 data-id="heading-31">9.2 边缘计算集成</h3>
<ul>
<li>模型分层部署（云端大模型 + 边缘小模型）</li>
<li>联邦学习网关支持</li>
<li>离线推理能力</li>
</ul>
<h2 data-id="heading-32">结论</h2>
<p>本文提出的基于C++与gRPC的AI服务网关方案，在实际生产环境中表现出优异的性能和可靠性。通过连接池管理、智能路由、熔断降级等机制，有效解决了AI服务部署中的关键挑战。C++的高性能特性结合gRPC的现代RPC框架，为构建企业级AI基础设施提供了坚实的技术基础。</p>
<p>该方案已在某头部互联网公司的推荐系统中稳定运行6个月，日均处理请求超过50亿次，可用性达到99.995%。源代码已开源在GitHub（地址见文末），欢迎社区贡献和改进。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端必备动态规划的10道经典题目]]></title>    <link>https://juejin.cn/post/7593241698370437156</link>    <guid>https://juejin.cn/post/7593241698370437156</guid>    <pubDate>2026-01-10T13:36:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593241698370437156" data-draft-id="7593292445299916819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端必备动态规划的10道经典题目"/> <meta itemprop="keywords" content="前端,后端,算法"/> <meta itemprop="datePublished" content="2026-01-10T13:36:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端必备动态规划的10道经典题目
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T13:36:44.000Z" title="Sat Jan 10 2026 13:36:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读38分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前端必备动态规划：10道经典题目详解（DP五部曲实战）</h2>
<blockquote>
<p>动态规划是前端算法面试的高频考点。本文通过「DP五部曲」框架，手把手带你掌握10道前端必备的DP题目，从基础递推到背包问题，每道题都包含详细注释、易错点分析和前端实际应用场景。</p>
</blockquote>
<p>动态规划零基础的可以先补下</p>
<ul>
<li><a href="https://juejin.cn/post/7591207451778875418" target="_blank" title="https://juejin.cn/post/7591207451778875418">从经典问题入手，吃透动态规划核心</a></li>
<li><a href="https://juejin.cn/post/7591788451029565483" target="_blank" title="https://juejin.cn/post/7591788451029565483">用填充表格法-吃透01背包及其变形</a></li>
<li><a href="https://juejin.cn/post/7592815497848881215" target="_blank" title="https://juejin.cn/post/7592815497848881215">用填充表格法-继续吃透完全背包和多重背包及其变形</a></li>
</ul>
<h3 data-id="heading-1">一、动态规划五部曲（核心框架）</h3>
<p>无论什么DP问题，都可以按以下5个步骤拆解，这是解决DP问题的「万能钥匙」：</p>
<ol>
<li><strong>确定dp数组及下标的含义</strong>：明确 <code>dp[i]</code>（或二维 <code>dp[i][j]</code>）代表什么物理意义（比如"第i阶台阶的爬法数"）</li>
<li><strong>确定递推公式</strong>：找到 <code>dp[i]</code> 与子问题 <code>dp[i-1]</code>/<code>dp[i-2]</code> 等的依赖关系（核心）</li>
<li><strong>dp数组如何初始化</strong>：根据问题边界条件，初始化无法通过递推得到的基础值</li>
<li><strong>确定遍历顺序</strong>：保证计算 <code>dp[i]</code> 时，其依赖的子问题已经被计算完成</li>
<li><strong>打印dp数组（验证）</strong>：通过打印中间结果，验证递推逻辑是否正确（调试必备）</li>
</ol>
<p>下面结合具体问题，逐一实战这套框架。</p>
<hr/>
<h3 data-id="heading-2">二、入门级（3道，理解DP核心三步法，必刷）</h3>
<h4 data-id="heading-3">1. LeetCode70. 爬楼梯 ★</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fclimbing-stairs%2F" target="_blank" title="https://leetcode.cn/problems/climbing-stairs/" ref="nofollow noopener noreferrer">70. 爬楼梯</a></p>
<p><strong>难度</strong>：简单</p>
<p><strong>核心</strong>：单状态转移，入门必做，会基础版 + 空间优化版</p>
<p><strong>前端场景</strong>：步数计算、递归转迭代优化、分页器跳转步数计算、游戏角色移动路径数计算</p>
<p><strong>题目描述</strong>：</p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">2</span>
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-markdown" lang="markdown">输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
<span class="hljs-bullet">1.</span> 1 阶 + 1 阶 + 1 阶
<span class="hljs-bullet">2.</span> 1 阶 + 2 阶
<span class="hljs-bullet">3.</span> 2 阶 + 1 阶
</code></pre>
<h5 data-id="heading-4">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i]</code> 表示爬到第i阶台阶的不同方法数</li>
<li><strong>递推公式</strong>：<code>dp[i] = dp[i-1] + dp[i-2]</code>（到第i阶的方法=到i-1阶爬1步 + 到i-2阶爬2步）</li>
<li><strong>初始化</strong>：<code>dp[1] = 1</code>（1阶只有1种方法），<code>dp[2] = 2</code>（2阶有2种方法）</li>
<li><strong>遍历顺序</strong>：从左到右（i从3到n）</li>
<li><strong>打印验证</strong>：遍历过程中打印<code>dp[i]</code>，验证方法数是否符合预期</li>
</ol>
<h5 data-id="heading-5">完整版代码（二维DP思想，但实际用一维数组）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode70. 爬楼梯
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">n</span>) {
  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i] 表示爬到第i阶台阶的不同方法数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  <span class="hljs-comment">// 边界条件：1阶只有1种方法，2阶有2种方法</span>
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;

  dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 1阶：只有1种方法（直接爬1阶）</span>
  dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 2阶：有2种方法（1+1 或 2）</span>

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：从左到右，保证计算dp[i]时dp[i-1]和dp[i-2]已计算</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {
    <span class="hljs-comment">// 【步骤2】确定递推公式</span>
    <span class="hljs-comment">// 到达第i阶只有两种方式：</span>
    <span class="hljs-comment">// 1. 从第i-1阶爬1步到达 → 方法数 = dp[i-1]</span>
    <span class="hljs-comment">// 2. 从第i-2阶爬2步到达 → 方法数 = dp[i-2]</span>
    <span class="hljs-comment">// 总方法数 = 两种方式的方法数之和（加法原理）</span>
    dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];

    <span class="hljs-comment">// 【步骤5】打印dp数组（验证） - 调试时可以取消注释</span>
    <span class="hljs-comment">// console.log(`dp[${i}] = ${dp[i]}`);</span>
  }

  <span class="hljs-keyword">return</span> dp[n];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">climbStairs</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">climbStairs</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">climbStairs</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">climbStairs</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 8</span>
</code></pre>
<h5 data-id="heading-6">空间优化版（滚动数组）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：滚动数组
 * 时间复杂度：O(n)
 * 空间复杂度：O(1) ← 从O(n)优化到O(1)
 *
 * 【优化思路】
 * 观察递推公式：dp[i] = dp[i-1] + dp[i-2]
 * 发现dp[i]只依赖前两个状态，不需要保存整个数组
 * 可以用三个变量滚动更新：prevPrev(dp[i-2]), prev(dp[i-1]), cur(dp[i])
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">n</span>) {
  <span class="hljs-comment">// 【易错点1】边界处理：n=1或n=2时需要提前返回</span>
  <span class="hljs-comment">// 如果n=1时进入循环，prevPrev=1, prev=2会计算出错误结果</span>
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;

  <span class="hljs-comment">// 初始化：对应dp[1]=1, dp[2]=2</span>
  <span class="hljs-keyword">let</span> prevPrev = <span class="hljs-number">1</span>; <span class="hljs-comment">// dp[i-2]，初始表示dp[1]=1</span>
  <span class="hljs-keyword">let</span> prev = <span class="hljs-number">2</span>; <span class="hljs-comment">// dp[i-1]，初始表示dp[2]=2</span>
  <span class="hljs-keyword">let</span> cur;

  <span class="hljs-comment">// 从第3阶开始计算</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {
    <span class="hljs-comment">// 计算当前阶的方法数</span>
    cur = prevPrev + prev;

    <span class="hljs-comment">// 【易错点2】滚动更新顺序很重要：先更新prevPrev，再更新prev</span>
    <span class="hljs-comment">// 如果顺序错误（如先更新prev），会导致prevPrev获取到错误的值</span>
    prevPrev = prev; <span class="hljs-comment">// 下一轮的dp[i-2] = 当前的dp[i-1]</span>
    prev = cur; <span class="hljs-comment">// 下一轮的dp[i-1] = 当前的dp[i]</span>
  }

  <span class="hljs-keyword">return</span> cur;
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>分页器组件</strong>：计算从第1页跳转到第n页的不同路径数（每次可以跳1页或2页）</li>
<li><strong>游戏开发</strong>：角色在台阶上移动，每次可以走1步或2步，计算到达目标位置的方案数</li>
<li><strong>动画路径计算</strong>：计算元素从位置A到位置B的不同动画路径数量</li>
</ul>
<hr/>
<h4 data-id="heading-7">2. LeetCode53. 最大子数组和 ★</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmaximum-subarray%2F" target="_blank" title="https://leetcode.cn/problems/maximum-subarray/" ref="nofollow noopener noreferrer">53. 最大子数组和</a></p>
<p><strong>难度</strong>：简单</p>
<p><strong>核心</strong>：贪心 + DP 结合，理解「状态转移的条件选择」</p>
<p><strong>前端场景</strong>：数据趋势统计、收益/数值最值分析、股票K线图最大收益区间、用户行为数据峰值分析</p>
<p><strong>题目描述</strong>：</p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组是数组中的一个连续部分。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]
输出：6
解释：连续子数组 <span class="hljs-section">[4,-1,2,1]</span> 的和最大，为 6。
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>]
输出：1
</code></pre>
<p><strong>示例 3</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]
输出：23
</code></pre>
<h5 data-id="heading-8">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i]</code> 表示以 <code>nums[i]</code> 为结尾的最大子数组和（注意：必须以nums[i]结尾）</li>
<li><strong>递推公式</strong>：<code>dp[i] = Math.max(nums[i], dp[i-1] + nums[i])</code>（要么重新开始，要么延续前面的和）</li>
<li><strong>初始化</strong>：<code>dp[0] = nums[0]</code>（第一个元素的最大子数组和就是它自己）</li>
<li><strong>遍历顺序</strong>：从左到右（i从1到n-1）</li>
<li><strong>打印验证</strong>：打印dp数组，找到最大值</li>
</ol>
<h5 data-id="heading-9">完整版代码</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode53. 最大子数组和
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;

  <span class="hljs-comment">// 【易错点1】边界处理：空数组返回0</span>
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i] 表示以nums[i]为结尾的最大子数组和（注意：必须以nums[i]结尾）</span>
  <span class="hljs-comment">// 这个定义很关键：保证子数组是连续的</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len);

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  <span class="hljs-comment">// 第一个元素的最大子数组和就是它自己（没有前面的元素可以延续）</span>
  dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];

  <span class="hljs-comment">// 用于记录全局最大值（因为dp[i]只表示以i结尾的最大和，不一定全局最大）</span>
  <span class="hljs-keyword">let</span> maxSum = dp[<span class="hljs-number">0</span>];

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：从左到右</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
    <span class="hljs-comment">// 【步骤2】确定递推公式</span>
    <span class="hljs-comment">// 核心思想：如果前面的和是负数，不如重新开始（贪心思想）</span>
    <span class="hljs-comment">// 两种选择：</span>
    <span class="hljs-comment">// 1. 重新开始：只选当前元素nums[i]（前面的和是负数，拖累总和）</span>
    <span class="hljs-comment">// 2. 延续前面的：dp[i-1] + nums[i]（前面的和是正数，可以继续累加）</span>
    dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i]);

    <span class="hljs-comment">// 【易错点2】必须实时更新全局最大值</span>
    <span class="hljs-comment">// 因为dp[i]只是以i结尾的最大和，最终答案不一定是dp[len-1]</span>
    maxSum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, dp[i]);

    <span class="hljs-comment">// 【步骤5】打印验证</span>
    <span class="hljs-comment">// console.log(`dp[${i}] = ${dp[i]}, maxSum = ${maxSum}`);</span>
  }

  <span class="hljs-keyword">return</span> maxSum;
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxSubArray</span>([-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxSubArray</span>([<span class="hljs-number">1</span>])); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxSubArray</span>([<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>])); <span class="hljs-comment">// 23</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxSubArray</span>([-<span class="hljs-number">1</span>])); <span class="hljs-comment">// -1</span>
</code></pre>
<h5 data-id="heading-10">空间优化版（只需一个变量）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：滚动变量
 * 时间复杂度：O(n)
 * 空间复杂度：O(1) ← 从O(n)优化到O(1)
 *
 * 【优化思路】
 * dp[i]只依赖dp[i-1]，不需要保存整个数组
 * 用一个变量prev保存上一个状态即可
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

  <span class="hljs-comment">// 用prev代替dp[i-1]，初始值为dp[0]</span>
  <span class="hljs-keyword">let</span> prev = nums[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">let</span> maxSum = prev;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
    <span class="hljs-comment">// 计算当前状态：要么重新开始，要么延续前面的</span>
    prev = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(nums[i], prev + nums[i]);

    <span class="hljs-comment">// 更新全局最大值</span>
    maxSum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, prev);
  }

  <span class="hljs-keyword">return</span> maxSum;
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>股票K线图</strong>：计算某段时间内买入卖出的最大收益（价格差的最大连续子数组和）</li>
<li><strong>用户行为分析</strong>：分析用户在某段时间内的活跃度峰值（数据流的最大连续区间和）</li>
<li><strong>性能监控</strong>：找到服务器响应时间最差的连续时间段（负值转换为响应时间）</li>
<li><strong>数据可视化</strong>：在折线图中高亮显示数据增长最快的连续区间</li>
</ul>
<hr/>
<h4 data-id="heading-11">3. LeetCode198. 打家劫舍 ★</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fhouse-robber%2F" target="_blank" title="https://leetcode.cn/problems/house-robber/" ref="nofollow noopener noreferrer">198. 打家劫舍</a></p>
<p><strong>难度</strong>：简单</p>
<p><strong>核心</strong>：状态转移的「条件限制」（相邻不选），基础空间优化</p>
<p><strong>前端场景</strong>：资源筛选、最优选择问题、权限分配优化、任务调度（不能同时执行相邻任务）</p>
<p><strong>题目描述</strong>：</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code>，请计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
输出：4
解释：偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。总金额 = 1 + <span class="hljs-attr">3</span> = <span class="hljs-number">4</span>。
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
输出：12
解释：偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 9），接着偷窃 5 号房屋（金额 = 1）。总金额 = 2 + 9 + <span class="hljs-attr">1</span> = <span class="hljs-number">12</span>。
</code></pre>
<h5 data-id="heading-12">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i]</code> 表示前i间房屋能偷到的最高金额
<ul>
<li>可以用二维状态：<code>dp[i][0]</code> 表示第i间不偷，<code>dp[i][1]</code> 表示第i间偷</li>
</ul>
</li>
<li><strong>递推公式</strong>：
<ul>
<li><code>dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1])</code>（不偷当前，前一间可偷可不偷）</li>
<li><code>dp[i][1] = dp[i-1][0] + nums[i-1]</code>（偷当前，前一间必须不偷）</li>
</ul>
</li>
<li><strong>初始化</strong>：<code>dp[0] = [0, 0]</code>（前0间，偷或不偷都是0）</li>
<li><strong>遍历顺序</strong>：从左到右（i从1到n）</li>
<li><strong>打印验证</strong>：打印dp数组验证</li>
</ol>
<h5 data-id="heading-13">完整版代码（二维状态）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode198. 打家劫舍
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;

  <span class="hljs-comment">// 【易错点1】边界处理</span>
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i][0] = 前i间房屋，第i间不偷能获取的最高金额</span>
  <span class="hljs-comment">// dp[i][1] = 前i间房屋，第i间偷能获取的最高金额</span>
  <span class="hljs-comment">// 使用二维状态可以清晰地表达"相邻不能同时偷"的约束</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len + <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  <span class="hljs-comment">// 前0间房屋：不偷和偷的金额都是0（没有房屋可偷）</span>
  dp[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：从左到右</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) {
    <span class="hljs-comment">// 【易错点2】数组索引转换：dp[i]对应nums[i-1]</span>
    <span class="hljs-comment">// dp[1]对应nums[0]（第1间房屋），dp[2]对应nums[1]（第2间房屋）</span>
    <span class="hljs-keyword">const</span> curVal = nums[i - <span class="hljs-number">1</span>];

    <span class="hljs-comment">// 【步骤2】确定递推公式</span>
    <span class="hljs-comment">// 状态1：第i间不偷 → 前i-1间可以偷也可以不偷，取最大值</span>
    <span class="hljs-keyword">const</span> valNotThief = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp[i - <span class="hljs-number">1</span>]);

    <span class="hljs-comment">// 状态2：第i间偷 → 前i-1间必须不偷（相邻不能同时偷），加上当前金额</span>
    <span class="hljs-comment">// 【易错点3】必须是dp[i-1][0]，不能是dp[i-1][1]（违反相邻规则）</span>
    <span class="hljs-keyword">const</span> valThief = curVal + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];

    <span class="hljs-comment">// 更新当前状态</span>
    dp[i] = [valNotThief, valThief];

    <span class="hljs-comment">// 【步骤5】打印验证</span>
    <span class="hljs-comment">// console.log(`dp[${i}] = [不偷:${valNotThief}, 偷:${valThief}]`);</span>
  }

  <span class="hljs-comment">// 最终结果：前len间房屋偷或不偷的最大值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp[len]);
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">rob</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])); <span class="hljs-comment">// 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">rob</span>([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])); <span class="hljs-comment">// 12</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">rob</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// 4</span>
</code></pre>
<h5 data-id="heading-14">空间优化版（两个变量）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：滚动变量
 * 时间复杂度：O(n)
 * 空间复杂度：O(1) ← 从O(n)优化到O(1)
 *
 * 【优化思路】
 * 观察递推公式：dp[i]只依赖dp[i-1]的两个值
 * 可以用两个变量vNot和vYes滚动更新
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

  <span class="hljs-comment">// 初始化：对应dp[0] = [0, 0]</span>
  <span class="hljs-keyword">let</span> vNot = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前i间不偷的最大值</span>
  <span class="hljs-keyword">let</span> vYes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前i间偷的最大值</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) {
    <span class="hljs-keyword">const</span> curVal = nums[i - <span class="hljs-number">1</span>];

    <span class="hljs-comment">// 【易错点4】关键：提前保存上一轮的所有状态，避免更新时覆盖</span>
    <span class="hljs-comment">// 如果直接使用vNot和vYes，更新vNot时可能会用到已经更新的vYes值</span>
    <span class="hljs-keyword">const</span> prevNot = vNot;
    <span class="hljs-keyword">const</span> prevYes = vYes;

    <span class="hljs-comment">// 不偷当前间：上一轮偷或不偷的最大值</span>
    vNot = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(prevNot, prevYes);

    <span class="hljs-comment">// 偷当前间：上一轮不偷的最大值 + 当前金额</span>
    <span class="hljs-comment">// 【易错点5】必须用prevNot，不能用vNot（因为vNot已经更新了）</span>
    vYes = curVal + prevNot;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(vNot, vYes);
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>任务调度</strong>：在任务列表中，某些任务不能同时执行（有依赖关系），求最大收益</li>
<li><strong>权限分配</strong>：某些权限不能同时授予（互斥权限），求最大权限价值组合</li>
<li><strong>资源选择</strong>：在资源列表中，相邻资源有冲突，求最优选择方案</li>
<li><strong>广告投放优化</strong>：相邻时段的广告不能同时投放，求最大收益的投放方案</li>
</ul>
<hr/>
<h3 data-id="heading-15">三、经典应用级（4道，DP核心考点，高频考）</h3>
<h4 data-id="heading-16">4. LeetCode62. 不同路径 ★</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Funique-paths%2F" target="_blank" title="https://leetcode.cn/problems/unique-paths/" ref="nofollow noopener noreferrer">62. 不同路径</a></p>
<p><strong>难度</strong>：中等</p>
<p><strong>核心</strong>：二维DP基础（可优化为一维），理解「路径型DP」</p>
<p><strong>前端场景</strong>：可视化布局路径计算、网格类问题、Canvas/SVG路径绘制、游戏地图路径规划</p>
<p><strong>题目描述</strong>：</p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 "Start" ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 "Finish"）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span>
输出：28
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-markdown" lang="markdown">输入：m = 3, n = 2
输出：3
解释：从左上角开始，总共有 3 条路径可以到达右下角：
<span class="hljs-bullet">1.</span> 向右 → 向下 → 向下
<span class="hljs-bullet">2.</span> 向下 → 向下 → 向右
<span class="hljs-bullet">3.</span> 向下 → 向右 → 向下
</code></pre>
<h5 data-id="heading-17">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i][j]</code> 表示从起点(0,0)走到位置(i,j)的不同路径数</li>
<li><strong>递推公式</strong>：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>（只能从上方或左方来）</li>
<li><strong>初始化</strong>：
<ul>
<li>第一行所有位置：<code>dp[0][j] = 1</code>（只能从左边来）</li>
<li>第一列所有位置：<code>dp[i][0] = 1</code>（只能从上边来）</li>
</ul>
</li>
<li><strong>遍历顺序</strong>：从上到下、从左到右（双重循环）</li>
<li><strong>打印验证</strong>：打印dp数组验证</li>
</ol>
<h5 data-id="heading-18">完整版代码（二维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode62. 不同路径
 * 时间复杂度：O(m * n)
 * 空间复杂度：O(m * n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">m, n</span>) {
  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i][j] 表示从左上角(0,0)走到位置(i,j)的不同路径数</span>
  <span class="hljs-comment">// 为了方便处理边界，使用dp[i+1][j+1]表示网格(i,j)的路径数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  <span class="hljs-comment">// 第一行（i=1）：所有位置只能从左边来，路径数都是1</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
    dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// 第一列（j=1）：所有位置只能从上边来，路径数都是1</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
    dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：从上到下、从左到右</span>
  <span class="hljs-comment">// 从(2,2)开始，因为第一行和第一列已经初始化</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {
      <span class="hljs-comment">// 【步骤2】确定递推公式</span>
      <span class="hljs-comment">// 走到(i,j)只有两种方式：</span>
      <span class="hljs-comment">// 1. 从上方(i-1,j)向下走一步 → 路径数 = dp[i-1][j]</span>
      <span class="hljs-comment">// 2. 从左方(i,j-1)向右走一步 → 路径数 = dp[i][j-1]</span>
      <span class="hljs-comment">// 总路径数 = 两种方式的路径数之和（加法原理）</span>
      dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
    }
  }

  <span class="hljs-comment">// 【步骤5】打印验证（调试时取消注释）</span>
  <span class="hljs-comment">// console.log('DP数组：');</span>
  <span class="hljs-comment">// for (let i = 1; i &lt;= m; i++) {</span>
  <span class="hljs-comment">//   console.log(dp[i].slice(1).join(' '));</span>
  <span class="hljs-comment">// }</span>

  <span class="hljs-keyword">return</span> dp[m][n];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniquePaths</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)); <span class="hljs-comment">// 28</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniquePaths</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniquePaths</span>(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 28</span>
</code></pre>
<h5 data-id="heading-19">空间优化版（一维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：一维DP
 * 时间复杂度：O(m * n)
 * 空间复杂度：O(n) ← 从O(m*n)优化到O(n)
 *
 * 【优化思路】
 * 观察递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]
 * 计算第i行时，只需要用到：
 * 1. 上一行第j列的值（dp[i-1][j]）→ 对应更新前的dp[j]
 * 2. 当前行第j-1列的值（dp[i][j-1]）→ 对应更新后的dp[j-1]
 * 可以用一维数组dp[j]滚动更新
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">m, n</span>) {
  <span class="hljs-comment">// 【步骤1】一维dp数组：dp[j]表示当前行第j列的路径数</span>
  <span class="hljs-comment">// 初始化为第一行的值：所有位置路径数都是1（只能从左边来）</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：从第2行开始遍历</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {
    <span class="hljs-comment">// 【易错点1】j从2开始，因为第1列（j=1）的值永远是1（只能从上边来）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {
      <span class="hljs-comment">// 【步骤2】递推公式（一维版）</span>
      <span class="hljs-comment">// dp[j]（更新前）= 上一行第j列的路径数（dp[i-1][j]）</span>
      <span class="hljs-comment">// dp[j-1]（更新后）= 当前行第j-1列的路径数（dp[i][j-1]）</span>
      <span class="hljs-comment">// 更新：dp[j] = dp[j]（旧值，来自上方）+ dp[j-1]（新值，来自左方）</span>
      dp[j] = dp[j] + dp[j - <span class="hljs-number">1</span>];

      <span class="hljs-comment">// 【易错点2】注意：这里dp[j-1]是已经更新的值（当前行），</span>
      <span class="hljs-comment">// 而dp[j]是旧值（上一行），正好符合递推公式的需求</span>
    }
  }

  <span class="hljs-keyword">return</span> dp[n];
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>Canvas/SVG路径绘制</strong>：计算从起点到终点的不同绘制路径数量</li>
<li><strong>游戏地图</strong>：计算角色从起点到终点的移动方案数（只能向右或向下）</li>
<li><strong>网格布局计算</strong>：在CSS Grid或Flex布局中，计算元素排列的不同路径数</li>
<li><strong>路由规划</strong>：在地图应用中，计算从A点到B点的不同路线数量</li>
</ul>
<hr/>
<h4 data-id="heading-20">5. LeetCode63. 不同路径 II</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Funique-paths-ii%2F" target="_blank" title="https://leetcode.cn/problems/unique-paths-ii/" ref="nofollow noopener noreferrer">63. 不同路径 II</a></p>
<p><strong>难度</strong>：中等</p>
<p><strong>核心</strong>：带障碍的路径DP，学会「状态转移的边界判断」</p>
<p><strong>前端场景</strong>：网格布局中的障碍物处理、表单验证路径计算、游戏地图障碍物路径规划</p>
<p><strong>题目描述</strong>：</p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 "Start" ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 "Finish"）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-lua" lang="lua">输入：obstacleGrid = <span class="hljs-string">[[0,0,0],[0,1,0],[0,0,0]]</span>
输出：<span class="hljs-number">2</span>
解释：<span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：
<span class="hljs-number">1.</span> 向右 → 向右 → 向下 → 向下
<span class="hljs-number">2.</span> 向下 → 向下 → 向右 → 向右
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-lua" lang="lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span>
输出：<span class="hljs-number">1</span>
</code></pre>
<h5 data-id="heading-21">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i][j]</code> 表示从起点到达位置(i,j)的路径数</li>
<li><strong>递推公式</strong>：
<ul>
<li>如果(i,j)是障碍物：<code>dp[i][j] = 0</code></li>
<li>否则：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></li>
</ul>
</li>
<li><strong>初始化</strong>：
<ul>
<li>第一行：遇到障碍物前都是1，遇到障碍物后都是0</li>
<li>第一列：遇到障碍物前都是1，遇到障碍物后都是0</li>
</ul>
</li>
<li><strong>遍历顺序</strong>：从上到下、从左到右</li>
<li><strong>打印验证</strong>：打印dp数组验证</li>
</ol>
<h5 data-id="heading-22">完整版代码（二维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode63. 不同路径 II（带障碍物）
 * 时间复杂度：O(m * n)
 * 空间复杂度：O(m * n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">obstacleGrid</span>) {
  <span class="hljs-keyword">const</span> m = obstacleGrid.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;

  <span class="hljs-comment">// 【易错点1】边界处理：起点或终点是障碍物，直接返回0</span>
  <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">1</span> || obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i][j] 表示从起点到达位置(i-1,j-1)的路径数（索引从1开始便于处理边界）</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  <span class="hljs-comment">// 初始化第一行：只能从左边来，遇到障碍物则后续位置无法到达</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
    <span class="hljs-keyword">const</span> curGrid = obstacleGrid[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 网格索引转换</span>
    <span class="hljs-keyword">if</span> (curGrid === <span class="hljs-number">1</span>) {
      <span class="hljs-comment">// 【易错点2】遇到障碍物，后续位置都无法到达，直接跳出</span>
      <span class="hljs-keyword">break</span>;
    }
    dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// 初始化第一列：只能从上边来，遇到障碍物则后续位置无法到达</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {
    <span class="hljs-comment">// 【易错点3】从i=2开始，因为dp[1][1]已在第一行初始化</span>
    <span class="hljs-keyword">const</span> curGrid = obstacleGrid[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (curGrid === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">break</span>;
    }
    dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：从第2行第2列开始</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) {
      <span class="hljs-comment">// 网格索引转换：dp[i][j]对应网格(i-1, j-1)</span>
      <span class="hljs-keyword">const</span> curGrid = obstacleGrid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];

      <span class="hljs-comment">// 【步骤2】确定递推公式</span>
      <span class="hljs-keyword">if</span> (curGrid === <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// 【易错点4】当前位置是障碍物，无法到达，路径数为0</span>
        dp[i][j] = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 当前位置不是障碍物，可以从上方或左方到达</span>
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
      }
    }
  }

  <span class="hljs-keyword">return</span> dp[m][n];
}
</code></pre>
<h5 data-id="heading-23">空间优化版（一维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：一维DP
 * 时间复杂度：O(m * n)
 * 空间复杂度：O(n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">obstacleGrid</span>) {
  <span class="hljs-keyword">const</span> m = obstacleGrid.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;

  <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">1</span> || obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// 一维dp数组：dp[j]表示当前行第j列的路径数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 初始化第一行</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
    <span class="hljs-keyword">const</span> curGrid = obstacleGrid[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (curGrid === <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
    dp[j] = <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// 从第2行开始遍历</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
      <span class="hljs-keyword">const</span> curGrid = obstacleGrid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (curGrid === <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// 【易错点5】障碍物位置路径数置0</span>
        dp[j] = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j === <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// 第一列：只能从上边来，保持dp[j]不变（如果上边是障碍物，dp[j]已经是0）</span>
        <span class="hljs-comment">// 不需要更新，因为第一列的路径数在初始化时已经确定</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 非第一列：可以从上方或左方到达</span>
        dp[j] = dp[j] + dp[j - <span class="hljs-number">1</span>];
      }
    }
  }

  <span class="hljs-keyword">return</span> dp[n];
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>表单验证</strong>：在复杂的多步骤表单中，某些步骤可能被禁用（障碍物），计算完成表单的不同路径</li>
<li><strong>游戏地图</strong>：在游戏中，某些格子是障碍物，计算从起点到终点的路径数</li>
<li><strong>权限路由</strong>：在权限系统中，某些路由节点被禁用，计算用户可访问的路由路径数</li>
<li><strong>工作流设计</strong>：在工作流中，某些节点可能被跳过，计算完成流程的不同路径</li>
</ul>
<hr/>
<h4 data-id="heading-24">6. LeetCode213. 打家劫舍 II</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fhouse-robber-ii%2F" target="_blank" title="https://leetcode.cn/problems/house-robber-ii/" ref="nofollow noopener noreferrer">213. 打家劫舍 II</a></p>
<p><strong>难度</strong>：中等</p>
<p><strong>核心</strong>：环形DP，拆分为两个基础DP问题（分治思想）</p>
<p><strong>前端场景</strong>：环形资源分配、循环任务调度、权限系统中的循环依赖处理</p>
<p><strong>题目描述</strong>：</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code>，请计算你在不触动警报装置的情况下，今晚能够偷窃到的最高金额。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2），因为他们是相邻的。
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + <span class="hljs-attr">3</span> = <span class="hljs-number">4</span>。
</code></pre>
<p><strong>示例 3</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
输出：3
</code></pre>
<h5 data-id="heading-25">DP五部曲分析（分治思想）</h5>
<p><strong>核心思路</strong>：环形问题转化为两个线性问题</p>
<ul>
<li>情况1：不偷第一间（可以偷最后一间）→ 转换为线性问题：偷 [1, len-1]</li>
<li>情况2：不偷最后一间（可以偷第一间）→ 转换为线性问题：偷 [0, len-2]</li>
<li>取两种情况的最大值</li>
</ul>
<h5 data-id="heading-26">完整版代码</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode213. 打家劫舍 II（环形）
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;

  <span class="hljs-comment">// 【易错点1】边界处理</span>
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);

  <span class="hljs-comment">// 【核心思路】环形问题拆分为两个线性问题</span>
  <span class="hljs-comment">// 情况1：不偷第一间（可以偷最后一间）→ 范围 [1, len-1]</span>
  <span class="hljs-comment">// 情况2：不偷最后一间（可以偷第一间）→ 范围 [0, len-2]</span>
  <span class="hljs-comment">// 取两种情况的最大值</span>

  <span class="hljs-comment">/**
   * 辅助函数：线性数组的打家劫舍（LeetCode198的解法）
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">arr</span> - 线性房屋数组
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 能偷到的最大金额
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">robLinear</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// 二维状态DP</span>
    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>);
    dp[<span class="hljs-number">0</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]; <span class="hljs-comment">// 前0间：不偷和偷都是0</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
      <span class="hljs-keyword">const</span> curVal = arr[i - <span class="hljs-number">1</span>];
      <span class="hljs-comment">// 不偷当前间：前i-1间偷或不偷的最大值</span>
      <span class="hljs-keyword">const</span> valNotThief = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp[i - <span class="hljs-number">1</span>]);
      <span class="hljs-comment">// 偷当前间：前i-1间必须不偷</span>
      <span class="hljs-keyword">const</span> valThief = curVal + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
      dp[i] = [valNotThief, valThief];
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp[n]);
  }

  <span class="hljs-comment">// 情况1：不偷第一间，范围是nums[1]到nums[len-1]</span>
  <span class="hljs-keyword">const</span> case1 = <span class="hljs-title function_">robLinear</span>(nums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>));

  <span class="hljs-comment">// 情况2：不偷最后一间，范围是nums[0]到nums[len-2]</span>
  <span class="hljs-keyword">const</span> case2 = <span class="hljs-title function_">robLinear</span>(nums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>));

  <span class="hljs-comment">// 【易错点2】返回两种情况的最大值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(case1, case2);
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">rob</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">rob</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])); <span class="hljs-comment">// 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">rob</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// 3</span>
</code></pre>
<h5 data-id="heading-27">空间优化版（使用滚动变量）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：robLinear函数使用滚动变量
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);

  <span class="hljs-comment">// 辅助函数：线性数组打家劫舍（空间优化版）</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">robLinear</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">const</span> n = arr.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">let</span> vNot = <span class="hljs-number">0</span>; <span class="hljs-comment">// 不偷的最大值</span>
    <span class="hljs-keyword">let</span> vYes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 偷的最大值</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
      <span class="hljs-keyword">const</span> curVal = arr[i];
      <span class="hljs-keyword">const</span> prevNot = vNot;
      <span class="hljs-keyword">const</span> prevYes = vYes;

      vNot = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(prevNot, prevYes);
      vYes = curVal + prevNot;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(vNot, vYes);
  }

  <span class="hljs-keyword">const</span> case1 = <span class="hljs-title function_">robLinear</span>(nums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>));
  <span class="hljs-keyword">const</span> case2 = <span class="hljs-title function_">robLinear</span>(nums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>));

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(case1, case2);
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>循环任务调度</strong>：在循环列表中，某些任务不能同时执行，求最大收益的调度方案</li>
<li><strong>环形权限分配</strong>：在权限环中，相邻权限互斥，求最大权限价值组合</li>
<li><strong>资源循环利用</strong>：在循环资源池中，某些资源不能同时使用，求最优资源分配</li>
<li><strong>时间轮调度</strong>：在时间轮算法中，计算最优的任务执行方案</li>
</ul>
<hr/>
<h4 data-id="heading-28">7. LeetCode322. 零钱兑换 ★</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcoin-change%2F" target="_blank" title="https://leetcode.cn/problems/coin-change/" ref="nofollow noopener noreferrer">322. 零钱兑换</a></p>
<p><strong>难度</strong>：中等</p>
<p><strong>核心</strong>：完全背包基础版，理解「最值型DP」的状态转移</p>
<p><strong>前端场景</strong>：金额/资源最优分配、最少步骤问题、支付找零算法、资源最小化配置</p>
<p><strong>题目描述</strong>：</p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], amount = <span class="hljs-number">11</span>
输出：3
解释：<span class="hljs-attr">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span>
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>], amount = <span class="hljs-number">3</span>
输出：-1
解释：无法凑成总金额 3
</code></pre>
<p><strong>示例 3</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], amount = <span class="hljs-number">0</span>
输出：0
</code></pre>
<h5 data-id="heading-29">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i][j]</code> 表示用前i种硬币凑出金额j所需的最少硬币个数</li>
<li><strong>递推公式</strong>：
<ul>
<li>不选第i种硬币：<code>dp[i][j] = dp[i-1][j]</code></li>
<li>选第i种硬币：<code>dp[i][j] = dp[i][j-coins[i-1]] + 1</code>（注意是<code>dp[i]</code>不是<code>dp[i-1]</code>，因为可以重复选）</li>
<li>取最小值：<code>dp[i][j] = Math.min(dp[i-1][j], dp[i][j-coins[i-1]] + 1)</code></li>
</ul>
</li>
<li><strong>初始化</strong>：
<ul>
<li><code>dp[0][0] = 0</code>（0种硬币凑0元需要0个）</li>
<li><code>dp[0][j&gt;0] = Infinity</code>（0种硬币无法凑正数金额）</li>
<li><code>dp[i][0] = 0</code>（凑0元永远需要0个）</li>
</ul>
</li>
<li><strong>遍历顺序</strong>：外层遍历硬币种类，内层遍历金额（正序，因为是完全背包）</li>
<li><strong>打印验证</strong>：打印dp数组验证</li>
</ol>
<h5 data-id="heading-30">完整版代码（二维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode322. 零钱兑换（完全背包-最值型）
 * 时间复杂度：O(coins.length * amount)
 * 空间复杂度：O(coins.length * amount)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">coins, amount</span>) {
  <span class="hljs-keyword">const</span> coinCount = coins.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> target = amount;

  <span class="hljs-comment">// 【易错点1】边界处理：凑0元直接返回0</span>
  <span class="hljs-keyword">if</span> (target === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i][j] = 用前i种硬币凑出金额j所需的最少硬币个数</span>
  <span class="hljs-comment">// 初始化：所有值先填Infinity（表示初始无法凑出）</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(coinCount + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Infinity</span>));

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0种硬币凑0元，需要0个</span>
  <span class="hljs-comment">// 0种硬币凑正数金额，无法凑出（保持Infinity）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= target; j++) {
    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-title class_">Infinity</span>;
  }

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：外层遍历硬币种类，内层遍历金额（正序）</span>
  <span class="hljs-comment">// 正序遍历是因为完全背包：每种硬币可以使用无限次</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= coinCount; i++) {
    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 凑0元永远需要0个硬币</span>
    <span class="hljs-keyword">const</span> curCoin = coins[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 【易错点2】数组索引转换：第i种硬币对应coins[i-1]</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= target; j++) {
      <span class="hljs-keyword">if</span> (j &lt; curCoin) {
        <span class="hljs-comment">// 金额不足，无法使用当前硬币，继承前i-1种硬币的结果</span>
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 【步骤2】确定递推公式</span>
        <span class="hljs-comment">// 完全背包核心：用当前硬币时是dp[i][j-curCoin]+1（而非dp[i-1]）</span>
        <span class="hljs-comment">// 因为硬币可以重复使用，所以用dp[i]（已经考虑了当前硬币）</span>
        dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(
          dp[i - <span class="hljs-number">1</span>][j], <span class="hljs-comment">// 不用第i种硬币</span>
          dp[i][j - curCoin] + <span class="hljs-number">1</span> <span class="hljs-comment">// 用第i种硬币（注意是dp[i]，可以重复选）</span>
        );
      }
    }
  }

  <span class="hljs-comment">// 【易错点3】无法凑出时返回-1，而非Infinity</span>
  <span class="hljs-keyword">return</span> dp[coinCount][target] === <span class="hljs-title class_">Infinity</span> ? -<span class="hljs-number">1</span> : dp[coinCount][target];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">coinChange</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], <span class="hljs-number">11</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">coinChange</span>([<span class="hljs-number">2</span>], <span class="hljs-number">3</span>)); <span class="hljs-comment">// -1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">coinChange</span>([<span class="hljs-number">1</span>], <span class="hljs-number">0</span>)); <span class="hljs-comment">// 0</span>
</code></pre>
<h5 data-id="heading-31">空间优化版（一维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：一维DP
 * 时间复杂度：O(coins.length * amount)
 * 空间复杂度：O(amount) ← 从O(coins.length * amount)优化到O(amount)
 *
 * 【优化思路】
 * 观察递推公式：dp[i][j] = Math.min(dp[i-1][j], dp[i][j-coins[i-1]] + 1)
 * 计算dp[i][j]时只需要：
 * 1. 上一行第j列的值（dp[i-1][j]）→ 对应更新前的dp[j]
 * 2. 当前行第j-coins[i-1]列的值（dp[i][j-coins[i-1]]）→ 对应更新后的dp[j-coins[i-1]]
 * 可以用一维数组dp[j]正序遍历（完全背包特征：正序）
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">coins, amount</span>) {
  <span class="hljs-keyword">const</span> coinCount = coins.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> target = amount;

  <span class="hljs-keyword">if</span> (target === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 【步骤1】一维dp数组：dp[j] = 凑出金额j所需的最少硬币个数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Infinity</span>);

  <span class="hljs-comment">// 【步骤3】初始化</span>
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 凑0元需要0个硬币</span>

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：外层遍历硬币，内层正序遍历金额</span>
  <span class="hljs-comment">// 【易错点4】完全背包必须正序遍历：保证每种硬币可以使用无限次</span>
  <span class="hljs-comment">// 如果倒序遍历，就变成了01背包（每种硬币只能用一次）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= coinCount; i++) {
    <span class="hljs-keyword">const</span> curCoin = coins[i - <span class="hljs-number">1</span>];

    <span class="hljs-comment">// 【易错点5】从curCoin开始遍历，避免j&lt;curCoin的无效判断</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = curCoin; j &lt;= target; j++) {
      <span class="hljs-comment">// 【步骤2】递推公式（一维版）</span>
      <span class="hljs-comment">// dp[j]（更新前）= 不用当前硬币的最少个数（上一轮的结果）</span>
      <span class="hljs-comment">// dp[j - curCoin] + 1 = 用当前硬币的最少个数（当前轮已更新的结果）</span>
      dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[j], dp[j - curCoin] + <span class="hljs-number">1</span>);
    }
  }

  <span class="hljs-comment">// 【易错点6】返回前检查是否为Infinity</span>
  <span class="hljs-keyword">return</span> dp[target] === <span class="hljs-title class_">Infinity</span> ? -<span class="hljs-number">1</span> : dp[target];
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>支付找零</strong>：在支付系统中，计算用最少硬币数找零给用户</li>
<li><strong>资源最小化配置</strong>：在资源分配中，用最少的资源组合达到目标值</li>
<li><strong>API调用优化</strong>：计算用最少的API调用次数完成某个任务</li>
<li><strong>组件懒加载</strong>：计算用最少的组件加载次数完成页面渲染</li>
</ul>
<hr/>
<h4 data-id="heading-32">8. LeetCode518. 零钱兑换 II</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcoin-change-ii%2F" target="_blank" title="https://leetcode.cn/problems/coin-change-ii/" ref="nofollow noopener noreferrer">518. 零钱兑换 II</a></p>
<p><strong>难度</strong>：中等</p>
<p><strong>核心</strong>：完全背包的「组合数型DP」，与322（最值型）做区分</p>
<p><strong>前端场景</strong>：组合方案统计、支付方式组合数计算、资源配置方案数统计</p>
<p><strong>题目描述</strong>：</p>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">amount</span> = <span class="hljs-number">5</span>, coins = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
输出：4
解释：有四种方式可以凑成总金额：
<span class="hljs-attr">5</span>=<span class="hljs-number">5</span>
<span class="hljs-attr">5</span>=<span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">1</span>
<span class="hljs-attr">5</span>=<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>
<span class="hljs-attr">5</span>=<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">amount</span> = <span class="hljs-number">3</span>, coins = [<span class="hljs-number">2</span>]
输出：0
解释：只用面额 2 的硬币无法凑成总金额 3。
</code></pre>
<p><strong>示例 3</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">amount</span> = <span class="hljs-number">10</span>, coins = [<span class="hljs-number">10</span>]
输出：1
</code></pre>
<h5 data-id="heading-33">DP五部曲分析（与322的区别）</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i][j]</code> 表示用前i种硬币凑出金额j的组合数（注意：是组合数，不是最少个数）</li>
<li><strong>递推公式</strong>：
<ul>
<li>不选第i种硬币：<code>dp[i][j] = dp[i-1][j]</code></li>
<li>选第i种硬币：<code>dp[i][j] = dp[i][j-coins[i-1]]</code>（注意是加法，不是取最小值）</li>
<li>总组合数：<code>dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]</code></li>
</ul>
</li>
<li><strong>初始化</strong>：
<ul>
<li><code>dp[0][0] = 1</code>（0种硬币凑0元，有1种组合：不选任何硬币）</li>
<li><code>dp[i][0] = 1</code>（凑0元永远只有1种组合）</li>
<li><code>dp[0][j&gt;0] = 0</code>（0种硬币无法凑正数金额）</li>
</ul>
</li>
<li><strong>遍历顺序</strong>：外层遍历硬币（保证组合不重复），内层正序遍历金额</li>
<li><strong>打印验证</strong>：打印dp数组验证</li>
</ol>
<h5 data-id="heading-34">完整版代码（二维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode518. 零钱兑换 II（完全背包-组合数型）
 * 时间复杂度：O(coins.length * amount)
 * 空间复杂度：O(coins.length * amount)
 *
 * 【与322的区别】
 * - 322求：最少的硬币个数（最值型）→ Math.min
 * - 518求：组合数（计数型）→ 加法
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">amount, coins</span>) {
  <span class="hljs-keyword">const</span> coinCount = coins.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> targetAmount = amount;

  <span class="hljs-comment">// 【易错点1】边界处理：凑0元返回1（唯一组合：不选任何硬币）</span>
  <span class="hljs-keyword">if</span> (targetAmount === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i][j] = 用前i种硬币凑出金额j的组合数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(coinCount + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(targetAmount + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  <span class="hljs-comment">// 【易错点2】凑0元的组合数是1（不选任何硬币），不是0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= coinCount; i++) {
    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 凑0元永远只有1种组合</span>
  }

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：外层遍历硬币，内层正序遍历金额</span>
  <span class="hljs-comment">// 【关键】外层遍历硬币保证了组合不重复：如[1,2]和[2,1]被视为同一种组合</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= coinCount; i++) {
    <span class="hljs-keyword">const</span> currentCoin = coins[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 【易错点3】数组索引转换</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= targetAmount; j++) {
      <span class="hljs-keyword">if</span> (j &lt; currentCoin) {
        <span class="hljs-comment">// 金额不足，无法用当前硬币，继承前i-1种的组合数</span>
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 【步骤2】确定递推公式（组合数 = 不用 + 用）</span>
        <span class="hljs-comment">// dp[i-1][j]：不用第i种硬币的组合数</span>
        <span class="hljs-comment">// dp[i][j-currentCoin]：用第i种硬币的组合数（注意是dp[i]，可重复选）</span>
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - currentCoin];
      }
    }
  }

  <span class="hljs-comment">// 无法凑出时自然返回0（符合题目要求）</span>
  <span class="hljs-keyword">return</span> dp[coinCount][targetAmount];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">change</span>(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>])); <span class="hljs-comment">// 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">change</span>(<span class="hljs-number">3</span>, [<span class="hljs-number">2</span>])); <span class="hljs-comment">// 0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">change</span>(<span class="hljs-number">10</span>, [<span class="hljs-number">10</span>])); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">change</span>(<span class="hljs-number">0</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// 1</span>
</code></pre>
<h5 data-id="heading-35">空间优化版（一维DP）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：一维DP
 * 时间复杂度：O(coins.length * amount)
 * 空间复杂度：O(amount)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">amount, coins</span>) {
  <span class="hljs-keyword">const</span> coinCount = coins.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> targetAmount = amount;

  <span class="hljs-keyword">if</span> (targetAmount === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

  <span class="hljs-comment">// 【步骤1】一维dp数组：dp[j] = 凑出金额j的组合数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(targetAmount + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 【核心初始化】凑0元的组合数为1</span>

  <span class="hljs-comment">// 【步骤4】遍历顺序：外层遍历硬币，内层正序遍历金额</span>
  <span class="hljs-comment">// 【关键理解】外层遍历硬币 → 保证组合数不重复</span>
  <span class="hljs-comment">// 如果外层遍历金额，内层遍历硬币，会得到排列数（顺序有关）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= coinCount; i++) {
    <span class="hljs-keyword">const</span> currentCoin = coins[i - <span class="hljs-number">1</span>];

    <span class="hljs-comment">// 【易错点4】完全背包：金额正序遍历（从currentCoin开始）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = currentCoin; j &lt;= targetAmount; j++) {
      <span class="hljs-comment">// 【步骤2】递推公式（一维版）</span>
      <span class="hljs-comment">// dp[j]（更新前）= 不用当前硬币的组合数（上一轮的结果）</span>
      <span class="hljs-comment">// dp[j - currentCoin]（更新后）= 用当前硬币的组合数（当前轮已更新的结果）</span>
      dp[j] = dp[j] + dp[j - currentCoin];
    }
  }

  <span class="hljs-keyword">return</span> dp[targetAmount];
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>支付方式组合</strong>：计算用户可以用多少种不同的支付方式组合完成支付</li>
<li><strong>资源配置方案</strong>：计算有多少种不同的资源配置方案可以达到目标</li>
<li><strong>功能组合统计</strong>：计算有多少种不同的功能组合可以满足用户需求</li>
<li><strong>优惠券组合</strong>：计算有多少种不同的优惠券组合可以使用</li>
</ul>
<hr/>
<h3 data-id="heading-36">四、进阶拓展级（3道，中大厂加分，理解即可）</h3>
<h4 data-id="heading-37">9. LeetCode300. 最长递增子序列</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flongest-increasing-subsequence%2F" target="_blank" title="https://leetcode.cn/problems/longest-increasing-subsequence/" ref="nofollow noopener noreferrer">300. 最长递增子序列</a></p>
<p><strong>难度</strong>：中等</p>
<p><strong>核心</strong>：单维度DP的经典拓展，理解「非连续状态转移」</p>
<p><strong>前端场景</strong>：数据趋势分析、序列统计、时间线组件、用户行为序列分析</p>
<p><strong>题目描述</strong>：</p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]
输出：4
解释：最长递增子序列是 <span class="hljs-section">[2,3,7,101]</span>，因此长度为 4。
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
输出：4
解释：最长递增子序列是 <span class="hljs-section">[0,1,2,3]</span>，长度为 4
</code></pre>
<p><strong>示例 3</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>]
输出：1
解释：最长递增子序列是 <span class="hljs-section">[7]</span>，长度为 1
</code></pre>
<h5 data-id="heading-38">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i]</code> 表示以 <code>nums[i]</code> 为最后一个元素的最长严格递增子序列的长度</li>
<li><strong>递推公式</strong>：
<ul>
<li>对于每个 <code>nums[i]</code>，遍历前面所有元素 <code>nums[j]</code> (j &lt; i)</li>
<li>如果 <code>nums[i] &gt; nums[j]</code>，则 <code>nums[i]</code> 可以接在 <code>nums[j]</code> 的子序列后面</li>
<li><code>dp[i] = Math.max(dp[i], dp[j] + 1)</code> （在所有满足条件的j中取最大值）</li>
</ul>
</li>
<li><strong>初始化</strong>：<code>dp[i] = 1</code>（每个元素自身构成长度为1的子序列）</li>
<li><strong>遍历顺序</strong>：外层遍历i（从1到n-1），内层遍历j（从0到i-1）</li>
<li><strong>打印验证</strong>：打印dp数组，返回最大值（注意：最长子序列不一定以最后一个元素结尾）</li>
</ol>
<h5 data-id="heading-39">完整版代码</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode300. 最长递增子序列
 * 时间复杂度：O(n²)
 * 空间复杂度：O(n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> count = nums.<span class="hljs-property">length</span>;

  <span class="hljs-comment">// 【易错点1】边界处理：空数组/单元素数组</span>
  <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> count;

  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i] = 以nums[i]为最后一个元素的最长严格递增子序列的长度</span>
  <span class="hljs-comment">// 【易错点2】初始化错误：必须初始化为1，不能初始化为0</span>
  <span class="hljs-comment">// 因为每个元素自身至少构成长度为1的子序列</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(count).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：外层遍历i，内层遍历j</span>
  <span class="hljs-comment">// 【易错点3】i从1开始：i=0时前面没有元素，无法计算</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; count; i++) {
    <span class="hljs-keyword">const</span> curNum = nums[i]; <span class="hljs-comment">// 当前元素</span>

    <span class="hljs-comment">// 内层遍历：检查i前面所有元素j（而非仅j=i-1）</span>
    <span class="hljs-comment">// 【易错点4】必须遍历所有j&lt;i，不能只遍历j=i-1</span>
    <span class="hljs-comment">// 因为子序列可以非连续，nums[i]可以接在任意满足条件的nums[j]后面</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
      <span class="hljs-comment">// 【步骤2】确定递推公式</span>
      <span class="hljs-comment">// 【易错点5】递增条件：必须是严格递增（&gt;），不能是&gt;=</span>
      <span class="hljs-keyword">if</span> (curNum &gt; nums[j]) {
        <span class="hljs-comment">// 如果nums[i] &gt; nums[j]，则nums[i]可以接在nums[j]的子序列后面</span>
        <span class="hljs-comment">// 取所有满足条件的dp[j]+1的最大值</span>
        dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-comment">// 【步骤5】打印验证</span>
    <span class="hljs-comment">// console.log(`dp[${i}] = ${dp[i]}`);</span>
  }

  <span class="hljs-comment">// 【易错点6】返回错误：不能返回dp[count-1]</span>
  <span class="hljs-comment">// 因为最长递增子序列不一定以最后一个元素结尾</span>
  <span class="hljs-comment">// 必须返回dp数组中的最大值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp);
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLIS</span>([<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">101</span>, <span class="hljs-number">18</span>])); <span class="hljs-comment">// 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLIS</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLIS</span>([<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>])); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLIS</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])); <span class="hljs-comment">// 6</span>
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>时间线组件</strong>：在时间线中，找到最长连续增长的时间段</li>
<li><strong>用户行为分析</strong>：分析用户行为序列中最长的正向发展趋势</li>
<li><strong>数据可视化</strong>：在图表中高亮显示数据的最长递增区间</li>
<li><strong>版本号比较</strong>：找到版本号序列中最长的递增子序列</li>
</ul>
<hr/>
<h4 data-id="heading-40">10. LeetCode121. 买卖股票的最佳时机 ★</h4>
<p><strong>题目链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fbest-time-to-buy-and-sell-stock%2F" target="_blank" title="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" ref="nofollow noopener noreferrer">121. 买卖股票的最佳时机</a></p>
<p><strong>难度</strong>：简单</p>
<p><strong>核心</strong>：DP + 贪心结合，也可纯DP实现，理解「状态定义的简化」</p>
<p><strong>前端场景</strong>：数据趋势、收益计算、股票K线图分析、价格波动分析</p>
<p><strong>题目描述</strong>：</p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>如果你不能获取任何利润，返回 0 。</p>
<p><strong>示例 1</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-section">[7,1,5,3,6,4]</span>
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = <span class="hljs-attr">6-1</span> = <span class="hljs-number">5</span>。
     注意利润不能是 <span class="hljs-attr">7-1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
</code></pre>
<p><strong>示例 2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">输入：<span class="hljs-attr">prices</span> = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
输出：0
解释：在这种情况下, 交易无法完成, 所以返回 0。
</code></pre>
<h5 data-id="heading-41">DP五部曲分析</h5>
<ol>
<li><strong>dp数组含义</strong>：<code>dp[i]</code> 表示第i天卖出股票能获得的最大利润</li>
<li><strong>递推公式</strong>：<code>dp[i] = prices[i] - minPrice</code>（当天价格减去之前的最小价格）</li>
<li><strong>初始化</strong>：<code>dp[0] = 0</code>（第0天无法卖出），<code>minPrice = prices[0]</code></li>
<li><strong>遍历顺序</strong>：从左到右（i从1到n-1），同时维护最小价格</li>
<li><strong>打印验证</strong>：打印dp数组，返回最大值（注意：最大利润不一定在最后一天卖出）</li>
</ol>
<h5 data-id="heading-42">完整版代码</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * LeetCode121. 买卖股票的最佳时机
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">prices</span>) {
  <span class="hljs-keyword">const</span> count = prices.<span class="hljs-property">length</span>;

  <span class="hljs-comment">// 【易错点1】边界处理：空数组/单元素数组</span>
  <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 【步骤1】确定dp数组及下标的含义</span>
  <span class="hljs-comment">// dp[i] = 第i天卖出股票能获得的最大利润</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(count).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 【步骤3】dp数组如何初始化</span>
  <span class="hljs-comment">// 第0天无法卖出（必须先买入），利润为0</span>
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 维护遍历到当前的最小价格（用于计算利润）</span>
  <span class="hljs-keyword">let</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始买入价格是第0天的价格</span>

  <span class="hljs-comment">// 【步骤4】确定遍历顺序：从左到右</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; count; i++) {
    <span class="hljs-keyword">const</span> curPrice = prices[i]; <span class="hljs-comment">// 当天价格</span>

    <span class="hljs-comment">// 【核心逻辑1】更新最小价格（必须先更新，再计算利润）</span>
    <span class="hljs-comment">// 【易错点2】顺序错误：如果先计算利润再更新minPrice，会导致"当天买当天卖"的逻辑错误</span>
    <span class="hljs-comment">// 正确的顺序：先更新minPrice（基于之前的价格），再计算当天卖出的利润</span>
    minPrice = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(minPrice, curPrice);

    <span class="hljs-comment">// 【步骤2】确定递推公式</span>
    <span class="hljs-comment">// 第i天卖出的最大利润 = 当天价格 - 之前的最小价格（最佳买入点）</span>
    <span class="hljs-comment">// 如果结果为负，dp[i]保持0（等价于不交易）</span>
    dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, curPrice - minPrice);

    <span class="hljs-comment">// 【步骤5】打印验证</span>
    <span class="hljs-comment">// console.log(`第${i}天：价格=${curPrice}, 最小价格=${minPrice}, 利润=${dp[i]}`);</span>
  }

  <span class="hljs-comment">// 【易错点3】返回错误：不能返回dp[count-1]</span>
  <span class="hljs-comment">// 因为最大利润不一定在最后一天卖出（如示例1中最大利润在第5天，不是最后一天）</span>
  <span class="hljs-comment">// 必须返回dp数组中的最大值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp);
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxProfit</span>([<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxProfit</span>([<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])); <span class="hljs-comment">// 0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxProfit</span>([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>])); <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">maxProfit</span>([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// 4</span>
</code></pre>
<h5 data-id="heading-43">空间优化版（只需一个变量）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * 空间优化版：贪心思想
 * 时间复杂度：O(n)
 * 空间复杂度：O(1) ← 从O(n)优化到O(1)
 *
 * 【优化思路】
 * 观察：dp[i]只依赖dp[i-1]和minPrice
 * 而且我们只需要最大值，不需要保存整个dp数组
 * 用一个变量maxProfit实时更新最大值即可
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">prices</span>) {
  <span class="hljs-keyword">const</span> count = prices.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">let</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 最小买入价格</span>
  <span class="hljs-keyword">let</span> maxProfit = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大利润</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; count; i++) {
    <span class="hljs-keyword">const</span> curPrice = prices[i];

    <span class="hljs-comment">// 更新最小价格</span>
    minPrice = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(minPrice, curPrice);

    <span class="hljs-comment">// 计算当天卖出的利润，并更新最大利润</span>
    maxProfit = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxProfit, curPrice - minPrice);
  }

  <span class="hljs-keyword">return</span> maxProfit;
}
</code></pre>
<p><strong>前端应用场景</strong>：</p>
<ul>
<li><strong>股票K线图</strong>：在股票图表中，计算买入卖出的最佳时机和最大收益</li>
<li><strong>价格趋势分析</strong>：分析商品价格变化，找到最佳买卖点</li>
<li><strong>收益计算器</strong>：在投资应用中，计算投资组合的最大收益</li>
<li><strong>数据波动分析</strong>：分析数据序列中的最大正向波动（类似股票收益）</li>
</ul>
<hr/>
<h3 data-id="heading-44">五、总结</h3>
<p>通过这10道动态规划经典题目，我们掌握了：</p>
<h4 data-id="heading-45">核心框架：DP五部曲</h4>
<ol>
<li>确定dp数组及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>打印dp数组（验证）</li>
</ol>
<h4 data-id="heading-46">题目分类</h4>









































<table><thead><tr><th>类别</th><th>题目</th><th>核心特点</th><th>空间优化</th></tr></thead><tbody><tr><td><strong>基础递推</strong></td><td>爬楼梯、最大子数组和、打家劫舍</td><td>一维DP，状态转移简单</td><td>滚动变量 O(1)</td></tr><tr><td><strong>路径型DP</strong></td><td>不同路径、不同路径II</td><td>二维DP，网格问题</td><td>一维数组 O(n)</td></tr><tr><td><strong>背包问题</strong></td><td>零钱兑换、零钱兑换II</td><td>完全背包，最值/计数</td><td>一维数组 O(amount)</td></tr><tr><td><strong>序列问题</strong></td><td>最长递增子序列</td><td>非连续状态转移</td><td>难优化</td></tr><tr><td><strong>状态机DP</strong></td><td>买卖股票、打家劫舍II</td><td>状态转换，环形问题</td><td>滚动变量 O(1)</td></tr></tbody></table>
<h4 data-id="heading-47">易错点总结</h4>
<ol>
<li><strong>边界处理</strong>：空数组、单元素、索引转换</li>
<li><strong>初始化</strong>：根据问题特点正确初始化（0、1、Infinity等）</li>
<li><strong>遍历顺序</strong>：完全背包正序，01背包倒序</li>
<li><strong>返回值</strong>：注意是返回<code>dp[n]</code>还是<code>Math.max(...dp)</code></li>
<li><strong>空间优化</strong>：注意更新顺序，避免覆盖未使用的值</li>
</ol>
<h4 data-id="heading-48">前端应用价值</h4>
<p>动态规划在前端开发中广泛应用于：</p>
<ul>
<li><strong>性能优化</strong>：资源分配、组件懒加载优化</li>
<li><strong>业务逻辑</strong>：支付找零、权限分配、任务调度</li>
<li><strong>数据可视化</strong>：趋势分析、K线图、时间线组件</li>
<li><strong>算法优化</strong>：路径规划、组合统计、最值计算</li>
</ul>
<p>掌握这10道题目，足以应对前端算法面试中的大部分DP问题。记住：<strong>先理解DP五部曲框架，再套用到具体问题，最后优化空间复杂度</strong>。</p>
<hr/>
<p><strong>相关资源</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Ftag%2Fdynamic-programming%2F" target="_blank" title="https://leetcode.cn/tag/dynamic-programming/" ref="nofollow noopener noreferrer">LeetCode动态规划专题</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fprogrammercarl.com%2F" target="_blank" title="https://programmercarl.com/" ref="nofollow noopener noreferrer">DP五部曲详细讲解</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftrending%2Fjavascript" target="_blank" title="https://github.com/trending/javascript" ref="nofollow noopener noreferrer">前端算法刷题路线</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【保姆级教程】10分钟把手机变成AI Agent：自动刷课、回消息，学不会我“退网”！]]></title>    <link>https://juejin.cn/post/7593310044478767113</link>    <guid>https://juejin.cn/post/7593310044478767113</guid>    <pubDate>2026-01-10T12:10:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593310044478767113" data-draft-id="7593541291011604507" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【保姆级教程】10分钟把手机变成AI Agent：自动刷课、回消息，学不会我“退网”！"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-10T12:10:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LucianaiB"/> <meta itemprop="url" content="https://juejin.cn/user/1269294586664749"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【保姆级教程】10分钟把手机变成AI Agent：自动刷课、回消息，学不会我“退网”！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1269294586664749/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LucianaiB
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T12:10:26.000Z" title="Sat Jan 10 2026 12:10:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是LucianaiB。</p>
<p>今天，我将带你一步步部署属于你自己的 <strong>AI 手机</strong>。别以为这很难，跟着我的节奏，<strong>10分钟就能搞定</strong>。如果你还是学不会，那我就真的“退网”好了！</p>
<p>此前，开源社区涌现出的 <strong>Open-AutoGLM</strong> 项目引起了广泛关注。很多人误以为配置私有化 AI 手机需要极高的技术门槛，其实只要掌握正确的方法，它比你想象的要简单得多。</p>
<p>无论是自动刷课、批量处理信息，还是在不方便触控时进行语音交互，它都能将你的“想象”转化为“行动”，真正解放劳动力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f20ed3338b5c4282aa101705d2ba29a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=l0S3NIc6srnEt%2FBJZHOvaSERhkM%3D" alt="f328c369dd4321cee682ccaf2e2e2bdb.png" loading="lazy"/></p>
<h2 data-id="heading-0">1.为什么需要一个AI手机？</h2>
<p>在快节奏的生活中，我们总是希望把重复、繁琐的工作交给机器。开源 AI 手机的出现，让这种想象成为了现实。</p>
<ul>
<li><strong>大学生</strong>：它可以帮你“代劳”那些枯燥的网课，甚至自动签到。</li>
<li><strong>生活达人</strong>：做饭、运动双手不便时，它能帮你自动回复消息、刷短视频。</li>
<li><strong>极客</strong>：自动进行 App UI 测试，批量处理数据。</li>
</ul>
<p>这不仅是解放双手，更是为生活增添了无限可能。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8402ff30412042b99b0eab9cb067c03c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=w8xXsXFYPPgJBNL9SkbIOVL84%2F0%3D" alt="img" loading="lazy"/></p>
<p>演示效果（懒人自动刷抖音）：</p>
<blockquote>
<p>“AI手机的本质，不是在手机里装一个聊天机器人，而是让手机具备‘理解意图并自动执行’的代理能力（Agentic Capability）。”</p>
</blockquote>
<h2 data-id="heading-1">2.前置环境配置</h2>
<p>本文章为开源的保姆级安装教程：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzai-org%2FOpen-AutoGLM" target="_blank" title="https://github.com/zai-org/Open-AutoGLM" ref="nofollow noopener noreferrer">github.com/zai-org/Ope…</a></p>
<p>所谓“工欲善其事，必先利其器”。在开始部署之前，我们需要准备好四大件：GLM API、Python环境、ADB工具和配置安卓环境。</p>
<h3 data-id="heading-2">3.Glm API</h3>
<p>这是AI手机的“大脑”，负责思考和决策。</p>
<p>点击链接注册：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bigmodel.cn%2Fglm-coding%3Fic%3D4G1ARPDRUV%25EF%25BC%2588%25F0%259F%258C%259F%25E6%2582%2584%25E6%2582%2584%25E8%25AF%25B4%25E4%25B8%2580%25E4%25B8%258B%25EF%25BC%258C%25E6%2596%25B0%25E7%2594%25A8%25E6%2588%25B7%25E6%259C%2589%25E7%25A6%258F%25E5%2588%25A9%25EF%25BC%2589" target="_blank" title="https://www.bigmodel.cn/glm-coding?ic=4G1ARPDRUV%EF%BC%88%F0%9F%8C%9F%E6%82%84%E6%82%84%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%96%B0%E7%94%A8%E6%88%B7%E6%9C%89%E7%A6%8F%E5%88%A9%EF%BC%89" ref="nofollow noopener noreferrer">www.bigmodel.cn/glm-coding?…</a></p>
<p>打开Glm API Key：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbigmodel.cn%2Fusercenter%2Fproj-mgmt%2Fapikeys" target="_blank" title="https://bigmodel.cn/usercenter/proj-mgmt/apikeys" ref="nofollow noopener noreferrer">bigmodel.cn/usercenter/…</a></p>
<p>右上角新建一个 API Key，然后记住即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85526b9032d44a99bc7c5dc52b1fe5e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=gOqiaJUnuaEr9U0qDDuvJakRXCs%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-3">Python</h3>
<p>访问 Python 官网下载页：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.python.org%2Fdownloads%2F%25E3%2580%2582" target="_blank" title="https://www.python.org/downloads/%E3%80%82" ref="nofollow noopener noreferrer">www.python.org/downloads/</a>，页面顶部会有“Download Python 3.x.x”按钮，自动匹配你的系统（Windows/macOS/Linux），点击即可下载安装包。（最好安装3.12以上版本）</p>
<p>查看你的Python版本号</p>
<pre><code class="hljs language-Plain" lang="Plain">python --version
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a932cff8db3404bac1898c3d859a299~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=w6ayKr1qufHzLYhumzlJljnDvAo%3D" alt="img" loading="lazy"/></p>
<p>为了避免污染全局环境，强烈建议创建一个虚拟环境。你可以使用以下代码创建一个独立的Python环境：</p>
<pre><code class="hljs language-Python" lang="Python"><span class="hljs-comment"># create_env.py</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> venv
 
<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_virtual_env</span>(<span class="hljs-params">path=<span class="hljs-string">"venv"</span></span>):
    <span class="hljs-string">"""
    创建Python虚拟环境，隔离项目依赖
    """</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"正在创建虚拟环境于: <span class="hljs-subst">{path}</span>..."</span>)
    <span class="hljs-keyword">try</span>:
        venv.create(path, with_pip=<span class="hljs-literal">True</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 虚拟环境创建成功！"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"👉 激活方式:"</span>)
        <span class="hljs-keyword">if</span> sys.platform == <span class="hljs-string">"win32"</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   .\\<span class="hljs-subst">{path}</span>\\Scripts\\activate"</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   source <span class="hljs-subst">{path}</span>/bin/activate"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 创建失败: <span class="hljs-subst">{e}</span>"</span>)
 
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    create_virtual_env(<span class="hljs-string">"autoglm_env"</span>)
</code></pre>
<h3 data-id="heading-4">ABD</h3>
<p>这个的作用就是是电脑可以控制手机。</p>
<p>Windows用户，直接下载ABD工具压缩包，然后解压并加入系统环境变量即可。</p>
<blockquote>
<p>下载地址：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdl.google.com%2Fandroid%2Frepository%2Fplatform-tools-latest-windows.zip" target="_blank" title="https://dl.google.com/android/repository/platform-tools-latest-windows.zip" ref="nofollow noopener noreferrer">dl.google.com/android/rep…</a></p>
</blockquote>
<p>如何设置环境变量呢？</p>
<p>首先，找到电脑的**「高级系统设置」**。其次，点「<strong>环境变量</strong>」，找到「<strong>Path</strong>」变量，编辑Path变量，点「<strong>新建</strong>」创建一个新变量，把你的ABD工具压缩包地址添加进来就可以了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9d9796ad83564b5185c8844b2b8a8f05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=Fh%2BrALYvfJ%2FNW1vc4ezT9z4VZLQ%3D" alt="img" loading="lazy"/></p>
<p>之后，陆续点「<strong>确定</strong>」，保存更改，关闭页面。</p>
<h3 data-id="heading-5">安卓环境</h3>
<p>我们的手机需要打开开发者模式，手机才可以接受电脑的连接。</p>
<p>让手机允许被电脑控制：</p>
<p>1.进入手机“设置” -&gt; “关于手机”。</p>
<p>2.连续狂点“版本号”7次，直到提示“您已处于开发者模式”。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be9851b36ae34194929415a11621f3c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=VFjhXMhcB3y7JRXyMv0mDazZbao%3D" alt="img" loading="lazy"/></p>
<p>3.返回设置主页，找到“开发者选项”，打开“USB调试”。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91cf3b7845ca4be88c148bdf050f116a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=gs7OKoChR3JyfvDnwiCE4rjTpr8%3D" alt="img" loading="lazy"/></p>
<p>4.用数据线连接手机和电脑，手机端弹窗一律点“允许”。</p>
<p>调试检查脚本： 为了确保ADB配置成功，你可以保存以下代码为 <code>check_adb.py</code> 并运行，它会自动检测ADB是否可用并列出连接设备。</p>
<pre><code class="hljs language-Python" lang="Python"><span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> sys
 
<span class="hljs-keyword">def</span> <span class="hljs-title function_">check_adb</span>():
    <span class="hljs-string">"""
    检查ADB环境是否配置正确，并列出已连接设备
    """</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 尝试获取ADB版本</span>
        version_result = subprocess.run([<span class="hljs-string">'adb'</span>, <span class="hljs-string">'version'</span>], capture_output=<span class="hljs-literal">True</span>, text=<span class="hljs-literal">True</span>, encoding=<span class="hljs-string">'utf-8'</span>)
        <span class="hljs-keyword">if</span> version_result.returncode == <span class="hljs-number">0</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ ADB 环境检测通过"</span>)
            <span class="hljs-built_in">print</span>(version_result.stdout)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 未找到ADB命令，请检查环境变量配置"</span>)
            sys.exit(<span class="hljs-number">1</span>)
            
        <span class="hljs-comment"># 尝试获取连接设备列表</span>
        devices_result = subprocess.run([<span class="hljs-string">'adb'</span>, <span class="hljs-string">'devices'</span>], capture_output=<span class="hljs-literal">True</span>, text=<span class="hljs-literal">True</span>, encoding=<span class="hljs-string">'utf-8'</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"--- 当前已连接设备 ---"</span>)
        <span class="hljs-built_in">print</span>(devices_result.stdout)
        
        <span class="hljs-keyword">if</span> <span class="hljs-string">"device"</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> devices_result.stdout:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 警告：未检测到已授权的手机设备，请检查USB连接。"</span>)
            
    <span class="hljs-keyword">except</span> FileNotFoundError:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 错误：系统找不到ADB程序。"</span>)
 
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    check_adb()
</code></pre>
<h2 data-id="heading-6">⚡ 部署与实战：两种方式任选</h2>
<p>环境搞定后，我们分“懒人版”和“保姆版”两种方式来部署。如果你是老手，直接看懒人版；如果你是新手，建议仔细阅读保姆版。</p>
<h3 data-id="heading-7">系统架构原理解析</h3>
<p>在开始之前，我们先了解一下Open-AutoGLM是如何工作的。这有助于你后续排查问题。</p>
<p>它本质上是一个 Agent（智能体） 循环：</p>
<ol>
<li>感知：通过ADB截图，获取手机当前画面。</li>
<li>思考：将截图传给GLM-4大模型，告诉它“我想刷抖音”，让模型分析当前该点哪里。</li>
<li>行动：模型返回坐标（如：x=500, y=1000，点击），Python脚本通过ADB执行点击。</li>
<li>反馈：再次截图，确认操作是否成功。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ab6d58dc42e4c4c9159f25253208cfc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=vZyP6jkoYmMmWWj7%2FlBjOM2chhE%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-8">懒人版快速安装</h3>
<p>使用Claude Code到你创建项目的位置。（没有Claude Code的，可以网上搜索下载一个）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9473aa41666d4111b387a440608c2094~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=fvsPNnXbbSaBmeJYDgMY9vs0McU%3D" alt="img" loading="lazy"/></p>
<p>打开配置 GLM Coding Plan 后，可以看到使用的是glm-4.7。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f6963dc15704f0b9aa03e0e05cdb4cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=LvMdDGtEm1MlZX%2B6PbUgF0t7i%2Bs%3D" alt="img" loading="lazy"/></p>
<p>输入以下提示词，快速部署本项目。</p>
<pre><code class="hljs language-Plain" lang="Plain">访问文档，为我安装 AutoGLM
https://raw.githubusercontent.com/zai-org/Open-AutoGLM/refs/heads/main/README.md
我是windows电脑，我的python在：D:\Miniconda\python.exe
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0730aa4113c342f0b1a3dd275a21dadf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=XUILs7sjZrVcGZMd9QEAxFarAqI%3D" alt="img" loading="lazy"/></p>
<p>AI 会自动帮你处理依赖安装和配置，你只需要坐享其成。</p>
<h3 data-id="heading-9">保姆级教程安装</h3>
<h4 data-id="heading-10">1.下载到本地</h4>
<p>把项目 git 或者直接在源码下载压缩包，然后解压。</p>
<blockquote>
<p>开源地址：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzai-org%2FOpen-AutoGLM" target="_blank" title="https://github.com/zai-org/Open-AutoGLM" ref="nofollow noopener noreferrer">github.com/zai-org/Ope…</a></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d21e6f645aa45b687c91d7c2d9c1a94~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=6KwIOJpiwDgc33plVkfOllIB%2Fr4%3D" alt="img" loading="lazy"/></p>
<p>需要安装依赖</p>
<pre><code class="hljs language-Plain" lang="Plain">pip install -r requirements.txt 
pip install -e .
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf1b0523a69f498c8f2e9a1c86fe4fc5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=gZNzYYOdKXq1pwMLKH0uen95PO8%3D" alt="img" loading="lazy"/></p>
<h4 data-id="heading-11">2.手机和电脑连接</h4>
<p>接下来，用USB数据线将手机链接到电脑，然后在命令行里输入：</p>
<pre><code class="hljs language-Plain" lang="Plain">adb devices
</code></pre>
<p>如果连接成功，你会看到这样的提示。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c83cccacb5e140e1b00ce291b272d0f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=oMkJyX2vgcwK12GBZHsU9YVierI%3D" alt="img" loading="lazy"/></p>
<p>首次连接，手机上会出现这样一段提示，点「允许」即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/78548b92adc248eb9b4fc626d6771c1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=VkRVlSgBc4pdxshKMA6sENIwIXk%3D" alt="img" loading="lazy"/></p>
<p>如果出现下面的需要选择<code>USB网络共享</code>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1edb62556ed34bca8b334efc3478b5d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=LpeJXuvqGweS7DjAyjx67bAdvfY%3D" alt="img" loading="lazy"/></p>
<h4 data-id="heading-12">3.使用AI手机</h4>
<p>直接用cmd打开到文件夹，并且输入下面的指令</p>
<pre><code class="hljs language-Markdown" lang="Markdown">python main.py --base-url https://open.bigmodel.cn/api/paas/v4 --model "autoglm-phone" --apikey "your-bigmodel-api-key" "任务"
</code></pre>
<p>这里需要把</p>
<p>your-bigmodel-api-key 换为你直接得到的 Glm API</p>
<p>任务 换为你直接得到的 具体的任务</p>
<p>下面是我实际使用的示例，所有过程，<strong>0接管，全自动</strong>。。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b8993aacd1b4d19ace1c5b3db05fb04~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=gS%2FQX4jvXYMaf8SOiyC3%2BJGvkVY%3D" alt="img" loading="lazy"/></p>
<h2 data-id="heading-13">常见问题</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/547931ab76a148c48a5dd3d69b3e563d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768651825&amp;x-signature=5vs2g5iordXe0S1%2Bun%2F12JpfTZQ%3D" alt="img" loading="lazy"/></p>
<p>原因：目标设备上未安装 ADB Keyboard，导致系统检查的第3步失败。</p>
<p>解决方案：</p>
<p>下载安装到手机：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsenzhk%2FADBKeyBoard%2Fblob%2Fmaster%2FADBKeyboard.apk" target="_blank" title="https://github.com/senzhk/ADBKeyBoard/blob/master/ADBKeyboard.apk" ref="nofollow noopener noreferrer">github.com/senzhk/ADBK…</a></p>
<p>启用键盘：在手机上进入“设置” &gt; “系统” &gt; “语言和输入” &gt; “虚拟键盘”，找到并开启“ADB Keyboard”。建议同时将其切换为当前输入法。</p>
<h3 data-id="heading-14">技术栈对比：传统自动化 vs AI Agent</h3>
<p>为了让你更直观地理解 Open-AutoGLM 的优势，我们将其与传统的手机自动化工具（如按键精灵、Auto.js）进行对比。</p>








































<table><thead><tr><th>维度</th><th>传统自动化</th><th>Open-AutoGLM (AI Agent)</th></tr></thead><tbody><tr><td>核心逻辑</td><td>固定坐标、图像匹配</td><td>视觉理解、意图推理</td></tr><tr><td>适配性</td><td>差，UI变动需重写脚本</td><td>强，像人一样适应界面变化</td></tr><tr><td>开发门槛</td><td>中，需掌握编程/脚本</td><td>低，自然语言描述任务</td></tr><tr><td>场景扩展</td><td>局限，单一任务重复</td><td>广泛，支持模糊指令</td></tr><tr><td>运行成本</td><td>本地运行，成本为0</td><td>需调用API，产生Token费用</td></tr><tr><td>不确定性</td><td>低，一旦写死非常稳定</td><td>中，依赖大模型推理准确性</td></tr></tbody></table>
<p><strong>总结来说</strong>：传统工具适合<strong>高重复、确定性强</strong>的流水线工作；而 AI 手机适合<strong>非标准化、需要理解能力</strong>的复杂任务。</p>
<h2 data-id="heading-15">写在最后</h2>
<p>在深入体验并拆解了 Open-AutoGLM 项目的全套技术栈后，我想从客观的角度为大家做一个深度的总结。这不仅仅是一个工具，更是一扇通向未来的窗，但我们必须清醒地看到它的双面性。</p>
<p><strong>关于这套工具栈的缺点：</strong></p>
<p>首先，<strong>稳定性是目前最大的短板</strong>。由于它极度依赖云端大模型的实时推理，网络延迟和API的响应速度会直接影响操作手感。有时候你会发现，它明明识别到了按钮，但点击坐标却发生了偏移，这是因为模型在视觉预测上存在一定的概率误差。其次，<strong>硬件依赖较强</strong>，必须通过数据线连接ADB（虽然也有无线方案，但延迟更高），这意味着你的手机被“拴”在了电脑旁，无法实现真正的随身远程操控，这在移动场景下略显尴尬。再者，<strong>使用成本并非为零</strong>，虽然新用户有福利，但高频使用产生的API Token费用积少成多，对于仅仅是想用来挂机刷视频的用户来说，性价比可能不如传统的脚本。最后，<strong>隐私风险</strong>不容忽视，为了理解屏幕，手机截图需要上传至云端分析，如果你的屏幕上有敏感信息（如密码、聊天记录），这就存在潜在的数据泄露风险。</p>
<p><strong>关于这套工具栈的优点：</strong></p>
<p>然而，瑕不掩瑜，它的优点是颠覆性的。最核心的优势在于<strong>通用性与泛化能力</strong>。传统脚本换个APP分辨率就失效了，但 AutoGLM 靠的是“理解”而非死记硬背，它能像人类一样看懂界面布局，这意味着你不需要为每个APP写专门的代码，一套逻辑通吃大部分应用。其次，它极大地<strong>降低了自动化的门槛</strong>。你不需要懂编程，不需要学像素点判断，只需要说出“帮我把朋友圈最新的十条点赞”，剩下的交给AI。这种自然语言交互的方式，真正实现了“所想即所得”。此外，它具备<strong>上下文记忆与逻辑推理能力</strong>，不仅能执行动作，还能根据上一步的结果调整下一步策略，比如“如果弹出登录框则输入密码，否则跳过”，这种逻辑判断是传统脚本难以低成本实现的。</p>
<p><strong>总体来说：</strong></p>
<p>我认为，Open-AutoGLM 所代表的 AI Agent 技术栈，其<strong>优点远远大于缺点</strong>。目前的连接延迟和推理误差，随着模型算力的提升和边缘计算的发展，终将得到解决。而它所展现出的“理解意图并操作物理设备”的能力，正是通往通用人工智能（AGI）的关键一步。</p>
<p><strong>强烈推荐</strong>大家，特别是技术爱好者和效率极客，去尝试部署和使用这套工具。不要把它仅仅看作一个“刷课神器”，它是一个极佳的学习样本，能让你直观地感受到大模型是如何与操作系统交互的。在这个过程中，你不仅解放了双手，更升级了自己的思维。未来的 computing，一定是 AI Agent 的时代，现在入局，就是抢占未来。</p>
<p><strong>你打算用AI手机用来干什么呢，留下你的想法，然后勇敢的去实践。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端佬们！！AI大势已来，未来的上限取决你的独特气质！恭请批阅！！]]></title>    <link>https://juejin.cn/post/7593337928307621914</link>    <guid>https://juejin.cn/post/7593337928307621914</guid>    <pubDate>2026-01-10T12:23:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593337928307621914" data-draft-id="7592088192515637291" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端佬们！！AI大势已来，未来的上限取决你的独特气质！恭请批阅！！"/> <meta itemprop="keywords" content="前端,AI编程,程序员"/> <meta itemprop="datePublished" content="2026-01-10T12:23:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大怪v"/> <meta itemprop="url" content="https://juejin.cn/user/4391901700043284"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端佬们！！AI大势已来，未来的上限取决你的独特气质！恭请批阅！！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4391901700043284/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大怪v
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T12:23:34.000Z" title="Sat Jan 10 2026 12:23:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>前言</strong></p>
<p>写这篇文章，纯粹是AI热潮给炸出来的。本来想继续更我的虚拟世界专栏，但看了一眼沸点，好家伙，大家都在聊DeepSeek、ChatGPT，感觉我不说两句显得我很不合群。</p>
<p>还有另外一个原因，就是身边的很多程序员，都在焦虑。</p>
<p>那么，程序员真的会被替代吗？兄弟们，别急别急！</p>
<p>我直接给出我自己的观点:如果还是之前那种记俩API、写两功能的程序员，我相信很快会替代。但是那种会整活、会整合，直接面向问题解决的程序员，不会的！！！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3462e07141674bf9b09111e8d1a67034~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5oCqdg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652614&amp;x-signature=S%2BQAL9Jcj4%2FuwE7lxk%2F39ByqK7Q%3D" alt="O9.gif" loading="lazy"/></p>
<p>对比以前还要苦哈哈地背API，现在AI把门槛直接铲平了。这哪里是危机？这分明是从“螺丝钉”进化成“架构师”的最佳版本！</p>
<p>我的核心观点：<strong>AI对于之前的经验总结、归纳非常牛牪犇！！但是对于复杂问题、现实的敏感度以及所谓创新，他们还直接不能！！</strong></p>
<p>来，上理由！</p>
<h2 data-id="heading-0">0变1的门槛，被无限拉低了！</h2>
<p>以前你想做一个全栈应用，你得懂前端、后端、数据库、运维... 还没开始写代码，环境配置就先把你劝退了。</p>
<p>现在呢？</p>
<p>只要你的想法够骚，AI就是你的一万个分身。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5f249eb43df84dafb48ea246b31b3a31~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5oCqdg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652614&amp;x-signature=fa4eWoNi12WOQEaSbnQdAXjWO7E%3D" alt="骄傲.gif" loading="lazy"/></p>
<p>我有一个专栏，<strong>手搓虚拟世界</strong>。</p>
<p>在没有 AI 的时候，你想从 0 到 1 做一个产品，你要懂后端、懂数据库、懂运维，甚至还得懂点 UI 设计。这每一项，都是一座大山。很多很棒的 idea，就死在了“我不会写后端接口”或者“这 UI 丑得我没眼看”上。</p>
<p>现在呢？</p>
<p>AI 就是你的那个全能外包团队。你不会写 SQL？问它。你不会画 icon？让它画。 以前我们为了画一个完美的圆，可能要算半天 Math.PI，现在你只需要告诉 AI：“给我整一个圆，要五彩斑斓的那种。”</p>
<p>0 变 1 的过程，不再是技术的堆砌，而是你“脑洞”的直接具象化。 只要你有想法，技术实现的壁垒正在被 AI 暴力拆除。</p>
<h2 data-id="heading-1">这是拼气质的时代</h2>
<p>很多人说 AI 出来的代码没有灵魂，是缝合怪。 我说：别急别急！</p>
<p>当所有人都能一键生成标准化代码的时候，什么东西最值钱？ 是个性。是那种“独属前端佬气质”的创新。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef732539608a4748b59dded9bb389471~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5oCqdg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652614&amp;x-signature=%2Brs7Yg721x33a0Zc5BSOQLUGYp8%3D" alt="0.gif" loading="lazy"/></p>
<p>就像当年的 Flash，工具大家都有，但只有少数人能做出《小小火柴人》。AI 时代同理，它能帮你生成 90% 的通用代码，但剩下那 10% 的、决定产品气质的、让人眼前一亮的 “手搓” 部分，才是你真正的价值所在。</p>
<p>未来的牛人，不是谁 API 背得熟，而是谁能用 AI 这个超级引擎，组合出别人没见过的玩法。这不就是我们最擅长的吗？不依赖第三方库（因为 AI 可能会瞎引用），纯靠逻辑和创意，去构建一个新的虚拟世界。</p>
<h2 data-id="heading-2">能做什么，取决于你能想到什么</h2>
<p>以前想整一个事情，大致如下流程：想法=&gt;需求=&gt;原型=&gt;UI=&gt;交互=&gt;编写代码</p>
<p>完全靠人海战术。 现在？一个拿着 AI 的工程师（或者说“全栈工程师”），战斗力可能抵得上以前的一个公司。</p>
<p>这意味着什么？意味着个人创新的回报率被无限放大了。你不需要在一个项目中，当一颗在大机器里运转的螺丝钉，你有机会成为那个设计机器的人。</p>
<p>假如未来硬件再大升级（就像我之前说的智能眼镜、脑机接口），结合 AI 的生产力，一个人手搓一个“元宇宙”雏形，可能真的不再是梦。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee69124d760d45faa2b4fc975413ae3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5oCqdg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768652614&amp;x-signature=nLe9gy2eG8sae5DmY8wFpfpH4Mw%3D" alt="93d794510fb30f248be3f2baca95d143ac4b03e8.gif" loading="lazy"/></p>
<p>AI 不会淘汰有想法的人，它只会淘汰那些只会 copy-paste 的“代码搬运工”。</p>
<p>与其在焦虑中等待被替代，不如现在就头脑热一把，利用这个时代的红利，去“手搓”一点属于你自己的、独一无二的东西。</p>
<p>毕竟，只有当现有的规则已经装不下你的野心时，打破规则才更有乐趣。</p>
<p>前端佬们，别怂，干！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别“手搓”场景：智元用LLM重构具身智能的“练功房”]]></title>    <link>https://juejin.cn/post/7593338828217581583</link>    <guid>https://juejin.cn/post/7593338828217581583</guid>    <pubDate>2026-01-10T12:41:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593338828217581583" data-draft-id="7593262196844314676" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别“手搓”场景：智元用LLM重构具身智能的“练功房”"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2026-01-10T12:41:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="墨风如雪"/> <meta itemprop="url" content="https://juejin.cn/user/4064249017803927"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别“手搓”场景：智元用LLM重构具身智能的“练功房”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4064249017803927/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    墨风如雪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T12:41:14.000Z" title="Sat Jan 10 2026 12:41:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>CES 2026 刚刚在拉斯维加斯落下帷幕，虽然展台上那些跳舞、后空翻的机器人依旧吸睛，但对于咱们这些真正在搞具身智能开发的“炼丹师”来说，真正的硬菜其实藏在代码和数据里。</p>
<p>智元机器人（Agibot）这次发布了一个非常有意思的东西——Genie Sim 3.0。如果不仔细看，你可能觉得这只是又一个仿真软件，但关键在于它的前缀：这是全球首个由大语言模型（LLM）驱动的开源机器人仿真平台。</p>
<p>说得直白点，以前我们在仿真环境里训练机器人，最痛苦的不是写算法，而是搭场景。为了让机器人学会收拾桌子，你得在软件里一个个摆放杯子、盘子，还得调整光照、摩擦力。这简直是在“手搓”世界，效率低到让人头秃。</p>
<p>Genie Sim 3.0 解决的就是这个问题，它把那种费时费力的“手搓”变成了一句话的事儿。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-10_20.32.56-1024x348.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-10_20.32.56-1024x348.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c8ec36f8150a4e219b02b835ce02e534~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768653674&amp;x-signature=Pkaz6Mrri5tHHBKzWVkL3Z2l4Co%3D" alt="iShot_2026-01-10_20.32.56" loading="lazy"/></a></p>
<p><strong>当上帝模式变成了“聊天窗口”</strong></p>
<p>这个平台最核心的突破，在于它听得懂人话。基于 NVIDIA Isaac Sim 构建的底座上，智元接入了 LLM。现在的玩法变成了：你在对话框里输入“生成一个由于昨晚聚会而杯盘狼藉的餐桌场景，要有剩菜和倒下的酒杯”，几分钟后，几千甚至上万个符合描述但细节各异的 3D 场景就生成好了。</p>
<p>这个“万级场景生成分钟级完成”的参数，对于需要海量数据喂养的具身模型来说，不仅仅是效率提升，简直就是降维打击。它意味着你可以通过自然语言，快速构建出各种极端案例（Corner Case），专门针对机器人的弱项进行特训。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-10_20.33.06-1024x555.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-10_20.33.06-1024x555.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c052be3630dd49d6b10e06cb48c6c6ce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768653674&amp;x-signature=16oK0DTJEaKbYFo7NZeypEH66Iw%3D" alt="iShot_2026-01-10_20.33.06" loading="lazy"/></a></p>
<p><strong>拒绝“虚假”的精细度</strong></p>
<p>仿真训练最大的坑是“Sim-to-Real Gap”（虚实迁移鸿沟）。在模拟器里机器人是个神枪手，放到真机上连瓶水都抓不稳，原因通常是物理引擎不准或者视觉渲染太假。</p>
<p>Genie Sim 3.0 居然敢宣称虚实差异小于 10%，这底气来自于它的“数字孪生级”复刻能力。它不仅仅是画得像，而是物理属性上的像。比如你想在这个虚拟世界里加一把现实中的椅子，不需要复杂的建模，拿着手机对着椅子拍一段 60 秒的环绕视频，算法就能生成带精确网格和纹理的仿真模型。</p>
<p>这种把现实物体“瞬间传送”进虚拟世界的能力，对于像超市上货、物流分拣这种物品极其杂乱的场景来说，实用性极强。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-10_20.33.13-1024x595.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-10_20.33.13-1024x595.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b86db1befce545939a7996d36a89aace~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768653674&amp;x-signature=D7upHDZD6oWEgpvzrTv1NS0d9wE%3D" alt="iShot_2026-01-10_20.33.13" loading="lazy"/></a></p>
<p><strong>开源才是最大的诚意</strong></p>
<p>如果仅仅是功能强，那它充其量是一个昂贵的商业软件。但智元这次的选择很聪明：全开源。</p>
<p>他们不仅开源了核心代码，还把那一万多小时的真实机器人作业仿真数据集给放出来了。这其中包括了 RGB-D 视频、双目视觉数据、关节状态等。据说基于这套数据训练出来的模型，即便没有见过真实世界，直接部署到真机上也能干活（零样本迁移）。</p>
<p>对于很多缺乏资金购买大量高端机器人、或者没场地搭建复杂测试环境的高校和实验室来说，这套数据集和评估体系（覆盖了 10 万+ 场景）简直就是“具身智能界的 ImageNet”。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2026%2F01%2FiShot_2026-01-10_20.33.22.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2026/01/iShot_2026-01-10_20.33.22.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/153db33e220b42ae91bb197e9f9f6f0f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768653674&amp;x-signature=LluAkWFP5Vlb5%2BkzcY9Z8L8w%2Bhs%3D" alt="iShot_2026-01-10_20.33.22" loading="lazy"/></a></p>
<p><strong>写在最后</strong></p>
<p>Genie Sim 3.0 的出现，某种意义上标志着机器人研发范式的转变。我们正在从“拼硬件、拼手速”的时代，进入“拼算力、拼数据质量”的时代。</p>
<p>当搭建训练场的成本被 LLM 压缩到几乎为零时，开发者终于可以把精力集中在真正重要的事情上——如何让机器人那颗大脑变得更聪明。智元这次在 CES 上不仅秀了肌肉，更重要的是，它给整个行业递了一把好用的铲子。</p>
<p><strong>如果你也对最新的AI信息感兴趣或者有疑问 都可以加入我的大家庭 第一时间分享最新AI资讯、工具、教程、文档 欢迎你的加入！！！😉😉😉</strong></p>
<p>公众号：墨风如雪小站</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我在企业落地AI这一年，全流程案例拆解，企业落地AI必看！]]></title>    <link>https://juejin.cn/post/7593311347291750427</link>    <guid>https://juejin.cn/post/7593311347291750427</guid>    <pubDate>2026-01-10T11:15:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593311347291750427" data-draft-id="7593261984190300210" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我在企业落地AI这一年，全流程案例拆解，企业落地AI必看！"/> <meta itemprop="keywords" content="人工智能,AI编程"/> <meta itemprop="datePublished" content="2026-01-10T11:15:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="石云升"/> <meta itemprop="url" content="https://juejin.cn/user/642537280772456"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我在企业落地AI这一年，全流程案例拆解，企业落地AI必看！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/642537280772456/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    石云升
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T11:15:46.000Z" title="Sat Jan 10 2026 11:15:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto;border:3px solid rgba(62,175,124,.2)}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-weight:700;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:6px;border:2px solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c}.markdown-body a:active,.markdown-body a:hover{border-bottom:1.5px solid #3eaf7c}.markdown-body a:before{content:"⇲"}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(62,175,124,.2)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:.5rem solid;border-color:#42b983;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none}.markdown-body ul li:before{content:"•";margin-right:4px;color:#3eaf7c}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>2023年躬身入局，从工具使用者转型为落地推动者。2024-2025年，我连续在两家不同行业企业主导AI落地。过去两年，我最深的感悟是：<strong>AI落地的难点不在技术，而在业务逻辑的解构。</strong> 站在2025年末回看，我总结了一套跨部门的AI落地实战路径。今天不讲大道理，只拆解真实案例，希望能给正在深耕AI增效的朋友一点启发。</p>
<h3 data-id="heading-0">从高价值业务切入</h3>
<h4 data-id="heading-1">电商AI客服 - 售前为主</h4>
<p>刚入职时，我就想好了落地路径。公司主营电商，在拼多多、京东、淘宝都有店铺。虽然平台自带机器人，但往往有点笨，更像能力较弱的小模型，远不如顶尖大模型智能，当然，国内平台估计也不让用国外的模型。所以当时想着还是自建。</p>
<p>自建的好处很明显：<strong>成本低、</strong> <strong>灵活、可定制</strong>。比如我们可以跟自己的内部业务系统进行打通。比如硬件的话，可以让AI客服根据硬件的实时数据进行回复；还有一些比如预约某个时间点上门维修等等。不过自建有个点要注意，各个电商平台没有开放API，只能通过其他方式进行实现。具体做的细节就不讲了，这里有几个坑要注意</p>
<ol>
<li>必须考虑大数据量并发的情况。</li>
<li>做好模型响应失败的容灾预案。</li>
<li>不同平台有违禁词限制，需通过关键词过滤系统进行二次替换。</li>
<li>建议先在夜间上线（本就是人工空白区，属于增量价值），验证后再推广。</li>
<li>AI解决不了的自动转人工，前期宁可保守一点，给知识库优化留出时间。</li>
</ol>
<p>我们最先落地的就是电商AI客服，当然落地之后效果怎样呢？这其实也是AI负责人在落地之前就要考虑到的情况。就是一个工具落地后，实际产生了什么价值，你得有数据支撑，不能光说，AI客服+人工肯定比纯人工要更高效，能接待更多的客户咨询。这是价值，但没有量化。作为AI负责人，必须用数据说话：接待了多少咨询、回复了多少次、卖了多少商品，带来了多少转化等等。数据会给你真实的反馈，指引你前进的方向。下面是几家不同行业店铺AI客服（晚上）与人工（白天）转化数据。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0287c67784b14fab993324bea9fd9b75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5LqR5Y2H:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768648546&amp;x-signature=1Mt0dgAh0NtVOTRV89tH0kluA%2Fw%3D" alt="图片" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h4 data-id="heading-2">企业微信AI客服 -售后为主</h4>
<p>对我们公司而言，电商AI客服只是售前。我们售后又是统一的另一套，用的企业微信客服。因为我们的用户主要是在微信体系，所以用企微更方便，并且对于我公司来说，企业微信的售后咨询量更大。本来一开始是准备找成熟产品用的，但基本都是按坐席收费，且需要改变客服的原有操作习惯，成本高、上手难。所以还是决定自己做。</p>
<p>市面上有很多一键接入微信客服的工具，像元宝，coze。但那种就是纯平台接入，看起来好像很好用，但不灵活。而且也无法配合人工进行操作。我们企业需求更希望保持原有客服的操作习惯所以还是得自建。</p>
<p>以前做这样一套系统，至少得一个小团队做个把月时间，但在AI时代，一个人也能把活干得又快又好。</p>
<h3 data-id="heading-3">部门提效</h3>
<p>企业里有很多部门，每个部门其实都有一些低效的工作，以前都是靠人力去做的。现在有了AI后，有些工作可以用程序自动化，有些工作流通过AI重构后，有些工作就不需要人再做了。当然，这里面很多都是企业定制化需求，我这里只是提供一些案例思路给大家参考。</p>
<h4 data-id="heading-4">研发部</h4>
<p>程序员使用 Vibe Coding（氛围编程）就不用说了，就现在，不会用AI编码的人出来找工作就很难了。但实际上很多程序员还没用起来，或者用得很浅。这块我也不知道怎么说，反正没有深入使用的。建议先自我分析下，到底是什么原因没用起来。</p>
<p>产品经理很多都是并入研发部部门的，如果产品经理不使用AI，那以后就业只比不会AI的程序员还要难。我认为产品经理是AI时代最受益的岗位之一。产品调研，产品需求整理可以借助AI提效；产品原型，可以借助AI直接生成；因为产品经理懂业务，可以借助AI编写各种业务功能的工具，实现价值最大化。</p>
<p>如果公司里要选择谁来深入学习AI，负责AI落地，<strong>产品经理是最适合的角色。</strong></p>
<h4 data-id="heading-5">财务部</h4>
<p>财务同事跟钱打交道。经常要对账，核对订单，还有整理发票。</p>
<p>对账工具：根据传入的表，自动核算表单金额，去掉重复订单，去掉状态变更的订单。支持一键导出有效订单数据，简化操作步骤，兼容异常数据，支持后期更新。原来这个工作需要运营做一遍，然后财务再核对一遍。现在两个部门都不需要做了。</p>
<p>快递签收工具：批量查询快递订单的轨迹，并获取物流信息里最后签收人信息。</p>
<p>发票整理：自动整理发票，根据不同主体，进销项，普票专票，然后给发票命名。</p>
<p>这些需求虽然小，但经常需要人工每天或者每周消耗几个小时时间来整理，既低效又容易出错，所以用AI做一些小工具就很适合。</p>
<h4 data-id="heading-6">客服部</h4>
<p>除了跟用户沟通的客服外，客服部还负责退货相关事宜。比如，要把微信群里的退单信息整理到Excel表上。</p>
<p>需求：自动统计微信群里发送的拦截，退回的快递单号（有个相对复杂的规则，支持多个快递公司），并汇总到Excel表里。支持撤回，支持导出拦截成功和失败的数据等等。在有了这个工具之前，每天客服每天都有1-2个人做一下午的统计工作，低效且容易出错。</p>
<p>还有一个企业微信侧边栏应用，也就是在聊天对话框右侧应用栏里显示当前用户和设备的资料。比如之前每次还要打开管理后台去查，方便了不止一点。整体效率起码提高了30%。这种需求以前也是需要一个小团队做的，但现在的AI真的可以干的又快又好。</p>
<h4 data-id="heading-7">运营部</h4>
<p>电商运营部，能做的事情很多。批量出商品图这个去年就说过了，之前是通过comfyui做的，相对会复杂一点，对电脑要求也高。现在AI生图模型能力强了，可以直接口语化ps了，而且像nano banana pro已经能非常好的输出中文字体了。最近可能由于算力限制，出图效果有点降智。不过相信很快就好的。成本的话还有点高，官方1块钱一张图，国内中转2-3毛一张图。</p>
<p>除了电商这块，还有新媒体运营。这块之前很多公司都做不好，毕竟内容创作对人的要求非常高。但AI出来后，创作门槛降低到极致了。好处是，创作变简单了。坏处是，想要做出成绩更难了。针对这个，我做了个AI自动生成内容，自动发布到各个平台的工具。但我认为，想要把内容做好，关键还是在用的人身上。</p>
<h4 data-id="heading-8">某部门负责人</h4>
<p>之前某部门负责人有一个很费劲的工作，就是调研竞品商品价格，在结合我们上游渠道价格反向倒推自己的定价。从商品价格获取，到换算，到最后更改我们商品价格。之前都是纯人工Excel表管理。不仅繁琐，而且非常容易出错，尤其是多个上游渠道，我们还需要平衡成本。这个事情就不应该人来做。最简单的方案就是，扔给程序一个或多个商品链接，手动录入一些必要的业务数据，然后程序自动输出产品定价并更新到线上系统。</p>
<p>要遵循最简单的设计原则，完成一件任务，<strong>如果一个按钮能解决，就不要让人操作两次。</strong></p>
<h4 data-id="heading-9">人事行政部</h4>
<p>行政主要负责公司跟事相关的事情，杂事特别多。比如入职资料整理。这块之前因为公司规模不大，都是人工整理，把入职人员的信息手动录入到Excel表里。每次花点时间整理。但如果入职的人员很多的话，人工干起来就觉得很浪费时间。你看，只要有做这事浪费时间的感觉，就应该考虑用新技术来重构。</p>
<p>填写入职资料（表单） —— 自动生成Word文档 —— 打印签名 —— 把Word文件以及社保，公积金卡都一起上传到AI工具做的工具，工具会自动识别所有信息录入到Excel表。</p>
<p>HR负责公司跟人相关的事情，也是非常多非常杂的。招人是一门技术活，之前HR做面试候选人的管理都是人工Excel表，可以用但中间很多费脑的事情。这个候选人简历匹配度怎样，要针对性问哪些问题，面试的结果如何评价等等。其实现在借助飞书多维表格，面试过程中产生的所有数据都能够更好的展示。说实话要是飞书能开放AI模型的接口，让我们用自己接入的模型，那使用效果会更好。</p>
<p>还有一个要分享的就是公司百事通智能体，上面讲了AI制作应用工具 + 多维表格。现在企业落地还有个很好用的工具，那就是各种智能体（agent)。比如，新员工入职总会有部门负责人带着熟悉公司业务，包括介绍公司的各项规章制度。但一般也就讲个大概，具体细节还是看公司里的员工手册。而具体业务上的事情，一般是集体培训或者老师带徒弟这种。但不管哪种，总有些事情是在遇到了才想到了要询问老员工。如果询问的多了，时间成本耗不起呀。所以我就做了个公司百事通智能体。所有跟公司相关的，包括规章制度，岗位职责，产品介绍，售前政策，售后政策，各平台操作指南等等都在这个智能体里。</p>
<h3 data-id="heading-10">智能体</h3>
<p>我把智能体分几类，从简单到复杂。</p>
<p><strong>第一类：提示词智能体（Prompt）。</strong>  通过内置特定人设提示词实现，如专门给孩子批改作文的语文老师智能体。一般只要你想要约束AI输出的内容，就可以针对性设计提示词做一个智能体。</p>
<p><strong>第二类：提示词 + 知识库（RAG）。</strong>  难点在于如何将非结构化文本转化为AI可精准解析的知识。它更垂直，能根据企业私有知识库回答问题，适用于员工手册、产品说明书或法律法规检索。</p>
<p><strong>第三类：提示词 + 知识库 + MCP（Tools）。</strong>  引入MCP协议调用外部工具（如查天气、订机票）。此时AI开始从生成内容转向执行动作，拥有的工具越多，能力边界越广。</p>
<p><strong>第四类：特定工作流智能体（Workflow）。</strong>  这个就厉害了，只要你不嫌麻烦，什么场景都能做。前面介绍的AI客服就是这样搭建的。</p>
<p><strong>第五类：多智能体协同（Multi-Agent）。</strong>  不是一个 AI 在战斗，而是一群 AI齐心协力帮你做事。比如，我用的一个开源项目微舆，多Agent舆情分析助手。当你需要深入调研某件事情的时候，可以用它。一次任务，会调用几百次AI，最后输出一个很不错的调研报告。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1994763bbfe45c189d791cf4ee824dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5LqR5Y2H:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768648546&amp;x-signature=e%2BPGhmu5sFhlfeD%2F0M5Oz2OEZdQ%3D" alt="图片" loading="lazy"/>​</p>
<p>以上是一些案例上的思路分享。当然，上面的分享只是AI企业落地的第一步，后面还需要做组织上的进化，企业AI落地并不是一个人或者一个部门的事。它是整个组织的事。</p>
<p>我叫石云升，同名公众号AI博主，在公司负责AI企业落地，关注我，后续分享更多AI落地经验。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[NestJS 🧑‍🍳 厨子必修课（九）：API 文档 Swagger]]></title>    <link>https://juejin.cn/post/7593232758127542278</link>    <guid>https://juejin.cn/post/7593232758127542278</guid>    <pubDate>2026-01-10T11:25:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593232758127542278" data-draft-id="7593215107406823460" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="NestJS 🧑‍🍳 厨子必修课（九）：API 文档 Swagger"/> <meta itemprop="keywords" content="前端,后端,NestJS"/> <meta itemprop="datePublished" content="2026-01-10T11:25:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="菠萝的蜜"/> <meta itemprop="url" content="https://juejin.cn/user/2154698521972423"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            NestJS 🧑‍🍳 厨子必修课（九）：API 文档 Swagger
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2154698521972423/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    菠萝的蜜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T11:25:07.000Z" title="Sat Jan 10 2026 11:25:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 前言</h2>
<p>后端 API 开发完成后，需要给前端一份接口文档，Swagger 能够帮助我们自动生成接口文档，这将会用到 <code>@nestjs/swagger</code> 和 <code>swagger-ui-express</code>。</p>
<p>欢迎加入<a href="https://juejin.cn/user/2154698521972423/pins" target="_blank" title="https://juejin.cn/user/2154698521972423/pins">技术交流群</a>。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dd5e4b8be907402d9d882517ff6a0e0c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=1MezTLjw6cgEyLRSiZU84XYgOD0%3D" alt="image.png" loading="lazy"/></p>
<ol>
<li><a href="https://juejin.cn/post/7407260232664186930" target="_blank" title="https://juejin.cn/post/7407260232664186930">NestJS 🧑‍🍳  厨子必修课（一）：后端的本质</a></li>
<li><a href="https://juejin.cn/post/7408021285768445961" target="_blank" title="https://juejin.cn/post/7408021285768445961">NestJS 🧑‍🍳 厨子必修课（二）：项目创建</a></li>
<li><a href="https://juejin.cn/post/7408778862283096102" target="_blank" title="https://juejin.cn/post/7408778862283096102">NestJS 🧑‍🍳 厨子必修课（三）：控制器</a></li>
<li><a href="https://juejin.cn/post/7416235834938212403" target="_blank" title="https://juejin.cn/post/7416235834938212403">NestJS 🧑‍🍳 厨子必修课（四）：服务类</a></li>
<li><a href="https://juejin.cn/post/7416908856868110374" target="_blank" title="https://juejin.cn/post/7416908856868110374">NestJS 🧑‍🍳 厨子必修课（五）：Prisma 集成（上）</a></li>
<li><a href="https://juejin.cn/post/7418460243502792731" target="_blank" title="https://juejin.cn/post/7418460243502792731">NestJS 🧑‍🍳 厨子必修课（六）：Prisma 集成（下）</a></li>
<li><a href="https://juejin.cn/post/7419887372463554601" target="_blank" title="https://juejin.cn/post/7419887372463554601">NestJS 🧑‍🍳 厨子必修课（七）：管道</a></li>
<li><a href="https://juejin.cn/post/7420272008146239514" target="_blank" title="https://juejin.cn/post/7420272008146239514">NestJS 🧑‍🍳 厨子必修课（八）：异常过滤器</a></li>
</ol>
<h2 data-id="heading-1">2. 安装与初始化</h2>
<h3 data-id="heading-2">2.1 安装</h3>
<pre><code class="hljs language-bash" lang="bash">npm install @nestjs/swagger swagger-ui-express
</code></pre>
<h3 data-id="heading-3">2.2 在 main.ts 中配置 Swagger</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DocumentBuilder</span>, <span class="hljs-title class_">SwaggerModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/swagger'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);
  
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// 配置 Swagger</span>
  <span class="hljs-keyword">const</span> config = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DocumentBuilder</span>()
    .<span class="hljs-title function_">setTitle</span>(<span class="hljs-string">'NestJS API for Cook'</span>)
    .<span class="hljs-title function_">setDescription</span>(<span class="hljs-string">'The NestJS API description for Cook'</span>)
    .<span class="hljs-title function_">setVersion</span>(<span class="hljs-string">'0.1'</span>)
    .<span class="hljs-title function_">build</span>();
  <span class="hljs-comment">// 创建 API 文档</span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">document</span> = <span class="hljs-title class_">SwaggerModule</span>.<span class="hljs-title function_">createDocument</span>(app, config);
  <span class="hljs-comment">// 启动 Swagger UI</span>
  <span class="hljs-title class_">SwaggerModule</span>.<span class="hljs-title function_">setup</span>(<span class="hljs-string">'api'</span>, app, <span class="hljs-variable language_">document</span>);
  
  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
}
<span class="hljs-title function_">bootstrap</span>();
</code></pre>
<p>接口文档的标题为：NestJS API for Cook，描述为：The NestJS API description for Cook，版本为 0.1，被设置在了 /api 路径下。</p>
<h3 data-id="heading-4">2.3 查看文档</h3>
<p>进入 <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fapi%23%2F" target="_blank" title="http://localhost:3000/api#/" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fapi" target="_blank" title="http://localhost:3000/api" ref="nofollow noopener noreferrer">http://localhost:3000/api</a> 就能在线查看接口文档：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5c0196a329e4b11bcf953a6c15c6cf5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=hmr89ZYigoKuc9qH23KfM7c70PU%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到之前写的接口都在上面。以 users 模块的接口为例，接口具体由以下内容构成：</p>
<ul>
<li>Parameters 👉 参数，包括 path 参数和 query 参数两类。</li>
<li>Request body 👉 请求 body 数据，包括例子展示 example values 和数据类型 schema。（一般存在于 POST 和 PATCH 请求中）</li>
<li>Responses 👉 响应，包括状态码 code 和描述 description。</li>
</ul>
<h4 data-id="heading-5">POST /users</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a29a4d950f64f91815ffd5a4aa1d2a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=BRpelMxcxAjzFCzqS4602c1fcdU%3D" alt="image.png" loading="lazy"/></p>
<p>不需要传参数，但需要传 body 数据。</p>
<h4 data-id="heading-6">GET /users</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/676fef5cd87f447d9e8013b6105cf449~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=Lsg5iopfWc3BcpmhFFgXubLIRCo%3D" alt="image.png" loading="lazy"/></p>
<p>需要传 <code>pageNum</code> 和 <code>pageSize</code>。</p>
<h4 data-id="heading-7">GET /users/search</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f8646127d7f47c8971903cf21705d8b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=mN21CZ8y7Mhkg5wiLhAhklw4eLU%3D" alt="image.png" loading="lazy"/></p>
<p>需要传 <code>query</code>。</p>
<h4 data-id="heading-8">GET /users/{id}</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9714b860e857467da886001278282828~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=7jhbpPT5RB35FfS3yWBK308VCvE%3D" alt="image.png" loading="lazy"/></p>
<p>这里需要传的 <code>id</code> 属于 path 参数，在代码中也是动态的。</p>
<h4 data-id="heading-9">PATCH /users/{id}</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfeefd8af6fd41f1b55c700351424bee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=v3rsrh8wjU3yiODAxbveXg8G7Ro%3D" alt="image.png" loading="lazy"/></p>
<p>需要传 <code>id</code> 以及修改的 <code>body</code> 数据。</p>
<h4 data-id="heading-10">DELETE /users/{id}</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ee540c0bf3348e1afd92511d634f91d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=qgNpX7evTB7y25O4o9v6wkIaYTc%3D" alt="image.png" loading="lazy"/></p>
<p>删除只需要传递 <code>id</code>。</p>
<h4 data-id="heading-11">PATCH /users/{id}/role</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/612e732874584440b6effd8445cc5efe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=T9G8nQez9w6DiEDke%2FEEbezJeKU%3D" alt="image.png" loading="lazy"/></p>
<p>修改指定用户的角色，要传递 <code>id</code> 以及 <code>body</code> 数据。</p>
<h3 data-id="heading-12">2.4 接口测试</h3>
<p>可以看到每一个接口的右侧都有一个 <strong>Try it out</strong> 按钮，点击可以对接口进行测试。</p>
<h2 data-id="heading-13">3. 基础<strong>注解</strong></h2>
<p>现在的文档还存在 2 个问题，第一是没有区分 API 版本；第二是所有的接口都在 default 分组下没有按照模块来划分。</p>
<p>首先给路由全局设置 api 版本前缀：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// main.ts</span>
app.<span class="hljs-title function_">setGlobalPrefix</span>(<span class="hljs-string">'api/v1'</span>);
</code></pre>
<p>再次打开 /api 查看，就设置上了前缀：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/05a0cc49b3c44a24bd2b7781286c1f97~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=Fx61IVuDKN068IYXiuNCHUITtkU%3D" alt="image.png" loading="lazy"/></p>
<p>⚠️ 注意：和设置管道、过滤器那些类似，当然也为单个控制器设置。</p>
<p><code>@nestjs/swagger</code> 包提供了一些装饰器用于对文档进行注解，下面以 users 为例。</p>
<h3 data-id="heading-14">3.1 <code>@ApiTags()</code></h3>
<p><code>@ApiTags()</code> 用于对控制器进行分组。</p>
<pre><code class="hljs language-diff" lang="diff">// users.controller.ts
@Controller('users')
<span class="hljs-addition">+ @ApiTags('用户管理')</span>
export class UsersController {
// ...
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6964275efd5b43bf9b4ed079f2d9f5a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=6xJyJ%2FnkudymfQJazw6uslfohDw%3D" alt="image.png" loading="lazy"/></p>
<p>有关 users 的路由被分在“用户管理”类别下。</p>
<h3 data-id="heading-15">3.2 <code>@ApiOperation()</code></h3>
<p><code>@ApiOperation()</code> 用于描述 API 的操作。</p>
<pre><code class="hljs language-diff" lang="diff">// users.controller.ts
@Post()
<span class="hljs-addition">+ @ApiOperation({ summary: '创建新用户' })</span>
create(
  @Body('name', UniqueUsernamePipe) name: string,
  @Body() createUserDto: CreateUserDto,
) {
  return this.usersService.create(createUserDto);
}
// ...
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/891a91ab017946d1bb7a939f385bbf54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=QJbfqnabruza8BeXLxioZbtRxsw%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-16">4. 高级注解</h2>
<p>另外，无论是请求体还是响应体的文档内容都缺少描述，示例也过于简单。DTO 可以帮助定义请求体或响应体的数据结构，并通过 <code>@ApiProperty()</code> 注解为每个字段添加描述，自动生成文档。</p>
<h3 data-id="heading-17">4.1 <code>@ApiProperty()</code> - DTO（Data Transfer Object）传输层</h3>
<p>DTO 用于定义数据传输的结构，通常在控制器中用于<strong>请求和响应的数据验证</strong>，会结合验证库 <code>class-validator</code> 来执行字段验证。</p>
<p><code>@ApiProperty()</code> 除了为 DTO 中的字段添加描述 <code>description</code> ，还可以添加例子 <code>example</code>，这样就使得每个 API 的输入输出更加清晰。</p>
<p>users 模块的 DTO 有三个：</p>
<ul>
<li>create-user.dto.ts 创建用户</li>
<li>update-user.dto.ts 更新用户</li>
<li>update-user-role.dto.ts 更新用户角色</li>
</ul>
<p>例如，创建用户的请求可以有一个 CreateUserDto 类，包含字段 name、email 等：</p>
<h4 data-id="heading-18">create-user.dto.ts</h4>
<pre><code class="hljs language-diff" lang="diff">import { UserRole } from '@prisma/client';
<span class="hljs-addition">+ import { ApiProperty } from '@nestjs/swagger';</span>
import {
  IsNotEmpty,
  MinLength,
  IsEmail,
  IsString,
  IsEnum,
  IsOptional,
} from 'class-validator';

export class CreateUserDto {
<span class="hljs-addition">+  @ApiProperty({ description: '用户名', example: 'zhangsan' })</span>
  @IsString()
  @IsNotEmpty()
  @MinLength(3)
  name: string;

<span class="hljs-addition">+  @ApiProperty({ description: '用户邮箱', example: 'zhangsan@example.com' })</span>
  @IsEmail()
  @IsNotEmpty()
  email: string;

<span class="hljs-addition">+  @ApiProperty({ description: '用户密码', example: 'password123' })</span>
  @IsString()
  @IsNotEmpty()
  @MinLength(8)
  password: string;

  @IsEnum(UserRole, { message: 'Role must be a valid user role' })
  @IsOptional()
  role: UserRole;
}
</code></pre>
<p>创建一个用户需要 <code>name</code>、<code>email</code>、<code>password</code>、<code>role</code>，最后一个 <code>role</code> 不是必填项，不必加上 <code>@ApiProperty</code> 装饰器。</p>
<p>在请求 body 数据的 <strong>Schema</strong> 中可以看到 <code>description</code> 和 <code>example</code>：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91f237d4d4e84f31b0bfcd68a574b612~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=ZgtoWLRJYuy%2FW3jSDTMpe%2BrS3BU%3D" alt="image.png" loading="lazy"/></p>
<p><code>example</code> 同时也作为 <strong>Example Value</strong> 中的示例值：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58ddf1614ade4839964b5b89b2b4cc67~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=GI9IG5gJkfMl3kmWbZVfr442nKM%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-19">update-user.dto.ts</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ApiProperty</span>, <span class="hljs-title class_">PartialType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/swagger'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CreateUserDto</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./create-user.dto'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateUserDto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PartialType</span>(<span class="hljs-title class_">CreateUserDto</span>) {
  <span class="hljs-meta">@ApiProperty</span>({ <span class="hljs-attr">description</span>: <span class="hljs-string">'用户名'</span>, <span class="hljs-attr">example</span>: <span class="hljs-string">'lisi'</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">false</span> })
  name?: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@ApiProperty</span>({
    <span class="hljs-attr">description</span>: <span class="hljs-string">'用户邮箱'</span>,
    <span class="hljs-attr">example</span>: <span class="hljs-string">'lisi@example.com'</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">false</span>,
  })
  email?: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@ApiProperty</span>({
    <span class="hljs-attr">description</span>: <span class="hljs-string">'用户密码'</span>,
    <span class="hljs-attr">example</span>: <span class="hljs-string">'newpassword123'</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">false</span>,
  })
  password?: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e3988644e17a4c59aaf6ed3fe9bd4599~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=n5QI03uUg1Qykkss%2F%2FLyTPDhxmY%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-20">update-user-role.dto.ts</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ApiProperty</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/swagger'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserRole</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../enums/user-role.enum'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateUserRoleDto</span> {
  <span class="hljs-meta">@ApiProperty</span>({
    <span class="hljs-attr">description</span>: <span class="hljs-string">'用户角色'</span>,
    <span class="hljs-attr">example</span>: <span class="hljs-title class_">UserRole</span>.<span class="hljs-property">ADMIN</span>,
    <span class="hljs-attr">enum</span>: <span class="hljs-title class_">UserRole</span>,
  })
  <span class="hljs-attr">role</span>: <span class="hljs-title class_">UserRole</span>;
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9cd5df20bb64a33b083adf19cba7439~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=x6dZt9sFTBvFbWy9h1ES4llOoqo%3D" alt="image.png" loading="lazy"/></p>
<p><code>enum</code> 表示这个参数是一个枚举类型，具体值来自 <code>UserRole</code>：</p>
<pre><code class="hljs language-ini" lang="ini">// ../enums/user-role.enum.ts
export enum UserRole {
  <span class="hljs-attr">USER</span> = <span class="hljs-string">'USER'</span>,
  <span class="hljs-attr">ADMIN</span> = <span class="hljs-string">'ADMIN'</span>,
}
</code></pre>
<p>这与 schema.prisma 中定义的保持一致：</p>
<pre><code class="hljs language-schema" lang="schema">// ...

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  password  String
  role      UserRole @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  orders    Order[]
}

enum UserRole {
  USER
  ADMIN
}
</code></pre>
<h3 data-id="heading-21">4.2 <code>@ApiQuery()</code> - 查询参数</h3>
<p>对于创建和更新数据实体可以使用 <code>@ApiProperty()</code> 注解，而对于请求体的查询参数就要使用 <code>@ApiQuery()</code> 了。</p>
<pre><code class="hljs language-diff" lang="diff">@Get()
@ApiOperation({ summary: '获取所有用户' })
<span class="hljs-addition">+ @ApiQuery({ name: 'pageNum', description: '页码', required: false })</span>
<span class="hljs-addition">+ @ApiQuery({ name: 'pageSize', description: '每页条数', required: false })</span>
findAll(
  @Query('pageNum') pageNum?: number,
  @Query('pageSize') pageSize?: number,
) {
  return this.usersService.findAll(pageNum, pageSize);
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c2f2153899c4c4db74bb379c400b087~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=xOX1POXGeESEy1I0Eak%2FOV8CFkM%3D" alt="image.png" loading="lazy"/></p>
<p>上面的注解为文档的查询参数添加了描述 <code>description</code> 以及是否为必填项 <code>required</code>。</p>
<p>再比如搜索用户：</p>
<pre><code class="hljs language-diff" lang="diff">@Get('search')
@ApiOperation({ summary: '搜索用户' })
<span class="hljs-addition">+ @ApiQuery({ name: 'query', description: '搜索关键词', example: '张三' })</span>
search(@Query('query') query: string) {
  return this.usersService.searchUsers(query);
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58c359b5d1a446b48be7732ae4364b05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=7Lp%2Bvm8ikilmohfHhejhIhl5Fuo%3D" alt="image.png" loading="lazy"/></p>
<p>额外加上 <code>example</code>，示例更完善。</p>
<h3 data-id="heading-22">4.3 <code>@ApiParam()</code> - 路径参数</h3>
<p>请求 URL 上路径参数则使用 <code>@ApiParam()</code> 来定义，也就是动态参数。</p>
<pre><code class="hljs language-diff" lang="diff">@Get(':id')
@ApiOperation({ summary: '根据ID获取用户' })
<span class="hljs-addition">+ @ApiParam({ name: 'id', description: '用户ID', example: 1 })</span>
findOne(@Param('id', ParseIntPipe) id: number) {
  return this.usersService.findOne(id);
}

// ...
</code></pre>
<p>上面以 GET 方法为例，PATCH、DELETE 同理。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f8da765626d413683c2c46b36bad248~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=Dzs06vRBCRS8QLvfq7%2FdeXFffF8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-23">4.4 <code>@ApiBody()</code> - 请求体结构</h3>
<p><code>@ApiBody()</code> 用于描述复杂的请求体结构，它和 DTO 一起用：</p>
<pre><code class="hljs language-diff" lang="diff">@Post()
@ApiOperation({ summary: '创建新用户' })
<span class="hljs-addition">+ @ApiBody({ type: CreateUserDto })</span>
@ApiResponse({ status: 201, description: '用户创建成功' })
@ApiResponse({ status: 400, description: '无效的输入数据' })
create(
  @Body('name', UniqueUsernamePipe) name: string,
  @Body() createUserDto: CreateUserDto,
) {
  return this.usersService.create(createUserDto);
}
</code></pre>
<h3 data-id="heading-24">4.5 <code>@ApiResponse()</code> - 状态码</h3>
<p><code>@ApiResponse()</code> 用于定义返回的响应状态码 <code>status</code> 和描述 <code>description</code>。</p>
<pre><code class="hljs language-diff" lang="diff">@Post()
@ApiOperation({ summary: '创建新用户' })
@ApiBody({ type: CreateUserDto })
<span class="hljs-addition">+ @ApiResponse({ status: 201, description: '用户创建成功' })</span>
<span class="hljs-addition">+ @ApiResponse({ status: 400, description: '无效的输入数据' })</span>
create(
  @Body('name', UniqueUsernamePipe) name: string,
  @Body() createUserDto: CreateUserDto,
) {
  return this.usersService.create(createUserDto);
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f8359acd35c440db194ccc6624735ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I-g6JCd55qE6Jyc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768649107&amp;x-signature=4DEkIRZBvkOSTdzgGeLTuB%2BFe%2B4%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-25">5. 总结</h2>
<p>本文介绍了 Swagger 在 NestJS 项目中的集成、配置以及注解用法，适合开发者在实际项目中生成清晰易读的 API 文档。其实除了 dto 文件，还有一个 entity 文件，它用于结合传统 ORM（如 TypeORM）定义数据实体，在笔者的教程中，使用 Prisma 作为 ORM，只有用 dto 就可以了，这是为什么呢？</p>
<p><strong>原因</strong></p>
<ol>
<li><strong>Prisma 的数据模型文件已经定义了数据库结构</strong>：在 Prisma 中，schema.prisma 文件用于定义数据库模型，它描述了数据库表的结构和关系。相比于传统 ORM（如 TypeORM）的实体类，这个文件就相当于实体的定义。</li>
<li><strong>DTO 负责请求和响应的数据结构</strong>：DTO（Data Transfer Object）用于定义请求体和响应体的结构，并结合验证器（如 class-validator）进行数据验证和转换。它可以独立于数据库模型来使用，确保数据输入输出的安全和一致性。</li>
<li><strong>减少重复定义</strong>：如果已经有 schema.prisma 文件和 DTO 类，再定义一个实体类会增加重复和维护的成本。使用 Prisma 时，主要依赖 PrismaClient 来执行数据库操作，直接使用 DTO 和 schema.prisma 文件即可满足大多数业务需求。</li>
</ol>
<p><strong>典型用法</strong></p>
<ul>
<li><strong>Prisma 负责数据库的持久化</strong>：使用 schema.prisma 定义数据库表结构，通过 Prisma 的 PrismaClient 进行数据查询和操作。</li>
<li><strong>DTO 负责请求和响应的数据格式</strong>：通过 DTO 类定义 API 请求体和响应体的结构，并结合 Swagger 生成 API 文档。</li>
</ul>
<p>这种做法符合“分离关注点”的原则，使得数据库层（Prisma）和数据传输层（DTO）各司其职。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Parcel 作者：如何用静态Hermes把JavaScript编译成C语言]]></title>    <link>https://juejin.cn/post/7593254419078365224</link>    <guid>https://juejin.cn/post/7593254419078365224</guid>    <pubDate>2026-01-10T09:51:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593254419078365224" data-draft-id="7593254419078332456" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Parcel 作者：如何用静态Hermes把JavaScript编译成C语言"/> <meta itemprop="keywords" content="前端,JavaScript,Rust"/> <meta itemprop="datePublished" content="2026-01-10T09:51:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Yanni4Night"/> <meta itemprop="url" content="https://juejin.cn/user/4089838983724520"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Parcel 作者：如何用静态Hermes把JavaScript编译成C语言
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4089838983724520/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Yanni4Night
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T09:51:19.000Z" title="Sat Jan 10 2026 09:51:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdevongovett.me%2Fblog%2Fstatic-hermes.html" target="_blank" title="https://devongovett.me/blog/static-hermes.html" ref="nofollow noopener noreferrer">devongovett.me/blog/static…</a>，parcel 作者 Devon 的博客</p>
</blockquote>
<p>最近我一直在把Parcel的更多部分移植到Rust上。基于Rust的工具面临的一大挑战就是如何支持插件。很多常用工具已经有了Rust版本的平替：比如处理JavaScript的SWC和OXC，CSS的Lightning CSS，SVG的oxvg等等。但像React Compiler、Less和Sass这些热门工具还在用JavaScript编写，所以我们得想办法在Rust工具里运行它们。</p>
<p>一种方案是通过napi把Rust核心嵌入Node。这种模式下，程序的入口是JavaScript，它会调用Rust代码。当Rust需要调用JS插件时，再回调到JavaScript引擎。Lightning CSS的JS插件就是这么实现的。不过这会带来一些性能损耗：我开发Lightning CSS时测过，用JS插件比不用慢了大概7倍。</p>
<p>另一种类似的方案是跨进程通信。这种模式下入口是Rust，需要运行插件时就启动Node子进程。这同样会有不小的性能开销。</p>
<h2 data-id="heading-0">静态Hermes</h2>
<p>Hermes是Facebook为React Native打造的定制JavaScript引擎。最新版本的静态Hermes（Static Hermes）采用了全新思路：它不再在运行时使用JIT（即时）编译器，而是提前把JavaScript编译成字节码或原生二进制文件。这样就省去了运行时编译和优化代码的启动时间，这在手机上可是个不小的提升。</p>
<p>静态Hermes的工作原理是把JavaScript编译成C代码，再通过LLVM编译成机器码。最终生成的是完全独立的二进制文件，不需要JavaScript虚拟机就能运行。编译出的C代码会用到Hermes提供的一些辅助函数，这些函数会像Rust等语言的标准库一样被静态链接到二进制文件中。这不仅能利用LLVM的高级优化提升性能，还能让JavaScript轻松嵌入到Rust这类能和C交互的语言编写的程序中。</p>
<h2 data-id="heading-1">把Less.js编译成C</h2>
<p>我打算给Parcel做个Less插件，能从Rust调用的那种。借助静态Hermes，我成功把它编译成了C库，然后就能从Rust调用了。</p>
<p>第一步是把less这个npm模块打包成一个没有外部依赖的单文件JavaScript。Hermes不支持Node模块，所以一切都得自给自足，也不能依赖<code>fs</code>或<code>path</code>这些Node内置模块。当然，我用Parcel来做这件事。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用Less的环境无关版本，并模拟PluginLoader</span>
<span class="hljs-keyword">const</span> less = <span class="hljs-built_in">require</span>(<span class="hljs-string">'less/lib/less'</span>).<span class="hljs-title function_">default</span>({}, {})
less.<span class="hljs-property">PluginLoader</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {}

<span class="hljs-comment">// 暴露一个全局函数，把Less代码字符串编译成CSS</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">compile</span>(<span class="hljs-params">input</span>) {
  <span class="hljs-keyword">let</span> result
  less.<span class="hljs-title function_">render</span>(input, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> {
    result = res.<span class="hljs-property">css</span>
  })
  <span class="hljs-keyword">return</span> result
}

globalThis.<span class="hljs-property">compile</span> = compile
</code></pre>
<p>用Parcel编译：</p>
<pre><code class="hljs language-bash" lang="bash">parcel build less.js --no-optimize
</code></pre>
<p>这样就生成了<code>dist/less.js</code>，一个完全独立的文件，暴露了全局的<code>compile</code>函数。</p>
<p>接下来把它编译成C库。首先得自己编译静态Hermes，按照官方文档操作就行。</p>
<pre><code class="hljs language-bash" lang="bash">./build_release/bin/shermes -O -c -exported-unit=less dist/less.js
</code></pre>
<ul>
<li><code>-O</code> 生成优化过的构建</li>
<li><code>-c</code> 编译成原生目标文件，之后可以链接到更大的程序中</li>
<li><code>-exported-unit=less</code> 告诉Hermes不要生成<code>main</code>函数，而是导出一个叫<code>less</code>的编译单元</li>
</ul>
<p>这会生成<code>less.o</code>目标文件。（如果想看看编译出的C源代码，可以把<code>-c</code>换成<code>-emit-c</code>。）</p>
<p>然后需要一个小的C包装器来调用这个JavaScript函数。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// compile.c</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hermes/VM/static_h.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hermes/hermes.h&gt;</span></span>

<span class="hljs-comment">// 声明静态Hermes生成的`less`单元</span>
<span class="hljs-comment">// 这个会来自`less.o`</span>
<span class="hljs-keyword">extern</span> \<span class="hljs-string">"C\" SHUnit sh_export_less;

extern \"C\" char* compile_less(char *in) {
  // 初始化Hermes运行时
  static SHRuntime *s_shRuntime = nullptr;
  static facebook::hermes::HermesRuntime *s_hermes = nullptr;

  if (s_shRuntime == nullptr) {
    s_shRuntime = _sh_init(0, nullptr);
    s_hermes = _sh_get_hermes_runtime(s_shRuntime);
    if (!_sh_initialize_units(s_shRuntime, 1, &amp;sh_export_less)) {
      abort();
    }
  }

  // 获取全局的`compile`函数并调用
  std::string res = s_hermes-&gt;global()
    .getPropertyAsFunction(*s_hermes, \"compile\")
    .call(*s_hermes, std::string(in))
    .getString(*s_hermes)
    .utf8(*s_hermes);

  // 把C++字符串转成能返回的C字符串
  char* result = new char[res.size() + 1];
  strcpy(result, res.c_str());
  return result;
}
</span></code></pre>
<p>用<code>clang++</code>把这个编译成另一个目标文件：</p>
<pre><code class="hljs language-bash" lang="bash">clang++ -c -O3 -std=c++17 -IAPI -IAPI/jsi -Iinclude -Ipublic -Ibuild_release/lib/config compile.c
</code></pre>
<ul>
<li><code>-c</code> 生成目标文件</li>
<li><code>-O3</code> 生成优化过的构建</li>
<li><code>-std=c++17</code> 启用C++17特性</li>
<li><code>-I</code> 添加Hermes的头文件路径</li>
</ul>
<p>这会生成<code>compile.o</code>目标文件。</p>
<p>最后就是从Rust调用这个<code>compile_less</code>函数了。</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// main.rs</span>
<span class="hljs-keyword">use</span> std::ffi::{CStr, CString};
<span class="hljs-keyword">use</span> std::os::raw::c_char;

<span class="hljs-comment">// 声明要调用的C函数</span>
<span class="hljs-keyword">extern</span> \<span class="hljs-string">"C\" {
  fn compile_less(input: *const c_char) -&gt; *const c_char;
}

fn main() {
  // 创建C字符串
  let input = CString::new(
    r#\"// 变量
      @link-color: #428bca;
      @link-color-hover: darken(@link-color, 10%);

      a,
      .link {
        color: @link-color;
      }
      a:hover {
        color: @link-color-hover;
      }
      .widget {
        color: #fff;
        background: @link-color;
      }
    \"#,
  )
  .unwrap();

  // 调用C函数并转成Rust字符串
  let res = unsafe {
    let ptr = compile_less(input.as_ptr());
    CStr::from_ptr(ptr).to_string_lossy().into_owned()
  };

  // 打印结果
  println!(\"OUTPUT: {}\", res);
}
</span></code></pre>
<p>用<code>rustc</code>编译并链接所有东西：</p>
<pre><code class="hljs language-bash" lang="bash">rustc main.rs -O -C link-arg=less.o -C link-arg=compile.o -Lbuild_release/lib -Lbuild_release/jsi -Lbuild_release/tools/shermes -lshermes_console_a -lhermesvm_a -ljsi -lc++ -Lbuild_release/external/boost/boost_1_86_0/libs/context/ -lboost_context -l framework=Foundation
</code></pre>
<ul>
<li><code>-O</code> 生成优化过的构建</li>
<li><code>-C link-arg=less.o -C link-arg=compile.o</code> 链接之前创建的C库</li>
<li><code>-L ...</code> 添加库搜索路径</li>
<li><code>-l ...</code> 链接Hermes库和依赖</li>
<li><code>-l framework=Foundation</code> 是macOS特有的，用来链接Foundation框架</li>
</ul>
<p>现在运行程序，就能看到它通过Rust编译Less了！🪄</p>
<pre><code class="hljs language-bash" lang="bash">./main
</code></pre>
<h2 data-id="heading-2">总结</h2>
<p>这只是个简单的初步示例，但展示了原生工具整合预编译JS插件的潜力，而且不需要嵌入解释器。另一个潜在用例是基于Babel的React Compiler——对很多人来说，这可能是他们构建流程中仅存的JS工具了。我简单试了下，但遇到了一些问题，可能是目前还缺少某些特性</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[小探mysql覆盖索引]]></title>    <link>https://juejin.cn/post/7593198957984661545</link>    <guid>https://juejin.cn/post/7593198957984661545</guid>    <pubDate>2026-01-10T10:27:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593198957984661545" data-draft-id="7593215107406807076" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="小探mysql覆盖索引"/> <meta itemprop="keywords" content="MySQL"/> <meta itemprop="datePublished" content="2026-01-10T10:27:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哈里谢顿"/> <meta itemprop="url" content="https://juejin.cn/user/3678304397695056"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            小探mysql覆盖索引
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3678304397695056/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哈里谢顿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T10:27:56.000Z" title="Sat Jan 10 2026 10:27:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 MySQL 中，<strong>覆盖索引（Covering Index）</strong> 是一种非常重要的查询优化技术。它的核心思想是：<strong>一个索引包含了查询所需的所有字段，因此 MySQL 可以直接从索引中获取数据，而无需回表（即无需访问主键索引或数据行）</strong> 。</p>
<hr/>
<h2 data-id="heading-0">🔍 一、为什么需要覆盖索引？</h2>
<h3 data-id="heading-1">1. <strong>普通索引查询的流程（非覆盖）</strong></h3>
<p>假设有一张用户表：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (
    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,
    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    age <span class="hljs-type">INT</span>,
    INDEX idx_name (name)
);
</code></pre>
<p>执行查询：</p>
<pre><code class="hljs language-ini" lang="ini">SELECT email FROM users WHERE <span class="hljs-attr">name</span> = <span class="hljs-string">'Alice'</span><span class="hljs-comment">;</span>
</code></pre>
<p>🔍 <strong>执行过程</strong>：</p>
<ol>
<li>在 <code>idx_name</code> 索引中查找 <code>name = 'Alice'</code> 的记录；</li>
<li>找到对应的 <strong>主键值（id）</strong> ；</li>
<li><strong>回表（回主键索引）</strong> ：用主键 <code>id</code> 去聚簇索引（InnoDB 的主键索引）中查找完整的行数据；</li>
<li>从行数据中提取 <code>email</code> 字段返回。</li>
</ol>
<blockquote>
<p>⚠️ <strong>问题</strong>：多了一次“回表”操作，增加了 I/O 和 CPU 开销。</p>
</blockquote>
<hr/>
<h3 data-id="heading-2">2. <strong>覆盖索引的查询流程</strong></h3>
<p>如果我们将索引改为：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建包含 name 和 email 的联合索引</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_name_email <span class="hljs-keyword">ON</span> users (name, email);
</code></pre>
<p>再执行相同查询：</p>
<pre><code class="hljs language-ini" lang="ini">SELECT email FROM users WHERE <span class="hljs-attr">name</span> = <span class="hljs-string">'Alice'</span><span class="hljs-comment">;</span>
</code></pre>
<p>✅ <strong>执行过程</strong>：</p>
<ol>
<li>在 <code>idx_name_email</code> 索引中查找 <code>name = 'Alice'</code>；</li>
<li><strong>直接从索引叶子节点中读取 <code>email</code> 值</strong>；</li>
<li><strong>无需回表！</strong></li>
</ol>
<blockquote>
<p>🎯 <strong>这就是覆盖索引：查询所需的所有列都包含在索引中。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-3">✅ 二、覆盖索引的核心优势</h2>

























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>减少 I/O 操作</strong></td><td>避免回表，少读一次聚簇索引（磁盘或缓冲池）</td></tr><tr><td><strong>提升查询速度</strong></td><td>尤其对大表、高并发场景效果显著</td></tr><tr><td><strong>降低 CPU 消耗</strong></td><td>减少数据解析和内存拷贝</td></tr><tr><td><strong>利用索引顺序性</strong></td><td>覆盖索引常配合 <code>ORDER BY</code> 实现“索引扫描排序”</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-4">🛠️ 三、如何判断是否使用了覆盖索引？</h2>
<p>使用 <code>EXPLAIN</code> 查看执行计划：</p>
<pre><code class="hljs language-ini" lang="ini">EXPLAIN SELECT email FROM users WHERE <span class="hljs-attr">name</span> = <span class="hljs-string">'Alice'</span><span class="hljs-comment">;</span>
</code></pre>
<p>关键看 <strong><code>Extra</code> 列</strong>：</p>
<ul>
<li>如果显示 <strong><code>Using index</code></strong> → ✅ 使用了覆盖索引</li>
<li>如果显示 <strong><code>Using where</code></strong> 或 <strong>空</strong> → ❌ 未覆盖，需要回表</li>
</ul>
<blockquote>
<p>✅ 示例输出：</p>
<pre><code class="hljs language-sql" lang="sql">id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys     <span class="hljs-operator">|</span> key             <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>   <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> Extra
<span class="hljs-number">1</span>  <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> users <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> idx_name_email    <span class="hljs-operator">|</span> idx_name_email  <span class="hljs-operator">|</span> <span class="hljs-number">303</span>     <span class="hljs-operator">|</span> const <span class="hljs-operator">|</span> <span class="hljs-number">1</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> index
</code></pre>
</blockquote>
<hr/>
<h2 data-id="heading-5">📌 四、覆盖索引的使用条件</h2>
<ol>
<li><strong>SELECT 的所有字段</strong> 必须包含在同一个索引中；</li>
<li><strong>WHERE 条件字段</strong> 也应尽可能在该索引中（用于快速定位）；</li>
<li><strong>不能包含未索引的列</strong>（如 <code>SELECT *</code> 通常无法覆盖，除非是主键表）；</li>
<li><strong>适用于 InnoDB 和 MyISAM</strong>（但 InnoDB 的聚簇索引结构使其更依赖覆盖索引来避免回表）。</li>
</ol>
<hr/>
<h2 data-id="heading-6">⚠️ 五、注意事项与陷阱</h2>
<h3 data-id="heading-7">1. <strong>不要盲目创建宽索引</strong></h3>
<ul>
<li>索引越大，写入（INSERT/UPDATE）越慢；</li>
<li>占用更多磁盘和内存（Buffer Pool）；</li>
<li><strong>只包含真正需要的字段</strong>。</li>
</ul>
<h3 data-id="heading-8">2. <strong>主键自动包含在 InnoDB 二级索引中</strong></h3>
<p>InnoDB 的二级索引叶子节点存储的是 <strong>(索引列, 主键值)</strong> 。<br/>
所以以下查询也能覆盖：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 表：users(id PK, name, email)</span>
<span class="hljs-comment">-- 索引：idx_name(name)</span>

<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">'Alice'</span>;  <span class="hljs-comment">-- ✅ 覆盖！因为 id 在二级索引中</span>
</code></pre>
<p>但：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> email <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">'Alice'</span>;  <span class="hljs-comment">-- ❌ 不覆盖！email 不在 idx_name 中</span>
</code></pre>
<h3 data-id="heading-9">3. <strong>函数或表达式会破坏覆盖</strong></h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 即使有 idx_email(email)，以下查询也无法覆盖：</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(email) <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">'a@example.com'</span>;
<span class="hljs-comment">-- 因为需要对 email 计算 UPPER()</span>
</code></pre>
<hr/>
<h2 data-id="heading-10">💡 六、实战优化示例</h2>
<h3 data-id="heading-11">场景：高频查询“用户邮箱”</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 优化前（无覆盖）</span>
<span class="hljs-keyword">SELECT</span> email <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> created_at <span class="hljs-operator">&gt;</span> <span class="hljs-string">'2023-01-01'</span>;

<span class="hljs-comment">-- 优化：创建覆盖索引</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_status_created_email <span class="hljs-keyword">ON</span> users (status, created_at, email);

<span class="hljs-comment">-- 现在查询完全走覆盖索引！</span>
</code></pre>
<h3 data-id="heading-12">场景：分页 + 排序</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 查询最近活跃用户的 ID 和昵称</span>
<span class="hljs-keyword">SELECT</span> id, nickname <span class="hljs-keyword">FROM</span> users 
<span class="hljs-keyword">WHERE</span> active <span class="hljs-operator">=</span> <span class="hljs-number">1</span> 
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> last_login <span class="hljs-keyword">DESC</span> 
LIMIT <span class="hljs-number">20</span>;

<span class="hljs-comment">-- 覆盖索引</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_active_login_nickname <span class="hljs-keyword">ON</span> users (active, last_login, nickname);
<span class="hljs-comment">-- 注意：id 是主键，InnoDB 二级索引自动包含，所以 SELECT id 也能覆盖</span>
</code></pre>
<hr/>
<h2 data-id="heading-13">✅ 七、总结</h2>





























<table><thead><tr><th>关键点</th><th>说明</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>索引包含查询所需全部字段，无需回表</td></tr><tr><td><strong>标志</strong></td><td><code>EXPLAIN</code> 中 <code>Extra = "Using index"</code></td></tr><tr><td><strong>优势</strong></td><td>减少 I/O、提升性能、降低负载</td></tr><tr><td><strong>适用</strong></td><td>高频查询、报表、API 接口等读多场景</td></tr><tr><td><strong>禁忌</strong></td><td>避免过度索引、注意写性能影响</td></tr></tbody></table>
<blockquote>
<p>🌟 <strong>最佳实践</strong>：<br/>
对高频查询的 <code>SELECT</code> 字段 + <code>WHERE</code> 字段 + <code>ORDER BY</code> 字段，设计<strong>联合覆盖索引</strong>，是 MySQL 性能优化的“黄金法则”之一。</p>
</blockquote>
<p>如果你有具体的 SQL 查询需要优化，欢迎贴出来，我可以帮你设计覆盖索引！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Trae IDE: 我为什么从Free版升级成了Pro版订阅]]></title>    <link>https://juejin.cn/post/7593296804108714024</link>    <guid>https://juejin.cn/post/7593296804108714024</guid>    <pubDate>2026-01-10T10:33:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593296804108714024" data-draft-id="7593254419078430760" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Trae IDE: 我为什么从Free版升级成了Pro版订阅"/> <meta itemprop="keywords" content="Trae,VibeCoding"/> <meta itemprop="datePublished" content="2026-01-10T10:33:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="bytebeats"/> <meta itemprop="url" content="https://juejin.cn/user/463698667655"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Trae IDE: 我为什么从Free版升级成了Pro版订阅
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/463698667655/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    bytebeats
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T10:33:44.000Z" title="Sat Jan 10 2026 10:33:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">我与Trae的这一年: 将 Trae IDE从Free版最终升级成了Pro版订阅</h2>
<p>我曾经用过完全免费的Trae.ai IDE版本, 现在也订阅了Pro版. 个人认为Pro版物超所值. 它彻底解决了免费版本使用AI模型时需排队等待的问题, 代码编辑无实际限制, 智能助手支持完全自定义, 且整个程序运行流畅度远超免费版, 体验更顺滑无缝.</p>
<p>免费版固然出色实用, 我对此毫无怨言.</p>
<blockquote>
<p>但免费版本也有致命伤: 使用 AI 模型时需要排队等待. 有时候会让你盯着进度条心烦意乱.</p>
</blockquote>
<p>但专业版订阅则能让基础的IDE AI助手蜕变为真正的超级工具, 成为不可小觑的利器.</p>
<p>我曾从零构建完整程序:</p>
<ul>
<li>通过<code>plan.md</code>进行全流程规划,</li>
<li>配合<code>todo.md</code>确保所有模块互联互通,</li>
<li>功能正常运行, 并实现数据库/API的深度集成.</li>
</ul>
<p>这款助手的工作方式令人惊叹——它能按阶段逐步构建并始终专注于当前任务.</p>
<p>我的程序分为8个阶段:</p>
<ul>
<li>从创意构思,</li>
<li>目标用户定位,</li>
<li>架构设计,</li>
<li>开发实现,</li>
<li>直至最终程序交付, 全程无遗漏.</li>
</ul>
<p>本质上, 我的智能助手如同员工般为我工作, 一步一个脚印地推进.</p>
<blockquote>
<p>最最关键的技巧是: 前端, 后端及数据库/API模块均应逐项开发. 如此方能确保所有组件正确配置且稳定运行.</p>
</blockquote>
<p>最后, 请发表自己的使用 Trae IDE 的使用体验和观点, 大家可以探讨一下Free 版和 Pro 版的优劣.</p>
<p>好吧, 今天的内容就分享到这里啦!</p>
<p>一家之言, 欢迎拍砖!</p>
<p>Happy Coding! Stay GOLDEN!</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【anthropic官方文章】揭秘 AI Agents 的评估方法]]></title>    <link>https://juejin.cn/post/7593310044478455817</link>    <guid>https://juejin.cn/post/7593310044478455817</guid>    <pubDate>2026-01-10T10:39:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593310044478455817" data-draft-id="7593337928307376154" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【anthropic官方文章】揭秘 AI Agents 的评估方法"/> <meta itemprop="keywords" content="Claude"/> <meta itemprop="datePublished" content="2026-01-10T10:39:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="是魔丸啊"/> <meta itemprop="url" content="https://juejin.cn/user/3217622495411292"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【anthropic官方文章】揭秘 AI Agents 的评估方法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3217622495411292/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    是魔丸啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T10:39:07.000Z" title="Sat Jan 10 2026 10:39:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读34分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"/>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fengineering%2Fdemystifying-evals-for-ai-agents" target="_blank" title="https://www.anthropic.com/engineering/demystifying-evals-for-ai-agents" ref="nofollow noopener noreferrer">转载</a></p>
<p>发布于 2026年1月9日</p>
<p>使 agents 变得有用的能力，恰恰也让它们难以评估。在实际部署中行之有效的策略，往往需要结合多种技术来匹配所测量系统的复杂性。</p>
<h3 data-id="heading-1">引言</h3>
<p>良好的评估能帮助团队更有信心地交付 AI agents。没有评估，团队很容易陷入被动循环——只能在生产环境中发现问题，而修复一个故障往往又会引发其他问题。评估能在问题影响用户之前使其可见，并且随着 agent 的整个生命周期，评估的价值会不断累积。</p>
<p>正如我们在<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fengineering%2Fbuilding-effective-agents" target="_blank" title="https://www.anthropic.com/engineering/building-effective-agents" ref="nofollow noopener noreferrer">构建高效 agents</a>一文中所述，agents 需要经过多轮操作：调用工具、修改状态、并根据中间结果进行调整。正是这些使 AI agents 变得有用的能力——自主性、智能性和灵活性——也让它们更难评估。</p>
<p>通过我们的内部工作以及与处于 agent 开发前沿的客户合作，我们学会了如何为 agents 设计更严谨、更有用的评估。以下是在各种 agent 架构和实际部署用例中行之有效的方法。</p>
<h3 data-id="heading-2">评估的结构</h3>
<p><strong>评估</strong>（eval）是对 AI 系统的测试：给 AI 一个输入，然后对其输出应用评分逻辑来衡量成功与否。在本文中，我们重点关注可以在开发阶段无需真实用户参与的 <strong>自动化评估</strong>。</p>
<p><strong>单轮评估</strong> 相对简单：一个提示、一个响应、一套评分逻辑。对于早期的 LLM，单轮非 agentic 评估是主要的评估方法。随着 AI 能力的提升，<strong>多轮评估</strong> 变得越来越普遍。</p>
<p>在简单评估中，agent 处理一个提示，评分器检查输出是否符合预期。在更复杂的多轮评估中，coding agent 接收工具、任务（本例中是构建 MCP server）和环境，执行"agent 循环"（工具调用和推理），并用实现结果更新环境。然后通过单元测试对工作的 MCP server 进行评分验证。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b86e85b886640c296b58bf461ccd44e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646346&amp;x-signature=hWrVr6sJBC2%2FGz8DDVTctIwDr4I%3D" alt="" loading="lazy"/></p>
<p><strong>Agent 评估</strong> 更加复杂。Agents 在多轮中使用工具，修改环境状态并随时调整——这意味着错误可能传播和累积。前沿模型还能找到超越静态评估限制的创造性解决方案。例如，Opus 4.5 在解决 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsierra-research%2Ftau2-bench" target="_blank" title="https://github.com/sierra-research/tau2-bench" ref="nofollow noopener noreferrer">𝜏2-bench</a> 关于预订航班的问题时，<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fclaude-opus-4-5" target="_blank" title="https://www.anthropic.com/news/claude-opus-4-5" ref="nofollow noopener noreferrer">发现</a>了政策中的漏洞。按照评估的字面标准，它"失败"了，但实际上为用户想出了更好的解决方案。</p>
<p>在构建 agent 评估时，我们使用以下定义：</p>
<p><strong>任务</strong>（又称 <strong>问题</strong> 或 <strong>测试用例</strong>）是具有明确输入和成功标准的单个测试。</p>
<p>每次尝试任务称为一次 <strong>试验</strong>。由于模型输出在不同运行之间存在差异，我们运行多次试验以产生更一致的结果。</p>
<p><strong>评分器</strong> 是对 agent 性能某些方面进行评分的逻辑。一个任务可以有多个评分器，每个评分器包含多个断言（有时称为 <strong>检查项</strong>）。</p>
<p><strong>记录</strong>（也称为 <strong>trace</strong> 或 <strong>trajectory</strong>）是一次试验的完整记录，包括输出、工具调用、推理、中间结果以及任何其他交互。对于 Anthropic API，这是评估运行结束时的完整 messages 数组——包含评估期间对 API 的所有调用和返回的所有响应。</p>
<p><strong>结果</strong> 是试验结束时环境的最终状态。航班预订 agent 可能在记录末尾说"您的航班已预订"，但结果是指环境的 SQL 数据库中是否存在预订记录。</p>
<p><strong>评估框架</strong> 是端到端运行评估的基础设施。它提供指令和工具，并发运行任务，记录所有步骤，对输出进行评分，并汇总结果。</p>
<p><strong>Agent 框架</strong>（或 <strong>scaffold</strong>）是使模型能够作为 agent 运行的系统：它处理输入、协调工具调用并返回结果。当我们评估"一个 agent"时，我们评估的是框架 <strong>和</strong> 模型的协同工作。例如，<a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.com%2Fproduct%2Fclaude-code" target="_blank" title="https://claude.com/product/claude-code" ref="nofollow noopener noreferrer">Claude Code</a> 是一个灵活的 agent 框架，我们使用其核心原语通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.claude.com%2Fdocs%2Fen%2Fagent-sdk%2Foverview" target="_blank" title="https://platform.claude.com/docs/en/agent-sdk/overview" ref="nofollow noopener noreferrer">Agent SDK</a> 构建了我们的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fengineering%2Feffective-harnesses-for-long-running-agents" target="_blank" title="https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents" ref="nofollow noopener noreferrer">长时间运行 agent 框架</a>。</p>
<p><strong>评估套件</strong> 是为衡量特定能力或行为而设计的任务集合。套件中的任务通常共享一个大目标。例如，客户支持评估套件可能测试退款、取消和升级处理。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59fb1fd01d184bc0933c1a8cd62132b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646346&amp;x-signature=QNP0WjZTClP1sb5U4v0KXR1WGwo%3D" alt="" loading="lazy"/></p>
<p><em>Agents 评估的组成部分。</em></p>
<h3 data-id="heading-3">为什么要构建评估？</h3>
<p>当团队刚开始构建 agents 时，通过手动测试、<a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FEating_your_own_dog_food" target="_blank" title="https://en.wikipedia.org/wiki/Eating_your_own_dog_food" ref="nofollow noopener noreferrer">内部试用</a>和直觉的组合，可以取得令人惊讶的进展。更严格的评估甚至可能看起来是减慢发布速度的额外开销。但在早期原型阶段之后，一旦 agent 投入生产并开始扩展，没有评估的构建方式就会崩溃。</p>
<p>转折点通常出现在用户报告 agent 在修改后感觉变差时，而团队处于"盲飞"状态，除了猜测和检查外别无验证方法。没有评估，调试是被动的：等待投诉、手动复现、修复 bug，然后希望没有其他地方出现回归。团队无法区分真正的回归和噪音，无法在发布前自动针对数百个场景测试变更，也无法衡量改进效果。</p>
<p>我们多次见证了这种演变过程。例如，Claude Code 最初是基于 Anthropic 员工和外部用户的反馈进行快速迭代的。后来，我们添加了评估——首先针对简洁性和文件编辑等狭窄领域，然后针对过度工程化等更复杂的行为。这些评估帮助识别问题、指导改进，并聚焦研究与产品团队的协作。结合生产监控、A/B 测试、用户研究等，评估提供了持续改进 Claude Code 的信号。</p>
<p>在 agent 生命周期的任何阶段编写评估都是有用的。在早期，评估迫使产品团队明确定义 agent 的成功标准，而后期则帮助维持一致的质量标准。<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.descript.com%2F" target="_blank" title="https://www.descript.com/" ref="nofollow noopener noreferrer">Descript</a> 的 agent 帮助用户编辑视频，因此他们围绕成功编辑工作流的三个维度构建了评估：不破坏内容、执行我要求的操作、执行得好。他们从手动评分演进到由产品团队定义标准并定期进行人工校准的 LLM 评分器，现在定期运行两个独立套件用于质量基准测试和回归测试。<a href="https://link.juejin.cn?target=https%3A%2F%2Fbolt.new%2F" target="_blank" title="https://bolt.new/" ref="nofollow noopener noreferrer">Bolt</a> AI 团队在较晚时候开始构建评估，当时他们已经有了广泛使用的 agent。在 3 个月内，他们构建了一个评估系统，可以运行其 agent 并使用静态分析对输出进行评分，使用浏览器 agents 测试应用，以及使用 LLM judges 评估指令遵循等行为。</p>
<p>有些团队在开发开始时就创建评估；其他团队在扩展后才添加，此时评估成为改进 agent 的瓶颈。评估在 agent 开发初期特别有用，可以明确编码预期行为。两位工程师阅读同一份初始规格说明后，可能对 AI 应如何处理边缘情况有不同的理解。评估套件可以消除这种歧义。无论何时创建，评估都有助于加速开发。</p>
<p>评估还影响你采用新模型的速度。当更强大的模型发布时，没有评估的团队面临数周的测试，而有评估的竞争对手可以快速确定模型的优势、调整提示，并在几天内完成升级。</p>
<p>一旦有了评估，你就能免费获得基线和回归测试：延迟、token 使用量、每任务成本和错误率都可以在静态任务库上跟踪。评估还可以成为产品和研究团队之间最高带宽的沟通渠道，定义研究人员可以优化的指标。显然，评估的好处远不止跟踪回归和改进。由于成本在前期可见而收益后期累积，其复合价值很容易被忽视。</p>
<h3 data-id="heading-4">如何评估 AI Agents</h3>
<p>我们看到目前大规模部署的常见 agent 类型包括 coding agents、research agents、computer use agents 和 conversational agents。每种类型可能部署在各种行业，但可以使用类似的技术进行评估。你不需要从头发明评估方法。以下部分描述了几种 agent 类型的成熟技术。使用这些方法作为基础，然后扩展到你的领域。</p>
<h4 data-id="heading-5">Agents 的评分器类型</h4>
<p>Agent 评估通常结合三种类型的评分器：基于代码的、基于模型的和人工的。每个评分器评估记录或结果的某些部分。有效评估设计的关键是为任务选择正确的评分器。</p>

















<table><thead><tr><th>基于代码的评分器</th><th>方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td/><td>• 字符串匹配检查（精确、正则、模糊等）<br/>• 二元测试（fail-to-pass, pass-to-pass）<br/>• 静态分析（lint、类型、安全）<br/>• 结果验证<br/>• 工具调用验证（使用的工具、参数）<br/>• 记录分析（轮次、token 使用量）</td><td>• 快速<br/>• 便宜<br/>• 客观<br/>• 可重复<br/>• 易于调试<br/>• 验证特定条件</td><td>• 对不完全匹配预期模式的有效变体很脆弱<br/>• 缺乏细微差别<br/>• 评估某些主观任务能力有限</td></tr></tbody></table>

















<table><thead><tr><th>基于模型的评分器</th><th>方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td/><td>基于评分标准的打分<br/>自然语言断言<br/>成对比较<br/>基于参考的评估<br/>多评委共识</td><td>灵活<br/>可扩展<br/>捕捉细微差别<br/>处理开放式任务<br/>处理自由格式输出</td><td>非确定性<br/>比代码更昂贵<br/>需要与人工评分器校准以确保准确性</td></tr></tbody></table>

















<table><thead><tr><th>人工评分器</th><th>方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td/><td>领域专家审查<br/>众包判断<br/>抽样检查<br/>A/B 测试<br/>评分者间一致性</td><td>金标准质量<br/>匹配专家用户判断<br/>用于校准基于模型的评分器</td><td>昂贵<br/>缓慢<br/>通常需要大规模获取人类专家</td></tr></tbody></table>
<p>对于每个任务，评分可以是加权的（组合评分器分数必须达到阈值）、二元的（所有评分器必须通过）或混合的。</p>
<h4 data-id="heading-6">能力评估 vs 回归评估</h4>
<p><strong>能力或"质量"评估</strong> 问的是"这个 agent 能做好什么？"它们应该从较低的通过率开始，针对 agent 挣扎的任务，给团队一个努力攀登的目标。</p>
<p><strong>回归评估</strong> 问的是"agent 是否仍能处理它以前能处理的所有任务？"应该有接近 100% 的通过率。它们防止倒退，分数下降表明某些东西出了问题需要改进。当团队在能力评估上努力攀升时，同时运行回归评估以确保变更不会在其他地方造成问题也很重要。</p>
<p>在 agent 发布和优化后，通过率高的能力评估可以"毕业"成为持续运行以捕捉任何漂移的回归套件。曾经衡量"我们能做到吗？"的任务然后衡量"我们还能可靠地做到吗？"</p>
<h4 data-id="heading-7">评估 Coding Agents</h4>
<p><strong>Coding agents</strong> 编写、测试和调试代码，导航代码库，运行命令，就像人类开发者一样。现代 coding agents 的有效评估通常依赖于明确定义的任务、稳定的测试环境，以及对生成代码的全面测试。</p>
<p>确定性评分器对 coding agents 来说很自然，因为软件通常很容易评估：代码能运行吗？测试通过了吗？两个广泛使用的 coding agent 基准，<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.swebench.com%2FSWE-bench%2F" target="_blank" title="https://www.swebench.com/SWE-bench/" ref="nofollow noopener noreferrer">SWE-bench Verified</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.tbench.ai%2F" target="_blank" title="https://www.tbench.ai/" ref="nofollow noopener noreferrer">Terminal-Bench</a>，遵循这种方法。SWE-bench Verified 给 agents 提供来自流行 Python 仓库的 GitHub issues，并通过运行测试套件对解决方案进行评分；解决方案只有在修复失败测试而不破坏现有测试的情况下才算通过。LLM 在一年内在这个评估上从 40% 提高到 &gt;80%。Terminal-Bench 采用不同的路线：它测试端到端技术任务，如从源代码构建 Linux 内核或训练 ML 模型。</p>
<p>一旦你有了一组用于验证 coding 任务关键 <strong>结果</strong> 的通过/失败测试，通常也有用的是对 <strong>记录</strong> 进行评分。例如，基于启发式的代码质量规则可以基于通过测试以外的标准评估生成的代码，具有明确评分标准的基于模型的评分器可以评估 agent 如何调用工具或与用户交互等行为。</p>
<p><strong>示例：Coding agent 的理论评估</strong></p>
<p>考虑一个 coding 任务，agent 必须修复身份验证绕过漏洞。如下面的示例 YAML 文件所示，可以使用评分器和指标来评估这个 agent。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">task:</span>
  <span class="hljs-attr">id:</span> <span class="hljs-string">"fix-auth-bypass_1"</span>
  <span class="hljs-attr">desc:</span> <span class="hljs-string">"Fix authentication bypass when password field is empty and ..."</span>
  <span class="hljs-attr">graders:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">deterministic_tests</span>
      <span class="hljs-attr">required:</span> [<span class="hljs-string">test_empty_pw_rejected.py</span>, <span class="hljs-string">test_null_pw_rejected.py</span>]
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">llm_rubric</span>
      <span class="hljs-attr">rubric:</span> <span class="hljs-string">prompts/code_quality.md</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">static_analysis</span>
      <span class="hljs-attr">commands:</span> [<span class="hljs-string">ruff</span>, <span class="hljs-string">mypy</span>, <span class="hljs-string">bandit</span>]
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">state_check</span>
      <span class="hljs-attr">expect:</span>
        <span class="hljs-attr">security_logs:</span> {<span class="hljs-attr">event_type:</span> <span class="hljs-string">"auth_blocked"</span>}
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">tool_calls</span>
      <span class="hljs-attr">required:</span>
        <span class="hljs-bullet">-</span> {<span class="hljs-attr">tool:</span> <span class="hljs-string">read_file</span>, <span class="hljs-attr">params:</span> {<span class="hljs-attr">path:</span> <span class="hljs-string">"src/auth/*"</span>}}
        <span class="hljs-bullet">-</span> {<span class="hljs-attr">tool:</span> <span class="hljs-string">edit_file</span>}
        <span class="hljs-bullet">-</span> {<span class="hljs-attr">tool:</span> <span class="hljs-string">run_tests</span>}
  <span class="hljs-attr">tracked_metrics:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">transcript</span>
      <span class="hljs-attr">metrics:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">n_turns</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">n_toolcalls</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">n_total_tokens</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">latency</span>
      <span class="hljs-attr">metrics:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">time_to_first_token</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">output_tokens_per_sec</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">time_to_last_token</span>
</code></pre>
<p>请注意，此示例展示了用于说明目的的所有可用评分器。在实践中，coding 评估通常依赖单元测试进行正确性验证，LLM 评分标准用于评估整体代码质量，仅在需要时添加其他评分器和指标。</p>
<h4 data-id="heading-8">评估 Conversational Agents</h4>
<p><strong>Conversational agents</strong> 在支持、销售或辅导等领域与用户互动。与传统聊天机器人不同，它们维护状态、使用工具，并在对话中采取行动。虽然 coding 和 research agents 也可能涉及与用户的多轮交互，但 conversational agents 提出了一个独特的挑战：交互本身的质量也是你要评估的内容之一。Conversational agents 的有效评估通常依赖于可验证的最终状态结果和捕捉任务完成度与交互质量的评分标准。与大多数其他评估不同，它们通常需要第二个 LLM 来模拟用户。我们在 <a href="https://link.juejin.cn?target=https%3A%2F%2Falignment.anthropic.com%2F2025%2Fautomated-auditing%2F" target="_blank" title="https://alignment.anthropic.com/2025/automated-auditing/" ref="nofollow noopener noreferrer">alignment auditing agents</a> 中使用这种方法，通过扩展的对抗性对话来压力测试模型。</p>
<p>Conversational agents 的成功可以是多维的：工单是否已解决（状态检查）、是否在 &lt;10 轮内完成（记录约束）、语气是否恰当（LLM 评分标准）？两个包含多维性的基准是 <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2406.12045" target="_blank" title="https://arxiv.org/abs/2406.12045" ref="nofollow noopener noreferrer">𝜏-Bench</a> 及其后续版本 <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2506.07982" target="_blank" title="https://arxiv.org/abs/2506.07982" ref="nofollow noopener noreferrer">τ2-Bench</a>。它们模拟零售支持和航空预订等领域的多轮交互，其中一个模型扮演用户角色，而 agent 导航真实场景。</p>
<p><strong>示例：Conversational agent 的理论评估</strong></p>
<p>考虑一个支持任务，agent 必须为一位沮丧的客户处理退款。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">graders:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">llm_rubric</span>
    <span class="hljs-attr">rubric:</span> <span class="hljs-string">prompts/support_quality.md</span>
    <span class="hljs-attr">assertions:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"Agent showed empathy for customer's frustration"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"Resolution was clearly explained"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"Agent's response grounded in fetch_policy tool results"</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">state_check</span>
    <span class="hljs-attr">expect:</span>
      <span class="hljs-attr">tickets:</span> {<span class="hljs-attr">status:</span> <span class="hljs-string">resolved</span>}
      <span class="hljs-attr">refunds:</span> {<span class="hljs-attr">status:</span> <span class="hljs-string">processed</span>}
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">tool_calls</span>
    <span class="hljs-attr">required:</span>
      <span class="hljs-bullet">-</span> {<span class="hljs-attr">tool:</span> <span class="hljs-string">verify_identity</span>}
      <span class="hljs-bullet">-</span> {<span class="hljs-attr">tool:</span> <span class="hljs-string">process_refund</span>, <span class="hljs-attr">params:</span> {<span class="hljs-attr">amount:</span> <span class="hljs-string">"&lt;=100"</span>}}
      <span class="hljs-bullet">-</span> {<span class="hljs-attr">tool:</span> <span class="hljs-string">send_confirmation</span>}
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">transcript</span>
    <span class="hljs-attr">max_turns:</span> <span class="hljs-number">10</span>
<span class="hljs-attr">tracked_metrics:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">transcript</span>
    <span class="hljs-attr">metrics:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">n_turns</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">n_toolcalls</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">n_total_tokens</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">latency</span>
    <span class="hljs-attr">metrics:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">time_to_first_token</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">output_tokens_per_sec</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">time_to_last_token</span>
</code></pre>
<p>与我们的 coding agent 示例一样，此任务展示了用于说明目的的多种评分器类型。在实践中，conversational agent 评估通常使用基于模型的评分器来评估沟通质量和目标完成度，因为许多任务——如回答问题——可能有多个"正确"的解决方案。</p>
<h4 data-id="heading-9">评估 Research Agents</h4>
<p><strong>Research agents</strong> 收集、综合和分析信息，然后产生输出，如答案或报告。与 coding agents 单元测试提供二元通过/失败信号不同，研究质量只能相对于任务来判断。什么算"全面"、"引用充分"，甚至"正确"取决于上下文：市场扫描、收购尽职调查和科学报告各有不同的标准。</p>
<p>Research 评估面临独特挑战：专家可能对综合是否全面存在分歧，参考内容不断变化导致基准事实发生变化，更长、更开放的输出为错误创造了更多空间。像 <a href="https://link.juejin.cn?target=http%3A%2F%2Farxiv.org%2Fabs%2F2504.12516" target="_blank" title="http://arxiv.org/abs/2504.12516" ref="nofollow noopener noreferrer">BrowseComp</a> 这样的基准测试 AI agents 是否能在开放网络上大海捞针——设计的问题易于验证但难以解决。</p>
<p>构建 research agent 评估的一个策略是结合评分器类型。Groundedness 检查验证主张是否有检索来源支持，coverage 检查定义好答案必须包含的关键事实，source quality 检查确认咨询的来源是权威的，而不仅仅是首先检索到的。对于有客观正确答案的任务（"X 公司第三季度收入是多少？"），精确匹配有效。LLM 可以标记不支持的主张和覆盖缺口，还可以验证开放式综合的连贯性和完整性。</p>
<p>鉴于研究质量的主观性，基于 LLM 的评分标准应经常与专家人工判断进行校准，以有效评分这些 agents。</p>
<h4 data-id="heading-10">Computer Use Agents</h4>
<p><strong>Computer use agents</strong> 通过与人类相同的界面与软件交互——截图、鼠标点击、键盘输入和滚动——而不是通过 API 或代码执行。它们可以使用任何带有图形用户界面（GUI）的应用程序，从设计工具到传统企业软件。评估需要在 agent 可以使用软件应用程序的真实或沙盒环境中运行它，并检查它是否达到了预期结果。例如，<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2307.13854" target="_blank" title="https://arxiv.org/abs/2307.13854" ref="nofollow noopener noreferrer">WebArena</a> 测试基于浏览器的任务，使用 URL 和页面状态检查来验证 agent 是否正确导航，以及对修改数据的任务进行后端状态验证（确认订单确实已下达，而不仅仅是确认页面出现了）。<a href="https://link.juejin.cn?target=https%3A%2F%2Fos-world.github.io%2F" target="_blank" title="https://os-world.github.io/" ref="nofollow noopener noreferrer">OSWorld</a> 将此扩展到完整的操作系统控制，评估脚本在任务完成后检查各种工件：文件系统状态、应用程序配置、数据库内容和 UI 元素属性。</p>
<p>Browser use agents 需要在 token 效率和延迟之间取得平衡。基于 DOM 的交互执行快但消耗大量 tokens，而基于截图的交互较慢但更节省 tokens。例如，当要求 Claude 总结 Wikipedia 时，从 DOM 中提取文本更高效。当在 Amazon 上寻找新的笔记本电脑包时，截图更高效（因为提取整个 DOM 消耗大量 tokens）。在我们的 Claude for Chrome 产品中，我们开发了评估来检查 agent 是否为每个上下文选择了正确的工具。这使我们能够更快、更准确地完成基于浏览器的任务。</p>
<h4 data-id="heading-11">如何理解 Agent 评估中的非确定性</h4>
<p>无论 agent 类型如何，agent 行为在不同运行之间都有差异，这使得评估结果比乍看起来更难解读。每个任务都有自己的成功率——可能一个任务 90%，另一个任务 50%——在一次评估运行中通过的任务可能在下一次失败。有时，我们想要衡量的是 agent 对一个任务成功的 <strong>频率</strong>（试验中的比例）。</p>
<p>两个指标有助于捕捉这种细微差别：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fproceedings.neurips.cc%2Fpaper%2F2019%2Ffile%2F7298332f04ac004a0ca44cc69ecf6f6b-Paper.pdf" target="_blank" title="https://proceedings.neurips.cc/paper/2019/file/7298332f04ac004a0ca44cc69ecf6f6b-Paper.pdf" ref="nofollow noopener noreferrer">pass@k</a> 衡量 agent 在 <em>k</em> 次尝试中至少获得一个正确解决方案的可能性。随着 k 增加，pass@k 分数上升——更多的"射门机会"意味着至少成功 1 次的概率更高。50% pass@1 的分数意味着模型在第一次尝试时成功完成评估中一半的任务。在 coding 中，我们通常最关心 agent 在第一次尝试时找到解决方案——pass@1。在其他情况下，提出多个解决方案是有效的，只要有一个有效即可。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2406.12045" target="_blank" title="https://arxiv.org/abs/2406.12045" ref="nofollow noopener noreferrer">pass^k</a> 衡量 <strong>所有 k 次</strong> 试验都成功的概率。随着 <em>k</em> 增加，pass^k 下降，因为要求在更多试验中保持一致性是更高的标准。如果你的 agent 每次试验成功率为 75%，你运行 3 次试验，三次都通过的概率是 (0.75)³ ≈ 42%。这个指标对于用户期望每次都有可靠行为的面向客户的 agents 特别重要。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b6858afbf5b4bd4af7011d102042474~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646346&amp;x-signature=munvQp4QJ1avIe6iTbUQ3cI61Tk%3D" alt="" loading="lazy"/></p>
<p><em>随着试验增加，pass@k 和 pass^k 出现分化。在 k=1 时，它们相同（都等于每次试验的成功率）。到 k=10 时，它们讲述相反的故事：pass@k 接近 100%，而 pass^k 下降到 0%。</em></p>
<p>两个指标都有用，使用哪个取决于产品需求：对于一次成功就重要的工具使用 pass@k，对于一致性至关重要的 agents 使用 pass^k。</p>
<h3 data-id="heading-12">从零到一：构建出色 Agent 评估的路线图</h3>
<p>本节列出了我们从无评估到可信赖评估的实用、经过实战检验的建议。将此视为评估驱动 agent 开发的路线图：尽早定义成功、清晰衡量它、持续迭代。</p>
<h4 data-id="heading-13">为初始评估数据集收集任务</h4>
<p><strong>步骤 0. 尽早开始</strong></p>
<p>我们看到团队推迟构建评估，因为他们认为需要数百个任务。实际上，从真实失败中提取的 20-50 个简单任务是一个很好的开始。毕竟，在 agent 开发早期，对系统的每次更改通常都有明显的影响，这种大效应量意味着小样本量就足够了。更成熟的 agents 可能需要更大、更困难的评估来检测较小的效应，但最好在开始时采用 80/20 方法。评估等得越久越难构建。在早期，产品需求自然会转化为测试用例。等太久，你就得从实时系统逆向工程成功标准。</p>
<p><strong>步骤 1. 从你已经手动测试的内容开始</strong></p>
<p>从你在开发期间运行的手动检查开始——你在每次发布前验证的行为和最终用户尝试的常见任务。如果你已经在生产环境中，查看你的 bug 跟踪器和支持队列。将用户报告的失败转换为测试用例可确保你的套件反映实际使用情况；按用户影响优先排序有助于你将精力投入在重要的地方。</p>
<p><strong>步骤 2：编写无歧义的任务并附带参考解决方案</strong></p>
<p>正确把握任务质量比看起来更难。一个好任务是两位领域专家会独立得出相同通过/失败结论的任务。他们自己能通过任务吗？如果不能，任务需要改进。任务规格中的歧义会成为指标中的噪音。基于模型的评分器标准也是如此：模糊的评分标准会产生不一致的判断。</p>
<p>每个任务应该可以被正确遵循指令的 agent 通过。这可能很微妙。例如，审计 Terminal-Bench 时发现，如果任务要求 agent 编写脚本但未指定文件路径，而测试假设脚本的特定文件路径，agent 可能会因为自身以外的原因而失败。评分器检查的所有内容都应从任务描述中明确；agents 不应因为规格歧义而失败。对于前沿模型，在多次试验中 0% 的通过率（即 0% pass@100）最常表明任务有问题，而不是 agent 能力不足，这是一个仔细检查任务规格和评分器的信号。对于每个任务，创建一个参考解决方案是有用的：一个已知有效的输出，可以通过所有评分器。这证明任务是可解决的，并验证评分器配置正确。</p>
<p><strong>步骤 3：构建平衡的问题集</strong></p>
<p>同时测试行为 <strong>应该</strong> 发生和 <strong>不应该</strong> 发生的情况。单边评估会产生单边优化。例如，如果你只测试 agent 是否在应该搜索时搜索，你可能最终得到一个几乎对所有事情都搜索的 agent。尽量避免<a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fmachine-learning%2Fcrash-course%2Foverfitting%2Fimbalanced-datasets" target="_blank" title="https://developers.google.com/machine-learning/crash-course/overfitting/imbalanced-datasets" ref="nofollow noopener noreferrer">类别不平衡</a>的评估。我们在为 <a href="https://link.juejin.cn?target=http%3A%2F%2Fclaude.ai%2F" target="_blank" title="http://claude.ai/" ref="nofollow noopener noreferrer">Claude.ai</a> 的网页搜索构建评估时亲身学到了这一点。挑战是防止模型在不应该搜索时搜索，同时保留其在适当时进行广泛研究的能力。团队构建了覆盖两个方向的评估：模型应该搜索的查询（如查找天气）和应该从现有知识回答的查询（如"谁创立了 Apple？"）。在触发不足（应该搜索时不搜索）和触发过度（不应该搜索时搜索）之间找到正确的平衡很困难，需要对提示和评估进行多轮改进。随着更多示例问题出现，我们继续添加评估以提高覆盖率。</p>
<h4 data-id="heading-14">设计评估框架和评分器</h4>
<p><strong>步骤 4：构建具有稳定环境的健壮评估框架</strong></p>
<p>评估中的 agent 与生产中使用的 agent 功能大致相同，且环境本身不引入进一步噪音，这一点至关重要。每次试验应该通过从干净环境开始来"隔离"。运行之间不必要的共享状态（遗留文件、缓存数据、资源耗尽）可能导致由于基础设施不稳定而非 agent 性能导致的相关失败。共享状态还可能人为地提高性能。例如，在一些内部评估中，我们观察到 Claude 通过检查之前试验的 git 历史在某些任务上获得了不公平的优势。如果多个不同的试验因为环境中的同一限制（如 CPU 内存有限）而失败，这些试验就不是独立的，因为它们受到同一因素的影响，评估结果对于衡量 agent 性能就不可靠了。</p>
<p><strong>步骤 5：精心设计评分器</strong></p>
<p>如上所述，出色的评估设计涉及为 agent 和任务选择最佳评分器。我们建议尽可能选择确定性评分器，必要时或为了额外灵活性使用 LLM 评分器，并谨慎使用人工评分器进行额外验证。</p>
<p>有一种常见的直觉是检查 agents 是否遵循了非常具体的步骤，如按正确顺序进行的工具调用序列。我们发现这种方法过于僵化，导致测试过于脆弱，因为 agents 经常找到评估设计者没有预料到的有效方法。为了不不必要地惩罚创造性，通常更好的做法是评分 agent 产生了什么，而不是它采取的路径。</p>
<p><strong>对于有多个组件的任务，构建部分学分</strong>。正确识别问题并验证客户但未能处理退款的支持 agent，明显优于立即失败的 agent。在结果中表示这种成功的连续性很重要。</p>
<p>模型评分通常需要仔细迭代以验证准确性。LLM-as-judge 评分器应与人类专家密切校准，以确信人工评分和模型评分之间几乎没有差异。为避免幻觉，给 LLM 一个出路，如提供指令在信息不足时返回"Unknown"。创建清晰、结构化的评分标准来评分任务的每个维度，然后用隔离的 LLM-as-judge 评分每个维度，而不是用一个来评分所有维度，这也有帮助。一旦系统健壮，只需偶尔使用人工审查。</p>
<p>一些评估有微妙的失败模式，即使 agent 性能良好也会导致低分，因为 agent 由于评分 bug、agent 框架约束或歧义而未能解决任务。即使是经验丰富的团队也可能错过这些问题。例如，<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fsayashk%2Fstatus%2F1996334941832089732%3Fs%3D46%26t%3Dc5pEvnVdVbMkcR_rcCHplg" target="_blank" title="https://x.com/sayashk/status/1996334941832089732?s=46&amp;t=c5pEvnVdVbMkcR_rcCHplg" ref="nofollow noopener noreferrer">Opus 4.5 最初在 CORE-Bench 上得分 42%</a>，直到 Anthropic 研究员发现多个问题：严格的评分在预期"96.124991…"时惩罚"96.12"、模糊的任务规格、以及无法精确重现的随机任务。修复 bug 并使用限制较少的 scaffold 后，Opus 4.5 的分数跃升至 95%。同样，<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fmetr_evals%2Fstatus%2F2001473506442375645%3Fs%3D46" target="_blank" title="https://x.com/metr_evals/status/2001473506442375645?s=46" ref="nofollow noopener noreferrer">METR 发现</a>他们时间范围基准中几个配置错误的任务要求 agents 优化到规定的分数阈值，但评分要求超过该阈值。这惩罚了像 Claude 这样遵循指令的模型，而忽略规定目标的模型获得了更好的分数。仔细检查任务和评分器可以帮助避免这些问题。</p>
<p>使你的评分器抵抗绕过或黑客攻击。Agent 不应能够轻易"作弊"评估。任务和评分器应设计成通过真正需要解决问题而不是利用意外漏洞。</p>
<h4 data-id="heading-15">长期维护和使用评估</h4>
<p><strong>步骤 6：检查记录</strong></p>
<p>除非你阅读许多试验的记录和评分，否则你不会知道评分器是否运行良好。在 Anthropic，我们投资了用于查看评估记录的工具，并定期花时间阅读它们。当任务失败时，记录会告诉你 agent 是犯了真正的错误还是你的评分器拒绝了有效的解决方案。它还经常揭示关于 agent 和评估行为的关键细节。</p>
<p>失败应该看起来是公平的：很清楚 agent 做错了什么以及为什么。当分数没有攀升时，我们需要确信这是由于 agent 性能而不是评估本身。阅读记录是你验证评估正在衡量真正重要的东西的方式，也是 agent 开发的关键技能。</p>
<p><strong>步骤 7：监控能力评估饱和</strong></p>
<p>100% 的评估可以跟踪回归但不提供改进信号。当 agent 通过所有可解决的任务时，就会发生 <strong>评估饱和</strong>，没有改进空间。例如，SWE-Bench Verified 分数今年从 30% 开始，前沿模型现在接近 &gt;80% 的饱和。随着评估接近饱和，进展也会放缓，因为只剩下最困难的任务。这可能使结果具有欺骗性，因为大的能力改进表现为小的分数增加。例如，代码审查初创公司 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.qodo.ai%2F" target="_blank" title="https://www.qodo.ai/" ref="nofollow noopener noreferrer">Qodo</a> 最初对 Opus 4.5 印象不深，因为他们的 one-shot coding 评估没有捕捉到在更长、更复杂任务上的收益。作为回应，他们开发了新的 agentic 评估框架，提供了更清晰的进展图景。</p>
<p>作为规则，在有人深入研究评估细节并阅读一些记录之前，我们不会把评估分数当真。如果评分不公平、任务模糊、有效解决方案受到惩罚，或者框架限制了模型，评估应该修订。</p>
<p><strong>步骤 8：通过开放贡献和维护保持评估套件长期健康</strong></p>
<p>评估套件是一个活的工件，需要持续关注和明确的所有权才能保持有用。</p>
<p>在 Anthropic，我们尝试了各种评估维护方法。事实证明最有效的是建立专门的评估团队来拥有核心基础设施，而领域专家和产品团队贡献大多数评估任务并自己运行评估。</p>
<p>对于 AI 产品团队，拥有和迭代评估应该像维护单元测试一样成为常规。团队可能在早期测试中"有效"的 AI 功能上浪费数周时间，但未能满足设计良好的评估本应早期发现的未明确的期望。定义评估任务是压力测试产品需求是否足够具体以开始构建的最佳方式之一。</p>
<p>我们建议实践评估驱动的开发：在 agents 能够实现计划能力之前构建评估来定义它们，然后迭代直到 agent 表现良好。在内部，我们经常构建今天"足够好"但押注于几个月后模型能做什么的功能。从低通过率开始的能力评估使这一点可见。当新模型发布时，运行套件可以快速揭示哪些押注得到了回报。</p>
<p>最接近产品需求和用户的人最有资格定义成功。以当前模型能力，产品经理、客户成功经理或销售人员可以使用 Claude Code 以 PR 的形式贡献评估任务——让他们做！或者更好的是，积极地支持他们。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c04cef81f269477cb2d111fe2a49bd3a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646346&amp;x-signature=O3Ac1%2Bl7eSZpgqsvfdjbjvhyqjM%3D" alt="" loading="lazy"/></p>
<p><em>创建有效评估的过程。</em></p>
<h3 data-id="heading-16">评估如何与其他方法配合以全面理解 Agents</h3>
<p>自动化评估可以在数千个任务中针对 agent 运行，无需部署到生产环境或影响真实用户。但这只是理解 agent 性能的众多方式之一。完整的图景包括生产监控、用户反馈、A/B 测试、手动记录审查和系统化人工评估。</p>















































<table><thead><tr><th>理解 AI Agent 性能的方法概述</th><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>自动化评估</td><td>无需真实用户即可以编程方式运行测试</td><td>更快迭代<br/>完全可重现<br/>无用户影响<br/>可在每次提交时运行<br/>无需生产部署即可大规模测试场景</td><td>需要更多前期投资来构建<br/>随着产品和模型演进需要持续维护以避免漂移<br/>如果不匹配真实使用模式可能产生虚假信心</td></tr><tr><td>生产监控</td><td>在实时系统中跟踪指标和错误</td><td>大规模揭示真实用户行为<br/>捕捉合成评估遗漏的问题<br/>提供 agents 实际表现的基准真相</td><td>被动，问题在你知道之前就影响了用户<br/>信号可能有噪音<br/>需要投资工具<br/>缺乏评分的基准真相</td></tr><tr><td>A/B 测试</td><td>用真实用户流量比较变体</td><td>衡量实际用户结果（留存、任务完成）<br/>控制混淆因素<br/>可扩展且系统化</td><td>慢，需要数天或数周才能达到显著性并需要足够的流量<br/>只测试你部署的变更<br/>在不能彻底审查记录的情况下对指标变化的底层"为什么"信号较少</td></tr><tr><td>用户反馈</td><td>明确的信号，如点踩或 bug 报告</td><td>发现你没有预料到的问题<br/>来自真实人类用户的真实示例<br/>反馈通常与产品目标相关</td><td>稀疏且自选择<br/>偏向严重问题<br/>用户很少解释 <em>为什么</em> 某事失败<br/>非自动化<br/>主要依赖用户发现问题可能对用户产生负面影响</td></tr><tr><td>手动记录审查</td><td>人类阅读 agent 对话</td><td>建立对失败模式的直觉<br/>捕捉自动检查遗漏的微妙质量问题<br/>帮助校准什么是"好"并掌握细节</td><td>耗时<br/>不可扩展<br/>覆盖不一致<br/>审查者疲劳或不同审查者可能影响信号质量<br/>通常只提供定性信号而非清晰的定量评分</td></tr><tr><td>系统化人工研究</td><td>由训练有素的评分员对 agent 输出进行结构化评分</td><td>来自多位人类评分员的金标准质量判断<br/>处理主观或模糊的任务<br/>为改进基于模型的评分器提供信号</td><td>相对昂贵且周转慢<br/>难以频繁运行<br/>评分者间分歧需要调和<br/>复杂领域（法律、金融、医疗）需要人类专家进行研究</td></tr></tbody></table>
<p>这些方法映射到 agent 开发的不同阶段。自动化评估在发布前和 CI/CD 中特别有用，在每次 agent 变更和模型升级时作为质量问题的第一道防线运行。生产监控在发布后启动，检测分布漂移和意外的真实世界故障。A/B 测试在你有足够流量后验证重大变更。用户反馈和记录审查是持续的实践来填补空白——持续分类反馈，每周抽样阅读记录，并根据需要深入挖掘。将系统化人工研究保留用于校准 LLM 评分器或评估以人类共识作为参考标准的主观输出。</p>
<p>像安全工程中的<a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSwiss_cheese_model" target="_blank" title="https://en.wikipedia.org/wiki/Swiss_cheese_model" ref="nofollow noopener noreferrer">瑞士奶酪模型</a>一样，没有单一的评估层能捕捉到每个问题。结合多种方法，穿过一层的失败会被另一层捕获。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7eafcff341ad460ea0b8ad1bf21c1804~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646346&amp;x-signature=jUPgMr%2BSKLNLOmXOzD6UOmgGnJE%3D" alt="" loading="lazy"/></p>
<p>最有效的团队结合这些方法——自动化评估用于快速迭代，生产监控用于基准真相，定期人工审查用于校准。</p>
<h3 data-id="heading-17">结论</h3>
<p>没有评估的团队陷入被动循环——修复一个故障，引发另一个，无法区分真正的回归和噪音。早期投资的团队发现相反的情况：随着失败变成测试用例、测试用例防止回归、指标取代猜测，开发加速。评估给整个团队一个明确的攀登目标，将"agent 感觉变差了"变成可操作的东西。价值会复合，但前提是你把评估当作核心组件而不是事后想法。</p>
<p>模式因 agent 类型而异，但这里描述的基础是不变的。尽早开始，不要等待完美的套件。从你看到的失败中获取真实任务。定义无歧义、健壮的成功标准。精心设计评分器并结合多种类型。确保问题对模型来说足够难。迭代评估以提高其信噪比。阅读记录！</p>
<p>AI agent 评估仍然是一个新兴、快速发展的领域。随着 agents 承担更长的任务、在多 agent 系统中协作、处理越来越主观的工作，我们需要调整我们的技术。我们将继续分享学到的最佳实践。</p>
<h4 data-id="heading-18">致谢</h4>
<p>作者：Mikaela Grace、Jeremy Hadfield、Rodrigo Olivares 和 Jiri De Jonghe。我们也感谢 David Hershey、Gian Segato、Mike Merrill、Alex Shaw、Nicholas Carlini、Ethan Dixon、Pedram Navid、Jake Eaton、Alyssa Baum、Lina Tawfik、Karen Zhou、Alexander Bricken、Sam Kennedy、Robert Ying 等人的贡献。特别感谢我们通过评估合作中学习的客户和合作伙伴，包括 iGent、Cognition、Bolt、Sierra、Vals.ai、Macroscope、PromptLayer、Stripe、Shopify、Terminal Bench 团队等。这项工作反映了帮助在 Anthropic 发展评估实践的多个团队的集体努力。</p>
<h3 data-id="heading-19">附录：评估框架</h3>
<p>几个开源和商业框架可以帮助团队实施 agent 评估，而无需从头构建基础设施。正确的选择取决于你的 agent 类型、现有技术栈，以及你是否需要离线评估、生产可观察性或两者兼有。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fharborframework.com%2F" target="_blank" title="https://harborframework.com/" ref="nofollow noopener noreferrer">Harbor</a> 专为在容器化环境中运行 agents 设计，具有跨云提供商大规模运行试验的基础设施和定义任务与评分器的标准化格式。流行的基准如 Terminal-Bench 2.0 通过 Harbor 注册表发布，使得运行已建立的基准以及自定义评估套件变得容易。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.promptfoo.dev%2F" target="_blank" title="https://www.promptfoo.dev/" ref="nofollow noopener noreferrer">Promptfoo</a> 是一个轻量级、灵活的开源框架，专注于用于提示测试的声明式 YAML 配置，断言类型从字符串匹配到 LLM-as-judge 评分标准。我们在许多产品评估中使用 Promptfoo 的一个版本。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.braintrust.dev%2F" target="_blank" title="https://www.braintrust.dev/" ref="nofollow noopener noreferrer">Braintrust</a> 是一个将离线评估与生产可观察性和实验跟踪相结合的平台——对需要在开发期间迭代和监控生产质量的团队很有用。其 <code>autoevals</code> 库包含用于事实性、相关性和其他常见维度的预构建评分器。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.langchain.com%2Flangsmith%2Fevaluation" target="_blank" title="https://docs.langchain.com/langsmith/evaluation" ref="nofollow noopener noreferrer">LangSmith</a> 提供追踪、离线和在线评估以及数据集管理，与 LangChain 生态系统紧密集成。<a href="https://link.juejin.cn?target=https%3A%2F%2Flangfuse.com%2F" target="_blank" title="https://langfuse.com/" ref="nofollow noopener noreferrer">Langfuse</a> 为有数据驻留要求的团队提供类似的功能，作为自托管的开源替代方案。</p>
<p>许多团队结合使用多种工具，自己构建评估框架，或只是使用简单的评估脚本作为起点。我们发现，虽然框架可以是加速进展和标准化的有价值方式，但它们的好坏取决于你通过它们运行的评估任务。通常最好快速选择一个适合你工作流程的框架，然后将精力投入到评估本身——通过迭代高质量的测试用例和评分器。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[VPS交易避坑指南：原油、改邮、PUSH与交易所模式深度解析 (含搬瓦工/DMIT/NetCup实战)]]></title>    <link>https://juejin.cn/post/7593338828217450511</link>    <guid>https://juejin.cn/post/7593338828217450511</guid>    <pubDate>2026-01-10T10:39:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7593338828217450511" data-draft-id="7593258683750989858" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="VPS交易避坑指南：原油、改邮、PUSH与交易所模式深度解析 (含搬瓦工/DMIT/NetCup实战)"/> <meta itemprop="keywords" content="服务器"/> <meta itemprop="datePublished" content="2026-01-10T10:39:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="墨风如雪"/> <meta itemprop="url" content="https://juejin.cn/user/4064249017803927"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            VPS交易避坑指南：原油、改邮、PUSH与交易所模式深度解析 (含搬瓦工/DMIT/NetCup实战)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4064249017803927/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    墨风如雪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-10T10:39:44.000Z" title="Sat Jan 10 2026 10:39:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 VPS 交易（MJJ 圈子）中，我们通常会遇到四种主要的交易模式。不同的商家政策和交接方式，决定了账号的安全性和交易价值。</p>
<p>本文将为您详细拆解这四种模式（原邮、改邮、官方 PUSH、交易所），并结合 <strong>搬瓦工、DMIT、NetCup、RackNerd</strong> 等代表性商家进行分析。</p>
<hr/>
<h2 data-id="heading-0">第一种：原邮</h2>
<p><strong>定义：</strong>
“原邮”（圈内常称“原油”）指的是用户在 VPS 商家注册账号时第一次使用的邮箱账户。通常是 Outlook、Gmail 或自建邮局账号。</p>
<ul>
<li><strong>特征</strong>：邮箱内通常保留着商家发送的第一封“Welcome”欢迎邮件。</li>
<li><strong>风险</strong>：交易时涉及移交邮箱账号本身，因此必须考虑邮箱被找回的风险。</li>
</ul>
<h3 data-id="heading-1">1. Outlook 邮箱的安全清洗</h3>
<p>如果是 Outlook 邮箱，在接收账号后必须进行彻底的防找回设置。我之前专门写过一篇教程：</p>
<blockquote>
<p><strong>文章地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.legacyvps.com%2Farchives%2Foutlook-account-security-guide-prevent-recovery-mjj" target="_blank" title="https://www.legacyvps.com/archives/outlook-account-security-guide-prevent-recovery-mjj" ref="nofollow noopener noreferrer">拒绝被找回！MJJ必修课：Outlook邮箱交易后的“防回手”安全设置全攻略</a></p>
</blockquote>
<h3 data-id="heading-2">2. 代表商家：搬瓦工 (BandwagonHost)</h3>
<p>搬瓦工的交易一般分成两种，分为“原油”和“改邮”两种，这两个在交易的时候容易价格方面差距明显：</p>
<ul>
<li><strong>带原邮</strong>：最安全，价格最高。没有找回的风险，也是交易的时候最受欢迎的。</li>
<li><strong>改邮</strong>：有很高的风险。因为搬瓦工的机器账户可以通过“原始邮箱”和“支付凭证”进行申诉找回。如果买到的是没有原始邮箱的改邮账号，很有可能被第一任号主，也就是原始邮箱的拥有者 “毁号”或“找回”的风险，因为有的搬瓦工账户被交易了很多次，追踪第一任号主有的时候是一件很麻烦的事情。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c64870d29444941a0209db08b43b913~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646383&amp;x-signature=S%2FUCiVt0NL%2FROLcWgqaTR41OvQM%3D" alt="image" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-3">第二种：改邮（修改绑定邮箱）</h2>
<p><strong>定义：</strong>
“改邮”是指在 VPS 商家后台将账户绑定的邮箱地址更改为买家的新邮箱。这通常意味着账户归属权的变更。</p>
<p>与搬瓦工不同，对于大多数支持改邮的商家，只要官方允许修改，交易通常是安全的。</p>
<h3 data-id="heading-4">1. 代表商家一：DMIT</h3>
<p>DMIT 可以通过后台修改邮箱界面完成账户邮箱的修改。</p>
<ul>
<li><strong>需要注意的是</strong>：新注册的账户或新购买的机器自带 <strong>10天冷却期</strong>。在此期间无法修改邮箱或转移机器（这是我曾在交易新机时踩过的坑）。</li>
<li><strong>安全建议</strong>：DMIT 改邮后基本无找回风险，具体操作可参考我的另一篇文章。</li>
</ul>
<blockquote>
<p><strong>🔗 文章地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.legacyvps.com%2Farchives%2Fdmit-account-transfer-change-email-guide-maximize-value" target="_blank" title="https://www.legacyvps.com/archives/dmit-account-transfer-change-email-guide-maximize-value" ref="nofollow noopener noreferrer">DMIT 账户交易完全指南：如何修改邮箱安全过户 &amp; 为什么“一号一机”最值钱？</a></p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b82bd3f28a104b8cbc04f48ea348f133~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646383&amp;x-signature=c1lTVULIulvqy%2BFk87qLLAlt4BA%3D" alt="image" loading="lazy"/></p>
<h3 data-id="heading-5">2. 代表商家二：RackNerd</h3>
<p>RackNerd 除了部分特定的闪购套餐（Flash Sale）会限制修改邮箱，大多数套餐的账户都可以通过<strong>发工单</strong>的方式申请修改绑定的邮箱，但是一般只能修改一次，如果次数过多可能要求，使用官方的PUSH（需要收费，一次<strong>8美元</strong>)。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bce6ed4268594c1ca07f5f7e7764b273~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646383&amp;x-signature=n%2Be3Tn%2BomC2IKWAgv025RjF5LoQ%3D" alt="image" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">第三种：官方 PUSH（最稳妥）</h2>
<p><strong>定义：</strong>
官方 PUSH 是指通过商家提供的平台功能，将账号内的<strong>某一台特定机器</strong>转移（Push）到买家的账号下。</p>
<ul>
<li><strong>优势</strong>：只涉及机器转移，不涉及账号、密码和原始邮箱的交接。这是三种方式中最稳妥、最方便的。</li>
</ul>
<h3 data-id="heading-7">1. 代表商家一：NetCup</h3>
<p>NetCup 提供了非常成熟的过户机制，这家的交易我想大家都应该很熟悉了，通过转移码完成机器的过户操作。</p>
<ul>
<li><strong>费用</strong>：免费。</li>
<li><strong>条件</strong>：必须付清当前季度的账单。</li>
<li><strong>操作</strong>：卖家在后台生成转移码，买家输入即可接收，怕大家不知道，我这里加上了我以前写的教学文章。</li>
</ul>
<blockquote>
<p><strong>🔗 文章地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.legacyvps.com%2Farchives%2Fhow-to-transfer-push-netcup-vps-guide" target="_blank" title="https://www.legacyvps.com/archives/how-to-transfer-push-netcup-vps-guide" ref="nofollow noopener noreferrer">Netcup VPS 过户全攻略：手把手教你如何安全地将服务器 Push 给新用户</a></p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f5d0b333bc394c8b8da57dd9ad77fd69~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646383&amp;x-signature=lRA%2FHAlYdv4rf1eONtWXuruGyQs%3D" alt="image" loading="lazy"/></p>
<h3 data-id="heading-8">2. 代表商家二：RackNerd</h3>
<ul>
<li><strong>费用</strong>：RackNerd 的 Push 费用是 <strong>$8</strong>，通过提交工单的方式完成机器的过户。</li>
<li><strong>需要注意的</strong>：RN 的 Push 费用是按<strong>次数（工单）<strong>收费，而不是按</strong>台数</strong>收费。如果你一次性 Push 多台机器给同一个账号，只需要支付一次 $8，所以如果一次性转移多台机器到另一个账户还是很划算的，转移的时候需要提供对方账户的邮箱地址。</li>
</ul>
<hr/>
<h2 data-id="heading-9">第四种：交易所交易</h2>
<p><strong>定义：</strong>
这是一种相对少见的模式，等于把你的机器放在商家内部的交易平台上。</p>
<ul>
<li><strong>操作</strong>：卖家设置好机器信息和价格，买家购买。也可以私下商定好价格，通过交易所指定 ID 或时间锁定机器完成交易。</li>
<li><strong>特点</strong>：官方的交易平台，还是有保障的，但是比较坑的是，部分商家可能会收取手续费，且卖出的资金不能立即到账，需要先提现到余额，然后再提现到你的对应支付宝或者微信账户，等待周期长提现时间不可控，还可能收取多笔手续费，很不划算。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc240302ecc54850bb10df419156cc53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768646383&amp;x-signature=NYnotkxQk3ArdMycJapmUlKXAEE%3D" alt="image" loading="lazy"/></p>
<h3 data-id="heading-10">代表商家（仅作知识扩展）</h3>
<ul>
<li><strong>Akile</strong></li>
<li><strong>狐蒂云</strong></li>
<li><em>注：这里不是打广告，仅为了告诉小白一种比较少的交易形式。</em></li>
</ul>
<hr/>
<h3 data-id="heading-11">💡 总结与建议</h3>
<ul>
<li><strong>追求相对安全</strong>：首选 <strong>官方 PUSH</strong> 因为官方提供的PUSH服务是有保障的，不会出现邮箱找回，或者账户被找回，泄露自己账户信息（很多原油交易的账户还绑定了银行卡或者PayPal的自动续费，给自己和他人造成麻烦）。</li>
</ul>
<blockquote>
<p>交易的原油的时候，记得解绑自己的交易信息，防止被无故扣钱。</p>
</blockquote>
<ul>
<li><strong>有原油要原油</strong>：比如搬瓦工这类的商家，能有原油交易肯定是 <strong>原邮</strong>，因为不容易出现问题，你下次交易也方便，不会留下隐患，下次交易也可以直接给别人邮箱账户，让他自己完成解绑你也方便。</li>
<li><strong>改邮不是不可用需要看清楚</strong>：<strong>改邮</strong> 通常也是安全的，但是需要分清楚商家，也要注意商家的修改邮箱的规则，比如DMIT不是随时都可以修改，有10天的冷静期，自己在频繁交易的时候注意账户安全和平台限制。</li>
</ul>
<h3 data-id="heading-12">如果觉得文章好，可以关注<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.legacyvps.com%2F" target="_blank" title="https://www.legacyvps.com/" ref="nofollow noopener noreferrer">传家宝VPS</a></h3>
<blockquote>
<p>原文地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.legacyvps.com%2Farchives%2Fvps-trading-guide-original-email-push-marketplace" target="_blank" title="https://www.legacyvps.com/archives/vps-trading-guide-original-email-push-marketplace" ref="nofollow noopener noreferrer">www.legacyvps.com/archives/vp…</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>