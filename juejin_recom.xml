<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[配置技巧｜GoLand 用户如何丝滑使用 TRAE]]></title>    <link>https://juejin.cn/post/7605792874173907007</link>    <guid>https://juejin.cn/post/7605792874173907007</guid>    <pubDate>2026-02-13T06:10:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605792874173907007" data-draft-id="7605985547569201158" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="配置技巧｜GoLand 用户如何丝滑使用 TRAE"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2026-02-13T06:10:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="TRAE_ai"/> <meta itemprop="url" content="https://juejin.cn/user/3048259110571032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            配置技巧｜GoLand 用户如何丝滑使用 TRAE
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3048259110571032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    TRAE_ai
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:10:44.000Z" title="Fri Feb 13 2026 06:10:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb807a53b5e3484f99da3a5013e7f413~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=v3U3aZPGRBsR4p5DD%2BzSHUjun2c%3D" alt="" loading="lazy"/></p>
<blockquote>
<p>本文作者：张铎，TRAE 开发者用户</p>
</blockquote>
<p><strong>本文以 GoLand 为例，其他 JetBrains 系列 IDE 的配置也可以参考使用。</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21430df326be417ea5735eaca4ebb578~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=ctz8R%2FA66Dqn7NKG5nR1VP7Ahnk%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0"><strong>前言</strong></h2>
<p>对于不少开发 Go 语言的同学而言，GoLand 是最为熟悉的一把“单兵利器”，作为 JetBrains 全家桶的一员，它在编辑、开发、调试等方面，延续了 IDEA、PyCharm 等产品一贯的开箱即用体验。</p>
<p>不少习惯了 JetBrains 系列的同学，初次上手 TRAE IDE 时可能一时难以适应偏 VS Code 风格的编辑体验，不得不在 TRAE 和原本使用的 IDE 之间频繁来回切换。</p>
<p>其实要改变这一点并不难。只要做几处简单的配置和调整，就能让你的 TRAE IDE 在使用体验上更接近 GoLand。本文把我自己的一些心得整理了一下，分享给大家，希望能对你有一点帮助。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0be1c7870af940c8889e3bd29f2afa7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=stu9ejlzOBMzw2uy6mhkiVAMTnk%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1"><strong>UI 外观与布局</strong></h2>
<p>想要有熟悉的 GoLand 味道，颜值和配色都很关键。我们先从视觉和布局入手。</p>
<h3 data-id="heading-2"><strong>主题与图标</strong></h3>
<p>TRAE 无缝支持大部分的原生 VS Code 插件。通过安装插件，你就可以轻松一键 get GoLand 的经典 Darcula 暗色系外观。可以获得与 GoLand 几乎一致的视觉风格，包括编辑器配色和文件树图标，带来亲切的视觉感受。</p>
<ul>
<li>
<p><strong>插件安装指南</strong></p>
<p>TRAE 本质上共享 VS Code 插件库，这里简述一下插件的安装方式，后文不再赘述：通过点击「首选项-扩展」或 <em><strong>Shift+Command+X</strong></em> 组合键打开插件市场，并搜索插件名，即可直接安装。</p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5cf4f3bd926453eb7d8ff2af6644623~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=UdTnEgAPAF3dNHVVAwVijhVapzk%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/089507563e864924a9e54ff05a8ca1a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=%2FBLJO3pJ6PnVIk1t5X8s9MnOT58%3D" alt="" loading="lazy"/></p>
<ul>
<li>
<p><strong>JetBrains 颜色主题：</strong></p>
<p>JetBrains Darcula Theme  配置后可以获得 Jetbrains 同款编辑器配色</p>
</li>
<li>
<p><strong>JetBrains 文件图标：</strong></p>
<p>JetBrains Icon Theme 配置后可获得 Jetbrains 同款 Icon 配色</p>
</li>
</ul>
<p>示例 （<em><strong>settings.json</strong></em>）：安装后，在主题设置中选择对应主题，或直接在 JSON 中指定。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c943b5e17c846de837dc3c7d091c278~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=ICgyukfj8ejOTquxknVduCMzxaU%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"workbench.ColorTheme"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JetBrains Darcula Theme"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"workbench.IconTheme"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"jetbrains-icon-theme"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>可选 （微调）</strong> ：如果你觉得默认主题颜色过深或过浅，可以通过 <em><strong>colorCustomizations</strong></em> 微调，更精确地复刻 GoLand 色值。</p>
<pre><code class="hljs language-css" lang="css">{
    "workbench<span class="hljs-selector-class">.colorCustomizations</span>": {
        "<span class="hljs-selector-attr">[JetBrains Darcula Theme]</span>": {
            "editor<span class="hljs-selector-class">.background</span>": <span class="hljs-string">"#2B2B2B"</span>,
            <span class="hljs-string">"sideBar.background"</span>: <span class="hljs-string">"#3C3F41"</span>,
            <span class="hljs-string">"activityBar.background"</span>: <span class="hljs-string">"#3C3F41"</span>,
            <span class="hljs-string">"statusBar.background"</span>: <span class="hljs-string">"#3C3F41"</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-3"><strong>字体与行高</strong></h3>
<p>可以使用 JetBrains 官方字体 <strong>JetBrains Mono</strong>，它为代码阅读做了专门优化。</p>
<ul>
<li>
<p><strong>下载与安装：</strong> JetBrains Mono 官网 </p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2Fmono%2F" target="_blank" title="https://www.jetbrains.com/mono/" ref="nofollow noopener noreferrer">www.jetbrains.com/mono/</a></p>
</li>
</ul>
<p><strong>示例</strong> （<em><strong>settings.json</strong></em>）：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"editor.fontFamily"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JetBrains Mono, Menlo, Monaco, 'Courier New', monospace"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"editor.fontSize"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">14</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"editor.lineHeight"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.6</span><span class="hljs-punctuation">,</span>
    <span class="hljs-comment">// 建议终端也使用相同字体，保持视觉统一</span>
    <span class="hljs-attr">"terminal.integrated.fontFamily"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JetBrains Mono"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-4"><strong>面板与布局习惯</strong></h3>
<p>在 GoLand 中，大家通常习惯于一个高度集成的视图，主界面应包含清晰的项目树、代码大纲、问题诊断、调试控制台和终端等，从而形成一个高效的工作闭环。在 TRAE 中也可以做相似的布局配置</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a18072cd5614ea8b869a7abe4103020~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=%2Bq%2BohF2MAUz6pBrVqFvxFWZEYPw%3D" alt="" loading="lazy"/></p>
<p><strong>建议 （布局设置）：</strong></p>
<ul>
<li>
<p><strong>左侧：资源管理器 （Explorer）</strong> ，并在其下方或旁边放置 <strong>大纲 （Outline）</strong> 视图。</p>
</li>
<li>
<p><strong>底部面板：</strong> 通过 **<em>⌘J （Cmd+J）</em> **或 <em><strong>Ctrl+J</strong></em> 切换显示/隐藏，常用的标签页包括 <strong>问题 （Problems）、输出 （Output）、调试控制台 （Debug Console）</strong> 和 <strong>终端 （Terminal）</strong> 。</p>
</li>
<li>
<p><strong>右侧：</strong> 代码编辑区。</p>
</li>
</ul>
<p><strong>建议 （快捷开关）：</strong> 熟练使用快捷键来控制面板，可以极大提升效率。</p>
<ul>
<li>
<p><em><strong>⇧⌘E</strong></em> （Shift+Cmd+E）：切换到资源管理器</p>
</li>
<li>
<p><em><strong>⇧⌘P</strong></em> （Shift+Cmd+P）：打开命令面板 （Command Palette），一切操作的入口</p>
</li>
<li>
<p><em><strong>⌘J</strong></em> （Cmd+J）：切换底部面板的显示与隐藏</p>
</li>
<li>
<p><em><strong>⇧⌘M</strong></em> （Shift+Cmd+M）：切换到问题面板</p>
</li>
</ul>
<h3 data-id="heading-5"><strong>阅读体验优化</strong></h3>
<p><strong>建议：</strong> 为了提高代码阅读体验，开启以下 <em><strong>settings.json</strong></em> 选项，让代码阅读更舒适。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-comment">// 在滚动时，让当前代码块的父结构（如函数、结构体）吸附在顶部</span>
    <span class="hljs-attr">"editor.stickyScroll.enabled"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-comment">// 在编辑器顶部显示文件路径和符号路径，方便定位</span>
    <span class="hljs-attr">"breadcrumbs.enabled"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-comment">// 括号对着色，便于区分</span>
    <span class="hljs-attr">"editor.bracketPairColorization.enabled"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>Unicode 高亮</strong></p>
<ul>
<li>
<p><strong>现象：</strong> 如果代码中需要出现中文冒号、括号等字符，会被黄色波浪线警告，看起来可能会有点恼人。</p>
</li>
<li>
<p><strong>解决：</strong> 在 <em><strong>settings.json</strong></em> 中设置 <em><strong>"editor.unicodeHighlight.ambiguousCharacters": false</strong></em>。</p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/704f58772a9e409698df1d5696235dea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=vSxAx9jXBNeIvBliIgym3j9C%2BiI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6"><strong>快捷键与导航</strong></h2>
<p>通常切换快捷键组合的适应成本是比较高的，我们可以通过一些配置，让操作习惯从 GoLand 无缝迁移过来。</p>
<h3 data-id="heading-7"><strong>快捷键映射插件</strong></h3>
<p><strong>建议：</strong> 最新版 TRAE 已经支持<strong>一键导入 Jetbrains 风格快捷键</strong>，可自行在偏好设置中直接进行修改，选择自己所需的快捷键键位（目前支持 VS Code / JetBrains 两种快捷键风格切换）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/158fbea412c741a8b04760a9c2fb66f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=NHouiyDX02%2FLGPWM6%2FEtSYP%2BF9k%3D" alt="" loading="lazy"/></p>
<p>你也可以通过自行配置其他 JetBrains 键位插件，它们会将 VS Code 的快捷键替换为 JetBrains 的风格。</p>
<ul>
<li>
<p>IntelliJ IDEA Keybindings （更流行）</p>
</li>
<li>
<p>JetBrains IDE Keymap</p>
</li>
</ul>
<p><strong>注意：</strong> 配置后，TRAE 自身的一些默认快捷键（如 <em><strong>⌘K</strong></em> 系列）可能会与插件快捷键冲突。需要手动调整。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c274fb8c77924abda01a9aaa5c3f3ef9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=UOOkE5%2BVUTazcVR%2BU5utpV4OGUc%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6395c4f8600d4597ad4335db96b97f1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=VY5Ofz8XahFJ6vJRoOaPIyZxvmU%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8"><strong>快捷键冲突与自定义</strong></h3>
<p><strong>入口：</strong> 通过命令面板 （<em><strong>⇧⌘P</strong></em>） 搜索 <em>Preferences: Open Keyboard Shortcuts (JSON)</em> ，即可打开 <em><strong>keybindings.json</strong></em> 文件进行手动配置。</p>
<p><strong>冲突案例：</strong> TRAE/VS Code 的 <em><strong>⌘K</strong></em> 是一个组合键的起始，例如 <em><strong>⌘K ⌘S</strong></em> 是保存所有文件。而 JetBrains Keymap 插件会把 <em><strong>⌘K</strong></em> 映射为 <em><strong>Git Commit</strong></em>。如果你不习惯，可以在 <em><strong>keybindings.json</strong></em> 中移除或修改它。</p>
<p><strong>代码的前进后退跳转</strong></p>
<ul>
<li><strong>背景：</strong> 这是在类 VS Code 编辑器上进行代码浏览的一大痛点，GoLand 键位的前后跳转键被 bind 到了上/下一个文件上，导致跳转基本不能正常使用。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e57e3d6060840e0bb25bbc2f2026ff9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=ShQRQRC5XV94OGgOTqvTE%2FeQoPI%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c09ca40d40e54978b35c7761dcd35b77~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=B6VFYllqXBFh8hHk5B9x1fIyOVg%3D" alt="" loading="lazy"/></p>
<ul>
<li><strong>建议：</strong> 修改键位冲突，将可以通过「键盘快捷键」的<strong>按键录制能力</strong>找到对应键位的绑定，仅保留 JetBrains IDE Keymap 设定的前进/返回 定义</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af3c086d55984b219f40dd6c66bf68eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=YINUe8cNMn5ClZp2u3j3Hp6n%2Bds%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc1b441fc8b6499285b4ef0a338053ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=qxdQCEHHgzjO7capYqqMEXsYchc%3D" alt="" loading="lazy"/></p>
<p><strong>CamelHumps 驼峰式导航</strong></p>
<ul>
<li>
<p><strong>背景：</strong> 在 GoLand 中，<em><strong>⌥+←/→</strong></em> （Alt+Left/Right） 可以在驼峰命名（<em><strong>camelCase</strong></em>）的单词内部按“驼峰”进行跳转。<em><strong>IntelliJ IDEA Keybindings</strong></em> 插件也支持此功能。</p>
</li>
<li>
<p><strong>建议：</strong> 在 <em><strong>settings.json</strong></em> 中开启此选项以获得更精细的光标移动体验。</p>
</li>
</ul>

<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"intellij-idea-keybindings.useCamelHumpsWords"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-9"><strong>常用操作映射清单</strong></h3>
<p>以下是安装快捷键插件后，一些 GoLand 常用操作在 TRAE/VS Code 中的等效快捷键（以 macOS 为例）：</p>
<p>功能</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c36aa63437cc488b9db177c830d3e1ab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=8R9jGUy06srRLjBQnWgi4ATjyww%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/da7bca70aac74e1e9471317e63a32d96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=B79J3esuCPHZpSWauJHiw8vnnDs%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10"><strong>运行与调试</strong></h2>
<blockquote>
<p>本文介绍重点在 UI 设置以及一些简单配置上。更多开发能力配置技巧，欢迎参考这篇文档：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fbytetech.info%2Farticles%2F7485577423476490259%3Fclick_from%3Darticle_detail_related" target="_blank" title="https://bytetech.info/articles/7485577423476490259?click_from=article_detail_related" ref="nofollow noopener noreferrer">bytetech.info/articles/74…</a></p>
</blockquote>
<p>本地环境配置和远程调试是开发流程中的核心环节。</p>
<h3 data-id="heading-11"><strong>项目粒度的 Go 版本跟随</strong></h3>
<p>最新版 TRAE 已经支持项目粒度的 Go 语言版本绑定，可通过「设置-开发环境」为你的项目配置特定的 Go 语言版本，同时推荐打开 TRAE goapls，经过深度优化，可显著降低大型 Go 项目的内存占用，提升索引性能</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e08a8700de148dea14c6f63b9975b76~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=m95%2BZR8Rc6LW399YNRfCIxGsgtY%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-12"><strong>基础调试配置</strong></h3>
<p><strong>目的：</strong> 配置 <em><strong>launch.json</strong></em> 文件来定义不同的调试场景。</p>
<p><strong>Tips：</strong> 在“运行和调试”面板，点击“创建 launch.json 文件”，TRAE 会为你生成一个基础模板。</p>
<p><strong>示例</strong> （ <em><strong>.vscode/launch.json</strong></em>）</p>
<pre><code class="hljs language-perl" lang="perl">{
    <span class="hljs-string">"version"</span>: <span class="hljs-string">"0.2.0"</span>,
    <span class="hljs-string">"configurations"</span>: [
        {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"启动主服务"</span>,
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"go"</span>,
            <span class="hljs-string">"request"</span>: <span class="hljs-string">"launch"</span>,
            <span class="hljs-regexp">//</span> 坑位：建议写死为 <span class="hljs-string">'debug'</span>，避免 <span class="hljs-string">'auto'</span> 模式在非 main 包文件下误判为 test，导致报错 “<span class="hljs-keyword">not</span> an executable file”。
            <span class="hljs-string">"mode"</span>: <span class="hljs-string">"debug"</span>,
            <span class="hljs-string">"program"</span>: <span class="hljs-string">"<span class="hljs-subst">${workspaceFolder}</span>"</span>, <span class="hljs-regexp">//</span> 运行整个项目
            <span class="hljs-string">"envFile"</span>: <span class="hljs-string">"<span class="hljs-subst">${workspaceFolder}</span>/.env"</span> // 加载 .env 文件中的环境变量
        },
        {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"运行当前文件"</span>,
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"go"</span>,
            <span class="hljs-string">"request"</span>: <span class="hljs-string">"launch"</span>,
            <span class="hljs-string">"mode"</span>: <span class="hljs-string">"debug"</span>,
            <span class="hljs-string">"program"</span>: <span class="hljs-string">"<span class="hljs-subst">${file}</span>"</span>, <span class="hljs-regexp">//</span> 仅运行当前打开的文件 (需为 main 包)
            <span class="hljs-string">"envFile"</span>: <span class="hljs-string">"<span class="hljs-subst">${workspaceFolder}</span>/.env"</span>
        }
    ]
}
</code></pre>
<h3 data-id="heading-13"><strong>远程调试 （Attach to Process）</strong></h3>
<p><strong>配置 Delve DAP</strong></p>
<ul>
<li>
<p><strong>背景：</strong> 当需要在任意远程服务器上 <em><strong>attach</strong></em> 一个已经运行的 Go 进程时，需要手动配置。更多关于 Delve DAP 的远程调试细节，可以查阅 VSCode Go 插件的官方 Wiki （<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fvscode-go%2Fwiki%2Fdebugging%25EF%25BC%2589%25E3%2580%2582" target="_blank" title="https://github.com/golang/vscode-go/wiki/debugging%EF%BC%89%E3%80%82" ref="nofollow noopener noreferrer">github.com/golang/vsco…</a></p>
</li>
<li>
<p><strong>步骤：</strong></p>
<p><strong>在远程服务器上启动 Delve：</strong> 你需要使用 <em><strong>dlv</strong></em> 以 <em><strong>headless</strong></em> 模式启动，并监听一个端口。<em><strong>dlv --listen=:2345 --headless=true --api-version=2 exec ./your_program</strong></em></p>
<p><strong>在 TRAE 中添加</strong> <em><strong>attach</strong></em> <strong>配置：</strong></p>
</li>
</ul>
<p><strong>示例</strong> （ <em><strong>.vscode/launch.json</strong></em>）</p>
<pre><code class="hljs language-perl" lang="perl">{
    <span class="hljs-string">"configurations"</span>: [
        <span class="hljs-regexp">//</span> ... 其他配置
        {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"远程 Attach (动态IP/端口)"</span>,
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"go"</span>,
            <span class="hljs-string">"request"</span>: <span class="hljs-string">"attach"</span>,
            <span class="hljs-string">"mode"</span>: <span class="hljs-string">"remote"</span>,
            <span class="hljs-regexp">//</span> 坑位：<span class="hljs-string">`remotePath`</span> 必须是远程服务器上代码的绝对路径。
            <span class="hljs-string">"remotePath"</span>: <span class="hljs-string">"/path/to/your/project/on/remote"</span>, 
            <span class="hljs-regexp">//</span> 使用 inputs 实现动态输入，避免硬编码
            <span class="hljs-string">"host"</span>: <span class="hljs-string">"<span class="hljs-subst">${input:debug_host}</span>"</span>,
            <span class="hljs-string">"port"</span>: <span class="hljs-string">"<span class="hljs-subst">${input:debug_port}</span>"</span>,
            <span class="hljs-regexp">//</span> 关键：substitutePath 用于映射本地与远程代码路径，让断点能正确命中。
            <span class="hljs-string">"substitutePath"</span>: [
                {
                    <span class="hljs-string">"from"</span>: <span class="hljs-string">"<span class="hljs-subst">${workspaceFolder}</span>"</span>,
                    <span class="hljs-string">"to"</span>: <span class="hljs-string">"/path/to/your/project/on/remote"</span>
                }
            ]
        }
    ],
    <span class="hljs-string">"inputs"</span>: [
        {
            <span class="hljs-string">"id"</span>: <span class="hljs-string">"debug_host"</span>,
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"promptString"</span>,
            <span class="hljs-string">"description"</span>: <span class="hljs-string">"输入远程调试服务器的 IP 地址"</span>
        },
        {
            <span class="hljs-string">"id"</span>: <span class="hljs-string">"debug_port"</span>,
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"promptString"</span>,
            <span class="hljs-string">"description"</span>: <span class="hljs-string">"输入 Delve 监听的端口 (如 2345)"</span>,
            <span class="hljs-string">"default"</span>: <span class="hljs-string">"2345"</span>
        }
    ]
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01f7a3a485334b29babc22d7b4706b4c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=2PPIvciZRkYegGNKPKDrdHB5qLY%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-14"><strong>测试与覆盖率</strong></h2>
<p><strong>UI 入口：</strong> 侧边栏的 <strong>Testing</strong> 面板是 Go 测试的主战场，提供了比命令行更友好的交互体验。</p>
<ul>
<li><strong>建议：</strong> 可直接在该面板中点击运行或调试按钮来执行单个测试、包测试或整个项目的测试。</li>
</ul>
<p><strong>环境变量配置 （</strong> <em><strong>settings.json</strong></em> <strong>）：</strong></p>
<ul>
<li><strong>建议：</strong> 通过 <em><strong>go.testEnvFile</strong></em> 指定一个 <em><strong>.env</strong></em> 文件，让所有测试都能加载必要的环境变量。</li>
</ul>

<pre><code class="hljs language-kotlin" lang="kotlin">{
    <span class="hljs-string">"go.testEnvFile"</span>: <span class="hljs-string">"<span class="hljs-subst">${workspaceFolder}</span>/.env"</span>,
    <span class="hljs-string">"go.testTimeout"</span>: <span class="hljs-string">"600s"</span>,
    <span class="hljs-comment">// 建议：配置常用的 test flags</span>
    <span class="hljs-string">"go.testFlags"</span>: [
        <span class="hljs-string">"-count=1"</span>, <span class="hljs-comment">// 关闭测试缓存</span>
        <span class="hljs-string">"-v"</span>,       <span class="hljs-comment">// 显示详细输出</span>
        <span class="hljs-string">"-race"</span>     <span class="hljs-comment">// 开启竞态检测</span>
    ]
}
</code></pre>
<p><strong>测试覆盖率：</strong></p>
<ul>
<li>
<p><strong>建议：</strong> 安装 <strong>Coverage Gutters</strong> 插件。</p>
</li>
<li>
<p><strong>用法：</strong></p>
<p>在终端运行 **<em>go test -coverprofile=coverage.out ./...</em> **生成覆盖率文件。</p>
<p>点击状态栏的 <em><strong>Watch</strong></em> 按钮（由 Coverage Gutters 提供），插件会自动读取 <em><strong>coverage.out</strong></em> 文件。</p>
</li>
<li>
<p><strong>效果：</strong> 编辑器行号旁会用绿色（已覆盖）和红色（未覆盖）来标记代码行，一目了然。</p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e4a121a4ca024feebfb44a973225e950~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=XHJ2XacxvXVOpO7H0M%2FSJXtMonI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-15"><strong>规范与格式化</strong></h2>
<p>保持代码风格统一是团队协作的基础。</p>
<p><strong>格式化工具：</strong></p>
<ul>
<li>
<p><strong>建议：</strong> 使用 <em><strong>goimports</strong></em>，它能在格式化代码的同时，自动整理 <em><strong>import</strong></em> 语句。</p>
</li>
<li>
<p><strong>关键配置</strong>（<em><strong>settings.json</strong></em>） <strong>：</strong> 为了遵循公司内部代码规范，需要配置 <em><strong>gopls</strong></em> 对 <em><strong>import</strong></em> 进行分组。</p>
</li>
</ul>

<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"editor.formatOnSave"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"go.formatTool"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"goimports"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-comment">// 关键：gopls 会读取此配置，将公司/项目的包放在第三方包之后</span>
    <span class="hljs-attr">"gopls"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"formatting.local"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"code.byted.org,git.byted.org"</span>
    <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>Auto Import 实践：</strong></p>
<ul>
<li><strong>个人建议：</strong> 不开启 AI 的自动 import 功能。更稳妥的方式是，在代码中输入包名后，手动按 <em><strong>⇧⌥O</strong></em> （Shift+Alt+O， Organize Imports） 或直接 <em><strong>⌘S</strong></em> （Cmd+S） 保存，触发 <em><strong>goimports</strong></em> 自动添加。</li>
</ul>
<p><strong>静态检查 （Lint）：</strong></p>
<ul>
<li>
<p><strong>建议：</strong> 使用 <strong>golangci-lint</strong>，它是一个集成了多种 Go linter 的高性能工具。</p>
</li>
<li>
<p><strong>配置</strong> （<em><strong>settings.json</strong></em>）</p>
</li>
</ul>

<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"go.lintTool"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"golangci-lint"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-comment">// 可选：在保存时对当前文件进行 lint 检查</span>
    <span class="hljs-attr">"go.lintOnSave"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"file"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><em><strong>go.mod</strong></em> <strong>自动添加</strong> <em><strong>toolchain</strong></em></p>
<ul>
<li><strong>现象：</strong> 当项目依赖了某个需要更高 Go 版本的库时，<em><strong>go mod tidy</strong></em> 会自动在 <em><strong>go.mod</strong></em> 文件中添加 <em><strong>toolchain</strong></em> 指令，这可能不是你想要的。</li>
<li><strong>建议：</strong> 为避免此问题，建议在 <em><strong>go.mod</strong></em> 中始终使用三段式的版本号，如 <em><strong>go 1.24.0</strong></em>，而不是 <em><strong>go 1.24</strong></em>。</li>
</ul>
<p><em><strong>go.mod</strong></em> <strong>UI 差异</strong></p>
<ul>
<li><strong>Tips：</strong> 在 GoLand 中，习惯于在 <em><strong>go.mod</strong></em> 文件上右键执行 <em><strong>tidy</strong></em> 等操作。在 TRAE/VS Code 中，这些操作的入口位于打开的 <em><strong>go.mod</strong></em> 文件的顶部 CodeLens 区域（蓝色文字链接）。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/450d49b029f44dc699dae9516df6e737~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=WfFvk5C%2FePmcf3N4HgITegS%2FV%2F8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-16"><strong>Git 与 MR</strong></h2>
<p>TRAE 的 Git 操作体验与 GoLand 有所不同，但有一些配置和插件可以很好地实现相近效果。</p>
<p><strong>智能提交 （Smart Commit）：</strong></p>
<ul>
<li><strong>建议：</strong> 在 <em><strong>settings.json</strong></em> 中开启 ** <em>"git.enableSmartCommit": true</em>**。这样，在没有文件被 add 到暂存区时，直接点击提交按钮，会自动将所有已修改的文件暂存并提交，更接近 GoLand 的体验。</li>
</ul>
<p><strong>Amend &amp; Force Push:</strong></p>
<ul>
<li><strong>Amend：</strong> 在“源代码管理”面板的提交信息输入框上方，点击 ** <em>...</em> **更多操作，选择 **<em>Commit Staged (Amend)</em> **。</li>
<li><strong>Force Push：</strong> 同样在 **<em>...</em> **菜单中，选择 **<em>Push to...</em> **，然后选择带有 **<em>(force)</em> **标识的远程分支。为减少误操作，可以保留 <em><strong>git.confirmForcePush</strong></em> 为 <em><strong>true</strong></em>。</li>
</ul>
<p><strong>Git Blame Lens 插件</strong></p>
<ul>
<li>安装该插件，可以获取与 GoLand 系列类似的 git blame 体验：右键左边框点击「显示 Blame 注释」，即可显示 jetbrains 同款 git 提交展示</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d63009fd4caa42dc9a763b8f5c70dbc9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=m6JBYE5sPczE4v2TZs5RHMt8jiQ%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7f89ea3367143f3b32664781151f4cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=qnE9QtTY48wKjVdjVg1qeUQrGpY%3D" alt="" loading="lazy"/></p>
<p><strong>MR 链接：</strong></p>
<ul>
<li><strong>Tips：</strong> 当 <em><strong>git push</strong></em> 一个新分支后，创建 MR 的链接会显示在底部面板的 <strong>输出 （Output） -&gt; Git</strong> 频道里。</li>
</ul>
<p><strong>插件增强：</strong></p>
<ul>
<li>
<p><strong>Git Graph：</strong> 强烈推荐安装。提供了一个比 VS Code 自带更强大、更直观的图形化 Git 提交历史视图，非常接近 GoLand 的 Git Log 界面。</p>
</li>
<li>
<p><strong>GitLens：</strong> 功能强大，其行内 <em><strong>blame</strong></em> 功能（在当前行显示最后一次提交信息）非常实用。</p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3124096042b84b48962cc1d3c7869c0c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=%2FFWjgXGQcvBAsZ4MXm6grdtNpZg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-17"><strong>接入 MCP Server：让 TRAE 协同 GoLand 高效工作</strong></h2>
<blockquote>
<p>网址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2Fhelp%2Fidea%2Fmcp-server.html" target="_blank" title="https://www.jetbrains.com/help/idea/mcp-server.html" ref="nofollow noopener noreferrer">www.jetbrains.com/help/idea/m…</a></p>
</blockquote>
<p>Jetbrains 系列 IDE 的更新版本也提供了一组“远程 IDE 能力接口”，通过一个 MCP Server 暴露给外部客户端使用，这些工具基本覆盖了“运行、项目结构、文件与目录操作、搜索、分析与重构、终端命令、VCS 信息”等常见功能，我们通过为 TRAE 配置这些 MCP 就可以直接使用 Goland （或其他 Jetbrains IDE ） 的相关能力。目前 Jetbrains MCP 提供的能力可以归纳为以下几类：</p>
<ul>
<li>
<p><strong>运行与调试：</strong> 获取项目中的所有 <em><strong>Run Configuration</strong></em> 并执行指定的任何一个，无论是启动服务还是跑测试。</p>
</li>
<li>
<p><strong>代码分析与检查：</strong> 对指定文件运行 GoLand 的代码检查，返回错误和警告，就像在 IDE 里看到的那样。</p>
</li>
<li>
<p><strong>代码重构与修改：</strong> 执行安全可靠的 <em><strong>rename</strong></em> 重构、对文件进行格式化、或者精确替换文件内的文本。</p>
</li>
<li>
<p><strong>文件与项目探索：</strong> 在项目中按名称或 <em><strong>glob</strong></em> 模式查找文件、列出目录树、或直接在 GoLand 编辑器里打开某个文件。</p>
</li>
<li>
<p><strong>终端命令执行：</strong> 在 GoLand 内嵌的终端里执行任意 Shell 命令。</p>
</li>
<li>
<p><strong>符号与依赖查询：</strong> 获取代码中特定符号（如函数、变量）的详细信息，或列出项目的依赖项。</p>
</li>
</ul>
<h3 data-id="heading-18"><strong>配置方法</strong></h3>
<p>对于熟悉 JetBrains IDE 的开发者，启用过程非常简单：</p>
<ol>
<li>
<p>打开 GoLand，进入 <em><strong>Settings</strong></em> → <em><strong>Tools</strong></em> → <em><strong>MCP Server</strong></em>。</p>
</li>
<li>
<p>勾选 <em><strong>Enable MCP Server</strong></em>。</p>
</li>
<li>
<p>在 <em><strong>Clients Auto-Configuration</strong></em> 部分，找到你使用的 TRAE IDE，点击 <em><strong>Auto-Configure</strong></em>。</p>
</li>
<li>
<p>重启你的 AI 客户端（如 TRAE），配置即可生效。</p>
</li>
</ol>
<p>如果你的客户端不在列表中，也可以通过 <em><strong>Copy SSE Config</strong></em> 或 <em><strong>Copy Stdio Config</strong></em> 手动配置。</p>
<h3 data-id="heading-19"><strong>安全边界</strong></h3>
<p>在使用 Jetbrains MCP 相关能力时，需要了解其边界，避免不符合预期的行为：</p>
<ul>
<li>
<p><strong>“勇敢模式”（Brave Mode）：</strong> 默认情况下，执行终端命令等有风险的操作需要你在 GoLand 端手动确认。你可以在设置中开启 <em><strong>Run shell commands or run configurations without confirmation (brave mod</strong></em> **<em>e)</em> **，实现无感执行。建议仅在完全信任客户端，且主要用于执行测试、构建等常规命令时开启。</p>
</li>
<li>
<p><strong>权限与范围：</strong> 所有操作都严格限制在当前打开的项目目录内，无法访问项目外的文件系统。MCP Server 也无法读取二进制文件的内容。</p>
</li>
<li>
<p><strong>资源限制：</strong> 读取大文件或执行长时间命令会受到超时（timeout）和最大行数（maxLinesCount）的限制，返回的输出可能会被截断。</p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b8bf3a10e2ba4b199c90f5e6d701a383~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567843&amp;x-signature=SuPL3GqPGM3RAVCtFEVsaYhavbA%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-20"><strong>总结</strong></h2>
<p>通过以上这些配置技巧，希望帮助已经习惯 GoLand 的同学，把 TRAE 调整到一个 <strong>“看起来顺眼、按起来不别扭、跑起来靠谱”</strong> 的状态，把迈出“第一步”的门槛再压低一点。</p>
<p>如果你现在用的不是 GoLand，而是 IDEA、PyCharm，或者本身就在用 VS Code，其实迁移思路也差不多：<strong>先搞定主题/字体/图标，其次是快捷键和导航习惯，最后再把运行、调试、工作流等关键场景一点点复刻出来。</strong></p>
<p>另外，老实说在很多场景下，IDE 双开也是一个很务实的选择。效率工具的使用不是非此即彼的二选一，把各自的价值都发挥出来，反而可能更有意义。比如在复杂项目下，可以这样双开 TRAE + GoLand：</p>
<ul>
<li>
<p><strong>业务开发、补单测、润色注释用 TRAE</strong>，充分发挥 AI 的增量价值；需要做大范围 review、复杂代码导航和测试时，可以切回 GoLand，利用它成熟而稳定的性能表现。</p>
</li>
<li>
<p><strong>排查线上问题时</strong>，可以在 TRAE 里 attach 远程进程、看日志，让 AI 一起帮忙分析调用链；对着可疑代码块再用 GoLand 做精细跳转、全局检索和静态检查。</p>
</li>
<li>
<p>做接口迁移或批量改名这类高风险操作时，用 GoLand 负责“安全落刀”，让重构工具兜底；<strong>TRAE 则帮你生成迁移脚本、补测试、看覆盖率哪里还不够。</strong></p>
</li>
</ul>
<p>以上是我自己的一些 GoLand ↔ TRAE 迁移心得。如果这篇分享能帮你把 TRAE 用成顺手的 AI IDE，那目的就算达到了。不妨来试一试吧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[GLM-5 发布了！10 分钟傻瓜化部署 OpenClaw 到飞书。]]></title>    <link>https://juejin.cn/post/7605625595571011599</link>    <guid>https://juejin.cn/post/7605625595571011599</guid>    <pubDate>2026-02-13T06:14:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605625595571011599" data-draft-id="7605625595570995215" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="GLM-5 发布了！10 分钟傻瓜化部署 OpenClaw 到飞书。"/> <meta itemprop="keywords" content="GitHub"/> <meta itemprop="datePublished" content="2026-02-13T06:14:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="逛逛GitHub"/> <meta itemprop="url" content="https://juejin.cn/user/1442202996186093"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            GLM-5 发布了！10 分钟傻瓜化部署 OpenClaw 到飞书。
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1442202996186093/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    逛逛GitHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:14:49.000Z" title="Fri Feb 13 2026 06:14:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>前两天，整个外网集体陷入猜谜游戏，仿佛整个科技区进入了全员侦探的模型。</p>
<p>这是因为一个叫 Pony Alpha 的匿名模型在海外各大评测榜单上横空出世。</p>
<p>它没有发布会，甚至没有一家具体的公司认领。。。</p>
<p>仅仅凭着几个简单的 API 接口和很惊艳的生成质量，就瞬间引爆了 X 和 Reddit 的技术社区。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c6a7801f68f14b2ba8c1c609d3232138~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=r%2Br88dGiLQsh02CVGUnkDfvRY2w%3D" alt="图片" loading="lazy"/></p>
<p>OpenRouter 全球模型聚合与分发平台在 2月6日首次公开推文宣布上线名为 Pony Alpha 的神秘模型。</p>
<p>随后两天在外网迅速发酵，大家都在猜这究竟是哪家模型？</p>
<p>有人说是 DeepSeek V4，也有人说是 Claude Sonnet 秘密升级版，甚至有人通过 Pony 代号猜测是腾讯的新模型？？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/884bbcf7089d4c16ac05191966621831~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=v0qqgCYF2RT1MY4w%2F0s%2BKPWQRFY%3D" alt="图片" loading="lazy"/></p>
<p><strong>现在，谜底揭晓，官宣了。</strong></p>
<p>这个霸榜外网的 Pony Alpha，正是我们国产的 AI 大模型—<strong>GLM-5</strong>。</p>
<p>没错，GLM-5 不仅来了，而且直接<strong>开源</strong>。</p>
<p><strong>01</strong>、GLM 5 模型介绍</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5956c2ff2ce45bf83f46780561fca05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=g3R23XvCXkkKPmoShA25uKq85AE%3D" alt="图片" loading="lazy"/></p>
<p>GLM-5 的定位非常清晰，它是面向复杂的系统工程、长链路 Agent 任务的开源模型基座。</p>
<p>不满足于写个前端 demo，而是开始追求 Agentic 深度。说白了，就是看模型能不能像人一样，独立搞定一整个系统工程。</p>
<p>在 2026 年初这个时间节点，GLM-5 想要重塑长程规划与系统级工程开发。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29acb7101ee1403eb16f67e0d264b991~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=UPyWlAbeyPkT0mvmMR3ESjnY7ow%3D" alt="图片" loading="lazy"/></p>
<p>① 跨时域的 Agentic 任务自主闭环 </p>
<p>GLM-5 不只会写几行碎代码，它更像是个<strong>脑子清醒的项目负责人</strong>。</p>
<p>面对那种要分好几步、折腾好几个小时的复杂大任务，它能自己把需求拆明白，而且全程不掉线、不跑题，盯着目标一直干到底。</p>
<p>② 硬核后端重构与全链路调试 </p>
<p>GLM-5 在后端架构设计、高复杂度算法实现等深水区游刃有余。 </p>
<p>最牛的是它有反思能力：如果程序跑不通，报错了？它不用你盯着，自己翻日志、找原因，一遍遍试错重来，直到代码彻底跑通为止。</p>
<p>③ 对标 Claude Opus 的开源工程标杆 </p>
<p>在代码逻辑密度与系统级工程交付能力上，GLM-5 能够对齐 Claude Opus 4.5。它为开发者提供了对标顶尖商业模型的智能水平，同时兼具开源部署的灵活性与极致的资源性价比。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2737fbd87b99471096094a6ddb2ebbb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=aHywS1oce5x5meDe5PXrT%2BVoqlE%3D" alt="图片" loading="lazy"/></p>
<p><strong>02</strong>、测试一下</p>
<p>把 OpenClaw 接入到飞书中。</p>
<p>我用最简单的提示词，GLM-5 拆解任务一步步引导我跑通了 OpenClaw 接入到飞书中。</p>
<p>你可以按照我如下的步骤试试，保证可以在 10 分钟内搞定。</p>
<p>提示词：</p>
<p>帮我部署一个 openclaw 开源项目，我要配置到飞书群里接入到一个机器人。</p>
<p>输入完这个提示词，GLM-5 会引导你进行一些配置，比如在飞书开放平台创建应用、配置应用权限，启用机器人的能力。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d886fdac3f84fbdbf234bab0c0b2095~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=6ddoORVZHURu9b0CP1j433U6tS4%3D" alt="图片" loading="lazy"/></p>
<p>不过这些配置你不用担心，GLM-5 怕你不会，已经整理了一个非常详细的 PDF 文档，你就跟着文档中的指示一步步操作就行了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c65073a04fbe40f79f5d115f9c5b3647~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=UAVXgB8GNLLTBTyGAANgqZn5C5E%3D" alt="图片" loading="lazy"/></p>
<p>当你根据这个文档去飞书开放平台进行了相关的配置， 你可以在开放平台拿到你的 appid 和 app secret ，这个时候你再给 GLM-5 发送一个命令：</p>
<p>我的 appid 是 xxxxx</p>
<p>我的 app secret 是：xxxxx</p>
<p>然后 GLM-5 会说：请问您是否需要我帮您配置 AI 模型？如果您有 Claude 或其他 AI 服务的 API Key，请告诉我，我可以帮您配置。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc2062dde9494cfabf970570951b29bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=JuSA8HaBV3u3TkdtDwb2Iog1Rtw%3D" alt="图片" loading="lazy"/></p>
<p>我再输入了提示词：</p>
<p>帮我接入 glm 的模型，我的 api key 为：xxxx</p>
<p>然后 GLM-5 会噼里啪啦自己去配置，然后告诉你 GLM 的 API Key 已经配置成功了，你需要再去飞书开放平台配置一下事件订阅。</p>
<p>我也不懂啥逻辑，就是跟着做就行了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/71d5f57a17d94fc4b7df30f987683f58~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=sI2n0aKD1vcO9nc2uRH60asyz1Q%3D" alt="图片" loading="lazy"/></p>
<p>最后你创建一个飞书群，把你这个机器人加进去。然后 @这个机器人，就 OK 了。。。</p>
<p>整个过程中，我只是输入了三个提示词，在飞书开放平台创建了一个应用、进行了相关的配置，然后把机器人接入到飞书群里。</p>
<p>傻瓜式的跟着 GLM-5 生成的 PDF 部署指南点点点，就 Work 了。。。</p>
<p>这个感觉真的太爽了，太牛了。。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b4b2937c02864efd907e150ec58ad654~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=jeAvalnJUqN1CD1%2BdkrrWzSQGYs%3D" alt="图片" loading="lazy"/></p>
<p>直观的感受是 GLM-5 模型在 Agentic 任务上表现确实不错。</p>
<p>尤其要分好几步甚至中间需要人来交互补充额外信息的任务，它能把需求拆明白，而且知道在哪些步骤上需要人参与进来补充信息。</p>
<p>补充完信息能接着干，不跑题，上下文连贯很强。</p>
<p>生成一个全栈论坛。</p>
<p>GLM 牛的点是做系统级工程，我让它做一个带管理后台、鉴权、发布的完整论坛。</p>
<p>而不是一个静态前端页面 Demo。</p>
<p>提示词：</p>
<p>你是一位资深全栈工程师，擅长使用现代技术栈（Next.js 14, Tailwind CSS, TypeScript, Lucide React 图标）构建简洁、美观、响应式的 Web 应用。</p>
<p>任务目标： 请帮我开发一个功能完备的轻量化论坛系统。要求设计风格参考知乎，美观、大气、有格调。</p>
<p>核心功能需求：</p>
<p>用户前端：身份验证： 实现邮箱登录/注册、帖子浏览： 首页展示帖子列表（含标题、作者、发布时间、标签）、帖子详情： 支持查看正文及评论区。</p>
<p>发布功能： 简单的富文本或 Markdown 编辑器页面、个人中心： 显示我的帖子和基本设置。</p>
<p>管理系统 (Admin Portal)：</p>
<p>独立入口： 默认登录账号：admin，密码：admin、管理看板： 统计帖子总数、用户总数、内容管理： 支持对违规帖子进行删除或置顶操作、用户管理： 查看用户列表，禁言用户。</p>
<p>大概需要等到 20～30 分钟，GLM 5 完成了任务拆解、Coding、部署上线。</p>
<p>实现了的注册、登录，帖子发布功能。如果登录的是管理员账号，还能切换到管理后台对论坛内容、用户进行管理。</p>
<p>如果切换到一个为未登录的用户状态，会发现社区的帖子是能够看到的，如果要点赞、评论会引导进行登录，有鉴权的逻辑。</p>
<p>GLM-5 模型不会立即写代码，而是判定这是一个复杂的项目，先进行前置的规划。</p>
<p>包括设计数据库模型、创建后端 API、开发前端页面等等。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88618a20a729412ba26c6594ab713b4c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=guxck8Nl2iy0n%2BMz52xX1bPpErI%3D" alt="图片" loading="lazy"/></p>
<p>如果跑不通、报错了，GLM-5 不需要你介入。它会自己翻日志、分析 Stack Trace、定位 Bug，然后重写代码，一遍遍试错直到跑通。</p>
<p>这种写代码-运行-报错-修Bug-再运行的自主闭环能力，才是 Agentic 时代的真正入场券。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/794f957a4ae842369eaf674c2c425f55~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=6doNlS2t4rKyEryHBndQPqEhpkI%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d430c80438db484595df8cd4a9a4204d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=ZI1o%2FKsorSwpvBqfvNzUxJpXMsA%3D" alt="图片" loading="lazy"/></p>
<p>如果想搞一搞 GLM 模型，没有 token 可用，可以使用下面这个我的专属链接订阅套餐，第一次购买 5 折，而且应邀再减 10%。 </p>
<pre><code class="hljs language-ini" lang="ini">链接：https://www.bigmodel.cn/claude-code?<span class="hljs-attr">ic</span>=UX7NF0VZ4S
</code></pre>
<p><strong>03</strong>、Agentic Coding 时代来临。</p>
<p>2026 年 Vibe Coding 可能真的不是主流叙事了，现在是 Agentic Coding。</p>
<p>GLM-5 的发布，就是在践行这个理念。</p>
<p>它不是来辅助你写代码的，它是来替你交付系统的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f80888d9e7e844a4822ddeacd9334543~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=di4tOGRD1lp%2ByQL%2Fn0JYWn8Lc1E%3D" alt="图片" loading="lazy"/></p>
<p>如果大家有时间，可以去听听 OpenClaw 开源项目作者最近的访谈，他说了一个观点。</p>
<p>Andrej Karpathy 等 AI 大佬们近期也表达过类似的想法。</p>
<p><strong>Vibe Coding 作为一种早期的、随意的 AI 编程方式已经触到了天花板，正在被更严肃、更具工程化的 Agentic Coding 所取代。</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/43b2cb3d840b426db3955c54c3bc0d02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YCb6YCbR2l0SHVi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568088&amp;x-signature=6NsaWx2ChzE0SBtrsaKksYeBx3k%3D" alt="图片" loading="lazy"/></p>
<p>Vibe Coding 是 AI 编程初期的一种野生玩法，但不是最终范式。</p>
<p>Agentic Coding 更加科学，它不是和一个大模型聊天写点代码。而是同时跑多个 agent，每个负责不同任务，开发者站在更高一层做架构设计、任务拆解和验证闭环。</p>
<p><strong>不太在意每一行代码，而是在意系统是否按预期工作。</strong></p>
<p>这两位 AI 大佬是 Vibe coding 最猛的一批实践者之一，但也是第一批公开说我得停下来，这样不行的人之一。</p>
<p>在代码逻辑密度、系统级工程交付能力、Agent 任务完成度这些维度上，GLM-5 已经可以直接对标 Claude Opus 这一档的顶级闭源模型。</p>
<p>在核心编程 / Agent 场景下，成本压到顶级闭源模型的一个零头，却能给到非常接近甚至超越的工程体验</p>
<p>对开发者来说，这意味着：你可以用开源模型的成本和可控性，享受接近顶级闭源模型的生产力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[简易的查询与缓存的统一执行器]]></title>    <link>https://juejin.cn/post/7605792874173874239</link>    <guid>https://juejin.cn/post/7605792874173874239</guid>    <pubDate>2026-02-13T06:01:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605792874173874239" data-draft-id="7605792874173857855" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="简易的查询与缓存的统一执行器"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T06:01:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小夏coding"/> <meta itemprop="url" content="https://juejin.cn/user/2403977616186251"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            简易的查询与缓存的统一执行器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2403977616186251/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小夏coding
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:01:42.000Z" title="Fri Feb 13 2026 06:01:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    18
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、背景与问题</h2>
<p>在高并发、高可用的业务场景中，我们常面临这样的数据获取流程：</p>
<ul>
<li><strong>先查缓存</strong>（如 Redis）减轻 DB 压力、提升响应速度</li>
<li><strong>缓存未命中再查 DB</strong></li>
<li><strong>DB 也没有则实时计算</strong></li>
<li><strong>计算或查询到结果后</strong>：先落库，再回写缓存，保证下次命中</li>
</ul>
<p>如果每个接口都手写「Redis → DB → 计算 → 写 DB → 写 Redis」这一套逻辑，会出现大量重复代码，且容易漏写回写步骤，导致缓存与 DB 不一致。因此需要一套<strong>可复用、声明式</strong>的执行器，把流程固定下来，只由调用方提供「查什么、怎么算、怎么存」。</p>
<hr/>
<h2 data-id="heading-1">二、整体设计思路</h2>
<p>核心思想：<strong>用函数式接口描述每一步能力，由工具类按固定顺序执行</strong>。</p>
<ul>
<li><strong>Supplier&lt;R&gt;  dbQueryFunc</strong> ：数据库查询方法，返回查询的结果；</li>
<li><strong>Function&lt;T, R&gt;  computeFunc</strong>：实时计算方法，接受参数，返回计算的结果；</li>
<li><strong>Consumer&lt;R&gt;  dbSaveFunc</strong>：保存结果到数据库的方法；</li>
</ul>
<p>流程由工具类统一编排，业务方只负责提供这些 Lambda，从而：</p>
<ul>
<li>减少重复的 if-else 和 null 判断</li>
<li>统一日志（如「DB 无数据，实时计算」「缓存和 DB 均无数据，实时计算」）</li>
<li>保证「先写 DB 再写 Redis」等顺序，降低出错概率</li>
</ul>
<hr/>
<h2 data-id="heading-2">三、关键实现</h2>
<p><strong>流程简述：</strong></p>
<ol>
<li><strong>读 Redis</strong>：用 <code>cacheKeyFunc.get()</code> 得到 key，按 <code>resultType</code> 反序列化；命中则直接返回</li>
<li><strong>读 DB</strong>：调用 <code>dbQueryFunc.get()</code>；若有结果，则写入 Redis（带过期时间）并返回</li>
<li><strong>实时计算</strong>：调用 <code>computeFunc.apply(param)</code>，param 由 <code>paramFunc</code> 提供</li>
<li><strong>写回</strong>：若结果非空，先 <code>dbSaveFunc.accept(result)</code> 写 DB，再写 Redis；</li>
</ol>
<p><strong>方法签名：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, R&gt; R <span class="hljs-title function_">execute</span><span class="hljs-params">(
    Supplier&lt;String&gt; cacheKeyFunc,    // 缓存 key
    Long cacheExpireSeconds,          // 过期时间（秒）
    Supplier&lt;R&gt; dbQueryFunc,          // 从数据库查询结果的方法
    Function&lt;T, R&gt; computeFunc,       // 实时计算的方法
    Supplier&lt;T&gt; paramFunc,            // 获取参数值的方法，获取的参数传递给computeFunc
    Consumer&lt;R&gt; dbSaveFunc,           // 保存结果到数据库的方法
    TypeReference&lt;R&gt; resultType       // 用于 Redis 反序列化
)</span>
</code></pre>
<p><strong>要点：</strong></p>
<ul>
<li><code>TypeReference&lt;R&gt;</code> 解决泛型 <code>R</code> 在 JSON 反序列化时的类型擦除问题</li>
<li>写回顺序固定为：<strong>先 DB，后 Redis</strong>，避免缓存与 DB 不一致</li>
</ul>
<p><strong>流程示意：</strong></p>
<pre><code class="hljs">Redis + DB + 计算：
  读 Redis → 命中则返回
  → 未命中：读 DB → 有则写 Redis 并返回
  → 仍无：取参数 → 实时计算 → 写 DB → 写 Redis → 返回
</code></pre>
<p><strong>关键代码</strong></p>
<pre><code class="hljs language-scss" lang="scss">public static &lt;T, R&gt; R <span class="hljs-built_in">execute</span>(Supplier&lt;String&gt; cacheKeyFunc,
                               Long cacheExpireSeconds,
                               Supplier&lt;R&gt; dbQueryFunc,
                               Function&lt;T, R&gt; computeFunc,
                               Supplier&lt;T&gt; paramFunc,
                               Consumer&lt;R&gt; dbSaveFunc,
                               TypeReference&lt;R&gt; resultType) {
    T param = Objects<span class="hljs-selector-class">.nonNull</span>(paramFunc) ? paramFunc<span class="hljs-selector-class">.get</span>() : null;   
	if (Objects.isNull(cacheKeyFunc) || Objects<span class="hljs-selector-class">.isNull</span>(resultType)) {
        throw new <span class="hljs-built_in">RuntimeException</span>("cacheKeyFunc和resultType不能为空"); 
    }
    String cacheKey = cacheKeyFunc<span class="hljs-selector-class">.get</span>();
	if (StringUtils.isBlank(cacheKey)) {
		throw new <span class="hljs-built_in">RuntimeException</span>("缓存键不能为空"); 
	}

    <span class="hljs-comment">// 1. 先读 Redis</span>
    R result = RedisUtils<span class="hljs-selector-class">.queryForObj</span>(cacheKey, resultType);
    if (Objects.nonNull(result)) return result;

    <span class="hljs-comment">// 2. 读 DB</span>
    result = dbQueryFunc<span class="hljs-selector-class">.get</span>();
    if (Objects.nonNull(result)) {
        <span class="hljs-comment">//保存到redis</span>
        RedisUtils<span class="hljs-selector-class">.saveObj</span>(cacheKey, JSON.toJSONString(result), cacheExpireSeconds, TimeUnit<span class="hljs-selector-class">.SECONDS</span>);
        return result;
    }

    <span class="hljs-comment">// 3. 未查询到数据，执行计算逻辑</span>
    log<span class="hljs-selector-class">.info</span>("缓存和DB均无数据，实时计算数据");
    result = computeFunc<span class="hljs-selector-class">.apply</span>(param);

    <span class="hljs-comment">// 4. 先保存到 DB，再保存到 Redis</span>
    if (Objects.nonNull(result)) {
        dbSaveFunc<span class="hljs-selector-class">.accept</span>(result);
        RedisUtils<span class="hljs-selector-class">.saveObj</span>(cacheKey, JSON.toJSONString(result), cacheExpireSeconds, TimeUnit<span class="hljs-selector-class">.SECONDS</span>);
    } else {
        log<span class="hljs-selector-class">.info</span>("计算结果为空，无需保存");
    }

    return result;
}
</code></pre>
<p>备注：其中的RedisUtils是我封装的一个redis操作工具类，提供了简化了redis操作的方法；</p>
<hr/>
<h2 data-id="heading-3">四、使用示例</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 示例：带 Redis 缓存的用户统计查询</span>
<span class="hljs-type">UserStat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> QueryProcessUtils.execute(
    () -&gt; <span class="hljs-string">"user:stat:"</span> + userId,                            <span class="hljs-comment">// cache key</span>
    <span class="hljs-number">3600L</span>,                                                   <span class="hljs-comment">// 过期 1 小时</span>
    () -&gt; userStatMapper.selectByUserId(userId),
    (userId) -&gt; userService.aggregateStat(userId),
    () -&gt; userId,
    (result) -&gt; userStatMapper.insert(result),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;UserStat&gt;() {}
);
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 子传父全解析：从基础用法到实战避坑]]></title>    <link>https://juejin.cn/post/7605859660612108322</link>    <guid>https://juejin.cn/post/7605859660612108322</guid>    <pubDate>2026-02-13T06:17:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605859660612108322" data-draft-id="7605810996125581346" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 子传父全解析：从基础用法到实战避坑"/> <meta itemprop="keywords" content="前端,Vue.js,面试"/> <meta itemprop="datePublished" content="2026-02-13T06:17:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 子传父全解析：从基础用法到实战避坑
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:17:51.000Z" title="Fri Feb 13 2026 06:17:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Vue3 开发中，组件通信是绕不开的核心场景，而子传父作为最基础、最常用的通信方式之一，更是新手入门必掌握的知识点。不同于 Vue2 的 <code>$emit</code> 写法，Vue3 组合式 API（<code>&lt;script setup&gt;</code>）简化了子传父的实现逻辑，但也有不少细节和进阶技巧需要注意。</p>
<p>本文将抛开 TypeScript，用最通俗的语言 + 可直接复制的实战代码，从基础用法、进阶技巧、常见场景到避坑指南，全方位讲解 Vue3 子传父，新手看完就能上手，老手也能查漏补缺。</p>
<h2 data-id="heading-0">一、核心原理：子组件触发事件，父组件监听事件</h2>
<p>Vue3 子传父的核心逻辑和 Vue2 一致：<strong>子组件通过触发自定义事件，将数据传递给父组件；父组件通过监听该自定义事件，接收子组件传递的数据</strong>。</p>
<p>关键区别在于：Vue3 <code>&lt;script setup&gt;</code> 中，无需通过 <code>this.$emit</code> 触发事件，而是通过 <code>defineEmits</code> 声明事件后，直接调用 emit 函数即可，语法更简洁、更直观。</p>
<p>先记住核心流程，再看具体实现：</p>
<ol>
<li>子组件：用 <code>defineEmits</code> 声明要触发的自定义事件（可选但推荐）；</li>
<li>子组件：在需要传值的地方（如点击事件、接口回调），调用 <code>emit('事件名', 要传递的数据)</code>；</li>
<li>父组件：在使用子组件的地方，通过 <code>@事件名="处理函数"</code> 监听事件；</li>
<li>父组件：在处理函数中，接收子组件传递的数据并使用。</li>
</ol>
<h2 data-id="heading-1">二、基础用法：最简洁的子传父实现（必学）</h2>
<p>我们用一个「子组件输入内容，父组件实时显示」的简单案例，讲解基础用法，代码可直接复制到项目中运行。</p>
<h3 data-id="heading-2">1. 子组件（Child.vue）：声明事件 + 触发事件</h3>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 输入框输入内容，触发input事件，传递输入值 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
      <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"childInput"</span> 
      @<span class="hljs-attr">input</span>=<span class="hljs-string">"handleInput"</span>
      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入要传递给父组件的内容"</span>
    /&gt;</span>
    <span class="hljs-comment">&lt;!-- 按钮点击，传递固定数据 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleClick"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin-top: 10px;"</span>&gt;</span>
      点击向父组件传值
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 1. 声明要触发的自定义事件（数组形式，元素是事件名）</span>
<span class="hljs-comment">// 可选，但推荐声明：增强代码可读性，IDE会有语法提示，避免拼写错误</span>
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'inputChange'</span>, <span class="hljs-string">'btnClick'</span>])

<span class="hljs-comment">// 子组件内部数据</span>
<span class="hljs-keyword">const</span> childInput = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)

<span class="hljs-comment">// 输入框变化时，触发事件并传递输入值</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleInput</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 2. 触发事件：第一个参数是事件名，第二个参数是要传递的数据（可选，可多个）</span>
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'inputChange'</span>, childInput.<span class="hljs-property">value</span>)
}

<span class="hljs-comment">// 按钮点击时，触发事件并传递固定对象</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'btnClick'</span>, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'子组件'</span>,
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'这是子组件通过点击按钮传递的数据'</span>
  })
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-3">2. 父组件（Parent.vue）：监听事件 + 接收数据</h3>
<pre><code class="hljs language-js" lang="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件输入的内容：{{ parentMsg }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件点击传递的数据：{{ parentData }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 3. 监听子组件声明的自定义事件，绑定处理函数 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> 
      @<span class="hljs-attr">inputChange</span>=<span class="hljs-string">"handleInputChange"</span>
      @<span class="hljs-attr">btnClick</span>=<span class="hljs-string">"handleBtnClick"</span>
    /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 引入子组件</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child.vue'</span>
<span class="hljs-keyword">import</span> { ref, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 父组件接收数据的容器</span>
<span class="hljs-keyword">const</span> parentMsg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
<span class="hljs-keyword">const</span> parentData = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">msg</span>: <span class="hljs-string">''</span>
})

<span class="hljs-comment">// 4. 处理子组件触发的inputChange事件，接收传递的数据</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleInputChange</span> = (<span class="hljs-params">val</span>) =&gt; {
  <span class="hljs-comment">// val 就是子组件emit传递过来的值（childInput.value）</span>
  parentMsg.<span class="hljs-property">value</span> = val
}

<span class="hljs-comment">// 处理子组件触发的btnClick事件，接收传递的对象</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleBtnClick</span> = (<span class="hljs-params">data</span>) =&gt; {
  <span class="hljs-comment">// data 是子组件传递的对象，直接解构或赋值即可</span>
  parentData.<span class="hljs-property">name</span> = data.<span class="hljs-property">name</span>
  parentData.<span class="hljs-property">msg</span> = data.<span class="hljs-property">msg</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-4">3. 核心细节说明</h3>
<ul>
<li><code>defineEmits</code> 是 Vue3 内置的宏，无需导入，可直接使用；</li>
<li>emit 函数的第一个参数必须和 <code>defineEmits</code> 中声明的事件名一致（大小写敏感），否则父组件无法监听到；</li>
<li>emit 可传递多个参数，比如 <code>emit('event', val1, val2)</code>，父组件处理函数可对应接收 <code>(val1, val2) =&gt; {}</code>；</li>
<li>父组件监听事件时，可使用 <code>@事件名</code>（简写）或 <code>v-on:事件名</code>（完整写法），效果一致。</li>
</ul>
<h2 data-id="heading-5">三、进阶用法：优化子传父的体验（实战常用）</h2>
<p>基础用法能满足简单场景，但在实际开发中，我们还会遇到「事件校验」「双向绑定」「事件命名规范」等需求，这部分进阶技巧能让你的代码更规范、更健壮。</p>
<h3 data-id="heading-6">1. 事件校验：限制子组件传递的数据类型</h3>
<p>通过 <code>defineEmits</code> 的对象形式，可对事件传递的数据进行类型校验，避免子组件传递错误类型的数据，提升代码可靠性（类似 props 校验）。</p>
<pre><code class="hljs language-js" lang="js">&lt;script setup&gt;
<span class="hljs-comment">// 对象形式声明事件，key是事件名，value是校验函数（参数是子组件传递的数据，返回boolean）</span>
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>({
  <span class="hljs-comment">// 校验inputChange事件传递的数据必须是字符串</span>
  <span class="hljs-attr">inputChange</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'string'</span>
  },
  <span class="hljs-comment">// 校验btnClick事件传递的数据必须是对象，且包含name和msg属性</span>
  <span class="hljs-attr">btnClick</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> data &amp;&amp; <span class="hljs-string">'msg'</span> <span class="hljs-keyword">in</span> data
  }
})

<span class="hljs-comment">// 若传递的数据不符合校验，控制台会报警告（不影响代码运行，仅提示）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleInput</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'inputChange'</span>, <span class="hljs-number">123</span>) <span class="hljs-comment">// 传递数字，不符合校验，控制台报警告</span>
}
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-7">2. 双向绑定：v-model 简化子传父（高频场景）</h3>
<p>很多时候，子传父是为了「修改父组件的数据」，比如表单组件、开关组件，这时可使用 <code>v-model</code> 简化代码，实现父子组件双向绑定，无需手动声明事件和处理函数。</p>
<p>Vue3 中，<code>v-model</code> 本质是「语法糖」，等价于 <code>:modelValue="xxx" @update:modelValue="xxx = $event"</code>。</p>
<h4 data-id="heading-8">优化案例：子组件开关，父组件显示状态</h4>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件（<span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span>） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>子组件开关<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleSwitch"</span>&gt;</span>
      {{ isOpen ? '关闭' : '打开' }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 1. 接收父组件通过v-model传递的modelValue</span>
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'modelValue'</span>])
<span class="hljs-comment">// 2. 声明update:modelValue事件（固定命名，不可修改）</span>
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:modelValue'</span>])

<span class="hljs-comment">// 子组件内部使用父组件传递的值</span>
<span class="hljs-keyword">const</span> isOpen = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">modelValue</span>)

<span class="hljs-comment">// 开关切换，触发事件，修改父组件数据</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSwitch</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'update:modelValue'</span>, !isOpen.<span class="hljs-property">value</span>)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<pre><code class="hljs language-js" lang="js">&lt;!-- 父组件（<span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span>） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>父组件：{{ isSwitchOpen ? '开关已打开' : '开关已关闭' }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 直接使用v-model，无需手动监听事件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"isSwitchOpen"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child.vue'</span>
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> isSwitchOpen = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-9">扩展：多个 v-model 双向绑定</h4>
<p>Vue3 支持给同一个子组件绑定多个 <code>v-model</code>，只需给 <code>v-model</code> 加后缀，对应子组件的<code>props</code> 和 <code>emit</code> 即可。</p>
<pre><code class="hljs language-js" lang="js">&lt;!-- 父组件 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> 
  <span class="hljs-attr">v-model:name</span>=<span class="hljs-string">"parentName"</span> 
  <span class="hljs-attr">v-model:age</span>=<span class="hljs-string">"parentAge"</span> 
/&gt;</span></span>

&lt;!-- 子组件 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 接收多个v-model传递的props</span>
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>])
<span class="hljs-comment">// 声明对应的update事件</span>
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'update:name'</span>, <span class="hljs-string">'update:age'</span>])

<span class="hljs-comment">// 触发事件修改父组件数据</span>
<span class="hljs-title function_">emit</span>(<span class="hljs-string">'update:name'</span>, <span class="hljs-string">'新名字'</span>)
<span class="hljs-title function_">emit</span>(<span class="hljs-string">'update:age'</span>, <span class="hljs-number">25</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-10">3. 事件命名规范：提升代码可读性</h3>
<p>在实际开发中，遵循统一的事件命名规范，能让团队协作更高效，推荐以下规范：</p>
<ul>
<li>事件名采用「kebab-case 短横线命名」（和 HTML 事件命名一致），比如 <code>input-change</code> 而非 <code>inputChange</code>；</li>
<li>事件名要语义化，体现事件的用途，比如 <code>form-submit</code>（表单提交）、<code>delete-click</code>（删除点击）；</li>
<li>双向绑定的事件固定为 <code>update:xxx</code>，xxx 对应 props 名，比如 <code>update:name</code>、<code>update:visible</code>。</li>
</ul>
<h2 data-id="heading-11">四、实战场景：子传父的常见应用</h2>
<p>结合实际开发中的高频场景，给大家补充 3 个常用案例，覆盖大部分子传父需求。</p>
<h3 data-id="heading-12">场景1：子组件表单提交，父组件接收表单数据</h3>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件（<span class="hljs-title class_">FormChild</span>.<span class="hljs-property">vue</span>） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-child"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.name"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入姓名"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"form.age"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入年龄"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleSubmit"</span>&gt;</span>提交表单<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'form-submit'</span>])

<span class="hljs-keyword">const</span> form = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-string">''</span>
})

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 表单校验（简化）</span>
  <span class="hljs-keyword">if</span> (!form.<span class="hljs-property">name</span> || !form.<span class="hljs-property">age</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">'请填写完整信息'</span>)
  <span class="hljs-comment">// 提交表单数据给父组件</span>
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'form-submit'</span>, form)
  <span class="hljs-comment">// 提交后重置表单</span>
  form.<span class="hljs-property">name</span> = <span class="hljs-string">''</span>
  form.<span class="hljs-property">age</span> = <span class="hljs-string">''</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-13">场景2：子组件关闭弹窗，父组件控制弹窗显示/隐藏</h3>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件（<span class="hljs-title class_">ModalChild</span>.<span class="hljs-property">vue</span>） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"visible"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal-content"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>子组件弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleClose"</span>&gt;</span>关闭弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'visible'</span>])
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'close-modal'</span>])

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClose</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 触发关闭事件，通知父组件隐藏弹窗</span>
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'close-modal'</span>)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-14">场景3：子组件列表删除，父组件更新列表</h3>
<pre><code class="hljs language-js" lang="js">&lt;!-- 子组件（<span class="hljs-title class_">ListChild</span>.<span class="hljs-property">vue</span>） --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-child"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>
      {{ item.name }}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleDelete(item.id)"</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">'list'</span>])
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'delete-item'</span>])

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDelete</span> = (<span class="hljs-params">id</span>) =&gt; {
  <span class="hljs-comment">// 传递要删除的id给父组件，由父组件更新列表</span>
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'delete-item'</span>, id)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h2 data-id="heading-15">五、常见坑点避坑指南（新手必看）</h2>
<p>很多新手在写子传父时，会遇到「父组件监听不到事件」「数据传递失败」等问题，以下是最常见的 4 个坑点，帮你快速避坑。</p>
<h3 data-id="heading-16">坑点1：事件名大小写不一致</h3>
<p>子组件 <code>emit('inputChange')</code>，父组件 <code>@inputchange="handle"</code>（小写），会导致父组件监听不到事件。</p>
<p>解决方案：统一采用 kebab-case 命名，子组件 <code>emit('input-change')</code>，父组件 <code>@input-change="handle"</code>。</p>
<h3 data-id="heading-17">坑点2：忘记声明事件（defineEmits）</h3>
<p>子组件直接调用 <code>emit('event')</code>，未用 <code>defineEmits</code> 声明事件，虽然开发环境可能不报错，但生产环境可能出现异常，且 IDE 无提示。</p>
<p>解决方案：无论事件是否需要校验，都用 <code>defineEmits</code> 声明（数组形式即可）。</p>
<h3 data-id="heading-18">坑点3：传递复杂数据（对象/数组）时，父组件修改后影响子组件</h3>
<p>子组件传递对象/数组给父组件，父组件直接修改该数据，会影响子组件（因为引用类型传递的是地址）。</p>
<p>解决方案：父组件接收数据后，用 <code>JSON.parse(JSON.stringify(data))</code> 深拷贝，或用 <code>reactive</code> + <code>toRaw</code> 处理，避免直接修改原始数据。</p>
<h3 data-id="heading-19">坑点4：v-model 双向绑定时报错，提示「modelValue 未定义」</h3>
<p>原因：子组件未接收 <code>modelValue</code> props，或未声明 <code>update:modelValue</code> 事件。</p>
<p>解决方案：确保子组件 <code>defineProps(['modelValue'])</code> 和 <code>defineEmits(['update:modelValue'])</code> 都声明。</p>
<h2 data-id="heading-20">六、总结：子传父核心要点回顾</h2>
<p>Vue3 子传父的核心就是「事件触发 + 事件监听」，记住以下 3 个核心要点，就能应对所有场景：</p>
<ol>
<li>基础写法：<code>defineEmits</code> 声明事件 → <code>emit</code> 触发事件 → 父组件 <code>@事件名</code> 监听；</li>
<li>进阶优化：事件校验提升可靠性，<code>v-model</code> 简化双向绑定，遵循 kebab-case 命名规范；</li>
<li>避坑关键：事件名大小写一致、必声明事件、复杂数据深拷贝、v-model 对应 props 和 emit 命名正确。</li>
</ol>
<p>子传父是 Vue3 组件通信中最基础的方式，掌握它之后，再学习父传子（props）、跨层级通信（provide/inject）、全局通信（Pinia）会更轻松。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI 编程的临界点：当三家巨头同时宣布我们不写代码了]]></title>    <link>https://juejin.cn/post/7605816833192067072</link>    <guid>https://juejin.cn/post/7605816833192067072</guid>    <pubDate>2026-02-13T06:20:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605816833192067072" data-draft-id="7605810996125630498" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI 编程的临界点：当三家巨头同时宣布我们不写代码了"/> <meta itemprop="keywords" content="AIGC,AI编程"/> <meta itemprop="datePublished" content="2026-02-13T06:20:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="孟健AI编程"/> <meta itemprop="url" content="https://juejin.cn/user/4212984287073895"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI 编程的临界点：当三家巨头同时宣布我们不写代码了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4212984287073895/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    孟健AI编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:20:51.000Z" title="Fri Feb 13 2026 06:20:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是孟健。</p>
<p><strong>昨天 24 小时内，三家公司同时说了同一句话：我们的代码，基本不是人写的了。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/46b65921c46b4aca9f6452b4c871aae1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568450&amp;x-signature=jesU9ZmQOBg6tcq3ClSaRO%2BC9dc%3D" alt="" loading="lazy"/></p>
<p>不是媒体炒作。不是 PR 包装。是 Nvidia、OpenAI、Cognition、Anthropic——四家站在 AI 最前沿的公司，几乎同一时间亮出了底牌。</p>
<p>这件事值得每个写代码的人停下来想一想。</p>
<hr/>
<h2 data-id="heading-0"><strong>发生了什么</strong></h2>
<p>先摆事实。</p>
<p><strong>Nvidia</strong>：黄仁勋几个月前在内部喊出"stop coding"，让 3 万名工程师全面换用 AI 编程工具。最新数据——代码产出量翻了 3 倍。不是 10%、20%的提升，是 3 倍。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f66bf95b9407443d8fc4e2e894e33817~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568450&amp;x-signature=Fz67t3TSyBnv7baK0wksir9DQ%2BQ%3D" alt="" loading="lazy"/></p>
<p><strong>OpenAI</strong>：内部团队交付了一个完整产品，每一行代码都是 AI Agent 生成的。工程师全程没写一行代码，只负责 Review 和监督。开发效率提升了 10 倍。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0c3bcedb20042299464c2a82c943c86~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568450&amp;x-signature=M%2FuiWV8LLK7X2WwynDffREiZE9Y%3D" alt="" loading="lazy"/></p>
<p><strong>Cognition</strong>（做 Devin 的那家）：联合创始人 Scott Wu 发了条推，说公司超过 90%的代码是 AI 写的。他的原话是："你现在实际需要亲手敲的代码有多少？对我们来说，大概不到 10%。"</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b92d009fb057444e8a036f3f8fd479d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568450&amp;x-signature=xX01GtDWvncvOUBzD1Qun9mjqTQ%3D" alt="" loading="lazy"/></p>
<p><strong>Anthropic</strong>：首席产品官 Mike Krieger 说得更直接——"Claude 在写 Claude。Claude 的产品和 Claude Code，完全由 Claude 自己写。"</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fea252c30fd64adb9f0dd24d601a4095~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568450&amp;x-signature=o7vvPC0LqSj5%2FV2FD%2FkPmoxkYe4%3D" alt="" loading="lazy"/></p>
<p>四家公司，同一个结论：<strong>程序员的核心工作，正在从"写代码"变成"不写代码"。</strong></p>
<hr/>
<h2 data-id="heading-1"><strong>这不是第一次有人喊"狼来了"</strong></h2>
<p>我知道你在想什么。</p>
<p>"AI 替代程序员"这话喊了三年了。2023 年 GitHub Copilot 发布的时候喊过一次。2024 年 Devin 出来的时候又喊了一次。2025 年 Claude Code 和 Codex 上线的时候再喊一次。</p>
<p>每次喊完，程序员还是该上班上班，该加班加班。</p>
<p>但这次不一样。</p>
<p>之前是模型公司说"我们能做到"——那是销售话术。</p>
<p>这次是<strong>用 AI 写代码的公司自己说"我们已经做到了"</strong>——这是生产实践。</p>
<p>Nvidia 不是 AI 编程工具公司，它是芯片公司。它给 3 万工程师换工具，不是为了 PR，是因为代码产出真的翻了 3 倍。当你的竞争对手用同样的人力做出 3 倍的产出，你不跟进就是在等死。</p>
<p>这个信号的含金量，跟"某 AI 公司发了个 Demo"完全不是一个量级。</p>
<hr/>
<h2 data-id="heading-2"><strong>为什么是现在</strong></h2>
<p>你可能好奇：AI 编程工具 2024 年就有了，为什么突然到了这个临界点？</p>
<p>答案是<strong>速度</strong>。</p>
<p>就在昨天，OpenAI 发布了 GPT-5.3-Codex-Spark——一个跑在 Cerebras 晶圆级芯片上的编码模型。这是 OpenAI 第一次用非 Nvidia 的芯片部署生产级模型。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e36ce70610e140c09210ef0a4ec0d688~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568450&amp;x-signature=UOyVeSHfHLqu9iMF2CoPWW5Ds08%3D" alt="" loading="lazy"/></p>
<p>关键数字：<strong>每秒 1000+ token 的代码生成速度，比之前快 15 倍。</strong></p>
<p>Cerebras 的芯片有多大？一整块硅晶圆，餐盘那么大，就是一个处理器。不是把几百个 GPU 堆在一起，是把一整个芯片做到极致。</p>
<p>15 倍速度意味着什么？</p>
<p>以前用 AI 写代码，你提交一个任务，泡杯咖啡等几分钟。现在是你话音刚落，代码就出来了。从"异步等结果"变成了"实时对话"。</p>
<p>这个体感差异是质变。</p>
<p>我自己每天用 Claude Code 做产品。之前等 AI 生成的时候我会切到别的窗口干别的事。现在？根本没时间切——它比我打字还快。</p>
<p><strong>当 AI 写代码的速度快到人类来不及思考的时候，"人写代码"这件事本身就变成了瓶颈。</strong></p>
<p>这就是为什么四家公司同时跨过了这个临界点。不是巧合，是速度到了。</p>
<hr/>
<h2 data-id="heading-3"><strong>我自己的体感</strong></h2>
<p>说说我的真实经历。</p>
<p>我在腾讯带过几十人的团队，在字节也做过前端技术 Leader。那时候团队产出的计算方式是：人头 × 工时 × 人效。想提高产出？加人、加班、优化流程。</p>
<p>2025 年 10 月辞职创业后，我开始全面用 AI 编程。</p>
<p><strong>一个人，一个月，做了近 30 个出海小产品。</strong></p>
<p>不是简单的静态页面。是有前端、有后端、有支付、有 SEO、有数据统计的完整产品。放在以前，这是一个 5-8 人的小团队干一个季度的量。</p>
<p>我不觉得 AI 替代了我。更准确地说，是 <strong>AI 把我从"写代码的人"变成了"做决策的人"</strong>。</p>
<p>以前 80%的时间在写代码，20%在想产品。</p>
<p>现在反过来了——80%的时间在想产品方向、用户需求、商业模式，20%在 Review AI 写的代码。</p>
<p>这个转变，跟 Nvidia 那 3 万工程师的转变是一模一样的。</p>
<hr/>
<h2 data-id="heading-4"><strong>程序员要失业了吗？</strong></h2>
<p>这是每次 AI 编程话题下必然出现的问题。</p>
<p>我的判断是：<strong>不会失业，但工作内容会彻底改变。</strong></p>
<p>上海交大最近发了一篇论文（ProjDevBench），测试 AI 从零构建完整软件项目的能力。结果通过率只有 27%——基础功能还行，但系统设计、性能优化、资源管理全崩。</p>
<p>这说明什么？</p>
<p>AI 已经能干 80%的活了。但剩下那 20%——架构决策、边界处理、性能调优、产品判断——恰恰是最值钱的 20%。</p>
<p>Scott Wu 说得好："瓶颈不再是写代码本身，而是两件事——1）让人类更容易理解、规划和提问；2）让 AI 更容易获取任务的真实上下文。"</p>
<p>翻译成人话就是：<strong>未来的程序员不是代码机器，是 AI 的 项目经理 。</strong></p>
<p>你的价值不再是一天能写多少行代码，而是你能不能把一个模糊的需求拆解成 AI 能理解的指令，能不能在 AI 写完之后判断"这个架构扛不扛得住"，能不能在 AI 犯错的时候快速定位问题。</p>
<p>这些能力，恰恰是在大厂带过团队、做过大项目的人最擅长的。</p>
<hr/>
<h2 data-id="heading-5"><strong>如果你只做一件事</strong></h2>
<p>说了这么多，落到行动上，我建议你今天就做一件事：</p>
<p><strong>把你最常做的一类开发任务，完整地交给 AI 做一次。</strong></p>
<p>不是让它补两行代码。是给它一份需求描述，让它从零开始搞。前端、后端、数据库、部署，全交出去。</p>
<p>你会发现两件事：</p>
<ol>
<li>
<p>AI 能搞定的部分，比你预期的多得多。</p>
</li>
<li>
<p>搞不定的部分，恰恰暴露了你真正不可替代的价值。</p>
</li>
</ol>
<p>Nvidia 的 3 万工程师已经这么干了。OpenAI 的团队已经这么干了。你还在等什么？</p>
<hr/>
<p>如果这篇对你有帮助，欢迎点赞、收藏、关注，你的支持是我持续输出的动力 ✨</p>
<hr/>
<p>我的其他平台账号和开源项目在个人主页中，欢迎交流 🤝</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android-封装个好用、轻量和通用的原生Adapter基类]]></title>    <link>https://juejin.cn/post/7605816833192017920</link>    <guid>https://juejin.cn/post/7605816833192017920</guid>    <pubDate>2026-02-13T06:02:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605816833192017920" data-draft-id="7605816833191985152" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android-封装个好用、轻量和通用的原生Adapter基类"/> <meta itemprop="keywords" content="Android,Kotlin"/> <meta itemprop="datePublished" content="2026-02-13T06:02:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RdoZam"/> <meta itemprop="url" content="https://juejin.cn/user/2019159609710904"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android-封装个好用、轻量和通用的原生Adapter基类
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2019159609710904/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RdoZam
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:02:33.000Z" title="Fri Feb 13 2026 06:02:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    17
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>基于RecyclerView.Adapter构建该通用适配器，以后其他项目直接拿来用就行~</p>
<blockquote>
<p><strong>思考1：</strong></p>
<ul>
<li>adapter功能纯粹，如 ‘构建复用条目布局’ 和 ‘绑定条目数据’ 等。</li>
<li>基类应具备的能力：构建条目布局、绑定数据、设置数据源、数据源的增删改查等。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>思考2：</strong></p>
<ul>
<li>需继承RecyclerView.ViewHolder抽象类</li>
<li>多布局场景的数据源，应具备区分ItemType能力，所以需定义对应接口</li>
</ul>
</blockquote>
<blockquote>
<p><strong>思考3：泛型相关</strong></p>
<ul>
<li>RecyclerView.ViewHolder的子类：泛型-参数View （更方便获取控件对象，否则只配苦逼地findViewById）</li>
<li>单布局Adapter基类：泛型-数据源类型、泛型-条目布局ViewBinding</li>
<li>多布局Adapter基类：泛型-数据源类型</li>
</ul>
</blockquote>
<p>废话不多说，直接上菜~</p>
<h3 data-id="heading-0">1.模块下build.gradle.kts中配置ViewBinding</h3>
<pre><code class="hljs language-ini" lang="ini">android{
    ...
    buildFeatures {
        ...
        <span class="hljs-attr">viewBinding</span> = <span class="hljs-literal">true</span>
    }
}
</code></pre>
<h3 data-id="heading-1">2.构建BaseViewHolder （继承RecyclerView.ViewHolder）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseViewHolder</span>&lt;<span class="hljs-type">VB : ViewBinding</span>&gt;(<span class="hljs-keyword">var</span> viewBinding: VB) : RecyclerView.ViewHolder(viewBinding.root)
</code></pre>
<h3 data-id="heading-2">★3. 构建单布局适配器BaseRvAdapter</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span> yyf
 * 单布局-基类适配器
 */</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRvAdapter</span>&lt;<span class="hljs-type">D,VB: ViewBinding</span>&gt; (<span class="hljs-keyword">var</span> mContext: Context) : RecyclerView.Adapter&lt;BaseViewHolder&lt;VB&gt;&gt;() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mList = mutableListOf&lt;D&gt;()

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = mList.size

    <span class="hljs-keyword">var</span> listener: ((View, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span>)? = <span class="hljs-literal">null</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setOnItemClickListener</span><span class="hljs-params">(listener: ((<span class="hljs-type">View</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)? = <span class="hljs-literal">null</span>)</span></span> {
        <span class="hljs-keyword">this</span>.listener = listener
    }

    <span class="hljs-comment">/*数据设置*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setData</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">D</span>&gt;?)</span></span> {
        list?.let {
            mList.clear()
            mList.addAll(it)
            notifyDataSetChanged()
        }
    }

    <span class="hljs-comment">/*数据获取*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>: MutableList&lt;D&gt; {
        <span class="hljs-keyword">return</span> mList
    }

    <span class="hljs-comment">/*增*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addData</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">D</span>&gt;?)</span></span> {
        <span class="hljs-keyword">if</span> (list?.isNotEmpty() == <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">var</span> start = mList.size
            mList.addAll(list)
            <span class="hljs-keyword">var</span> end = mList.size - <span class="hljs-number">1</span>
            notifyItemRangeChanged(start, end)
        }
    }

    <span class="hljs-comment">/*删*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeData</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt; mList.size) {
            mList.removeAt(position)
            notifyItemRemoved(position)
        }
    }

    <span class="hljs-comment">/*改*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateData</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>, bean: <span class="hljs-type">D</span>)</span></span> {
        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt; mList.size) {
            mList[position] = bean
            notifyItemChanged(position)
        }
    }

    <span class="hljs-comment">/*查*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: D? {
        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt; mList.size) {
            <span class="hljs-keyword">return</span> mList[position]
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
}

</code></pre>
<h3 data-id="heading-3">4.定义MultiItem接口（数据bean实现该接口，使其具备区分ItemType能力）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MultiItem</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemType</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span>
}
</code></pre>
<h3 data-id="heading-4">5.★ 构建多布局适配器BaseRvMultiAdapter</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span> yyf
 * 多布局-基类适配器
 */</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRvMultiAdapter</span>&lt;<span class="hljs-type">D : MultiItem</span>&gt; (<span class="hljs-keyword">var</span> mContext: Context) : RecyclerView.Adapter&lt;BaseViewHolder&lt;ViewBinding&gt;&gt;() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mList = mutableListOf&lt;D&gt;()

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = mList.size

    <span class="hljs-keyword">var</span> listener: ((View, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span>)? = <span class="hljs-literal">null</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setOnItemClickListener</span><span class="hljs-params">(listener: ((<span class="hljs-type">View</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)? = <span class="hljs-literal">null</span>)</span></span> {
        <span class="hljs-keyword">this</span>.listener = listener
    }

    <span class="hljs-comment">/*数据设置*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setData</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">D</span>&gt;?)</span></span> {
        list?.let {
            mList.clear()
            mList.addAll(it)
            notifyDataSetChanged()
        }
    }

    <span class="hljs-comment">/*数据获取*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>: MutableList&lt;D&gt; {
        <span class="hljs-keyword">return</span> mList
    }

    <span class="hljs-comment">/*增*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addData</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">D</span>&gt;?)</span></span> {
        <span class="hljs-keyword">if</span> (list?.isNotEmpty() == <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">var</span> start = mList.size
            mList.addAll(list)
            <span class="hljs-keyword">var</span> end = mList.size - <span class="hljs-number">1</span>
            notifyItemRangeChanged(start, end)
        }
    }

    <span class="hljs-comment">/*删*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeData</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt; mList.size) {
            mList.removeAt(position)
            notifyItemRemoved(position)
        }
    }

    <span class="hljs-comment">/*改*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateData</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>, bean: <span class="hljs-type">D</span>)</span></span> {
        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt; mList.size) {
            mList[position] = bean
            notifyItemChanged(position)
        }
    }

    <span class="hljs-comment">/*查*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getData</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: D? {
        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt; mList.size) {
            <span class="hljs-keyword">return</span> mList[position]
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">return</span> mList[position].getItemType()
    }
}
</code></pre>
<p><em><strong>干货上齐了，大家亲自尝尝看吧~</strong></em></p>
<p>————————————————— <strong>完</strong> —————————————————</p>
<p>以下使用示例可忽略了，没啥看的！</p>
<p>举个栗子：</p>
<p>UI布局 activity_main.xml</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/mListRv"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<p>条目布局 item_test.xml</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"50dp"</span>
    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
    <span class="hljs-attr">android:background</span>=<span class="hljs-string">"#80000000"</span>
    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/mName2Tv"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"name"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"-"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/mValue2Tv"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"value"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<p>条目布局 item2_test.xml</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"50dp"</span>
    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/mNameTv"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"name"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"-"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/mValueTv"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"value"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<p>单布局BaseRvAdapter的使用</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span> yyf
 * 单布局尝试
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNewAdapter</span>(context: Context) : BaseRvAdapter&lt;TestBean, ItemTestBinding&gt;(context) {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(
        parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>
    )</span></span>: BaseViewHolder&lt;ItemTestBinding&gt; {
        <span class="hljs-keyword">return</span> BaseViewHolder&lt;ItemTestBinding&gt;(ItemTestBinding.inflate(LayoutInflater.from(mContext), parent, <span class="hljs-literal">false</span>))
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(
        holder: <span class="hljs-type">BaseViewHolder</span>&lt;<span class="hljs-type">ItemTestBinding</span>&gt;,
        position: <span class="hljs-type">Int</span>
    )</span></span> {
        getData()[position].let {
            holder.viewBinding.mNameTv.text = it.name
            holder.viewBinding.mValueTv.text = it.value

            holder.viewBinding.root.setOnClickListener {
                listener?.invoke(it, position)
            }
        }
    }
}
</code></pre>
<p>多布局BaseRvMultiAdapter的使用</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span> yyf
 * 多布局尝试
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNewMultiAdapter</span>(context: Context) : BaseRvMultiAdapter&lt;TestBean&gt;(context) {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(
        parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>
    )</span></span>: BaseViewHolder&lt;ViewBinding&gt; {
        <span class="hljs-keyword">when</span> (viewType) {
            <span class="hljs-number">0</span> -&gt; {
                <span class="hljs-keyword">return</span> BaseViewHolder&lt;ViewBinding&gt;(ItemTestBinding.inflate(LayoutInflater.from(mContext), parent, <span class="hljs-literal">false</span>))
            }
            <span class="hljs-number">1</span> -&gt; {
                <span class="hljs-keyword">return</span> BaseViewHolder&lt;ViewBinding&gt;(Item2TestBinding.inflate(LayoutInflater.from(mContext), parent, <span class="hljs-literal">false</span>))
            }
        }
        <span class="hljs-keyword">return</span> BaseViewHolder&lt;ViewBinding&gt;(ItemTestBinding.inflate(LayoutInflater.from(mContext), parent, <span class="hljs-literal">false</span>))
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(
        holder: <span class="hljs-type">BaseViewHolder</span>&lt;<span class="hljs-type">ViewBinding</span>&gt;,
        position: <span class="hljs-type">Int</span>
    )</span></span> {
        getData()[position].let { bean-&gt;
            <span class="hljs-keyword">when</span> (getItemViewType(position)) {
                <span class="hljs-number">0</span> -&gt; {
                    (holder.viewBinding <span class="hljs-keyword">as</span> ItemTestBinding).mNameTv.text = bean.name
                    (holder.viewBinding <span class="hljs-keyword">as</span> ItemTestBinding).mValueTv.text = bean.value
                }
                <span class="hljs-number">1</span> -&gt; {
                    (holder.viewBinding <span class="hljs-keyword">as</span> Item2TestBinding).mName2Tv.text = bean.name
                    (holder.viewBinding <span class="hljs-keyword">as</span> Item2TestBinding).mValue2Tv.text = bean.value
                }
            }
            holder.viewBinding.root.setOnClickListener {
                listener?.invoke(it, position)
            }
        }

    }
}
</code></pre>
<p>UI层调用</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() {

    <span class="hljs-keyword">val</span> viewBinding <span class="hljs-keyword">by</span> lazy { ActivityMainBinding.inflate(LayoutInflater.from(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>)) }

    <span class="hljs-comment">//    val mAdapter by lazy { TestNewAdapter(this@MainActivity) } //单布局适配器</span>
    <span class="hljs-keyword">val</span> mAdapter <span class="hljs-keyword">by</span> lazy { TestNewMultiAdapter(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>) } <span class="hljs-comment">//多布局适配器</span>
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(viewBinding.root)

        viewBinding.mListRv.layoutManager = LinearLayoutManager(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>)
        viewBinding.mListRv.adapter = mAdapter
        mAdapter.setOnItemClickListener { view, position -&gt;
            Toast.makeText(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>, <span class="hljs-string">"点击了 position=<span class="hljs-variable">$position</span>"</span>, Toast.LENGTH_SHORT).show()
        }

        requestData()

    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestData</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">var</span> list = mutableListOf&lt;TestBean&gt;()
        <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until <span class="hljs-number">30</span>) {
            <span class="hljs-keyword">var</span> bean = TestBean()
            bean.name = <span class="hljs-string">"name <span class="hljs-variable">$index</span>"</span>
            bean.value = <span class="hljs-string">"value <span class="hljs-variable">$index</span>"</span>
            bean.type = index % <span class="hljs-number">2</span>
            list.add(bean)
        }
        mAdapter.setData(list)
    }
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[鸿蒙开发：独立开发者的烦恼之icon图标选择]]></title>    <link>https://juejin.cn/post/7605772919225090082</link>    <guid>https://juejin.cn/post/7605772919225090082</guid>    <pubDate>2026-02-13T06:24:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605772919225090082" data-draft-id="7605810996125597730" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="鸿蒙开发：独立开发者的烦恼之icon图标选择"/> <meta itemprop="keywords" content="HarmonyOS,Android,iOS"/> <meta itemprop="datePublished" content="2026-02-13T06:24:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员一鸣"/> <meta itemprop="url" content="https://juejin.cn/user/1398234520239095"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            鸿蒙开发：独立开发者的烦恼之icon图标选择
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1398234520239095/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员一鸣
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:24:18.000Z" title="Fri Feb 13 2026 06:24:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">前言</h2>
<p>企业的开发者，都有自己的UI设计师，对于图标而言，基本不会发愁，但是独立开发者，就不得不自己来考虑了，做为上架过多个应用的开发者，这一点是深有体会，有时候，为了找到一个好的，并且合适的图标，需要花费很长的时间，为了让后续的开发者少走弯路，目前总结了三个可以免费获取图标的渠道，希望可以帮助到大家。</p>
<h2 data-id="heading-1">系统的图标</h2>
<p>毋庸置疑，系统的图标是首推的，如果系统能满足的，当然以系统为主要首选。</p>
<p>系统图标目前大概有433个图标，包含了时间，箭头，媒体，相机与照片等多种分类，可以说是十分丰富，最大的便捷是，我们不用再额外配置什么，直接就可以使用，简直不要太方便。</p>
<p>地址如下：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdesign%2Fharmonyos-symbol%2F" target="_blank" title="https://developer.huawei.com/consumer/cn/design/harmonyos-symbol/" ref="nofollow noopener noreferrer">developer.huawei.com/consumer/cn…</a></p>
<p>毕竟图标太多了，大家可以点击以上的地址去详细的查看，这里就简单的截几张图吧：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c152323b589e4d15aa16d114eda1fbb2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=oTeXLBmx5xAv5rdOW7bjzj8zaHI%3D" alt="" width="70%" loading="lazy"/></p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c665de8da0934c69acd49b5011cb852d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=O00jb%2BVBhEmnkMLaiW2a0f7XrM0%3D" alt="" width="70%" loading="lazy"/></p>
<h3 data-id="heading-2">使用方式</h3>
<p>系统的图标使用也是十分的简单，给提供了两个组件用于加载，一个是SymbolGlyph组件，另一个是SymbolSpan组件，SymbolGlyph主要用于精美的图标，如渲染多色图标和使用动效图标，而SymbolSpan，则作为Text组件的子组件，主要用于在文本中穿插显示图标小符号。</p>
<h4 data-id="heading-3">SymbolGlyph组件</h4>
<p>代码如下，sys.symbol.后面连接的是图标的标识，大家打开上面的图标地址，每个图标下面都有自己的标识，选择适合的，复制即可。</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"> <span class="hljs-title class_">SymbolGlyph</span>($r(<span class="hljs-string">'sys.symbol.airplane_fill'</span>))
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)
        .<span class="hljs-title function_">renderingStrategy</span>(<span class="hljs-title class_">SymbolRenderingStrategy</span>.<span class="hljs-property">SINGLE</span>)
        .<span class="hljs-title function_">fontColor</span>([<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>])
</code></pre>
<p>以上的代码，就展示了一个大小为50，颜色为红色的飞机图标，想实现什么图标，只需要把图标标识替换即可。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7a483fdb38c4a5eaba5e961bff088de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=Msq2%2FEYZcKLvvn1nMHTM8FYkUqw%3D" alt="" loading="lazy"/></p>
<p>常用的属性如下：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/edd0c367858842c8b5ec5cf9e4a3c10c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=GV2xKuV7BacxKCqJseEY6n%2FM8d4%3D" alt="image.png" width="70%" loading="lazy"/></p>
<p><strong>SymbolRenderingStrategy</strong></p>

























<table><thead><tr><th><strong>名称</strong></th><th><strong>值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>SINGLE</td><td>0</td><td>单色模式（默认值）。可以设置一个或者多个颜色，默认为黑色。当设置多个颜色时，仅生效第一个颜色。</td></tr><tr><td>MULTIPLE_COLOR</td><td>1</td><td>多色模式。最多可以设置三个颜色。当只设置一个颜色时，修改symbol图标的第一层颜色，其他颜色保持默认颜色。颜色设置顺序与图标分层顺序匹配，当颜色数量大于图标分层时，多余的颜色不生效。仅支持设置颜色，设置透明度设置不生效。</td></tr><tr><td>MULTIPLE_OPACITY</td><td>2</td><td>分层模式。默认为黑色，可以设置一个或者多个颜色。当设置多个颜色时，仅生效第一个颜色。不透明度与图层相关，symbol图标的第一层透明度为100%、第二层透明度为50%、第三层透明度为20%。</td></tr></tbody></table>
<p><strong>SymbolEffectStrategy</strong></p>

























<table><thead><tr><th><strong>名称</strong></th><th><strong>值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>NONE</td><td>0</td><td>无动效（默认值）。</td></tr><tr><td>SCALE</td><td>1</td><td>整体缩放动效。</td></tr><tr><td>HIERARCHICAL</td><td>2</td><td>层级动效。</td></tr></tbody></table>
<p><strong>多色模式</strong></p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-title class_">SymbolGlyph</span>($r(<span class="hljs-string">'sys.symbol.ohos_folder_badge_plus'</span>))
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)
        .<span class="hljs-title function_">renderingStrategy</span>(<span class="hljs-title class_">SymbolRenderingStrategy</span>.<span class="hljs-property">MULTIPLE_COLOR</span>)
        .<span class="hljs-title function_">fontColor</span>([<span class="hljs-title class_">Color</span>.<span class="hljs-property">Black</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">Pink</span>])
</code></pre>
<p><strong>图标动效</strong></p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-title class_">SymbolGlyph</span>($r(<span class="hljs-string">'sys.symbol.ohos_wifi'</span>))
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)
        .<span class="hljs-title function_">symbolEffect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HierarchicalSymbolEffect</span>(<span class="hljs-title class_">EffectFillStyle</span>.<span class="hljs-property">ITERATIVE</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span>)
</code></pre>
<p>当然了，更多的案例，还是查看官方文档，目前，可以说，系统的图标已经是十分丰富，可以满足大部分的场景，不仅支持更改大小，颜色，也支持动效设置。</p>
<h4 data-id="heading-4">SymbolSpan组件</h4>
<p>SymbolSpan可作为Text的子组件用于显示图标小符号。可以在一个Text组件内添加多个SymbolSpan，从而展示一串连续的图标，使用上也是非常的简单，简单如下所示：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-title class_">Text</span>() {
  <span class="hljs-title class_">SymbolSpan</span>($r(<span class="hljs-string">'sys.symbol.ohos_trash'</span>))
    .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Normal</span>)
    .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">96</span>)
}
</code></pre>
<p>常用的属性如下，基本上和SymbolGlyph组件类似。</p>








































<table><thead><tr><th>属性</th><th>参数</th><th>概述</th></tr></thead><tbody><tr><td>fontColor</td><td>Array&lt;ResourceColor&gt;</td><td>图标颜色</td></tr><tr><td>fontSize</td><td>number/string/Resource</td><td>图标大小</td></tr><tr><td>fontWeight</td><td>number/FontWeight/string</td><td>图标粗细</td></tr><tr><td>renderingStrategy</td><td>SymbolRenderingStrategy</td><td>组件渲染策略</td></tr><tr><td>effectStrategy</td><td>SymbolEffectStrategy</td><td>组件动效策略</td></tr><tr><td>symbolEffect</td><td>SymbolEffect,boolean</td><td>组件动效策略及播放状态</td></tr></tbody></table>
<h2 data-id="heading-5">icon组件</h2>
<p>icon组件主要解决了系统组件无法满足的情况，比如常见的分享图标，底部tab图标等，目前拥有408个常见图标，支持更改图标颜色大小，它虽然需要依赖使用，但是整个包的大小仅仅只有200KB，总体还是非常小的。</p>
<p>icon组件地址：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fohpm.openharmony.cn%2F%23%2Fcn%2Fdetail%2F%40abner%252Ficon" target="_blank" title="https://ohpm.openharmony.cn/#/cn/detail/@abner%2Ficon" ref="nofollow noopener noreferrer">ohpm.openharmony.cn/#/cn/detail…</a></p>
<p>目前支持408个场景图标，支持颜色和大小更改，由于图标大多，这里还是截取几张效果图，详细的大家可以查看上面的地址。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2d91be9f7a0432981fc449148100556~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=QlmsqNmbBDXVJv0rw1eIodCNC%2Fk%3D" alt="" width="70%" loading="lazy"/></p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f6b1517282f94fc6857f14d9b4e052fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=aB9YV64hXB7s9lPIx4PkfR17Xok%3D" alt="" width="70%" loading="lazy"/></p>
<h3 data-id="heading-6">使用方式</h3>
<p>方式一：在Terminal窗口中，执行如下命令安装三方包，DevEco Studio会自动在工程的oh-package.json5中自动添加三方包依赖。</p>
<p><strong>建议：在使用的模块路径下进行执行命令。</strong></p>
<pre><code class="hljs language-TypeScript" lang="TypeScript">ohpm install <span class="hljs-meta">@abner</span>/icon
</code></pre>
<p>方式二：在需要的模块中的oh-package.json5中设置三方包依赖，配置示例如下：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-string">"dependencies"</span>: { <span class="hljs-string">"@abner/icon"</span>: <span class="hljs-string">"^1.0.0"</span>}
</code></pre>
<h3 data-id="heading-7">代码使用</h3>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-title class_">Icon</span>({ <span class="hljs-attr">iconModel</span>: <span class="hljs-title class_">IconModel</span>.<span class="hljs-property">wei_xin_circle</span>, <span class="hljs-attr">iconSize</span>: <span class="hljs-number">25</span> })
</code></pre>
<h3 data-id="heading-8">属性介绍</h3>
<p>常见属性配置如下：</p>






























<table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>概述</strong></th></tr></thead><tbody><tr><td>iconModel</td><td>IconModel</td><td>图标类型，传入不同类型就会展示不同图标，目前支持408种类型，具体可看上面的图标效果，每个图标下的标识就是图标类型</td></tr><tr><td>iconColor</td><td>ResourceColor</td><td>图标颜色</td></tr><tr><td>iconSize</td><td>number/string/Resource</td><td>图标大小，也可在组件外设置</td></tr><tr><td>iconBorder</td><td>BorderOptions</td><td>图标边框样式</td></tr></tbody></table>
<h2 data-id="heading-9">阿里图标库</h2>
<p>如果系统的图标和icon图标，还无法满足你的需求，那么还有一个宝藏的图标平台，那就是阿里图标库。</p>
<p>地址如下：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.iconfont.cn" target="_blank" title="https://www.iconfont.cn" ref="nofollow noopener noreferrer">www.iconfont.cn</a></p>
<p>这绝对是独立开发者的天堂，这里有无数的图标资源，格式各样，支持各种图片格式，比如，png、svg等，同样，也支持颜色更改。</p>
<p>各式各样的图标，任你去挑选。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8adf5d76d2c6413f8f1d0a12c389bdcd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=v%2F3JSfj7AJKAIoELaM9KNZ9DbB4%3D" alt="" width="70%" loading="lazy"/></p>
<p>同样，也支持搜索，可以根据中文或者英文进行检索，非常的方便，比如搜索返回，那么就会罗列出无数个返回的图标，任你挑选。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3fed9dcb86a4b63ac9e541cd5de089f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=i3Ufrv6d3WBocC2N4eDOlmYmEK4%3D" alt="" width="70%" loading="lazy"/></p>
<p>点击之后，可以更改图标的颜色，然后底部就可以进行下载，复制到项目中使用。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/45fa2dfa730e40a98f88e3ffc4e9b52c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5LiA6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771568657&amp;x-signature=tcBDBYc8FnANFKkmeB4MlCOJuKc%3D" alt="" width="70%" loading="lazy"/></p>
<h2 data-id="heading-10">相关总结</h2>
<p>目前的三种方式，可以说，完全能够满足日常的图标需求，这里最值得推荐的还是系统的图标库，毕竟自带的，不用任何的依赖，也不存在包体积的增加，大小、颜色、动效等等都可以原生实现，还是非常的方便的。当然了，如果原生无法满足的情况下，后面的两种方式，也是值得大家来尝试的，总之，选择一个自己适合的方式。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[seedance 2.0，让创作者成为内容可控的导演，附免费体验教程]]></title>    <link>https://juejin.cn/post/7605625595570978831</link>    <guid>https://juejin.cn/post/7605625595570978831</guid>    <pubDate>2026-02-13T06:01:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605625595570978831" data-draft-id="7605542907119452212" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="seedance 2.0，让创作者成为内容可控的导演，附免费体验教程"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2026-02-13T06:01:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="陌晨"/> <meta itemprop="url" content="https://juejin.cn/user/4352310171673354"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            seedance 2.0，让创作者成为内容可控的导演，附免费体验教程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4352310171673354/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    陌晨
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:01:00.000Z" title="Fri Feb 13 2026 06:01:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是陌晨，分享有用的AI知识与工具，喜欢记得关注。</p>
<p>这几天seedance2.0又被连续刷屏，记得去年这时候也是deepseek的刷屏，进度超快。再看元宝、千问他们春节大尺度撒币，在真正解决需求的层面上，还是会被碾压。</p>
<p>seedance2.0为什么被刷屏，从团队发布的信息看，主要是：</p>
<blockquote>
<p>❝</p>
<p>Seedance 2.0 采用统一的多模态音视频联合生成架构，支持文字、图片、音频、视频四种模态输入，集成了目前业界最全面的多模态内容参考和编辑能力。`</p>
</blockquote>
<p>解读到实际应用上，就是：你可以用一张图定下画面风格，用一个视频指定角色的动作和镜头的变化，再用几秒音频带起节奏氛围，搭配提示词，让创作过程变得更自然、更高效，也更像真正的“导演”。</p>
<p><strong>在内容创作上，可控对创作者来说真是太重要。</strong></p>
<blockquote>
<p>❝</p>
<p><strong>seedance 2.0官方使用手册:</strong> <code>https://bytedance.larkoffice.com/wiki/A5RHwWhoBiOnjukIIw6cu5ybnXQ</code></p>
</blockquote>
<h2 data-id="heading-0">快速使用seedance 2.0</h2>
<ul>
<li>即梦网页端-视频生成-选择 Seedance 2.0；</li>
<li>豆包 App 对话框-Seedance2.0-选择 2.0 模型；</li>
<li>火山方舟体验中心-选择 Doubao-Seedance-2.0。</li>
</ul>
<h3 data-id="heading-1">即梦网页端</h3>
<p>访问入口：<em><a href="https://link.juejin.cn?target=https%3A%2F%2Fjimeng.jianying.com%2Fai-tool%2Fhome" target="_blank" title="https://jimeng.jianying.com/ai-tool/home" ref="nofollow noopener noreferrer">jimeng.jianying.com/ai-tool/hom…</a></em></p>
<p>选择视频生成-选择 Seedance 2.0，如截图所示</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f50805d737f545f1b773c72507862a22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZmM5pmo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567260&amp;x-signature=VELOz8MPqbqGY2luSc%2FYD4f%2FXtc%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-2">豆包APP端</h3>
<p>升级到最新版豆包，下方即可看到入口。对话框-Seedance2.0-选择 2.0 模型；</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/167cb74369614ebe8bf64879ead91ae3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZmM5pmo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567260&amp;x-signature=v7R83hkwsUFtAH2nz%2B9u3jr7q7k%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-3">火山引擎</h3>
<p>访问入口： <a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.volcengine.com%2Fark%2Fregion%3Aark%2Bcn-beijing%2Fexperience%2Fvision%3FmodelId%3Ddoubao-seedance-2-0-260128%26tab%3DGenVideo" target="_blank" title="https://console.volcengine.com/ark/region:ark+cn-beijing/experience/vision?modelId=doubao-seedance-2-0-260128&amp;tab=GenVideo" ref="nofollow noopener noreferrer">console.volcengine.com/ark/region:…</a></p>
<p>直接送500万token，诚意满满可以放心薅。大概可生成1-2分钟视频，体验足够。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4c9752580ac4267b03887bd35a2846a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZmM5pmo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771567260&amp;x-signature=eGqnlVYCrHmMj7l3HYZ0zpt8ZSY%3D" alt="图片" loading="lazy"/></p>
<p>有感兴趣的同学可以去体验，提示词直接用我们的口语表达即可。</p>
<p><strong>感谢读到这里，如果文章有帮助到你，欢迎点赞关注。我是陌晨，咱们下次见。</strong></p>
<h6 data-id="heading-4">相关内容推荐</h6>
<h6 data-id="heading-5">4 步搞定 Claude code 搭建！小白也能轻松上手</h6>
<h6 data-id="heading-6">coze工作流自动生成爆火的星座运势内容，插件免费，去AI味成功标原创</h6>
<h6 data-id="heading-7">爆款小红书健康养生赛道图文，Deepseek+Coze工作流，5分钟批量生成100篇，附送教程</h6>
<h6 data-id="heading-8">##### 更多AI探索及案例欢迎扫码备注“AI”拉你入群。</h6></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[NanoBot 向量记忆系统升级实现重要记忆用不丢失]]></title>    <link>https://juejin.cn/post/7605807405307822143</link>    <guid>https://juejin.cn/post/7605807405307822143</guid>    <pubDate>2026-02-13T05:54:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605807405307822143" data-draft-id="7605539194690945024" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="NanoBot 向量记忆系统升级实现重要记忆用不丢失"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T05:54:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="贺卫国"/> <meta itemprop="url" content="https://juejin.cn/user/932842324370135"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            NanoBot 向量记忆系统升级实现重要记忆用不丢失
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/932842324370135/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    贺卫国
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:54:20.000Z" title="Fri Feb 13 2026 05:54:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">NanoBot 向量记忆系统升级实战指南（完整版）</h2>
<blockquote>
<p><strong>预估时间</strong>: 15-20分钟</p>
<p><strong>重要提示</strong>: 可以将这个文章中直接喂给运行中的nanobot让他自动迁移替换</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">一、项目介绍</h3>
<h4 data-id="heading-2">1.1 升级背景</h4>
<p>原版NanoBot使用简单的Markdown文件存储记忆，存在以下痛点，本指南详细介绍如何将 NanoBot 的简单 Markdown 记忆系统升级为基于 SQLite + 向量嵌入的智能记忆系统，实现语义检索、自动优化、长久保存。</p>

























<table><thead><tr><th>缺陷</th><th>影响</th></tr></thead><tbody><tr><td>关键词匹配</td><td>只能精确匹配，无法理解语义，"发邮件"和"邮件发送"被认为是不同的</td></tr><tr><td>无优先级管理</td><td>重要记忆和闲聊混在一起，检索时容易被淹没</td></tr><tr><td>手动维护</td><td>需要人工清理旧文件，随着使用时间越长越混乱</td></tr><tr><td>无上下文关联</td><td>无法根据对话历史自动提取相关记忆</td></tr></tbody></table>
<h4 data-id="heading-3">1.2 升级后的优势</h4>
<ul>
<li>✅ <strong>语义理解</strong>: "怎么处理邮件"能匹配到"邮件回复要高质量"</li>
<li>✅ <strong>自动优化</strong>: 自动合并重复、清理无效、调整优先级</li>
<li>✅ <strong>长久保存</strong>: SQLite单文件存储，高价值记忆永不丢失</li>
<li>✅ <strong>轻量无负担</strong>: 仅增加2个Python依赖，总大小 &lt; 100MB</li>
</ul>
<hr/>
<h3 data-id="heading-4">二、核心架构设计</h3>
<h4 data-id="heading-5">2.1 目录结构（避坑重点）</h4>
<p>❌ <strong>错误做法</strong>（单文件）</p>
<pre><code class="hljs language-bash" lang="bash">nanobot/agent/
├── memory.py          <span class="hljs-comment"># 所有代码塞在一个文件</span>
└── ...
</code></pre>
<p>✅ <strong>正确做法</strong>（Python包）</p>
<pre><code class="hljs language-bash" lang="bash">nanobot/agent/
├── memory/                    <span class="hljs-comment"># Python包目录</span>
│   ├── __init__.py           <span class="hljs-comment"># 包入口，关键！</span>
│   ├── store.py              <span class="hljs-comment"># 原有 MemoryStore 类</span>
│   └── vector_store.py       <span class="hljs-comment"># 增强版 EnhancedMemoryStore</span>
└── ...
</code></pre>
<blockquote>
<p>⚠️ <strong>避坑提示</strong>: 必须将 <code>memory.py</code> 改为 <code>memory/</code> 目录，否则在 Windows 和 Linux 上会出现导入错误！</p>
</blockquote>
<h4 data-id="heading-6">2.2 核心组件</h4>

























<table><thead><tr><th>组件</th><th>功能</th><th>技术栈</th></tr></thead><tbody><tr><td><code>MemoryStore</code></td><td>基础文件存储</td><td>Markdown + 文件IO</td></tr><tr><td><code>EnhancedMemoryStore</code></td><td>增强向量存储</td><td>SQLite + sentence-transformers</td></tr><tr><td><code>自优化器</code></td><td>自动维护记忆</td><td>APScheduler + 相似度计算</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-7">三、完整代码实现</h3>
<h4 data-id="heading-8">3.1 memory/<strong>init</strong>.py（包入口）</h4>
<p>这是<strong>最关键的文件</strong>，它决定了外部如何导入你的模块。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># nanobot/agent/memory/__init__.py</span>
<span class="hljs-string">"""
NanoBot 记忆系统包
支持向后兼容：未安装向量依赖时自动回退到文件存储
"""</span>

<span class="hljs-comment"># 导入基础存储（原有功能）</span>
<span class="hljs-keyword">from</span> nanobot.agent.memory.store <span class="hljs-keyword">import</span> MemoryStore

<span class="hljs-comment"># 尝试导入增强存储，失败时回退</span>
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">from</span> nanobot.agent.memory.vector_store <span class="hljs-keyword">import</span> EnhancedMemoryStore
<span class="hljs-keyword">except</span> ImportError:
    <span class="hljs-comment"># 如果未安装 sentence-transformers，使用基础版</span>
    EnhancedMemoryStore = MemoryStore

__all__ = [<span class="hljs-string">'MemoryStore'</span>, <span class="hljs-string">'EnhancedMemoryStore'</span>]
</code></pre>
<p><strong>设计亮点</strong>:</p>
<ul>
<li>使用 <code>try/except</code> 实现容错导入</li>
<li>确保用户未安装依赖时不会报错，自动回退到原有功能</li>
</ul>
<hr/>
<h4 data-id="heading-9">3.2 memory/store.py（基础存储类）</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># nanobot/agent/memory/store.py</span>
<span class="hljs-string">"""
基础记忆存储类
保持向后兼容，支持Markdown文件存储
"""</span>

<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">Optional</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryStore</span>:
    <span class="hljs-string">"""
    基础记忆存储类
    使用Markdown文件持久化存储
    """</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, workspace: Path</span>):
        <span class="hljs-string">"""
        初始化记忆存储
        
        Args:
            workspace: NanoBot工作目录
        """</span>
        self.workspace = workspace
        self.memory_file = workspace / <span class="hljs-string">"memory"</span> / <span class="hljs-string">"MEMORY.md"</span>
        self.memory_file.parent.mkdir(parents=<span class="hljs-literal">True</span>, exist_ok=<span class="hljs-literal">True</span>)
        
        <span class="hljs-comment"># 如果文件不存在，创建初始文件</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.memory_file.exists():
            self.memory_file.write_text(<span class="hljs-string">"# NanoBot 记忆档案\n\n"</span>, encoding=<span class="hljs-string">'utf-8'</span>)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, content: <span class="hljs-built_in">str</span>, category: <span class="hljs-built_in">str</span> = <span class="hljs-string">"general"</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""
        添加记忆
        
        Args:
            content: 记忆内容
            category: 分类标签
            
        Returns:
            是否添加成功
        """</span>
        timestamp = datetime.now().isoformat()
        entry = <span class="hljs-string">f"\n## [<span class="hljs-subst">{category}</span>] <span class="hljs-subst">{timestamp}</span>\n<span class="hljs-subst">{content}</span>\n"</span>
        
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.memory_file, <span class="hljs-string">'a'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
                f.write(entry)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"保存记忆失败: <span class="hljs-subst">{e}</span>"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, keyword: <span class="hljs-built_in">str</span>, limit: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>]:
        <span class="hljs-string">"""
        关键词搜索（基础版）
        
        Args:
            keyword: 搜索关键词
            limit: 返回结果数量
            
        Returns:
            匹配的记忆列表
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.memory_file.exists():
            <span class="hljs-keyword">return</span> []
        
        results = []
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.memory_file, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
            content = f.read()
        
        <span class="hljs-comment"># 简单的关键词匹配</span>
        sections = content.split(<span class="hljs-string">"## ["</span>)
        <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> sections[<span class="hljs-number">1</span>:]:  <span class="hljs-comment"># 跳过第一个空部分</span>
            <span class="hljs-keyword">if</span> keyword.lower() <span class="hljs-keyword">in</span> section.lower():
                lines = section.split(<span class="hljs-string">"\n"</span>)
                <span class="hljs-keyword">if</span> lines:
                    header = lines[<span class="hljs-number">0</span>].strip()
                    body = <span class="hljs-string">"\n"</span>.join(lines[<span class="hljs-number">1</span>:]).strip()
                    results.append({
                        <span class="hljs-string">"header"</span>: header,
                        <span class="hljs-string">"content"</span>: body[:<span class="hljs-number">200</span>] + <span class="hljs-string">"..."</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(body) &gt; <span class="hljs-number">200</span> <span class="hljs-keyword">else</span> body
                    })
        
        <span class="hljs-keyword">return</span> results[:limit]
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_context</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, n_turns: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""
        获取对话上下文
        
        Args:
            query: 查询词
            n_turns: 返回记忆条数
            
        Returns:
            格式化的上下文字符串
        """</span>
        results = self.search(query, limit=n_turns)
        
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> results:
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
        
        context_parts = []
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:
            context_parts.append(<span class="hljs-string">f"- <span class="hljs-subst">{r[<span class="hljs-string">'header'</span>]}</span>: <span class="hljs-subst">{r[<span class="hljs-string">'content'</span>]}</span>"</span>)
        
        <span class="hljs-keyword">return</span> <span class="hljs-string">"\n"</span>.join(context_parts)
</code></pre>
<hr/>
<h4 data-id="heading-10">3.3 memory/vector_store.py（增强向量存储 - 第一部分）</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># nanobot/agent/memory/vector_store.py</span>
<span class="hljs-string">"""
增强版记忆存储：SQLite + 向量嵌入
实现语义检索、自动优化、长久保存
"""</span>

<span class="hljs-keyword">import</span> sqlite3
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">Optional</span>, <span class="hljs-type">Tuple</span>

<span class="hljs-comment"># 尝试导入 sentence-transformers，如果未安装则提示安装</span>
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">from</span> sentence_transformers <span class="hljs-keyword">import</span> SentenceTransformer
    VECTOR_AVAILABLE = <span class="hljs-literal">True</span>
<span class="hljs-keyword">except</span> ImportError:
    VECTOR_AVAILABLE = <span class="hljs-literal">False</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 提示：未安装 sentence-transformers，请运行: pip install sentence-transformers"</span>)

<span class="hljs-comment"># 继承原有 MemoryStore 实现向后兼容</span>
<span class="hljs-keyword">from</span> nanobot.agent.memory.store <span class="hljs-keyword">import</span> MemoryStore


<span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedMemoryStore</span>(<span class="hljs-title class_ inherited__">MemoryStore</span>):
    <span class="hljs-string">"""
    增强版记忆存储系统
    
    特性:
    - 语义检索：基于向量相似度，理解查询意图
    - 自动优化：合并重复、清理无效、调整优先级
    - 长久保存：SQLite 持久化，高价值记忆保护
    - 向后兼容：继承 MemoryStore，原有 API 完全兼容
    """</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, workspace: Path, model_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">'all-MiniLM-L6-v2'</span></span>):
        <span class="hljs-string">"""
        初始化增强记忆系统
        
        Args:
            workspace: NanoBot 工作目录
            model_name: 嵌入模型名称（默认 80MB 轻量模型）
        """</span>
        <span class="hljs-comment"># 调用父类初始化（保持向后兼容）</span>
        <span class="hljs-built_in">super</span>().__init__(workspace)
        
        self.workspace = workspace
        self.db_path = workspace / <span class="hljs-string">"memory"</span> / <span class="hljs-string">"vector_memory.db"</span>
        self.db_path.parent.mkdir(parents=<span class="hljs-literal">True</span>, exist_ok=<span class="hljs-literal">True</span>)
        
        <span class="hljs-comment"># 检查依赖</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> VECTOR_AVAILABLE:
            <span class="hljs-keyword">raise</span> ImportError(
                <span class="hljs-string">"请先安装依赖： pip install sentence-transformers"</span>
            )
        
        <span class="hljs-comment"># 加载嵌入模型（首次加载约需 2-3 秒）</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"🧠 加载向量嵌入模型..."</span>)
        self.model = SentenceTransformer(model_name)
        self.embedding_dim = self.model.get_sentence_embedding_dimension()
        
        <span class="hljs-comment"># 初始化数据库</span>
        self._init_database()
        
        <span class="hljs-comment"># 加载或初始化检索参数（用于自优化）</span>
        self.retrieval_params = self._load_retrieval_params()
        
        <span class="hljs-comment"># 操作计数器（用于触发轻量优化）</span>
        self.operation_count = <span class="hljs-number">0</span>
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ 向量记忆系统就绪 | 维度: <span class="hljs-subst">{self.embedding_dim}</span> | 数据库: <span class="hljs-subst">{self.db_path}</span>"</span>)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_init_database</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""初始化 SQLite 数据库表结构"""</span>
        <span class="hljs-keyword">with</span> sqlite3.connect(self.db_path) <span class="hljs-keyword">as</span> conn:
            conn.execute(<span class="hljs-string">"""
                CREATE TABLE IF NOT EXISTS memories (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    content TEXT NOT NULL,
                    category TEXT DEFAULT 'general',
                    priority REAL DEFAULT 5.0,
                    access_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    is_deleted INTEGER DEFAULT 0,
                    deleted_reason TEXT,
                    embedding BLOB
                )
            """</span>)
            
            <span class="hljs-comment"># 创建索引加速检索</span>
            conn.execute(<span class="hljs-string">"CREATE INDEX IF NOT EXISTS idx_priority ON memories(priority DESC)"</span>)
            conn.execute(<span class="hljs-string">"CREATE INDEX IF NOT EXISTS idx_category ON memories(category)"</span>)
            conn.execute(<span class="hljs-string">"CREATE INDEX IF NOT EXISTS idx_deleted ON memories(is_deleted)"</span>)
            conn.commit()
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_load_retrieval_params</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>:
        <span class="hljs-string">"""加载检索参数（用于自优化）"""</span>
        params_file = self.workspace / <span class="hljs-string">"memory"</span> / <span class="hljs-string">"retrieval_params.json"</span>
        <span class="hljs-keyword">if</span> params_file.exists():
            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(params_file, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
                <span class="hljs-keyword">return</span> json.load(f)
        <span class="hljs-comment"># 默认参数</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"top_k"</span>: <span class="hljs-number">5</span>,
            <span class="hljs-string">"similarity_threshold"</span>: <span class="hljs-number">0.7</span>,
            <span class="hljs-string">"recall_rate_history"</span>: []
        }
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_save_retrieval_params</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""保存检索参数"""</span>
        params_file = self.workspace / <span class="hljs-string">"memory"</span> / <span class="hljs-string">"retrieval_params.json"</span>
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(params_file, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
            json.dump(self.retrieval_params, f)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_embedding</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span></span>) -&gt; np.ndarray:
        <span class="hljs-string">"""
        生成文本的向量嵌入
        
        Args:
            text: 输入文本
            
        Returns:
            float16 格式的向量（节省50%存储空间）
        """</span>
        embedding = self.model.encode(text, convert_to_numpy=<span class="hljs-literal">True</span>)
        <span class="hljs-comment"># float16 压缩节省 50% 存储空间</span>
        <span class="hljs-keyword">return</span> embedding.astype(np.float16)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, content: <span class="hljs-built_in">str</span>, category: <span class="hljs-built_in">str</span> = <span class="hljs-string">"general"</span>, 
            priority: <span class="hljs-built_in">float</span> = <span class="hljs-number">5.0</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""
        添加记忆（增强版）
        
        同时写入：
        1. 父类的 Markdown 文件（向后兼容）
        2. 向量数据库（语义检索）
        
        Args:
            content: 记忆内容
            category: 分类标签（core_rule/preference/tech_note等）
            priority: 优先级 0-10，越高越重要（&gt;=7 为长久保护）
            
        Returns:
            是否添加成功
        """</span>
        <span class="hljs-comment"># 1. 调用父类方法写入文件（向后兼容）</span>
        <span class="hljs-built_in">super</span>().add(content, category)
        
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># 2. 生成向量嵌入</span>
            embedding = self._get_embedding(content)
            embedding_blob = pickle.dumps(embedding)
            
            <span class="hljs-comment"># 3. 存入 SQLite</span>
            <span class="hljs-keyword">with</span> sqlite3.connect(self.db_path) <span class="hljs-keyword">as</span> conn:
                conn.execute(<span class="hljs-string">"""
                    INSERT INTO memories 
                    (content, category, priority, embedding)
                    VALUES (?, ?, ?, ?)
                """</span>, (content, category, priority, embedding_blob))
                conn.commit()
            
            <span class="hljs-comment"># 4. 触发轻量优化（每 10 次操作）</span>
            self.operation_count += <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> self.operation_count &gt;= <span class="hljs-number">10</span>:
                self._lightweight_optimize()
                self.operation_count = <span class="hljs-number">0</span>
            
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"向量存储失败: <span class="hljs-subst">{e}</span>"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
<hr/>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, limit: <span class="hljs-built_in">int</span> = <span class="hljs-literal">None</span>, 
           use_semantic: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>]:
    <span class="hljs-string">"""
    搜索记忆（增强版）
    
    支持两种模式：
    - 语义检索（默认）：理解查询意图
    - 关键词检索：与父类保持一致
    
    自动更新访问统计和优先级
    
    Args:
        query: 查询词
        limit: 返回结果数量
        use_semantic: 是否使用语义检索
        
    Returns:
        匹配的记忆列表（包含相似度得分）
    """</span>
    <span class="hljs-keyword">if</span> limit <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        limit = self.retrieval_params[<span class="hljs-string">"top_k"</span>]
    
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> use_semantic:
        <span class="hljs-comment"># 回退到父类的关键词搜索</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().search(query, limit)
    
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 1. 生成查询向量</span>
        query_embedding = self._get_embedding(query)
        
        <span class="hljs-comment"># 2. 检索所有有效记忆</span>
        <span class="hljs-keyword">with</span> sqlite3.connect(self.db_path) <span class="hljs-keyword">as</span> conn:
            cursor = conn.execute(<span class="hljs-string">"""
                SELECT id, content, category, priority, access_count, 
                       created_at, embedding
                FROM memories
                WHERE is_deleted = 0
                ORDER BY priority DESC
            """</span>)
            
            memories = cursor.fetchall()
        
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> memories:
            <span class="hljs-keyword">return</span> []
        
        <span class="hljs-comment"># 3. 计算相似度</span>
        similarities = []
        <span class="hljs-keyword">for</span> mem <span class="hljs-keyword">in</span> memories:
            mem_id, content, category, priority, access_count, created_at, emb_blob = mem
            mem_embedding = pickle.loads(emb_blob)
            
            <span class="hljs-comment"># 余弦相似度</span>
            similarity = np.dot(query_embedding, mem_embedding) / (
                np.linalg.norm(query_embedding) * np.linalg.norm(mem_embedding)
            )
            
            <span class="hljs-comment"># 综合评分 = 相似度 * 优先级权重</span>
            score = similarity * (<span class="hljs-number">1</span> + priority / <span class="hljs-number">10</span>)
            similarities.append((mem_id, content, category, priority, 
                               access_count, created_at, score, similarity))
        
        <span class="hljs-comment"># 4. 过滤和排序</span>
        threshold = self.retrieval_params[<span class="hljs-string">"similarity_threshold"</span>]
        filtered = [s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> similarities <span class="hljs-keyword">if</span> s[<span class="hljs-number">7</span>] &gt;= threshold]
        filtered.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">6</span>], reverse=<span class="hljs-literal">True</span>)
        
        results = filtered[:limit]
        
        <span class="hljs-comment"># 5. 更新访问统计（用于自优化）</span>
        self._update_access_stats([r[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results])
        
        <span class="hljs-comment"># 6. 返回格式化结果</span>
        <span class="hljs-keyword">return</span> [{
            <span class="hljs-string">"id"</span>: r[<span class="hljs-number">0</span>],
            <span class="hljs-string">"content"</span>: r[<span class="hljs-number">1</span>],
            <span class="hljs-string">"category"</span>: r[<span class="hljs-number">2</span>],
            <span class="hljs-string">"priority"</span>: r[<span class="hljs-number">3</span>],
            <span class="hljs-string">"score"</span>: <span class="hljs-built_in">round</span>(r[<span class="hljs-number">6</span>], <span class="hljs-number">3</span>),
            <span class="hljs-string">"similarity"</span>: <span class="hljs-built_in">round</span>(r[<span class="hljs-number">7</span>], <span class="hljs-number">3</span>)
        } <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results]
        
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"语义搜索失败: <span class="hljs-subst">{e}</span>，回退到关键词搜索"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().search(query, limit)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_access_stats</span>(<span class="hljs-params">self, memory_ids: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):
    <span class="hljs-string">"""
    更新记忆访问统计（用于优先级自优化）
    
    每次访问后，优先级微微提升（上限 10）
    """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> memory_ids:
        <span class="hljs-keyword">return</span>
    
    <span class="hljs-keyword">with</span> sqlite3.connect(self.db_path) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">for</span> mem_id <span class="hljs-keyword">in</span> memory_ids:
            conn.execute(<span class="hljs-string">"""
                UPDATE memories
                SET access_count = access_count + 1,
                    last_accessed = CURRENT_TIMESTAMP,
                    priority = MIN(10.0, priority + 0.1)
                WHERE id = ?
            """</span>, (mem_id,))
        conn.commit()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_context</span>(<span class="hljs-params">self, query: <span class="hljs-built_in">str</span>, n_turns: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""
    获取对话上下文
    
    用于 Agent Loop 中构造 prompt，自动提取相关记忆
    
    Args:
        query: 用户查询
        n_turns: 返回记忆条数
        
    Returns:
        格式化的上下文字符串
    """</span>
    results = self.search(query, limit=n_turns)
    
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> results:
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
    
    context_parts = []
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:
        priority_marker = <span class="hljs-string">"🔴"</span> <span class="hljs-keyword">if</span> r[<span class="hljs-string">'priority'</span>] &gt;= <span class="hljs-number">7</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"⚪"</span>
        context_parts.append(
            <span class="hljs-string">f"<span class="hljs-subst">{priority_marker}</span> [<span class="hljs-subst">{r[<span class="hljs-string">'category'</span>]}</span>] <span class="hljs-subst">{r[<span class="hljs-string">'content'</span>]}</span>"</span>
        )
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">"\n"</span>.join(context_parts)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, memory_id: <span class="hljs-built_in">int</span>, reason: <span class="hljs-built_in">str</span> = <span class="hljs-string">""</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">"""
    软删除记忆（可恢复）
    
    高优先级记忆（&gt;=7）会提示警告
    
    Args:
        memory_id: 记忆ID
        reason: 删除原因
        
    Returns:
        是否删除成功
    """</span>
    <span class="hljs-keyword">with</span> sqlite3.connect(self.db_path) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-comment"># 检查优先级</span>
        cursor = conn.execute(
            <span class="hljs-string">"SELECT priority, content FROM memories WHERE id = ?"</span>,
            (memory_id,)
        )
        row = cursor.fetchone()
        
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> row:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        
        priority, content = row
        <span class="hljs-keyword">if</span> priority &gt;= <span class="hljs-number">7</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"⚠️ 警告：删除高优先级记忆（<span class="hljs-subst">{priority}</span>分）: <span class="hljs-subst">{content[:<span class="hljs-number">50</span>]}</span>..."</span>)
        
        <span class="hljs-comment"># 软删除</span>
        conn.execute(<span class="hljs-string">"""
            UPDATE memories
            SET is_deleted = 1, deleted_reason = ?
            WHERE id = ?
        """</span>, (reason, memory_id))
        conn.commit()
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">restore</span>(<span class="hljs-params">self, memory_id: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">"""恢复软删除的记忆"""</span>
    <span class="hljs-keyword">with</span> sqlite3.connect(self.db_path) <span class="hljs-keyword">as</span> conn:
        conn.execute(<span class="hljs-string">"""
            UPDATE memories
            SET is_deleted = 0, deleted_reason = NULL
            WHERE id = ?
        """</span>, (memory_id,))
        conn.commit()
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<hr/>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_lightweight_optimize</span>(<span class="hljs-params">self</span>):
    <span class="hljs-string">"""
    轻量优化（每10次操作触发）
    
    - 合并重复记忆（相似度 &gt; 0.9）
    - 清理低价值记忆（优先级 &lt; 3 且 30天未访问）
    """</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> sqlite3.connect(self.db_path) <span class="hljs-keyword">as</span> conn:
            <span class="hljs-comment"># 1. 查找并标记重复记忆</span>
            cursor = conn.execute(<span class="hljs-string">"""
                SELECT id, content, embedding FROM memories
                WHERE is_deleted = 0
                ORDER BY priority DESC, created_at ASC
            """</span>)
            memories = cursor.fetchall()
            
            to_merge = []
            <span class="hljs-keyword">for</span> i, (id1, content1, emb1_blob) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(memories):
                <span class="hljs-keyword">if</span> id1 <span class="hljs-keyword">in</span> [m[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> to_merge]:
                    <span class="hljs-keyword">continue</span>
                
                emb1 = pickle.loads(emb1_blob)
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(memories)):
                    id2, content2, emb2_blob = memories[j]
                    emb2 = pickle.loads(emb2_blob)
                    
                    similarity = np.dot(emb1, emb2) / (
                        np.linalg.norm(emb1) * np.linalg.norm(emb2)
                    )
                    
                    <span class="hljs-keyword">if</span> similarity &gt; <span class="hljs-number">0.9</span>:
                        to_merge.append((id1, id2, similarity))
            
            <span class="hljs-comment"># 标记重复（保留高优先级的）</span>
            <span class="hljs-keyword">for</span> keep_id, del_id, sim <span class="hljs-keyword">in</span> to_merge:
                conn.execute(<span class="hljs-string">"""
                    UPDATE memories
                    SET is_deleted = 1, deleted_reason = ?
                    WHERE id = ?
                """</span>, (<span class="hljs-string">f"重复记忆，与ID:<span class="hljs-subst">{keep_id}</span>相似度<span class="hljs-subst">{sim:<span class="hljs-number">.2</span>f}</span>"</span>, del_id))
            
            <span class="hljs-comment"># 2. 清理低价值记忆</span>
            conn.execute(<span class="hljs-string">"""
                UPDATE memories
                SET is_deleted = 1, deleted_reason = '低价值自动清理'
                WHERE priority &lt; 3 
                  AND access_count = 0
                  AND created_at &lt; datetime('now', '-30 days')
                  AND is_deleted = 0
            """</span>)
            
            conn.commit()
            
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"轻量优化失败: <span class="hljs-subst">{e}</span>"</span>)
</code></pre>
<hr/>
<h4 data-id="heading-11">3.4 安装脚本 setup_vector_memory.sh</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># setup_vector_memory.sh</span>
<span class="hljs-comment"># 一键安装 NanoBot 向量记忆系统</span>

<span class="hljs-built_in">set</span> -e  <span class="hljs-comment"># 遇到错误立即退出</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"🚀 开始安装向量记忆系统..."</span>

<span class="hljs-comment"># 1. 检查 Python 版本</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"🔍 检查 Python 版本..."</span>
python3 --version || { <span class="hljs-built_in">echo</span> <span class="hljs-string">"❌ 需要 Python 3.8+"</span>; <span class="hljs-built_in">exit</span> 1; }

<span class="hljs-comment"># 2. 安装依赖</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"📦 安装 Python 依赖..."</span>
pip3 install --upgrade pip
pip3 install sentence-transformers apscheduler numpy

<span class="hljs-comment"># 3. 创建目录结构</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"📁 创建目录结构..."</span>
<span class="hljs-built_in">mkdir</span> -p nanobot/agent/memory

<span class="hljs-comment"># 4. 检测安装</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"✅ 验证安装..."</span>
python3 -c <span class="hljs-string">"from sentence_transformers import SentenceTransformer; print('✓ sentence-transformers 安装成功')"</span>
python3 -c <span class="hljs-string">"import apscheduler; print('✓ apscheduler 安装成功')"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">""</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"🎉 安装完成！请将以下文件复制到对应位置："</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"  - memory/__init__.py → nanobot/agent/memory/"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"  - memory/store.py → nanobot/agent/memory/"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"  - memory/vector_store.py → nanobot/agent/memory/"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">""</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"📚 使用方法参阅博文正文"</span>
</code></pre>
<hr/>
<h4 data-id="heading-12">3.5 验证测试 test_memory.py</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#!/usr/bin/env python3</span>
<span class="hljs-comment"># test_memory.py</span>
<span class="hljs-comment"># 验证向量记忆系统是否正常工作</span>

<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path

<span class="hljs-comment"># 添加到路径</span>
sys.path.insert(<span class="hljs-number">0</span>, <span class="hljs-built_in">str</span>(Path(__file__).parent))

<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">from</span> nanobot.agent.memory <span class="hljs-keyword">import</span> EnhancedMemoryStore
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 导入成功"</span>)
<span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> e:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 导入失败: <span class="hljs-subst">{e}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"请先运行: pip install sentence-transformers"</span>)
    sys.exit(<span class="hljs-number">1</span>)

<span class="hljs-comment"># 初始化</span>
workspace = Path(<span class="hljs-string">"./test_workspace"</span>)
workspace.mkdir(exist_ok=<span class="hljs-literal">True</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"🚀 初始化记忆系统..."</span>)
memory = EnhancedMemoryStore(workspace)

<span class="hljs-comment"># 测试添加</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"📝 测试添加记忆..."</span>)
memory.add(<span class="hljs-string">"我喜欢用Python写代码"</span>, category=<span class="hljs-string">"preference"</span>, priority=<span class="hljs-number">8.0</span>)
memory.add(<span class="hljs-string">"处理邮件需要注意格式美观"</span>, category=<span class="hljs-string">"rule"</span>, priority=<span class="hljs-number">9.0</span>)
memory.add(<span class="hljs-string">"数据分析需要pandas库"</span>, category=<span class="hljs-string">"tech_note"</span>, priority=<span class="hljs-number">6.0</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 添加成功"</span>)

<span class="hljs-comment"># 测试语义搜索</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"🔍 测试语义搜索..."</span>)
results = memory.search(<span class="hljs-string">"怎么写代码"</span>, use_semantic=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"找到 <span class="hljs-subst">{<span class="hljs-built_in">len</span>(results)}</span> 条相关记忆:"</span>)
<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  - [<span class="hljs-subst">{r[<span class="hljs-string">'category'</span>]}</span>] 相似度:<span class="hljs-subst">{r[<span class="hljs-string">'similarity'</span>]}</span> <span class="hljs-subst">{r[<span class="hljs-string">'content'</span>][:<span class="hljs-number">30</span>]}</span>..."</span>)

<span class="hljs-comment"># 测试上下文获取</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"💭 测试上下文获取..."</span>)
context = memory.get_context(<span class="hljs-string">"我想学习编程"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"上下文:\n<span class="hljs-subst">{context}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n🎉 所有测试通过！"</span>)
</code></pre>
<hr/>
<h3 data-id="heading-13">四、安装与使用指南</h3>
<h4 data-id="heading-14">4.1 安装步骤</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 安装依赖</span>
pip3 install sentence-transformers apscheduler

<span class="hljs-comment"># 2. 创建目录结构</span>
<span class="hljs-built_in">cd</span> nanobot/agent
<span class="hljs-built_in">mkdir</span> -p memory
<span class="hljs-built_in">mv</span> memory.py memory/store.py  <span class="hljs-comment"># 移动原有文件</span>

<span class="hljs-comment"># 3. 创建 __init__.py 和 vector_store.py</span>
<span class="hljs-comment"># （复制上面的完整代码）</span>

<span class="hljs-comment"># 4. 更新导入</span>
<span class="hljs-comment"># 修改 context.py: </span>
<span class="hljs-comment"># from nanobot.agent.memory import EnhancedMemoryStore</span>
</code></pre>
<h4 data-id="heading-15">4.2 快速开始示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">from</span> nanobot.agent.memory <span class="hljs-keyword">import</span> EnhancedMemoryStore

<span class="hljs-comment"># 初始化</span>
workspace = Path(<span class="hljs-string">"/path/to/workspace"</span>)
memory = EnhancedMemoryStore(workspace)

<span class="hljs-comment"># 添加记忆（自动生成向量嵌入）</span>
memory.add(
    <span class="hljs-string">"邮件发送要注意HTML格式美观"</span>,
    category=<span class="hljs-string">"core_rule"</span>,
    priority=<span class="hljs-number">9.0</span>  <span class="hljs-comment"># 高优先级，长久保存</span>
)

<span class="hljs-comment"># 语义搜索（"怎么发邮件"也能找到上面的记忆）</span>
results = memory.search(<span class="hljs-string">"如何发邮件"</span>, use_semantic=<span class="hljs-literal">True</span>)
<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"[<span class="hljs-subst">{r[<span class="hljs-string">'category'</span>]}</span>] 相似度:<span class="hljs-subst">{r[<span class="hljs-string">'similarity'</span>]}</span> <span class="hljs-subst">{r[<span class="hljs-string">'content'</span>]}</span>"</span>)

<span class="hljs-comment"># 获取对话上下文</span>
context = memory.get_context(<span class="hljs-string">"用户问关于邮件的问题"</span>)
</code></pre>
<hr/>
<h3 data-id="heading-16">五、避坑指南</h3>
<h4 data-id="heading-17">常见问题解决</h4>



































<table><thead><tr><th>问题</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td><code>ImportError: cannot import name 'EnhancedMemoryStore'</code></td><td>目录结构错误，memory.py 未改为包</td><td>确保是 <code>memory/</code> 目录，不是单文件</td></tr><tr><td><code>缺少 sentence-transformers</code></td><td>未安装依赖</td><td>运行 <code>pip install sentence-transformers</code></td></tr><tr><td><code>模型加载慢</code></td><td>首次下载 80MB 模型</td><td>等待2-3分钟，或预先下载模型</td></tr><tr><td><code>数据库权限错误</code></td><td>SQLite 文件被占用</td><td>关闭其他进程，或更改数据库路径</td></tr><tr><td><code>相似度计算为空</code></td><td>向量维度不匹配</td><td>确保模型名称一致，重新初始化</td></tr></tbody></table>
<h4 data-id="heading-18">模型选择建议</h4>





























<table><thead><tr><th>模型</th><th>大小</th><th>速度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>all-MiniLM-L6-v2</code></td><td>80MB</td><td>快</td><td>默认推荐，轻量级</td></tr><tr><td><code>paraphrase-multilingual-MiniLM-L12-v2</code></td><td>120MB</td><td>中</td><td>多语言支持</td></tr><tr><td><code>all-mpnet-base-v2</code></td><td>420MB</td><td>慢</td><td>更高精度（可选）</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-19">六、升级效果</h3>
<h4 data-id="heading-20">对比测试</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 测试查询: "怎么处理邮件"</span>

<span class="hljs-comment"># 原版（关键词匹配）</span>
结果: []  <span class="hljs-comment"># 找不到，因为没有完全一样的词</span>

<span class="hljs-comment"># 新版（语义检索）</span>
结果: [
    {content: <span class="hljs-string">"邮件发送要注意HTML格式美观"</span>, similarity: <span class="hljs-number">0.82</span>}
]
</code></pre>
<h4 data-id="heading-21">性能指标</h4>
<ul>
<li>记忆检索速度：&lt; 100ms（千级记忆）</li>
<li>存储空间：每条记忆约1KB（压缩后）</li>
<li>自动优化：每10次操作触发，零开销</li>
</ul>
<hr/>
<h3 data-id="heading-22">七、总结</h3>
<p>通过本次升级，NanoBot 获得了：</p>
<ol>
<li>🧠 <strong>语义理解</strong> - 真正理解用户意图</li>
<li>🔄 <strong>自动优化</strong> - 无需手动维护</li>
<li>💾 <strong>长久保存</strong> - 高价值记忆不丢失</li>
<li>🌐 <strong>轻量无负担</strong> - 仅增加2个依赖</li>
</ol>
<p>快来尝试升级你的 NanoBot 吧！🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[skills-lc-cli：3 天做出来的一个小工具，结果自己每天都在用]]></title>    <link>https://juejin.cn/post/7605882792144764991</link>    <guid>https://juejin.cn/post/7605882792144764991</guid>    <pubDate>2026-02-13T06:36:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605882792144764991" data-draft-id="7605941424536469558" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="skills-lc-cli：3 天做出来的一个小工具，结果自己每天都在用"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T06:36:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HBLOG"/> <meta itemprop="url" content="https://juejin.cn/user/131597124767479"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            skills-lc-cli：3 天做出来的一个小工具，结果自己每天都在用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/131597124767479/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HBLOG
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:36:31.000Z" title="Fri Feb 13 2026 06:36:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>一开始做 <strong>skills-lc-cli</strong>，并没有什么宏大的计划。</p>
<p>说白了，就是被自己折腾烦了。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F02%2Fimage-5.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/02/image-5.png" ref="nofollow noopener noreferrer"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc13f69bc5ae47d4b0f96370b07dd93c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569391&amp;x-signature=qvwjjmJb1U6vHxyrMWURiPmE0es%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-0">一、背景：问题不是“模型不够聪明”</h2>
<p>当时我在维护 skills.lc，也在同时用几套 AI Agent 环境。问题很一致：</p>
<ul>
<li>skills.lc 上有越来越多 Skills</li>
<li>我想用，但每次都要手动 clone、复制、放目录</li>
<li>不同 Agent 的技能目录还不一样</li>
</ul>
<p>最要命的是：<br/>
<strong>这件事本身不复杂，但每天都在重复。</strong></p>
<p>我意识到一个问题：</p>
<blockquote>
<p>Skills 已经是一个独立资产了，但缺一个最基本的“安装工具”。</p>
</blockquote>
<p>不是平台、不是 UI，就是一个 CLI。</p>
<h2 data-id="heading-1">二、3 天开发：目标非常克制</h2>
<p>我给自己定了一个硬限制：<br/>
<strong>3 天做完，不扩需求。</strong></p>
<h3 data-id="heading-2">第 1 天：只解决一件事</h3>
<p>第一天我只想清楚一件事：</p>
<blockquote>
<p>能不能用一条命令，把 skills.lc 上的技能装到本地？</p>
</blockquote>
<p>于是第一个原型只有一个命令：</p>
<pre><code class="hljs language-csharp" lang="csharp">skills <span class="hljs-keyword">add</span> &lt;repo&gt;
</code></pre>
<p>不关心 UI，不关心配置，<br/>
只关心三步：</p>
<ol>
<li>拉代码</li>
<li>找 <code>SKILL.md</code></li>
<li>放到 agent 能识别的目录里</li>
</ol>
<h3 data-id="heading-3">第 2 天：发现“找技能”才是刚需</h3>
<p>写完 <code>add</code> 之后，我自己用了一下，很快发现一个问题：</p>
<blockquote>
<p>我记不住 skill 名字。</p>
</blockquote>
<p>skills.lc 上的技能多了之后，<br/>
<strong>你真正需要的不是安装，而是“先找到”。</strong></p>
<p>于是第二天加了 <code>search</code> 命令。</p>
<h3 data-id="heading-4">第 3 天：打磨成“自己用得下去”的状态</h3>
<p>第三天没有加新功能，主要做了三件事：</p>
<ul>
<li>错误信息写清楚</li>
<li>参数别太多</li>
<li>不要搞“智能猜测”</li>
</ul>
<p>skills-lc-cli 到现在的形态，基本就是那三天定下来的。</p>
<h2 data-id="heading-5">三、安装方式（尽量不折腾）</h2>
<p>我自己用 CLI 的习惯是：<br/>
<strong>能 npx 就 npx，能少一步就少一步。</strong></p>
<h3 data-id="heading-6">全局安装</h3>
<pre><code class="hljs language-perl" lang="perl">npm install -g skills-<span class="hljs-keyword">lc</span>-cli
</code></pre>
<h3 data-id="heading-7">或直接使用</h3>
<pre><code class="hljs language-perl" lang="perl">npx skills-<span class="hljs-keyword">lc</span>-cli
</code></pre>
<p>CLI 本身没有状态，不依赖后台服务，用完就走。</p>
<h2 data-id="heading-8">四、最常用的两个命令：search + add</h2>
<h3 data-id="heading-9">1️⃣ search：先找到你要的 Skill</h3>
<pre><code class="hljs language-sql" lang="sql">skills <span class="hljs-keyword">search</span> git
</code></pre>
<p>这个命令做的事情很简单：</p>
<ul>
<li>从 skills.lc 拉取最新索引</li>
<li>根据关键词筛选</li>
<li>只展示有用信息（name / description）</li>
</ul>
<p>我刻意没加复杂排序，也没做推荐算法。<br/>
<strong>因为 search 的目的只是帮你“定位”，不是替你做决定。</strong></p>
<h3 data-id="heading-10">2️⃣ add：一条命令完成安装</h3>
<p>找到合适的 Skill 之后，直接：</p>
<pre><code class="hljs language-bash" lang="bash">skills add author/skill-name
</code></pre>
<p>它支持几种常见写法：</p>
<pre><code class="hljs language-csharp" lang="csharp">skills <span class="hljs-keyword">add</span> vercel-labs/agent-skills
skills <span class="hljs-keyword">add</span> https:<span class="hljs-comment">//github.com/vercel-labs/agent-skills</span>
skills <span class="hljs-keyword">add</span> ./local-skills
</code></pre>
<p>add 命令会：</p>
<ol>
<li>下载 Skill</li>
<li>校验 <code>SKILL.md</code></li>
<li>安装到当前 agent 可识别的位置</li>
</ol>
<p>没有隐藏步骤，也不会偷偷改你配置。</p>
<h2 data-id="heading-11">五、为什么要和 skills.lc 配合用</h2>
<p>单独看 skills-lc-cli，其实就是个普通 CLI。</p>
<p>但它真正的价值，来自 <strong>和 skills.lc 搭在一起用</strong>。</p>
<ul>
<li>skills.lc 负责 <strong>发现</strong></li>
<li>skills-lc-cli 负责 <strong>落地</strong></li>
</ul>
<p>你在网页上看到一个 Skill，<br/>
下一步不是复制链接、clone、整理目录，<br/>
而是一条命令。</p>
<p>这件事一旦顺了，你就不想回到手动操作了。</p>
<h2 data-id="heading-12">六、我刻意没做的事情</h2>
<p>有些东西不是不会做，是刻意不做：</p>
<ul>
<li>❌ 自动修改 agent 配置</li>
<li>❌ 智能补全 Skill 行为</li>
<li>❌ 帮用户“猜”要什么</li>
</ul>
<p>skills-lc-cli 的定位很清楚：<br/>
<strong>它是工具，不是助理。</strong></p>
<h2 data-id="heading-13">结尾</h2>
<p>skills-lc-cli 是一个典型的“工程师自用工具”。</p>
<p>它不是从需求文档里长出来的，<br/>
而是从「这事我已经干烦了」里长出来的。</p>
<p>官方介绍：<a href="https://link.juejin.cn?target=https%3A%2F%2Fskills.lc%2Fcli" target="_blank" title="https://skills.lc/cli" ref="nofollow noopener noreferrer">skills.lc/cli</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Mokup：构建工具友好的可视化 Mock 工具]]></title>    <link>https://juejin.cn/post/7605881632541196339</link>    <guid>https://juejin.cn/post/7605881632541196339</guid>    <pubDate>2026-02-13T06:40:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605881632541196339" data-draft-id="7605888927714689062" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Mokup：构建工具友好的可视化 Mock 工具"/> <meta itemprop="keywords" content="前端,JavaScript,后端"/> <meta itemprop="datePublished" content="2026-02-13T06:40:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="icebreaker"/> <meta itemprop="url" content="https://juejin.cn/user/1943592290496919"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Mokup：构建工具友好的可视化 Mock 工具
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1943592290496919/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    icebreaker
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:40:21.000Z" title="Fri Feb 13 2026 06:40:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef42b41d22b846539116ab5b1e620293~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaWNlYnJlYWtlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569620&amp;x-signature=2pKJ4xtq6%2BsLcJBm0xg5g%2FptG58%3D" alt="devio-cover.jpg" loading="lazy"/></p>
<h2 data-id="heading-0">Mokup：构建工具友好的可视化 Mock 工具</h2>
<p>大家好呀，我是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsonofmagic" target="_blank" title="https://github.com/sonofmagic" ref="nofollow noopener noreferrer">icebreaker</a>，一名前端开发者兼开源爱好者。</p>
<p>马上就过年了，在这个特别的时间点，我先祝大家：新年快乐！身体健康！工作顺利！来年发大财！</p>
<hr/>
<p>当然，回归正题，这里也向大家介绍一下我最近做的一个开源项目：<code>Mokup</code>，一个基于文件路由的 HTTP Mock 工具。</p>
<p>我做这个当时的目的，主要是给我团队里的同学用的，想让大家最低成本地在现有前端工程里接入服务端的能力，让大家循序渐进的成为全栈，这样才能在AI时代立足。</p>
<p>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsonofmagic%2Fmokup" target="_blank" title="https://github.com/sonofmagic/mokup" ref="nofollow noopener noreferrer">GitHub</a> , <a href="https://link.juejin.cn?target=http%3A%2F%2Fmokup.icebreaker.top%2F" target="_blank" title="http://mokup.icebreaker.top/" ref="nofollow noopener noreferrer">官网与文档</a></p>
<h3 data-id="heading-1">Mokup 是什么</h3>
<p>Mokup 是一个基于文件路由的 HTTP Mock 工具。你把 mock 文件放在 <code>mock/</code> 目录里，它会自动生成可匹配的路由并提供响应。</p>
<p>它的目标很直接：让 mock 在你已有的前端工程里尽快跑起来，减少“为了联调再造一套服务”的成本。</p>
<h3 data-id="heading-2">有什么特性</h3>
<ul>
<li>构建工具友好：Vite / Webpack 都能快速的接入，接入成本极低。</li>
<li>可视化：内置 Playground，路由是否生效一眼可见。</li>
<li>开发体验好：mock 文件和目录配置改完就刷新，不用频繁重启。</li>
<li>能部署到多个环境：本地开发、Node 服务端、Worker、Service Worker 都可用。</li>
</ul>
<h3 data-id="heading-3">为什么要做它</h3>
<p>这个实际上也和我自己在我自己的群里，还有公司里的项目组搜集痛点有关，那就是，很多团队的痛点不是“不会写 mock”，而是：</p>
<ul>
<li>接入步骤多，换个构建工具就要重配一次。</li>
<li>本地排查时看不到全局路由状态，只能翻文件猜。</li>
<li>每改一个 mock 都要重启或手动验证，反馈慢。</li>
</ul>
<p>Mokup 就是为了解决这三个问题：接入更轻、可视化更强、开发反馈更快。</p>
<h3 data-id="heading-4">构建工具友好</h3>
<h4 data-id="heading-5">Vite 接入</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> mokup <span class="hljs-keyword">from</span> <span class="hljs-string">'mokup/vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">mokup</span>({
      <span class="hljs-attr">entries</span>: { <span class="hljs-attr">dir</span>: <span class="hljs-string">'mock'</span>, <span class="hljs-attr">prefix</span>: <span class="hljs-string">'/api'</span> },
    }),
  ],
}
</code></pre>
<p>然后这时候 你就可以在 <code>mock/</code> 目录里放 mock 文件了，Mokup 会自动扫描并生成对应的路由。</p>
<p>你也可以在你的 CLI 中快速访问 mokup 的 playground 进行可视化调试</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/740566f7d99d497696aa462b4ac5a71a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaWNlYnJlYWtlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569620&amp;x-signature=y97aMYKiXuBMKQ9yRb4pqOBMRjE%3D" alt="cli.png" loading="lazy"/></p>
<h4 data-id="heading-6">Webpack 接入</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> { mokupWebpack } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mokup/webpack'</span>)

<span class="hljs-keyword">const</span> withMokup = <span class="hljs-title function_">mokupWebpack</span>({
  <span class="hljs-attr">entries</span>: { <span class="hljs-attr">dir</span>: <span class="hljs-string">'mock'</span>, <span class="hljs-attr">prefix</span>: <span class="hljs-string">'/api'</span> },
})

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">withMokup</span>({})
</code></pre>
<p>你可以在不改动业务代码结构的情况下，把 mock 能力挂到现有构建流程里。</p>
<h3 data-id="heading-7">可视化：Playground（重点）</h3>
<p>Mokup 内置 Playground，用来查看当前被扫描到的路由、方法、路径和配置链。</p>
<p>Vite 开发时默认入口：</p>
<pre><code class="hljs language-txt" lang="txt">http://localhost:5173/__mokup
</code></pre>
<p>在线体验 Demo：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmokup.icebreaker.top%2F__mokup%2F" target="_blank" title="https://mokup.icebreaker.top/__mokup/" ref="nofollow noopener noreferrer">mokup.icebreaker.top/__mokup/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0181e00ca080401dbc9d73b766a94a37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaWNlYnJlYWtlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569620&amp;x-signature=ExqF0uPXTXahturuyDRQway7SlM%3D" alt="playground.png" loading="lazy"/></p>
<p>它解决的是一个非常实际的问题：
接口不生效时，你不用到处去找问题，只要打开页面就能看到“有没有被扫到、有没有被禁用、匹配到了什么配置”。</p>
<h3 data-id="heading-8">开发体验：哪些文件会热更新</h3>
<p>在 Vite dev 下，Mokup 会监听 mock 目录变化并自动刷新路由表。常见会触发热更新的改动包括：</p>
<ul>
<li>新增/修改/删除 mock 路由文件，例如：
<ul>
<li><code>mock/users.get.ts</code></li>
<li><code>mock/messages.get.json</code></li>
<li><code>mock/orders/[id].patch.ts</code></li>
</ul>
</li>
<li>修改目录配置文件：<code>mock/**/index.config.ts</code></li>
<li>调整目录结构（移动、重命名、创建子目录）</li>
</ul>
<p>改完后 Playground 会自动刷新路由列表，调试链路更短。</p>
<blockquote>
<p>如果你不需要监听，可以在 <code>entries</code> 里配置 <code>watch: false</code>。</p>
</blockquote>
<h3 data-id="heading-9">快速示例：从写文件到看到结果</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// mock/users.get.ts</span>
<span class="hljs-keyword">import</span> { defineHandler } <span class="hljs-keyword">from</span> <span class="hljs-string">'mokup'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineHandler</span>({
  <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.<span class="hljs-title function_">json</span>([{ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Ada'</span> }]),
})
</code></pre>
<p>启动 dev 后访问 <code>/api/users</code> (你设置了 <code>prefix: '/api'</code> )，即可拿到 mock 数据。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2450a7f1fa43487781e3fcb248a90c70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaWNlYnJlYWtlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569620&amp;x-signature=P02tK4VoqpP%2FyNsxCcoDWD1JDqs%3D" alt="mock-dir.png" loading="lazy"/></p>
<h3 data-id="heading-10">快速集成 @faker-js/faker</h3>
<p><code>@faker-js/faker</code> 是我们造假数据最常使用的库了，这里也可以很好的和它集成</p>
<p>Mokup 的 handler 本质上就是 TS/JS 函数，所以能直接接入 <code>@faker-js/faker</code> 这类 mock 数据库，不需要额外适配层。</p>
<p>下面这个示例会根据查询参数 <code>size</code> 返回一组用户列表：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// mock/users.get.ts</span>
<span class="hljs-keyword">import</span> { faker } <span class="hljs-keyword">from</span> <span class="hljs-string">'@faker-js/faker'</span>
<span class="hljs-keyword">import</span> { defineHandler } <span class="hljs-keyword">from</span> <span class="hljs-string">'mokup'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineHandler</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> size = <span class="hljs-title class_">Number</span>(c.<span class="hljs-property">req</span>.<span class="hljs-title function_">query</span>(<span class="hljs-string">'size'</span>) ?? <span class="hljs-number">10</span>)
  <span class="hljs-keyword">const</span> count = <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(size) ? <span class="hljs-number">10</span> : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(size, <span class="hljs-number">1</span>), <span class="hljs-number">50</span>)
  <span class="hljs-keyword">const</span> list = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: count }, <span class="hljs-function">() =&gt;</span> ({
    <span class="hljs-attr">id</span>: faker.<span class="hljs-property">string</span>.<span class="hljs-title function_">uuid</span>(),
    <span class="hljs-attr">name</span>: faker.<span class="hljs-property">person</span>.<span class="hljs-title function_">fullName</span>(),
    <span class="hljs-attr">email</span>: faker.<span class="hljs-property">internet</span>.<span class="hljs-title function_">email</span>(),
    <span class="hljs-attr">city</span>: faker.<span class="hljs-property">location</span>.<span class="hljs-title function_">city</span>(),
    <span class="hljs-attr">createdAt</span>: faker.<span class="hljs-property">date</span>.<span class="hljs-title function_">recent</span>({ <span class="hljs-attr">days</span>: <span class="hljs-number">30</span> }).<span class="hljs-title function_">toISOString</span>(),
  }))

  <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">json</span>({
    list,
    <span class="hljs-attr">total</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">pageSize</span>: count,
  })
})
</code></pre>
<p>这对列表页、搜索页、详情页联调都很实用。
如果你希望测试结果可复现，可以在 handler 顶部加上 <code>faker.seed(123)</code>。</p>
<h3 data-id="heading-11">可部署到多个环境</h3>
<p>这套 mock 可以运行在多个环境：比如在 Node.js 里直接使用，甚至还能部署到 Cloudflare Worker。</p>
<p>Node.js 直接使用示例：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { createFetchServer, serve } <span class="hljs-keyword">from</span> <span class="hljs-string">'mokup/server/node'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createFetchServer</span>({ <span class="hljs-attr">entries</span>: { <span class="hljs-attr">dir</span>: <span class="hljs-string">'mock'</span> } })
<span class="hljs-title function_">serve</span>({ <span class="hljs-attr">fetch</span>: app.<span class="hljs-property">fetch</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> })
</code></pre>
<p>部署到 Cloudflare Worker 示例：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { createMokupWorker } <span class="hljs-keyword">from</span> <span class="hljs-string">'mokup/server/worker'</span>
<span class="hljs-keyword">import</span> mokupBundle <span class="hljs-keyword">from</span> <span class="hljs-string">'virtual:mokup-bundle'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createMokupWorker</span>(mokupBundle)
</code></pre>
<p>提示：<code>virtual:mokup-bundle</code> 仅在 Vite 与 <code>@cloudflare/vite-plugin</code> 集成环境可用；Node.js Dev 模式可直接使用 <code>createFetchServer</code>，无需该虚拟模块。</p>
<h3 data-id="heading-12">核心架构</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1ce02c8671643549a167e9f118c371c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaWNlYnJlYWtlcg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569620&amp;x-signature=zAc2GWgLiUg1I748hjmJikx6CDQ%3D" alt="core-zh.jpg" loading="lazy"/></p>
<h3 data-id="heading-13">适用场景与边界</h3>
<p>适合：</p>
<ul>
<li>已有 Vite/webpack 工程，想低成本接入 mock 的团队</li>
<li>需要可视化路由排查能力的项目</li>
<li>重视开发反馈速度，希望 mock 修改后立即可见的场景</li>
</ul>
<p>不太适合：</p>
<ul>
<li>主要依赖复杂动态代理链路的场景</li>
<li>完全不希望引入构建期/插件能力的极轻量脚本方案</li>
</ul>
<p>Mokup 不是为了替代所有 mock 方案，而是让 mock 更快接入、更好调试、更贴近日常开发流程。</p>
<h3 data-id="heading-14">AI 友好性</h3>
<p>都已经在这个时代了，怎么能不用 AI 呢， Mokup 当时设计就是考虑到 AI 时代的开发者需求的，所以在设计上也做了一些 AI 友好的考虑，</p>
<p>毕竟时代变了，我们也像纺纱机的工人那样，换到了蒸汽纺纱机，每天奴役 AI 24小时帮我们打工，爽是真的爽，验证问题效率极高。</p>
<p>而且很多开发是懒得写文档的，现在文档什么完全不是问题，就像这篇文章，大部分也是由AI生成的。</p>
<h3 data-id="heading-15">结语</h3>
<p>Mokup 目前还在快速迭代中，欢迎大家试用并提反馈！无论是功能需求、使用体验还是文档改进都非常欢迎。</p>
<p>如果你也有类似的痛点，或者对 mock 工具有什么想法，也欢迎在评论区交流！我们一起让前端 mock 更好用、更高效！</p>
<p>有志同道合的小伙伴，也可以访问我的 Github 主页联系我一起交流！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[视频生成推理加速实践：基于全局时间索引的序列并行 3D 位置编码优化]]></title>    <link>https://juejin.cn/post/7605888927714787366</link>    <guid>https://juejin.cn/post/7605888927714787366</guid>    <pubDate>2026-02-13T06:48:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605888927714787366" data-draft-id="7605907495770062857" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="视频生成推理加速实践：基于全局时间索引的序列并行 3D 位置编码优化"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T06:48:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哔哩哔哩技术"/> <meta itemprop="url" content="https://juejin.cn/user/3030701626893405"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            视频生成推理加速实践：基于全局时间索引的序列并行 3D 位置编码优化
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3030701626893405/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哔哩哔哩技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:48:25.000Z" title="Fri Feb 13 2026 06:48:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>一、Self-Forcing：从 Wan2.1 到因果视频推理</strong></h2>
<h3 data-id="heading-1"><strong>Wan2.1：全帧并行的视频扩散模型</strong></h3>
<p>Wan2.1 是阿里巴巴团队开源的大规模视频生成基础模型，基于主流的扩散 Transformer（DiT）架构，并采用 Flow Matching 作为训练框架，在多个视频生成评测基准上展现了领先的生成质量。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b2a07bc97bd4a6b9e90f01cf660a06d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOU5ZOp5ZOU5ZOp5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771570104&amp;x-signature=%2BupYVINenxO97jm%2BR1ydToOmXFA%3D" alt="图片" loading="lazy"/></p>
<p>在模型设计上，Wan2.1 采用典型的<strong>全时空并行建模思路</strong>。模型使用 Full Spatio-temporal Attention，使得所有视频帧在时间和空间维度上完全互相可见，从而实现双向的信息流动与全局一致性建模。视频首先通过 3D Causal VAE 被压缩到 4×8×8 的时空比例，latent 维度为 16，文本侧则使用 umT5 编码器，将中英文输入映射为 512 tokens、4096 维的语义表示，并通过 Cross-Attention 注入到生成过程中。</p>
<p>从规模上看，Wan2.1 同时提供了面向效率和质量的不同版本：1.3B 模型采用 1536 维隐藏层、30 层 Transformer 和 12 个注意力头，更适合资源受限场景，14B 模型则扩展到 5120 维隐藏层、40 层 Transformer 和 40 个注意力头，以追求更高的生成上限。</p>
<p>在推理阶段，Wan2.1 会一次性处理所有视频帧，通过 40–50 步去噪迭代生成完整视频。这种全帧并行的生成方式在中短视频场景中能够有效保证时序一致性，但其设计假设也直接决定了模型在更长视频和实时推理场景下会遇到不可回避的瓶颈。</p>
<h3 data-id="heading-2"><strong>全局扩散模型在长视频推理中的瓶颈</strong></h3>
<p>随着视频长度的增加，基于双向全注意力的扩散模型逐渐暴露出结构性问题。首先是显存和计算复杂度的快速膨胀。自注意力的复杂度为 O(N²)，其中 N 为 token 序列长度。以 Wan2.1 生成 5 秒、16 FPS、832×480 分辨率视频为例，经过 VAE 压缩后仍然会形成约 3 万级别的 token 序列，当视频长度翻倍时，注意力相关的显存需求将增长至原来的四倍，这使得单卡生成更长视频变得困难。</p>
<p>其次，全局并行注意力隐含了<strong>固定长度假设</strong>。由于所有帧必须同时参与计算，模型在训练阶段通常就需要设定最大帧数，当推理阶段希望生成更长的视频时，只能通过滑动窗口或分段拼接来变通处理，而这往往会带来明显的时间接缝和长程一致性退化，模型本身并不具备自然向更长时间轴扩展的能力。</p>
<p>更重要的是，这种双向依赖的建模方式使得模型无法进行流式推理。由于当前帧的生成会受到未来帧的反向影响，系统必须等待整个视频生成完成后才能输出结果，首帧延迟往往达到数十秒甚至更长。这种“离线式”的推理模式显然无法满足实时交互、在线生成或视频续写等应用需求。</p>
<p>这些问题并非简单的工程优化可以解决，而是源自全局扩散模型在时间建模上的基本假设。</p>
<h3 data-id="heading-3"><strong>Self-Forcing：用因果生成重构视频扩散推理</strong></h3>
<p>Self-Forcing 提出了一种因果自回归的视频扩散训练与推理方式，其核心思想是将 Wan2.1 这类全帧并行模型，改造为<strong>只依赖历史信息的逐步生成模型</strong>，同时避免传统自回归模型中常见的误差累积问题。</p>
<p>在模型结构上，Self-Forcing 引入因果注意力约束，使当前帧只能关注历史帧而无法“看到”未来信息。这一约束通过 Block Mask 施加在注意力计算中，并配合 Flex Attention 实现高效计算。由于满足因果性，模型在推理时可以安全地复用历史帧的 Key / Value，从而引入 KV 缓存机制，避免在每一步生成中重复计算已经确定的上下文。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36410b5dffc348f4bcefecbff9df666b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOU5ZOp5ZOU5ZOp5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771570104&amp;x-signature=irvnIvS1s%2BgZA%2FhPamTm0DHXYhg%3D" alt="图片" loading="lazy"/></p>
<p>在此基础上，Self-Forcing 采用逐块生成策略，将视频按帧或按小段 latent 分块生成。每一块完成去噪后，其结果会被写入 KV 缓存，作为后续生成的上下文；当缓存达到上限时，通过 Rolling KV Cache 自动淘汰最早的 tokens，从而在有限显存下支持任意长度的视频生成。这种设计将注意力的峰值复杂度从 O(N²) 降低到 O(B×N)，其中 B 为单次生成的块大小。</p>
<p>从工程实现上看，Self-Forcing 使用 CausalWanModel 替代原始 WanModel，并在注意力层中系统性地引入因果掩码、KV 缓存以及编译级优化。在保持训练与推理一致性的前提下，模型在生成质量上与 Wan2.1 基本持平，VBench 指标甚至略有提升，同时将首帧延迟降低到亚秒级，并在单卡 H100 上实现了接近实时的视频生成速度。</p>
<p>总体而言，Self-Forcing 并不是对 Wan2.1 的局部加速，而是一次从<strong>全局扩散范式向因果推理范式</strong>的结构性转变，为长视频生成、流式推理和实时交互提供了可行的技术路径。</p>
<h2 data-id="heading-4"><strong>二、推理优化工作详解</strong></h2>
<h3 data-id="heading-5"><strong>序列并行实现</strong></h3>
<p>官方的 Self-Forcing 实现并未支持序列并行（Sequence Parallelism, SP），这在单卡显存受限、尤其是长视频推理场景下，成为扩展模型能力的主要瓶颈。为了解决这一问题，我们的算法团队在 Self-Forcing 因果注意力的基础上，参考 Megatron 以及 Ulysses 的设计，引入了对 SP 的完整支持。</p>
<p>在 SP 模式下，序列维度被均匀切分到多个并行 rank 上，每个 rank 仅持有长度为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>L</mi><mi mathvariant="normal">/</mi><mi>P</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex">  L/P </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord"> </span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"> </span></span></span></span></span>的局部序列。整体的计算流程如下所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34ac8fec9ad14e0281aa3365410e65a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOU5ZOp5ZOU5ZOp5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771570104&amp;x-signature=jaTYlg2o92Dwl%2B%2FpnGG%2BOTaEBpU%3D" alt="图片" loading="lazy"/></p>
<p>在实际的性能分析中，我们注意到两个关键问题：一方面，RoPE 在整个自注意力模块的计算中占据了显著的时间比例；另一方面，现有 Causal RoPE 的实现需要完整序列信息，其计算依赖于前面的三次 all-gather 通信，导致 RoPE 无法与通信阶段重叠执行，从而进一步放大了通信带来的性能损耗。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/15f1ad87683441f9b0eae6a3b076861a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOU5ZOp5ZOU5ZOp5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771570104&amp;x-signature=mV1phFGH4YgV7m1el2FtZdPQs%2Fc%3D" alt="图片" loading="lazy"/></p>
<p>在 Self-Forcing 的分块自回归生成中，时间位置需要通过全局偏移来编码，这使得 RoPE 的计算逻辑相比传统实现有所不同。为了保证 KV Cache 与因果注意力的一致性，我们需要在序列分片内部正确应用全局时间索引，实现 Causal-RoPE 的局部化计算。</p>
<h3 data-id="heading-6"><strong>分块自回归下的旋转位置编码</strong></h3>
<p>Wan2.1 使用的 3D Rotary Positional Encoding 与 Qwen2.5-VL 中的多模态 RoPE（M-RoPE）在设计上是一致的：将旋转频率在维度上拆分为时间（temporal）、高度（height）和宽度（width）三部分，从而对视频 token 的三维空间位置进行编码。</p>
<p>在具体实现上，Qwen2.5-VL 采用传统的 cos/sin 形式，并通过 <strong>rotate_half</strong> 实现旋转：</p>
<pre><code class="hljs language-arduino" lang="arduino">q_embed = (q * cos) + (<span class="hljs-built_in">rotate_half</span>(q) * sin)
</code></pre>
<p>而 Wan2.1 则直接使用复数形式来表达旋转操作，将 RoPE 显式建模为复平面上的乘法：</p>
<pre><code class="hljs language-scss" lang="scss"># freqs 在 rope_params 中已通过 torch<span class="hljs-selector-class">.polar</span> 转换为复数
freqs = freqs<span class="hljs-selector-class">.split</span>([c - <span class="hljs-number">2</span> * (c // <span class="hljs-number">3</span>), c <span class="hljs-comment">// 3, c // 3], dim=1)</span>
x_i = torch<span class="hljs-selector-class">.view_as_complex</span>(x[i, :seq_len].to(torch.float64)<span class="hljs-selector-class">.reshape</span>(    
    seq_len, n, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
    
freqs_i = torch<span class="hljs-selector-class">.cat</span>([
    freqs[<span class="hljs-number">0</span>][:f].view(f, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)<span class="hljs-selector-class">.expand</span>(f, h, w, -<span class="hljs-number">1</span>), 
    freqs<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[:h]</span><span class="hljs-selector-class">.view</span>(<span class="hljs-number">1</span>, h, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)<span class="hljs-selector-class">.expand</span>(f, h, w, -<span class="hljs-number">1</span>), 
    freqs<span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[:w]</span><span class="hljs-selector-class">.view</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, w, -<span class="hljs-number">1</span>)<span class="hljs-selector-class">.expand</span>(f, h, w, -<span class="hljs-number">1</span>)
], dim=-<span class="hljs-number">1</span>)

x_i = torch<span class="hljs-selector-class">.view_as_real</span>(x_i * freqs_i)<span class="hljs-selector-class">.flatten</span>(<span class="hljs-number">2</span>)
</code></pre>
<p>这种实现方式更贴近 RoPE 的数学本质，其核心等价关系可以写为：</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>RoPE</mtext><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>⋅</mo><msup><mi>e</mi><mrow><mi>i</mi><mi>θ</mi></mrow></msup><mo>=</mo><mi>x</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>+</mo><mi>i</mi><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{RoPE}(x, \theta)=x \cdot e^{i \theta}=x \cdot(\cos \theta+i \sin \theta) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord text"><span class="mord">RoPE</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.4445em;"/><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.8991em;"/><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.4445em;"/><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></div>
<p>在 Self-Forcing 框架下，为了支持分块因果推理与 KV Cache，引入了额外的 </p>
<p><strong>start_frame</strong> 参数，用于显式指定当前生成块在全局时间轴上的起始位置：</p>
<pre><code class="hljs language-scss" lang="scss">def <span class="hljs-built_in">causal_rope_apply</span>(x, grid_sizes, freqs, start_frame=<span class="hljs-number">0</span>): 
    freqs_i = torch.<span class="hljs-built_in">cat</span>([
        freqs[<span class="hljs-number">0</span>][start_frame:start_frame + f].<span class="hljs-built_in">view</span>(f, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-built_in">expand</span>(f, h, w, -<span class="hljs-number">1</span>),        
        freqs[<span class="hljs-number">1</span>][:h].<span class="hljs-built_in">view</span>(<span class="hljs-number">1</span>, h, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-built_in">expand</span>(f, h, w, -<span class="hljs-number">1</span>),        
        freqs[<span class="hljs-number">2</span>][:w].<span class="hljs-built_in">view</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, w, -<span class="hljs-number">1</span>).<span class="hljs-built_in">expand</span>(f, h, w, -<span class="hljs-number">1</span>)    
    ], dim=-<span class="hljs-number">1</span>)
</code></pre>
<p>通过这一改动，3D RoPE 被自然地扩展为适用于分块自回归生成的因果形式。对于时间–空间位置为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mtext> </mtext></mrow><annotation encoding="application/x-tex"> (t, h, w) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mord"> </span></span></span></span></span>的 token，其位置编码可以形式化表示为：</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Causal-RoPE</mtext><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>t</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mrow><mi>t</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>w</mi></mrow></msub><mo>⊙</mo><msup><mi>e</mi><mrow><mi>i</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mtext>global</mtext></msub><msub><mi>θ</mi><mi>T</mi></msub><mo>+</mo><mi>h</mi><msub><mi>θ</mi><mi>H</mi></msub><mo>+</mo><mi>w</mi><msub><mi>θ</mi><mi>W</mi></msub><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\text{Causal-RoPE}(x_{t, h, w}) = x_{t, h, w} \odot e^{i(t_{\text{global}}\theta_T + h\theta_H + w\theta_W)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"/><span class="mord text"><span class="mord">Causal-RoPE</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.8694em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.938em;"/><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">global</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span/></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span/></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">h</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span/></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span/></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></div>
<p>其中，全局时间索引定义为：</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>t</mi><mtext>global</mtext></msub><mo>=</mo><mi>t</mi><mo>+</mo><mi>s</mi><mo separator="true">,</mo><mspace width="1em"/><mi>s</mi><mo>=</mo><mi>k</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">t_{\text{global}} = t + s,\quad s = k\tau </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">global</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"/><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"/><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span></span></div>
<p>这里<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>k</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord"> </span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"> </span></span></span></span></span>为块索引，<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>τ</mi></mrow><annotation encoding="application/x-tex"> \tau </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord"> </span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span></span> 为块大小。以 chunk-wise（每块 3 个 latent 帧）为例，不同生成块对应的 start_frame 分别为 0、3、6 …，依此类推。</p>
<p>如果仅使用局部时间索引，不同块中处于相同相对位置的 token 将获得完全相同的位置编码，从而导致全局时间顺序混淆，并使 KV Cache 中的位置信息失真。通过显式引入全局时间偏移，Causal-RoPE 保证了位置编码与自回归生成顺序之间的一一对应关系。</p>
<h3 data-id="heading-7"><strong>局部计算的可行性</strong></h3>
<p>在序列并行设置下，序列维度被划分到<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi mathvariant="normal">∣</mi><mi mathvariant="script">R</mi><mi mathvariant="normal">∣</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex">  |\mathcal{R}| </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord"> ∣</span><span class="mord mathcal">R</span><span class="mord">∣ </span></span></span></span></span>个并行 rank 上。对于 rank <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mtext>  </mtext></mrow><annotation encoding="application/x-tex"> r  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">  </span></span></span></span></span>，其负责的序列区间为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mo stretchy="false">[</mo><mi>r</mi><mo>⋅</mo><mi>L</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mi>L</mi><mo stretchy="false">)</mo><mtext> </mtext></mrow><annotation encoding="application/x-tex">  [r\cdot L, (r+1)\cdot L) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord"> </span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord"> </span></span></span></span></span>，其中 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>L</mi><mo>=</mo><mo stretchy="false">⌈</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∣</mi><mi mathvariant="script">R</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">⌉</mo><mtext> </mtext></mrow><annotation encoding="application/x-tex">  L=\lceil S/|\mathcal{R}|\rceil </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord"> </span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/∣</span><span class="mord mathcal">R</span><span class="mord">∣</span><span class="mclose">⌉</span><span class="mord"> </span></span></span></span></span>。</p>
<p>由于 token 在序列中按照"帧优先"的顺序排列，序列切分在效果上等价于对时间维度的近似划分。对于 rank <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>r</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex"> r </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"> </span></span></span></span></span>中局部索引为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><msub><mi>i</mi><mtext>local</mtext></msub><mtext> </mtext></mrow><annotation encoding="application/x-tex">  i_{\text{local}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"/><span class="mord"> </span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">local</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord"> </span></span></span></span></span>的 token，其对应的全局序列位置和全局时间索引分别为：</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>i</mi><mtext>global</mtext></msub><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>L</mi><mo>+</mo><msub><mi>i</mi><mtext>local</mtext></msub></mrow><annotation encoding="application/x-tex">i_{\text{global}} = r \cdot L + i_{\text{local}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9456em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">global</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.4445em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">local</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>t</mi><mtext>global</mtext></msub><mo>=</mo><mi>s</mi><mo>+</mo><mrow><mo fence="true">⌊</mo><mfrac><msub><mi>i</mi><mtext>global</mtext></msub><mrow><mi>H</mi><mo>×</mo><mi>W</mi></mrow></mfrac><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">t_{\text{global}} = s + \left\lfloor \frac{i_{\text{global}}}{H \times W} \right\rfloor </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">global</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"/><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"/><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"/><span class="frac-line" style="border-bottom-width:0.04em;"/></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"/><span class="mord"><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">global</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span/></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span/></span></span></span></span><span class="mclose nulldelimiter"/></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span></span></span></span></span></div>
<p>其中<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>s</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex"> s </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord"> </span><span class="mord mathnormal">s</span><span class="mord"> </span></span></span></span></span>为当前块的 start_frame。</p>
<p>可以看到，对每个 token，Causal-RoPE 的计算仅依赖其自身特征、全局时间位置以及共享的频率参数 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>T</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>H</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>W</mi></msub><mtext> </mtext></mrow><annotation encoding="application/x-tex"> \theta_T, \theta_H, \theta_W </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord"> </span></span></span></span></span>。在分块自回归 + SP 的组合下，我们通过在每个 rank 内应用正确的全局时间索引，实现了 RoPE 的完全局部计算，无需额外跨 rank 通信，同时保持了因果一致性。</p>
<p>这一结论为后续的优化提供了理论基础。</p>
<h3 data-id="heading-8"><strong>实现方案与性能对比</strong></h3>
<p>基于上述分析，我们将 RoPE 的计算下沉到序列分片内部，先在本地完成 Causal-RoPE 的计算，再通过一次融合的 all-to-all 通信，同时完成序列维度与注意力头维度的重排，从而替代原始实现中的三次 all-gather 和一次 split 操作：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df3b46ea587348e580ffd6f0d84642da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOU5ZOp5ZOU5ZOp5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771570104&amp;x-signature=BWaM8D%2Fzht1h414glYm%2Brcu5no0%3D" alt="图片" loading="lazy"/></p>
<p>在第一阶段优化中，我们进一步缓存 RoPE 所需的 sin/cos，并基于 TileLang 实现算子融合，相比社区常见的 Triton 实现获得了约 10% 的性能提升，整体优化方案的 profile 结果如下所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53e394bcb979472e91cb369d88bebd34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOU5ZOp5ZOU5ZOp5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771570104&amp;x-signature=%2BNSs9HXbgBl00wV2BxCPwT8%2BoYs%3D" alt="图片" loading="lazy"/></p>
<p>在一次典型的 5s 480P 视频推理中，会触发 920 次的自注意力计算，整体耗时降低约：</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>T</mi><mrow><mi>e</mi><mn>2</mn><mi>e</mi></mrow></msub><mo>=</mo><mn>920</mn><mo>×</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>1.308</mn><mo>+</mo><mn>2.166</mn><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mn>0.069257</mn><mo>+</mo><mn>0.273916</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mi>m</mi><mi>s</mi><mo>≈</mo><mn>2.88</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">\Delta T_{e 2 e}=920 \times[(1.308+2.166)-(0.069257+0.273916)] ms \approx 2.88 s </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"/><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">920</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">[(</span><span class="mord">1.308</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">2.166</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord">0.069257</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.273916</span><span class="mclose">)]</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">2.88</span><span class="mord mathnormal">s</span></span></span></span></span></div>
<p>相比优化前 8.86s 的端到端耗时，整体推理性能实现 约 1.48× 无损加速（≈47.5% speedup），与实际的实验结果高度一致。后续我们在做计算图优化的时候，注意到 RoPE 的缓存逻辑对整图优化不友好，进一步将动态的缓存逻辑改成了预计算逻辑，并将结果存储在连续张量中，绕过 Host Op，在推理过程中直接在 GPU 上进行寻址，使用预计算的 cos / sin 对输入张量进行旋转编码计算，优化了 CUDA 的计算流，实现了计算性能的进一步提升。</p>
<h2 data-id="heading-9"><strong>三、总结与展望</strong></h2>
<p>本文分享了我们在视频生成模型推理优化中的一系列实践，重点围绕分块自回归视频模型在序列并行场景下的计算与通信优化展开。除上述工作外，我们还在低比特量化、计算图优化等方向持续探索，为后续更大规模、更低延迟的视频生成系统打下基础。</p>
<p>-End-</p>
<p>作者丨storyicon、在喝可乐的派派</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[std::function/模板/裸函数指针选型指南]]></title>    <link>https://juejin.cn/post/7605810996125679650</link>    <guid>https://juejin.cn/post/7605810996125679650</guid>    <pubDate>2026-02-13T06:32:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125679650" data-draft-id="7605625595571126287" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="std::function/模板/裸函数指针选型指南"/> <meta itemprop="keywords" content="C++"/> <meta itemprop="datePublished" content="2026-02-13T06:32:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sTone87375"/> <meta itemprop="url" content="https://juejin.cn/user/2946346894764584"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            std::function/模板/裸函数指针选型指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2946346894764584/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sTone87375
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:32:37.000Z" title="Fri Feb 13 2026 06:32:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>选择 <code>std::function</code>、模板还是裸函数指针，核心在于<strong>权衡灵活性、性能和代码复杂度</strong>。以下是详细的决策指南：</p>
<hr/>
<h2 data-id="heading-0">快速决策图</h2>
<pre><code class="hljs language-c" lang="c">是否需要存储回调？（类成员、容器、跨函数传递）
├── 是 → 是否需要类型擦除？（存储不同类型但相同签名的可调用对象）
│   ├── 是 → <span class="hljs-built_in">std</span>::function（或 <span class="hljs-built_in">std</span>::function_ref C++<span class="hljs-number">23</span>）
│   └── 否 → 模板（如 <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;具体类型&gt;）
└── 否 → 编译时确定类型？
    ├── 是 → 模板（零开销，最优性能）
    └── 否 → 裸函数指针（C接口、极简场景）
</code></pre>
<hr/>
<h2 data-id="heading-1">详细场景对比</h2>
<h3 data-id="heading-2">1. 模板（<code>template&lt;typename F&gt;</code>）— <strong>首选，如果可能</strong></h3>
<p><strong>适用场景：</strong></p>
<ul>
<li>回调只在单个函数内使用，不需要存储</li>
<li>性能敏感（高频调用）</li>
<li>编译时就能确定可调用对象类型</li>
</ul>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 推荐：零开销抽象</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Func&amp;&amp; func)</span> </span>{
    <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 直接内联，无间接调用开销</span>
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-built_in">execute</span>([]{ std::cout &lt;&lt; <span class="hljs-string">"lambda\n"</span>; });
<span class="hljs-built_in">execute</span>(my_functor);
<span class="hljs-built_in">execute</span>(free_function);
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>零运行时开销（完全内联）</li>
<li>支持任意可调用对象（lambda、仿函数、函数指针）</li>
<li>类型安全，编译期检查</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不能存储（无法作为类成员或放入容器）</li>
<li>必须在头文件中实现（或显式实例化）</li>
<li>编译时间可能增加</li>
</ul>
<hr/>
<h3 data-id="heading-3">2. <code>std::function</code> — <strong>需要类型擦除时</strong></h3>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要存储回调（类成员变量）</li>
<li>需要放入容器（<code>std::vector&lt;std::function&lt;...&gt;&gt;</code>）</li>
<li>需要运行时多态（不同类型，相同签名）</li>
<li>跨层传递（如从UI层传递到业务层）</li>
</ul>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 推荐：需要存储的场景</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskScheduler</span> {
    std::vector&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks_;  <span class="hljs-comment">// 存储不同类型任务</span>
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; task)</span> </span>{  <span class="hljs-comment">// 接受任何可调用对象</span>
        tasks_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(task));
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : tasks_) <span class="hljs-built_in">t</span>();
    }
};

<span class="hljs-comment">// 可以混合添加：</span>
scheduler.<span class="hljs-built_in">add</span>([]{ <span class="hljs-comment">/* lambda */</span> });
scheduler.<span class="hljs-built_in">add</span>(std::<span class="hljs-built_in">bind</span>(&amp;Class::method, &amp;obj));
scheduler.<span class="hljs-built_in">add</span>(free_function);
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>极强的灵活性，真正的类型擦除</li>
<li>可以存储、复制、移动</li>
<li>接口清晰，解耦调用方和实现方</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>运行时开销（通常 1-2 次间接跳转）</li>
<li>可能堆分配（大 lambda/仿函数）</li>
<li>可能抛出 <code>bad_function_call</code></li>
</ul>
<p><strong>性能优化：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// C++23 引入 std::function_ref：轻量级、非拥有、零分配</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(std::function_ref&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; callback)</span></span>;  <span class="hljs-comment">// 只读引用，不存储</span>
</code></pre>
<hr/>
<h3 data-id="heading-4">3. 裸函数指针 — <strong>C 接口或极简场景</strong></h3>
<p><strong>适用场景：</strong></p>
<ul>
<li>C 语言接口/兼容</li>
<li>系统级编程（信号处理、线程创建）</li>
<li>绝对零开销且确定无捕获 lambda</li>
<li>嵌入式/资源极度受限环境</li>
</ul>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 推荐：C API 回调</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span>* base, <span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> size, 
           <span class="hljs-type">int</span> (*cmp)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*))</span></span>;  <span class="hljs-comment">// C 标准库</span>

<span class="hljs-comment">// ✅ 推荐：信号处理</span>
<span class="hljs-built_in">void</span> (*<span class="hljs-built_in">signal</span>(<span class="hljs-type">int</span> sig, <span class="hljs-built_in">void</span> (*func)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);

<span class="hljs-comment">// ❌ 不推荐：现代 C++ 应用开发</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_callback</span><span class="hljs-params">(<span class="hljs-type">void</span> (*cb)(<span class="hljs-type">int</span>))</span></span>;  <span class="hljs-comment">// 无法接受 lambda！</span>
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>最小内存占用（通常 4/8 字节）</li>
<li>与 C 完全兼容</li>
<li>最简单的 ABI</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法接受有捕获的 lambda</li>
<li>无法接受仿函数</li>
<li>类型不安全（<code>void*</code> 转换）</li>
</ul>
<hr/>
<h2 data-id="heading-5">实战选择指南</h2>


















































<table><thead><tr><th>场景</th><th>推荐方案</th><th>理由</th></tr></thead><tbody><tr><td>算法中的自定义比较/操作</td><td><strong>模板</strong></td><td><code>std::sort(begin, end, cmp)</code> 式接口</td></tr><tr><td>事件/回调系统</td><td><strong><code>std::function</code></strong></td><td>需要存储不同监听者</td></tr><tr><td>依赖注入/策略模式</td><td><strong>模板</strong> 或 <strong><code>std::function</code></strong></td><td>模板编译期确定，<code>std::function</code> 运行时切换</td></tr><tr><td>跨 DLL 边界</td><td><strong><code>std::function</code></strong> 或 <strong>裸指针</strong></td><td>注意 ABI 兼容性</td></tr><tr><td>C API 封装</td><td><strong>裸指针</strong></td><td>被迫使用</td></tr><tr><td>高频调用（&gt;100万次/秒）</td><td><strong>模板</strong></td><td>避免虚函数开销</td></tr><tr><td>延迟执行/任务队列</td><td><strong><code>std::function</code></strong></td><td>必须存储</td></tr><tr><td>配置驱动（运行时决定行为）</td><td><strong><code>std::function</code></strong></td><td>运行时多态</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">现代 C++ 演进（C++23）</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// C++23 std::function_ref：只读、非拥有、零分配</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(std::function_ref&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; op)</span></span>;

<span class="hljs-comment">// 对比：</span>
<span class="hljs-comment">// std::function      : 拥有，可存储，有分配开销</span>
<span class="hljs-comment">// std::function_ref  : 不拥有，轻量，仅借用</span>
<span class="hljs-comment">// 模板               : 编译期确定，最优性能，无存储能力</span>
</code></pre>
<hr/>
<h2 data-id="heading-7">总结建议</h2>
<ol>
<li><strong>默认用模板</strong>：如果不需要存储，模板是零成本抽象的黄金标准</li>
<li><strong>存储用 <code>std::function</code></strong>：需要放入容器或类成员时</li>
<li><strong>C 接口用裸指针</strong>：被迫场景，或极端资源受限</li>
<li><strong>关注 C++23</strong>：<code>std::function_ref</code> 可能成为"需要引用但不存储"场景的最佳选择</li>
</ol>
<p><strong>核心原则</strong>：先尝试模板，遇到存储需求再降级到 <code>std::function</code>，裸指针作为最后手段。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[进程线程和协程一]]></title>    <link>https://juejin.cn/post/7605907495770144777</link>    <guid>https://juejin.cn/post/7605907495770144777</guid>    <pubDate>2026-02-13T06:45:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605907495770144777" data-draft-id="7605807405307019327" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="进程线程和协程一"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T06:45:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大魔王719"/> <meta itemprop="url" content="https://juejin.cn/user/2256671358595687"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            进程线程和协程一
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2256671358595687/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大魔王719
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:45:40.000Z" title="Fri Feb 13 2026 06:45:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前引</h2>
<p align="left">**回到老生常谈的问题什么是进程什么线程什么又是协程，每个编程语言里虽然名词一样但是实际意义多多少少又又一些不同，借着今天想写文章的冲动，浅谈一下自己的理解，如果有不对的还请指出</p>
<h2 data-id="heading-1">进程</h2>
<p align="left">先谈一下进程，顾名思义在进程，线程和协程里面 这个进程在宏观意义上来说可以是最大的了，你可以把它想象成一个*执行程序*有自己的pid,如任务管理器里的每个启动的程序都可以看成是进程。</p>
<p align="left">那除了宏观肯定也有微观，比如对一个值进行读取修改的操作都可以看作是一个进程，比如
</p><pre><code class="hljs language-python" lang="python">    <span class="hljs-built_in">str</span>  = <span class="hljs-string">'dada'</span>
    a = <span class="hljs-built_in">str</span>
    <span class="hljs-built_in">str</span> = a.split(<span class="hljs-string">'d'</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)

</code></pre>
<p>这种都是属于进程操作，那抛出一个官方的定义 所有的<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext>密集型任务</mtext><mo>∗</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{green}{CPU密集型任务*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord" style="color:green;"><span class="mord mathnormal" style="margin-right:0.13889em;color:green;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:green;">U</span><span class="mord cjk_fallback" style="color:green;">密集型任务</span><span class="mord" style="color:green;">∗</span></span></span></span></span></span>*都属于进程</p>
<p/>
<h3 data-id="heading-2">什么是CPU密集型任务</h3>
<p>
    1、复杂的数学计算
</p>
<p>
    2、加密和解密
</p>
<p>
    3、机器学习
</p>
<p>
    4、值的读取修改和回写
</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mrow><mtext>因此只要是满足上面任意一个我们都可以把它看成</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mtext>密集型任务</mtext><mo>−</mo><mo>&gt;</mo><mtext>进程</mtext></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{green}{因此只要是满足上面任意一个我们都可以把它看成CPU密集型任务-&gt;进程}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"/><span class="mord" style="color:green;"><span class="mord cjk_fallback" style="color:green;">因此只要是满足上面任意一个我们都可以把它看成</span><span class="mord mathnormal" style="margin-right:0.13889em;color:green;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:green;">U</span><span class="mord cjk_fallback" style="color:green;">密集型任务</span><span class="mord" style="color:green;">−</span><span class="mspace" style="color:green;margin-right:0.2778em;"/><span class="mrel" style="color:green;">&gt;</span><span class="mspace" style="color:green;margin-right:0.2778em;"/><span class="mord cjk_fallback" style="color:green;">进程</span></span></span></span></span></span></p>
<h2 data-id="heading-3">线程</h2>
<p>
    线程要比进程小，一个进程里面可能是有多个线程来构成，线程是IO密集型任务
    那线程程之间呢可能又分为主线程和子线程，
</p>
<h3 data-id="heading-4">什么是IO密集型任务</h3>
<p>
    1、文件的读写操作
</p>
<p>
    2、网络请求
</p>
<p>
    3、数据库操作
</p>
<p>
    4、sleep操作
</p>
<h5 data-id="heading-5"><strong>ps:读取，响应，修改是CPU密集型（占用CPU计算）,等待、获取结果是IO密集型（占用时间等待IO）</strong></h5>
<h3 data-id="heading-6">接下来让我们先看一个经典的<strong>线程代码</strong></h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">import</span> time

total_money = <span class="hljs-number">200</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_money</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, sp_money: <span class="hljs-built_in">int</span></span>):
    time.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">global</span> total_money
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>,准备取<span class="hljs-subst">{sp_money}</span>元,开始检测余额是否充足"</span>)
    <span class="hljs-keyword">if</span> total_money:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，余额充足为<span class="hljs-subst">{total_money}</span>，开始取钱"</span>)
        total_money = <span class="hljs-built_in">round</span>(total_money - sp_money, <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，已经取了<span class="hljs-subst">{sp_money}</span>,账号余额<span class="hljs-subst">{total_money}</span>"</span>)
    <span class="hljs-keyword">return</span> total_money

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 构建线程</span>
    t1 = Thread(target=speed_money, args=(<span class="hljs-string">"第一个线程"</span>, <span class="hljs-number">100</span>))
    t2 = Thread(target=speed_money, args=(<span class="hljs-string">"第二个线程"</span>, <span class="hljs-number">100</span>))
    t3 = Thread(target=speed_money, args=(<span class="hljs-string">"第三个线程"</span>, <span class="hljs-number">100</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程"</span>)
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [t1, t2, t3]:
        i.start()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程,在join前打印"</span>)
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):
        t1.join()
        t2.join()
        t3.join()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程,在join后打印"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_time = time.time()
    main()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nmain函数执行结束"</span>)
    end_time = time.time()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n总耗时"</span>, <span class="hljs-built_in">round</span>(end_time - start_time, <span class="hljs-number">2</span>))
</code></pre>
<p><strong>打印结果如下</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f2a5c63b6f240878f345226cf66e216~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=OWXwhtnPN3R%2F0V18EvE9R%2BSSsQk%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">抛出疑问</h3>
<ul>
<li><strong>start是干啥的</strong></li>
<li><strong>join是干啥的</strong></li>
<li><strong>为啥结果最后打印的 账号余额是0，我们不是启动了3个线程吗？按照固定思维来说不应该是-100才能体现出线程的作用吗?</strong></li>
</ul>
<p>
</p><p>ok,我们来一个一个解释</p>
<p/>
<h4 data-id="heading-8">start</h4>
<p>我们先改造一下上述代码去掉start和join看是什么样的</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">import</span> time

total_money = <span class="hljs-number">200</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_money</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, sp_money: <span class="hljs-built_in">int</span></span>):
    time.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">global</span> total_money
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>,准备取<span class="hljs-subst">{sp_money}</span>元,开始检测余额是否充足"</span>)
    <span class="hljs-keyword">if</span> total_money:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，余额充足为<span class="hljs-subst">{total_money}</span>，开始取钱"</span>)
        total_money = <span class="hljs-built_in">round</span>(total_money - sp_money, <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，已经取了<span class="hljs-subst">{sp_money}</span>,账号余额<span class="hljs-subst">{total_money}</span>"</span>)
    <span class="hljs-keyword">return</span> total_money

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 构建线程</span>
    t1 = Thread(target=speed_money, args=(<span class="hljs-string">"第一个线程"</span>, <span class="hljs-number">100</span>))
    t2 = Thread(target=speed_money, args=(<span class="hljs-string">"第二个线程"</span>, <span class="hljs-number">100</span>))
    t3 = Thread(target=speed_money, args=(<span class="hljs-string">"第三个线程"</span>, <span class="hljs-number">100</span>))
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_time = time.time()
    main()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nmain函数执行结束"</span>)
    end_time = time.time()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n总耗时"</span>, <span class="hljs-built_in">round</span>(end_time - start_time, <span class="hljs-number">2</span>
</code></pre>
<p>打印结果如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55737269b03e4152ae0173d28496ee55~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=WYj7Br0E1rM1dmM%2BRooaPVA4SGE%3D" alt="image.png" loading="lazy"/>
<em>看起来不加start的话t1，t2，t3 3个子线程都没有执行，倒是有打印主线程的数据如</em></p>
<ul>
<li><strong>构建完线程</strong></li>
<li><strong>main函数执行结束</strong></li>
<li><strong>总耗时</strong></li>
</ul>
<p>那我们加上start继续看</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">import</span> time

total_money = <span class="hljs-number">200</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_money</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, sp_money: <span class="hljs-built_in">int</span></span>):
    time.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">global</span> total_money
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>,准备取<span class="hljs-subst">{sp_money}</span>元,开始检测余额是否充足"</span>)
    <span class="hljs-keyword">if</span> total_money:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，余额充足为<span class="hljs-subst">{total_money}</span>，开始取钱"</span>)
        total_money = <span class="hljs-built_in">round</span>(total_money - sp_money, <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，已经取了<span class="hljs-subst">{sp_money}</span>,账号余额<span class="hljs-subst">{total_money}</span>"</span>)
    <span class="hljs-keyword">return</span> total_money

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 构建线程</span>
    t1 = Thread(target=speed_money, args=(<span class="hljs-string">"第一个线程"</span>, <span class="hljs-number">100</span>))
    t2 = Thread(target=speed_money, args=(<span class="hljs-string">"第二个线程"</span>, <span class="hljs-number">100</span>))
    t3 = Thread(target=speed_money, args=(<span class="hljs-string">"第三个线程"</span>, <span class="hljs-number">100</span>))
    
    t1.start()
    t2.start()
    t3.start()
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_time = time.time()
    main()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nmain函数执行结束"</span>)
    end_time = time.time()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n总耗时"</span>, <span class="hljs-built_in">round</span>(end_time - start_time, <span class="hljs-number">2</span>
</code></pre>
<p>打印结果如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc6cf2be85c940d593bed39b06d2047e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=a1lEKT11h5ZL5uPOjZ2cHbyS%2BcQ%3D" alt="image.png" loading="lazy"/></p>
<h6 data-id="heading-9">综上得出结论</h6>
<ul>
<li><strong>start关键字是启动子线程</strong></li>
<li><strong>start关键字不会阻塞主进程（类似河流分叉-子进程执行子进程，主进程执行主进程的，主进程即使执行完，子进程也会继续执行）</strong></li>
</ul>
<p>但是只有start的话肯定是不满足我们使用的，比如我们主进程需要等子进程执行完才会执行。</p>
<h4 data-id="heading-10">join</h4>
<p>继续完善上面只有start的代码</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">import</span> time

total_money = <span class="hljs-number">200</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_money</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, sp_money: <span class="hljs-built_in">int</span></span>):
    time.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">global</span> total_money
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>,准备取<span class="hljs-subst">{sp_money}</span>元,开始检测余额是否充足"</span>)
    <span class="hljs-keyword">if</span> total_money:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，余额充足为<span class="hljs-subst">{total_money}</span>，开始取钱"</span>)
        total_money = <span class="hljs-built_in">round</span>(total_money - sp_money, <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，已经取了<span class="hljs-subst">{sp_money}</span>,账号余额<span class="hljs-subst">{total_money}</span>"</span>)
    <span class="hljs-keyword">return</span> total_money

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 构建线程</span>
    t1 = Thread(target=speed_money, args=(<span class="hljs-string">"第一个线程"</span>, <span class="hljs-number">100</span>))
    t2 = Thread(target=speed_money, args=(<span class="hljs-string">"第二个线程"</span>, <span class="hljs-number">100</span>))
    t3 = Thread(target=speed_money, args=(<span class="hljs-string">"第三个线程"</span>, <span class="hljs-number">100</span>))

    t1.start()
    t2.start()
    t3.start()

    t1.join()
    t2.join()
    t3.join()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_time = time.time()
    main()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nmain函数执行结束"</span>)
    end_time = time.time()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n总耗时"</span>, <span class="hljs-built_in">round</span>(end_time - start_time, <span class="hljs-number">2</span>))
</code></pre>
<p>打印结果如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/477bedc3f87045cf9e416328321ec29a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=isZgWzah%2BQeL7FgIjPucOt7Q%2Fv0%3D" alt="image.png" loading="lazy"/></p>
<h6 data-id="heading-11">综上得出结论</h6>
<ul>
<li><strong>join需要和strat成对出现</strong></li>
<li><strong>join会阻塞当前主线程。</strong></li>
<li><strong>被join的子线程执行完，会继续执行主线程</strong></li>
</ul>
<h4 data-id="heading-12">为啥打印余额是0</h4>
<p>不知道你还记不记得我们在进行if判断的时候，我们是有一个sleep的操作的,</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6b7d8b628664259954889ea137652de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=YUjGtQ%2BHBb1dtMk7Q1HiY9a7f3Q%3D" alt="image.png" loading="lazy"/></p>
<p>很关键的一步，那我们先后启动了<strong>3</strong>个子线程，<strong>t1.start,，t2.start,，t3.start</strong>,当子线程执行到<strong>sleep</strong>这步时，线程1，线程2，线程3都在这个地方停了下来，也就是在<strong>1s内这个地方可能聚集了3个子线程</strong>，然后睡眠时间结束，t1，t2，t3开始继续向下执行。<strong>（这里不引入gli的概念（即一个进程会有一个gli锁，也就是同一时间同一行代码只有一个线程可以执行））</strong>
那我t1先进行逻辑判断，total_money首次肯定是通过的，进行一次减法运算，<strong>total_money最后是100</strong>，这个时候可能t2也进行了判断，total_money是100也通过，再次进行一次减法运算，<strong>total_money最后是0</strong>，这个时候可能t3也进行了判断，total_money是0，所以不会通过 最后结果打印是** 0**，<strong>当然这个是理想状态，且if逻辑很短，所以出现了逻辑结束，下一个子线程还没开始进入内部逻辑运算的场景</strong></p>
<h5 data-id="heading-13">修改代码</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">import</span> time

total_money = <span class="hljs-number">200</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_money</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, sp_money: <span class="hljs-built_in">int</span></span>):
    time.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">global</span> total_money
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>,准备取<span class="hljs-subst">{sp_money}</span>元,开始检测余额是否充足"</span>)
    <span class="hljs-keyword">if</span> total_money:
        time.sleep(<span class="hljs-number">1</span>)<span class="hljs-comment">#只是增加了这步</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，余额充足为<span class="hljs-subst">{total_money}</span>，开始取钱"</span>)
        total_money = <span class="hljs-built_in">round</span>(total_money - sp_money, <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，已经取了<span class="hljs-subst">{sp_money}</span>,账号余额<span class="hljs-subst">{total_money}</span>"</span>)
    <span class="hljs-keyword">return</span> total_money

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 构建线程</span>
    t1 = Thread(target=speed_money, args=(<span class="hljs-string">"第一个线程"</span>, <span class="hljs-number">100</span>))
    t2 = Thread(target=speed_money, args=(<span class="hljs-string">"第二个线程"</span>, <span class="hljs-number">100</span>))
    t3 = Thread(target=speed_money, args=(<span class="hljs-string">"第三个线程"</span>, <span class="hljs-number">100</span>))

    t1.start()
    t2.start()
    t3.start()

    t1.join()
    t2.join()
    t3.join()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_time = time.time()
    main()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nmain函数执行结束"</span>)
    end_time = time.time()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n总耗时"</span>, <span class="hljs-built_in">round</span>(end_time - start_time, <span class="hljs-number">2</span>))
</code></pre>
<h6 data-id="heading-14">改动内容</h6>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3fa4d02eb634eceba1485e763fd9f81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=7w3BKZ0bjUK3VL6726BDlf87FDU%3D" alt="image.png" loading="lazy"/>
打印结果如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/291082bc174d41e8bc40d2b2895d1ae8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=vySwNdKhUAahrI0qjVCVUwBGdwI%3D" alt="image.png" loading="lazy"/>
<strong>这里代码只是加了一个sleep,为啥余额变成负数了呢？</strong>
按照上面现象的解释对照分析，第一个sleep聚齐了3个子线程，第一个子线程sleep结束，向里执行首次total_money是200，肯定是通过的，<strong>这个时候又遇到了sleep,所以继续睡眠</strong>。那这个时候第二个线程sleep也结束了，因为第一个线程还在睡眠肯定是还没有修改total_money的，<strong>所以total_money也是200，也进入了if里面，又碰到了sleep，所以也继续睡眠</strong>，第三个同理。最后也即是在里面的sleep又聚集了3个子线程，然后<strong>3个子线程依次唤醒，依次进行减100的操作，最后得出 total_money是-100</strong>，ps:代码里的sleep主要是为了增加耗时，实际场景可能是任意操作。</p>
<h2 data-id="heading-15">线程锁</h2>
<p><strong>所以针对多线程的操作，为了保证数据的正确性我们需要加上线程锁（lock）</strong></p>
<h5 data-id="heading-16">代码如下</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock
<span class="hljs-keyword">import</span> time

total_money = <span class="hljs-number">200</span>

l = Lock()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_money</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, sp_money: <span class="hljs-built_in">int</span></span>):
    time.sleep(<span class="hljs-number">1</span>)
    l.acquire()  <span class="hljs-comment"># 上锁</span>
    <span class="hljs-keyword">global</span> total_money
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>,准备取<span class="hljs-subst">{sp_money}</span>元,开始检测余额是否充足"</span>)
    <span class="hljs-keyword">if</span> total_money:
        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 只是增加了这步</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，余额充足为<span class="hljs-subst">{total_money}</span>，开始取钱"</span>)
        total_money = <span class="hljs-built_in">round</span>(total_money - sp_money, <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，已经取了<span class="hljs-subst">{sp_money}</span>,账号余额<span class="hljs-subst">{total_money}</span>"</span>)
    l.release()  <span class="hljs-comment"># 释放锁</span>
    <span class="hljs-keyword">return</span> total_money

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 构建线程</span>
    t1 = Thread(target=speed_money, args=(<span class="hljs-string">"第一个线程"</span>, <span class="hljs-number">100</span>))
    t2 = Thread(target=speed_money, args=(<span class="hljs-string">"第二个线程"</span>, <span class="hljs-number">100</span>))
    t3 = Thread(target=speed_money, args=(<span class="hljs-string">"第三个线程"</span>, <span class="hljs-number">100</span>))

    t1.start()
    t2.start()
    t3.start()

    t1.join()
    t2.join()
    t3.join()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_time = time.time()
    main()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nmain函数执行结束"</span>)
    end_time = time.time()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n总耗时"</span>, <span class="hljs-built_in">round</span>(end_time - start_time, <span class="hljs-number">2</span>))
</code></pre>
<p>上面代码呢主要是在代码执行逻辑那里加了lock.acquire()和lock.release()</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2242d49c82f74967873dc27aa3ac9720~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=1mD3%2FZ3gHd%2FuMlZPEO%2BfRppUgVQ%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-17">执行结果</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cadf12952774497ca50e2547ca57f919~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=riN%2B7NHQih%2B921r1wyqtRSCcpgA%3D" alt="image.png" loading="lazy"/>
可以看到我们加了lock以后，账号余额是没有变成负数的了，说明在子线程相互竞争的时候，由于上了锁，只会通过一个，但是lock使用需要手动acquire和lock，基于这个我们可以使用一下with,</p>
<h5 data-id="heading-18">优化代码如下</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock
<span class="hljs-keyword">import</span> time

total_money = <span class="hljs-number">200</span>

l = Lock()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_money</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, sp_money: <span class="hljs-built_in">int</span></span>):
    time.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">with</span> l:  <span class="hljs-comment"># 使用 with 语句来自动加锁和释放锁</span>
        <span class="hljs-keyword">global</span> total_money
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>,准备取<span class="hljs-subst">{sp_money}</span>元,开始检测余额是否充足"</span>)
        <span class="hljs-keyword">if</span> total_money:
            time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 只是增加了这步</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，余额充足为<span class="hljs-subst">{total_money}</span>，开始取钱"</span>)
            total_money = <span class="hljs-built_in">round</span>(total_money - sp_money, <span class="hljs-number">2</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n当前线程是<span class="hljs-subst">{name}</span>，已经取了<span class="hljs-subst">{sp_money}</span>,账号余额<span class="hljs-subst">{total_money}</span>"</span>)
    <span class="hljs-keyword">return</span> total_money

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-comment"># 构建线程</span>
    t1 = Thread(target=speed_money, args=(<span class="hljs-string">"第一个线程"</span>, <span class="hljs-number">100</span>))
    t2 = Thread(target=speed_money, args=(<span class="hljs-string">"第二个线程"</span>, <span class="hljs-number">100</span>))
    t3 = Thread(target=speed_money, args=(<span class="hljs-string">"第三个线程"</span>, <span class="hljs-number">100</span>))

    t1.start()
    t2.start()
    t3.start()

    t1.join()
    t2.join()
    t3.join()

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n构建完线程"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    start_time = time.time()
    main()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\nmain函数执行结束"</span>)
    end_time = time.time()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n总耗时"</span>, <span class="hljs-built_in">round</span>(end_time - start_time, <span class="hljs-number">2</span>))
</code></pre>
<h6 data-id="heading-19">改动内容</h6>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39b6d244c034460db9ec5080e7cc4280~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=2hrvAHTMz3%2BiCHgijqekSyK%2BfGM%3D" alt="image.png" loading="lazy"/></p>
<h6 data-id="heading-20">执行结果</h6>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/98e1b1c7a3cc479cad31ed6f53d9aa8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6a2U546LNzE5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569940&amp;x-signature=xjTPQT7tKkd6trd%2F43uikr7JQHY%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[拒绝重写！Flutter Add-to-App 全攻略：让原生应用“渐进式”拥抱跨平台]]></title>    <link>https://juejin.cn/post/7605772919225106466</link>    <guid>https://juejin.cn/post/7605772919225106466</guid>    <pubDate>2026-02-13T06:34:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605772919225106466" data-draft-id="7605772919225073698" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="拒绝重写！Flutter Add-to-App 全攻略：让原生应用“渐进式”拥抱跨平台"/> <meta itemprop="keywords" content="Flutter,前端框架,前端"/> <meta itemprop="datePublished" content="2026-02-13T06:34:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RaidenLiu"/> <meta itemprop="url" content="https://juejin.cn/user/1781679670965208"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            拒绝重写！Flutter Add-to-App 全攻略：让原生应用“渐进式”拥抱跨平台
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1781679670965208/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RaidenLiu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:34:20.000Z" title="Fri Feb 13 2026 06:34:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">为什么我们需要 Add-to-App？</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ecfa3fcb441443ada7c50f6455f432d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUmFpZGVuTGl1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771569260&amp;x-signature=Yjai0j2pEz9SceYjeg6lFLBXJwE%3D" alt="unwatermarked_Gemini_Generated_Image_51ku3f51ku3f51ku.png" loading="lazy"/>
在移动开发领域，Flutter 的跨平台优势（Write once, run anywhere）毋庸置疑。但在现实世界中，我们往往面临着沉重的“历史包袱”。</p>
<p><strong>痛点场景：</strong></p>
<blockquote>
<p>“我们公司有一个维护了 5 年的电商 App，原生代码几十万行。最近老板嫌 UI 迭代慢，想用 Flutter，但完全重写是不可能的——业务线太长，风险太大。我们要的是渐进式的改变。”</p>
</blockquote>
<p>这就是 <strong>Add-to-App</strong> 存在的意义。它允许我们将 Flutter 视为一个“库”或“模块”，嵌入到现有的 Android 或 iOS 应用中。</p>
<p><strong>它的核心价值在于：</strong></p>
<ol>
<li><strong>成本控制</strong>：无需抛弃现有的原生资产（支付模块、复杂的底层算法等）。</li>
<li><strong>渐进迁移</strong>：可以从一个非核心页面（如“关于我们”或“活动页”）开始，逐步扩大 Flutter 的版图。</li>
<li><strong>复用能力</strong>：新开发的 Flutter 模块可以直接在 Android 和 iOS 甚至 Web 上复用，从一开始就享受跨平台红利。</li>
</ol>
<hr/>
<h2 data-id="heading-1">Add-to-App 的基本概念与原理</h2>
<h3 data-id="heading-2">什么是 Add-to-App？</h3>
<p>简单来说，Add-to-App 就是把 Flutter 环境（Dart VM + Flutter Engine）打包成一个原生组件（View 或 ViewController/Activity），塞进现有的原生 App 里。</p>
<ul>
<li><strong>对于 Android</strong>：Flutter 只是一个 View，或者一个 Activity/Fragment。</li>
<li><strong>对于 iOS</strong>：Flutter 只是一个 UIView，或者 FlutterViewController。</li>
</ul>
<h3 data-id="heading-3">运行模式：多引擎 vs 多视图</h3>
<p>在混合开发中，理解 Flutter 的“寄生”方式至关重要：</p>





























<table><thead><tr><th><strong>策略</strong></th><th><strong>描述</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>单引擎复用 (Single Engine)</strong></td><td>全局维护一个 Engine，在不同原生页面间跳转时，通过 attach/detach 挂载到当前界面。</td><td>内存占用最低；状态不仅共享且保持。</td><td>导航栈管理极其复杂（原生页面 A -&gt; Flutter B -&gt; 原生 C -&gt; 返回 B 时需恢复现场）。</td></tr><tr><td><strong>多引擎 (Multi-Engine)</strong></td><td>每次打开 Flutter 页面都创建一个新 Engine。</td><td>逻辑隔离，互不干扰；导航栈管理简单。</td><td><strong>内存爆炸</strong>（每个 Engine 默认消耗较大），启动延迟明显。</td></tr><tr><td><strong>FlutterEngineGroup (推荐)</strong></td><td>官方提供的轻量级多引擎方案（Flutter 2.0+）。</td><td>多个 Engine 共享 GPU 上下文、字体和代码段，<strong>新增一个 Engine 仅需 ~180KB 内存</strong>。</td><td>Dart Isolate 彼此隔离，<strong>状态不共享</strong>（需通过数据层同步）。</td></tr></tbody></table>
<p><strong>误区提示</strong>：桌面端/Web 支持的“多视图（Multi-view）”模式（即一个 Engine 渲染多个窗口）目前<strong>尚未</strong>在移动端 Add-to-App 场景中稳定支持。在移动端，请优先考虑 <strong>FlutterEngineGroup</strong>。</p>
<h3 data-id="heading-4">最佳实践场景</h3>
<ul>
<li><strong>高频迭代的业务模块</strong>：如电商的活动页、个人中心。</li>
<li><strong>复杂的 UI 交互</strong>：如需要高性能动画的图表页。</li>
<li><strong>统一逻辑</strong>：双端逻辑完全一致的表单提交或业务计算。</li>
</ul>
<hr/>
<h2 data-id="heading-5">实战 I：在 Android 原生 App 中嵌入 Flutter</h2>
<h3 data-id="heading-6">创建 Flutter Module</h3>
<p>注意，我们不能 <code>flutter create my_app</code>，因为我们不需要一个完整的 App 壳子，我们需要的是一个<strong>模块</strong>。</p>
<pre><code class="hljs language-lua" lang="lua"># 在原生项目同级目录下执行
flutter <span class="hljs-built_in">create</span> -t <span class="hljs-built_in">module</span> my_flutter_module
</code></pre>
<p>执行后，你会发现生成的目录结构中，<code>android</code> 和 <code>ios</code> 文件夹是隐藏的（.android, .ios），因为它们是自动生成的包装器。</p>
<h3 data-id="heading-7">将 Flutter Module 导入 Android 项目</h3>
<p>自 Flutter 3.x 起，官方推荐通过 Gradle 脚本自动管理依赖，避免手动编写 implementation 导致的版本冲突。</p>
<p><strong>步骤 1：修改 settings.gradle</strong></p>
<p>在 include ':app' 之后加入：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 绑定 Flutter 模块构建脚本</span>
<span class="hljs-built_in">setBinding</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Binding</span>([gradle: <span class="hljs-keyword">this</span>]))
<span class="hljs-built_in">evaluate</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(
  settingsDir.parentFile, <span class="hljs-comment">// 假设 flutter_module 与当前项目同级</span>
  <span class="hljs-string">'my_flutter_module/.android/include_flutter.groovy'</span>
))
</code></pre>
<p><strong>步骤 2：修改 app/build.gradle</strong></p>
<p>依赖会自动注入，<strong>通常无需手动添加</strong> implementation project(':flutter')。但需确保 compileSdkVersion 与 Flutter 模块要求一致（通常需 API 33+）。</p>
<p><strong>在 Android 上渲染 Flutter (Activity 与 Fragment)</strong></p>
<p><strong>方式 A：使用 FlutterActivity（全屏场景）</strong></p>
<p>适合独立的业务流程，如“个人中心”或“设置页”。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 使用缓存 Engine 启动（推荐）</span>
startActivity(
    FlutterActivity
        .withCachedEngine(<span class="hljs-string">"my_engine_id"</span>)
        .build(<span class="hljs-keyword">this</span>)
);
</code></pre>
<p><strong>方式 B：使用 FlutterFragment（局部嵌入）</strong></p>
<p>适合将 Flutter 作为一个 View 块嵌入原生页面，例如在一个原生 Tab 页中展示 Flutter 列表。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 在原生 Activity 或 Fragment 中</span>
FragmentManager fragmentManager = <span class="hljs-built_in">getSupportFragmentManager</span>();
fragmentManager
    <span class="hljs-selector-class">.beginTransaction</span>()
    <span class="hljs-selector-class">.replace</span>(R.id.fragment_container, 
             FlutterFragment.withCachedEngine("my_engine_id")<span class="hljs-selector-class">.build</span>())
    <span class="hljs-selector-class">.commit</span>();
</code></pre>
<p><strong>性能优化 Tip：使用缓存 Engine</strong></p>
<p><code>withNewEngine()</code> 会导致每次打开页面都有明显的“白屏”或加载延迟。推荐使用 <strong>FlutterEngineCache</strong> 进行预热：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-comment">// 1. 在 Application 启动时预热</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>{
    <span class="hljs-meta">@Override</span>
    public void onCreate() {
        <span class="hljs-keyword">super</span>.onCreate();
        <span class="hljs-comment">// 实例化 Engine</span>
        <span class="hljs-type">FlutterEngine</span> flutterEngine = <span class="hljs-keyword">new</span> <span class="hljs-type">FlutterEngine</span>(<span class="hljs-keyword">this</span>);
        <span class="hljs-comment">// 开始执行 Dart 代码（预加载）</span>
        flutterEngine.getDartExecutor().executeDartEntrypoint(
            <span class="hljs-type">DartExecutor</span>.<span class="hljs-type">DartEntrypoint</span>.createDefault()
        );
        <span class="hljs-comment">// 存入缓存</span>
        <span class="hljs-type">FlutterEngineCache</span>
            .getInstance()
            .put(<span class="hljs-string">"my_engine_id"</span>, flutterEngine);
    }
}

<span class="hljs-comment">// 2. 启动时使用缓存的 Engine</span>
startActivity(
    <span class="hljs-type">FlutterActivity</span>
        .withCachedEngine(<span class="hljs-string">"my_engine_id"</span>)
        .build(<span class="hljs-keyword">this</span>)
);
</code></pre>
<h2 data-id="heading-8">实战 II：在 iOS 原生 App 集成 Flutter</h2>
<h3 data-id="heading-9">创建 Flutter Module</h3>
<p>（同上，使用同一个 <code>my_flutter_module</code> 即可）</p>
<h3 data-id="heading-10">CocoaPods 集成</h3>
<p>这是 iOS 最标准的集成方式。</p>
<p><strong>修改 <code>Podfile</code></strong></p>
<p>在 iOS 工程的 <code>Podfile</code> 中添加脚本钩子：</p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-comment"># Podfile</span>
platform <span class="hljs-symbol">:ios</span>, <span class="hljs-string">'14.0'</span>

<span class="hljs-comment"># 定义 Flutter 模块路径</span>
flutter_application_path = <span class="hljs-string">'../my_flutter_module'</span>

<span class="hljs-comment"># 加载 Flutter 的 Pod 助手脚本</span>
load <span class="hljs-title class_">File</span>.join(flutter_application_path, <span class="hljs-string">'.ios'</span>, <span class="hljs-string">'Flutter'</span>, <span class="hljs-string">'podhelper.rb'</span>)

target <span class="hljs-string">'MyApp'</span> <span class="hljs-keyword">do</span>
  use_frameworks!
  
  <span class="hljs-comment"># 安装 Flutter 依赖</span>
  install_all_flutter_pods(flutter_application_path)
<span class="hljs-keyword">end</span>
</code></pre>
<p>执行 <code>pod install</code>，你会发现 Flutter 相关的 Framework 已经被链接进来了。</p>
<h3 data-id="heading-11">在 iOS 中打开 Flutter View</h3>
<p>使用 <code>FlutterViewController</code>。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> Flutter

<span class="hljs-comment">// 在某个按钮点击事件中</span>
<span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">showFlutter</span>() {
    <span class="hljs-comment">// 获取 Flutter Engine（同样建议使用 Cache，这里演示简单模式）</span>
    <span class="hljs-keyword">let</span> flutterEngine <span class="hljs-operator">=</span> (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as!</span> <span class="hljs-type">AppDelegate</span>).flutterEngine
    
    <span class="hljs-keyword">let</span> flutterViewController <span class="hljs-operator">=</span> <span class="hljs-type">FlutterViewController</span>(
        engine: flutterEngine, 
        nibName: <span class="hljs-literal">nil</span>, 
        bundle: <span class="hljs-literal">nil</span>
    )
    
    present(flutterViewController, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)
}
</code></pre>
<h3 data-id="heading-12">在 iOS 中使用缓存 Engine</h3>
<p>为了避免点击按钮时卡顿，<strong>强烈建议</strong>在 App 启动时预热 Engine。</p>
<p><strong>步骤 1：在 AppDelegate 中初始化并缓存</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-keyword">import</span> Flutter
<span class="hljs-keyword">import</span> FlutterPluginRegistrant <span class="hljs-comment">// 用于注册插件</span>

<span class="hljs-keyword">@main</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppDelegate</span>: <span class="hljs-title class_">FlutterAppDelegate</span> { <span class="hljs-comment">// 继承 FlutterAppDelegate</span>
  
  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> flutterEngine <span class="hljs-operator">=</span> <span class="hljs-type">FlutterEngine</span>(name: <span class="hljs-string">"my_engine_id"</span>)

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">application</span>(
    <span class="hljs-keyword">_</span> <span class="hljs-params">application</span>: <span class="hljs-type">UIApplication</span>,
    <span class="hljs-params">didFinishLaunchingWithOptions</span> <span class="hljs-params">launchOptions</span>: [<span class="hljs-type">UIApplication</span>.<span class="hljs-params">LaunchOptionsKey</span>: <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>
  ) -&gt; <span class="hljs-type">Bool</span> {
    <span class="hljs-comment">// 1. 运行 Engine (预热)</span>
    flutterEngine.run();
    <span class="hljs-comment">// 2. 注册插件（关键！否则 Flutter 里的插件无法使用）</span>
    <span class="hljs-type">GeneratedPluginRegistrant</span>.register(with: flutterEngine);
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.application(application, didFinishLaunchingWithOptions: launchOptions);
  }
}
</code></pre>
<p><strong>步骤 2：使用缓存 Engine 弹出页面</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">showFlutter</span>() {
    <span class="hljs-keyword">let</span> appDelegate <span class="hljs-operator">=</span> <span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as!</span> <span class="hljs-type">AppDelegate</span>
    <span class="hljs-keyword">let</span> flutterEngine <span class="hljs-operator">=</span> appDelegate.flutterEngine
    
    <span class="hljs-keyword">let</span> flutterVC <span class="hljs-operator">=</span> <span class="hljs-type">FlutterViewController</span>(engine: flutterEngine, nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)
    present(flutterVC, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)
}
</code></pre>
<h2 data-id="heading-13">进阶：原生与 Flutter 的双向通信 (MethodChannel)</h2>
<p>当混合开发时，不可避免地需要数据交互：Flutter 读取原生的 Token，或者原生调用 Flutter 的刷新方法。<strong>MethodChannel</strong> 是最常用的桥梁。</p>
<h3 data-id="heading-14">5.1 Flutter 端 (Dart)</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/services.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeBridge</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> platform = MethodChannel(<span class="hljs-string">'com.example.app/data'</span>);

  <span class="hljs-comment">// 调用原生方法</span>
  Future&lt;<span class="hljs-built_in">String</span>&gt; getUserToken() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> token = <span class="hljs-keyword">await</span> platform.invokeMethod(<span class="hljs-string">'getToken'</span>);
      <span class="hljs-keyword">return</span> token;
    } <span class="hljs-keyword">on</span> PlatformException <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Failed: '<span class="hljs-subst">${e.message}</span>'."</span>;
    }
  }
}
</code></pre>
<h3 data-id="heading-15">5.2 Android 端</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 需在 Engine 初始化后注册 Channel</span>
new <span class="hljs-built_in">MethodChannel</span>(flutterEngine.getDartExecutor()<span class="hljs-selector-class">.getBinaryMessenger</span>(), "com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.app</span>/data")
    <span class="hljs-selector-class">.setMethodCallHandler</span>(
        (call, result) -&gt; {
            if (call.method.equals("getToken")) {
                <span class="hljs-comment">// 执行原生逻辑获取 Token</span>
                String token = MyAuthManager<span class="hljs-selector-class">.getToken</span>();
                result<span class="hljs-selector-class">.success</span>(token);
            } else {
                result<span class="hljs-selector-class">.notImplemented</span>();
            }
        }
    );
</code></pre>
<h3 data-id="heading-16"><strong>注意事项：</strong></h3>
<p>MethodChannel 并非能传递任意对象，它的底层依赖 <strong>BinaryMessenger</strong> 进行二进制流传输。</p>
<ul>
<li>
<p><strong>StandardMethodCodec（标准编解码器）</strong> ： Flutter 默认使用此 Codec，它只支持高效序列化以下<strong>基础类型</strong>：</p>
<ul>
<li><code>null</code>, <code>bool</code>, <code>int</code>, <code>double</code>, <code>String</code></li>
<li><code>List</code>, <code>Map</code> (仅限上述基础类型的集合)</li>
<li>二进制数据 (<code>Uint8List</code> / <code>byte[]</code>)</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：如果你尝试直接传递一个自定义类 <code>User</code>，通道会报错。 <strong>解决方案</strong>：将对象转为 JSON String 或 Map 进行传递，或者自定义 Codec。</p>
</blockquote>
<hr/>
<h2 data-id="heading-17">进阶：混合栈管理与多 Engine 挑战</h2>
<p>在 Add-to-App 中，最头疼的问题往往是 导航栈（Navigation Stack）。</p>
<p>比如：<code>原生 A -&gt; Flutter B -&gt; 原生 C -&gt; Flutter D</code>。</p>
<h3 data-id="heading-18">挑战</h3>
<ol>
<li><strong>内存爆炸</strong>：如果每次 <code>&gt; Flutter</code> 都创建一个新 Engine，内存会迅速耗尽。</li>
<li><strong>状态丢失</strong>：如果复用同一个 Engine，从 C 返回 B 时，Flutter 的状态怎么恢复？</li>
</ol>
<h3 data-id="heading-19">解决方案策略</h3>
<p>当原生应用需要在 Feed 流中嵌入多个 Flutter 卡片，或者同时存在多个 Flutter 页面栈时，单纯的“单引擎”或“多引擎”都不够完美。</p>
<p><strong>终极方案：FlutterEngineGroup</strong> 这是官方为了解决“多实例内存占用”推出的 API。</p>
<p><strong>原理</strong>： 它允许你创建多个 Engine 实例，这些实例共享内存重的资源（如 Skia Shader、字体、Dart VM 快照），但保持 <strong>Dart Isolate 隔离</strong>。</p>
<p><strong>代码示例 (Android)</strong> ：</p>
<pre><code class="hljs language-ini" lang="ini">// 创建 EngineGroup
FlutterEngineGroup <span class="hljs-attr">engineGroup</span> = new FlutterEngineGroup(context)<span class="hljs-comment">;</span>

// 创建第一个轻量级 Engine
FlutterEngine <span class="hljs-attr">engine1</span> = engineGroup.createAndRunDefaultEngine(context)<span class="hljs-comment">;</span>

// 创建第二个轻量级 Engine（复用资源，内存开销极低）
FlutterEngine <span class="hljs-attr">engine2</span> = engineGroup.createAndRunDefaultEngine(context)<span class="hljs-comment">;</span>
</code></pre>
<p><strong>状态管理挑战</strong>： 由于 EngineGroup 中的 Isolate 是隔离的，<code>engine1</code> 中的全局变量无法被 <code>engine2</code> 直接读取。</p>
<ul>
<li><strong>解决</strong>：相比于通过原生层（Host）作为中转站，或者使用持久化存储（Database/SharedPrefs）来同步不同 Flutter 页面间的数据。使用平台通道并且搭配上<strong>pigeon</strong>，相信会给你复杂原生交互提供不少的便利。</li>
</ul>
<h2 data-id="heading-20">7. 常见问题与“避坑”指南</h2>






























<table><thead><tr><th><strong>场景</strong></th><th><strong>现象/原因</strong></th><th><strong>解决方案</strong></th></tr></thead><tbody><tr><td><strong>冷启动</strong></td><td>点击按钮后，等待 1-2 秒才出现 Flutter 画面，且有白屏。</td><td><strong>必须预热 Engine</strong>！在 App 启动时初始化 Engine 并存入 Cache。</td></tr><tr><td><strong>调试</strong></td><td>运行原生 App 后，无法使用 Flutter 的热重载 (Hot Reload)。</td><td>在终端运行 <code>flutter attach</code>，连接到正在运行的设备。</td></tr><tr><td><strong>图片加载</strong></td><td>Flutter 无法加载原生 Assets 中的图片。</td><td>原生图片需在 Flutter <code>pubspec.yaml</code> 中声明，或通过 Platform Channel 传递图片数据（字节流）。</td></tr><tr><td><strong>生命周期</strong></td><td>Flutter 页面退后台后，代码被挂起。</td><td>原生层需正确转发生命周期事件（<code>lifecycle_channel</code>），确保 Flutter 知道自己处于前台还是后台。</td></tr></tbody></table>
<h2 data-id="heading-21">8. 总结</h2>
<p>Add-to-App 方案打破了“非黑即白”的技术选型困境，是目前大型 App 引入 Flutter 的主流路径。</p>
<p><strong>核心路径回顾：</strong></p>
<ol>
<li><code>flutter create -t module</code> 创建模块。</li>
<li>利用 <strong>FlutterEngineCache</strong> 解决性能问题。</li>
<li>利用 <strong>MethodChannel</strong> 打通数据经脉。</li>
</ol>
<p>混合开发没有银弹，只有不断的权衡。希望本文能帮助你在现有的原生堡垒中，成功开辟出第一块 Flutter 的疆土！</p>
<h3 data-id="heading-22">延伸阅读</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Fdevelopment%2Fadd-to-app" target="_blank" title="https://flutter.dev/docs/development/add-to-app" ref="nofollow noopener noreferrer">Flutter 官方 Add-to-App 指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fsamples%2Ftree%2Fmaster%2Fadd_to_app" target="_blank" title="https://github.com/flutter/samples/tree/master/add_to_app" ref="nofollow noopener noreferrer">GitHub 示例：flutter_module_books</a></li>
</ul>
<p><em>希望这篇分享对你有帮助！如果想了解更深层的 Engine 源码分析，欢迎留言讨论。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[别再用 ID 定位了！教你用"语义指纹"实现 99% 的元素定位成功率]]></title>    <link>https://juejin.cn/post/7605856048361701414</link>    <guid>https://juejin.cn/post/7605856048361701414</guid>    <pubDate>2026-02-13T06:42:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605856048361701414" data-draft-id="7605888927714721830" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="别再用 ID 定位了！教你用&quot;语义指纹&quot;实现 99% 的元素定位成功率"/> <meta itemprop="keywords" content="前端,AIGC"/> <meta itemprop="datePublished" content="2026-02-13T06:42:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大龄程序员"/> <meta itemprop="url" content="https://juejin.cn/user/784393864231083"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            别再用 ID 定位了！教你用"语义指纹"实现 99% 的元素定位成功率
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/784393864231083/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大龄程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T06:42:12.000Z" title="Fri Feb 13 2026 06:42:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">痛点</h2>
<p>做过自动化测试或爬虫的同学一定遇到过这种情况：
昨天写的脚本 <code>document.querySelector('#login-btn')</code> 还能跑，今天网站更新了，ID 变成了 <code>#login-btn-123</code>，脚本直接挂掉。</p>
<p>在开发 <strong>AutoForm 智能表单填充 SDK</strong> 时，我们面临同样的挑战：如何让 SDK 在页面结构变化后，依然能找到那个"用户名输入框"？</p>
<p>答案是：<strong>语义指纹（Semantic Fingerprinting）</strong>。</p>
<h2 data-id="heading-1">什么是语义指纹？</h2>
<p>人类找元素不是靠 ID，而是靠"特征"。
当你看到一个输入框，旁边写着"用户名"，里面提示"请输入手机号"，你就知道它是干嘛的。</p>
<p>我们将这些特征提取出来，生成一个唯一的哈希值，这就是"语义指纹"。</p>
<h2 data-id="heading-2">算法实现</h2>
<h3 data-id="heading-3">1. 特征提取</h3>
<p>我们提取以下维度的特征：</p>
<ul>
<li><strong>Label 文本</strong>：这是最强的语义特征。</li>
<li><strong>Placeholder</strong>：提示文案。</li>
<li><strong>Name 属性</strong>：通常包含字段含义（如 <code>username</code>, <code>email</code>）。</li>
<li><strong>Input Type</strong>：输入类型（<code>text</code>, <code>password</code>, <code>checkbox</code>）。</li>
<li><strong>前驱/后继文本</strong>：DOM 树中相邻的文本节点。</li>
</ul>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extractFeatures</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">tag</span>: element.<span class="hljs-property">tagName</span>,
    <span class="hljs-attr">type</span>: element.<span class="hljs-property">type</span>,
    <span class="hljs-attr">name</span>: element.<span class="hljs-property">name</span>,
    <span class="hljs-attr">label</span>: <span class="hljs-title function_">findLabel</span>(element), <span class="hljs-comment">// 关联的 label 文本</span>
    <span class="hljs-attr">placeholder</span>: element.<span class="hljs-property">placeholder</span>,
    <span class="hljs-attr">surroundingText</span>: <span class="hljs-title function_">getSurroundingText</span>(element)
  };
}
</code></pre>
<h3 data-id="heading-4">2. 指纹生成</h3>
<p>将特征拼接成字符串，然后计算 Hash。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { md5 } <span class="hljs-keyword">from</span> <span class="hljs-string">'hash-wasm'</span>;

<span class="hljs-keyword">const</span> fingerprint = <span class="hljs-keyword">await</span> <span class="hljs-title function_">md5</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(features));
</code></pre>
<h3 data-id="heading-5">3. 模糊匹配</h3>
<p>当页面更新后，新元素的指纹可能与旧指纹不完全一致（比如 placeholder 变了）。这时我们计算<strong>相似度（Similarity Score）</strong>。</p>
<p>我们使用 <strong>Levenshtein Distance（编辑距离）</strong> 算法来比较两个特征对象的相似度。如果相似度 &gt; 80%，我们就认为找到了目标。</p>
<h2 data-id="heading-6">效果</h2>
<p>引入语义指纹后，AutoForm 的定位抗干扰能力大幅提升：</p>
<ul>
<li><strong>ID 变化</strong>：完全免疫。</li>
<li><strong>DOM 结构微调</strong>：完全免疫。</li>
<li><strong>文案微调</strong>：只要核心语义没变（如"用户名"变成"请输入用户名"），依然能识别。</li>
</ul>
<h2 data-id="heading-7">总结</h2>
<p>在 AI 时代，基于规则的硬编码（Hard-coding）已经过时了。基于特征的模糊匹配才是未来的方向。</p>
<hr/>
<p><strong>思考</strong>：如果页面上有两个完全一样的输入框（如两个"手机号"），该如何区分？欢迎评论区交流！</p>
<p>👉 <strong>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2F51bpms.com" target="_blank" title="https://51bpms.com" ref="nofollow noopener noreferrer">51bpms.com</a></strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Prompt caching 技术是如何实现 1 折的推理成本优化的？]]></title>    <link>https://juejin.cn/post/7605817795629252658</link>    <guid>https://juejin.cn/post/7605817795629252658</guid>    <pubDate>2026-02-13T05:27:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795629252658" data-draft-id="7605811866908819465" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Prompt caching 技术是如何实现 1 折的推理成本优化的？"/> <meta itemprop="keywords" content="人工智能,LLM,面试"/> <meta itemprop="datePublished" content="2026-02-13T05:27:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Baihai_IDP"/> <meta itemprop="url" content="https://juejin.cn/user/3123071228582343"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Prompt caching 技术是如何实现 1 折的推理成本优化的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3123071228582343/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Baihai_IDP
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:27:18.000Z" title="Fri Feb 13 2026 05:27:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读24分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>编者按：</strong> 你是否曾好奇过，那些声称能将长文本输入成本降低90%、延迟减少85%的"Prompt Caching"技术，背后究竟缓存了什么？是简单的文本复用，还是某种更深层的计算优化？</p>
<p>我们今天为大家带来的文章，作者的核心观点是：Prompt Caching的本质并非简单的文本字符串缓存，而是对Transformer注意力机制中Key-Value（KV）矩阵计算结果的复用，通过避免重复计算注意力权重来实现成本削减与性能提升。</p>
<p>文章的重点内容包括：第一，从Tokenizer到Embedding再到Transformer的完整技术拆解，帮助读者建立对LLM内部数据流的直觉认知；第二，对注意力机制（Attention）的数学原理进行深入浅出的阐释，详细展示了Query、Key、Value矩阵的计算过程以及Softmax权重分配机制；第三，揭示了"KV Caching"的核心实现逻辑 —— 通过缓存历史token的K、V投影矩阵，使模型在增量生成时只需计算最新token，而非重新处理整个上下文；第四，对OpenAI与Anthropic两种缓存策略的对比分析，指出自动路由与显式控制之间的权衡，以及Temperature等采样参数对缓存机制的零影响。</p>
</blockquote>
<p><strong>作者 | Sam Rose</strong></p>
<p><strong>编译 | 岳扬</strong></p>
<p>撰写本文时，OpenAI 和 Anthropic 的 API 中，缓存的 input token 单价仅为普通 input token 的十分之一。</p>
<p>Anthropic 甚至声称[1]，prompt caching 能将长 prompt 的延迟“最高降低 85%”。而在实际测试中，我发现对于足够长的 prompt，这一说法确实成立。我向 Anthropic 和 OpenAI 各发送了数百次请求，注意到在所有 input token 均被缓存的情况下，首 token 延迟（time-to-first-token latency）出现了明显下降。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2764ce95d6845ac9561176b2e45fd21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=X6TG1R9ac7VLfJuCCkCkXz7on6c%3D" alt="image.png" loading="lazy"/></p>
<p>缓存 token（cached token）到底是什么玩意儿？ </p>
<p>这背后究竟发生了什么，让服务商能给 input token 打出 1 折的超低折扣？他们在各次请求之间到底保存了什么？这可不是简单地把响应结果存下来，等收到相同 prompt 时再复用 —— 通过 API 就能很容易地验证这一点并未发生。<strong>随便写个 prompt，连续发送十几次，你会发现即使使用情况栏（usage 部分）显示 input token 已被缓存，每次得到的回复仍然各不相同。</strong></p>
<p>我对大模型厂商文档中的解释[2-3]并不满意 —— 它们虽能很好地说明如何使用 prompt caching，却巧妙地避开了“究竟缓存了什么”这个核心问题。于是我决定深入探究，一头扎进 LLM 工作原理的“兔子洞”，直到彻底搞明白服务商究竟缓存了哪些精确的数据、这些数据的用途，以及它们如何让每个人的 LLM 请求都变得更快速、更便宜。</p>
<p>读完本文，你将……</p>
<ul>
<li>在更深层次上理解 LLM 的工作原理</li>
<li>对“LLM 的运作方式”建立新的直觉认知</li>
<li>弄明白究竟哪些二进制数据被缓存了，以及它们如何降低你的 LLM 请求成本</li>
</ul>
<h2 data-id="heading-0"><strong>01 LLM 架构</strong></h2>
<p>本质上，LLM 就是一个巨大的数学函数：输入一串数字，并输出一个数字。在 LLM 内部，存在着一个由数十亿个精心设计的运算构成的巨型图结构，负责将这些输入数字转化为输出数字。</p>
<p>这个由海量数学运算构成的巨型图结构大致可分为 4 个部分。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e23abc23589f4d2d85e4fc84f523cd75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=4N5FySyn4F3NdZPwakxjBlOKtc8%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图中的每个节点都可以看作一个函数，接收输入并产生输出。输入会以循环方式不断馈入 LLM，直到遇到某个特殊的输出值指示其停止。</strong> 用伪代码表示大致如下：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">prompt</span> =<span class="hljs-string">"What is the meaning of life?"</span><span class="hljs-comment">;</span>

<span class="hljs-attr">tokens</span> = tokenizer(prompt)<span class="hljs-comment">;</span>
while(true){
 <span class="hljs-attr">embeddings</span> = embed(tokens)<span class="hljs-comment">;</span>
for(<span class="hljs-section">[attention, feedforward]</span> of transformers){
 <span class="hljs-attr">embeddings</span> = attention(embeddings)<span class="hljs-comment">;</span>
 <span class="hljs-attr">embeddings</span> = feedforward(embeddings)<span class="hljs-comment">;</span>
}
 <span class="hljs-attr">output_token</span> = output(embeddings)<span class="hljs-comment">;</span>
if(<span class="hljs-attr">output_token</span> === END_TOKEN){
break<span class="hljs-comment">;</span>
}
 tokens.push(output_token)<span class="hljs-comment">;</span>
}

print(decode(tokens))<span class="hljs-comment">;</span>
</code></pre>
<p>尽管以上描述已大幅简化，但现代 LLM 的核心代码行数之少仍让我感到意外。</p>
<p>Sebastian Raschka[4] 用 PyTorch 从零实现了多个开源模型，还产出了大量高质量的教学材料 —— 如果你喜欢本文，大概率也会喜欢他的内容。以当前领先的开源模型之一 Olmo 3 为例，其核心代码仅数百行[5]。</p>
<p>Prompt caching 发生在 Transformer 的“attention（注意力机制）”中。接下来我们将按顺序逐步拆解 LLM 的工作原理，直到抵达这一环节。这意味着，我们的旅程得从 tokens 说起。</p>
<h2 data-id="heading-1"><strong>02 Tokenizer（分词器）</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba85563fcf4c4406a7a511e49c71cb20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=h0BtIta1GQt2UOqqDb3rzws01Ks%3D" alt="image.png" loading="lazy"/></p>
<p>在 LLM 处理你的 prompt（提示词）之前，必须先将其转换为它能理解的表示形式。这个过程分为两步，由 tokenizer 和 embedding 共同完成。为什么要这么做，要到讲 embedding 时才能完全明晰，现在请先耐心了解 tokenizer 的作用。</p>
<p>Tokenizer 会将你的 prompt 拆成多个小片段，并为每个唯一的片段分配一个整数 ID，称为"token"。例如，GPT-5 对 prompt "Check out ngrok.ai" 的分词结果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b0b2175da11a47a6bf8e9c33b4f76f1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=9JcvcEfOFkw6qOgbmkg0lWuIiTc%3D" alt="image.png" loading="lazy"/></p>
<p>该 prompt 已被拆分为数组 [“Check”, " out", " ng", “rok”, “.ai”]，并转换为 tokens [4383, 842, 1657, 17690, 75584]。相同的 prompt 始终生成相同的 tokens。tokens 也是区分大小写的 —— 因为大小写能传递语义信息。例如，首字母大写的 "Will" 更可能是人名，而小写的 "will" 则更可能是助动词。</p>
<p>为什么不直接按空格或字符分割？</p>
<p>这其实是个相当深刻的问题，细讲起来足以让本文篇幅翻倍。简短而不尽兴的答案是：这是一种权衡。若想深入理解，Andrej Karpathy 有一期从零实现 tokenizer 的精彩视频（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DzduSFxRajkE%25EF%25BC%2589" target="_blank" title="https://www.youtube.com/watch?v=zduSFxRajkE%EF%BC%89" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=zdu…</a> 。<strong>对于 prompt caching 而言，只需知道：tokenization 的作用就是把文本变成数字。</strong></p>
<p>Tokens 是 LLM 输入与输出的基本单位。当你向 ChatGPT 提问时，回复会随着每次 LLM 迭代完成而逐个 token 流式返回。服务商这么做，是因为生成完整回复可能需要数十秒，而一旦 token 生成就立即返回，能让交互体验更流畅自然。</p>
<p>我们来问一个 LLM 领域的经典问题，亲眼看看这个过程：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f623bb995c1a49c6b48737c31c789714~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=hO24WCOIn3KcV0ODEkx2P9HJAgU%3D" alt="image.png" loading="lazy"/></p>
<p>Prompt tokens 输入，✨ AI 魔法发生 ✨，输出一个 token，循环往复。这个过程称为“inference（推理）”。注意：每个输出 token 都会在下一轮迭代前被追加到 input prompt 中。LLM 需要全部上下文才能给出高质量回答 —— 如果只输入原始 prompt，它会反复尝试生成答案的第一个 token。如果只输入已生成的回答部分，它会立刻忘记问题本身。因此，每一轮迭代都必须将完整的 prompt 加上已生成的回答内容重新输入 LLM。</p>
<p><strong>那个 199999  token 是什么？</strong></p>
<p>这个推理过程总得有个终点。<strong>LLM 拥有多种“特殊”token，其中之一就是标志着响应结束的 token。</strong> 在 GPT-5 的分词器中，这就是 token 199999。这只是 LLM 终止生成过程的多种方式之一：<strong>你也可以通过 API 指定最大生成 token 数，服务商还可能基于安全策略设定其他终止规则。</strong></p>
<p>此外还有用于标记对话消息起止的特殊 token —— 正是这些 token 让 ChatGPT、Claude 等聊天模型能分辨一条消息何时结束、下一条何时开始。</p>
<p>关于 tokenizer（分词器）的最后一点：它们种类繁多！ChatGPT 使用的 tokenizer 与 Claude 不同，甚至 OpenAI 自家的不同模型也使用不同的 tokenizer。每种 tokenizer 都有自己独特的文本切分规则。如果你想直观比较不同 tokenizer 的分词效果，可以试试 tiktokenizer[6]。</p>
<p>认识了 tokens 之后，接下来我们聊聊 embeddings。</p>
<h2 data-id="heading-2"><strong>03 Embedding</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/52de7bad6c8b4ede900ea19a292df5fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=nM75RjxsYx20JVfxRP8vm3nARhM%3D" alt="image.png" loading="lazy"/></p>
<p>经过 tokenizer 处理后的 tokens，现在进入 embedding 阶段。要理解 embedding，不妨先思考模型的目标是什么。</p>
<p>人类用代码解决问题时，会编写接收输入、产生输出的函数，比如华氏转摄氏：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">fahrenheitToCelsius</span>(fahrenheit){
<span class="hljs-built_in">return</span>((fahrenheit -<span class="hljs-number">32</span>)*<span class="hljs-number">5</span>)/<span class="hljs-number">9</span>;
}
</code></pre>
<p>我们可以把任意数字传入 fahrenheitToCelsius，并能获得正确结果。但假如我们面对一个问题，却不知道背后的公式呢？假如我们只有下面这张神秘的输入-输出对照表：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f04832306da4348b9736a7d55fd8eaa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=%2BdTHSm5VPy%2F7SzIMrZ%2BVLKq8PMs%3D" alt="图片" loading="lazy"/></p>
<p>（我并不指望你能认出这个函数 —— 不过，如果你把截图贴进 ChatGPT，它能立刻识别出来。）</p>
<p>当我们知道每个输入对应的正确输出，却不知道产生这种对应关系的函数时，就可以“训练”一个模型来学习这个函数。做法是：给模型提供一块“画布” —— 那个由海量数学运算构成的巨型图结构，然后不断调整这个图结构，直到模型收敛到正确的函数。每次更新图结构后，我们都将输入数据喂进去，观察输出数据与目标的差距。反复迭代，直到结果足够接近目标。这就是训练的本质。</p>
<p>事实证明，在训练文本生成模型时，能够识别两个句子是否“相似”会很有帮助。但“相似”具体指什么？它们可能同样悲伤、幽默或发人深省；也可能在长度、节奏、语气、语言、词汇或结构上相近。描述句子相似性的方式有无数维度，而两个句子可能在某些维度上相似，在另一些维度上则不然。</p>
<p><strong>Tokens 本身只是简单的整数编号，没有任何“维度”信息；而 embeddings 则是高维向量，承载了丰富的语义和结构信息。</strong></p>
<p>Embedding 是一个长度为 n 的数组，代表 n 维空间中的一个位置。如果 n=3，embedding 可能是 [10, 4, 2]，表示三维空间中 x=10、y=4、z=2 的坐标点。在 LLM 训练过程中，每个 token 会被随机分配一个起始位置，随后训练过程会不断微调所有 token 的位置，直到找到能产生最佳输出的排列方式。</p>
<p>Embedding 阶段的第一步，就是查表获取每个 token 对应的 embedding。用伪代码表示大概是这样：</p>
<pre><code class="hljs language-ini" lang="ini">// Created during training, never changes during inference.
const <span class="hljs-attr">EMBEDDINGS</span> = [...]<span class="hljs-comment">;</span>
 
function embed(tokens) {
 return tokens.map(<span class="hljs-attr">token</span> =&gt; {
 return EMBEDDINGS<span class="hljs-section">[token]</span><span class="hljs-comment">;</span>
 })<span class="hljs-comment">;</span>
}
</code></pre>
<p>于是，我们把 tokens（整数数组）转换成了 embeddings（数组的数组，即“矩阵”）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3fe6b77a8a34f88bde24bde2b8c361e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=M0OPQI8Nqk8TpPSy4sxYCCTP58w%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7e95661b89e643028dda2e13a0f08ecf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=oWqWH8AKM%2BoqjMNpHxWeJ0LDeos%3D" alt="image.png" loading="lazy"/></p>
<p>tokens [75, 305, 284, 887] 被转换为一个由 3 维 embeddings 构成的矩阵。</p>
<p><strong>Embedding 的维度越多，模型可用于比较句子的“角度”就越多。</strong> 我们刚才一直在用 3 维 embeddings 举例，但当前主流模型的 embedding 维度通常是几千维，最大的甚至超过 10,000 维。</p>
<p>为了说明更高维度的价值，下面我展示了 8 组彩色形状，它们最初位于一维空间中 —— 挤在一条直线上，杂乱无章，难以理解。但随着维度增加，你就能清楚地看到存在 8 个不同的、相关的组别。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23e158d605cc453080698f9eb2abe70c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=U9%2BjWt9inP2iu%2BMpxux2JFTussc%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f94e90f2dd0045ac8069a2a7f634e58d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=rH0QWYRyOYNU8E4ALhOZKTeB9aY%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed7faaf0c6e14d329251ca65e250872a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=YALz8yr0sbw4dr7E7gOxDr3VJws%3D" alt="image.png" loading="lazy"/></p>
<p>三维是我这里能提供的视觉示例的极限，至于几千维的空间能表达什么，就得靠你发挥想象力了。</p>
<p>Embedding 阶段还有最后一件事要做。<strong>在获取 token 的 embedding 后，会将该 token 在 prompt 中的位置信息编码进 embedding 中。</strong> 我没有深入研究这一机制的具体实现方式，只知道它对 prompt caching 的工作方式影响不大，但如果没有这一步，LLM 就无法判断 prompt 中 tokens 的先后顺序。</p>
<p>更新一下前面的伪代码，假设存在一个叫 encodePosition 的函数，它接收 embeddings 和位置信息，并返回嵌入了位置编码的新 embeddings。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">EMBEDDINGS</span> =[...];
 
<span class="hljs-comment">// Input: array of tokens (integers)</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">embed</span>(<span class="hljs-params">tokens</span>){
<span class="hljs-comment">// Output: array of n-dimensional embedding arrays</span>
<span class="hljs-keyword">return</span> tokens.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">token, i</span>)=&gt;</span>{
 <span class="hljs-keyword">const</span> embeddings = <span class="hljs-variable constant_">EMBEDDINGS</span>[token];
<span class="hljs-keyword">return</span> <span class="hljs-title function_">encodePosition</span>(embeddings, i);
});
}
</code></pre>
<p>总而言之，embeddings 是 n 维空间中的点，你可以将其视为它们所代表文本的语义含义。<strong>在训练过程中，每个 token 都会在该空间中移动，靠近其他语义相似的 token。维度越多，LLM 对每个 token 的表示就越复杂、越细腻。</strong></p>
<p>至此，tokenizer 和 embedding 阶段所做的全部工作，都是为了把原始文本转换成 LLM 能处理的形式。接下来，我们来看看这些数据进入 transformer 阶段后会发生什么。</p>
<h2 data-id="heading-3"><strong>04 Transformer</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/953ad94df0c840f5a6566dcedae4f404~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=aH2M8hxE6kLJrKQiRYJTe719DcU%3D" alt="image.png" loading="lazy"/></p>
<p>Transformer 阶段的核心任务，就是接收 embeddings 作为输入，并在 n 维空间中对它们进行调整。它通过两种方式实现这一点，而我们只关注第一种：attention（注意力机制）。我们暂不讨论 “Feedforward” 层或输出阶段（至少在这篇文章中👀）。</p>
<p><strong>Attention 机制的作用，是帮助 LLM 理解 prompt 中各个 token 之间的关系 —— 具体做法是让每个 token 能够影响其他 token 在 n 维空间中的位置。</strong> 它通过加权组合 prompt 中所有 token 的 embeddings 来实现这一点。输入是整个 prompt 的 embeddings，输出则是一个新的 embedding，它是所有输入 embeddings 的加权组合。</p>
<p>举个例子，如果 prompt 是 “Mary had a little”，被分词为四个 token：Mary、had、a、little，那么 attention 机制可能会决定，在生成下一个 token 时，模型会认为：</p>
<ul>
<li>“Mary” 最重要（63%）（译者注：因为整个句子的主语是 Mary，后续内容很可能围绕她展开）</li>
<li>“had” 和 “a” 次之（16% 和 12%）（译者注：它们是语法结构的一部分，但语义信息较弱）</li>
<li>“little” 也有一定作用（9%）（译者注：它修饰后面的名词）</li>
</ul>
<p>然后，它会把所有 token 的 embeddings 分别乘以对应的权重，然后把结果加在一起，得到一个融合后的向量。这正是 LLM 判断“在当前上下文中，每个 token 应该被关注多少”的方式。</p>
<p>这是目前为止整个流程中最复杂、最抽象的部分。我会先用伪代码展示它，然后再看看 embeddings 在经过这一过程时是如何被变换的。我本想让这一部分的数学内容少一些，但这里很难避免一些数学运算。别担心，你能行的，我相信你。</p>
<p>Attention 中的大部分计算都是矩阵乘法。对于本文而言，你只需知道：输出矩阵的形状由两个输入矩阵的形状决定，输出的行数等于第一个输入矩阵的行数，列数等于第二个输入矩阵的列数。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dcfe0f6e2a924a2b8735ca4334166f00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=mGBYYF0i2S8z2r3WszZkbJ7ivGA%3D" alt="image.png" loading="lazy"/></p>
<p>理解了这一点，我们来看一个简化版的注意力机制如何计算分配给每个 token 的权重。在以下代码中，我用 * 表示矩阵乘法。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// Similar to EMBEDDINGS from the pseudocode</span>
<span class="hljs-comment">// earlier, WQ and WK are learned during </span>
<span class="hljs-comment">// training and do not change during inference.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// These are both n*n matrices, where n is the</span>
<span class="hljs-comment">// number of embedding dimensions. In our example</span>
<span class="hljs-comment">// above, n =3.</span>
const WQ =<span class="hljs-selector-attr">[[...]</span>,<span class="hljs-selector-attr">[...]</span>,<span class="hljs-selector-attr">[...]</span>];
const WK =<span class="hljs-selector-attr">[[...]</span>,<span class="hljs-selector-attr">[...]</span>,<span class="hljs-selector-attr">[...]</span>];

<span class="hljs-comment">// The input embeddings look like this:</span>
<span class="hljs-comment">//[</span>
<span class="hljs-comment">//[-0.1,0.1,-0.3],// Mary</span>
<span class="hljs-comment">//[1.0,-0.5,-0.6],// had</span>
<span class="hljs-comment">//[0.0,0.8,0.6],// a</span>
<span class="hljs-comment">//[0.5,-0.7,1.0]// little</span>
<span class="hljs-comment">//]</span>
function <span class="hljs-built_in">attentionWeights</span>(embeddings){
 const <span class="hljs-selector-tag">Q</span> = embeddings * WQ;
 const K = embeddings * WK;
 const scores = <span class="hljs-selector-tag">Q</span> * <span class="hljs-built_in">transpose</span>(K);
 const masked = <span class="hljs-attribute">mask</span>(scores);
return <span class="hljs-built_in">softmax</span>(masked);
}
</code></pre>
<p>接下来，让我们看看 embedding 在流经这个函数时是如何变化的。</p>
<p>等等，WQ 和 WK 变量到底是什么？</p>
<p>还记得我之前说过，每个 token 的 embedding 最初都被随机分配了一个位置，然后在训练过程中不断微调，直到模型找到一个良好的排列状态吗？</p>
<p>WQ 和 WK 也是类似的。它们是 n×n 的矩阵（n 即 embedding 维度），在训练开始时被赋予随机值，随后也在训练中被不断调整，以帮助模型收敛到一个更优的解。</p>
<p>任何在训练过程中被调整的数，都被称为“模型参数”。embedding 向量中的每个浮点数，以及 WQ、WK 矩阵中的每个数值，都是一个参数。当你听说某个模型有“1750 亿参数”时，指的就是这些数字。</p>
<p><strong>至于 WQ 和 WK 到底代表什么，我们其实并不完全清楚。随着模型训练收敛，它们最终会变成某种对 embedding 的变换方式，有助于模型生成更好的输出。</strong> 它们内部可能在做任何事情 —— 而如何解释这些矩阵的含义，目前仍是一个开放且活跃的研究方向。</p>
<p>要得到 Q 和 K，我们分别将 embeddings 与 WQ 和 WK 相乘。WQ 和 WK 的行数和列数始终等于 embedding 的维度（本例中为 3）。这里我为 WQ 和 WK 选取了随机值，并将结果四舍五入到小数点后两位以便阅读。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e159dbbf21a43e493f9ea943ea4b1c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=J8NZQfamfiu5kRPor3%2Bfi4SV9Eg%3D" alt="image.png" loading="lazy"/></p>
<p>得到的 Q 矩阵有 4 行 3 列。4 行是因为 embeddings 矩阵有 4 行（每个 token 一行），3 列是因为 WQ 有 3 列（每个 embedding 维度一列）。</p>
<p>K 的计算完全相同，只是将 WQ 换成 WK。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9175435a3134dd3ad535e8f2d17c353~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=%2B1QGrgQoo6JY1Fyc04q4Drb90r8%3D" alt="image.png" loading="lazy"/></p>
<p>Q 和 K 都是输入 embedding 到新的 n 维空间的"投影"。它们不是原始的 embedding，但由原始 embeddings 推导而来。</p>
<p>然后，我们将 Q 和 K 相乘。我们对 K 进行“转置”，也就是沿对角线翻转，使得得到的矩阵是一个方阵，其行数和列数都等于输入提示词中的 token 数量。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f16cbd2a6a194a50893b8a520f633862~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=psRQUMRukT1tbagekOepQNBsXmY%3D" alt="image.png" loading="lazy"/></p>
<p><strong>这些 scores 表示每个 token 对下一个生成 token 的重要程度。</strong> 左上角的数值 -0.08，代表 “Mary” 对 “had” 的重要性。再往下一行的 -0.10，则代表 “Mary” 对 “a” 的重要性。在展示完矩阵运算后，我会用图示更直观地说明这一点。接下来的所有操作，都是为了将这些 scores 转换为可用于混合 embeddings 的权重。</p>
<p>这个 score 矩阵的第一个问题是：它允许未来的 token 影响过去的 token。在第一行，我们唯一知道的词是"Mary"，所以它应该是唯一对生成"had"有贡献的词。第二行也是如此，我们知道"Mary"和"had"，所以只有这两个词应该对生成"a"有贡献，依此类推。</p>
<p>为了解决这个问题，我们对矩阵应用一个三角形掩码（triangular mask），将未来 token 对应的位置置零。不过，我们并不是真的设为 0，而是设为负无穷（negative infinity） —— 原因稍后解释。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1d01707f9c044bfad12682ae035fe81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=wkeNlMCQHEINeDc1SyHYhjM3C3Y%3D" alt="image.png" loading="lazy"/></p>
<p>第二个问题是，这些 scores 是任意的数值。如果它们能变成一个每行之和等于 1 的概率分布，对我们来说会更有用。这正是 softmax 函数的作用。softmax 具体如何运作的细节并不重要 —— 它比简单的“将每个数字除以该行总和”稍复杂一点，但结果是一样的：每行之和为 1，且每个数字都在 0 和 1 之间。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3277ecdbcf314dd6b331c68e31beaace~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=HB9xKE8kTusGY5oYNBPk92E%2BmoA%3D" alt="image.png" loading="lazy"/></p>
<p>为了解释为什么用负无穷，下面是一个 softmax 的代码实现：</p>
<pre><code class="hljs language-ini" lang="ini">function softmax(matrix){
return matrix.map(<span class="hljs-attr">row</span> =&gt;{
 const <span class="hljs-attr">exps</span> = row.map(x =&gt; Math.exp(x))<span class="hljs-comment">;</span>
 const <span class="hljs-attr">sumExps</span> = exps.reduce((a, b)=&gt; a + b,<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
return exps.map(<span class="hljs-attr">exp</span> =&gt; exp / sumExps)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
}
</code></pre>
<p>它并不是简单地把每个数加起来再除以总和，而是先对每个数值取 Math.exp，也就是计算 e^x。如果我们用 0 代替负无穷，Math.exp(0) === 1，这些被屏蔽的位置仍然会产生非零权重。而 Math.exp(-Infinity) 是 0，这正是我们想要的。</p>
<p>下面的图片展示了提示词"Mary had a little"的 attention 权重示例。</p>
<p>这些权重与上面的计算结果不匹配，因为我是从 Transformer Explained 网站[7]上运行的 GPT-2 模型中提取的。所以这些是一个真实模型（尽管是老模型）的真实权重。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97f4cdd50c414f2eb49315e76fba2187~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=x6%2Bbv%2FGgwA5sYI5WBpjEwVxJ2Rk%3D" alt="image.png" loading="lazy"/></p>
<p>第一行只有"Mary"，因此Mary对"had"的生成的贡献是100%。然后在第二行，"Mary"贡献了79%，而"had"贡献了21%用于生成"a"，以此类推。LLM 认为这个句子中最重要的词是 “Mary”，这一点并不意外——从每一行中 “Mary” 都拥有最高权重就能看出。如果我让你补全"Jessica had a little"这个句子，你不太可能选择"lamb"。</p>
<p>接下来就只剩下对 token embeddings 进行加权混合了，谢天谢地，这一步比计算权重要简单得多。</p>
<pre><code class="hljs language-vbnet" lang="vbnet">// Learned during training, doesn<span class="hljs-comment">'t change </span>
// during inference. This <span class="hljs-built_in">is</span> also an n*n matrix,
// <span class="hljs-keyword">where</span> n <span class="hljs-built_in">is</span> the number <span class="hljs-keyword">of</span> embedding dimensions.
<span class="hljs-keyword">const</span> WV =[[...],[...],...];
 
<span class="hljs-keyword">function</span> attention(embeddings){
 <span class="hljs-keyword">const</span> V = embeddings * WV;
// This <span class="hljs-built_in">is</span> the `attentionWeights` <span class="hljs-keyword">function</span> <span class="hljs-keyword">from</span>
// the section above. We<span class="hljs-comment">'re wrapping it in</span>
// this `attention` <span class="hljs-keyword">function</span>.
 <span class="hljs-keyword">const</span> weights = attentionWeights(embeddings);
<span class="hljs-keyword">return</span> weights * V;
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3be2d52478db48c3ad24342c21415e47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=2yUvvRSL5re74%2BV7fY2%2FMODfYwA%3D" alt="image.png" loading="lazy"/></p>
<p>为什么不直接混合原始 embeddings？</p>
<p>当我们通过 Q 和 K 相乘得到 attention 权重时，我们完全是在衡量 token 之间的相关性。Embeddings 编码了 token 的各种语义信息 —— 某一维可能表示“颜色”，另一维表示“大小”，再一维表示“礼貌/粗鲁程度”，等等。而权重是通过相似度来判断哪些 token 更相关。</p>
<p>WV 的作用，则是让模型决定在混合时保留哪些维度的信息。</p>
<p>以句子 “Mary had a little” 为例，这里关于 “Mary” 最重要的信息是“人名”。模型在训练中可能也学到了很多关于 “Bloody Mary（血腥玛丽鸡尾酒）” 或 “Mary Queen of Scots（苏格兰女王玛丽）” 的知识，但这些与这首童谣无关，如果带入后续计算反而会引入噪声。因此，WV 允许模型在混合 embeddings 之前，先过滤掉不相关的特征。</p>
<p>接着，我们将生成的权重与 V 相乘，输出一组新的 embeddings：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33fb977942b747efab4bd5d4a1c10f14~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=pS9CPjaJIGNm7kDP2Pb4drNJ%2F00%3D" alt="image.png" loading="lazy"/></p>
<p><strong>Attention 机制的最终输出，就是这个输出矩阵的最后一行。</strong> 通过 attention 过程，前面所有 token 的上下文信息都被融合进了这一行。但要注意：为了得到最后一行，前面所有行都必须被计算出来。</p>
<p>总而言之，输入是一组 embeddings，输出是一个新的 embedding。Attention 机制通过大量精细的数学运算，按照训练中学到的 WQ、WK 和 WV 矩阵所决定的重要性比例，将各个 token 的信息进行了加权融合。正是这一机制，让 LLM 能够理解在其上下文窗口中“什么内容重要，以及为什么重要”。</p>
<p>现在，我们终于掌握了讨论 caching 所需的一切知识。</p>
<p>当然，Attention 还有更多技术细节</p>
<p>我在本文展示的是一个简化版的 attention，目的是突出与 prompt caching 最相关的核心部分。实际中的 attention 机制更为复杂。如果你希望深入了解更多技术细节，我推荐 3blue1brown 关于 attention 的视频[8]。</p>
<h2 data-id="heading-4"><strong>05 Prompt caching</strong></h2>
<p>我们再来看一遍上面的网格，但这次会展示在推理循环中每生成一个新 token 时，它是如何逐步填充的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd098773c4594486abaaf3d19da88503~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=6Xnizr8khWVeWGjfnV00BU1s758%3D" alt="image.png" loading="lazy"/></p>
<p>每次生成新 token 时，都会将其追加到输入中，并重新完整处理整个 prompt。但仔细观察：之前计算出的权重从未改变。第二行始终是 0.79 和 0.21，第三行始终是 0.81、0.13、0.06。我们其实在不断重复大量不必要的计算。如果你刚刚才处理完 “Mary had a”，那么在生成下一个 token 时，对 “Mary had a little” 中前三个 token 的大部分矩阵运算其实是冗余的 —— 而这正是 LLM 推理循环的默认行为。</p>
<p>通过以下两个改动，就能避免这些重复计算：</p>
<ul>
<li><strong>在每次迭代中缓存 K 和 V 矩阵。</strong></li>
<li><strong>只将最新 token 的 embeddings 输入模型，而不是整个 prompt。</strong></li>
</ul>
<p>现在我们再次走一遍矩阵运算过程，但这一次：前 4 个 token 的 K 和 V 矩阵已被缓存，我们只传入一个新 token 的 embeddings。</p>
<p>是的，又要面对矩阵运算了，抱歉！不过内容和之前基本一致，我们会快速过一遍。</p>
<p>计算新的 Q 时，输出只有一行。WQ 和之前一样，没有变化。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/534869cbd4814219923cc9154703a6ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=yD%2FZ1XvqmZFawz%2FnANDnmqKyrxQ%3D" alt="image.png" loading="lazy"/></p>
<p>接着，计算新的 K 也同样只输出一行，而 WK 也和之前一样保持不变。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b2e3118920486495c4b0bd227b946e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=rnR12gAjn75v2iHrtxQpW2RYDPE%3D" alt="image.png" loading="lazy"/></p>
<p>但随后我们将这一新行追加到前一次迭代缓存的 4 行 K 矩阵之后：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95e7ec0e039e434fa75df74e6904d7cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=N%2B%2FjErKQgdBZNc809KbjSJDZ0wI%3D" alt="image.png" loading="lazy"/></p>
<p>于是现在我们拥有了提示词中所有 token 的 K 矩阵，但我们只需要计算它的最后一行。</p>
<p>我们继续以这种方式来获取新的 score：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cee05647e3c4fc8a4750770e2ea0fe1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=ycfCSP99sq2Sx3IDun%2FeiB8DeUU%3D" alt="image.png" loading="lazy"/></p>
<p>以及新的的 weights：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6633a0b02c5441d39dfe5f0ecf6169f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=uuBcj%2FAsiYDVlAzGjPWUtDmNDt0%3D" alt="image.png" loading="lazy"/></p>
<p>全程我们只计算必需的部分，完全不需要对旧值进行任何重新计算。获取 V 的新一行时也是同样的做法：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/502a7fd0566f417c800bbfd161d43fb6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=1vh%2BWgC6qYbc5z9SwbJWRCWe13s%3D" alt="image.png" loading="lazy"/></p>
<p>然后将其追加到我们缓存的 V 中：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f94842f7ce014c74a28953735532c2cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=lMmh5Eso7c2PCvVC2igKDhSb4YY%3D" alt="image.png" loading="lazy"/></p>
<p>最后，我们将新的权重与新的 V 相乘，得到最终的新 embeddings：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adf75bd238f5464a848ba387b856bf5e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=%2BwGCAkxH2%2B14Ww%2BgefkR1I4a%2FYk%3D" alt="image.png" loading="lazy"/></p>
<p>我们只需要这单独一行新的 embedding。得益于缓存的 K 和 V，先前所有 token 的上下文信息都已被融入其中。</p>
<p><strong>被缓存的数据是 embeddings * WK 和 embeddings * WV 的结果，也就是 K 和 V。</strong> 因此，提示词缓存通常被称为"KV caching"。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/411d6b1a3a20496bba649b733f64d87a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=hSH8tERZlEuqQqKjlZpj4X8acnE%3D" alt="image.png" loading="lazy"/></p>
<p>就是这样，上面那些 K 和 V 矩阵，就是服务提供商保存在他们巨大数据中心里的 1 和 0，用来给我们提供一折的 token 成本和更快的响应。</p>
<p>服务提供商在请求发出后，会将每个提示词的这些矩阵保留 5-10 分钟，如果你发送一个以相同提示词开头的新请求，他们就会复用缓存的 K 和 V，而不是重新计算它们。<strong>缓存匹配不需要完全一致 —— 即使新 prompt 只和缓存中的某一部分开头相同，也可以复用那部分已缓存的计算结果，而不必整个 prompt 完全匹配。</strong></p>
<p>OpenAI 和 Anthropic 的缓存机制截然不同。<strong>OpenAI 完全自动处理，会尽可能尝试将请求路由到缓存条目。</strong> 在我的实验中，通过发送请求然后立即重发，缓存命中率约为 50%。考虑到长上下文窗口的首字节延迟（time-to-first-byte）可能很长，这种自动缓存可能导致性能表现不稳定。</p>
<p><strong>Anthropic 则赋予你更多控制权，让你决定何时缓存以及缓存多久。</strong> 你需要为这项特权付费，但在我进行的实验中，当我们要求 Anthropic 缓存某个提示词时，他们会 100% 地将请求路由到缓存条目。因此，如果你的应用涉及长上下文窗口，并且需要可预测的延迟，Anthropic 可能是更合适的选择。</p>
<p>等等，那 temperature 这些参数会影响提示词缓存吗？</p>
<p>LLM 提供商提供了多种参数来控制模型输出的随机性，常见的有 temperature、top_p 和 top_k。这些参数都作用于推理循环的最后一步，即模型根据它为词表中每个 token 分配的概率来选取 token。这发生在 attention 机制产生最终 embedding 之后，因此提示词缓存不受这些参数影响。你可以随意调整它们，而不用担心导致缓存的提示词失效。</p>
<h2 data-id="heading-5"><strong>致谢</strong></h2>
<p>为了学习撰写本文所需的全部知识，我如饥似渴地阅读了大量优质内容，以下是我认为对我最有帮助的：</p>
<ul>
<li>Build a Large Language Model (From Scratch)[9] by Sebastian Raschka[10].</li>
<li>Neural Networks: Zero to Hero[11] by Andrej Karpathy[12].</li>
<li>Neural Networks video course[13] by 3blue1brown[14].</li>
<li>Transformer Explainer[15] by Aeree Cho[16] et al.</li>
</ul>
<p>如果你喜欢这篇文章，你一定会喜欢这些资源。</p>
<p><strong>END</strong></p>
<p><strong>本期互动内容 🍻</strong></p>
<p><strong>❓按照文中逻辑，缓存本质是拿内存换计算。当你处理10万Token以上的超长上下文时，有没有估算过KV Cache的内存占用成本 vs 重新计算的API成本？在什么临界点你会选择放弃缓存？</strong></p>
<p><strong>文中链接</strong></p>
<p>[1]<a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.com%2Fblog%2Fprompt-caching" target="_blank" title="https://claude.com/blog/prompt-caching" ref="nofollow noopener noreferrer">claude.com/blog/prompt…</a></p>
<p>[2]<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.claude.com%2Fen%2Fdocs%2Fbuild-with-claude%2Fprompt-caching" target="_blank" title="https://docs.claude.com/en/docs/build-with-claude/prompt-caching" ref="nofollow noopener noreferrer">docs.claude.com/en/docs/bui…</a></p>
<p>[3]<a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fguides%2Fprompt-caching" target="_blank" title="https://platform.openai.com/docs/guides/prompt-caching" ref="nofollow noopener noreferrer">platform.openai.com/docs/guides…</a></p>
<p>[4]<a href="https://link.juejin.cn?target=https%3A%2F%2Fmagazine.sebastianraschka.com%2F" target="_blank" title="https://magazine.sebastianraschka.com/" ref="nofollow noopener noreferrer">magazine.sebastianraschka.com/</a></p>
<p>[5]<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frasbt%2FLLMs-from-scratch%2Fblob%2Fmain%2Fch05%2F13_olmo3%2Fstandalone-olmo3.ipynb" target="_blank" title="https://github.com/rasbt/LLMs-from-scratch/blob/main/ch05/13_olmo3/standalone-olmo3.ipynb" ref="nofollow noopener noreferrer">github.com/rasbt/LLMs-…</a></p>
<p>[6]<a href="https://link.juejin.cn?target=https%3A%2F%2Ftiktokenizer.vercel.app%2F" target="_blank" title="https://tiktokenizer.vercel.app/" ref="nofollow noopener noreferrer">tiktokenizer.vercel.app/</a></p>
<p>[7]<a href="https://link.juejin.cn?target=https%3A%2F%2Fpoloclub.github.io%2Ftransformer-explainer%2F" target="_blank" title="https://poloclub.github.io/transformer-explainer/" ref="nofollow noopener noreferrer">poloclub.github.io/transformer…</a></p>
<p>[8]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DeMlx5fFNoYc" target="_blank" title="https://www.youtube.com/watch?v=eMlx5fFNoYc" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=eMl…</a></p>
<p>[9]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oreilly.com%2Flibrary%2Fview%2Fbuild-a-large%2F9781633437166%2F" target="_blank" title="https://www.oreilly.com/library/view/build-a-large/9781633437166/" ref="nofollow noopener noreferrer">www.oreilly.com/library/vie…</a></p>
<p>[10]<a href="https://link.juejin.cn?target=https%3A%2F%2Fsebastianraschka.com%2F" target="_blank" title="https://sebastianraschka.com/" ref="nofollow noopener noreferrer">sebastianraschka.com/</a></p>
<p>[11]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DVMj-3S1tku0%26list%3DPLAqhIrjkxbuWI23v9cThsA9GvCAUhRvKZ" target="_blank" title="https://www.youtube.com/watch?v=VMj-3S1tku0&amp;list=PLAqhIrjkxbuWI23v9cThsA9GvCAUhRvKZ" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=VMj…</a></p>
<p>[12]<a href="https://link.juejin.cn?target=https%3A%2F%2Fkarpathy.ai%2F" target="_blank" title="https://karpathy.ai/" ref="nofollow noopener noreferrer">karpathy.ai/</a></p>
<p>[13]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fplaylist%3Flist%3DPLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi" target="_blank" title="https://www.youtube.com/playlist?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi" ref="nofollow noopener noreferrer">www.youtube.com/playlist?li…</a></p>
<p>[14]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2F%403blue1brown" target="_blank" title="https://www.youtube.com/@3blue1brown" ref="nofollow noopener noreferrer">www.youtube.com/@3blue1brow…</a></p>
<p>[15]<a href="https://link.juejin.cn?target=https%3A%2F%2Fpoloclub.github.io%2Ftransformer-explainer%2F" target="_blank" title="https://poloclub.github.io/transformer-explainer/" ref="nofollow noopener noreferrer">poloclub.github.io/transformer…</a></p>
<p>[16]<a href="https://link.juejin.cn?target=https%3A%2F%2Faereeeee.github.io%2F" target="_blank" title="https://aereeeee.github.io/" ref="nofollow noopener noreferrer">aereeeee.github.io/</a></p>
<p><strong>本文经原作者授权，由</strong> <strong>Baihai IDP</strong> <strong>编译。如需转载译文，请联系获取授权。</strong></p>
<p><strong>原文链接：</strong></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fngrok.com%2Fblog%2Fprompt-caching%2F" target="_blank" title="https://ngrok.com/blog/prompt-caching/" ref="nofollow noopener noreferrer">ngrok.com/blog/prompt…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别 JSON.parse(JSON.stringify()) — 原生深拷贝 structuredClone]]></title>    <link>https://juejin.cn/post/7605810996125286434</link>    <guid>https://juejin.cn/post/7605810996125286434</guid>    <pubDate>2026-02-13T03:40:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125286434" data-draft-id="7605542907119124532" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别 JSON.parse(JSON.stringify()) — 原生深拷贝 structuredClone"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2026-02-13T03:40:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="陈广亮"/> <meta itemprop="url" content="https://juejin.cn/user/3139860937575934"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别 JSON.parse(JSON.stringify()) — 原生深拷贝 structuredClone
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860937575934/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    陈广亮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:40:38.000Z" title="Fri Feb 13 2026 03:40:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深拷贝的老办法</h2>
<p>在 JavaScript 中深拷贝一个对象，最常见的"hack"写法是：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(original));
</code></pre>
<p>这个方法简单粗暴，但有一堆坑：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
  <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/test/gi</span>,
  <span class="hljs-attr">map</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>]]),
  <span class="hljs-attr">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-attr">undef</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">"hello"</span>,
  <span class="hljs-attr">nan</span>: <span class="hljs-title class_">NaN</span>,
  <span class="hljs-attr">infinity</span>: <span class="hljs-title class_">Infinity</span>,
};

<span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy);
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   date: "2026-02-11T06:00:00.000Z",  ← 变成了字符串</span>
<span class="hljs-comment">//   regex: {},                           ← 丢失了</span>
<span class="hljs-comment">//   map: {},                             ← 丢失了</span>
<span class="hljs-comment">//   set: {},                             ← 丢失了</span>
<span class="hljs-comment">//                                        ← undefined 直接消失</span>
<span class="hljs-comment">//                                        ← 函数直接消失</span>
<span class="hljs-comment">//   nan: null,                           ← 变成了 null</span>
<span class="hljs-comment">//   infinity: null                       ← 变成了 null</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p>还有一个致命问题 —— 循环引用直接报错：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> a = { <span class="hljs-attr">name</span>: <span class="hljs-string">"a"</span> };
a.<span class="hljs-property">self</span> = a;
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a)); <span class="hljs-comment">// ❌ TypeError: Converting circular structure to JSON</span>
</code></pre>
<h2 data-id="heading-1">structuredClone 登场</h2>
<p><code>structuredClone()</code> 是浏览器和 Node.js (v17+) 提供的<strong>原生深拷贝</strong>方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> original = {
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
  <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/test/gi</span>,
  <span class="hljs-attr">map</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>]]),
  <span class="hljs-attr">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">deep</span>: { <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> } },
  <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]],
};

<span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(original);

copy.<span class="hljs-property">nested</span>.<span class="hljs-property">deep</span>.<span class="hljs-property">value</span> = <span class="hljs-number">0</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original.<span class="hljs-property">nested</span>.<span class="hljs-property">deep</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 42 ✅ 互不影响</span>

copy.<span class="hljs-property">date</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// true ✅ 类型保留</span>
copy.<span class="hljs-property">regex</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>; <span class="hljs-comment">// true ✅</span>
copy.<span class="hljs-property">map</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>; <span class="hljs-comment">// true ✅</span>
copy.<span class="hljs-property">set</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>; <span class="hljs-comment">// true ✅</span>
</code></pre>
<p>循环引用也能正确处理：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> a = { <span class="hljs-attr">name</span>: <span class="hljs-string">"a"</span> };
a.<span class="hljs-property">self</span> = a;
<span class="hljs-keyword">const</span> b = <span class="hljs-title function_">structuredClone</span>(a); <span class="hljs-comment">// ✅ 正常工作</span>
b.<span class="hljs-property">self</span> === b; <span class="hljs-comment">// true（引用指向拷贝后的自身）</span>
</code></pre>
<h2 data-id="heading-2">支持的类型</h2>
<p>structuredClone 使用的是结构化克隆算法，支持绝大多数内置类型：</p>













































<table><thead><tr><th>类型</th><th>JSON 方式</th><th>structuredClone</th></tr></thead><tbody><tr><td>Date</td><td>❌ 变字符串</td><td>✅</td></tr><tr><td>RegExp</td><td>❌ 变 <code>{}</code></td><td>✅</td></tr><tr><td>Map / Set</td><td>❌ 变 <code>{}</code></td><td>✅</td></tr><tr><td>ArrayBuffer</td><td>❌</td><td>✅</td></tr><tr><td>undefined</td><td>❌ 丢失</td><td>✅</td></tr><tr><td>NaN / Infinity</td><td>❌ 变 null</td><td>✅</td></tr><tr><td>循环引用</td><td>❌ 报错</td><td>✅</td></tr></tbody></table>
<h2 data-id="heading-3">不支持什么</h2>
<p>有几种东西是 structuredClone <strong>无法克隆</strong>的：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// ❌ 函数</span>
<span class="hljs-title function_">structuredClone</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> {} });
<span class="hljs-comment">// DOMException: () =&gt; {} could not be cloned.</span>

<span class="hljs-comment">// ❌ DOM 节点</span>
<span class="hljs-title function_">structuredClone</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);

<span class="hljs-comment">// ❌ 原型链（拷贝后丢失）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {
  <span class="hljs-title function_">bark</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-string">"woof"</span>; }
}
<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();
<span class="hljs-keyword">const</span> cloned = <span class="hljs-title function_">structuredClone</span>(dog);
cloned <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// false</span>
cloned.<span class="hljs-property">bark</span>; <span class="hljs-comment">// undefined</span>
</code></pre>
<p>所以如果你的对象包含函数或需要保留原型链，structuredClone 不适用。</p>
<h2 data-id="heading-4">一个实用技巧：transferable objects</h2>
<p>structuredClone 支持第二个参数 <code>transfer</code>，可以"移交"而不是"复制"某些对象（如 ArrayBuffer），避免内存翻倍：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 1MB</span>
<span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(buffer, { <span class="hljs-attr">transfer</span>: [buffer] });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 0 ← 原始的被清空了</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 1048576 ← 数据转移到了 copy</span>
</code></pre>
<p>这在处理大型二进制数据时非常有用。</p>
<h2 data-id="heading-5">兼容性</h2>
<ul>
<li>Chrome 98+, Firefox 94+, Safari 15.4+, Node.js 17+</li>
<li>2026 年的今天，基本可以放心使用</li>
</ul>
<h2 data-id="heading-6">总结</h2>





















<table><thead><tr><th>场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>简单对象，无特殊类型</td><td><code>JSON.parse(JSON.stringify())</code> 仍然可用</td></tr><tr><td>包含 Date/Map/Set/循环引用</td><td><code>structuredClone()</code></td></tr><tr><td>需要保留原型链/函数</td><td>手写递归或 lodash <code>_.cloneDeep()</code></td></tr></tbody></table>
<p>以后深拷贝，先想想 <code>structuredClone</code> 吧。</p>
<hr/>
<blockquote>
<p>原文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fchenguangliang.com%2Fposts%2Fjs-structured-clone%2F" target="_blank" title="https://chenguangliang.com/posts/js-structured-clone/" ref="nofollow noopener noreferrer">chenguangliang.com/posts/js-st…</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实战：将 Android 多Module应用迁移到 kmp+cmp]]></title>    <link>https://juejin.cn/post/7605907495769767945</link>    <guid>https://juejin.cn/post/7605907495769767945</guid>    <pubDate>2026-02-13T05:24:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605907495769767945" data-draft-id="7605811866908835849" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实战：将 Android 多Module应用迁移到 kmp+cmp"/> <meta itemprop="keywords" content="Kotlin,Android,iOS"/> <meta itemprop="datePublished" content="2026-02-13T05:24:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="智先森zhi"/> <meta itemprop="url" content="https://juejin.cn/user/1987506650767966"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实战：将 Android 多Module应用迁移到 kmp+cmp
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1987506650767966/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    智先森zhi
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:24:28.000Z" title="Fri Feb 13 2026 05:24:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">实战：将 Android 多模块应用迁移到 Kotlin Multiplatform + Compose Multiplatform</h2>
<p>最近把自己的 NBA 数据应用 <a href="https://juejin.cn/post/7605451617286553627" target="_blank" title="https://juejin.cn/post/7605451617286553627">HoopsNow</a> 从纯 Android 多模块架构迁移到了 KMP + CMP，实现了 Android/iOS 共享一套代码。这篇文章记录整个迁移过程中的思路、踩坑和最终方案。</p>

<h3 data-id="heading-1">项目背景</h3>
<p>HoopsNow 是一个 NBA 数据展示应用，功能包括比赛比分、球队信息、球员搜索和收藏管理。迁移前的架构参考了 Google 的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fandroid%2Fnowinandroid" target="_blank" title="https://github.com/android/nowinandroid" ref="nofollow noopener noreferrer">Now in Android</a> 项目，是一个标准的 Android 多模块架构：</p>
<pre><code class="hljs language-bash" lang="bash">hoopsnow/
├── app/                        <span class="hljs-comment"># 入口 + Navigation3</span>
├── core/                       <span class="hljs-comment"># 9 个核心模块</span>
│   ├── common/                 <span class="hljs-comment"># 工具类</span>
│   ├── data/                   <span class="hljs-comment"># Repository</span>
│   ├── database/               <span class="hljs-comment"># Room</span>
│   ├── datastore/              <span class="hljs-comment"># DataStore</span>
│   ├── designsystem/           <span class="hljs-comment"># 主题</span>
│   ├── model/                  <span class="hljs-comment"># 数据模型</span>
│   ├── network/                <span class="hljs-comment"># Ktor</span>
│   ├── testing/                <span class="hljs-comment"># 测试工具</span>
│   └── ui/                     <span class="hljs-comment"># 共享 UI</span>
├── feature/                    <span class="hljs-comment"># 4 个功能模块 (api/impl)</span>
│   ├── games/
│   ├── teams/
│   ├── players/
│   └── favorites/
└── build-logic/                <span class="hljs-comment"># 7 个 Convention Plugins</span>
</code></pre>
<p>技术栈：<strong>Hilt</strong> + <strong>Navigation3</strong> + <strong>Room</strong> + <strong>ViewModel</strong> + <strong>Coil</strong></p>
<p>这套架构在纯 Android 场景下很好用，模块边界清晰，构建并行度高。但当我想把应用扩展到 iOS 时，这些 Android 专属的库就成了障碍。</p>
<h3 data-id="heading-2">为什么选择 KMP + CMP</h3>
<p>考虑过几个方案：</p>






























<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Flutter</td><td>生态成熟，热重载</td><td>需要重写全部代码，Dart 语言</td></tr><tr><td>React Native</td><td>Web 开发者友好</td><td>性能开销，桥接复杂</td></tr><tr><td>KMP + 原生 UI</td><td>共享逻辑，原生体验</td><td>需要写两套 UI</td></tr><tr><td>KMP + CMP</td><td>共享逻辑 + UI，Kotlin 全栈</td><td>CMP iOS 端相对年轻</td></tr></tbody></table>
<p>最终选了 KMP + CMP，原因很简单：现有代码是 Kotlin + Compose，迁移成本最低，UI 也能共享。</p>
<h3 data-id="heading-3">技术栈替换</h3>
<p>迁移的核心就是把 Android 专属库替换为 KMP 兼容的���：</p>





















































<table><thead><tr><th>功能</th><th>迁移前</th><th>迁移后</th><th>迁移难度</th></tr></thead><tbody><tr><td>依赖注入</td><td>Hilt</td><td><strong>Koin 4.0</strong></td><td>⭐⭐</td></tr><tr><td>导航</td><td>Navigation3</td><td><strong>Voyager 1.1.0-beta03</strong></td><td>⭐⭐⭐</td></tr><tr><td>数据库</td><td>Room</td><td><strong>SQLDelight 2.0</strong></td><td>⭐⭐⭐</td></tr><tr><td>状态管理</td><td>ViewModel</td><td><strong>Voyager ScreenModel</strong></td><td>⭐</td></tr><tr><td>图片加载</td><td>Coil</td><td><strong>Coil 3 (KMP)</strong></td><td>⭐</td></tr><tr><td>网络</td><td>Ktor (Android)</td><td><strong>Ktor 3.0 (KMP)</strong></td><td>⭐</td></tr><tr><td>UI</td><td>Jetpack Compose</td><td><strong>Compose Multiplatform 1.7</strong></td><td>⭐</td></tr></tbody></table>
<p>下面逐个说说迁移细节。</p>
<h3 data-id="heading-4">一、创建 shared 模块</h3>
<p>第一步是创建 KMP 共享模块。<code>shared/build.gradle.kts</code> 的核心配置：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">plugins {
    alias(libs.plugins.kotlin.multiplatform)
    alias(libs.plugins.android.library)
    alias(libs.plugins.kotlin.compose)
    alias(libs.plugins.compose.multiplatform)
    alias(libs.plugins.kotlin.serialization)
    alias(libs.plugins.sqldelight)
}

kotlin {
    androidTarget {
        compilerOptions { jvmTarget.<span class="hljs-keyword">set</span>(JvmTarget.JVM_17) }
    }

    listOf(iosX64(), iosArm64(), iosSimulatorArm64()).forEach {
        it.binaries.framework {
            baseName = <span class="hljs-string">"Shared"</span>
            isStatic = <span class="hljs-literal">true</span>
        }
    }

    sourceSets {
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material3)
            implementation(compose.materialIconsExtended)
            <span class="hljs-comment">// Ktor, SQLDelight, Koin, Voyager, Coil ...</span>
        }
        androidMain.dependencies {
            implementation(libs.ktor.client.okhttp)
            implementation(libs.sqldelight.android.driver)
        }
        iosMain.dependencies {
            implementation(libs.ktor.client.darwin)
            implementation(libs.sqldelight.native.driver)
        }
    }
}
</code></pre>
<h3 data-id="heading-5">二、数据库迁移：Room → SQLDelight</h3>
<p>这是迁移中工作量最大的部分。Room 不支持 KMP，必须换成 SQLDelight。</p>
<h4 data-id="heading-6">定义 .sq 文件</h4>
<p>SQLDelight 用 <code>.sq</code> 文件定义表结构和查询，放在 <code>commonMain/sqldelight/</code> 目录下：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- Team.sq</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> TeamEntity (
    id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    conference TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    division TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    city TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    name TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    fullName TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    abbreviation TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>
);

getAll: <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TeamEntity;
getById: <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TeamEntity <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> ?;
upsert: <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">INTO</span> TeamEntity <span class="hljs-keyword">VALUES</span> (?, ?, ?, ?, ?, ?, ?);
</code></pre>
<h4 data-id="heading-7">平台 Driver</h4>
<p>通过 <code>expect/actual</code> 为不同平台提供数据库驱动：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// commonMain</span>
<span class="hljs-keyword">expect</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseDriverFactory</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDriver</span><span class="hljs-params">()</span></span>: SqlDriver
}

<span class="hljs-comment">// androidMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseDriverFactory</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context) {
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDriver</span><span class="hljs-params">()</span></span>: SqlDriver =
        AndroidSqliteDriver(NbaDatabase.Schema, context, <span class="hljs-string">"nba.db"</span>)
}

<span class="hljs-comment">// iosMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseDriverFactory</span> {
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDriver</span><span class="hljs-params">()</span></span>: SqlDriver =
        NativeSqliteDriver(NbaDatabase.Schema, <span class="hljs-string">"nba.db"</span>)
}
</code></pre>
<h4 data-id="heading-8">踩坑：SQLDelight 属性名</h4>
<p>SQLDelight 生成的 Queries 属性名基于 <code>.sq</code> 文件名，不是表名。比如 <code>Game.sq</code> 生成 <code>database.gameQueries</code>，不是 <code>database.gameEntityQueries</code>。这个坑让我排查了好一会儿。</p>
<h4 data-id="heading-9">踩坑：Kotlin 类型推断</h4>
<p>SQLDelight 的链式 mapper 调用会让 Kotlin 的类型推断犯迷糊。解决方案是写显式的扩展函数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> TeamEntity.<span class="hljs-title">toTeam</span><span class="hljs-params">()</span></span>: Team = Team(
    id = id.toInt(),
    conference = conference,
    division = division,
    city = city,
    name = name,
    fullName = fullName,
    abbreviation = abbreviation,
)
</code></pre>
<h3 data-id="heading-10">三、依赖注入：Hilt → Koin</h3>
<p>Hilt 依赖 Android 的注解处理器（KSP），不支持 KMP。Koin 是纯 Kotlin 实现，天然跨平台。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// commonMain - KoinModules.kt</span>
<span class="hljs-keyword">val</span> sharedModule = module {
    <span class="hljs-comment">// Network</span>
    single&lt;NbaNetworkDataSource&gt; { KtorNbaNetwork(<span class="hljs-keyword">get</span>()) }

    <span class="hljs-comment">// Database</span>
    single { <span class="hljs-keyword">get</span>&lt;DatabaseDriverFactory&gt;().createDriver() }
    single { NbaDatabase(<span class="hljs-keyword">get</span>()) }

    <span class="hljs-comment">// Repositories</span>
    single&lt;GamesRepository&gt; { OfflineFirstGamesRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    single&lt;TeamsRepository&gt; { OfflineFirstTeamsRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    single&lt;PlayersRepository&gt; { OfflineFirstPlayersRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    single&lt;FavoritesRepository&gt; { OfflineFirstFavoritesRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }

    <span class="hljs-comment">// ScreenModels</span>
    factory { GamesListScreenModel(<span class="hljs-keyword">get</span>()) }
    factory { params -&gt; GameDetailScreenModel(params.<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 平台模块通过 expect/actual 提供</span>
<span class="hljs-keyword">expect</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformModule</span><span class="hljs-params">()</span></span>: Module
</code></pre>
<p>平台模块只需要提供 HTTP 引擎和数据库驱动：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// androidMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformModule</span><span class="hljs-params">()</span></span>: Module = module {
    single&lt;HttpClientEngine&gt; { OkHttp.create() }
    single { DatabaseDriverFactory(<span class="hljs-keyword">get</span>()) }
}

<span class="hljs-comment">// iosMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformModule</span><span class="hljs-params">()</span></span>: Module = module {
    single&lt;HttpClientEngine&gt; { Darwin.create() }
    single { DatabaseDriverFactory() }
}
</code></pre>
<p>迁移体验：Hilt 的 <code>@HiltViewModel</code> + <code>@Inject constructor</code> 全部删掉，换成 Koin 的 <code>factory { }</code> 声明。代码量反而少了。</p>
<h3 data-id="heading-11">四、导航：Navigation3 → Voyager</h3>
<p>导航是迁移中设计决策最多的部分。Voyager 提供了 <code>TabNavigator</code> + <code>Navigator</code> 的组合，很适合底部 Tab + 页面栈的场景。</p>
<h4 data-id="heading-12">Tab 定义</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">object</span> GamesTab : Tab {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> options <span class="hljs-meta">@Composable</span> <span class="hljs-keyword">get</span>() = TabOptions(
        index = 0u,
        title = <span class="hljs-string">"Games"</span>,
        icon = rememberVectorPainter(Icons.Default.SportsBasketball),
    )

    <span class="hljs-meta">@Composable</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Content</span><span class="hljs-params">()</span></span> {
        Navigator(GamesListScreen()) { navigator -&gt;
            SlideTransition(navigator)
        }
    }
}
</code></pre>
<p>每个 Tab 内嵌独立的 <code>Navigator</code>，Tab 切换时各自的导航栈互不影响。</p>
<h4 data-id="heading-13">Screen 定义</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamesListScreen</span> : <span class="hljs-type">Screen</span> {
    <span class="hljs-meta">@Composable</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Content</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> screenModel = koinScreenModel&lt;GamesListScreenModel&gt;()
        <span class="hljs-keyword">val</span> uiState <span class="hljs-keyword">by</span> screenModel.uiState.collectAsState()
        <span class="hljs-comment">// UI ...</span>
    }
}
</code></pre>
<h4 data-id="heading-14">页面间传参</h4>
<p>Voyager 通过构造函数传参，简单直接：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameDetailScreen</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gameId: <span class="hljs-built_in">Int</span>) : Screen { ... }

<span class="hljs-comment">// 导航</span>
navigator.push(GameDetailScreen(gameId = <span class="hljs-number">123</span>))
</code></pre>
<p>Koin 端用 <code>parametersOf</code> 传递：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 定义</span>
factory { params -&gt; GameDetailScreenModel(params.<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">val</span> screenModel = koinScreenModel&lt;GameDetailScreenModel&gt; { parametersOf(gameId) }
</code></pre>
<h4 data-id="heading-15">主入口</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HoopsNowApp</span><span class="hljs-params">()</span></span> {
    HoopsNowTheme {
        TabNavigator(GamesTab) {
            Scaffold(
                bottomBar = {
                    NavigationBar {
                        TabNavigationItem(GamesTab)
                        TabNavigationItem(TeamsTab)
                        TabNavigationItem(PlayersTab)
                        TabNavigationItem(FavoritesTab)
                    }
                },
            ) {
                CurrentTab()
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-16">五、状态管理：ViewModel → ScreenModel</h3>
<p>这是最简单的一步。Voyager 的 <code>ScreenModel</code> 和 <code>ViewModel</code> 几乎一模一样：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 迁移前</span>
<span class="hljs-meta">@HiltViewModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GamesListViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gamesRepository: GamesRepository,
) : ViewModel() {
    <span class="hljs-keyword">val</span> uiState = gamesRepository.getGames()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(<span class="hljs-number">5000</span>), Loading)
}

<span class="hljs-comment">// 迁移后</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GamesListScreenModel</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gamesRepository: GamesRepository,
) : ScreenModel {
    <span class="hljs-keyword">val</span> uiState = gamesRepository.getGames()
        .stateIn(screenModelScope, SharingStarted.WhileSubscribed(<span class="hljs-number">5000</span>), Loading)
}
</code></pre>
<p>改动点：</p>
<ul>
<li>删除 <code>@HiltViewModel</code> 和 <code>@Inject constructor</code></li>
<li><code>ViewModel()</code> → <code>ScreenModel</code></li>
<li><code>viewModelScope</code> → <code>screenModelScope</code></li>
<li><code>collectAsStateWithLifecycle()</code> → <code>collectAsState()</code>（CMP 中没�� AndroidX Lifecycle）</li>
</ul>
<h3 data-id="heading-17">六、Android 入口精简</h3>
<p>迁移后 <code>app</code> 模块只剩两个文件：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// HoopsNowApplication.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HoopsNowApplication</span> : <span class="hljs-type">Application</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCreate()
        startKoin {
            androidContext(<span class="hljs-keyword">this</span><span class="hljs-symbol">@HoopsNowApplication</span>)
            modules(sharedModule, platformModule())
        }
    }
}

<span class="hljs-comment">// MainActivity.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        enableEdgeToEdge(...)
        setContent {
            CompositionLocalProvider(
                LocalTeamLogos provides TeamLogoProvider.getAllLogos(),
                LocalPlayerHeadshot provides PlayerHeadshotProvider::getHeadshotUrl,
            ) {
                HoopsNowApp()  <span class="hljs-comment">// 来自 shared 模块</span>
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-18">七、iOS 接入</h3>
<p>iOS 端更简单，只需要一个 SwiftUI 壳：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// iOSApp.swift</span>
<span class="hljs-keyword">@main</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">iOSApp</span>: <span class="hljs-title class_">App</span> {
    <span class="hljs-keyword">init</span>() {
        <span class="hljs-type">KoinHelperKt</span>.doInitKoin()
    }
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> { <span class="hljs-type">ContentView</span>() }
    }
}

<span class="hljs-comment">// ContentView.swift</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">ComposeView</span>().ignoresSafeArea(.all)
    }
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComposeView</span>: <span class="hljs-title class_">UIViewControllerRepresentable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeUIViewController</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) -&gt; <span class="hljs-type">UIViewController</span> {
        <span class="hljs-type">MainViewControllerKt</span>.<span class="hljs-type">MainViewController</span>()
    }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateUIViewController</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">uiViewController</span>: <span class="hljs-type">UIViewController</span>, <span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) {}
}
</code></pre>
<p>shared 模块中提供 iOS 入口：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// iosMain - MainViewController.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MainViewController</span><span class="hljs-params">()</span></span> = ComposeUIViewController { HoopsNowApp() }
</code></pre>
<p>就这样，iOS 端就能跑起来了。整个 Compose UI 通过 <code>ComposeUIViewController</code> 嵌入 SwiftUI。</p>
<h3 data-id="heading-19">八、清理旧代码</h3>
<p>迁移完成后，大量旧文件可以删除：</p>
<ul>
<li><code>core/</code> — 9 个旧 Android 模块全部删除</li>
<li><code>feature/</code> — 4 个功能模块全部删除</li>
<li><code>app/navigation/</code> — 旧 Navigation3 代码</li>
<li><code>build-logic/</code> 中的 6 个 Convention Plugin（Hilt、Room、Feature、Library 等）</li>
<li><code>libs.versions.toml</code> 中的 Hilt、KSP 相关声明</li>
</ul>
<p>从 20+ 个模块精简到 2 个（<code>app</code> + <code>shared</code>），<code>settings.gradle.kts</code> 清爽了很多。</p>
<h3 data-id="heading-20">迁移后的项目结构</h3>
<pre><code class="hljs language-bash" lang="bash">hoopsnow/
├── app/                                <span class="hljs-comment"># Android 入口（2 个文件）</span>
├── shared/                             <span class="hljs-comment"># KMP 共享模块</span>
│   └── src/
│       ├── commonMain/                 <span class="hljs-comment"># 全部业务逻辑 + UI</span>
│       │   ├── kotlin/.../
│       │   │   ├── core/               <span class="hljs-comment"># 数据层（model, data, database, network��</span>
│       │   │   ├── di/                 <span class="hljs-comment"># Koin 模块</span>
│       │   │   └── ui/                 <span class="hljs-comment"># UI 层（screens, components, theme, navigation）</span>
│       │   └── sqldelight/             <span class="hljs-comment"># 数据库定义</span>
│       ├── androidMain/                <span class="hljs-comment"># Android 平台实现</span>
│       └── iosMain/                    <span class="hljs-comment"># iOS 平台实现</span>
├── iosApp/                             <span class="hljs-comment"># iOS 入口（2 个 Swift 文件）</span>
└── build-logic/                        <span class="hljs-comment"># Convention Plugins（精简）</span>
</code></pre>
<h3 data-id="heading-21">踩坑总结</h3>
<h4 data-id="heading-22">1. SQLDelight 属性名</h4>
<p>生成的 Queries 属性名基于 <code>.sq</code> 文件名（<code>gameQueries</code>），不是 <code>CREATE TABLE</code> 的表名（<code>gameEntityQueries</code>）。</p>
<h4 data-id="heading-23">2. collectAsStateWithLifecycle 不可用</h4>
<p>这是 AndroidX Lifecycle 的扩展，CMP 中用 <code>collectAsState()</code> 替代。ScreenModel 会在 Screen dispose 时自动取消 scope，不用担心泄漏。</p>
<h4 data-id="heading-24">3. Kotlin 类型推断与 SQLDelight</h4>
<p>链式 mapper 调用时类型推断可能失败，写显式的 <code>toModel()</code> 扩展函数解决。</p>
<h4 data-id="heading-25">4. Material Icons Extended</h4>
<p><code>Icons.Default.StarBorder</code>、<code>Icons.Default.OpenInNew</code> 等图标需要额外添加 <code>compose.materialIconsExtended</code> 依赖。</p>
<h4 data-id="heading-26">5. Koin ScreenModel 参数传递</h4>
<p>带参数的 ScreenModel 需要用 <code>factory { params -&gt; }</code> 定义，使用时通过 <code>koinScreenModel { parametersOf(...) }</code> 传入。</p>
<h4 data-id="heading-27">6. iOS Framework 编译</h4>
<p>每次修改 shared 代码后需要重新编译 Framework。开发阶段建议在 Xcode Build Phase 中添加自动编译脚本。</p>
<h3 data-id="heading-28">迁移收益</h3>








































<table><thead><tr><th>指标</th><th>迁移前</th><th>迁移后</th></tr></thead><tbody><tr><td>模块数量</td><td>20+</td><td>2 (app + shared)</td></tr><tr><td>支持平台</td><td>Android</td><td>Android + iOS</td></tr><tr><td>UI 代码共享</td><td>0%</td><td>100%</td></tr><tr><td>业务逻辑共享</td><td>0%</td><td>100%</td></tr><tr><td>build.gradle 文件</td><td>20+</td><td>3</td></tr><tr><td>Convention Plugins</td><td>7</td><td>2</td></tr></tbody></table>
<p>最大的收益是 iOS 端几乎零成本接入 — 只需要两个 Swift 文件就能跑起完整的应用。</p>
<h3 data-id="heading-29">依赖版本参考</h3>

















































<table><thead><tr><th>库</th><th>版本</th></tr></thead><tbody><tr><td>Kotlin</td><td>2.0.21</td></tr><tr><td>Compose Multiplatform</td><td>1.7.3</td></tr><tr><td>Ktor</td><td>3.0.3</td></tr><tr><td>SQLDelight</td><td>2.0.2</td></tr><tr><td>Koin</td><td>4.0.0</td></tr><tr><td>Voyager</td><td>1.1.0-beta03</td></tr><tr><td>Coil 3</td><td>3.0.4</td></tr><tr><td>kotlinx-serialization</td><td>1.7.3</td></tr><tr><td>kotlinx-datetime</td><td>0.6.1</td></tr><tr><td>Coroutines</td><td>1.9.0</td></tr></tbody></table>
<h3 data-id="heading-30">总结</h3>
<p>整个迁移花了大约一周时间，其中数据库迁移（Room → SQLDelight）和导航迁移（Navigation3 → Voyager）占了大部分工作量。网络层（Ktor）和序列化（kotlinx-serialization）本身就是 KMP 库，基本不用改。</p>
<p>如果你的 Android 项目已经在用 Kotlin + Compose，迁移到 KMP + CMP 的成本比想象中低很多。最大的障碍是 Room 和 Hilt 这两个 Android 专属库的替换，但 SQLDelight 和 Koin 都是成熟的替代方���。</p>
<p>项目源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flaibinzhi%2Fhoopsnow" target="_blank" title="https://github.com/laibinzhi/hoopsnow" ref="nofollow noopener noreferrer">GitHub - laibinzhi/hoopsnow</a>（cmp 分支）</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[想学 Electron？这份「能跑的示例集」一篇搞懂]]></title>    <link>https://juejin.cn/post/7605817795628990514</link>    <guid>https://juejin.cn/post/7605817795628990514</guid>    <pubDate>2026-02-13T04:03:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795628990514" data-draft-id="7605907495769554953" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="想学 Electron？这份「能跑的示例集」一篇搞懂"/> <meta itemprop="keywords" content="Electron,前端"/> <meta itemprop="datePublished" content="2026-02-13T04:03:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一枚小太阳"/> <meta itemprop="url" content="https://juejin.cn/user/2771228509602109"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            想学 Electron？这份「能跑的示例集」一篇搞懂
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2771228509602109/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一枚小太阳
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:03:58.000Z" title="Fri Feb 13 2026 04:03:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">想学 Electron？这份「能跑的示例集」一篇搞懂</h2>
<p>VS Code、钉钉、Slack、Figma 桌面版……这些你熟悉的软件，背后都有同一个名字：<strong>Electron</strong>。用前端技术（HTML/CSS/JS）就能做桌面应用，是很多团队的选择。但官方文档知识点多、自己从零搭又容易踩坑，<strong>有没有一份「按主题拆好、每个都能直接跑」的示例？</strong> 有。本文就介绍这样一份示例仓库，并帮你把 Electron 的核心知识点串一遍，<strong>看完一篇，知道学什么、去哪看代码</strong>。</p>
<hr/>
<h3 data-id="heading-1">一、Electron 是什么？这个仓库能帮你什么？</h3>
<p><strong>一句话：</strong> Electron 让你用写网页的技术（HTML/CSS/JavaScript）来开发桌面软件，一套代码可跑在 Windows、macOS、Linux 上。</p>
<p><strong>这个仓库做什么：</strong> 把 Electron 常见能力拆成 <strong>23 个独立小项目</strong>，每个项目一个文件夹，里面是<strong>可运行代码 + 说明文档</strong>。你不需要从零搭环境，克隆下来进目录、装依赖、运行命令就能看到效果。适合：</p>
<ul>
<li><strong>想学 Electron 的人</strong>：按主题边看边跑，比光看文档好懂；</li>
<li><strong>做桌面端开发的人</strong>：遇到「窗口、菜单、通知、IPC」等问题，可以对着对应示例改；</li>
<li><strong>面试前突击的人</strong>：仓库里还带 3 套 Electron 面试卷（含答案），可用来自查。</li>
</ul>
<hr/>
<h3 data-id="heading-2">二、怎么跑起来？（3 步）</h3>
<p><strong>环境准备：</strong> 本机装好 <strong>Node.js</strong>（建议 18 及以上），示例在 Windows 11 下验证过，macOS / Linux 下大多也可直接运行。</p>
<p><strong>运行任意一个示例：</strong></p>
<ol>
<li>克隆仓库；</li>
<li>进入想玩的案例目录（例如 <code>ipc</code>、<code>darkmode</code>）；</li>
<li>在该目录下执行：<code>npm install</code> → <code>npm run start</code> 或 <code>npm run start:1</code>（具体看该目录的 readme）。</li>
</ol>
<p>每个案例的<strong>详细命令和说明</strong>都在对应目录的 <strong>readme.md</strong> 里，进去就能看到。</p>
<hr/>
<h3 data-id="heading-3">三、Electron 知识点串讲（对应仓库怎么用）</h3>
<p>下面按「从入门到进阶」的顺序，把主要概念过一遍，并标出<strong>仓库里哪一类示例可以对照着看</strong>。不展开代码细节，只帮你建立地图。</p>
<h4 data-id="heading-4">1. 入门：第一个应用长什么样？</h4>
<p>Electron 应用至少有两个「角色」：<strong>主进程</strong>（负责创建窗口、系统 API）和<strong>渲染进程</strong>（你看到的页面）。两者不能直接互相调函数，要通过 <strong>preload 脚本</strong>安全地暴露接口，或用 <strong>IPC</strong>（进程间通信）传消息。</p>
<p><strong>仓库对应：</strong> <code>tutorial-first-app</code> —— 第一个应用、主进程 / 渲染进程 / preload / IPC 入门。</p>
<hr/>
<h4 data-id="heading-5">2. 进程与通信：页面和「后台」怎么配合？</h4>
<ul>
<li><strong>IPC</strong>：渲染进程和主进程互相发消息（单向、双向、主进程主动推给页面等）。</li>
<li><strong>MessagePort</strong>：更灵活的通道，适合「渲染进程直连」「流式回复」等场景。</li>
<li><strong>Utility Process（效率进程）</strong>：跑 CPU 重活或容易崩的逻辑，和主进程隔离，用 MessagePort 通信。</li>
<li><strong>多线程</strong>：在渲染进程里用 Web Worker，避免大量计算卡住界面。</li>
<li><strong>沙盒</strong>：渲染进程默认沙盒、安全配置，减少安全风险。</li>
</ul>
<p><strong>仓库对应：</strong> <code>ipc</code>、<code>message-ports</code>、<code>efficiency-process</code>、<code>multithreading</code>、<code>sandbox</code>。</p>
<hr/>
<h4 data-id="heading-6">3. 窗口与 UI：桌面应用「长什么样」？</h4>
<ul>
<li><strong>暗色模式</strong>：用系统主题或自己切换，和 CSS 的 <code>prefers-color-scheme</code> 配合。</li>
<li><strong>任务栏</strong>：Windows 上的 JumpList、缩略图工具栏、进度条、图标闪烁等。</li>
<li><strong>窗口定制</strong>：无边框、自定义标题栏、拖拽区域。</li>
<li><strong>进度条</strong>：在任务栏 / Dock 上显示进度（如下载、处理任务）。</li>
</ul>
<p><strong>仓库对应：</strong> <code>darkmode</code>、<code>windows-taskbar</code>、<code>window-customization</code>、<code>progressbar</code>。</p>
<hr/>
<h4 data-id="heading-7">4. 系统与原生能力：和操作系统打交道</h4>
<ul>
<li><strong>菜单</strong>：应用菜单、右键菜单、托盘菜单。</li>
<li><strong>快捷键</strong>：绑定在菜单上的、全局的、窗口内自己监听的。</li>
<li><strong>系统通知</strong>：像微信/邮件那样在系统通知栏弹出，而不是只在页面里弹个提示。</li>
<li><strong>设备访问</strong>：例如蓝牙（Web Bluetooth API）。</li>
<li><strong>深度链接</strong>：自定义协议，从浏览器或别的应用点链接唤起你的应用。</li>
</ul>
<p><strong>仓库对应：</strong> <code>menus</code>、<code>keyboardshortcut</code>、<code>notificationsDemo</code>、<code>bluetooth</code>、<code>deeplinks</code>。</p>
<hr/>
<h4 data-id="heading-8">5. 文件与文档、Web 与导航</h4>
<ul>
<li><strong>文件拖拽</strong>：把文件从应用拖到桌面或资源管理器。</li>
<li><strong>最近文档</strong>：系统「最近打开」列表的集成。</li>
<li><strong>Web 嵌入</strong>：在窗口里嵌网页（iframe、webview、WebContentsView）。</li>
<li><strong>导航历史</strong>：窗口内前进/后退（goBack / goForward）。</li>
<li><strong>在线/离线</strong>：检测网络状态，做离线提示或缓存策略。</li>
</ul>
<p><strong>仓库对应：</strong> <code>draganddrop</code>、<code>recentdocuments</code>、<code>web-embeds</code>、<code>navigationHistory</code>、<code>onlineofflineevents</code>。</p>
<hr/>
<h4 data-id="heading-9">6. 其他常用能力</h4>
<ul>
<li><strong>离屏渲染</strong>：在不可见的画布上渲染（例如生成图、PDF）。</li>
<li><strong>拼写检查</strong>：系统级拼写检查集成。</li>
</ul>
<p><strong>仓库对应：</strong> <code>offscreenrendering</code>、<code>spellchecker</code>。</p>
<hr/>
<h4 data-id="heading-10">7. 学习与面试</h4>
<p>仓库内带 <strong>paper</strong> 目录：3 套 Electron 面试卷，各 100 分，含答案与解析，适合考前自查。</p>
<hr/>
<h3 data-id="heading-11">四、案例目录一览（按需进目录看 readme 和代码）</h3>
<p>下面表格里的<strong>目录名</strong>，在仓库里对应一个文件夹，点进去有 <strong>readme</strong> 和<strong>可运行代码</strong>。不同子项目可能有不同启动命令（如 <code>npm run start:1</code>、<code>start:2</code>），以该目录下的 readme 为准。</p>





















































































































































<table><thead><tr><th>分类</th><th>序号</th><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>入门</td><td>1</td><td>tutorial-first-app</td><td>第一个应用（主进程、渲染进程、preload、IPC 入门）</td></tr><tr><td>窗口与 UI</td><td>2</td><td>darkmode</td><td>黑暗模式 / 主题切换</td></tr><tr><td/><td>3</td><td>windows-taskbar</td><td>Windows 任务栏（JumpList、缩略图、叠加图标、闪烁）</td></tr><tr><td/><td>4</td><td>window-customization</td><td>自定义窗口（无边框、自定义标题栏、拖拽区域）</td></tr><tr><td/><td>5</td><td>progressbar</td><td>任务栏/Dock 进度条</td></tr><tr><td>进程与通信</td><td>6</td><td>ipc</td><td>进程间通信（单向/双向、主→渲染）</td></tr><tr><td/><td>7</td><td>message-ports</td><td>消息端口（MessageChannel、流式回复）</td></tr><tr><td/><td>8</td><td>efficiency-process</td><td>效率进程（Utility Process、MessagePort）</td></tr><tr><td/><td>9</td><td>multithreading</td><td>多线程（Web Workers）</td></tr><tr><td/><td>10</td><td>sandbox</td><td>进程沙盒与安全配置</td></tr><tr><td>系统与原生</td><td>11</td><td>menus</td><td>菜单（应用菜单、上下文菜单、托盘）</td></tr><tr><td/><td>12</td><td>keyboardshortcut</td><td>键盘快捷键（局部、全局、窗口内）</td></tr><tr><td/><td>13</td><td>notificationsDemo</td><td>系统通知（主进程/渲染进程）</td></tr><tr><td/><td>14</td><td>bluetooth</td><td>设备访问（如蓝牙）</td></tr><tr><td/><td>15</td><td>deeplinks</td><td>深度链接（自定义协议、从链接唤起应用）</td></tr><tr><td>文件与文档</td><td>16</td><td>draganddrop</td><td>文件拖拽（拖出到桌面/资源管理器）</td></tr><tr><td/><td>17</td><td>recentdocuments</td><td>最近文件（系统最近文档列表）</td></tr><tr><td>Web 与导航</td><td>18</td><td>web-embeds</td><td>Web 嵌入（iframe、webview、WebContentsView）</td></tr><tr><td/><td>19</td><td>navigationHistory</td><td>导航历史（前进/后退）</td></tr><tr><td/><td>20</td><td>onlineofflineevents</td><td>在线/离线事件</td></tr><tr><td>其他</td><td>21</td><td>offscreenrendering</td><td>离屏渲染</td></tr><tr><td/><td>22</td><td>spellchecker</td><td>拼写检查器</td></tr><tr><td>学习与面试</td><td>23</td><td>paper</td><td>Electron 面试卷（3 套，含答案与解析）</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-12">五、去哪看代码？仓库在这里</h3>
<p>以上所有示例的<strong>完整代码、运行命令和说明</strong>都在下面这个仓库里，每个案例独立可运行，按目录即可找到对应 readme 和代码。</p>
<p><strong>仓库地址：</strong> [<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fsharetoyouclub%2Felectron-demo" target="_blank" title="https://gitee.com/sharetoyouclub/electron-demo" ref="nofollow noopener noreferrer">gitee.com/sharetoyouc…</a>]</p>
<p>克隆后，进入任意目录执行 <code>npm install</code>，再按该目录 readme 的脚本运行即可。MIT 许可，欢迎 Star、Fork，或提 Issue / PR。</p>
<hr/>
<p><em>本文基于 Electron 官方文档与示例整理，旨在帮助初学者和开发者快速建立知识地图并找到可运行示例。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[IDEA + Codex · 32ai 零魔法直连各模型]]></title>    <link>https://juejin.cn/post/7605941424536109110</link>    <guid>https://juejin.cn/post/7605941424536109110</guid>    <pubDate>2026-02-13T04:09:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605941424536109110" data-draft-id="7605807405307723839" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="IDEA + Codex · 32ai 零魔法直连各模型"/> <meta itemprop="keywords" content="OpenAI,AI编程"/> <meta itemprop="datePublished" content="2026-02-13T04:09:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="玹外之音"/> <meta itemprop="url" content="https://juejin.cn/user/2666763911448411"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            IDEA + Codex · 32ai 零魔法直连各模型
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2666763911448411/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    玹外之音
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:09:44.000Z" title="Fri Feb 13 2026 04:09:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🧠 IDEA + Codex · 32ai 零魔法直连各模型</h2>
<blockquote>
<p>完整教程——从安装Codex到使用自定义端点，每一步都包含配置截图占位与详细解释。基于<strong>32ai中转平台</strong>，直连、稳定、低价。</p>
</blockquote>
<h3 data-id="heading-1">目录</h3>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85-codex" title="#%E5%AE%89%E8%A3%85-codex">安装 Codex</a></li>
<li><a href="#idea-%E6%8F%92%E4%BB%B6%E6%90%9C%E7%B4%A2--%E5%AE%89%E8%A3%85" title="#idea-%E6%8F%92%E4%BB%B6%E6%90%9C%E7%B4%A2--%E5%AE%89%E8%A3%85">IDEA 插件搜索 &amp; 安装</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-configtoml" title="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-configtoml">修改配置文件 config.toml</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96-32ai-api-key" title="#%E8%8E%B7%E5%8F%96-32ai-api-key">获取 32ai API Key</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6-authjson" title="#%E4%BF%AE%E6%94%B9%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6-authjson">修改认证文件 auth.json</a></li>
<li><a href="#idea-%E4%B8%AD%E5%90%AF%E5%8A%A8-codex" title="#idea-%E4%B8%AD%E5%90%AF%E5%8A%A8-codex">IDEA 中启动 Codex</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B--%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%94%9F%E6%95%88" title="#%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B--%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%94%9F%E6%95%88">验证模型 &amp; 配置文件生效</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E6%B5%8B%E8%AF%95--%E5%AE%8C%E6%88%90%E9%9B%86%E6%88%90" title="#%E4%BB%BB%E5%8A%A1%E6%B5%8B%E8%AF%95--%E5%AE%8C%E6%88%90%E9%9B%86%E6%88%90">任务测试 · 完成集成</a></li>
</ul>
<h3 data-id="heading-2">安装 Codex</h3>
<p>全局安装 <code>@openai/codex</code> 包：</p>
<pre><code class="hljs language-bash" lang="bash">npm install -g @openai/codex
</code></pre>
<h3 data-id="heading-3">IDEA 插件搜索 &amp; 安装</h3>
<p>在 IntelliJ IDEA 中搜索插件 <strong>Codex</strong> 并下载安装。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3a12bb7031d4773801bd12ac878a4fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=khQIhaspesIEVofa9WLTLQDEQb0%3D" alt="屏幕截图 2026-02-13 094222.png" loading="lazy"/></p>
<h3 data-id="heading-4">修改配置文件 config.toml</h3>
<p>Codex 配置优先级（从高到低）：
<code>CLI标志</code> → <code>剖面值 --profile</code> → 项目级 <code>.codex/config.toml</code> → 用户级 → 系统级 → 内置默认。</p>
<p><strong>Windows 用户配置路径</strong>（不存在则创建）：</p>
<pre><code class="hljs language-bash" lang="bash">~/.codex/config.toml   <span class="hljs-comment"># 用户配置</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d426d730f97745d2899dfcf296027e17~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=bjW%2BQ3ebYXYL1KEvDHn3YuNeOGY%3D" alt="屏幕截图 2026-02-13 113420.png" loading="lazy"/></p>
<h4 data-id="heading-5">📋 直接复制以下内容到 config.toml</h4>
<pre><code class="hljs language-toml" lang="toml"><span class="hljs-attr">model_provider</span> = <span class="hljs-string">"32ai"</span>
<span class="hljs-attr">model</span> = <span class="hljs-string">"gpt-5-codex"</span>

<span class="hljs-comment"># Reasoning effort: minimal | low | medium | high | xhigh (default: medium; xhigh on gpt-5.2-codex and gpt-5.2)</span>
<span class="hljs-attr">model_reasoning_effort</span> = <span class="hljs-string">"medium"</span>

<span class="hljs-comment"># Reasoning summary: auto | concise | detailed | none (default: auto)</span>
<span class="hljs-attr">model_reasoning_summary</span> = <span class="hljs-string">"auto"</span>

<span class="hljs-comment"># Text verbosity for GPT-5 family (Responses API): low | medium | high (default: medium)</span>
<span class="hljs-attr">model_verbosity</span> = <span class="hljs-string">"medium"</span>

<span class="hljs-comment"># Force-enable reasoning summaries for current model (default: false)</span>
<span class="hljs-attr">model_supports_reasoning_summaries</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">disable_response_storage</span> = <span class="hljs-literal">true</span>
<span class="hljs-attr">preferred_auth_method</span> = <span class="hljs-string">"apikey"</span>

<span class="hljs-comment"># Optional manual model metadata...</span>
<span class="hljs-comment"># model_context_window = 128000</span>
<span class="hljs-comment"># model_auto_compact_token_limit = 0</span>
<span class="hljs-comment"># tool_output_token_limit = 10000</span>
<span class="hljs-comment"># log_dir = "/absolute/path/to/codex-logs"</span>

<span class="hljs-attr">approval_policy</span> = <span class="hljs-string">"on-request"</span>

<span class="hljs-section">[model_providers]</span>

<span class="hljs-comment"># --- 32ai 自定义提供商 ---</span>
<span class="hljs-section">[model_providers.32ai]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"32ai"</span>
<span class="hljs-attr">base_url</span> = <span class="hljs-string">"https://ai.32zi.com/v1"</span>        <span class="hljs-comment"># 核心端点</span>
<span class="hljs-attr">wire_api</span> = <span class="hljs-string">"responses"</span>                           <span class="hljs-comment"># "responses" | "chat"</span>
<span class="hljs-attr">requires_openai_auth</span> = <span class="hljs-literal">true</span>                    
<span class="hljs-attr">request_max_retries</span> = <span class="hljs-number">4</span>                        
<span class="hljs-attr">stream_max_retries</span> = <span class="hljs-number">5</span>                         
<span class="hljs-attr">stream_idle_timeout_ms</span> = <span class="hljs-number">300000</span>                
<span class="hljs-comment"># experimental_bearer_token = ""       </span>
<span class="hljs-comment"># http_headers = { "X-Example" = "value" }</span>

<span class="hljs-section">[profiles]</span>

<span class="hljs-section">[profiles.32ai]</span>
<span class="hljs-attr">model</span> = <span class="hljs-string">"gpt-5-codex"</span>
<span class="hljs-attr">model_provider</span> = <span class="hljs-string">"32ai"</span>
<span class="hljs-attr">approval_policy</span> = <span class="hljs-string">"on-request"</span>
<span class="hljs-attr">sandbox_mode</span> = <span class="hljs-string">"read-only"</span>
<span class="hljs-comment"># oss_provider = "ollama"</span>
<span class="hljs-attr">model_reasoning_effort</span> = <span class="hljs-string">"medium"</span>
<span class="hljs-attr">model_reasoning_summary</span> = <span class="hljs-string">"auto"</span>
<span class="hljs-attr">model_verbosity</span> = <span class="hljs-string">"medium"</span>
<span class="hljs-attr">personality</span> = <span class="hljs-string">"friendly"</span> <span class="hljs-comment"># or "pragmatic" or "none"</span>
<span class="hljs-comment"># chatgpt_base_url = "https://ai.32zi.com/v1"</span>
<span class="hljs-attr">include_apply_patch_tool</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">experimental_use_unified_exec_tool</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">experimental_use_freeform_apply_patch</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">tools.web_search</span> = <span class="hljs-literal">false</span>             

<span class="hljs-section">[notice.model_migrations]</span>
<span class="hljs-attr">gpt-5-codex</span> = <span class="hljs-string">"gpt-5.3-codex"</span>
<span class="hljs-attr">"gpt-5.2-codex"</span> = <span class="hljs-string">"gpt-5.3-codex"</span>
<span class="hljs-comment"># features = { unified_exec = false }</span>
</code></pre>
<p>🔗 参考示例来自 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.openai.com%2Fcodex%2Fconfig-sample" target="_blank" title="https://developers.openai.com/codex/config-sample" ref="nofollow noopener noreferrer">developers.openai.com/codex/confi…</a> (已适配32ai)</p>
<h3 data-id="heading-6">获取 32ai API Key</h3>
<p>前往中转平台 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com" target="_blank" title="https://ai.32zi.com" ref="nofollow noopener noreferrer">ai.32zi.com</a></strong> 注册/登录，生成 API 密钥。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/875059ec08c74ffab17ae804945fc458~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=JFrQD%2BpEaT7AJWzn5Y4U5NtfzL8%3D" alt="屏幕截图 2026-02-12 171825.png" loading="lazy"/></p>
<h4 data-id="heading-7">⚡ 32ai 优势</h4>
<p><strong>低价 · 稳定 · 直连 · 免魔法</strong></p>
<p><strong>价格 0.56 : 1</strong></p>
<h3 data-id="heading-8">修改认证文件 auth.json</h3>
<p>在 Codex 配置目录（通常是用户级 <code>~/.codex/</code>）创建或编辑 <strong>auth.json</strong>，填入你的 API key。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"auth_mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"apikey"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"OPENAI_API_KEY"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"你的32ai_api_key_粘贴在此"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f011b735ee1f4b44988c9be92c567a59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=H5mqJ8YH3u4lgHhVMjoJpV5mC4I%3D" alt="屏幕截图 2026-02-13 113420.png" loading="lazy"/></p>
<blockquote>
<p>⚠️ <strong>OPENAI_API_KEY</strong> 就是中转平台 <a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com" target="_blank" title="https://ai.32zi.com" ref="nofollow noopener noreferrer">ai.32zi.com</a> 获取的密钥。</p>
</blockquote>
<h3 data-id="heading-9">IDEA 中启动 Codex</h3>
<p>返回 IDEA，找到 Codex 插件图标（通常位于右侧边栏或工具窗口），点击启动。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9212df1ecb724b32a417dc863405ce7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=Rs63Qowl6nTa4uOQ%2FsT8Tr49aJE%3D" alt="屏幕截图 2026-02-13 114038.png" loading="lazy"/></p>
<h3 data-id="heading-10">验证模型 &amp; 配置文件生效</h3>
<p>启动后直接查看当前使用的模型，应当显示 <code>gpt-5-codex</code>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb3189867a314b0b9c864a8384957e70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=ASIzPjwxoq6Jnz5H0SfyUsSa3tY%3D" alt="屏幕截图 2026-02-13 113110.png" loading="lazy"/></p>
<h3 data-id="heading-11">任务测试 · 完成集成</h3>
<p>给它一个代码任务或任意指令，验证整个链路是否正常工作。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7d9427661eb4ceaac24848951c04677~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=dmUyZsZHbGCtkd07xuKYuw4rFss%3D" alt="屏幕截图 2026-02-13 113055.png" loading="lazy"/></p>
<blockquote>
<p>🎉 <strong>恭喜！IDEA + Codex (32ai) 已成功集成。</strong> 现在你可以使用自定义端点，基于 GPT-5-Codex 模型进行开发、问答等。</p>
</blockquote>
<hr/>
<h3 data-id="heading-12">💰 为什么选择 32ai？</h3>
<p><strong>低至 0.56 : 1 比率</strong></p>

















<table><thead><tr><th>功能</th><th>优势</th></tr></thead><tbody><tr><td>价格方案</td><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf2e0b80784d4ae590d8e93bd4ed2319~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=umDnomRYz6UjZcX5UzI6bJEK3Kg%3D" alt="屏幕截图 2026-02-12 172853.png" loading="lazy"/></td></tr><tr><td>计费说明</td><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4357e4e48ef543c5a67011de31b81c96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=4OatHyWOTFmH69E7U1GyWwlezLA%3D" alt="屏幕截图 2026-02-12 173008.png" loading="lazy"/></td></tr></tbody></table>
<p>🔗 <strong>快速访问</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com" target="_blank" title="https://ai.32zi.com" ref="nofollow noopener noreferrer">ai.32zi.com</a> — 直连、无需魔法。</p>
<h3 data-id="heading-13">📌 配置备忘</h3>
<ul>
<li>使用用户配置 (<code>~/.codex/config.toml</code>) 全局生效</li>
<li>配置节 <code>[model_providers.32ai]</code> 定义 base_url = <a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com%2Fv1" target="_blank" title="https://ai.32zi.com/v1" ref="nofollow noopener noreferrer">ai.32zi.com/v1</a> 以及 wire_api = responses</li>
<li>通过 <code>[profiles.32ai]</code> 关联提供商与模型，personality 可选 friendly / pragmatic</li>
<li>迁移通知：<code>gpt-5-codex → gpt-5.3-codex</code> 自动映射</li>
<li>更多高级参数（日志、上下文窗口）可按需取消注释</li>
</ul>
<h4 data-id="heading-14">🔄 官方模型迁移 (notice.model_migrations)</h4>
<p><code>gpt-5-codex</code> → <code>gpt-5.3-codex</code>     <code>gpt-5.2-codex</code> → <code>gpt-5.3-codex</code></p>
<hr/>
<p>⚡ <strong>IDEA + Codex + 32ai</strong> 全流程集成完毕。</p>
<p>享受低价、稳定、无需代理的GPT-5-Codex编程体验。</p>
<hr/>
<p><strong>原创声明</strong>：本文为原创教程，转载请注明出处</p>
<p>欢迎在评论区交流讨论！如果觉得有帮助，请点赞收藏支持～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【保姆级教程】Claude Code 进阶指南：用 Everything Claude Code 打造更有“记忆”的 AI 程序员]]></title>    <link>https://juejin.cn/post/7605811866908786697</link>    <guid>https://juejin.cn/post/7605811866908786697</guid>    <pubDate>2026-02-13T04:05:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908786697" data-draft-id="7605817795628974130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【保姆级教程】Claude Code 进阶指南：用 Everything Claude Code 打造更有“记忆”的 AI 程序员"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-02-13T04:05:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="李同学Lino"/> <meta itemprop="url" content="https://juejin.cn/user/3085689267423785"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【保姆级教程】Claude Code 进阶指南：用 Everything Claude Code 打造更有“记忆”的 AI 程序员
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3085689267423785/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    李同学Lino
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:05:41.000Z" title="Fri Feb 13 2026 04:05:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在之前的教程中，我们成功在 Windows 11 环境下把 Anthropic 的“编程神器” <strong>Claude Code</strong> 跑了起来。相信很多朋友在体验过那种“这才是未来编程”的快感后，都跟我一样大受震撼。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a01bef3be37a436e9000e85e876d02d8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Q%2FGgJUFqUhlty6ptCPoDDF9pw1U%3D" alt="" loading="lazy"/></p>
<p>但是，随着我最近在高强度的开发实战（特别是用来写稍微复杂一点的 AI 智能体项目）中深入使用，我发现这位“天才程序员”也有它的软肋：</p>
<ol>
<li>
<p><strong>它是“金鱼记忆”</strong>：一旦对话变长，或者隔天再打开，它就忘了之前的项目架构和决策，你得费劲地重新把上下文“喂”给它。</p>
</li>
<li>
<p><strong>它是“随性派”</strong>：有时你得反复强调“请用 TypeScript”、“请遵循这个文件结构”，它才肯乖乖听话，非常消耗 Token 和耐心。</p>
</li>
<li>
<p><strong>它缺乏“工程直觉”</strong>：原生的 Claude Code 很强，但它更像是一个在大厂待过的“外包”，虽然活儿好，但不懂你的项目习惯。</p>
</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd8d41fa7c0a42fbb4d6652f461645f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=TEFEpiLRb9L9IczITwqgMvy%2FrPI%3D" alt="" loading="lazy"/></p>
<p><strong>这就引出了今天的主角 —— Everything Claude Code。</strong>
如果把 Claude Code 比作一把绝世好剑，那么 <strong>Everything Claude Code</strong> 就是那本失传已久的“剑谱”。这是目前 GitHub 上最火的 Claude Code 配置集合（由 Anthropic Hackathon 冠军 Affaan Mustafa 开发），它通过一系列巧妙的 <strong>Rules（规则）</strong>、<strong>Skills（技能）</strong> 和 <strong>Hooks（钩子）</strong>，彻底解决了上述痛点。
它能让你的 AI 助手学会“记笔记”（持久化记忆）、学会“自我反思”（代码审查），甚至能自动化生成文档。
<strong>开源链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faffaan-m%2Feverything-claude-code" target="_blank" title="https://github.com/affaan-m/everything-claude-code" ref="nofollow noopener noreferrer">github.com/affaan-m/ev…</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a88eaceb474d4726a8e2dcc52c3523da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=zLH7HVrxrGGqIrs1H9kRIDarJo8%3D" alt="" loading="lazy"/></p>
<p>今天这篇进阶教程，我就手把手教大家：<strong>如何在 Windows 11 环境下，把这就套“最强配置”装进你的 Claude Code 里，把它从一个“聊天机器人”进化成一个真正懂你、有记忆、能干重活的“资深 AI 工程师”。</strong>
准备好了吗？我们要开始给 AI “做手术”了。</p>
<h2 data-id="heading-0">第一部分：环境准备与安装</h2>
<p>我们要做的不是安装一个新软件，而是要把一套“绝世武功秘籍”（配置文件）下载下来，然后“传授”（复制）给你的 Claude Code。</p>
<h3 data-id="heading-1">检查你的装备库 (环境自检)</h3>
<p>在开始之前，我们需要确保你的 Windows 11 已经准备好了基础工具。请打开你的 <strong>PowerShell</strong> 或 <strong>终端 (Windows Terminal)</strong>，依次输入以下命令：
<strong>A. 检查 Claude Code 是否存活</strong></p>
<pre><code class="hljs language-Markdown" lang="Markdown">claude --version
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d910323d9214eb7b6f219122c85a09e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Ag4emVjUKqfqKhzFJiuPTIw4Nw4%3D" alt="" loading="lazy"/></p>
<p><strong>正常反馈</strong>：会出现类似 <code>2.x.x</code> 的版本号。
<strong>如果不正常</strong>：请回看我的之前那篇**<a href="https://link.juejin.cn?target=https%3A%2F%2Fmy.feishu.cn%2Fwiki%2FPFBJwgs5qioKL5kfAlOcuY8xnAe" target="_blank" title="https://my.feishu.cn/wiki/PFBJwgs5qioKL5kfAlOcuY8xnAe" ref="nofollow noopener noreferrer">《Claude Code 部署教程》</a>**，先把 Claude Code 装好。
<strong>B. 检查 Git 是否安装</strong></p>
<pre><code class="hljs language-Markdown" lang="Markdown">git --version
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/154d35310fd34653bc9dc392c8a5dbdb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Ki%2FsvLjVX68btnvILt6PaNLZCzg%3D" alt="" loading="lazy"/></p>
<p><strong>正常反馈</strong>：会出现 <code>git version 2.x.x...</code>。
<strong>如果不正常</strong>：去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin" target="_blank" title="https://git-scm.com/download/win" ref="nofollow noopener noreferrer">Git for Windows 官网</a> 下载安装。</p>
<h2 data-id="heading-2">第二部分：插件化极速部署</h2>
<p>在以前，给 Claude Code 装配置需要像搬砖一样手动复制一堆文件。但现在，我们可以利用 Claude Code 原生的<strong>插件市场（Plugin Marketplace）</strong> 功能，像给 Chrome 装插件一样简单。
整个过程只需 <strong>3 步</strong>，耗时约 <strong>2 分钟</strong>。</p>
<h3 data-id="heading-3">第一步：安装“Everything”插件核心</h3>
<p>打开你的终端（Terminal 或 PowerShell），不需要下载任何 ZIP 包，直接在终端里和 Claude 对话即可。
<strong>启动 Claude Code</strong>：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">claude
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94f942f63fc24bd4b0b0bdb1e1cce3da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=rP5m%2BTpkt0tkA1UHiRoUF2Egry0%3D" alt="" loading="lazy"/></p>
<p><strong>添加插件市场源</strong>： 在 Claude 的对话框中，直接输入以下命令并回车（这会告诉 Claude 去哪里找这个插件）：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/plugin marketplace add affaan-m/everything-claude-code
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a7eeccc6c85470eb4707a5aaa9b1743~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=SyYcR88ZQ7swN1o42DhipcU26X0%3D" alt="" loading="lazy"/>
一键安装插件，接着输入：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/plugin install everything-claude-code@everything-claude-code
</code></pre>
<p>输入安装命令并回车后，终端会出现一个交互式的选择界面（如下图所示）。这时候不要慌，这里需要你决定“把这些能力装在哪里”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6850836bbd664e40888f59fb1126cb19~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=MIR27DglUtSjP96Kf2NMpBdjVnw%3D" alt="" loading="lazy"/></p>
<p>你会看到三个选项，我们来逐一解读（保姆级解释）：</p>
<ol>
<li>
<p><strong><code>Install for you (user scope)</code></strong> <strong>【强烈推荐选这个！】</strong></p>
</li>
<li>
<p><strong>含义</strong>：安装到你当前用户的全局配置里。</p>
</li>
<li>
<p><strong>好处</strong>：一次安装，处处可用。无论你以后打开哪个文件夹、写哪个新项目，Claude Code 都会自带这些强大的技能和记忆。</p>
</li>
<li>
<p><strong>适合</strong>：个人开发者、独行侠、希望 AI 助手时刻保持最强状态的你。</p>
</li>
<li>
<p><code>Install for all collaborators on this repository (project scope)</code></p>
</li>
<li>
<p><strong>含义</strong>：只安装在当前这个项目文件夹里，并且把配置写入文件，推送到 Git 仓库。</p>
</li>
<li>
<p><strong>好处</strong>：你的队友拉取代码后，也能自动获得这些工具。</p>
</li>
<li>
<p><strong>适合</strong>：团队协作，且你希望强制队友也使用这套工作流。</p>
</li>
<li>
<p><code>Install for you, in this repo only (local scope)</code></p>
</li>
<li>
<p><strong>含义</strong>：只在这个项目里用，且不分享给队友。</p>
</li>
<li>
<p><strong>适合</strong>：你在秘密测试某个插件，不想影响全局环境。</p>
</li>
</ol>
<p><strong>📝 操作步骤：</strong></p>
<ol>
<li>
<p>确保光标停留在第一项 <strong><code>Install for you (user scope)</code></strong> 上（如果有变动，使用键盘上下箭头 <code>↑</code> <code>↓</code> 移动）。</p>
</li>
<li>
<p>直接按 <strong><code>Enter</code></strong> <strong>(回车键)</strong> 确认。</p>
</li>
</ol>
<p><strong>👀 重点注意：安装成功的标志</strong> 按下回车后，终端可能会出现两种情况：</p>
<ul>
<li>
<p><strong>情况 A（话痨模式）</strong>：刷屏显示 <code>Installed agent: xxx</code>, <code>Installed command: xxx</code> 等一长串列表。</p>
</li>
<li>
<p><strong>情况 B（高冷模式）</strong>：只显示一行 <code>(no content)</code> 或者什么都不显示，直接跳回输入框。</p>
</li>
</ul>
<p><strong>请注意：情况 B 也是成功的！</strong> 如果你不确定是否装好了，可以再次输入一遍安装命令，如果它提示 <code>Plugin ... is already installed</code>（如截图所示），那就说明你已经大功告成了，请放心继续下一步。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6feabb258843489c979e62ee3ef9d409~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=AKU8EoIw4m2AVnx4C3X%2Fxl4yyRM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">第二步：手动注入“大脑规则”（必做！）</h3>
<p>⚠️ <strong>注意：这是最关键的一步！</strong> 由于 Claude Code 目前的限制，插件无法自动修改你的系统规则（Rules）。如果不做这一步，Claude 只是学会了“技能”，但还没学会“纪律”和“思维方式”。
我们需要手动把规则文件放入 Claude 的配置目录。</p>
<ol>
<li><strong>找到你的 Claude 配置目录</strong></li>
</ol>
<ul>
<li>
<p><strong>Windows 用户</strong>：通常在 <code>C:\Users\你的用户名\.claude\rules</code></p>
</li>
<li>
<p><strong>macOS/Linux 用户</strong>：在 <code>~/.claude/rules</code></p>
</li>
</ul>
<ol start="2">
<li><strong>下载规则文件</strong> 如果你不想克隆整个仓库，我为你准备了<strong>最简单的“偷懒”方法</strong>： 你需要去 GitHub 仓库的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faffaan-m%2Feverything-claude-code%2Ftree%2Fmain%2Frules" target="_blank" title="https://github.com/affaan-m/everything-claude-code/tree/main/rules" ref="nofollow noopener noreferrer">rules 文件夹</a>，把里面的 <code>.md</code> 文件（如 <code>security.md</code>, <code>coding-style.md</code>, <code>testing.md</code> 等）下载下来。</li>
</ol>
<p><strong>推荐操作（命令行极客版）：</strong> 先退出 Claude（输入 <code>/exit</code>），然后在终端（Powershell）运行：</p>
<pre><code class="hljs language-Markdown" lang="Markdown"><span class="hljs-section"># 1. 克隆仓库到临时目录git clone https://github.com/affaan-m/everything-claude-code.git temp<span class="hljs-emphasis">_ecc# 2. 创建规则目录（如果不存在）mkdir -p ~/.claude/rules# 3. 复制规则文件过去cp temp_</span>ecc/rules/* ~/.claude/rules/# 4. (可选) 删除临时目录Remove-Item temp<span class="hljs-emphasis">_ecc -Recurse -Force
</span></span></code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d79fd4103d634e60b2fa9100ce27d430~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=FfSfHGAkjAsPCF8PQcAhQXhOuG0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">第三步：验证安装 &amp; 初始化包管理器</h3>
<p>一切就绪，我们来测试一下，顺便配置一下你常用的包管理器（npm, pnpm 等），这样 Claude 写代码时知道该用什么命令。
<strong>重启 Claude</strong>：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">claude
</code></pre>
<p><strong>运行初始化命令</strong>： 在对话框输入以下命令（Claude 可能会自动补全成长得像 <code>everything-claude-code:setup-pm</code> 的样子，不用管，直接回车）：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/setup-pm
</code></pre>
<p><strong>授权执行脚本（重点！）</strong>： 回车后，你会看到类似下图的界面。Claude 会请求运行一个名为 <code>setup-package-manager.js</code> 的脚本。</p>
<ul>
<li>
<p><strong>不必惊慌</strong>：这是它在请求权限扫描你的环境。</p>
</li>
<li>
<p><strong>操作方法</strong>：看到 <code>Do you want to proceed?</code>（你想要继续吗？）时，默认选项是 <strong><code>&gt; 1. Yes</code></strong>。直接按 <strong><code>Enter</code></strong> <strong>(回车)</strong> 确认即可。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11c29f7a6a3144758a31410fc5f01b69~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2BJ7fBOPgnDkHpWJlo0BwNyb5odQ%3D" alt="" loading="lazy"/></p>
<p><strong>再次确认（请耐心）</strong>： 紧接着，它可能会再次请求权限来“列出可用列表” (<code>--list</code>)。 <strong>请继续按回车选择</strong> <strong><code>Yes</code></strong>。这是一个正常的流程，不要拒绝它，否则初始化会中断。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7ed9492ddc147928bbf4d7703671915~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=zGN8NtGmD8lRG5A6sutJ9g5h04g%3D" alt="" loading="lazy"/></p>
<p><strong>做最终决定（Final Decision）</strong> 脚本跑完后，会弹出一个交互式菜单（如下图）。它会列出你电脑里已经装了哪些工具（表格里 <code>Installed: Yes</code> 的项）。</p>
<ul>
<li>
<p><strong>如果你是新手</strong>：直接选 <strong><code>1. Keep npm (current)</code></strong>（或者你电脑上默认已安装的那个）。这是最稳妥的选择。</p>
</li>
<li>
<p><strong>如果你是老手</strong>：想换成更快的 <code>pnpm</code> 或 <code>bun</code>，可以选对应的选项，Claude 会帮你去安装它。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44a0652e409745c290b722dad6f7c718~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=lR6Y4T2Ki5FsG3JtFX750WnWM9A%3D" alt="" loading="lazy"/></p>
<p><strong>最后的“画押”（写入配置）</strong> 选完工具后，Claude 会最后一次请求权限：<strong>创建一个名为</strong> <strong><code>package-manager.json</code></strong> <strong>的配置文件</strong>。 这一步是为了把你的选择“刻在硬盘里”，以后就不用再设置了。
<strong>操作方法</strong>：看到 <code>Create file</code> 的请求时，确认为 <strong><code>&gt; 1. Yes</code></strong>，按下 <strong>Enter (回车)</strong>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7eac3d18d82b44d8ae489f9cf2e3dd1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=P70ToSujY2fm0FM9L4ZJwMRIKvM%3D" alt="" loading="lazy"/></p>
<p><strong>最终验证（Verify）</strong> 文件保存后，Claude 会<strong>最后再运行一次检测脚本</strong>，目的是确认刚才的配置真的生效了（Verify package manager configuration）。 <strong>操作方法</strong>：不要犹豫，再次选择 <strong><code>&gt; 1. Yes</code></strong> 并回车。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2cc3c9c335ba4618aeeefe8397dca400~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=J5LtYjVTins%2Bwxv3vEqg6BJ1%2Fz0%3D" alt="" loading="lazy"/></p>
<p><strong>见证胜利（配置完成）</strong> 在经过几次确认后，终端最终会显示一段详细的总结报告（如下图）。</p>
<ul>
<li>
<p><strong>Configuration</strong>: 显示你选了 <code>npm</code>。</p>
</li>
<li>
<p><strong>Commands</strong>: 显示以后它会用什么命令来干活。</p>
</li>
</ul>
<p>当你看到 <strong>"Done. Your package manager configuration is now set up"</strong> 这行字时，恭喜你！所有的环境配置工作全部结束！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0481829d010442368e16f6ca15fd2776~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=ow7w%2FxJK7uw9vEEIBXrkQ22yQ0s%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">第三部分：实战演练</h2>
<p>环境装好了，不拿出来溜溜怎么行？
很多朋友以前用 Claude Code，上来就说：“给我写个贪吃蛇游戏”。结果 AI 经常是“哐当”扔给你一大坨代码，要么跑不起来，要么改一个 Bug 冒出三个新 Bug。
<strong>为什么？因为它没有“脑子”（规划）。</strong> 但装了 <strong>Everything Claude Code</strong> 之后，我们拥有了一个核心核武器：<strong><code>/plan</code></strong> <strong>命令</strong>。
现在，请跟着我做，我们来体验一下什么叫“<strong>降维打击</strong>”。</p>
<h3 data-id="heading-7"><strong>1.提出需求：不要直接写代码，先做计划</strong></h3>
<p>在终端里，输入以下命令（还是以经典的贪吃蛇游戏为例，因为它简单且直观）：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/plan "使用 HTML5 和原生 JavaScript 写一个贪吃蛇游戏，界面要现代简洁，支持分数记录"
</code></pre>
<p><strong>💡 小贴士</strong>：注意 <code>/plan</code> 和后面的需求之间有个空格。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4521ad2da07b45ed949fc59b8c85a320~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2BtjTtwOqKMr2e8ySKGWeh%2BDsULo%3D" alt="" loading="lazy"/></p>
<p>请看屏幕左下角那个蓝色的 <strong><code>[||] plan mode on</code></strong> 标志 —— 这意味着 Claude 已经从普通的“聊天模式”切换到了专业的“架构师模式（Plan Mode）”。
在当前版本的 Claude Code 中，<code>/plan</code> 命令有时只作为一个“模式开关”。它听到了你的召唤，打开了开关，但可能没有把你刚才引号里的那句话直接当成任务发出去（或者它正在等你确认）。</p>
<h4 data-id="heading-8"><strong>怎么办？（只需一步）</strong></h4>
<p>现在的光标 <code>&gt;</code> 已经在闪烁等待了，你只需要<strong>在当前模式下，把需求再发一遍</strong>即可：</p>
<ol>
<li>
<p><strong>直接输入</strong>： <code>使用 HTML5 和原生 JavaScript 写一个贪吃蛇游戏，界面要现代简洁，支持分数记录</code></p>
</li>
<li>
<p><strong>按下回车</strong>。</p>
</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/da97def5c4134df4a23d21763c3427a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=ORVtgluy8WkIDpIG2%2Flq9ChkPcU%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">2.见证“降维打击”级的规划能力</h3>
<p>按下回车后，Claude <strong>绝对不会</strong>像个愣头青一样直接开始写代码。相反，它会先停下来思考，然后输出一份<strong>极具专业水准的“项目设计书”</strong>。
请看下图，这就是 Everything Claude Code 的威力所在。它不仅理解了你的需求，还自动补全了所有细节：</p>
<ul>
<li>
<p><strong>文件结构</strong>：自动规划好了 <code>index.html</code> (骨架), <code>style.css</code> (皮肤), <code>game.js</code> (灵魂)。</p>
</li>
<li>
<p><strong>核心功能拆解</strong>：</p>
<ul>
<li>
<p>明确画布大小 (400x400)</p>
</li>
<li>
<p>操作逻辑 (WASD + 方向键双重支持)</p>
</li>
<li>
<p>数据存储 (利用 localStorage 存最高分，连这个细节都想到了！)</p>
</li>
</ul>
</li>
<li>
<p><strong>UI 设计规范</strong>：</p>
<ul>
<li>甚至连配色都想好了：深色背景 (<code>#1a1a2e</code>) 配霓虹绿蛇身 (<code>#00ff88</code>)。这哪是写代码，简直是自带设计师！</li>
</ul>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2ad75288a1b429889c5c586a02b3643~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2FmsRdygb5HW2cCRFRdIWb9YuJcA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10">3.架构师的“追问”：它竟然懂得抠细节！</h3>
<p>这真是一个超级大的<strong>惊喜点</strong>！
大多数 AI 编程工具（包括 ChatGPT 网页版）都是你发个指令，它就直接闷头写代码，根本不管细节。
但装了 <strong>Everything Claude Code</strong> 后，它竟然懂得了**“需求调研”<strong>（Interview Mode）。它发现你的需求里没说清楚“游戏难度/地图大小”，于是它</strong>主动停下来询问你的偏好**。
这简直就是<strong>从“外包工”进化成了“产品经理”</strong>！
我把这关键的一步补充进教程，作为**“第三部分：实战演练”<strong>的</strong>第 3 小节**（把原来的“步步为营”顺延为第 4 小节）。</p>
<ol>
<li>
<h5 data-id="heading-11"><strong>架构师的“追问”：它竟然懂得抠细节！</strong></h5>
</li>
</ol>
<p>在生成初步计划后，最让我震惊的一幕发生了。Claude 并没有急着去写代码，而是发现我的需求里有一个模糊点：<strong>地图大小和游戏节奏</strong>。
于是，它主动发起了一个“交互式问卷”（如下图）：</p>
<ul>
<li>
<p>它问我：<strong>“你偏好什么样的网格大小？”</strong></p>
</li>
<li>
<p>并且给出了专业的选项分析：</p>
<ul>
<li>
<p><strong>20x20 (推荐)</strong>：经典手感。</p>
</li>
<li>
<p><strong>15x15</strong>：地图小，节奏快（适合急性子）。</p>
</li>
<li>
<p><strong>25x25</strong>：地图大，难度高（适合高手）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fd1cdf0585d4f68a6b46e4e5f70cb1b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=VxKlpwiD9KBQHAqJSFYX1ehlUIk%3D" alt="" loading="lazy"/></p>
<p><strong>📝 操作方法：</strong> 在这个界面，你可以用上下键选择，或者直接回车选择它推荐的 <strong><code>&gt; 1. 20x20 格子 (推荐)</code></strong>。
<strong>为什么要强调这一点？</strong> 这证明了 Everything Claude Code 的 <code>planner</code> 智能体具有<strong>批判性思维</strong>。它知道“模糊的需求”会导致“垃圾的代码”，所以它要在动工前把所有细节都敲定。这就是为什么用它写出来的程序 Bug 极少的原因。</p>
<h3 data-id="heading-12">4.交棒时刻：从“设计”到“施工”</h3>
<p>当你在屏幕上看到详细的 <strong>最终方案总结</strong>，并且 Claude 询问 <code>Exit plan mode?</code> 时，说明规划阶段完美结束。
<strong>确认退出</strong>： 直接选择 <strong><code>&gt; 1. Yes</code></strong> 并回车。
<strong>⚠️ 注意：</strong> 这里不需要你再输入“开始写代码”之类的指令。Claude 非常聪明，它知道你退出规划模式就是为了去执行。 一旦你按下回车，你会发现它<strong>立刻</strong>抛出了第一个文件的代码（通常是 <code>index.html</code>），并请求创建文件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b55ee0608db049fcb783da3c739f494e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2FgD1V%2FhAD2zRoHwR9FeqHyWwBN8%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">5.关键技巧：如何“一键授权”所有文件？</h3>
<p>现在 Claude 已经把 <code>index.html</code> 的代码写好了（如下图所示），它停下来问你：</p>
<blockquote>
<p><strong>"Do you want to create index.html?"</strong></p>
</blockquote>
<p>这里有一个<strong>省时 90% 的老手技巧</strong>！
因为我们的贪吃蛇游戏有 3 个文件（HTML, CSS, JS），如果你选第一个选项 <code>Yes</code>，它每写一个文件都会停下来问你一次，非常啰嗦。
<strong>✅ 推荐操作：选择“全权委托”</strong> 请按下键盘的 <strong><code>Shift + Tab</code></strong> 键（或者用方向键下移），选中第二个选项： <strong><code>&gt; 2. Yes, allow all edits during this session</code></strong>
<strong>意思是：</strong> “好的，不仅这个文件可以写，接下来本次会话里所有的文件修改，我都授权给你，别再烦我了。”</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/685ff6b1bdf44ca19e38d068fcd36652~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Vc7eekvO2n1Pth21PSV8nqL7TSM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-14">6.见证成果</h3>
<p>当你授权后，你会看到屏幕上代码飞速滚动。几秒钟后，Claude 会告诉你所有文件都创建完毕。 这时候，你可以直接去你的项目文件夹里打开 <code>index.html</code>，一个只有 20KB 大小、界面现代、手感丝滑的贪吃蛇游戏就已经躺在那里了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/86d834045fcb48cb8334b4ee134316b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Uy3qW18talEpKTBXWxnWYU6jE9g%3D" alt="" loading="lazy"/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f203bebae4514d03931aa428331648e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=qHoy3OFdKBtAiaE%2BaDFnJ7XqSXo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-15">第四部分：结语</h2>
<p>当你按下回车，看着 <code>index.html</code> 里那个运行完美的贪吃蛇游戏时，恭喜你，你的 Claude Code 已经完成了“进化”。
<strong>Everything Claude Code</strong> 带来的改变是本质的：</p>
<ol>
<li>
<p><strong>告别“盲写”</strong>：通过 <strong><code>/plan</code></strong> <strong>架构模式</strong>，它学会了先思考、再确认细节（甚至还会问你网格大小偏好）、最后才动工。</p>
</li>
<li>
<p><strong>告别“失忆”</strong>：不用再反复喂提示词，<strong>Hooks</strong> 会自动把项目背景写入 <code>.claudememory</code>，让它像老员工一样永远记得你的项目细节。</p>
</li>
<li>
<p><strong>告别“调教”</strong>：它记住了你的 <code>npm</code> 配置和代码规范，上手就是熟练工。</p>
</li>
</ol>
<p><strong>原生的 Claude Code 是一把好剑，而这套配置就是绝世剑法。</strong>
现在，去试试比贪吃蛇更复杂的项目吧，看看这位“资深 AI 工程师”还能给你带来多少惊喜！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OpenClaw 入门实战：5分钟搭建你的自托管 AI 助手]]></title>    <link>https://juejin.cn/post/7605810996125351970</link>    <guid>https://juejin.cn/post/7605810996125351970</guid>    <pubDate>2026-02-13T04:05:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125351970" data-draft-id="7605810996125335586" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OpenClaw 入门实战：5分钟搭建你的自托管 AI 助手"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T04:05:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="陈广亮"/> <meta itemprop="url" content="https://juejin.cn/user/3139860937575934"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OpenClaw 入门实战：5分钟搭建你的自托管 AI 助手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860937575934/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    陈广亮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:05:40.000Z" title="Fri Feb 13 2026 04:05:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近在研究如何更高效地使用 AI 助手，发现了一个很有意思的开源项目：<strong>OpenClaw</strong>。它能让你在 Telegram、WhatsApp、Discord 等各种 App 里直接跟 Claude 对话，而且完全由你自己掌控。今天就来分享一下如何从零搭建你的第一个 OpenClaw AI 助手。</p>
<h2 data-id="heading-0">OpenClaw 是什么？</h2>
<p>简单说，<strong>OpenClaw 是一个自托管的 AI 代理网关</strong>。它帮你把 Claude、GPT 等 AI 模型接入到各种消息平台，让你可以像跟朋友聊天一样跟 AI 交互。</p>
<h3 data-id="heading-1">核心特性</h3>
<ul>
<li><strong>多渠道支持</strong>：Telegram、WhatsApp、Discord、Slack 等主流平台</li>
<li><strong>自托管架构</strong>：所有数据留在你自己的服务器上</li>
<li><strong>灵活配置</strong>：支持多个 Agent、自定义工具、记忆管理</li>
<li><strong>开箱即用</strong>：内置 Web 控制面板，配置简单</li>
</ul>
<h3 data-id="heading-2">为什么选择自托管？</h3>
<p>很多人可能会问：市面上已经有 ChatGPT、Claude.ai 这些现成服务了，为什么还要自己搭建？</p>
<p><strong>数据隐私</strong>：所有对话记录、配置信息都存储在你自己的设备上，不会被第三方收集。</p>
<p><strong>完全可控</strong>：想换模型就换模型，想接入哪个平台就接入哪个平台，不受平台限制。</p>
<p><strong>成本透明</strong>：直接调用 API，按实际用量付费，不用担心订阅费用。</p>
<p><strong>功能自由</strong>：可以自定义工具、配置记忆系统、接入本地服务，玩法更多。</p>
<p>对于开发者和注重隐私的用户来说，自托管是个更好的选择。</p>
<h2 data-id="heading-3">快速安装（macOS）</h2>
<p>下面以 macOS 为例，演示如何安装 OpenClaw。其他系统的安装方法类似，可以参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2Finstall" target="_blank" title="https://openclaw.ai/install" ref="nofollow noopener noreferrer">官方文档</a>。</p>
<h3 data-id="heading-4">前置条件</h3>
<p>在开始之前，确保你的系统满足以下条件：</p>
<ol>
<li>
<p><strong>Node.js 22+</strong>：OpenClaw 基于 Node.js 运行</p>
<pre><code class="hljs language-bash" lang="bash">node --version  <span class="hljs-comment"># 检查版本，应该 &gt;= 22</span>
</code></pre>
<p>如果版本不够，建议用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnvm-sh%2Fnvm" target="_blank" title="https://github.com/nvm-sh/nvm" ref="nofollow noopener noreferrer">nvm</a> 安装最新版。</p>
</li>
<li>
<p><strong>Anthropic API Key</strong>：你需要一个 Claude 的 API 密钥</p>
<ul>
<li>前往 <a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.anthropic.com%2F" target="_blank" title="https://console.anthropic.com/" ref="nofollow noopener noreferrer">Anthropic Console</a> 注册账号</li>
<li>在 API Keys 页面创建新密钥</li>
<li>记下这个密钥，稍后会用到</li>
</ul>
</li>
</ol>
<h3 data-id="heading-5">一键安装</h3>
<p>OpenClaw 提供了非常方便的一键安装脚本：</p>
<pre><code class="hljs language-bash" lang="bash">curl -fsSL https://openclaw.ai/install.sh | bash
</code></pre>
<p>这个脚本会自动下载并安装 OpenClaw CLI。安装完成后，验证一下：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw --version
</code></pre>
<h3 data-id="heading-6">运行配置向导</h3>
<p>安装好之后，运行配置向导来初始化你的 Gateway：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw onboard --install-daemon
</code></pre>
<p>向导会引导你完成以下配置：</p>
<ol>
<li><strong>选择模型提供商</strong>：选择 Anthropic（Claude）</li>
<li><strong>输入 API Key</strong>：粘贴你刚才获取的 Anthropic API Key</li>
<li><strong>配置 Gateway 端口</strong>：默认 18789，一般不用改</li>
<li><strong>选择渠道</strong>：暂时先跳过，我们后面手动配置 Telegram</li>
</ol>
<p>向导运行完成后，OpenClaw Gateway 会自动启动。</p>
<h2 data-id="heading-7">配置你的第一个 Telegram Bot</h2>
<p>接下来是最有趣的部分：创建一个 Telegram bot，让它接入你的 OpenClaw Gateway。</p>
<h3 data-id="heading-8">1. 通过 @BotFather 创建 Bot</h3>
<p>打开 Telegram，搜索 <strong>@BotFather</strong>（Telegram 官方的 bot 管理工具），然后：</p>
<ol>
<li>发送 <code>/newbot</code> 命令</li>
<li>输入你的 bot 名称，比如：<code>My OpenClaw Assistant</code></li>
<li>输入 bot 的用户名（必须以 <code>bot</code> 结尾），比如：<code>my_openclaw_bot</code></li>
<li>创建成功后，<strong>BotFather 会给你一个 Token</strong>，类似：
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">7123456789:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw</span>
</code></pre>
<strong>务必保存好这个 Token</strong>！</li>
</ol>
<h3 data-id="heading-9">2. 配置 OpenClaw</h3>
<p>现在需要把你的 Telegram bot 接入 OpenClaw。编辑配置文件：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config edit
</code></pre>
<p>在配置文件中找到 <code>channels.telegram</code> 部分，添加你的 bot 配置：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">channels:</span>
  <span class="hljs-attr">telegram:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">accounts:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">my-bot</span>
        <span class="hljs-attr">token:</span> <span class="hljs-string">"7123456789:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw"</span>
        <span class="hljs-attr">agent:</span> <span class="hljs-string">main</span>
</code></pre>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>id</code>：给这个 bot 取个内部标识符，随便起名</li>
<li><code>token</code>：刚才从 BotFather 获得的 bot token</li>
<li><code>agent</code>：指定使用哪个 Agent（默认的 <code>main</code> agent 就够用）</li>
</ul>
<p>保存配置后，重启 Gateway 让配置生效：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart
</code></pre>
<h3 data-id="heading-10">3. 启动验证</h3>
<p>检查 Gateway 状态，确保一切正常：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway status
</code></pre>
<p>你应该能看到类似这样的输出：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">✓</span> <span class="hljs-string">Gateway</span> <span class="hljs-string">is</span> <span class="hljs-string">running</span>
  <span class="hljs-attr">PID:</span> <span class="hljs-number">12345</span>
  <span class="hljs-attr">Port:</span> <span class="hljs-number">18789</span>
  <span class="hljs-attr">Uptime:</span> <span class="hljs-string">5s</span>
</code></pre>
<h2 data-id="heading-11">测试你的 Bot</h2>
<p>现在万事俱备，来测试一下你的 AI 助手吧！</p>
<h3 data-id="heading-12">发送第一条消息</h3>
<ol>
<li>打开 Telegram，搜索你刚才创建的 bot（用户名）</li>
<li>点击 <strong>Start</strong> 或发送 <code>/start</code></li>
<li>发送一条消息，比如：<code>你好，介绍一下你自己</code></li>
</ol>
<p>如果一切顺利，你的 bot 应该会回复你！这就是 Claude 通过 OpenClaw Gateway 在响应。</p>
<h3 data-id="heading-13">查看实时日志</h3>
<p>想看到 Gateway 内部发生了什么？打开日志监控：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw logs --follow
</code></pre>
<p>这会实时显示所有请求、响应、错误信息，方便调试。</p>
<h3 data-id="heading-14">使用 Web 控制面板</h3>
<p>OpenClaw 还提供了一个很实用的 Web 控制面板。打开浏览器访问：</p>
<pre><code class="hljs language-arduino" lang="arduino">http:<span class="hljs-comment">//localhost:18789</span>
</code></pre>
<p>在控制面板里，你可以：</p>
<ul>
<li>查看所有对话历史</li>
<li>手动测试对话（不需要通过 Telegram）</li>
<li>查看系统状态和配置</li>
<li>管理多个 Agent</li>
</ul>
<p>这是最方便的调试工具，强烈推荐试试。</p>
<h2 data-id="heading-15">常见问题</h2>
<p><strong>Q: Bot 没有回复怎么办？</strong></p>
<p>检查以下几点：</p>
<ol>
<li><code>openclaw gateway status</code> 确认 Gateway 正在运行</li>
<li><code>openclaw logs --follow</code> 查看是否有错误信息</li>
<li>确认 Telegram token 配置正确</li>
<li>确认 Anthropic API Key 有效且有余额</li>
</ol>
<p><strong>Q: 想让 Bot 更智能怎么办？</strong></p>
<p>OpenClaw 支持自定义 Agent 配置，可以给 Agent 添加记忆、工具、自定义 prompt 等。这些高级功能我会在下一篇文章详细介绍。</p>
<p><strong>Q: 可以同时配置多个 Bot 吗？</strong></p>
<p>当然可以！在 <code>channels.telegram.accounts</code> 数组里添加多个配置即可，每个 bot 可以指定不同的 agent。</p>
<h2 data-id="heading-16">下一步</h2>
<p>恭喜你！现在你已经成功搭建了一个完全由你掌控的 AI 助手。</p>
<p>如果你想进一步探索 OpenClaw 的强大功能，可以关注我接下来的系列文章：</p>
<ul>
<li><strong>多 Agent 配置</strong>：为不同场景创建专用助手（工作、娱乐、学习）</li>
<li><strong>工具集成</strong>：让 AI 能执行命令、搜索网页、管理文件</li>
<li><strong>记忆系统</strong>：让 AI 记住你的偏好和历史对话</li>
</ul>
<p>也可以直接查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2F" target="_blank" title="https://openclaw.ai/" ref="nofollow noopener noreferrer">OpenClaw 官方文档</a> 了解更多高级用法。</p>
<p>如果在搭建过程中遇到任何问题，欢迎在评论区留言交流。</p>
<hr/>
<p><strong>相关资源</strong>：</p>
<ul>
<li>OpenClaw 官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2F" target="_blank" title="https://openclaw.ai/" ref="nofollow noopener noreferrer">openclaw.ai/</a></li>
<li>GitHub 仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenclaw%2Fopenclaw" target="_blank" title="https://github.com/openclaw/openclaw" ref="nofollow noopener noreferrer">github.com/openclaw/op…</a></li>
<li>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2Fdocs" target="_blank" title="https://openclaw.ai/docs" ref="nofollow noopener noreferrer">openclaw.ai/docs</a></li>
<li>Anthropic API：<a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.anthropic.com%2F" target="_blank" title="https://console.anthropic.com/" ref="nofollow noopener noreferrer">console.anthropic.com/</a></li>
</ul>
<hr/>
<blockquote>
<p>原文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fchenguangliang.com%2Fposts%2Fopenclaw-getting-started" target="_blank" title="https://chenguangliang.com/posts/openclaw-getting-started" ref="nofollow noopener noreferrer">chenguangliang.com/posts/openc…</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[令牌环式同步扩展]]></title>    <link>https://juejin.cn/post/7605816833191870464</link>    <guid>https://juejin.cn/post/7605816833191870464</guid>    <pubDate>2026-02-13T05:05:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605816833191870464" data-draft-id="7605772919224959010" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="令牌环式同步扩展"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T05:05:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="guchen66"/> <meta itemprop="url" content="https://juejin.cn/user/3191200923270394"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            令牌环式同步扩展
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3191200923270394/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    guchen66
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:05:08.000Z" title="Fri Feb 13 2026 05:05:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">令牌环式同步扩展：从 Ping-Pong 到 ABC 交替执行</h2>
<p>在上一篇博客中，我们介绍了六种实现两个线程交替执行的方法。本文将作为扩展，探讨如何将这些实现方式改造为三个线程交替执行 "A"、"B"、"C"，形成 "ABCABC..." 的环形序列。</p>
<h3 data-id="heading-1">问题描述</h3>
<p>实现三个线程交替打印 "A"、"B"、"C"，共打印 100 轮，形成 "ABCABC..." 的交替序列。</p>
<h3 data-id="heading-2">六种实现方式的改造分析</h3>
<h4 data-id="heading-3">1. ManualResetEvent / AutoResetEvent 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-scss" lang="scss">internal class ABC_EventTestCode
{
    public static void <span class="hljs-built_in">Print</span>()
    {
        <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = new <span class="hljs-built_in">AutoResetEvent</span>(true);  <span class="hljs-comment">// A 初始可用</span>
        <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = new <span class="hljs-built_in">AutoResetEvent</span>(false); <span class="hljs-comment">// B 初始不可用</span>
        <span class="hljs-selector-tag">var</span> c = new <span class="hljs-built_in">AutoResetEvent</span>(false); <span class="hljs-comment">// C 初始不可用</span>
​
        <span class="hljs-comment">// 线程 A</span>
        Task<span class="hljs-selector-class">.Run</span>(() =&gt;
        {
            for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.WaitOne</span>();    <span class="hljs-comment">// 等待 A 信号</span>
                Console<span class="hljs-selector-class">.WriteLine</span>("A");
                <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.Set</span>();        <span class="hljs-comment">// 释放 B 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        Task<span class="hljs-selector-class">.Run</span>(() =&gt;
        {
            for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.WaitOne</span>();    <span class="hljs-comment">// 等待 B 信号</span>
                Console<span class="hljs-selector-class">.WriteLine</span>("B");
                c<span class="hljs-selector-class">.Set</span>();        <span class="hljs-comment">// 释放 C 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        Task<span class="hljs-selector-class">.Run</span>(() =&gt;
        {
            for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                c<span class="hljs-selector-class">.WaitOne</span>();    <span class="hljs-comment">// 等待 C 信号</span>
                Console<span class="hljs-selector-class">.WriteLine</span>("C");
                <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.Set</span>();        <span class="hljs-comment">// 释放 A 信号，形成闭环</span>
            }
        });
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>AutoResetEvent</code> 对象，初始状态分别为 <code>true</code>（A 可用）、<code>false</code>（B 不可用）和 <code>false</code>（C 不可用）</li>
<li>每个线程执行前调用 <code>WaitOne()</code> 等待信号</li>
<li>执行完成后，通过 <code>Set()</code> 通知下一个线程，最后一个线程通知第一个线程形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 改造简单，逻辑清晰</li>
<li>✅ AutoResetEvent 自动重置，无需手动调用 Reset()</li>
<li>✅ 适用于传统同步场景</li>
<li>❌ 不支持异步编程，会阻塞线程</li>
<li>❌ ManualResetEvent 需要手动 Reset，三个信号时容易漏掉</li>
</ul>
<h4 data-id="heading-4">2. SemaphoreSlim 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_SemaphoreSlimTestCode</span>
{
    <span class="hljs-comment">// A 初始可用(1)，B、C 初始不可用(0)</span>
    <span class="hljs-keyword">private</span> SemaphoreSlim semA = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> SemaphoreSlim semB = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> SemaphoreSlim semC = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
​
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span>
    {
        <span class="hljs-comment">// 线程 A</span>
        Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> semA.WaitAsync();   <span class="hljs-comment">// 等待 A 信号</span>
                Console.WriteLine(<span class="hljs-string">"A"</span>);
                semB.Release();           <span class="hljs-comment">// 释放 B 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> semB.WaitAsync();   <span class="hljs-comment">// 等待 B 信号</span>
                Console.WriteLine(<span class="hljs-string">"B"</span>);
                semC.Release();           <span class="hljs-comment">// 释放 C 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> semC.WaitAsync();   <span class="hljs-comment">// 等待 C 信号</span>
                Console.WriteLine(<span class="hljs-string">"C"</span>);
                semA.Release();           <span class="hljs-comment">// 释放 A 信号，形成闭环</span>
            }
        });
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>SemaphoreSlim</code> 对象，初始计数分别为 1（A 可用）、0（B 不可用）和 0（C 不可用）</li>
<li>每个线程执行前调用 <code>WaitAsync()</code> 等待信号</li>
<li>执行完成后，通过 <code>Release()</code> 增加下一个信号量的计数，最后一个线程释放第一个信号量形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 改造简单，代码简洁</li>
<li>✅ 支持异步编程，使用 <code>await</code> 语法更现代</li>
<li>✅ 轻量级，性能较好</li>
<li>✅ 最适合 ABC 场景，代码清晰易维护</li>
<li>✅ 支持超时和取消操作</li>
</ul>
<h4 data-id="heading-5">3. TaskCompletionSource 实现</h4>
<p><strong>改造难度：⭐⭐⭐ 中等</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_TaskCompletionSourceTestCode</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintAsync</span>()</span>
    {
        <span class="hljs-keyword">var</span> tcsA = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
        <span class="hljs-keyword">var</span> tcsB = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
        <span class="hljs-keyword">var</span> tcsC = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
​
        <span class="hljs-comment">// 初始让 A 可以执行</span>
        tcsA.SetResult(<span class="hljs-literal">true</span>);
​
        <span class="hljs-comment">// 线程 A</span>
        <span class="hljs-keyword">var</span> taskA = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> tcsA.Task;     <span class="hljs-comment">// 等待 A 信号</span>
                Console.WriteLine(<span class="hljs-string">"A"</span>);
                tcsA = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
                tcsB.SetResult(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 B 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        <span class="hljs-keyword">var</span> taskB = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> tcsB.Task;     <span class="hljs-comment">// 等待 B 信号</span>
                Console.WriteLine(<span class="hljs-string">"B"</span>);
                tcsB = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
                tcsC.SetResult(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 C 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        <span class="hljs-keyword">var</span> taskC = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> tcsC.Task;     <span class="hljs-comment">// 等待 C 信号</span>
                Console.WriteLine(<span class="hljs-string">"C"</span>);
                tcsC = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
                tcsA.SetResult(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 A 可以执行，形成闭环</span>
            }
        });
​
        <span class="hljs-keyword">await</span> Task.WhenAll(taskA, taskB, taskC);
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>TaskCompletionSource</code> 对象</li>
<li>初始时，将 A 的任务标记为完成，允许 A 立即执行</li>
<li>每个线程执行前等待对应的 <code>Task</code> 完成</li>
<li>执行完成后，创建新的 <code>TaskCompletionSource</code> 对象，并将下一个线程的任务标记为完成，最后一个线程通知第一个线程形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 支持异步编程模型</li>
<li>✅ 可以传递实际数据，不仅仅是信号</li>
<li>❌ 每次迭代都需要创建三个新的 <code>TaskCompletionSource</code> 对象，内存开销较大</li>
<li>❌ 代码相对复杂，需要理解异步编程模型</li>
<li>❌ 对于纯信号控制场景，有点杀鸡用牛刀</li>
</ul>
<h4 data-id="heading-6">4. Channel 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_ChannelTestCode</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintAsync</span>()</span>
    {
        <span class="hljs-keyword">var</span> chA = Channel.CreateUnbounded&lt;<span class="hljs-built_in">bool</span>&gt;();
        <span class="hljs-keyword">var</span> chB = Channel.CreateUnbounded&lt;<span class="hljs-built_in">bool</span>&gt;();
        <span class="hljs-keyword">var</span> chC = Channel.CreateUnbounded&lt;<span class="hljs-built_in">bool</span>&gt;();
​
        <span class="hljs-comment">// 初始让 A 可以执行</span>
        <span class="hljs-keyword">await</span> chA.Writer.WriteAsync(<span class="hljs-literal">true</span>);
​
        <span class="hljs-comment">// 线程 A</span>
        <span class="hljs-keyword">var</span> taskA = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> chA.Reader.ReadAsync(); <span class="hljs-comment">// 等待 A 信号</span>
                Console.WriteLine(<span class="hljs-string">"A"</span>);
                <span class="hljs-keyword">await</span> chB.Writer.WriteAsync(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 B 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        <span class="hljs-keyword">var</span> taskB = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> chB.Reader.ReadAsync(); <span class="hljs-comment">// 等待 B 信号</span>
                Console.WriteLine(<span class="hljs-string">"B"</span>);
                <span class="hljs-keyword">await</span> chC.Writer.WriteAsync(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 C 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        <span class="hljs-keyword">var</span> taskC = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> chC.Reader.ReadAsync(); <span class="hljs-comment">// 等待 C 信号</span>
                Console.WriteLine(<span class="hljs-string">"C"</span>);
                <span class="hljs-keyword">await</span> chA.Writer.WriteAsync(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 A 可以执行，形成闭环</span>
            }
        });
​
        <span class="hljs-keyword">await</span> Task.WhenAll(taskA, taskB, taskC);
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>Channel</code> 对象创建无界通道</li>
<li>初始时，向 A 通道写入数据，允许 A 立即执行</li>
<li>每个线程从自己的通道读取数据（等待信号）</li>
<li>执行完成后，向下一个通道写入数据（发送信号），最后一个线程向第一个通道写入数据形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 现代异步编程模型，设计优雅</li>
<li>✅ 高性能，适合高并发场景</li>
<li>✅ 可以轻松扩展为传递复杂数据</li>
<li>❌ 需要 .NET Core 3.0+ 或 .NET 5+ 支持</li>
<li>❌ 对于纯信号控制场景，可能显得过于复杂</li>
</ul>
<h4 data-id="heading-7">5. Monitor/lock 实现</h4>
<p><strong>改造难度：⭐⭐⭐⭐ 困难</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">internal <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABC_MonitorLockTestCode</span>
{
    <span class="hljs-keyword">private</span> object lockObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0=A, 1=B, 2=C</span>
​
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// 线程 A</span>
        <span class="hljs-built_in">Task</span>.<span class="hljs-built_in">Run</span>(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">lock</span> (lockObj)
                {
                    <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">0</span>) <span class="hljs-comment">// 等待自己的回合</span>
                    {
                        Monitor.<span class="hljs-built_in">Wait</span>(lockObj); <span class="hljs-comment">// 释放锁并等待信号</span>
                    }
                    
                    <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">"A"</span>);
                    turn = <span class="hljs-number">1</span>; <span class="hljs-comment">// 切换到 B 回合</span>
                    Monitor.<span class="hljs-built_in">PulseAll</span>(lockObj); <span class="hljs-comment">// 唤醒所有等待的线程</span>
                }
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        <span class="hljs-built_in">Task</span>.<span class="hljs-built_in">Run</span>(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">lock</span> (lockObj)
                {
                    <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">1</span>) <span class="hljs-comment">// 等待自己的回合</span>
                    {
                        Monitor.<span class="hljs-built_in">Wait</span>(lockObj); <span class="hljs-comment">// 释放锁并等待信号</span>
                    }
                    
                    <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">"B"</span>);
                    turn = <span class="hljs-number">2</span>; <span class="hljs-comment">// 切换到 C 回合</span>
                    Monitor.<span class="hljs-built_in">PulseAll</span>(lockObj); <span class="hljs-comment">// 唤醒所有等待的线程</span>
                }
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        <span class="hljs-built_in">Task</span>.<span class="hljs-built_in">Run</span>(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">lock</span> (lockObj)
                {
                    <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">2</span>) <span class="hljs-comment">// 等待自己的回合</span>
                    {
                        Monitor.<span class="hljs-built_in">Wait</span>(lockObj); <span class="hljs-comment">// 释放锁并等待信号</span>
                    }
                    
                    <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">"C"</span>);
                    turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// 切换到 A 回合，形成闭环</span>
                    Monitor.<span class="hljs-built_in">PulseAll</span>(lockObj); <span class="hljs-comment">// 唤醒所有等待的线程</span>
                }
            }
        });
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用一个共享的 <code>lockObj</code> 作为同步对象</li>
<li>使用一个整数变量 <code>turn</code> 来跟踪当前应该执行的线程（0=A, 1=B, 2=C）</li>
<li>每个线程在执行前检查是否是自己的回合，如果不是则等待</li>
<li>执行完成后，切换回合状态并唤醒所有等待的线程</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 不需要额外的同步原语，只使用 .NET 内置的 Monitor 机制</li>
<li>❌ 改造复杂，代码冗长</li>
<li>❌ 不支持异步编程，会阻塞线程</li>
<li>❌ 需要使用 <code>PulseAll()</code> 唤醒所有线程，性能较差</li>
<li>❌ 三个线程竞争锁，容易导致不必要的唤醒</li>
<li>❌ 代码复杂度指数增长，难以维护</li>
</ul>
<h4 data-id="heading-8">6. 混合方案：流水线 Channel 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_PipelineChannelTestCode</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintAsync</span>()</span>
    {
        <span class="hljs-comment">// 创建两个通道，形成 A → B → C 的流水线</span>
        <span class="hljs-keyword">var</span> abChannel = Channel.CreateUnbounded&lt;<span class="hljs-built_in">string</span>&gt;();
        <span class="hljs-keyword">var</span> bcChannel = Channel.CreateUnbounded&lt;<span class="hljs-built_in">string</span>&gt;();
​
        <span class="hljs-comment">// 线程 A - 生产数据</span>
        <span class="hljs-keyword">var</span> taskA = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">string</span> data = <span class="hljs-string">$"A-<span class="hljs-subst">{i}</span>"</span>;
                Console.WriteLine(<span class="hljs-string">$"A: <span class="hljs-subst">{data}</span>"</span>);
                <span class="hljs-keyword">await</span> abChannel.Writer.WriteAsync(data); <span class="hljs-comment">// 传递给 B</span>
            }
            abChannel.Writer.Complete(); <span class="hljs-comment">// 完成写入</span>
        });
​
        <span class="hljs-comment">// 线程 B - 处理数据</span>
        <span class="hljs-keyword">var</span> taskB = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">await</span> <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> data <span class="hljs-keyword">in</span> abChannel.Reader.ReadAllAsync())
            {
                <span class="hljs-built_in">string</span> processedData = <span class="hljs-string">$"B-<span class="hljs-subst">{data}</span>"</span>;
                Console.WriteLine(<span class="hljs-string">$"B: <span class="hljs-subst">{processedData}</span>"</span>);
                <span class="hljs-keyword">await</span> bcChannel.Writer.WriteAsync(processedData); <span class="hljs-comment">// 传递给 C</span>
            }
            bcChannel.Writer.Complete(); <span class="hljs-comment">// 完成写入</span>
        });
​
        <span class="hljs-comment">// 线程 C - 消费数据</span>
        <span class="hljs-keyword">var</span> taskC = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">await</span> <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> data <span class="hljs-keyword">in</span> bcChannel.Reader.ReadAllAsync())
            {
                <span class="hljs-built_in">string</span> finalData = <span class="hljs-string">$"C-<span class="hljs-subst">{data}</span>"</span>;
                Console.WriteLine(<span class="hljs-string">$"C: <span class="hljs-subst">{finalData}</span>"</span>);
            }
        });
​
        <span class="hljs-keyword">await</span> Task.WhenAll(taskA, taskB, taskC);
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用两个 <code>Channel</code> 对象创建流水线</li>
<li>线程 A 生产数据并写入第一个通道</li>
<li>线程 B 从第一个通道读取数据，处理后写入第二个通道</li>
<li>线程 C 从第二个通道读取数据并消费</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 非常适合需要传递数据的场景</li>
<li>✅ 现代异步编程模型，设计优雅</li>
<li>✅ 高性能，适合高并发场景</li>
<li>✅ 代码逻辑清晰，易于理解</li>
<li>❌ 对于纯信号控制场景，可能显得过于复杂</li>
<li>❌ 需要 .NET Core 3.0+ 或 .NET 5+ 支持</li>
</ul>
<h3 data-id="heading-9">实现方式对比</h3>















































<table><thead><tr><th>实现方式</th><th>改造难度</th><th>ABC 适合度</th><th>推荐场景</th></tr></thead><tbody><tr><td>AutoResetEvent</td><td>⭐⭐</td><td>⭐⭐⭐</td><td>传统同步，无 async/await</td></tr><tr><td>SemaphoreSlim</td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>现代异步，首选</td></tr><tr><td>TaskCompletionSource</td><td>⭐⭐⭐</td><td>⭐⭐</td><td>需传递复杂数据</td></tr><tr><td>Channel</td><td>⭐⭐</td><td>⭐⭐⭐</td><td>高并发+数据传递</td></tr><tr><td>Monitor/lock</td><td>⭐⭐⭐⭐</td><td>⭐</td><td>简单场景，避免多信号</td></tr><tr><td>流水线 Channel</td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>数据流转（A→B→C）</td></tr></tbody></table>
<h3 data-id="heading-10">通用模式：扩展到 N 个线程</h3>
<p>使用 <code>SemaphoreSlim</code> 可以很容易地扩展到 N 个线程的交替执行。以下是一个通用的实现模式：</p>
<pre><code class="hljs language-ini" lang="ini">internal class NThreadsSemaphoreSlimTestCode
{
    private List&lt;SemaphoreSlim&gt; semaphores<span class="hljs-comment">;</span>
    private int threadCount<span class="hljs-comment">;</span>
​
    public NThreadsSemaphoreSlimTestCode(int count)
    {
        <span class="hljs-attr">threadCount</span> = count<span class="hljs-comment">;</span>
        <span class="hljs-attr">semaphores</span> = new List&lt;SemaphoreSlim&gt;()<span class="hljs-comment">;</span>
        
        // 初始化信号量，第一个初始可用，其余初始不可用
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++)</span>
        {
            semaphores.Add(new SemaphoreSlim(<span class="hljs-attr">i</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
        }
    }
​
    public void Print()
    {
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; threadCount; i++)</span>
        {
            int <span class="hljs-attr">threadIndex</span> = i<span class="hljs-comment">;</span>
            char <span class="hljs-attr">threadChar</span> = (char)(<span class="hljs-string">'A'</span> + threadIndex)<span class="hljs-comment">;</span>
            
            Task.Run(async () =&gt;
            {
                for (int <span class="hljs-attr">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; 100; j++)</span>
                {
                    // 等待自己的信号
                    await semaphores<span class="hljs-section">[threadIndex]</span>.WaitAsync()<span class="hljs-comment">;</span>
                    Console.WriteLine(threadChar)<span class="hljs-comment">;</span>
                    
                    // 释放下一个线程的信号，最后一个线程释放第一个线程的信号
                    int <span class="hljs-attr">nextIndex</span> = (threadIndex + <span class="hljs-number">1</span>) % threadCount<span class="hljs-comment">;</span>
                    semaphores<span class="hljs-section">[nextIndex]</span>.Release()<span class="hljs-comment">;</span>
                }
            })<span class="hljs-comment">;</span>
        }
    }
}
​
// 使用示例：
// var <span class="hljs-attr">nThreadsTest</span> = new NThreadsSemaphoreSlimTestCode(<span class="hljs-number">5</span>)<span class="hljs-comment">; // 5个线程，交替打印 ABCDE</span>
// nThreadsTest.Print()<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-11">结论</h3>
<p>从两种线程扩展到三种线程（ABC）的交替执行，不同实现方式的表现差异更加明显：</p>
<ol start="0">
<li><strong>SemaphoreSlim</strong> 仍然是最佳选择，代码简洁、支持异步、性能良好，尤其是在多线程场景下优势更加突出。</li>
<li><strong>AutoResetEvent</strong> 也是一个不错的选择，改造简单，适合传统同步场景。</li>
<li><strong>Channel</strong> 在需要传递数据的场景下表现优异，尤其是流水线模式非常适合数据处理流程。</li>
<li><strong>TaskCompletionSource</strong> 虽然可以实现，但在多线程场景下代码膨胀严重，内存开销较大。</li>
<li><strong>Monitor/lock</strong> 在多线程场景下表现最差，代码复杂，性能较差，不推荐使用。</li>
</ol>
<p>选择哪种实现方式，取决于具体的场景需求：</p>
<ul>
<li><strong>纯信号控制</strong>（ABCABC）：首选 <code>SemaphoreSlim</code>，代码最简洁，性能最好。</li>
<li><strong>需要传递数据</strong>：首选 <code>Channel</code> 流水线模式，尤其是在 A→B→C 需要处理数据的场景。</li>
<li><strong>传统同步场景</strong>：选择 <code>AutoResetEvent</code>，兼容性好，易于理解。</li>
<li><strong>特殊需求</strong>：根据具体情况选择其他实现方式。</li>
</ul>
<p>通过本文的扩展，我们可以看到令牌环式同步模式的灵活性和多样性，以及不同同步原语在不同场景下的适用情况。了解这些实现方式，有助于我们在实际项目中选择合适的同步机制，编写高效、可靠的并发代码。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite + Rollup 打包分包陷阱：依赖版本冲突与状态隔离问题]]></title>    <link>https://juejin.cn/post/7605769126272352302</link>    <guid>https://juejin.cn/post/7605769126272352302</guid>    <pubDate>2026-02-13T04:34:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605769126272352302" data-draft-id="7605856048361373734" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite + Rollup 打包分包陷阱：依赖版本冲突与状态隔离问题"/> <meta itemprop="keywords" content="前端框架"/> <meta itemprop="datePublished" content="2026-02-13T04:34:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户9823610790277"/> <meta itemprop="url" content="https://juejin.cn/user/545774580012813"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite + Rollup 打包分包陷阱：依赖版本冲突与状态隔离问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/545774580012813/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户9823610790277
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:34:16.000Z" title="Fri Feb 13 2026 04:34:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">问题背景</h2>
<p>在使用 Vite + Rollup 构建的 Vue 3 项目中，引入第三方组件库 <code>ai-agent</code> 后，发现开发环境正常运行，但生产环境打包上线后出现兼容性问题。</p>
<h2 data-id="heading-1">问题现象</h2>
<ul>
<li><strong>开发环境</strong>：一切正常，无任何错误</li>
<li><strong>生产环境</strong>：打包后运行时出现兼容性问题，功能异常</li>
<li><strong>临时解决方案</strong>：注释掉 [vite.config.ts] 中 manualChunks 对 <code>@vueuse/core</code> 和 [naive-ui] 的单独分包配置</li>
</ul>
<h2 data-id="heading-2">根本原因分析</h2>
<h3 data-id="heading-3">1. 开发环境 vs 生产环境差异</h3>























<table><thead><tr><th>环境</th><th>模块加载方式</th><th>manualChunks 生效</th><th>依赖解析</th></tr></thead><tbody><tr><td>开发环境</td><td>原生 ES Modules</td><td>❌ 不生效</td><td>动态解析，Node.js 模块机制</td></tr><tr><td>生产环境</td><td>Rollup 打包</td><td>✅ 生效</td><td>静态分析，按配置分包</td></tr></tbody></table>
<h3 data-id="heading-4">2. 依赖状态隔离问题</h3>
<p><strong>核心问题</strong>：具有内部状态的库被分到不同 chunk 后，造成状态不共享。</p>
<p>以 <code>@vueuse/core</code> 为例：</p>
<ul>
<li>包含全局状态（globalState）、缓存、事件监听器等</li>
<li>当被分到不同 chunk 时，每个 chunk 都有独立的状态实例</li>
<li>导致运行时行为不一致，甚至功能失效</li>
</ul>
<h3 data-id="heading-5">3. 版本兼容性风险</h3>
<p>虽然 <code>ai-agent</code> 和主项目可能使用兼容的依赖版本，但 manualChunks 强制分离会：</p>
<ul>
<li>破坏 Rollup 的自动去重机制</li>
<li>即使是同一版本，也被复制到不同 bundle</li>
<li>增加 bundle 体积，降低运行效率</li>
</ul>
<h2 data-id="heading-6">技术细节剖析</h2>
<h3 data-id="heading-7">正常情况（无 manualChunks）</h3>
<pre><code class="hljs language-bash" lang="bash">vendor.js
├── @vueuse/core (单例)
├── naive-ui (单例)  
├── ai-agent
└── 其他依赖
</code></pre>
<p>✅ 所有模块共享同一份依赖实例</p>
<h3 data-id="heading-8">问题情况（有 manualChunks）</h3>
<pre><code class="hljs language-bash" lang="bash">vueuse.js
└── @vueuse/core (实例A)

naive-ui.js  
└── naive-ui (实例A)

vendor.js
├── @vueuse/core (实例B) ← ai-agent 内部使用
├── naive-ui (实例B) ← ai-agent 内部使用
└── ai-agent
</code></pre>
<p>❌ 状态隔离，潜在冲突</p>
<h2 data-id="heading-9">解决方案</h2>
<h3 data-id="heading-10">方案一：保守策略（推荐）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-title function_">manualChunks</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"node_modules"</span>)) {
    <span class="hljs-comment">// 避免对可能引起状态冲突的库进行单独分包</span>
    <span class="hljs-comment">// 让它们统一打包到 vendor chunk 中</span>
    
    <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"await-to-js"</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"awaitToJs"</span>;
    }
    <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"axios"</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"axios"</span>;
    }
    <span class="hljs-comment">// ... 其他无状态的工具库</span>
    
    <span class="hljs-comment">// 不单独分包 @vueuse/core、naive-ui 等有状态库</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"vendor"</span>;
  }
}
</code></pre>
<h3 data-id="heading-11">方案二：精确控制策略</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 如果确实需要分包，确保版本完全一致</span>
<span class="hljs-keyword">const</span> sharedDeps = [
  <span class="hljs-string">'@vueuse/core'</span>,
  <span class="hljs-string">'naive-ui'</span>, 
  <span class="hljs-string">'vue'</span>
];

<span class="hljs-title function_">manualChunks</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"node_modules"</span>)) {
    <span class="hljs-comment">// 检查是否为共享依赖</span>
    <span class="hljs-keyword">const</span> sharedDep = sharedDeps.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">dep</span> =&gt;</span> id.<span class="hljs-title function_">includes</span>(dep));
    <span class="hljs-keyword">if</span> (sharedDep) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'shared'</span>; <span class="hljs-comment">// 统一放到 shared chunk</span>
    }
    
    <span class="hljs-comment">// 其他依赖正常分包</span>
    <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"lodash-es"</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"lodash"</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"vendor"</span>;
  }
}
</code></pre>
<h2 data-id="heading-12">最佳实践建议</h2>
<h3 data-id="heading-13">1. 分包原则</h3>
<ul>
<li><strong>可以分包</strong>：纯函数库（lodash-es、date-fns）、无状态工具库</li>
<li><strong>避免分包</strong>：UI 组件库、状态管理库、包含全局配置的库</li>
</ul>
<h3 data-id="heading-14">2. 依赖管理</h3>
<ul>
<li>保持项目依赖与第三方库依赖的版本兼容性</li>
<li>使用 <code>npm ls &lt;package&gt;</code> 检查依赖树</li>
<li>定期更新依赖，减少版本碎片化</li>
</ul>
<h3 data-id="heading-15">3. 调试技巧</h3>
<ul>
<li>使用 <a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">rollup-plugin-visualizer</a> 分析打包结果</li>
<li>在浏览器中检查模块的内存地址是否一致</li>
<li>对比开发环境和生产环境的网络请求和 bundle 内容</li>
</ul>
<h3 data-id="heading-16">4. 预防措施</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在 vite.config.ts 中添加注释说明</span>
<span class="hljs-comment">// 注意：由于第三方库可能依赖相同的基础库，</span>
<span class="hljs-comment">// 为避免状态隔离问题，暂不单独分包以下依赖：</span>
<span class="hljs-comment">// - @vueuse/core (包含全局状态)</span>
<span class="hljs-comment">// - naive-ui (UI 组件库，包含主题配置)</span>
</code></pre>
<p>这个问题完美展示了现代前端开发中，看似简单的配置可能带来的复杂运行时问题，也体现了深入理解工具链的重要性。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[设计模式的本质：隔离变化]]></title>    <link>https://juejin.cn/post/7605817795629269042</link>    <guid>https://juejin.cn/post/7605817795629269042</guid>    <pubDate>2026-02-13T05:37:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795629269042" data-draft-id="7605817795628187698" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="设计模式的本质：隔离变化"/> <meta itemprop="keywords" content="设计模式,后端"/> <meta itemprop="datePublished" content="2026-02-13T05:37:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LukeLi"/> <meta itemprop="url" content="https://juejin.cn/user/430664725579725"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            设计模式的本质：隔离变化
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664725579725/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LukeLi
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:37:18.000Z" title="Fri Feb 13 2026 05:37:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"> 设计模式的本质：隔离变化</h2>
<h3 data-id="heading-1">一、为什么要学设计模式？</h3>
<h4 data-id="heading-2">❓ 痛点：没有设计模式的代码有多痛苦？</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 地狱级 if-else（每次加新功能都要改核心）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Order order)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"NORMAL"</span>.equals(order.getType())) {
        <span class="hljs-comment">// 正常订单逻辑（50行）</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"VIP.equals(order.getType())) {
        // VIP 订单逻辑（60行）
    } else if ("</span>GROUP_BUY<span class="hljs-string">".equals(order.getType())) {
        // 拼团逻辑（70行）
    }
    // 老板说要加“预售”？再加一个 else if...
}
</span></code></pre>
<p>后果：</p>
<ul>
<li>
<p>🔥 改一处，崩三处（测试覆盖难）</p>
</li>
<li>
<p>🧩 无法复用（逻辑散落在各处）</p>
</li>
<li>
<p>👥 新人看不懂（协作成本高）</p>
</li>
</ul>
<h4 data-id="heading-3">✅ 优化后代码（策略模式）</h4>
<h5 data-id="heading-4">第1步：定义一个接口</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span>;
}
</code></pre>
<h5 data-id="heading-5">第2步：每种订单写一个类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 普通订单</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"NORMAL"</span>.equals(type);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"处理普通订单"</span>);
    }
}

<span class="hljs-comment">// VIP 订单</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"VIP"</span>.equals(type);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"处理VIP订单"</span>);
    }
}

<span class="hljs-comment">// 拼团订单</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupBuyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"GROUP_BUY"</span>.equals(type);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"处理拼团订单"</span>);
    }
}
</code></pre>
<h5 data-id="heading-6">第3步：主方法改成这样</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 把所有处理器放到一个列表里（实际项目中可用 Spring 自动注入）</span>
List&lt;OrderHandler&gt; handlers = Arrays.asList(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NormalOrderHandler</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VipOrderHandler</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupBuyHandler</span>()
);

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Order order)</span> {
    <span class="hljs-keyword">for</span> (OrderHandler handler : handlers) {
        <span class="hljs-keyword">if</span> (handler.supports(order.getType())) {
            handler.handle(order);
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"不支持的订单类型: "</span> + order.getType());
}
</code></pre>
<hr/>
<h4 data-id="heading-7">🎯 对比效果</h4>

























<table><thead><tr><th><strong>场景</strong></th><th><strong>原始代码</strong></th><th><strong>优化后代码</strong></th></tr></thead><tbody><tr><td>加“预售订单”</td><td>要改 <code>processOrder</code> 方法</td><td>只需新增一个 <code>PresaleOrderHandler</code> 类</td></tr><tr><td>代码结构</td><td>所有逻辑挤在一起</td><td>每种类型独立，清晰易读</td></tr><tr><td>测试</td><td>难以单独测某一种</td><td>每个 Handler 可单独测试</td></tr></tbody></table>
<p>💡 本质：把“会变的”封装起来，让“不变的”稳定运行</p>
<h3 data-id="heading-8">二、SOLID 原则：隔离变化的 5 条军规</h3>
<h4 data-id="heading-9">1. 单一职责（SRP）→ 一个类只干一件事</h4>
<ul>
<li>
<p>问题：UserService 既管用户信息，又发邮件、记日志</p>
</li>
<li>
<p>隔离变化：把“发邮件”、“记日志”拆出去</p>
</li>
<li>
<p>效果：改邮件逻辑不影响用户保存</p>
</li>
</ul>
<h4 data-id="heading-10">2. 开闭原则（OCP）→ 对扩展开放，对修改关闭</h4>
<ul>
<li>
<p>问题：加新支付方式要改 OrderService</p>
</li>
<li>
<p>隔离变化：用策略模式，新增类不改旧代码</p>
</li>
<li>
<p>效果：需求变，代码不动</p>
</li>
</ul>
<h4 data-id="heading-11">3. 里氏替换（LSP）→ 子类能无缝替换父类</h4>
<ul>
<li>
<p>问题：Square 继承 Rectangle，面积计算出错</p>
</li>
<li>
<p>隔离变化：正方形和矩形应为兄弟类，而非父子</p>
</li>
<li>
<p>效果：多态安全，不破坏原有逻辑</p>
</li>
</ul>
<h4 data-id="heading-12">4. 接口隔离（ISP）→ 客户端只依赖需要的接口</h4>
<ul>
<li>
<p>问题：Printer 被迫实现 fax() 方法</p>
</li>
<li>
<p>隔离变化：拆成 Printer/Scanner/Fax 小接口</p>
</li>
<li>
<p>效果：类只实现自己需要的功能</p>
</li>
</ul>
<h4 data-id="heading-13">5. 依赖倒置（DIP）→ 依赖抽象，不依赖具体</h4>
<ul>
<li>
<p>问题：OrderService 直接 new MySQLDatabase()</p>
</li>
<li>
<p>隔离变化：依赖 Database 接口，注入具体实现</p>
</li>
<li>
<p>效果：换 PostgreSQL？只需改配置！</p>
</li>
</ul>
<h3 data-id="heading-14">三、23 种设计模式：如何隔离变化？</h3>
<p>每个模式都回答一个问题：什么在变？怎么隔离？</p>
<h4 data-id="heading-15">🧱 创建型模式（5种）：隔离“对象创建”的变化</h4>









































<table><thead><tr><th><strong>模式</strong></th><th><strong>什么在变？</strong></th><th><strong>怎么隔离？</strong></th><th><strong>Spring Boot 实战</strong></th></tr></thead><tbody><tr><td>单例</td><td>全局唯一实例</td><td>私有构造 + 静态方法</td><td><code>@Component</code> + <code>@Scope("singleton")</code></td></tr><tr><td>工厂方法</td><td>创建哪种对象</td><td>子类决定</td><td><code>@Bean</code> 方法返回不同实现</td></tr><tr><td>抽象工厂</td><td>创建产品族</td><td>工厂接口</td><td>多数据源配置（MySQLFactory / PGFactory）</td></tr><tr><td>建造者</td><td>复杂对象构建步骤</td><td>分步构建</td><td><code>RestTemplateBuilder</code>, <code>WebClient.builder()</code></td></tr><tr><td>原型</td><td>对象初始化成本高</td><td>克隆现有对象</td><td><code>@Scope("prototype")</code> Bean</td></tr></tbody></table>
<p>✅ 核心：不让业务代码关心“对象怎么来”</p>
<h4 data-id="heading-16">🔗 结构型模式（7种）：隔离“结构组合”的变化</h4>





















































<table><thead><tr><th><strong>模式</strong></th><th><strong>什么在变？</strong></th><th><strong>怎么隔离？</strong></th><th><strong>Spring Boot 实战</strong></th></tr></thead><tbody><tr><td>适配器</td><td>接口不兼容</td><td>包装旧接口</td><td>集成第三方 SDK（如微信支付适配器）</td></tr><tr><td>装饰器</td><td>功能动态增减</td><td>包装增强</td><td><code>BufferedInputStream</code>, Spring Security 过滤器链</td></tr><tr><td>代理</td><td>控制对象访问</td><td>中介拦截</td><td>Spring AOP（事务、日志）、Feign Client</td></tr><tr><td>外观</td><td>子系统复杂</td><td>提供统一入口</td><td><code>@Service</code> 封装多个 Repository 调用</td></tr><tr><td>桥接</td><td>抽象与实现耦合</td><td>分离维度</td><td>日志框架（Logger + Appender）</td></tr><tr><td>组合</td><td>树形结构</td><td>统一处理</td><td>菜单权限树、组织架构树</td></tr><tr><td>享元</td><td>大量相似对象</td><td>共享内部状态</td><td>数据库连接池、线程池</td></tr></tbody></table>
<p>✅ 核心：不让调用方知道“内部怎么组合”</p>
<h4 data-id="heading-17">🔄 行为型模式（11种）：隔离“行为算法”的变化</h4>













































































<table><thead><tr><th><strong>模式</strong></th><th><strong>什么在变？</strong></th><th><strong>怎么隔离？</strong></th><th><strong>Spring Boot 实战</strong></th></tr></thead><tbody><tr><td>策略</td><td>算法选择</td><td>封装算法</td><td>支付方式、折扣计算、路由规则</td></tr><tr><td>观察者</td><td>事件通知</td><td>松耦合监听</td><td><code>ApplicationEventPublisher</code>, Spring 事件机制</td></tr><tr><td>责任链</td><td>请求处理链</td><td>传递处理</td><td>Spring Security Filter Chain、审批流</td></tr><tr><td>命令</td><td>请求封装</td><td>对象化请求</td><td>任务队列、撤销操作（如 Redis Queue）</td></tr><tr><td>状态</td><td>状态行为</td><td>状态驱动</td><td>订单状态机（待支付 → 已支付 → 已发货）</td></tr><tr><td>模板方法</td><td>算法骨架</td><td>固定流程</td><td><code>JdbcTemplate</code>, <code>RestTemplate</code></td></tr><tr><td>迭代器</td><td>遍历方式</td><td>统一访问</td><td><code>List.iterator()</code>, Stream API</td></tr><tr><td>中介者</td><td>对象交互</td><td>中心协调</td><td>消息总线、事件中心</td></tr><tr><td>备忘录</td><td>状态保存</td><td>快照恢复</td><td>游戏存档、表单草稿</td></tr><tr><td>访问者</td><td>新操作</td><td>外部定义</td><td>报表生成、AST 遍历</td></tr><tr><td>解释器</td><td>语法规则</td><td>解析执行</td><td>规则引擎（如 Drools）、简单表达式</td></tr></tbody></table>
<p>✅ 核心：不让主流程知道“具体怎么执行”</p>
<h3 data-id="heading-18">四、Spring Boot 中的最佳实践</h3>
<h4 data-id="heading-19">a、创建型模式（5种）</h4>
<h5 data-id="heading-20">1. 单例模式（Singleton）</h5>
<blockquote>
<p>隔离变化：全局唯一实例（如配置、工具类）<br/>
Spring 实现：默认所有 Bean 都是单例</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCacheService</span> {
    <span class="hljs-comment">// 整个应用只有一个实例</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> {
        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().get(key);
    }
}
</code></pre>
<p>✅ 效果：无需手动管理实例，Spring 自动保证单例。</p>
<h5 data-id="heading-21">2. 工厂方法模式（Factory Method）</h5>
<blockquote>
<p>隔离变化：对象创建逻辑<br/>
Spring 实现：<code>@Bean</code> 方法</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 定义接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Payment</span> {
    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回 "alipay" 或 "wechat"</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span>;
}

<span class="hljs-comment">// 2. 实现类</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alipay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"alipay"</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> { ... }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"wechat"</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> { ... }
}

<span class="hljs-comment">// 3. 策略工厂（自动注册）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentFactory</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Payment&gt; payments;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PaymentFactory</span><span class="hljs-params">(List&lt;Payment&gt; paymentList)</span> {
        <span class="hljs-built_in">this</span>.payments = paymentList.stream()
            .collect(Collectors.toMap(Payment::getType, p -&gt; p));
    }

    <span class="hljs-keyword">public</span> Payment <span class="hljs-title function_">get</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> payments.get(type);
    }
}

<span class="hljs-comment">// 4. 使用</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> PaymentFactory paymentFactory;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> paymentFactory.get(order.getPayType());
        payment.pay(order);
    }
}

</code></pre>
<p>✅ 效果：根据参数动态创建对象。</p>
<h5 data-id="heading-22">3. 抽象工厂模式（Abstract Factory）</h5>
<blockquote>
<p>隔离变化：产品族（如多环境数据源）<br/>
Spring 实现：Profile + 条件装配</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile("prod")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProdDatabaseFactory</span> {
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariDataSource</span>(); }
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource ds)</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(ds); }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile("test")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDatabaseFactory</span> {
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedDatabaseBuilder</span>().build(); }
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource ds)</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(ds); }
}
</code></pre>
<p>✅ 效果：整套组件一键切换，无需改业务代码。</p>
<h5 data-id="heading-23">4. 建造者模式（Builder）</h5>
<blockquote>
<p>隔离变化：复杂对象构建步骤<br/>
Spring 实现：<code>WebClient.builder()</code></p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApiService</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">this</span>.webClient = WebClient.builder()
            .baseUrl(<span class="hljs-string">"https://api.example.com"</span>)
            .defaultHeader(<span class="hljs-string">"User-Agent"</span>, <span class="hljs-string">"MyApp/1.0"</span>)
            .build();
    }

    <span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title function_">getData</span><span class="hljs-params">(String path)</span> {
        <span class="hljs-keyword">return</span> webClient.get().uri(path).retrieve().bodyToMono(String.class);
    }
}
</code></pre>
<p>✅ 效果：构建过程清晰，参数可选，避免构造函数爆炸。</p>
<hr/>
<h5 data-id="heading-24">5. 原型模式（Prototype）</h5>
<blockquote>
<p>隔离变化：高成本对象初始化<br/>
Spring 实现：<code>@Scope("prototype")</code></p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope("prototype")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderContext</span> {
    <span class="hljs-keyword">private</span> String orderId;
    <span class="hljs-keyword">private</span> <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">createTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderId</span><span class="hljs-params">(String id)</span> { <span class="hljs-built_in">this</span>.orderId = id; }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>✅ 效果：每次注入都是新实例，避免状态污染（如请求级上下文）。</p>
<h4 data-id="heading-25">b、结构型模式（7种）</h4>
<h5 data-id="heading-26">6. 适配器模式（Adapter）</h5>
<blockquote>
<p>隔离变化：第三方接口不兼容<br/>
Spring 实现：封装 SDK</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 第三方 SDK</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WxPaySDK</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String openid, <span class="hljs-type">double</span> amount)</span> { <span class="hljs-comment">/* 微信支付 */</span> }
}

<span class="hljs-comment">// 适配器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WxPayAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">WxPaySDK</span> <span class="hljs-variable">sdk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WxPaySDK</span>();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> {
        sdk.pay(order.getUser().getOpenid(), order.getAmount());
    }
}
</code></pre>
<p>✅ 效果：业务只依赖 <code>Payment</code> 接口，不关心微信细节。</p>
<h5 data-id="heading-27">7. 装饰器模式（Decorator）</h5>
<blockquote>
<p>隔离变化：功能动态增强<br/>
Spring 实现：AOP 或包装 Bean</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Primary</span> <span class="hljs-comment">// 优先注入</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingUserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService target;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoggingUserService</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("userServiceImpl")</span> UserService target)</span> {
        <span class="hljs-built_in">this</span>.target = target;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(Long id)</span> {
        log.info(<span class="hljs-string">"查询用户: {}"</span>, id);
        <span class="hljs-keyword">return</span> target.getUser(id); <span class="hljs-comment">// 增强原功能</span>
    }
}
</code></pre>
<p>✅ 效果：日志、缓存、限流等功能可叠加，不侵入核心逻辑。</p>
<h5 data-id="heading-28">8. 代理模式（Proxy）</h5>
<blockquote>
<p>隔离变化：控制对象访问（事务、安全等）<br/>
Spring 实现：Spring AOP（自动代理）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {

    <span class="hljs-meta">@Transactional</span> <span class="hljs-comment">// Spring 自动生成代理，开启事务</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        orderRepository.save(order);
        inventoryService.deduct(order.getItems());
    }
}
</code></pre>
<p>✅ 效果：事务、缓存、安全等横切关注点与业务完全解耦。</p>
<h5 data-id="heading-29">9. 外观模式（Facade）</h5>
<blockquote>
<p>隔离变化：子系统复杂性<br/>
Spring 实现：<code>@Service</code> 封装多个依赖</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFacade</span> {
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> OrderRepository orderRepo;
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> InventoryService inventory;
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> NotificationService notify;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderRepo.save(dto.toEntity());
        inventory.deduct(order.getItems());
        notify.send(order.getUser(), <span class="hljs-string">"下单成功"</span>);
    }
}
</code></pre>
<p>✅ 效果：调用方只需面对一个简单接口，内部复杂性被隐藏。</p>
<h5 data-id="heading-30">10. 桥接模式（Bridge）</h5>
<blockquote>
<p>隔离变化：抽象与实现紧耦合<br/>
两个维度的变化：</p>
</blockquote>
<blockquote>
<p>抽象维度（如：消息类型：通知、告警、营销）</p>
</blockquote>
<blockquote>
<p>实现维度（如：发送渠道：邮件、短信、微信）</p>
</blockquote>
<blockquote>
<p>组合而非继承：抽象持有实现的引用</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 实现维度：发送渠道</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageSender</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageSender</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> { System.out.println(<span class="hljs-string">"📧 邮件: "</span> + msg); }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageSender</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> { System.out.println(<span class="hljs-string">"📱 短信: "</span> + msg); }
}


<span class="hljs-comment">// 抽象维度：消息类型</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">protected</span> MessageSender sender; <span class="hljs-comment">// 持有实现的引用（桥接！）</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">this</span>.sender = sender;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span>;
}

<span class="hljs-comment">// 通知消息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotificationMessage</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">super</span>(sender);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span> {
        sender.send(<span class="hljs-string">"[通知] "</span> + content);
    }
}

<span class="hljs-comment">// 告警消息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlertMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlertMessage</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">super</span>(sender);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span> {
        sender.send(<span class="hljs-string">"[🚨 告警] "</span> + content);
    }
}

<span class="hljs-comment">// 营销消息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarketingMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarketingMessage</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">super</span>(sender);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span> {
        sender.send(<span class="hljs-string">"[🎁 营销] "</span> + content);
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> EmailSender emailSender;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> SmsSender smsSender;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 通知 + 邮件</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationMessage</span>(emailSender).send(<span class="hljs-string">"系统升级"</span>);

        <span class="hljs-comment">// 告警 + 短信</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertMessage</span>(smsSender).send(<span class="hljs-string">"CPU 使用率过高！"</span>);

        <span class="hljs-comment">// 营销 + 邮件</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarketingMessage</span>(emailSender).send(<span class="hljs-string">"双11大促开始了！"</span>);
    }
}



</code></pre>
<p>✅ 效果：发送方式和通知逻辑独立演进，互不影响。</p>
<h5 data-id="heading-31">11. 组合模式（Composite）</h5>
<blockquote>
<p>隔离变化：树形结构处理差异<br/>
Spring 实现：菜单/权限树</p>
</blockquote>
<ul>
<li>
<p>统一接口：单个（叶子）和组合（容器）都实现同一个接口</p>
</li>
<li>
<p>递归处理：组合对象调用自己内部每个子对象的相同方法</p>
</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuComponent</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 所有菜单元素（单个 or 组）都要能渲染</span>
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MenuItem</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MenuComponent</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"渲染菜单项"</span>); <span class="hljs-comment">// 就干这一件事</span>
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MenuGroup</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MenuComponent</span> {
    <span class="hljs-comment">// 存放子菜单（可以是 MenuItem，也可以是 MenuGroup！）</span>
    <span class="hljs-keyword">private</span> List&lt;MenuComponent&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addChild</span><span class="hljs-params">(MenuComponent child)</span> {
        children.add(child);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 关键！遍历所有子元素，调用它们的 render()</span>
        children.forEach(child -&gt; child.render());
    }
}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 创建根菜单组</span>
        <span class="hljs-type">MenuGroup</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuGroup</span>();

        <span class="hljs-comment">// 添加单个菜单项</span>
        root.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "首页"</span>
        root.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "关于我们"</span>

        <span class="hljs-comment">// 创建子菜单组</span>
        <span class="hljs-type">MenuGroup</span> <span class="hljs-variable">userMenu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuGroup</span>();
        userMenu.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "个人中心"</span>
        userMenu.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "退出登录"</span>

        <span class="hljs-comment">// 把子菜单组加入根菜单</span>
        root.addChild(userMenu);

        <span class="hljs-comment">// 渲染整个菜单！</span>
        root.render();
    }
}

</code></pre>
<p>✅ 效果：统一处理单个和组合对象，客户端无需区分。</p>
<h5 data-id="heading-32">12. 享元模式（Flyweight）</h5>
<blockquote>
<p>隔离变化：大量相似对象内存开销<br/>
享元模式 = 共享不变的部分 + 传递变化的部分</p>
</blockquote>
<blockquote>
<p>能有效解决 大量重复小对象导致的内存问题。</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 标签享元接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserTagFlyweight</span> {
    <span class="hljs-comment">/**
     * 显示标签（外部状态：userId, position）
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Long userId, String position)</span>;
}

<span class="hljs-comment">// 具体标签实现（内部状态：type, color, icon）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope("prototype")</span> <span class="hljs-comment">// 每次从工厂获取时由工厂控制，不是 Spring 管理单例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteUserTag</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserTagFlyweight</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;      <span class="hljs-comment">// 内部状态：标签类型（VIP/NEW/...）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String color;     <span class="hljs-comment">// 内部状态：颜色</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String icon;      <span class="hljs-comment">// 内部状态：图标</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteUserTag</span><span class="hljs-params">(String type, String color, String icon)</span> {
        <span class="hljs-built_in">this</span>.type = type;
        <span class="hljs-built_in">this</span>.color = color;
        <span class="hljs-built_in">this</span>.icon = icon;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Long userId, String position)</span> {
        System.out.printf(<span class="hljs-string">"[用户%d] 在 %s 显示标签: %s | 颜色=%s | 图标=%s%n"</span>, 
            userId, position, type, color, icon);
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTagFactory</span> {
    
    <span class="hljs-comment">// 享元池：缓存所有已创建的标签（内部状态作为 key）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, UserTagFlyweight&gt; tagPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();

    <span class="hljs-comment">/**
     * 获取标签（相同 type/color/icon 只创建一次）
     */</span>
    <span class="hljs-keyword">public</span> UserTagFlyweight <span class="hljs-title function_">getTag</span><span class="hljs-params">(String type, String color, String icon)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> type + <span class="hljs-string">"_"</span> + color + <span class="hljs-string">"_"</span> + icon;
        <span class="hljs-keyword">return</span> tagPool.computeIfAbsent(key, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteUserTag</span>(type, color, icon));
    }

    <span class="hljs-comment">// 用于监控</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPoolSize</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> tagPool.size();
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserTagFactory tagFactory;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renderUserTags</span><span class="hljs-params">(Long userId)</span> {
        <span class="hljs-comment">// 模拟用户拥有的标签（实际可能来自数据库）</span>
        List&lt;TagConfig&gt; userTags = getUserTagsFromDB(userId);

        <span class="hljs-keyword">for</span> (TagConfig config : userTags) {
            <span class="hljs-comment">// 从享元池获取标签（相同配置复用同一个对象）</span>
            <span class="hljs-type">UserTagFlyweight</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> tagFactory.getTag(
                config.getType(), 
                config.getColor(), 
                config.getIcon()
            );
            
            <span class="hljs-comment">// 显示标签（传入外部状态）</span>
            tag.display(userId, config.getPosition());
        }
    }

    <span class="hljs-comment">// 模拟数据库查询</span>
    <span class="hljs-keyword">private</span> List&lt;TagConfig&gt; <span class="hljs-title function_">getUserTagsFromDB</span><span class="hljs-params">(Long userId)</span> {
        <span class="hljs-keyword">return</span> Arrays.asList(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagConfig</span>(<span class="hljs-string">"VIP"</span>, <span class="hljs-string">"gold"</span>, <span class="hljs-string">"⭐"</span>, <span class="hljs-string">"header"</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagConfig</span>(<span class="hljs-string">"NEW"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"🆕"</span>, <span class="hljs-string">"profile"</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagConfig</span>(<span class="hljs-string">"VIP"</span>, <span class="hljs-string">"gold"</span>, <span class="hljs-string">"⭐"</span>, <span class="hljs-string">"sidebar"</span>) <span class="hljs-comment">// 和第一个相同！</span>
        );
    }

    <span class="hljs-comment">// 内部 DTO</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TagConfig</span> {
        String type, color, icon, position;
        TagConfig(String type, String color, String icon, String position) {
            <span class="hljs-built_in">this</span>.type = type; <span class="hljs-built_in">this</span>.color = color; <span class="hljs-built_in">this</span>.icon = icon; <span class="hljs-built_in">this</span>.position = position;
        }
        <span class="hljs-comment">// getter...</span>
    }
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserTagFactory tagFactory;

    <span class="hljs-meta">@GetMapping("/test")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"=== 渲染用户 1001 ==="</span>);
        userService.renderUserTags(<span class="hljs-number">1001L</span>);
        
        System.out.println(<span class="hljs-string">"=== 渲染用户 1002 ==="</span>);
        userService.renderUserTags(<span class="hljs-number">1002L</span>);
        
        System.out.println(<span class="hljs-string">"享元池大小: "</span> + tagFactory.getPoolSize()); <span class="hljs-comment">// 应该是 2（VIP 和 NEW）</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;
    }
}



</code></pre>
<p>✅ 效果：共享内部状态，大幅节省资源。</p>
<h4 data-id="heading-33">c、行为型模式（11种）</h4>
<h5 data-id="heading-34">13. 策略模式（Strategy）</h5>
<blockquote>
<p>隔离变化：算法选择（支付、折扣等）<br/>
Spring 实现：Map 自动注册（最常用！）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> {
    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;
    BigDecimal <span class="hljs-title function_">apply</span><span class="hljs-params">(Order order)</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"VIP"</span>; }
    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">apply</span><span class="hljs-params">(Order order)</span> { <span class="hljs-keyword">return</span> order.getAmount().multiply(BigDecimal.valueOf(<span class="hljs-number">0.9</span>)); }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HolidayDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"HOLIDAY"</span>; }
    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">apply</span><span class="hljs-params">(Order order)</span> { <span class="hljs-keyword">return</span> order.getAmount().multiply(BigDecimal.valueOf(<span class="hljs-number">0.8</span>)); }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, DiscountStrategy&gt; strategies;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscountService</span><span class="hljs-params">(List&lt;DiscountStrategy&gt; list)</span> {
        <span class="hljs-built_in">this</span>.strategies = list.stream()
            .collect(Collectors.toMap(DiscountStrategy::getType, s -&gt; s));
    }

    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculate</span><span class="hljs-params">(String type, Order order)</span> {
        <span class="hljs-keyword">return</span> strategies.get(type).apply(order);
    }
}
</code></pre>
<p>✅ 效果：新增折扣类型？只需写一个新类！零修改核心代码。</p>
<h5 data-id="heading-35">14. 观察者模式（Observer）</h5>
<blockquote>
<p>隔离变化：事件通知耦合<br/>
Spring 实现：<code>ApplicationEventPublisher</code>（最常用！）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 事件</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCreatedEvent</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Order order;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderCreatedEvent</span><span class="hljs-params">(Order order)</span> { <span class="hljs-built_in">this</span>.order = order; }
    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> order; }
}

<span class="hljs-comment">// 发布</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> ApplicationEventPublisher publisher;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        orderRepository.save(order);
        publisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(order)); <span class="hljs-comment">// 发布事件</span>
    }
}

<span class="hljs-comment">// 监听</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsListener</span> {
    <span class="hljs-meta">@EventListener</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        sendSms(event.getOrder().getUser(), <span class="hljs-string">"下单成功"</span>);
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PointsListener</span> {
    <span class="hljs-meta">@EventListener</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        addPoints(event.getOrder().getUser());
    }
}
</code></pre>
<p>✅ 效果：新增“发券”？加一个 Listener 即可！完全解耦。</p>
<h5 data-id="heading-36">15. 责任链模式（Chain of Responsibility）</h5>
<blockquote>
<p>隔离变化：请求处理流程<br/>
Spring 实现：Filter Chain / 手动链</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthHandler</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthHandler next;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AuthHandler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> AuthHandler next)</span> {
        <span class="hljs-built_in">this</span>.next = next;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Request req)</span> {
        <span class="hljs-keyword">if</span> (!checkAuth(req)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> next == <span class="hljs-literal">null</span> || next.handle(req); <span class="hljs-comment">// 传递</span>
    }
}

<span class="hljs-comment">// 配置链</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChainConfig</span> {
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> AuthHandler <span class="hljs-title function_">authChain</span><span class="hljs-params">(RateLimitHandler rateLimit, LogHandler log)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimitHandler</span>(log));
    }
}
</code></pre>
<p>✅ 效果：动态增减处理环节，流程灵活可配。</p>
<h5 data-id="heading-37">16. 命令模式（Command）</h5>
<blockquote>
<p>隔离变化：请求封装（支持撤销/队列）<br/>
Spring 实现：任务队列</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 定义命令接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span>;
}

<span class="hljs-comment">// 定义 Receiver（真正干活的）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderReceiver</span> {
    
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-comment">// 完整业务逻辑：校验、保存、发事件...</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(dto);
        orderRepository.save(order);
    }

    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelOrder</span><span class="hljs-params">(Long orderId)</span> {
        orderRepository.deleteById(orderId);
    }
}

<span class="hljs-comment">// 命令只保存指令参数（不是实体！）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope("prototype")</span> <span class="hljs-comment">// 每次需要新实例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateOrderCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderReceiver receiver;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderDTO orderData; <span class="hljs-comment">// 只存必要参数</span>
    <span class="hljs-keyword">private</span> Long createdOrderId; <span class="hljs-comment">// 用于 undo</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CreateOrderCommand</span><span class="hljs-params">(OrderReceiver receiver, OrderDTO orderData)</span> {
        <span class="hljs-built_in">this</span>.receiver = receiver;
        <span class="hljs-built_in">this</span>.orderData = orderData;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 执行并记录结果（用于 undo）</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(orderData);
        orderRepository.save(order);
        <span class="hljs-built_in">this</span>.createdOrderId = order.getId(); <span class="hljs-comment">// 保存 ID 用于撤销</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (createdOrderId != <span class="hljs-literal">null</span>) {
            receiver.cancelOrder(createdOrderId);
        }
    }
}

<span class="hljs-comment">// 命令工厂（避免手动 new）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandFactory</span> {
    
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> OrderReceiver orderReceiver;

    <span class="hljs-keyword">public</span> Command <span class="hljs-title function_">createOrderCommand</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateOrderCommand</span>(orderReceiver, dto);
    }
}

<span class="hljs-comment">// Invoker（命令调度器）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandInvoker</span> {
    
    <span class="hljs-comment">// 同步执行</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Command command)</span> {
        command.execute();
    }

    <span class="hljs-comment">// 异步执行（存入队列）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submitAsync</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-comment">// 只存 DTO 到 Redis（可序列化！）</span>
        redisTemplate.opsForList().leftPush(<span class="hljs-string">"order-commands"</span>, dto);
    }

    <span class="hljs-comment">// 消费队列（在消费者服务中）</span>
    <span class="hljs-meta">@Scheduled(fixedDelay = 1000)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processQueue</span><span class="hljs-params">()</span> {
        <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> redisTemplate.opsForList().rightPop(<span class="hljs-string">"order-commands"</span>, OrderDTO.class);
        <span class="hljs-keyword">if</span> (dto != <span class="hljs-literal">null</span>) {
            <span class="hljs-type">Command</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> commandFactory.createOrderCommand(dto);
            cmd.execute(); <span class="hljs-comment">// 执行命令</span>
        }
    }
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> {
    
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> CommandFactory commandFactory;
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> CommandInvoker invoker;

    <span class="hljs-meta">@PostMapping("/orders")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrderDTO dto)</span> {
        <span class="hljs-comment">// 方式1：同步执行 + 支持撤销</span>
        <span class="hljs-type">Command</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> commandFactory.createOrderCommand(dto);
        invoker.execute(cmd);
        
        <span class="hljs-comment">// 可保存 cmd 到 session，后续调用 cmd.undo() 撤销</span>
        
        <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;
    }

    <span class="hljs-meta">@PostMapping("/orders/async")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createOrderAsync</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrderDTO dto)</span> {
        <span class="hljs-comment">// 方式2：异步执行</span>
        invoker.submitAsync(dto);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Submitted"</span>;
    }
}




</code></pre>
<p>✅ 效果：请求可存储、可撤销、可异步执行。</p>
<h5 data-id="heading-38">17. 状态模式（State）</h5>
<blockquote>
<p>隔离变化：状态行为差异<br/>
Spring 实现：订单状态机</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderState</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">(Order order)</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaidState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">"已支付"</span>); }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">(Order order)</span> { order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShippedState</span>()); }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">(Long orderId)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> repo.findById(orderId);
        order.getState().ship(order); <span class="hljs-comment">// 状态驱动行为</span>
    }
}
</code></pre>
<p>✅ 效果：避免巨型 if-else，状态行为清晰隔离。</p>
<h5 data-id="heading-39">18. 模板方法模式（Template Method）</h5>
<blockquote>
<p>隔离变化：算法骨架 vs 具体步骤<br/>
Spring 实现：<code>JdbcTemplate</code>（最经典！）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
        loadData();    <span class="hljs-comment">// 固定</span>
        parseData();   <span class="hljs-comment">// 固定</span>
        saveData();    <span class="hljs-comment">// 钩子（子类实现）</span>
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">()</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DataProcessor</span> {
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">()</span> { <span class="hljs-comment">/* 保存 CSV */</span> }
}
</code></pre>
<p>✅ 效果：复用流程，定制细节，符合开闭原则。</p>
<hr/>
<h5 data-id="heading-40">19. 迭代器模式（Iterator）</h5>
<blockquote>
<p>隔离变化：遍历方式<br/>
Spring 实现：Stream API / Repository</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 用户组（聚合对象）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGroup</span> {
    <span class="hljs-keyword">private</span> List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> {
        users.add(user);
    }

    <span class="hljs-comment">// 关键：提供 iterator() 方法</span>
    <span class="hljs-keyword">public</span> Iterator&lt;User&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> users.iterator(); <span class="hljs-comment">// 返回 JDK 内置的迭代器</span>
    }
}

<span class="hljs-comment">// 2. 使用迭代器（客户端不关心内部结构）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processAllUsers</span><span class="hljs-params">(UserGroup group)</span> {
        <span class="hljs-comment">// 显式使用 Iterator</span>
        Iterator&lt;User&gt; it = group.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()) {
            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> it.next();
            process(user);
        }
    }
}

</code></pre>
<p>✅ 效果：统一访问聚合对象，客户端无需知道内部结构。</p>
<h5 data-id="heading-41">20. 中介者模式（Mediator）</h5>
<blockquote>
<p>隔离变化：对象间复杂交互<br/>
Spring 实现：事件总线 / 服务协调</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 用户（Colleague）—— 它们本来想直接通信！</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> ChatRoomMediator mediator; <span class="hljs-comment">// 只依赖中介者</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, ChatRoomMediator mediator)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.mediator = mediator;
    }

    <span class="hljs-comment">// 发消息（不直接发给其他人！）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> {
        mediator.sendMessage(msg, <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String msg)</span> {
        System.out.println(name + <span class="hljs-string">" 收到: "</span> + msg);
    }
}

<span class="hljs-comment">// 中介者（Mediator）—— 协调通信</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoomMediator</span> {
    <span class="hljs-keyword">private</span> List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> {
        users.add(user);
    }

    <span class="hljs-comment">// 关键：中介者决定谁收到消息</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String msg, User sender)</span> {
        <span class="hljs-keyword">for</span> (User user : users) {
            <span class="hljs-keyword">if</span> (user != sender) { <span class="hljs-comment">// 不发给自己</span>
                user.receive(sender.getName() + <span class="hljs-string">": "</span> + msg);
            }
        }
    }
}

<span class="hljs-type">ChatRoomMediator</span> <span class="hljs-variable">chat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoomMediator</span>();

<span class="hljs-type">User</span> <span class="hljs-variable">alice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Alice"</span>, chat);
<span class="hljs-type">User</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Bob"</span>, chat);

chat.addUser(alice);
chat.addUser(bob);

alice.send(<span class="hljs-string">"你好！"</span>); 
<span class="hljs-comment">// 输出: Bob 收到: Alice: 你好！</span>

</code></pre>
<p>✅ 效果：对象不直接通信，降低耦合，便于测试。</p>
<h5 data-id="heading-42">21. 备忘录模式（Memento）</h5>
<blockquote>
<p>隔离变化：内部状态保存/恢复<br/>
Spring 实现：表单草稿</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 要保存状态的对象（比如订单）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">"草稿"</span>;

    <span class="hljs-comment">// 保存当前状态</span>
    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">save</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(status);
    }

    <span class="hljs-comment">// 恢复到之前的状态</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(Memento m)</span> {
        <span class="hljs-built_in">this</span>.status = m.status;
    }
}

<span class="hljs-comment">// 2. 备忘录（快照）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> {
    String status;
    Memento(String status) {
        <span class="hljs-built_in">this</span>.status = status;
    }
}

<span class="hljs-comment">// 3. 使用示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();

        <span class="hljs-comment">// 1. 保存当前状态（草稿）</span>
        <span class="hljs-type">Memento</span> <span class="hljs-variable">draft</span> <span class="hljs-operator">=</span> order.save();

        <span class="hljs-comment">// 2. 修改状态</span>
        order.status = <span class="hljs-string">"已提交"</span>;
        System.out.println(<span class="hljs-string">"当前状态: "</span> + order.status); <span class="hljs-comment">// 已提交</span>

        <span class="hljs-comment">// 3. 恢复到草稿</span>
        order.restore(draft);
        System.out.println(<span class="hljs-string">"恢复后: "</span> + order.status); <span class="hljs-comment">// 草稿</span>
    }
}

</code></pre>
<p>✅ 效果：支持回滚、草稿、快照，不破坏封装性。</p>
<h5 data-id="heading-43">22. 访问者模式（Visitor）</h5>
<blockquote>
<p>隔离变化：新操作 vs 对象结构<br/>
Spring 实现：报表生成</p>
</blockquote>
<ul>
<li>
<p>Element（元素）：你的数据结构（比如订单、用户、商品）</p>
</li>
<li>
<p>Visitor（访问者）：想对这些数据做不同操作的人（比如生成 PDF、发邮件、统计报表）</p>
</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1.定义“数据”（Element）</span>
<span class="hljs-comment">// 所有能被访问的数据都要实现这个接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>; <span class="hljs-comment">// 接受访问者</span>
}

<span class="hljs-comment">// 订单数据</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> {
    <span class="hljs-keyword">private</span> String id;
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;

    <span class="hljs-comment">// 关键：把自己交给访问者</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> {
        visitor.visit(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 注意：this 是 Order 类型！</span>
    }
    
    <span class="hljs-comment">// getter...</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> id; }
    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> amount; }
}

<span class="hljs-comment">// 2.定义“操作”（Visitor）</span>
<span class="hljs-comment">// 所有操作都要实现这个接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span>; <span class="hljs-comment">// 专门处理 Order</span>
    <span class="hljs-comment">// 如果还有 User，就加 void visit(User user);</span>
}

<span class="hljs-comment">// 操作1：生成 PDF 报表</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfReportVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"生成 PDF 报表: 订单 "</span> + order.getId());
        <span class="hljs-comment">// 实际：用 iText 生成 PDF</span>
    }
}

<span class="hljs-comment">// 操作2：发送通知（新增！）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"发短信通知: 订单金额 "</span> + order.getAmount());
    }
}


<span class="hljs-comment">// 3. 使用方式</span>
<span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">"1001"</span>, <span class="hljs-number">99.9</span>);

<span class="hljs-comment">// 想生成 PDF？</span>
<span class="hljs-type">PdfReportVisitor</span> <span class="hljs-variable">pdfVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfReportVisitor</span>();
order.accept(pdfVisitor); <span class="hljs-comment">// 输出：生成 PDF 报表: 订单 1001</span>

<span class="hljs-comment">// 想发短信？</span>
<span class="hljs-type">SmsVisitor</span> <span class="hljs-variable">smsVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsVisitor</span>();
order.accept(smsVisitor); <span class="hljs-comment">// 输出：发短信通知: 订单金额 99.9</span>

</code></pre>
<p>✅ 效果：新增报表类型不改 Order 类，符合开闭原则。</p>
<h5 data-id="heading-44">23. 解释器模式（Interpreter）</h5>
<blockquote>
<p>隔离变化：语法规则解析<br/>
Spring 友好：用 <code>@Component</code> 管理基础规则</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 表达式接口（解释器核心）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span>;
}

<span class="hljs-comment">// 2. 基础条件：年龄 &gt; 18</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-keyword">return</span> user.getAge() &gt; <span class="hljs-number">18</span>;
    }
}

<span class="hljs-comment">// 3. 基础条件：是 VIP</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-keyword">return</span> user.isVip();
    }
}

<span class="hljs-comment">// 4. 组合规则：AND</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RuleExpression left, right;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndRule</span><span class="hljs-params">(RuleExpression left, RuleExpression right)</span> {
        <span class="hljs-built_in">this</span>.left = left;
        <span class="hljs-built_in">this</span>.right = right;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-keyword">return</span> left.interpret(user) &amp;&amp; right.interpret(user);
    }
}

<span class="hljs-comment">// 5. 使用（在 Service 中组合规则）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> AgeRule ageRule;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> VipRule vipRule;

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canAccessPremium</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-comment">// 手动组合：age &gt; 18 AND vip == true</span>
        <span class="hljs-type">RuleExpression</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndRule</span>(ageRule, vipRule);
        <span class="hljs-keyword">return</span> rule.interpret(user);
    }
}
</code></pre>
<p>✅ 效果：“组合对象 + interpret()” 就是解释器模式的核心思想。</p>
<h3 data-id="heading-45">五、总结：设计模式不是银弹，而是“隔离变化”的工具箱</h3>
<h4 data-id="heading-46">📌 记住三句话：</h4>
<ol>
<li>
<p>“会变的”和“不变的”必须分开</p>
<ul>
<li>
<p>支付方式会变 → 抽成策略</p>
</li>
<li>
<p>日志逻辑会变 → 用 AOP 代理</p>
</li>
<li>
<p>通知渠道会变 → 用观察者</p>
</li>
</ul>
</li>
<li>
<p>SOLID 是隔离变化的操作手册</p>
<ul>
<li>
<p>单一职责 → 别让一个类干太多</p>
</li>
<li>
<p>开闭原则 → 新需求别改老代码</p>
</li>
<li>
<p>依赖倒置 → 依赖接口，不依赖实现</p>
</li>
</ul>
</li>
<li>
<p>Spring Boot 天然支持设计模式</p>
<ul>
<li>
<p><code>@Component</code> = 工厂</p>
</li>
<li>
<p>AOP = 代理</p>
</li>
<li>
<p>事件 = 观察者</p>
</li>
<li>
<p><code>@Bean</code> = 策略注册</p>
</li>
</ul>
</li>
</ol>
<p>“好的代码，不是写出来的，而是‘隔离’出来的。”</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让JDK 8成就Web神话的核心特性]]></title>    <link>https://juejin.cn/post/7605810996125515810</link>    <guid>https://juejin.cn/post/7605810996125515810</guid>    <pubDate>2026-02-13T05:45:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125515810" data-draft-id="7605542907119386676" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让JDK 8成就Web神话的核心特性"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T05:45:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="日月云棠"/> <meta itemprop="url" content="https://juejin.cn/user/420442283981488"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让JDK 8成就Web神话的核心特性
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/420442283981488/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    日月云棠
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:45:19.000Z" title="Fri Feb 13 2026 05:45:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JDK 8 特性详解</h2>
<h3 data-id="heading-1">1. 概述</h3>
<p>JDK 8（2014年3月发布）是Java历史上最重要的版本之一，引入了大量革命性的特性，彻底改变了Java的编程方式。这些特性不仅使代码更简洁、更易读，还显著提升了性能和开发效率。</p>
<h3 data-id="heading-2">2. 核心特性详解</h3>
<h4 data-id="heading-3">2.1 Lambda表达式</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>Lambda表达式允许将函数作为方法参数传递，支持函数式编程风格</li>
<li>减少了匿名内部类的模板代码，使代码更简洁</li>
<li>编译时生成 <code>invokedynamic</code> 指令，比匿名内部类更高效</li>
</ul>
<p><strong>语法格式：</strong></p>
<pre><code class="hljs language-java" lang="java">(参数列表) -&gt; 表达式或代码块
</code></pre>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 传统方式 - 匿名内部类</span>
<span class="hljs-type">Runnable</span> <span class="hljs-variable">traditionalRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"传统方式执行"</span>);
    }
};

<span class="hljs-comment">// Lambda方式 - 更简洁</span>
<span class="hljs-type">Runnable</span> <span class="hljs-variable">lambdaRunnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">"Lambda方式执行"</span>);

<span class="hljs-comment">// 执行</span>
traditionalRunnable.run();  <span class="hljs-comment">// 输出: 传统方式执行</span>
lambdaRunnable.run();       <span class="hljs-comment">// 输出: Lambda方式执行</span>

<span class="hljs-comment">// 集合排序的Lambda应用</span>
List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"赵六"</span>);

<span class="hljs-comment">// Lambda排序方式</span>
Collections.sort(names, (a, b) -&gt; a.compareTo(b));

<span class="hljs-comment">// 更简洁的方法引用</span>
Collections.sort(names, String::compareTo);
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>避免了匿名内部类的对象创建开销</li>
<li>减少了字节码大小</li>
<li>运行时通过 <code>invokedynamic</code> 指令动态链接，执行效率更高</li>
<li>内存占用更小，垃圾回收压力减轻</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>事件处理</li>
<li>集合操作</li>
<li>函数式接口实现</li>
<li>并行处理</li>
</ul>
<h4 data-id="heading-4">2.2 Stream API</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>支持链式操作的函数式数据处理</li>
<li>提供了丰富的中间操作和终端操作</li>
<li>支持串行和并行处理</li>
<li>延迟执行，只有在终端操作时才会真正执行</li>
</ul>
<p><strong>核心操作类型：</strong></p>
<ul>
<li><strong>中间操作</strong>：返回Stream，可链式调用（如filter、map、sorted）</li>
<li><strong>终端操作</strong>：返回非Stream结果，触发实际执行（如collect、forEach、reduce）</li>
</ul>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Stream方式：筛选偶数并计算平方</span>
List&lt;Integer&gt; resultStream = numbers.stream()
        .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)      <span class="hljs-comment">// 过滤偶数</span>
        .map(n -&gt; n * n)              <span class="hljs-comment">// 计算平方</span>
        .collect(Collectors.toList()); <span class="hljs-comment">// 收集结果</span>

System.out.println(<span class="hljs-string">"Stream方式结果: "</span> + resultStream); <span class="hljs-comment">// 输出: [4, 16, 36, 64, 100]</span>

<span class="hljs-comment">// 统计操作</span>
<span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">stats</span> <span class="hljs-operator">=</span> numbers.stream()
        .mapToInt(Integer::intValue)
        .summaryStatistics();

System.out.println(<span class="hljs-string">"统计信息: "</span> + stats);
System.out.println(<span class="hljs-string">"平均值: "</span> + stats.getAverage());
System.out.println(<span class="hljs-string">"最大值: "</span> + stats.getMax());

<span class="hljs-comment">// 分组操作</span>
Map&lt;String, List&lt;Integer&gt;&gt; grouped = numbers.stream()
        .collect(Collectors.groupingBy(
                n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">"偶数"</span> : <span class="hljs-string">"奇数"</span>
        ));

System.out.println(<span class="hljs-string">"分组结果: "</span> + grouped); <span class="hljs-comment">// 输出: {奇数=[1, 3, 5, 7, 9], 偶数=[2, 4, 6, 8, 10]}</span>
</code></pre>
<p><strong>并行流处理：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 并行流处理</span>
List&lt;Integer&gt; parallelResult = numbers.parallelStream()
        .filter(n -&gt; n &gt; <span class="hljs-number">5</span>)
        .map(n -&gt; n * <span class="hljs-number">2</span>)
        .sorted()
        .collect(Collectors.toList());

System.out.println(<span class="hljs-string">"并行处理结果: "</span> + parallelResult); <span class="hljs-comment">// 输出: [12, 14, 16, 18, 20]</span>
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>并行流自动利用ForkJoinPool，充分发挥多核CPU性能</li>
<li>惰性计算减少了不必要的中间结果存储</li>
<li>内部迭代比外部迭代更高效，减少了循环开销</li>
<li>优化的流水线处理，减少了内存访问</li>
<li>对于大数据集，并行处理可显著提升性能</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>大数据集处理</li>
<li>复杂的数据转换和过滤</li>
<li>统计分析</li>
<li>并行计算</li>
</ul>
<h4 data-id="heading-5">2.3 新日期时间API</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>基于ISO-8601标准设计</li>
<li>所有类都是不可变的，线程安全</li>
<li>清晰的API设计，区分日期、时间、日期时间、时区等概念</li>
<li>支持流畅的方法链调用</li>
</ul>
<p><strong>核心类：</strong></p>
<ul>
<li><code>LocalDate</code>：表示日期（年、月、日）</li>
<li><code>LocalTime</code>：表示时间（时、分、秒、纳秒）</li>
<li><code>LocalDateTime</code>：表示日期时间</li>
<li><code>ZonedDateTime</code>：表示带时区的日期时间</li>
<li><code>Duration</code>：表示时间间隔</li>
<li><code>Period</code>：表示日期间隔</li>
<li><code>DateTimeFormatter</code>：日期时间格式化</li>
</ul>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 新版日期时间API</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">currentDate</span> <span class="hljs-operator">=</span> LocalDate.now();
<span class="hljs-type">LocalTime</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> LocalTime.now();
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">currentDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();

System.out.println(<span class="hljs-string">"当前日期: "</span> + currentDate);
System.out.println(<span class="hljs-string">"当前时间: "</span> + currentTime);
System.out.println(<span class="hljs-string">"当前日期时间: "</span> + currentDateTime);

<span class="hljs-comment">// 日期操作</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">tomorrow</span> <span class="hljs-operator">=</span> currentDate.plusDays(<span class="hljs-number">1</span>);
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextWeek</span> <span class="hljs-operator">=</span> currentDate.plusWeeks(<span class="hljs-number">1</span>);
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextMonth</span> <span class="hljs-operator">=</span> currentDate.plusMonths(<span class="hljs-number">1</span>);

System.out.println(<span class="hljs-string">"明天: "</span> + tomorrow);
System.out.println(<span class="hljs-string">"下周: "</span> + nextWeek);
System.out.println(<span class="hljs-string">"下月: "</span> + nextMonth);

<span class="hljs-comment">// 日期比较</span>
<span class="hljs-type">boolean</span> <span class="hljs-variable">isBefore</span> <span class="hljs-operator">=</span> tomorrow.isBefore(nextWeek);
System.out.println(<span class="hljs-string">"明天是否在下周之前: "</span> + isBefore); <span class="hljs-comment">// 输出: true</span>

<span class="hljs-comment">// 日期格式化</span>
<span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> currentDateTime.format(formatter);
System.out.println(<span class="hljs-string">"格式化日期: "</span> + formatted);

<span class="hljs-comment">// 时区处理</span>
<span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zonedDateTime</span> <span class="hljs-operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="hljs-string">"America/New_York"</span>));
System.out.println(<span class="hljs-string">"纽约时间: "</span> + zonedDateTime);

<span class="hljs-comment">// 持续时间计算</span>
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.now();
<span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);
System.out.println(<span class="hljs-string">"从2024年开始已经过去了: "</span> + duration.toDays() + <span class="hljs-string">" 天"</span>);
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>不可变设计避免了线程同步开销</li>
<li>比旧版Date/Calendar更高效，减少了对象创建</li>
<li>优化的格式化和解析算法</li>
<li>时区处理更高效，基于IANA时区数据库</li>
<li>清晰的API设计减少了错误使用</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>日期时间计算和比较</li>
<li>时区转换</li>
<li>日期时间格式化和解析</li>
<li>时间间隔计算</li>
</ul>
<h4 data-id="heading-6">2.4 接口默认方法和静态方法</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>允许接口中包含带有实现的默认方法</li>
<li>支持接口演进，不破坏现有实现类</li>
<li>接口中可以定义静态方法</li>
</ul>
<p><strong>语法格式：</strong></p>
<pre><code class="hljs language-java" lang="java">interface 接口名 {
    <span class="hljs-comment">// 抽象方法</span>
    返回类型 方法名(参数列表);
    
    <span class="hljs-comment">// 默认方法</span>
    <span class="hljs-keyword">default</span> 返回类型 方法名(参数列表) {
        <span class="hljs-comment">// 实现</span>
    }
    
    <span class="hljs-comment">// 静态方法</span>
    <span class="hljs-keyword">static</span> 返回类型 方法名(参数列表) {
        <span class="hljs-comment">// 实现</span>
    }
}
</code></pre>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 接口默认方法示例</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;
    <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;

    <span class="hljs-comment">// 默认方法 - 接口可以提供实现</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a * b;
    }

    <span class="hljs-comment">// 另一个默认方法</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> {
        <span class="hljs-keyword">return</span> multiply(a, a);
    }

    <span class="hljs-comment">// 静态方法 - 接口中的工具方法</span>
    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getVersion</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Calculator v1.0"</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a - b;
    }

    <span class="hljs-comment">// 不需要实现默认方法，可以直接使用</span>
    <span class="hljs-comment">// 也可以选择重写默认方法</span>
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicCalculator</span>();
System.out.println(<span class="hljs-string">"加法: "</span> + calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
System.out.println(<span class="hljs-string">"减法: "</span> + calculator.subtract(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
System.out.println(<span class="hljs-string">"乘法: "</span> + calculator.multiply(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
System.out.println(<span class="hljs-string">"默认方法平方: "</span> + calculator.square(<span class="hljs-number">5</span>));
System.out.println(<span class="hljs-string">"静态方法版本: "</span> + Calculator.getVersion());
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>避免了为扩展功能而创建的适配器类</li>
<li>减少了类层次结构的复杂性</li>
<li>默认方法通过invokespecial指令调用，执行效率高</li>
<li>接口演进更加灵活，不破坏现有代码</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>接口扩展</li>
<li>函数式接口增强</li>
<li>工具方法定义</li>
<li>框架设计</li>
</ul>
<h4 data-id="heading-7">2.5 其他重要特性</h4>
<h5 data-id="heading-8">2.5.1 Optional类</h5>
<ul>
<li>优雅处理null值，减少空指针异常</li>
<li>提供了丰富的方法链操作</li>
<li>使代码更清晰，表达意图更明确</li>
</ul>
<h5 data-id="heading-9">2.5.2 方法引用</h5>
<ul>
<li>简化Lambda表达式，使代码更简洁</li>
<li>支持静态方法、实例方法和构造方法引用</li>
<li>提高代码可读性</li>
</ul>
<h5 data-id="heading-10">2.5.3 类型注解</h5>
<ul>
<li>支持在更多位置使用注解</li>
<li>增强了静态代码分析能力</li>
<li>提高了代码安全性</li>
</ul>
<h3 data-id="heading-11">3. 性能提升总结</h3>



































<table><thead><tr><th>特性</th><th>性能提升</th><th>适用场景</th></tr></thead><tbody><tr><td>Lambda表达式</td><td>减少对象创建开销，执行效率更高</td><td>事件处理、集合操作</td></tr><tr><td>Stream API</td><td>并行处理利用多核CPU，惰性计算减少内存使用</td><td>大数据集处理、统计分析</td></tr><tr><td>新日期时间API</td><td>不可变设计避免线程同步开销，更高效的实现</td><td>日期时间处理、时区转换</td></tr><tr><td>接口默认方法</td><td>减少适配器类，执行效率高</td><td>接口扩展、框架设计</td></tr><tr><td>并行流</td><td>自动利用多核处理器，显著提升大数据处理速度</td><td>CPU密集型任务、大规模数据处理</td></tr></tbody></table>
<h3 data-id="heading-12">4. 最佳实践</h3>
<h4 data-id="heading-13">4.1 Lambda表达式使用建议</h4>
<ul>
<li>保持Lambda体简洁，避免复杂逻辑</li>
<li>优先使用方法引用提高可读性</li>
<li>注意变量作用域，避免修改外部变量</li>
</ul>
<h4 data-id="heading-14">4.2 Stream API使用建议</h4>
<ul>
<li>对于小数据集，使用串行流即可</li>
<li>对于大数据集（ thousands+ 元素），考虑使用并行流</li>
<li>避免在并行流中使用状态ful操作</li>
<li>合理使用中间操作减少数据量</li>
</ul>
<h4 data-id="heading-15">4.3 日期时间API使用建议</h4>
<ul>
<li>根据需要选择合适的日期时间类</li>
<li>使用不可变的日期时间对象</li>
<li>优先使用DateTimeFormatter进行格式化</li>
<li>注意时区处理的正确性</li>
</ul>
<h3 data-id="heading-16">5. 代码示例</h3>
<h4 data-id="heading-17">5.1 完整示例类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.java.learning;

<span class="hljs-keyword">import</span> java.time.*;
<span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.stream.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDK8Features</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        demonstrateLambda();
        demonstrateStreamAPI();
        demonstrateDateTimeAPI();
        demonstrateDefaultMethods();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateLambda</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"=== Lambda表达式示例 ==="</span>);

        <span class="hljs-comment">// 传统方式 - 匿名内部类</span>
        <span class="hljs-type">Runnable</span> <span class="hljs-variable">traditionalRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                System.out.println(<span class="hljs-string">"传统方式执行"</span>);
            }
        };

        <span class="hljs-comment">// Lambda方式 - 更简洁</span>
        <span class="hljs-type">Runnable</span> <span class="hljs-variable">lambdaRunnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">"Lambda方式执行"</span>);

        <span class="hljs-comment">// 执行</span>
        traditionalRunnable.run();
        lambdaRunnable.run();

        <span class="hljs-comment">// 集合排序的Lambda应用</span>
        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"赵六"</span>);

        <span class="hljs-comment">// 传统排序方式</span>
        Collections.sort(names, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> {
                <span class="hljs-keyword">return</span> a.compareTo(b);
            }
        });

        <span class="hljs-comment">// Lambda排序方式</span>
        Collections.sort(names, (a, b) -&gt; a.compareTo(b));

        <span class="hljs-comment">// 更简洁的方法引用</span>
        Collections.sort(names, String::compareTo);

        System.out.println(<span class="hljs-string">"排序后的名字: "</span> + names);

        <span class="hljs-comment">// 事件处理中的Lambda</span>
        javax.swing.<span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.swing.JButton(<span class="hljs-string">"测试按钮"</span>);
        button.addActionListener(e -&gt; System.out.println(<span class="hljs-string">"按钮被点击了!"</span>));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateStreamAPI</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n=== Stream API示例 ==="</span>);

        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);

        <span class="hljs-comment">// 传统方式：筛选偶数并计算平方</span>
        List&lt;Integer&gt; resultTraditional = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (Integer num : numbers) {
            <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                resultTraditional.add(num * num);
            }
        }

        <span class="hljs-comment">// Stream方式：更声明式、更简洁</span>
        List&lt;Integer&gt; resultStream = numbers.stream()
                .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)      <span class="hljs-comment">// 过滤偶数</span>
                .map(n -&gt; n * n)              <span class="hljs-comment">// 计算平方</span>
                .collect(Collectors.toList()); <span class="hljs-comment">// 收集结果</span>

        System.out.println(<span class="hljs-string">"传统方式结果: "</span> + resultTraditional);
        System.out.println(<span class="hljs-string">"Stream方式结果: "</span> + resultStream);

        <span class="hljs-comment">// 更多Stream操作</span>
        System.out.println(<span class="hljs-string">"\n--- 更多Stream操作 ---"</span>);

        <span class="hljs-comment">// 统计操作</span>
        <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">stats</span> <span class="hljs-operator">=</span> numbers.stream()
                .mapToInt(Integer::intValue)
                .summaryStatistics();

        System.out.println(<span class="hljs-string">"统计信息: "</span> + stats);
        System.out.println(<span class="hljs-string">"平均值: "</span> + stats.getAverage());
        System.out.println(<span class="hljs-string">"最大值: "</span> + stats.getMax());

        <span class="hljs-comment">// 分组操作</span>
        Map&lt;String, List&lt;Integer&gt;&gt; grouped = numbers.stream()
                .collect(Collectors.groupingBy(
                        n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">"偶数"</span> : <span class="hljs-string">"奇数"</span>
                ));

        System.out.println(<span class="hljs-string">"分组结果: "</span> + grouped);

        <span class="hljs-comment">// 并行流处理</span>
        List&lt;Integer&gt; parallelResult = numbers.parallelStream()
                .filter(n -&gt; n &gt; <span class="hljs-number">5</span>)
                .map(n -&gt; n * <span class="hljs-number">2</span>)
                .sorted()
                .collect(Collectors.toList());

        System.out.println(<span class="hljs-string">"并行处理结果: "</span> + parallelResult);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateDateTimeAPI</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n=== 新的日期时间API示例 ==="</span>);

        <span class="hljs-comment">// 旧版Date的问题</span>
        <span class="hljs-type">Date</span> <span class="hljs-variable">oldDate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
        System.out.println(<span class="hljs-string">"旧Date: "</span> + oldDate);

        <span class="hljs-comment">// 新版日期时间API</span>
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">currentDate</span> <span class="hljs-operator">=</span> LocalDate.now();
        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> LocalTime.now();
        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">currentDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();

        System.out.println(<span class="hljs-string">"当前日期: "</span> + currentDate);
        System.out.println(<span class="hljs-string">"当前时间: "</span> + currentTime);
        System.out.println(<span class="hljs-string">"当前日期时间: "</span> + currentDateTime);

        <span class="hljs-comment">// 日期操作</span>
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">tomorrow</span> <span class="hljs-operator">=</span> currentDate.plusDays(<span class="hljs-number">1</span>);
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextWeek</span> <span class="hljs-operator">=</span> currentDate.plusWeeks(<span class="hljs-number">1</span>);
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextMonth</span> <span class="hljs-operator">=</span> currentDate.plusMonths(<span class="hljs-number">1</span>);

        System.out.println(<span class="hljs-string">"明天: "</span> + tomorrow);
        System.out.println(<span class="hljs-string">"下周: "</span> + nextWeek);
        System.out.println(<span class="hljs-string">"下月: "</span> + nextMonth);

        <span class="hljs-comment">// 日期比较</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">isBefore</span> <span class="hljs-operator">=</span> tomorrow.isBefore(nextWeek);
        System.out.println(<span class="hljs-string">"明天是否在下周之前: "</span> + isBefore);

        <span class="hljs-comment">// 日期格式化</span>
        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> currentDateTime.format(formatter);
        System.out.println(<span class="hljs-string">"格式化日期: "</span> + formatted);

        <span class="hljs-comment">// 时区处理</span>
        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zonedDateTime</span> <span class="hljs-operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="hljs-string">"America/New_York"</span>));
        System.out.println(<span class="hljs-string">"纽约时间: "</span> + zonedDateTime);

        <span class="hljs-comment">// 持续时间计算</span>
        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.now();
        <span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);
        System.out.println(<span class="hljs-string">"从2024年开始已经过去了: "</span> + duration.toDays() + <span class="hljs-string">" 天"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateDefaultMethods</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n=== 接口默认方法示例 ==="</span>);

        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicCalculator</span>();
        System.out.println(<span class="hljs-string">"加法: "</span> + calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">"减法: "</span> + calculator.subtract(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">"乘法: "</span> + calculator.multiply(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">"默认方法平方: "</span> + calculator.square(<span class="hljs-number">5</span>));
    }
}

<span class="hljs-comment">// 接口默认方法示例</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;
    <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;

    <span class="hljs-comment">// 默认方法 - 接口可以提供实现</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a * b;
    }

    <span class="hljs-comment">// 另一个默认方法</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> {
        <span class="hljs-keyword">return</span> multiply(a, a);
    }

    <span class="hljs-comment">// 静态方法 - 接口中的工具方法</span>
    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getVersion</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Calculator v1.0"</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a - b;
    }

    <span class="hljs-comment">// 不需要实现默认方法，可以直接使用</span>
    <span class="hljs-comment">// 也可以选择重写默认方法</span>
}
</code></pre>
<h3 data-id="heading-18">6. 总结</h3>
<p>JDK 8是Java发展史上的一个重要里程碑，引入的Lambda表达式、Stream API、新日期时间API等特性，不仅使代码更简洁、更易读，还显著提升了性能。这些特性为Java带来了函数式编程的能力，使Java在现代应用开发中保持竞争力。</p>
<p>通过合理使用JDK 8的新特性，开发者可以：</p>
<ul>
<li>编写更简洁、更表达力强的代码</li>
<li>充分利用多核处理器提升性能</li>
<li>避免常见的错误（如空指针异常、线程安全问题）</li>
<li>提高开发效率和代码可维护性</li>
</ul>
<p>JDK 8的特性为后续版本的发展奠定了基础，是每个Java开发者都应该掌握的核心知识。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端监控实践]]></title>    <link>https://juejin.cn/post/7605856048361537574</link>    <guid>https://juejin.cn/post/7605856048361537574</guid>    <pubDate>2026-02-13T05:51:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605856048361537574" data-draft-id="7605881632541016115" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端监控实践"/> <meta itemprop="keywords" content="前端,性能优化"/> <meta itemprop="datePublished" content="2026-02-13T05:51:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="李元_霸"/> <meta itemprop="url" content="https://juejin.cn/user/2524917887410397"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端监控实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2524917887410397/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    李元_霸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:51:40.000Z" title="Fri Feb 13 2026 05:51:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">从零开发前端监控 SDK：异常、性能、访问量一网打尽</h2>
<blockquote>
<p>本文将带你从零开发一个完整的前端监控 SDK，涵盖异常监控、性能监控和访问量统计三大核心功能。</p>
</blockquote>
<h3 data-id="heading-1">目录</h3>
<ol>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7" title="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7">为什么需要前端监控</a></li>
<li><a href="#sdk-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1" title="#sdk-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">SDK 架构设计</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" title="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">核心功能实现</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" title="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B" title="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B">总结与展望</a></li>
</ol>
<hr/>
<h3 data-id="heading-2">为什么需要前端监控</h3>
<p>在现代 Web 应用中，前端监控已经成为保障用户体验的重要手段：</p>
<ul>
<li><strong>异常监控</strong>：及时发现并修复线上 Bug，减少用户流失</li>
<li><strong>性能监控</strong>：优化页面加载速度，提升用户体验</li>
<li><strong>访问统计</strong>：了解用户行为，指导产品决策</li>
</ul>
<p>市面上已有 Sentry、Fundebug 等成熟的监控服务，但开发自己的 SDK 能让我们：</p>
<ol>
<li>完全掌控数据，保障隐私安全</li>
<li>根据业务需求定制功能</li>
<li>深入理解监控原理，提升技术能力</li>
</ol>
<hr/>
<h3 data-id="heading-3">SDK 架构设计</h3>
<h4 data-id="heading-4">整体架构</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────┐
│                        Monitor SDK                          │
├─────────────────────────────────────────────────────────────┤
│  Core Layer  │  Reporter (上报中心)  │  Config (配置管理)    │
├─────────────────────────────────────────────────────────────┤
│  Module Layer│  ErrorMonitor │ PerformanceMonitor │ VisitMonitor│
├─────────────────────────────────────────────────────────────┤
│  Utils Layer │  Device │ Storage │ UUID │ Sampling           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-5">设计原则</h4>
<ol>
<li><strong>模块化</strong>：每个监控功能独立模块，可单独启用/禁用</li>
<li><strong>插件化</strong>：Reporter 统一管理上报，支持批量和即时发送</li>
<li><strong>低侵入</strong>：自动捕获异常，业务代码零改动</li>
<li><strong>高兼容</strong>：支持多种引入方式（ESM/CJS/UMD）</li>
</ol>
<hr/>
<h3 data-id="heading-6">核心功能实现</h3>
<h4 data-id="heading-7">1. 异常监控模块</h4>
<p>异常监控是 SDK 的核心功能，我们需要捕获多种类型的错误：</p>
<h5 data-id="heading-8">1.1 JavaScript 运行时错误</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/globalError.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initGlobalError</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">event: ErrorEvent</span>) =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">errorData</span>: <span class="hljs-title class_">ErrorData</span> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'js'</span>,
      <span class="hljs-attr">message</span>: event.<span class="hljs-property">message</span>,
      <span class="hljs-attr">filename</span>: event.<span class="hljs-property">filename</span>,
      <span class="hljs-attr">lineno</span>: event.<span class="hljs-property">lineno</span>,
      <span class="hljs-attr">colno</span>: event.<span class="hljs-property">colno</span>,
      <span class="hljs-attr">stack</span>: event.<span class="hljs-property">error</span>?.<span class="hljs-property">stack</span>
    };
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, errorData);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, handler);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'error'</span>, handler);
}
</code></pre>
<p>通过监听 <code>window.onerror</code>，我们可以捕获所有同步和异步的 JavaScript 错误。</p>
<h5 data-id="heading-9">1.2 Promise 未捕获异常</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/promiseError.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initPromiseError</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">event: PromiseRejectionEvent</span>) =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">errorData</span>: <span class="hljs-title class_">ErrorData</span> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'promise'</span>,
      <span class="hljs-attr">message</span>: event.<span class="hljs-property">reason</span>?.<span class="hljs-property">message</span> || <span class="hljs-title class_">String</span>(event.<span class="hljs-property">reason</span>),
      <span class="hljs-attr">stack</span>: event.<span class="hljs-property">reason</span>?.<span class="hljs-property">stack</span>
    };
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, errorData);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, handler);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, handler);
}
</code></pre>
<p>现代前端大量使用 Promise，未捕获的 Promise 错误会导致应用崩溃。</p>
<h5 data-id="heading-10">1.3 资源加载错误</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/resourceError.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initResourceError</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">event: Event</span>) =&gt; {
    <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;
    <span class="hljs-keyword">const</span> tagName = target.<span class="hljs-property">tagName</span>?.<span class="hljs-title function_">toLowerCase</span>();

    <span class="hljs-keyword">if</span> (![<span class="hljs-string">'img'</span>, <span class="hljs-string">'script'</span>, <span class="hljs-string">'link'</span>].<span class="hljs-title function_">includes</span>(tagName)) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> src = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">src</span> || (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">href</span> || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-attr">errorData</span>: <span class="hljs-title class_">ErrorData</span> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'resource'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">`Failed to load <span class="hljs-subst">${tagName}</span>: <span class="hljs-subst">${src}</span>`</span>,
      <span class="hljs-attr">filename</span>: src,
      <span class="hljs-attr">extra</span>: { tagName }
    };
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, errorData);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, handler, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 捕获阶段监听</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'error'</span>, handler, <span class="hljs-literal">true</span>);
}
</code></pre>
<p>使用捕获阶段（<code>true</code>）可以监听到资源加载错误。</p>
<h5 data-id="heading-11">1.4 网络请求错误</h5>
<p>通过劫持 XMLHttpRequest 和 fetch API，监控所有网络请求：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/networkError.ts</span>
<span class="hljs-keyword">const</span> originalFetch = <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span>;
<span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">input: RequestInfo | URL, init?: RequestInit</span>) {
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">typeof</span> input === <span class="hljs-string">'string'</span> ? input : input.<span class="hljs-title function_">toString</span>();

  <span class="hljs-keyword">return</span> originalFetch.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'network'</span>,
          <span class="hljs-attr">message</span>: <span class="hljs-string">`Fetch <span class="hljs-subst">${response.status}</span>: <span class="hljs-subst">${response.statusText}</span>`</span>,
          <span class="hljs-attr">extra</span>: { <span class="hljs-attr">method</span>: init?.<span class="hljs-property">method</span> || <span class="hljs-string">'GET'</span>, url, <span class="hljs-attr">status</span>: response.<span class="hljs-property">status</span> }
        });
      }
      <span class="hljs-keyword">return</span> response;
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'network'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">`Fetch failed: <span class="hljs-subst">${error.message}</span>`</span>,
        <span class="hljs-attr">extra</span>: { <span class="hljs-attr">method</span>: init?.<span class="hljs-property">method</span> || <span class="hljs-string">'GET'</span>, url }
      });
      <span class="hljs-keyword">throw</span> error;
    });
};
</code></pre>
<h4 data-id="heading-12">2. 性能监控模块</h4>
<h5 data-id="heading-13">2.1 Web Vitals 指标</h5>
<p>Core Web Vitals 是 Google 提出的衡量用户体验的关键指标：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/performance/webVitals.ts</span>

<span class="hljs-comment">// LCP - 最大内容绘制</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeLCP</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> entries = list.<span class="hljs-title function_">getEntries</span>();
    <span class="hljs-keyword">const</span> lastEntry = entries[entries.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> value = (lastEntry <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">renderTime</span> || lastEntry.<span class="hljs-property">startTime</span>;

    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'web-vitals'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'LCP'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(value),
      <span class="hljs-attr">rating</span>: value &lt;= <span class="hljs-number">2500</span> ? <span class="hljs-string">'good'</span> : value &lt;= <span class="hljs-number">4000</span> ? <span class="hljs-string">'needs-improvement'</span> : <span class="hljs-string">'poor'</span>
    });
  });

  observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'largest-contentful-paint'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span> });
}

<span class="hljs-comment">// CLS - 累积布局偏移</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeCLS</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">let</span> clsValue = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {
      <span class="hljs-keyword">const</span> layoutEntry = entry <span class="hljs-keyword">as</span> <span class="hljs-title class_">PerformanceEntry</span> &amp; { <span class="hljs-attr">hadRecentInput</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> };
      <span class="hljs-keyword">if</span> (!layoutEntry.<span class="hljs-property">hadRecentInput</span>) {
        clsValue += layoutEntry.<span class="hljs-property">value</span>;
      }
    }
  });

  observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'layout-shift'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span> });

  <span class="hljs-comment">// 页面隐藏时上报</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">'hidden'</span>) {
      reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'web-vitals'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'CLS'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(clsValue * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>,
        <span class="hljs-attr">rating</span>: clsValue &lt;= <span class="hljs-number">0.1</span> ? <span class="hljs-string">'good'</span> : clsValue &lt;= <span class="hljs-number">0.25</span> ? <span class="hljs-string">'needs-improvement'</span> : <span class="hljs-string">'poor'</span>
      });
    }
  });
}
</code></pre>
<h5 data-id="heading-14">2.2 导航性能</h5>
<p>利用 Navigation Timing API 获取页面加载各阶段耗时：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeNavigation</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> navigation = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">'navigation'</span>)[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">as</span> <span class="hljs-title class_">PerformanceNavigationTiming</span>;

      <span class="hljs-keyword">const</span> metrics = [
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'DNS'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">domainLookupEnd</span> - navigation.<span class="hljs-property">domainLookupStart</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'TCP'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">connectEnd</span> - navigation.<span class="hljs-property">connectStart</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'TTFB'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">responseStart</span> - navigation.<span class="hljs-property">startTime</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'DOM解析'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">domInteractive</span> - navigation.<span class="hljs-property">responseEnd</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Load'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">loadEventEnd</span> - navigation.<span class="hljs-property">startTime</span> }
      ];

      metrics.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ name, value }</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>) {
          reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'navigation'</span>,
            name,
            <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(value)
          });
        }
      });
    }, <span class="hljs-number">0</span>);
  });
}
</code></pre>
<h5 data-id="heading-15">2.3 API 耗时监控</h5>
<p>劫持 XMLHttpRequest 和 fetch，统计所有 API 请求耗时：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeAPI</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 劫持 XMLHttpRequest</span>
  <span class="hljs-keyword">const</span> originalXHRSend = <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span>;

  <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'loadend'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime;
      reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'api'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">`API: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>._url}</span>`</span>,
        <span class="hljs-attr">value</span>: duration
      });
    });

    <span class="hljs-keyword">return</span> originalXHRSend.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
  };

  <span class="hljs-comment">// 劫持 fetch...</span>
}
</code></pre>
<h4 data-id="heading-16">3. 访问监控模块</h4>
<h5 data-id="heading-17">3.1 PV 统计</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/visit/pv.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observePV</span>(<span class="hljs-params">reporter: Reporter, enableSPA: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 初始页面 PV</span>
  <span class="hljs-title function_">reportPV</span>(reporter);

  <span class="hljs-keyword">if</span> (!enableSPA) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 劫持 history API 监听路由变化</span>
  <span class="hljs-keyword">const</span> originalPushState = history.<span class="hljs-property">pushState</span>;
  history.<span class="hljs-property">pushState</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
    originalPushState.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    <span class="hljs-title function_">reportPV</span>(reporter);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'popstate'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reportPV</span>(reporter));
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'hashchange'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reportPV</span>(reporter));
}
</code></pre>
<h5 data-id="heading-18">3.2 Session 管理</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/visit/session.ts</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SESSION_TIMEOUT</span> = <span class="hljs-number">30</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 30分钟</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initSession</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();

  <span class="hljs-comment">// 上报会话开始</span>
  reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'visit'</span>, { <span class="hljs-attr">type</span>: <span class="hljs-string">'session-start'</span> });

  <span class="hljs-comment">// 页面可见性变化</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">'visible'</span>) {
      <span class="hljs-keyword">const</span> lastActive = <span class="hljs-built_in">parseInt</span>(storage.<span class="hljs-title function_">get</span>(<span class="hljs-string">'session_time'</span>) || <span class="hljs-string">'0'</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - lastActive &gt; <span class="hljs-variable constant_">SESSION_TIMEOUT</span>) {
        <span class="hljs-comment">// 新会话</span>
        reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'visit'</span>, { <span class="hljs-attr">type</span>: <span class="hljs-string">'session-start'</span> });
      }
    } <span class="hljs-keyword">else</span> {
      storage.<span class="hljs-title function_">set</span>(<span class="hljs-string">'session_time'</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toString</span>());
    }
  });

  <span class="hljs-comment">// 页面卸载时上报会话结束</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'beforeunload'</span>, <span class="hljs-function">() =&gt;</span> {
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'visit'</span>, {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'session-end'</span>,
      <span class="hljs-attr">duration</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime
    });
  });
}
</code></pre>
<h4 data-id="heading-19">4. 数据上报中心</h4>
<h5 data-id="heading-20">4.1 上报策略</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/core/reporter.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reporter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">QueueItem</span>[] = [];
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">FLUSH_INTERVAL</span> = <span class="hljs-number">5000</span>; <span class="hljs-comment">// 5秒刷新</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">MAX_QUEUE_SIZE</span> = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 10条批量发送</span>

  <span class="hljs-title function_">report</span>(<span class="hljs-attr">type</span>: <span class="hljs-title class_">ReportData</span>[<span class="hljs-string">'type'</span>], <span class="hljs-attr">data</span>: <span class="hljs-title class_">ReportData</span>[<span class="hljs-string">'data'</span>]): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 采样检查</span>
    <span class="hljs-keyword">const</span> sampleRate = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">sampleRate</span>?.[<span class="hljs-keyword">type</span>] || <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">shouldSample</span>(sampleRate)) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> url = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">reportUrl</span>[<span class="hljs-keyword">type</span>];
    <span class="hljs-keyword">if</span> (!url) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 异常数据立即上报</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">'error'</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendImmediately</span>(data, url);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 性能和访问数据批量上报</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addToQueue</span>(data, url);
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">addToQueue</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">ReportData</span>, <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>({ data, url });

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">MAX_QUEUE_SIZE</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">flush</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">scheduleFlush</span>();
    }
  }
}
</code></pre>
<h5 data-id="heading-21">4.2 页面关闭补发</h5>
<p>使用 <code>sendBeacon</code> API 在页面关闭前发送剩余数据：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">bindEvents</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendRemaining</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ data, url }</span>) =&gt;</span> {
      navigator.<span class="hljs-property">sendBeacon</span>?.(url, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
    });
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'beforeunload'</span>, sendRemaining);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">'hidden'</span>) {
      <span class="hljs-title function_">sendRemaining</span>();
    }
  });
}
</code></pre>
<h4 data-id="heading-22">5. 设备信息解析</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/utils/device.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDeviceInfo</span>(<span class="hljs-params"/>): <span class="hljs-title class_">DeviceInfo</span> {
  <span class="hljs-keyword">const</span> ua = navigator.<span class="hljs-property">userAgent</span>;

  <span class="hljs-comment">// 解析操作系统</span>
  <span class="hljs-keyword">let</span> os = <span class="hljs-string">'unknown'</span>;
  <span class="hljs-keyword">let</span> osVersion = <span class="hljs-string">'unknown'</span>;

  <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Win'</span>) !== -<span class="hljs-number">1</span>) {
    os = <span class="hljs-string">'Windows'</span>;
    <span class="hljs-keyword">const</span> match = ua.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Windows NT (\d+\.\d+)/</span>);
    <span class="hljs-keyword">if</span> (match) osVersion = match[<span class="hljs-number">1</span>];
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Mac'</span>) !== -<span class="hljs-number">1</span>) {
    os = <span class="hljs-string">'macOS'</span>;
    <span class="hljs-comment">// ...</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/iPad|iPhone|iPod/</span>.<span class="hljs-title function_">test</span>(ua)) {
    os = <span class="hljs-string">'iOS'</span>;
    <span class="hljs-comment">// ...</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Android'</span>) !== -<span class="hljs-number">1</span>) {
    os = <span class="hljs-string">'Android'</span>;
    <span class="hljs-comment">// ...</span>
  }

  <span class="hljs-comment">// 解析浏览器</span>
  <span class="hljs-keyword">let</span> browser = <span class="hljs-string">'unknown'</span>;
  <span class="hljs-keyword">let</span> browserVersion = <span class="hljs-string">'unknown'</span>;

  <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Chrome'</span>) !== -<span class="hljs-number">1</span> &amp;&amp; ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Edg'</span>) === -<span class="hljs-number">1</span>) {
    browser = <span class="hljs-string">'Chrome'</span>;
    <span class="hljs-keyword">const</span> match = ua.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Chrome\/(\d+\.\d+)/</span>);
    <span class="hljs-keyword">if</span> (match) browserVersion = match[<span class="hljs-number">1</span>];
  }
  <span class="hljs-comment">// ... Safari, Firefox, Edge</span>

  <span class="hljs-keyword">return</span> {
    ua,
    os,
    osVersion,
    browser,
    browserVersion,
    <span class="hljs-attr">screen</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">window</span>.screen.width}</span>x<span class="hljs-subst">${<span class="hljs-variable language_">window</span>.screen.height}</span>`</span>,
    <span class="hljs-attr">language</span>: navigator.<span class="hljs-property">language</span>
  };
}
</code></pre>
<hr/>
<h3 data-id="heading-23">使用示例</h3>
<h4 data-id="heading-24">基础使用</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Monitor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'frontend-monitor-sdk'</span>;

<span class="hljs-title class_">Monitor</span>.<span class="hljs-title function_">init</span>({
  <span class="hljs-attr">appId</span>: <span class="hljs-string">'my-app'</span>,
  <span class="hljs-attr">appVersion</span>: <span class="hljs-string">'1.0.0'</span>,
  <span class="hljs-attr">env</span>: <span class="hljs-string">'production'</span>,
  <span class="hljs-attr">reportUrl</span>: {
    <span class="hljs-attr">error</span>: <span class="hljs-string">'https://api.example.com/error'</span>,
    <span class="hljs-attr">performance</span>: <span class="hljs-string">'https://api.example.com/perf'</span>,
    <span class="hljs-attr">visit</span>: <span class="hljs-string">'https://api.example.com/visit'</span>
  },
  <span class="hljs-attr">sampleRate</span>: {
    <span class="hljs-attr">error</span>: <span class="hljs-number">1</span>,         <span class="hljs-comment">// 异常100%上报</span>
    <span class="hljs-attr">performance</span>: <span class="hljs-number">0.1</span>, <span class="hljs-comment">// 性能10%采样</span>
    <span class="hljs-attr">visit</span>: <span class="hljs-number">0.1</span>        <span class="hljs-comment">// 访问10%采样</span>
  },
  <span class="hljs-attr">enableSPA</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">beforeReport</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-comment">// 上报前钩子，可修改数据或返回 false 阻止上报</span>
    <span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">'error'</span> &amp;&amp; data.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>?.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'ignore'</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> data;
  }
});
</code></pre>
<h4 data-id="heading-25">Vue 集成</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Monitor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'frontend-monitor-sdk'</span>;

<span class="hljs-title class_">Monitor</span>.<span class="hljs-title function_">init</span>({ <span class="hljs-comment">/* ... */</span> });

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);
app.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-title class_">Monitor</span>.<span class="hljs-property">vueErrorHandler</span>;
</code></pre>
<h4 data-id="heading-26">React 集成</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, errorInfo: React.ErrorInfo</span>) {
    <span class="hljs-title class_">Monitor</span>.<span class="hljs-title function_">reportError</span>(error, {
      <span class="hljs-attr">componentStack</span>: errorInfo.<span class="hljs-property">componentStack</span>
    });
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;
  }
}
</code></pre>
<hr/>
<h3 data-id="heading-27">总结与展望</h3>
<h4 data-id="heading-28">已实现功能</h4>
<p>✅ <strong>异常监控</strong>：JS 错误、Promise 错误、资源错误、网络错误、控制台错误、框架错误
✅ <strong>性能监控</strong>：Web Vitals、导航计时、资源性能、API 耗时、长任务
✅ <strong>访问监控</strong>：PV/UV、Session、设备信息、SPA 路由监听
✅ <strong>数据上报</strong>：分类上报、采样控制、批量上报、页面关闭补发</p>
<h4 data-id="heading-29">技术亮点</h4>
<ol>
<li><strong>类型安全</strong>：完整的 TypeScript 类型定义</li>
<li><strong>模块化设计</strong>：各功能独立，可灵活组合</li>
<li><strong>低侵入性</strong>：自动捕获，业务代码零改动</li>
<li><strong>高兼容性</strong>：支持 ESM/CJS/UMD 多种格式</li>
</ol>
<h4 data-id="heading-30">未来优化方向</h4>
<p>🔲 <strong>SourceMap 解析</strong>：实现错误堆栈的源码还原
🔲 <strong>用户行为录屏</strong>：记录用户操作路径，辅助问题定位
🔲 <strong>性能面板可视化</strong>：开发 Chrome 插件查看性能数据
🔲 <strong>离线缓存</strong>：支持网络断开时的数据本地存储</p>
<hr/>
<h3 data-id="heading-31">参考资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FPerformance" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/Performance" ref="nofollow noopener noreferrer">MDN Performance API</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fvitals%2F" target="_blank" title="https://web.dev/vitals/" ref="nofollow noopener noreferrer">Google Web Vitals</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fw3c.github.io%2Fbeacon%2F" target="_blank" title="https://w3c.github.io/beacon/" ref="nofollow noopener noreferrer">W3C Beacon API</a></li>
</ul>
<hr/>
<p><em>本文完，如有问题欢迎留言讨论！</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OpenClaw 多 Agent 配置实战：踩坑指南与最佳实践]]></title>    <link>https://juejin.cn/post/7605810996125548578</link>    <guid>https://juejin.cn/post/7605810996125548578</guid>    <pubDate>2026-02-13T05:53:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125548578" data-draft-id="7605816833191968768" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OpenClaw 多 Agent 配置实战：踩坑指南与最佳实践"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T05:53:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="陈广亮"/> <meta itemprop="url" content="https://juejin.cn/user/3139860937575934"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OpenClaw 多 Agent 配置实战：踩坑指南与最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860937575934/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    陈广亮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:53:58.000Z" title="Fri Feb 13 2026 05:53:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>如果你已经用了一段时间 OpenClaw，肯定会遇到这样的需求：我需要一个专门写博客的 AI 助手，一个写小说的，一个做代码开发的……每个都有独立的角色定位、工作目录和配置。这就是多 Agent 配置要解决的问题。</p>
<p>本文不是理论教程，而是实战踩坑记录。我会告诉你配置过程中会遇到哪些坑，为什么会踩坑，以及怎么避免和解决。</p>
<h2 data-id="heading-0">为什么需要多 Agent</h2>
<p><strong>场景隔离</strong>。不同的工作场景需要不同的 AI 助手：</p>
<ul>
<li><strong>博客助手</strong>：专注于技术写作，熟悉你的博客部署流程，有独立的文章草稿目录</li>
<li><strong>小说助手</strong>：创意写作风格，管理小说章节和人物设定，不需要访问技术代码</li>
<li><strong>开发助手</strong>：熟悉代码规范，可以执行敏感命令，但不应该访问私人笔记</li>
<li><strong>家庭助手</strong>：绑定到家庭 WhatsApp 群，只能访问受限的工具集，保护隐私</li>
</ul>
<p><strong>独立配置</strong>。每个 Agent 有自己的：</p>
<ul>
<li><strong>Workspace</strong>：独立的工作目录，互不干扰</li>
<li><strong>SOUL.md</strong>：独立的角色定位和性格设定</li>
<li><strong>Model</strong>：可以给不同 Agent 配置不同模型（Opus 做深度思考，Sonnet 做日常聊天）</li>
<li><strong>Tool Policy</strong>：限制某些 Agent 的工具权限（比如家庭助手不能执行 shell 命令）</li>
</ul>
<p><strong>账号路由</strong>。多个 Telegram bot 或 WhatsApp 账号，路由到不同的 Agent，一个 Gateway 管理所有账号。</p>
<p>举个例子，你可能会配置这样的 Agent：</p>
<ul>
<li><code>main</code>：日常聊天，全功能</li>
<li><code>work</code>：工作场景，可以访问项目文档</li>
<li><code>creative</code>：创作助手，专注于写作</li>
<li><code>coding</code>：开发助手，执行代码相关任务</li>
</ul>
<h2 data-id="heading-1">多 Agent 配置流程</h2>
<h3 data-id="heading-2">1. 创建 Agent</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建一个新 Agent</span>
openclaw agents add blog --workspace ~/.openclaw/workspace-blog

<span class="hljs-comment"># 验证创建结果</span>
openclaw agents list
</code></pre>
<p>这会在配置文件中添加：</p>
<pre><code class="hljs language-json5" lang="json5">{
  agents: {
    list: [
      {
        id: "main",
        default: true,
        workspace: "~/.openclaw/workspace",
      },
      {
        id: "blog",
        workspace: "~/.openclaw/workspace-blog",
      },
    ],
  },
}
</code></pre>
<h3 data-id="heading-3">2. 设置模型</h3>
<p><strong>⚠️ 第一个坑：模型 ID 格式</strong></p>
<p>配置模型时，要用<strong>别名</strong>，不要带日期后缀！</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># ✅ 正确：使用别名</span>
openclaw config patch agents.list.1.model <span class="hljs-string">"anthropic/claude-sonnet-4-5"</span>

<span class="hljs-comment"># ❌ 错误：带日期后缀的完整 ID</span>
openclaw config patch agents.list.1.model <span class="hljs-string">"anthropic/claude-sonnet-4-20250514"</span>
</code></pre>
<p><strong>为什么？</strong></p>
<p>带日期的 ID 会在新版本发布时失效。别名（如 <code>claude-sonnet-4-5</code>）会自动指向最新版本。</p>
<p>验证配置：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config get agents.list.1.model
<span class="hljs-comment"># 应该输出：anthropic/claude-sonnet-4-5</span>
</code></pre>
<h3 data-id="heading-4">3. 编写 SOUL.md 定义角色</h3>
<p>每个 Agent 的 workspace 下创建 <code>SOUL.md</code>，定义它的角色：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> ~/.openclaw/workspace-blog
</code></pre>
<p>创建 <code>SOUL.md</code>：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># SOUL.md - 工作助手</span>

你是工作助手，帮助处理日常工作任务。

<span class="hljs-section">## 角色定位</span>
<span class="hljs-bullet">-</span> 专注于工作场景，风格专业高效
<span class="hljs-bullet">-</span> 熟悉常用开发工具和工作流程
<span class="hljs-bullet">-</span> 所有重要操作需要确认后执行

<span class="hljs-section">## 工作流程</span>
<span class="hljs-bullet">1.</span> 接收任务需求
<span class="hljs-bullet">2.</span> 分析任务并制定执行计划
<span class="hljs-bullet">3.</span> 执行任务
<span class="hljs-bullet">4.</span> 汇报结果

<span class="hljs-section">## 工作规范</span>
<span class="hljs-bullet">-</span> 代码示例要完整可用
<span class="hljs-bullet">-</span> 文档结构清晰
<span class="hljs-bullet">-</span> 操作前确认权限
</code></pre>
<p><strong>⚠️ 第二个坑：不要创建 BOOTSTRAP.md</strong></p>
<p>如果你手动创建了 <code>BOOTSTRAP.md</code>，Agent 会一直卡在 bootstrapping 状态！</p>
<p><strong>为什么？</strong></p>
<p><code>BOOTSTRAP.md</code> 是 Agent 的"初始化任务清单"。Agent 启动后会执行里面的指令，执行完才会删除这个文件。如果你手动创建了这个文件但内容不完整，Agent 会不断尝试执行，永远无法进入正常状态。</p>
<p><strong>解决方法：</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 如果发现 Agent 卡住了，检查是否有 BOOTSTRAP.md</span>
<span class="hljs-built_in">ls</span> ~/.openclaw/workspace-blog/BOOTSTRAP.md

<span class="hljs-comment"># 如果存在，直接删除</span>
<span class="hljs-built_in">rm</span> ~/.openclaw/workspace-blog/BOOTSTRAP.md

<span class="hljs-comment"># 重启 Gateway</span>
openclaw gateway restart
</code></pre>
<h3 data-id="heading-5">4. 测试 Agent</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 列出所有 Agent</span>
openclaw agents list

<span class="hljs-comment"># 查看 Agent 详细配置</span>
openclaw config get agents.list.1

<span class="hljs-comment"># 重启 Gateway 让配置生效</span>
openclaw gateway restart
</code></pre>
<h2 data-id="heading-6">Telegram 多账号配置</h2>
<p>多 Agent 的典型用法是配置多个 Telegram bot，每个 bot 路由到不同的 Agent。</p>
<h3 data-id="heading-7">1. 创建 Telegram Bot</h3>
<p>在 Telegram 找 <a href="https://link.juejin.cn?target=https%3A%2F%2Ft.me%2FBotFather" target="_blank" title="https://t.me/BotFather" ref="nofollow noopener noreferrer">@BotFather</a>，创建 bot：</p>
<pre><code class="hljs language-bash" lang="bash">/newbot
</code></pre>
<p>按提示输入名称和用户名，获得 token（类似 <code>1234567890:ABCdefGHIjklMNOpqrsTUVwxyz</code>）。</p>
<p>假设你创建了两个 bot：</p>
<ul>
<li><code>@MyMainBot</code> → token1</li>
<li><code>@MyWorkBot</code> → token2</li>
</ul>
<h3 data-id="heading-8">2. 配置多账号</h3>
<p>编辑 <code>~/.openclaw/openclaw.json</code>（或用 <code>openclaw config patch</code>）：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      accounts: {
        main: {
          token: "token1",
          dmPolicy: "allowlist",
          allowFrom: ["123456789"], // 你的 Telegram user ID
        },
        blog: {
          token: "token2",
          dmPolicy: "allowlist",
          allowFrom: ["123456789"],
        },
      },
    },
  },
}
</code></pre>
<p><strong>⚠️ 第三个坑：dmPolicy 默认值</strong></p>
<p>如果不设置 <code>dmPolicy</code>，默认是 <code>pairing</code>，这意味着用户必须先执行 <code>/pair</code> 命令才能聊天。但如果配置有问题，<code>/pair</code> 可能也不会响应，消息会被<strong>静默丢弃</strong>！</p>
<p><strong>解决方法：</strong></p>
<p>明确设置 <code>dmPolicy: "allowlist"</code>，并配置 <code>allowFrom</code> 列表：</p>
<pre><code class="hljs language-json5" lang="json5">{
  dmPolicy: "allowlist",
  allowFrom: ["123456789", "987654321"], // 允许的 user ID 列表
}
</code></pre>
<p>获取你的 Telegram user ID：给 <a href="https://link.juejin.cn?target=https%3A%2F%2Ft.me%2Fuserinfobot" target="_blank" title="https://t.me/userinfobot" ref="nofollow noopener noreferrer">@userinfobot</a> 发消息。</p>
<h3 data-id="heading-9">3. 配置路由规则</h3>
<p>添加 <code>bindings</code> 将不同的 Telegram 账号路由到不同的 Agent：</p>
<pre><code class="hljs language-json5" lang="json5">{
  bindings: [
    {
      agentId: "main",
      match: { channel: "telegram", accountId: "main" },
    },
    {
      agentId: "blog",
      match: { channel: "telegram", accountId: "blog" },
    },
  ],
}
</code></pre>
<p><strong>路由规则优先级</strong>：</p>
<ol>
<li><code>peer</code> 精确匹配（具体的 DM 或群组 ID）</li>
<li><code>accountId</code> 匹配（哪个 Telegram 账号）</li>
<li><code>channel</code> 匹配（哪个平台）</li>
<li>默认 Agent（<code>default: true</code> 或列表中第一个）</li>
</ol>
<h3 data-id="heading-10">4. 重启 Gateway</h3>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart --reason <span class="hljs-string">"添加新 Telegram bot"</span>
</code></pre>
<p>测试：给两个 bot 发 <code>/start</code>，应该分别收到来自不同 Agent 的回复。</p>
<h2 data-id="heading-11">常见问题与解决</h2>
<h3 data-id="heading-12">问题 1：config.patch 把配置冲掉了</h3>
<p><strong>现象：</strong></p>
<p>我想给 <code>telegram.accounts</code> 添加一个新账号，执行：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config patch channels.telegram.accounts.blog <span class="hljs-string">'{"token":"xxx"}'</span>
</code></pre>
<p>结果其他账号的配置全没了！</p>
<p><strong>原因：</strong></p>
<p><code>config.patch</code> 对<strong>嵌套对象</strong>是<strong>整体替换</strong>，不是增量修改！</p>
<p>如果配置是：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      accounts: {
        main: {...},
        novel: {...},
      },
    },
  },
}
</code></pre>
<p>执行 <code>patch channels.telegram.accounts.blog {...}</code> 会导致：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      accounts: {
        blog: {...}, // 只剩这一个！
      },
    },
  },
}
</code></pre>
<p><strong>解决方法：</strong></p>
<p>patch 时带上<strong>完整的对象</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># ❌ 错误：只 patch 一个子项</span>
openclaw config patch channels.telegram.accounts.blog <span class="hljs-string">'{"token":"xxx"}'</span>

<span class="hljs-comment"># ✅ 正确：patch 整个 accounts 对象</span>
openclaw config patch channels.telegram.accounts <span class="hljs-string">'{
  "main": {"token":"token1", "dmPolicy":"allowlist", "allowFrom":["123456789"]},
  "blog": {"token":"token2", "dmPolicy":"allowlist", "allowFrom":["123456789"]}
}'</span>
</code></pre>
<p>同样适用于 <code>bindings</code>、<code>agents.list</code> 等数组或对象。</p>
<p><strong>最佳实践：</strong></p>
<p>配置变更前，先导出当前配置：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 导出当前配置</span>
openclaw config get channels.telegram.accounts &gt; telegram-accounts-backup.json

<span class="hljs-comment"># 编辑后再 patch 回去</span>
openclaw config patch channels.telegram.accounts <span class="hljs-string">"<span class="hljs-subst">$(cat telegram-accounts-edited.json)</span>"</span>
</code></pre>
<h3 data-id="heading-13">问题 2：Telegram bot 不响应消息</h3>
<p><strong>现象：</strong></p>
<p>给 bot 发 <code>/start</code> 或任何消息，都没有回复。</p>
<p><strong>可能的原因 1：dmPolicy 配置问题</strong></p>
<p>检查配置：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config get channels.telegram.accounts.blog.dmPolicy
</code></pre>
<p>如果是 <code>pairing</code> 或未设置，改成 <code>allowlist</code>：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config patch channels.telegram.accounts.blog.dmPolicy <span class="hljs-string">'"allowlist"'</span>
openclaw config patch channels.telegram.accounts.blog.allowFrom <span class="hljs-string">'["123456789"]'</span>
openclaw gateway restart
</code></pre>
<p><strong>可能的原因 2：Telegram 409 冲突</strong></p>
<p><strong>症状：</strong> 日志中有 <code>getUpdates conflict (409)</code> 错误。</p>
<p><strong>原因：</strong> 同一个 bot token 被多个实例同时使用！常见场景：</p>
<ul>
<li>OpenClaw.app (GUI) 和 CLI gateway 同时运行</li>
<li>两个 terminal 同时启动了 gateway</li>
</ul>
<p><strong>检查：</strong></p>
<pre><code class="hljs language-bash" lang="bash">ps aux | grep -i openclaw
</code></pre>
<p>如果看到多个进程（GUI app 和 CLI gateway），说明冲突了。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>退出 OpenClaw.app (GUI)</li>
<li>重启 CLI gateway：</li>
</ol>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart --reason <span class="hljs-string">"清除 Telegram bot 冲突"</span>
</code></pre>
<p><strong>教训：</strong></p>
<p>同一个 Telegram bot token <strong>只能被一个 Gateway 实例使用</strong>。如果要切换 GUI/CLI，必须先停掉其中一个。</p>
<h3 data-id="heading-14">问题 3：绑定规则不生效</h3>
<p><strong>现象：</strong></p>
<p>配置了 <code>bindings</code>，但消息还是路由到了错误的 Agent。</p>
<p><strong>检查绑定：</strong></p>
<pre><code class="hljs language-bash" lang="bash">openclaw agents list --bindings
</code></pre>
<p><strong>常见错误：</strong></p>
<ol>
<li><strong>顺序错误</strong>：更具体的规则要放在前面</li>
</ol>
<pre><code class="hljs language-json5" lang="json5">// ❌ 错误：通配规则在前，精确规则在后
bindings: [
  { agentId: "main", match: { channel: "telegram" } }, // 会匹配所有 telegram 消息
  { agentId: "blog", match: { channel: "telegram", accountId: "blog" } }, // 永远不会执行
]

// ✅ 正确：精确规则在前
bindings: [
  { agentId: "blog", match: { channel: "telegram", accountId: "blog" } },
  { agentId: "main", match: { channel: "telegram", accountId: "main" } },
]
</code></pre>
<ol start="2">
<li><strong>accountId 拼写错误</strong>：检查是否与 <code>channels.telegram.accounts</code> 中的 key 一致</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 列出所有配置的账号</span>
openclaw config get channels.telegram.accounts | jq <span class="hljs-string">'keys'</span>
</code></pre>
<h3 data-id="heading-15">问题 4：Agent 配置变更后不生效</h3>
<p><strong>解决方法：</strong></p>
<p>Gateway 需要重启才能加载新配置：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart --reason <span class="hljs-string">"更新 Agent 配置"</span>
</code></pre>
<p>检查 Agent 是否正常启动：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw status --deep
</code></pre>
<p>如果看到某个 Agent 状态异常，查看日志：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">tail</span> -n 100 ~/.openclaw/gateway.err.log
</code></pre>
<h3 data-id="heading-16">问题 5：配置了嵌套对象，但只有部分生效</h3>
<p><strong>现象：</strong></p>
<p>我在顶层配置了 <code>channels.telegram.dmPolicy</code>，为什么某个账号还是用了不同的策略？</p>
<p><strong>原因：</strong></p>
<p>配置有<strong>继承关系</strong>，account 级别的配置会<strong>覆盖</strong>顶层配置：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      dmPolicy: "allowlist", // 顶层默认
      allowFrom: ["123456789"],
      accounts: {
        main: {
          token: "token1",
          // 继承顶层的 dmPolicy 和 allowFrom
        },
        public: {
          token: "token2",
          dmPolicy: "pairing", // 覆盖顶层配置
        },
      },
    },
  },
}
</code></pre>
<p><strong>最佳实践：</strong></p>
<ul>
<li>如果所有账号都用相同策略，配置在顶层</li>
<li>如果某个账号需要不同策略，在 account 级别覆盖</li>
<li>明确写出每个 account 的 <code>dmPolicy</code>，避免继承混淆</li>
</ul>
<h2 data-id="heading-17">最佳实践</h2>
<h3 data-id="heading-18">1. 配置变更前先审查</h3>
<p><strong>教训：</strong> 我曾因为没仔细审查 patch 命令，把所有 Telegram 账号配置冲掉，导致所有 bot 连接中断。</p>
<p><strong>规则：</strong></p>
<ul>
<li>任何 <code>config.patch</code>、<code>gateway restart</code>、模型变更等操作，<strong>先审查一遍</strong></li>
<li>嵌套对象（<code>bindings</code>、<code>accounts</code>）必须带完整列表</li>
<li>有疑问先导出当前配置对比</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 变更前备份</span>
openclaw config get &gt; openclaw-config-backup.json

<span class="hljs-comment"># 变更后对比</span>
openclaw config get &gt; openclaw-config-new.json
diff openclaw-config-backup.json openclaw-config-new.json
</code></pre>
<h3 data-id="heading-19">2. 使用 status --deep 诊断</h3>
<pre><code class="hljs language-bash" lang="bash">openclaw status --deep
</code></pre>
<p>输出包括：</p>
<ul>
<li>每个 Agent 的状态</li>
<li>Channel 连接状态</li>
<li>最近的错误日志</li>
</ul>
<p>如果某个 Agent 或 Channel 异常，会直接显示。</p>
<h3 data-id="heading-20">3. 查看错误日志</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 实时查看日志</span>
<span class="hljs-built_in">tail</span> -f ~/.openclaw/gateway.err.log

<span class="hljs-comment"># 搜索特定错误</span>
grep -i <span class="hljs-string">"error\|conflict\|fail"</span> ~/.openclaw/gateway.err.log | <span class="hljs-built_in">tail</span> -n 50
</code></pre>
<p>常见错误关键词：</p>
<ul>
<li><code>409 conflict</code>：Telegram bot 冲突</li>
<li><code>unauthorized</code>：token 错误或过期</li>
<li><code>dmPolicy</code>：消息被访问控制策略拦截</li>
<li><code>binding</code>：路由规则问题</li>
</ul>
<h3 data-id="heading-21">4. 分阶段配置</h3>
<p>不要一次性配置所有 Agent 和 Channel，容易出错且难以排查。</p>
<p><strong>推荐流程：</strong></p>
<ol>
<li>先配置一个新 Agent（不配置 Telegram），本地测试</li>
<li>Agent 正常后，添加一个 Telegram bot，测试路由</li>
<li>验证通过后，再添加其他 Agent 和 bot</li>
<li>每次变更后，验证所有已有功能正常</li>
</ol>
<h3 data-id="heading-22">5. 文档化你的配置</h3>
<p>在 workspace 下创建 <code>SETUP.md</code>，记录：</p>
<ul>
<li>每个 Agent 的用途和配置</li>
<li>Telegram bot 对应关系</li>
<li>特殊配置的原因</li>
</ul>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># SETUP.md</span>

<span class="hljs-section">## Agents</span>
<span class="hljs-bullet">-</span> main: 日常聊天，全功能，Telegram @MyMainBot
<span class="hljs-bullet">-</span> blog: 技术写作，workspace-blog，Telegram @MyWorkBot
<span class="hljs-bullet">-</span> novel: 小说创作，workspace-novel，仅本地使用

<span class="hljs-section">## Telegram Bots</span>
<span class="hljs-bullet">-</span> @MyMainBot (123456789): main agent
<span class="hljs-bullet">-</span> @MyWorkBot (987654321): work agent

<span class="hljs-section">## 特殊配置</span>
<span class="hljs-bullet">-</span> work agent 的 dmPolicy 设为 allowlist，只允许授权用户访问
<span class="hljs-bullet">-</span> main agent 启用了 heartbeat，定期检查日程
</code></pre>
<h2 data-id="heading-23">总结</h2>
<p>OpenClaw 多 Agent 配置不复杂，但有几个容易踩的坑：</p>
<ol>
<li><strong>config.patch 陷阱</strong>：嵌套对象是整体替换，不是增量修改</li>
<li><strong>模型 ID</strong>：用别名（<code>claude-sonnet-4-5</code>），不要带日期</li>
<li><strong>BOOTSTRAP.md</strong>：不要手动创建，会导致 Agent 卡住</li>
<li><strong>dmPolicy</strong>：默认是 <code>pairing</code>，建议改成 <code>allowlist</code></li>
<li><strong>Telegram 409</strong>：同一个 bot token 只能被一个 Gateway 使用</li>
<li><strong>配置继承</strong>：account 级别配置会覆盖顶层配置</li>
</ol>
<p><strong>核心原则：</strong></p>
<ul>
<li>配置前先备份</li>
<li>变更后先验证</li>
<li>出问题先看日志</li>
<li>分阶段逐步配置</li>
</ul>
<p>希望这篇文章能帮你少走弯路。如果还有其他问题，欢迎在评论区讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026年了，为什么我建议你放弃“纯原生”开发？]]></title>    <link>https://juejin.cn/post/7605769126272139310</link>    <guid>https://juejin.cn/post/7605769126272139310</guid>    <pubDate>2026-02-13T03:07:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605769126272139310" data-draft-id="7605907495769227273" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026年了，为什么我建议你放弃“纯原生”开发？"/> <meta itemprop="keywords" content="Flutter,客户端"/> <meta itemprop="datePublished" content="2026-02-13T03:07:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员老刘"/> <meta itemprop="url" content="https://juejin.cn/user/662360127965769"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026年了，为什么我建议你放弃“纯原生”开发？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/662360127965769/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员老刘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:07:21.000Z" title="Fri Feb 13 2026 03:07:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>大家好，我是老刘</strong></p>
<p>昨天有个老朋友找我喝酒，哭丧着脸。</p>
<p>这哥们是个五年的Android开发，技术那是没得说。</p>
<p>能独立完成复杂的系统模块，优化过千万级日活的App。</p>
<p>最近去面试一家大厂挂了。</p>
<p>面试官就问了一句：</p>
<p>“如果让你带队把这个模块迁移到鸿蒙和 iOS，除了重写三遍，你有什么低成本方案？”</p>
<p>他愣住了，他引以为傲的原生深度，在降本增效的大潮面前，就变成了一颗昂贵的螺丝钉。</p>
<p>2026 年，不知道有多少朋友又开始了或者将要开始投简历、面试的过程。</p>
<p>老刘借着这篇文章聊聊原生开发、跨平台开发在AI时代的客户端开发领域的生态位，以及作为开发者，我们该如何优化我们的技能树，以适应这个快速变化的行业。</p>
<hr/>
<h2 data-id="heading-0">原生不是死了，而是下沉了</h2>
<p>别误会，我不是说原生技术要消失。</p>
<p>它只是下沉了，沉成了基础设施，就有点像汇编语言一样。</p>
<p>你看现在的 App 架构是啥样的？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5fb17713aeae4696b5564608272e05a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556840&amp;x-signature=h%2BAMmisL%2BDCz124o%2F7KBfAMFq4U%3D" alt="Mermaid Diagram" loading="lazy"/></p>
<p>如果你只守着那 10% 的原生胶水层，你的职业道路只会越走越窄。</p>
<p>最后变成公司里那个维护遗留代码的守门人，每天对着一堆陈年老代码叹气。</p>
<p>新人都在用新架构写新业务，你在角落里修改哪些该死的兼容性 Bug。</p>
<hr/>
<h2 data-id="heading-1">Flutter vs 原生</h2>
<p>这里老刘不想讨论技术参数的差异，而是想站在开发者的角度，谈谈聚焦不同的技术栈对我们有什么影响。</p>
<p>很多坚持“纯原生”的兄弟，理由往往只有一个：</p>
<p>“原生体验更好，性能更强，跨平台总觉得有点卡。”</p>
<p>听着挺有道理，但在 2026 年，这更像是一个给自己寻找舒适区的借口。</p>
<p><strong>现在的跨平台技术，早已经不是当年的“缝合怪”了。</strong></p>
<p>以 Flutter 为例， Impeller 引擎的成熟，让它的渲染性能在大多数业务场景下，已经做到了和原生毫无差异的程度。</p>
<p>你还在纠结那个滚动条的阻尼感是不是差了 0.01 秒，老板在纠结为什么隔壁组用一套代码已经上线了三个平台，而你还在为 iOS 的一个布局错位调了一下午。</p>
<p><strong>未来的核心竞争力，是端抽象的能力</strong></p>
<p>当你站在跨平台的角度进行开发，你思考问题的维度就变了：</p>
<ul>
<li>你不再是“那个写 Android 的”，你是“那个能搞定全端交付的”。</li>
<li>你不再关心某个系统的私有 API，你开始关心如何设计一套通用的组件库，让业务逻辑在各个端之间无缝流动。</li>
</ul>
<p>这种“端抽象”的能力，才是跨平台开发者真正的护城河。</p>
<hr/>
<h2 data-id="heading-2">跨平台（Flutter）不是加分项，而是及格线</h2>
<p>以前面试，你会 Flutter是加分项。</p>
<p>现在那是及格线。</p>
<p>看看现在的终端环境，乱成一锅粥了：Android、iOS、鸿蒙、web、桌面端...</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed67a001c10541e7a7b5eacd83040b21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556840&amp;x-signature=XHKuTug%2BCYh2v8rTs%2Fcual4UDMY%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>你指望老板招 5 拨人去维护 5 套代码？</p>
<p>老板根本不在乎你用原生还是Flutter，老板只在乎能不能把团队裁到只有一个人，然后你把所有的工作搞定。</p>
<p>只会纯原生等于把自己锁死在一个平台上。</p>
<p>一旦那个平台没落了，或者公司业务调整不做了。</p>
<p>想想当年的塞班开发，甚至前几年的 Windows Phone 开发，是不是背脊发凉？</p>
<hr/>
<h2 data-id="heading-3">你是不是那个解决问题的人？</h2>
<p>其实不管是团队的技术方案选择，还是开发者个人技能树的升级，技术栈的选择从来都不仅仅是技术参数的对比。</p>
<p><strong>站在团队的角度</strong>，老刘当年选择Flutter的原因有以下几个方面：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22fabffacbe9458eadf0143d7c58cc96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556840&amp;x-signature=6Tu8iY%2B0lQTxqiYxLzyvWmqvBEE%3D" alt="Mermaid Diagram" loading="lazy"/></p>
<p><strong>站在开发者个人的角度</strong>，你需要保证自己的技能树中点出来当前主流的技术方向。</p>
<p>我不是说一定要学Flutter或者某一个技术，而是你要知道现在在行业内大家都在用哪些技术。</p>
<p>而被大量企业和团队选择的技术栈大概率是当前最能解决实战问题的，或者是最具备性价比的选项。</p>
<p>为啥要做从众的选择？</p>
<p>因为商业社会你不能做那个掌握屠龙技的人，而要与做那个解决问题的人。</p>
<p>那什么样的技术路线能解决问题呢？</p>
<p>并不是你钻研最深入的，看起来参数最好的，而是你的同事都会用的。</p>
<p>不仅仅是你的同事，还是那些LLM比如Claude、ChatGPT甚至Kimi都能玩得转的。</p>
<hr/>
<h2 data-id="heading-4">换个活法，路宽得很</h2>
<p>我建议你放弃纯原生，不是让你忘掉基础。</p>
<p>而是让你放弃那种画地为牢的心态。</p>
<p>不要做一个只会砌墙的泥瓦匠，要做一个懂结构的建筑师。</p>
<p>未来属于那些<strong>站在原生肩膀上，用跨平台和 AI 俯视业务</strong>的开发者。</p>
<p>别让技术栈限制了你的想象力。</p>
<p>更别让纯原生限制了你的身价。</p>
<p>共勉。</p>
<blockquote>
<p>🤝 如果看到这里的同学对客户端或者Flutter开发感兴趣，欢迎联系老刘，我们互相学习。</p>
<p>🎁 私信免费领老刘整理的《Flutter开发手册》，覆盖90%应用开发场景。可以作为Flutter学习的知识地图。</p>
<p>💬 : laoliu_dev</p>
</blockquote>
<blockquote>
<p>📂 老刘也把自己历史文章整理在GitHub仓库里，方便大家查阅。
🔗 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flzt-code%2Fblog" target="_blank" title="https://github.com/lzt-code/blog" ref="nofollow noopener noreferrer">github.com/lzt-code/bl…</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[零 JavaScript 的性能优化视频嵌入]]></title>    <link>https://juejin.cn/post/7605807405307412543</link>    <guid>https://juejin.cn/post/7605807405307412543</guid>    <pubDate>2026-02-13T03:07:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605807405307412543" data-draft-id="7605941424535928886" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="零 JavaScript 的性能优化视频嵌入"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-13T03:07:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掘金安东尼"/> <meta itemprop="url" content="https://juejin.cn/user/1521379823340792"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            零 JavaScript 的性能优化视频嵌入
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1521379823340792/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    掘金安东尼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:07:56.000Z" title="Fri Feb 13 2026 03:07:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Ffrontendmasters.com%2Fblog%2Fperformance-optimized-video-embeds-with-zero-javascript%2F" target="_blank" title="https://frontendmasters.com/blog/performance-optimized-video-embeds-with-zero-javascript/" ref="nofollow noopener noreferrer">Performance-Optimized Video Embeds with Zero JavaScript</a></p>
<p>翻译：TUARAN</p>
<p>欢迎关注 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTUARAN%2Ffrontend-weekly-digest-cn" target="_blank" title="https://github.com/TUARAN/frontend-weekly-digest-cn" ref="nofollow noopener noreferrer">{{前端周刊}}</a>，每周更新国外论坛的前端热门文章，紧跟时事，掌握前端技术动态。</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9adab526bf35403b930731150fbe7285~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR5a6J5Lic5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556876&amp;x-signature=qCH4PSQPzxnMqBljgE%2BTusLDBL4%3D" alt="image.png" loading="lazy"/></p>
<p>嵌入视频往往会显著拖慢页面：播放器会加载一堆额外资源，即使用户最终根本不点播放。</p>
<p>常见的优化是用 <code>lite-youtube-embed</code> 之类的轻量组件先占位、再按需加载。但如果视频就在首屏（above the fold），仍然可能因为占位与真实播放器尺寸/渲染时机问题带来 CLS（累计布局偏移）。</p>
<p>这篇文章给出一种“极简但很实用”的模式：只用原生 HTML 的 <code>&lt;details&gt;</code> / <code>&lt;summary&gt;</code> + 一点 CSS，实现<strong>交互时才加载 iframe</strong>，并且不写一行 JS。</p>
<h2 data-id="heading-0">解决方案：用 <code>&lt;details&gt;</code> / <code>&lt;summary&gt;</code> 作为交互边界</h2>
<p><code>&lt;summary&gt;</code> 的默认行为类似按钮：点击会展开对应 <code>&lt;details&gt;</code>，浏览器会给 <code>&lt;details&gt;</code> 加上 <code>open</code> 属性；再点一次就收起。</p>
<p>页面初始加载时，<code>&lt;details&gt;</code> 内除了 <code>&lt;summary&gt;</code> 以外的内容默认不显示——这使它天然适合“用户交互后才呈现”的内容（比如 iframe 视频）。</p>
<h2 data-id="heading-1">懒加载：要避免“首屏懒加载反伤”</h2>
<p>现代浏览器支持 <code>loading="lazy"</code> 对图片与 iframe 做原生懒加载。</p>
<p>但需要注意：把所有东西都懒加载，可能反而让 LCP 变差。Chrome 团队的研究提到，过度懒加载可能让 LCP 下降约 20%，尤其是当你把内容懒加载到首屏视口里时。</p>
<p>这里的关键点在于：iframe 视频作为 <code>&lt;details&gt;</code> 的内容，在用户点击之前并不算“初始视口内容”，所以不会触发那种“首屏懒加载带来的反效果”。</p>
<p>结论：如果你本来就把视频放在一个可折叠区域里（accordion），那就非常适合把它延迟到“用户想看”的那一刻才加载。</p>
<h2 data-id="heading-2">样式：把 <code>&lt;summary&gt;</code> 做成视频缩略图</h2>
<p>默认的 <code>&lt;details&gt;</code> 样式很朴素。我们可以把 <code>&lt;summary&gt;</code> 做成一个“视频缩略图占位”，上面叠一个自定义播放按钮。</p>
<pre><code class="hljs language-ini" lang="ini">&lt;details <span class="hljs-attr">class</span>=<span class="hljs-string">"video-embed"</span>&gt;
  &lt;summary <span class="hljs-attr">class</span>=<span class="hljs-string">"video-summary"</span> aria-label=<span class="hljs-string">"播放视频：Big Buck Bunny"</span>&gt;
    &lt;img
      <span class="hljs-attr">src</span>=<span class="hljs-string">"https://lab.n8d.studio/htwoo/htwoo-core/images/videos/big-bug-bunny.webp"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"video-thumbnail"</span>
      <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>
    /&gt;
    &lt;svg <span class="hljs-attr">class</span>=<span class="hljs-string">"video-playicon"</span> viewBox=<span class="hljs-string">"0 0 32 32"</span> aria-hidden=<span class="hljs-string">"true"</span>&gt;
      &lt;path <span class="hljs-attr">d</span>=<span class="hljs-string">"m11.167 5.608 16.278 8.47a2.169 2.169 0 0 1 .011 3.838l-.012.006-16.278 8.47a2.167 2.167 0 0 1-3.167-1.922V7.529a2.167 2.167 0 0 1 3.047-1.981l-.014-.005.134.065z"</span> /&gt;
    &lt;/svg&gt;
  &lt;/summary&gt;

  &lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"video-content"</span>&gt;
    &lt;!-- 原始 embed 代码尽量不改，直接放进来 --&gt;
    &lt;iframe
      <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.youtube.com/embed/aqz-KE-bpKQ?autoplay=1"</span>
      <span class="hljs-attr">title</span>=<span class="hljs-string">"Big Buck Bunny"</span>
      <span class="hljs-attr">loading</span>=<span class="hljs-string">"lazy"</span>
      <span class="hljs-attr">allow</span>=<span class="hljs-string">"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"</span>
      allowfullscreen
    &gt;&lt;/iframe&gt;
  &lt;/div&gt;
&lt;/details&gt;
</code></pre>
<p>要点：</p>
<ul>
<li>缩略图与 iframe 维持同一宽高比（避免布局跳动）。</li>
<li>播放按钮用自有 SVG，保证品牌一致性。</li>
<li><code>aria-label</code> 给屏幕阅读器一个明确的动作提示（作者也强调需要做跨 VoiceOver/NVDA/JAWS 的实际测试）。</li>
</ul>
<p>CSS 可以用 grid 把按钮叠在缩略图正中：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.video-summary</span> {
  <span class="hljs-attribute">display</span>: grid;
  place-items: center;
}

<span class="hljs-selector-class">.video-thumbnail</span>,
<span class="hljs-selector-class">.video-playicon</span> {
  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / <span class="hljs-number">1</span>;
}

<span class="hljs-selector-class">.video-playicon</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">64px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">64px</span>;
}
</code></pre>
<h2 data-id="heading-3">展开后隐藏缩略图，让 iframe 出现</h2>
<p><code>&lt;summary&gt;</code> 默认即使展开也会持续可见；但我们展开后希望看到的是 iframe，而不是缩略图。</p>
<p>思路很简单：当 <code>&lt;details&gt;</code> 具备 <code>open</code> 属性时，把 summary 隐藏。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.video-embed</span> {
  <span class="hljs-attribute">position</span>: relative;
}

<span class="hljs-selector-class">.video-embed</span><span class="hljs-selector-attr">[open]</span> <span class="hljs-selector-class">.video-summary</span> {
  <span class="hljs-attribute">visibility</span>: hidden;
}

<span class="hljs-selector-class">.video-content</span> <span class="hljs-selector-tag">iframe</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
}
</code></pre>
<p>用户点击缩略图时：</p>
<ul>
<li>浏览器把 <code>open</code> 加到 <code>&lt;details&gt;</code> 上</li>
<li>summary 被隐藏</li>
<li>iframe 进入视口并开始加载（而且只在用户真的想看时才加载）</li>
</ul>
<p>小提示：对于 YouTube，可以在 iframe URL 上加 <code>?autoplay=1</code>，让播放器尽快开始播放；但如果用户浏览器禁用了 autoplay，仍需要再次点击。</p>
<h2 data-id="heading-4">性能对比（与 lite-youtube-embed）</h2>
<p>作者用同一张缩略图对比了本方案与 <code>lite-youtube-embed</code>：</p>





















































<table><thead><tr><th>指标</th><th><code>&lt;details&gt;</code> 模式</th><th>lite-youtube-embed</th><th>更优</th></tr></thead><tbody><tr><td>Load Time</td><td>595ms</td><td>693ms</td><td><code>&lt;details&gt;</code>（约快 14%）</td></tr><tr><td>FCP</td><td>11ms</td><td>70ms</td><td><code>&lt;details&gt;</code>（约快 6.4×）</td></tr><tr><td>LCP</td><td>97ms</td><td>157ms</td><td><code>&lt;details&gt;</code>（约快 1.6×）</td></tr><tr><td>Transfer</td><td>34 KB</td><td>84 KB</td><td><code>&lt;details&gt;</code>（约少 2.5×）</td></tr><tr><td>CLS</td><td>0.0075</td><td>0.0000</td><td>都不错</td></tr><tr><td>TBT</td><td>0ms</td><td>0ms</td><td>持平</td></tr><tr><td>JavaScript</td><td>0</td><td>~3KB</td><td><code>&lt;details&gt;</code></td></tr></tbody></table>
<p>（原文还提到资源请求数量也显著更少。）</p>
<h2 data-id="heading-5">收尾</h2>
<ul>
<li><code>&lt;details&gt;</code> 自 2011 起就在浏览器中可用</li>
<li>iframe 原生 lazy loading 大约在 2019 落地</li>
</ul>
<p>把两者结合起来，你就能获得“首屏更快、重内容延后、交互自然、键盘可用”的视频嵌入体验，而且完全不依赖 JavaScript。</p>
<p>它不是一个“产品”，而是一个“模式”：同样适用于 Vimeo、自托管视频、GIF、CodePen、地图等任何重量级嵌入内容。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击]]></title>    <link>https://juejin.cn/post/7605811866908524553</link>    <guid>https://juejin.cn/post/7605811866908524553</guid>    <pubDate>2026-02-13T02:49:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908524553" data-draft-id="7605817795628597298" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击"/> <meta itemprop="keywords" content="JavaScript,Java"/> <meta itemprop="datePublished" content="2026-02-13T02:49:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Gogo1121"/> <meta itemprop="url" content="https://juejin.cn/user/4162081326907051"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4162081326907051/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Gogo1121
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:49:12.000Z" title="Fri Feb 13 2026 02:49:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>让我们先看两段代码。</p>
<p><strong>Java 代码：</strong></p>
<pre><code class="hljs language-ini" lang="ini">CountPointsTransactDto <span class="hljs-attr">record</span> = new CountPointsTransactDto()<span class="hljs-comment">;</span>
<span class="hljs-attr">record.amount</span> = <span class="hljs-number">100</span><span class="hljs-comment">;</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>TypeScript 代码：</strong></p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">record</span> = new CountPointsTransactDto()<span class="hljs-comment">;</span>
<span class="hljs-attr">record.amount</span> = <span class="hljs-number">100</span><span class="hljs-comment">;</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p>乍一看，这简直就是<strong>双胞胎</strong>。语法结构、关键字、甚至赋值方式都如出一辙。很多从 Java 转过来的后端同学看到这里会松一口气：“切，TS 不就是带类型的 JS 嘛，跟写 Java 没区别。”</p>
<p><strong>大错特错。</strong></p>
<p>虽然它们长得像，但在计算机内存的微观世界里，这两行代码触发的逻辑完全属于两个不同的宇宙。</p>
<hr/>
<h2 data-id="heading-0">🧊 一、内存模型：蓝图 vs 黏土</h2>
<h3 data-id="heading-1">1. Java 的 <code>new</code>：严格的蓝图 (Blueprint)</h3>
<p>在 Java 中，类（Class）是一张<strong>不可修改的工程蓝图</strong>。</p>
<p>当你执行 <code>new</code> 时，JVM 会做以下事情：</p>
<ol>
<li><strong>加载蓝图</strong>：读取 <code>.class</code> 文件，解析字段和方法。</li>
<li><strong>划地盘</strong>：根据蓝图计算出对象需要多少内存（例如：2个 int + 1个 String 引用 = 固定字节数）。</li>
<li><strong>浇筑</strong>：在堆内存中开辟一块<strong>固定大小、固定结构</strong>的区域。</li>
</ol>
<p><strong>结论</strong>：Java 对象出生那一刻，它的结构就定死了。你不可能在运行时突然给它加一个 <code>nickname</code> 属性。如果你敢这么做，编译器会直接报错，IDE 会标红。</p>
<h3 data-id="heading-2">2. TypeScript (JS) 的 <code>new</code>：可塑的黏土 (Clay)</h3>
<p>在 TypeScript（最终运行的是 JavaScript）中，类只是一个<strong>函数</strong>，对象只是一个<strong>哈希表（Key-Value Map）</strong> 。</p>
<p>当你执行 <code>new</code> 时，JS 引擎做了这 4 件事：</p>
<ol>
<li>创建一个空的哈希表 <code>{}</code>。</li>
<li>把这个空表的 <code>__proto__</code> 指针指向类的 <code>prototype</code>（为了能用类的方法）。</li>
<li>执行构造函数（Constructor），给这个哈希表塞入初始属性（如 <code>this.amount = 0</code>）。</li>
<li>返回这个哈希表。</li>
</ol>
<p><strong>结论</strong>：JS 对象本质上是一团可以随意揉捏的黏土。</p>
<p>虽然 TypeScript 的编译器（tsc）会像 Java 一样检查你的拼写，但在<strong>运行时</strong>，你完全可以给这个对象追加任何属性（<code>record.whatever = 123</code>），JS 引擎绝不会拦你。</p>
<hr/>
<h2 data-id="heading-3">⚔️ 二、赋值逻辑：权限控制 vs 约定俗成</h2>
<h3 data-id="heading-4">Java：严防死守</h3>
<p>Java 能不能直接赋值，取决于<strong>访问修饰符</strong>。</p>
<ul>
<li>如果 <code>amount</code> 是 <code>public</code>，可以。</li>
<li>但 Java 开发的黄金法则是 <strong>封装（Encapsulation）</strong> 。绝大多数 entity/dto 的字段都是 <code>private</code> 的，必须通过 <code>setAmount()</code> 方法来访问。</li>
<li><strong>为什么？</strong> 为了安全。Java 可以在 setter 里加逻辑（比如 <code>if (amount &lt; 0) throw error</code>），保证数据安全。</li>
</ul>
<h3 data-id="heading-5">TypeScript：自由奔放</h3>
<p>TypeScript 默认所有属性都是 <code>public</code>。</p>
<p>在 TS/JS 生态中，直接操作属性（<code>record.amount = 100</code>）是<strong>标准做法</strong>。</p>
<ul>
<li>我们很少在 DTO 里写 <code>getAmount()</code> / <code>setAmount()</code>。</li>
<li><strong>为什么？</strong> 因为 JS 追求灵活性和简洁。如果真要控制权限，TS 也有 <code>private</code> 关键字，但那只是编译时的约束，编译成 JS 后，私有属性依然可以被访问（虽然不推荐）。</li>
</ul>
<hr/>
<h2 data-id="heading-6">🦆 三、类型系统：名义 vs 结构 (核心差异)</h2>
<p>这是最颠覆 Java 开发者认知的一点。</p>
<h3 data-id="heading-7">Java：名义类型 (Nominal Typing)</h3>
<p>Java 只认<strong>名字</strong>（身份证）。</p>
<p>哪怕两个类长得一模一样，名字不一样，就是不兼容。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> { <span class="hljs-type">int</span> x; }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> { <span class="hljs-type">int</span> x; }
<span class="hljs-type">A</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>(); <span class="hljs-comment">// ❌ 报错！B 不是 A。</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-8">TypeScript：结构化类型 (Structural / Duck Typing)</h3>
<p>TypeScript 只认<strong>长相</strong>（鸭子测试）。</p>
<p>只要你长得像（属性列表匹配），你就是它。</p>
<pre><code class="hljs language-css" lang="css">class <span class="hljs-selector-tag">A</span> { x: number; }
class <span class="hljs-selector-tag">B</span> { x: number; }
const obj: A = new <span class="hljs-built_in">B</span>(); // ✅ 通过！因为 <span class="hljs-selector-tag">B</span> 也有 x，结构满足 <span class="hljs-selector-tag">A</span> 的要求。
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这也是为什么在 TS 里，你经常看到有人<strong>偷懒</strong>，不用 <code>new</code>，而是直接写个字面量对象：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// TS 允许这样（只要属性对得上）</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">record</span>: <span class="hljs-title">CountPointsTransactDto</span> = { amount: <span class="hljs-number">100</span> }; 
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-9">🤔 四、灵魂拷问：既然如此，为什么还要用 <code>new</code>？</h2>
<p>既然 <code>{ amount: 100 }</code> 就能冒充 DTO，为什么我们在 NestJS 中还是推荐写：</p>
<p><code>const record = new CountPointsTransactDto();</code></p>
<p>原因有三：</p>
<ol>
<li>
<p><strong>初始值 (Default Values)</strong> ：</p>
<p>类里定义了 <code>status = 'PENDING'</code>，<code>new</code> 出来的对象自动就有。字面量 <code>{}</code> 必须手动写一遍。</p>
</li>
<li>
<p><strong>方法 (Methods)</strong> ：</p>
<p>只有 <code>new</code> 出来的实例才挂载了原型链，才能调用 DTO 里定义的 <code>isValid()</code> 或 <code>calculateTax()</code> 方法。</p>
</li>
<li>
<p><strong>元数据 (Metadata &amp; Decorators)</strong> ：</p>
<p>这是最重要的。NestJS 大量使用装饰器（如 <code>@IsString()</code>, <code>@Expose()</code>）。</p>
<p><strong>纯 JSON 对象是不带这些装饰器信息的</strong>。只有通过 <code>class-transformer</code> 的 <code>plainToInstance</code> 或者直接 <code>new</code> 出来的对象，验证管道（ValidationPipe）才能正常工作。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-10">📝 总结</h2>



































<table><thead><tr><th><strong>特性</strong></th><th><strong>Java (new)</strong></th><th><strong>TypeScript / JS (new)</strong></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>按照蓝图开辟固定内存块</td><td>创建空哈希表，链接原型链</td></tr><tr><td><strong>结构灵活性</strong></td><td><strong>不可变</strong> (编译后固定)</td><td><strong>高度可变</strong> (运行时可增删属性)</td></tr><tr><td><strong>属性赋值</strong></td><td>依赖 public/private，常用 Setter</td><td>默认 public，常用直接赋值</td></tr><tr><td><strong>类型兼容</strong></td><td><strong>看名字</strong> (必须是同一个类或子类)</td><td><strong>看结构</strong> (属性匹配即可)</td></tr><tr><td><strong>使用建议</strong></td><td>必须用 <code>new</code></td><td>推荐用 <code>new</code> (为了默认值和装饰器)</td></tr></tbody></table>
<p><strong>一句话总结：</strong></p>
<p>不要被 TypeScript 的语法糖欺骗了。它虽然穿上了 Java 的西装（Class, new, private），但它的灵魂依然是那个自由、灵活、基于原型的 JavaScript。理解了这一点，你写出的 TS 代码才会有真正的“TS 味”。</p>
<p>​同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[车载大端序和tcp大端序]]></title>    <link>https://juejin.cn/post/7605792874173415487</link>    <guid>https://juejin.cn/post/7605792874173415487</guid>    <pubDate>2026-02-13T03:01:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605792874173415487" data-draft-id="7605807405307215935" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="车载大端序和tcp大端序"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T03:01:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="十间fish"/> <meta itemprop="url" content="https://juejin.cn/user/2165385864686928"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            车载大端序和tcp大端序
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2165385864686928/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    十间fish
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:01:15.000Z" title="Fri Feb 13 2026 03:01:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><ul>
<li>
<p><strong>TCP/IP 大端 = 网络字节序 = htonl/htons</strong></p>
</li>
<li>
<p><strong>CAN DBC 大端 = Motorola 格式（CANoe/CANdb++ 里的 MSB）</strong></p>
</li>
</ul>
<h2 data-id="heading-0">一个字节内部的 bit 是固定的</h2>
<p>任何一个字节，硬件上永远是：</p>
<p>plaintext</p>
<pre><code class="hljs language-markdown" lang="markdown">bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
<span class="hljs-code">                                  
最高位                                    最低位
</span></code></pre>
<h3 data-id="heading-1">这个 <strong>bit7~bit0 的顺序，永远不会变</strong>。不管你用大端、小端、网络序、DBC，<strong>单个字节内部的 bit 编号永远固定</strong>。</h3>
<h3 data-id="heading-2">① TCP 大端（网络字节序）</h3>
<ul>
<li>只管<strong>字节序</strong>，不管<strong>位序</strong></li>
<li>字节：<strong>高字节在前，低字节在后</strong></li>
<li>位序：<strong>每个字节内部，位序不变</strong></li>
</ul>
<p>复习：</p>
<p>以 32 位整数 <code>0x12345678</code> 为例：</p>
<p>它在内存里（小端 CPU，比如 ARM/x86）是：</p>
<p>plaintext</p>
<pre><code class="hljs">低地址 → 高地址
0x78  0x56  0x34  0x12
</code></pre>
<p>用 <code>htonl</code> 转成 <strong>TCP 大端（网络序）</strong> 后：</p>
<p>plaintext</p>
<pre><code class="hljs">0x12  0x34  0x56  0x78
</code></pre>
<p>例：<code>0x12345678</code>TCP 大端传输：<code>12 34 56 78</code></p>
<h3 data-id="heading-3">② DBC 大端（Motorola）</h3>
<p><strong>既管字节序，又管位序，是 “整段信号按位从高往低排”</strong></p>
<p>规则：</p>
<ol>
<li><strong>信号的最高位（MSB）放在 CAN 报文的最高地址位</strong></li>
<li><strong>跨字节时，字节是大端顺序（高字节→低字节）</strong></li>
<li><strong>字节内部位也是大端位序（bit7→bit0）</strong></li>
</ol>
<p>DBC 信号解析必须：</p>
<ul>
<li>按 <strong>start_bit、length、byte_order=Motorola</strong> 逐位抽取</li>
<li>DBC 的 start_bit 不是从 Byte0 开始算，而是从 Byte7.bit7 开始算。</li>
<li>DBC Motorola 的信号，是从「你指定的 start_bit」开始，往「更小的数字」方向，连续占 N 个 bit。</li>
</ul>
<h4 data-id="heading-4">所谓的跨字节理解，取决于信号的长度</h4>
<h2 data-id="heading-5">用一个 32bit 信号，给你看什么叫「跨字节」</h2>
<p>我们定义一个信号：</p>
<ul>
<li><strong>Motorola 大端</strong></li>
<li><strong>start_bit = 63</strong>（就是 Byte7.bit7）</li>
<li><strong>length = 32 bit</strong></li>
</ul>
<h3 data-id="heading-6">它占的 bit 是：</h3>
<p>63 → 62 → 61 → … → 32一共 32 个 bit</p>
<h3 data-id="heading-7">对应到字节：</h3>
<ul>
<li>63～56 → <strong>Byte7</strong></li>
<li>55～48 → <strong>Byte6</strong></li>
<li>47～40 → <strong>Byte5</strong></li>
<li>39～32 → <strong>Byte4</strong></li>
</ul>
<h4 data-id="heading-8">信号横跨：</h4>
<p><strong>Byte7、Byte6、Byte5、Byte4</strong>这就是我之前说的：<strong>一个信号横跨 4 个字节。</strong></p>
<h2 data-id="heading-9">看需求：</h2>
<h4 data-id="heading-10">一、需求描述：（3.0）</h4>
<p>1）位置信息共享软开关关闭状态下，位置信息相关信号上传赋值0处理；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c38b33d98a94a19b3d2a664f6d3e66f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2B6Ze0ZmlzaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556475&amp;x-signature=60daghAWD%2F1uRjPpYreV6yi%2FloE%3D" alt="企业微信截图_17709510982755.png" loading="lazy"/></p>
<p>工具：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.csselectronics.com%2Fpages%2Fdbc-editor-can-bus-database" target="_blank" title="https://www.csselectronics.com/pages/dbc-editor-can-bus-database" ref="nofollow noopener noreferrer">DBC Editor for CAN Bus Database Files [Online | 100% Free] – CSS Electronics</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33fa594ccb704d8a9b493707b0b5acaf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2B6Ze0ZmlzaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556475&amp;x-signature=uqGJ%2BZcyCPTbBE7Lued8K35ExTw%3D" alt="企业微信截图_17708910896928.png" loading="lazy"/></p>
<h3 data-id="heading-11">2.2 MCU打包协议数据格式关键解析点</h3>
<p>(1)整体数据格式</p>



















<table><thead><tr><th>帧头（2Byte）</th><th>Payload数据长度（2Byte）</th><th>Counter（1Byte）</th><th>CRC（1Byte）</th><th>Payload（可变长度）</th></tr></thead><tbody><tr><td>0x514D</td><td> </td><td> </td><td> </td><td>包含 N 帧子数据</td></tr></tbody></table>
<p>（2）Payload 中的单帧子数据格式（确认.=》报文类型&amp;帧ID作为整体处理）</p>

















<table><thead><tr><th>起始标识（1Byte）</th><th>报文类型 + 帧 ID（2Byte）</th><th>Updatebit + 帧长度（1Byte）</th><th>帧数据（8-64Byte）</th></tr></thead><tbody><tr><td>0x55（有效帧）</td><td>高 4 位 = 报文类型（如 0x00=ZCU_CANFD1）低 12 位 = CanId</td><td>最高位 = Updatebit低 7 位 = 帧数据长度</td><td/></tr></tbody></table>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PositionSignalProcessor::clearBitsDBCBigEndian</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">int</span> data_len, <span class="hljs-type">uint32_t</span> start, <span class="hljs-type">uint32_t</span> length)</span> </span>{
    <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">nullptr</span> || data_len &lt;= <span class="hljs-number">0</span> || length == <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsDBCBigEndian: (data=%p, data_len=%d, start=%d, length=%d)\n"</span>,
                   data, data_len, start, length);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
   <span class="hljs-comment">// DBC大端字节序：按字节顺序，非连续位</span>
    <span class="hljs-type">int</span> startByte = start / <span class="hljs-number">8</span>;
    <span class="hljs-type">int</span> bitsInStartByte = start % <span class="hljs-number">8</span> + <span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> bitsLeft = length - bitsInStartByte;
    
    <span class="hljs-comment">// 边界检查</span>
    <span class="hljs-keyword">if</span> (startByte &gt;= data_len) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"frame boundary: startByte=%d &gt;= data_len=%d\n"</span>, startByte, data_len);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-comment">// 保存原始数据用于调试</span>
    std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; originalData;
    <span class="hljs-keyword">if</span> (m_debug) {
        originalData.<span class="hljs-built_in">assign</span>(data, data + data_len);
    }
    <span class="hljs-comment">// 如果有多于一个字节的位需要处理</span>
    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 清除第一个字节的高位</span>
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = <span class="hljs-number">0xFF</span> &lt;&lt; bitsInStartByte;
        data[startByte] &amp;= mask;

        <span class="hljs-comment">// 清除所有中间字节</span>
        <span class="hljs-type">int</span> middleByte = startByte + (bitsLeft) / <span class="hljs-number">8</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startByte + <span class="hljs-number">1</span>; i &lt;= middleByte; ++i) {
            data[i] = <span class="hljs-number">0</span>;
        }

        <span class="hljs-comment">// 处理最后一个字节的低位</span>
        <span class="hljs-type">int</span> lastByteBitsLeft = bitsLeft % <span class="hljs-number">8</span>;
        <span class="hljs-keyword">if</span> (lastByteBitsLeft &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">/*
             -1：将 1 &lt;&lt; n 生成的「1 后跟 n 个 0」的数，转为「n 个 1」的二进制数
             可以想象成「最右侧 N 个格子为 1，其余为 0」的遮挡板
             掩码为 1 的格子保留原值，掩码为 0 的格子清零
            */</span> 
            mask = (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">8</span> - lastByteBitsLeft)) - <span class="hljs-number">1</span>;
            data[middleByte + <span class="hljs-number">1</span>] &amp;= mask;
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 单字节情况</span>
        <span class="hljs-type">int</span> startBit = bitsInStartByte - length;
        <span class="hljs-comment">/*
            注意:单字节和上面的最后一个字节的处理不一样
            上面的处理只适用于：不管清零位在哪个位置，都只把「最右侧 N 个格子」设为 1
            而一旦清零位是字节中间位，就不适用。用下面数据可验证:
            9A 03 BB 64 1A 0A 67 28
            2.start = 36,len = 3 =&gt; 结果是 9A 03 BB 64 02 0A 67 28
        */</span>
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = ((<span class="hljs-number">1</span> &lt;&lt; length) - <span class="hljs-number">1</span>) &lt;&lt; startBit;
        data[startByte] &amp;= ~mask;
    }
    
    <span class="hljs-comment">// 调试输出</span>
    <span class="hljs-keyword">if</span> (m_debug) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsDBCBigEndian: 处理前数据 (start=%d, length=%d): \n"</span>, start, length);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data_len; ++i) {
            <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"%02X "</span>, originalData[i]);
        }
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"\n"</span>);

        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsDBCBigEndian: 处理后数据: \n"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data_len; ++i) {
            <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"%02X "</span>, data[i]);
        }
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"\n"</span>);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PositionSignalProcessor::clearBitsIntelLittleEndian</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">int</span> data_len, <span class="hljs-type">uint32_t</span> start, <span class="hljs-type">uint32_t</span> length)</span> </span>{
     <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">nullptr</span> || data_len &lt;= <span class="hljs-number">0</span> || length == <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: (data=%p, data_len=%d, start=%u, length=%u)\n"</span>,
                   data, data_len, start, length);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-comment">// 小端边界检查</span>
    <span class="hljs-keyword">if</span> (start - length + <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: frame boundary: start=%u, length=%u, start-length+1 &lt; 0\n"</span>, start, length);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-type">int</span> downByte = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(data_len) - <span class="hljs-number">1</span> - start / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">if</span> (downByte &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: frame boundary: downByte=%d &gt;= data_len=%d\n"</span>, downByte, data_len);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-type">int</span> bitsInDownByte = <span class="hljs-number">8</span> - start % <span class="hljs-number">8</span>;
    <span class="hljs-type">int</span> bitsLeft = length - bitsInDownByte;

    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: Multi byte case, start=%d, bitsInDownByte=%d, length=%d,bitsLeft=%d\n"</span>, start, bitsInDownByte, length,bitsLeft);
        <span class="hljs-comment">// 清除第一个字节的低位</span>
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(<span class="hljs-number">0xFF</span> &gt;&gt; bitsInDownByte);
        data[downByte] &amp;= mask;

        <span class="hljs-comment">// 清除中间字节</span>
        <span class="hljs-type">int</span> middleByte = downByte - (bitsLeft) / <span class="hljs-number">8</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = downByte - <span class="hljs-number">1</span>; i &gt;= middleByte; --i) {
            data[i] = <span class="hljs-number">0</span>;
        }

        <span class="hljs-comment">// 处理最后一个字节的高位</span>
        <span class="hljs-type">int</span> lastByteBitsLeft = bitsLeft % <span class="hljs-number">8</span>;
        <span class="hljs-keyword">if</span> (lastByteBitsLeft &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-type">int</span> lastByteIdx = middleByte - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (lastByteIdx &gt;= <span class="hljs-number">0</span>) {
                mask = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(<span class="hljs-number">0xFF</span> &lt;&lt; lastByteBitsLeft);
                data[lastByteIdx] &amp;= mask;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: frame boundary lastByteIdx=%d out of bounds\n"</span>, lastByteIdx);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 单字节情况</span>
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: Single byte case, start=%d, bitsInDownByte=%d, length=%d,bitsLeft=%d\n"</span>, start, bitsInDownByte, length,bitsLeft);
        <span class="hljs-type">int</span> leftBit = <span class="hljs-number">9</span> - start % <span class="hljs-number">8</span> - length;
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(((<span class="hljs-number">1</span> &lt;&lt; length) - <span class="hljs-number">1</span>) &lt;&lt; leftBit);
        data[downByte] &amp;= ~mask;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}



</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入解析 React 回到顶部（BackToTop）组件的实现与设计]]></title>    <link>https://juejin.cn/post/7605811866908459017</link>    <guid>https://juejin.cn/post/7605811866908459017</guid>    <pubDate>2026-02-13T02:37:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908459017" data-draft-id="7605782093482835994" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入解析 React 回到顶部（BackToTop）组件的实现与设计"/> <meta itemprop="keywords" content="前端,React.js,TypeScript"/> <meta itemprop="datePublished" content="2026-02-13T02:37:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冻梨政哥"/> <meta itemprop="url" content="https://juejin.cn/user/2373184444182659"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入解析 React 回到顶部（BackToTop）组件的实现与设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2373184444182659/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冻梨政哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:37:04.000Z" title="Fri Feb 13 2026 02:37:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入解析 React 回到顶部（BackToTop）组件的实现与设计</h2>
<p>在现代网页开发中，长页面的场景十分常见，为了提升用户体验，“回到顶部” 功能几乎成为标配。本文将基于一段 React 实现的 BackToTop 组件代码，从结构、核心逻辑、性能优化等维度，全面解析该组件的设计与实现细节。</p>
<h3 data-id="heading-1">一、组件整体结构概览</h3>
<p>首先来看 BackToTop 组件的完整代码结构，该组件基于 React 函数式组件实现，核心依赖 React 的 Hooks、UI 组件库、图标库以及自定义的节流工具函数，整体结构清晰且模块化。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/ui/button'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ArrowUp</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"lucide-react"</span>;
<span class="hljs-keyword">import</span> { throttle } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/utils"</span>;

<span class="hljs-comment">// 定义组件Props类型</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">BackToTopProps</span> {
    <span class="hljs-comment">// 滚动超过多少像素后显示按钮</span>
    threshold?: <span class="hljs-built_in">number</span>
}

<span class="hljs-comment">// 函数式组件，设置threshold默认值为400</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BackToTop</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">BackToTopProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">{
    threshold = <span class="hljs-number">400</span>
}</span>) =&gt;</span> {
    <span class="hljs-comment">// 状态管理：控制按钮是否可见</span>
    <span class="hljs-keyword">const</span> [isVisible, setIsVisible] = useState&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>);
    
    <span class="hljs-comment">// 回到顶部核心逻辑</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollTop</span> = (<span class="hljs-params"/>) =&gt; {
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>({
            <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">behavior</span>:<span class="hljs-string">'smooth'</span>
        })
    }
    
    <span class="hljs-comment">// 监听滚动事件，控制按钮显示/隐藏</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleVisibility</span> = (<span class="hljs-params"/>) =&gt; {
            <span class="hljs-title function_">setIsVisible</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span> &gt; threshold);
        }
        <span class="hljs-comment">// 节流处理滚动监听函数</span>
        <span class="hljs-keyword">const</span> thtottled_func = <span class="hljs-title function_">throttle</span>(toggleVisibility,<span class="hljs-number">200</span>);
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
        <span class="hljs-comment">// 清理副作用：移除滚动监听</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
    },[threshold])
    
    <span class="hljs-comment">// 条件渲染：未达到阈值时不渲染组件</span>
    <span class="hljs-keyword">if</span>(!isVisible) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-comment">// 组件UI渲染</span>
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"outline"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{scrollTop}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-6 right-6 rounded-full shadow-lg hover:shadow-xl z-50"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ArrowUp</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"h-4 w-4"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>
    )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">BackToTop</span>
</code></pre>
<p>组件整体可分为 5 个核心部分：</p>
<ol>
<li>依赖导入与类型定义；</li>
<li>状态管理（控制按钮可见性）；</li>
<li>回到顶部核心逻辑；</li>
<li>滚动事件监听与性能优化；</li>
<li>条件渲染与 UI 展示。</li>
</ol>
<h3 data-id="heading-2">二、核心功能逐行解析</h3>
<h4 data-id="heading-3">1. 类型定义与 Props 设计</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">BackToTopProps</span> {
    threshold?: <span class="hljs-built_in">number</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">BackToTop</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">BackToTopProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">{
    threshold = <span class="hljs-number">400</span>
}</span>) =&gt;</span> { ... }
</code></pre>
<ul>
<li>定义<code>BackToTopProps</code>接口，仅暴露<code>threshold</code>可选属性，用于配置 “滚动超过多少像素后显示按钮”，符合 “最小可用 API” 设计原则；</li>
<li>通过解构赋值为<code>threshold</code>设置默认值 400，确保组件在未传入参数时仍能正常工作。</li>
</ul>
<h4 data-id="heading-4">2. 状态管理：控制按钮可见性</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> [isVisible, setIsVisible] = <span class="hljs-built_in">useState</span>&lt;<span class="hljs-type">boolean</span>&gt;(<span class="hljs-literal">false</span>);
</code></pre>
<p>使用<code>useState</code> Hook 创建布尔类型状态<code>isVisible</code>，初始值为<code>false</code>（页面加载时按钮默认隐藏），该状态用于控制组件的条件渲染。</p>
<h4 data-id="heading-5">3. 回到顶部逻辑：平滑滚动实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollTop</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>({
        <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">behavior</span>:<span class="hljs-string">'smooth'</span>
    })
}
</code></pre>
<ul>
<li>调用<code>window.scrollTo</code>方法实现滚动到页面顶部；</li>
<li>通过配置<code>behavior: 'smooth'</code>实现平滑滚动，替代传统的瞬间跳转，提升用户体验；</li>
<li>该函数作为按钮的点击事件回调，触发回到顶部操作。</li>
</ul>
<h4 data-id="heading-6">4. 滚动监听与性能优化（核心）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleVisibility</span> = (<span class="hljs-params"/>) =&gt; {
        <span class="hljs-title function_">setIsVisible</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span> &gt; threshold);
    }
    <span class="hljs-keyword">const</span> thtottled_func = <span class="hljs-title function_">throttle</span>(toggleVisibility,<span class="hljs-number">200</span>);
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
},[threshold])
</code></pre>
<p>这是组件的核心逻辑，需重点解析：</p>
<h5 data-id="heading-7">（1）滚动监听函数<code>toggleVisibility</code></h5>
<p><code>toggleVisibility</code>的作用是判断页面滚动距离（<code>window.scrollY</code>）是否超过阈值（<code>threshold</code>），并通过<code>setIsVisible</code>更新按钮可见状态。</p>
<h5 data-id="heading-8">（2）节流处理的必要性</h5>
<p><code>scroll</code>事件是高频触发事件（页面滚动时会连续触发），若直接将<code>toggleVisibility</code>绑定到<code>scroll</code>事件，会导致该函数被频繁调用，引发不必要的状态更新和重渲染，影响页面性能。</p>
<p>因此，组件通过<code>throttle</code>工具函数对<code>toggleVisibility</code>进行节流处理，设置 200ms 的节流间隔 —— 即滚动事件触发时，<code>toggleVisibility</code>最多每 200ms 执行一次，有效减少函数执行次数，优化性能。</p>
<h5 data-id="heading-9">（3）副作用的挂载与清理</h5>
<ul>
<li><code>useEffect</code>在组件挂载时执行，为<code>window</code>添加<code>scroll</code>事件监听，绑定节流后的函数；</li>
<li><code>useEffect</code>的返回值是一个清理函数，在组件卸载时执行，移除<code>scroll</code>事件监听 —— 避免内存泄漏，是 React 函数式组件处理事件监听的标准写法；</li>
<li><code>useEffect</code>的依赖数组包含<code>threshold</code>，确保当阈值变化时，重新绑定监听函数。</li>
</ul>
<h4 data-id="heading-10">5. 条件渲染与 UI 展示</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span>(!isVisible) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

<span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"outline"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{scrollTop}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-6 right-6 rounded-full shadow-lg hover:shadow-xl z-50"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ArrowUp</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"h-4 w-4"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>
)
</code></pre>
<ul>
<li>
<p>条件渲染：当<code>isVisible</code>为<code>false</code>时，组件返回<code>null</code>，不渲染任何内容；仅当滚动距离超过阈值时，才渲染回到顶部按钮；</p>
</li>
<li>
<p>UI 设计细节：</p>
<ul>
<li>使用 UI 组件库的<code>Button</code>组件，设置<code>variant="outline"</code>（轮廓样式）、<code>size="icon"</code>（图标尺寸）；</li>
<li>通过<code>className</code>设置固定定位（<code>fixed</code>）、位置（<code>bottom-6 right-6</code>，右下角）、圆角（<code>rounded-full</code>）、阴影（<code>shadow-lg/xl</code>）、层级（<code>z-50</code>），确保按钮悬浮在页面最上层且样式美观；</li>
<li>嵌入<code>lucide-react</code>的<code>ArrowUp</code>图标作为按钮内容，直观传达 “回到顶部” 的功能；</li>
<li>按钮绑定<code>onClick</code>事件，触发<code>scrollTop</code>函数。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-11">三、节流工具函数（throttle）解析</h3>
<p>组件依赖的<code>throttle</code>函数位于<code>index.ts</code>中，其实现如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ThrottleFunction</span> = <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fun: ThrottleFunction, delay: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ThrottleFunction</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">last</span>: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">deferTimer</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) {
    <span class="hljs-keyword">const</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();

    <span class="hljs-keyword">if</span> (last &amp;&amp; now &lt; last + delay) {
      <span class="hljs-built_in">clearTimeout</span>(deferTimer);
      deferTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
        last = now;
        <span class="hljs-title function_">fun</span>(args);
      }, delay);
    } <span class="hljs-keyword">else</span> {
      last = now;
      <span class="hljs-title function_">fun</span>(args);
    }
  };
}
</code></pre>
<h4 data-id="heading-12">节流函数的核心原理</h4>
<p>节流（Throttle）的核心思想是：<strong>在指定时间间隔内，只允许函数执行一次</strong>，即使触发多次，也仅生效一次。该实现的关键逻辑：</p>
<ol>
<li>
<p>定义<code>last</code>（上一次函数执行的时间戳）和<code>deferTimer</code>（延迟定时器）两个闭包变量，用于记录执行状态；</p>
</li>
<li>
<p>每次触发函数时，获取当前时间戳<code>now</code>；</p>
</li>
<li>
<p>若距离上一次执行时间不足<code>delay</code>：</p>
<ul>
<li>清除原有定时器，避免重复执行；</li>
<li>重新设置定时器，延迟<code>delay</code>后执行函数，并更新<code>last</code>；</li>
</ul>
</li>
<li>
<p>若距离上一次执行时间超过<code>delay</code>：直接执行函数，并更新<code>last</code>。</p>
</li>
</ol>
<h4 data-id="heading-13">注意点</h4>
<p>该实现中<code>fun(args)</code>的传参方式需注意 —— 原函数的参数通过数组形式传递，若原函数依赖参数解构，需确保传参逻辑匹配（本文中<code>toggleVisibility</code>无参数，因此无影响）。</p>
<h3 data-id="heading-14">四、组件的使用与扩展</h3>
<h4 data-id="heading-15">1. 基础使用</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BackToTop</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/BackToTop'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* 其他页面内容 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">BackToTop</span> <span class="hljs-attr">threshold</span>=<span class="hljs-string">{500}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>仅需引入组件，可通过<code>threshold</code>自定义显示阈值，开箱即用。</p>
<h4 data-id="heading-16">2. 扩展方向</h4>
<ul>
<li><strong>自定义样式</strong>：通过<code>className</code>覆盖默认样式，或新增<code>className</code> Props 支持自定义样式；</li>
<li><strong>自定义图标</strong>：将图标作为 Props 传入，支持替换为自定义图标；</li>
<li><strong>滚动目标</strong>：扩展 Props 支持滚动到指定元素（而非仅顶部）；</li>
<li><strong>动画效果</strong>：添加按钮显示 / 隐藏的过渡动画（如 React Transition Group）；</li>
<li><strong>移动端适配</strong>：针对移动端调整按钮尺寸和位置；</li>
<li><strong>无障碍访问（a11y）</strong> ：添加<code>aria-label</code>等属性，提升无障碍体验。</li>
</ul>
<h3 data-id="heading-17">五、总结</h3>
<p>本文解析的 BackToTop 组件是一个典型的 “小而美” 的 React 组件，其设计具备以下优点：</p>
<ol>
<li><strong>类型安全</strong>：通过 TypeScript 定义 Props 接口，确保类型校验；</li>
<li><strong>性能优化</strong>：使用节流处理高频滚动事件，避免性能损耗；</li>
<li><strong>用户体验</strong>：平滑滚动、条件渲染、美观的 UI 设计；</li>
<li><strong>可维护性</strong>：模块化结构、清晰的逻辑拆分、完善的副作用清理；</li>
<li><strong>可扩展性</strong>：通过 Props 暴露核心配置，便于扩展。</li>
</ol>
<p>该组件的实现思路不仅适用于 “回到顶部” 功能，也可迁移到其他需要监听滚动事件的场景（如导航栏吸顶、懒加载等），是 React 函数式组件开发的典型实践案例。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[gsap 配置解读 --1]]></title>    <link>https://juejin.cn/post/7605985547568758790</link>    <guid>https://juejin.cn/post/7605985547568758790</guid>    <pubDate>2026-02-13T02:56:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605985547568758790" data-draft-id="7605792874173268031" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="gsap  配置解读 --1"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-13T02:56:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大时光"/> <meta itemprop="url" content="https://juejin.cn/user/2529296311138013"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            gsap  配置解读 --1
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2529296311138013/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大时光
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:56:59.000Z" title="Fri Feb 13 2026 02:56:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">toggleActions: "play none none reverse"  是什么意思</h2>
<pre><code class="hljs language-js" lang="js">gsap.<span class="hljs-title function_">to</span>(panel, {
<span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
<span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
<span class="hljs-attr">duration</span>: <span class="hljs-number">0.8</span>,
<span class="hljs-attr">ease</span>: <span class="hljs-string">"power2.out"</span>, 
<span class="hljs-attr">scrollTrigger</span>: {
<span class="hljs-attr">trigger</span>: panel, 
<span class="hljs-attr">start</span>: <span class="hljs-string">"top 80%"</span>, <span class="hljs-comment">// 当 panel 的顶部到达 viewport 的 80% 位置时，进入触发区</span>
<span class="hljs-attr">end</span>: <span class="hljs-string">"top 40%"</span>, <span class="hljs-comment">// 当 panel 的顶部到达 viewport 的 40% 位置时，离开触发区 </span>
<span class="hljs-attr">toggleActions</span>: <span class="hljs-string">"play none none reverse"</span>
} 
});
</code></pre>






























<table><thead><tr><th>位置</th><th>触发时机</th><th>说明</th></tr></thead><tbody><tr><td>1. <code>onEnter</code></td><td>元素从上往下滚动进入触发区间（比如进入 <code>start</code> 到 <code>end</code> 区域）</td><td>此处是 <code>"play"</code> → 播放动画</td></tr><tr><td>2. <code>onLeave</code></td><td>元素继续向下滚动，离开触发区间（滚出 <code>end</code> 之后）</td><td>此处是 <code>"none"</code> → 什么都不做</td></tr><tr><td>3. <code>onEnterBack</code></td><td>元素从下往上滚动，重新进入触发区间（反向滚动进入）</td><td>此处是 <code>"none"</code> → 什么都不做</td></tr><tr><td>4. <code>onLeaveBack</code></td><td>元素继续向上滚动，离开触发区间（反向滚出 <code>start</code> 之前）</td><td>此处是 <code>"reverse"</code> → 反向播放动画（即倒放）</td></tr></tbody></table>
<h4 data-id="heading-1"><code>toggleActions</code></h4>





































<table><thead><tr><th>动作值</th><th>效果</th></tr></thead><tbody><tr><td><code>"play"</code></td><td>播放动画（从当前进度开始）</td></tr><tr><td><code>"pause"</code></td><td>暂停动画</td></tr><tr><td><code>"resume"</code></td><td>恢复播放（如果已暂停）</td></tr><tr><td><code>"reverse"</code></td><td>反向播放（倒放）</td></tr><tr><td><code>"restart"</code></td><td>从头开始播放</td></tr><tr><td><code>"reset"</code></td><td>重置到初始状态</td></tr><tr><td><code>"none"</code></td><td>无操作（保持当前状态）</td></tr></tbody></table>
<h4 data-id="heading-2"> 典型使用场景对比：</h4>

























<table><thead><tr><th>需求</th><th>推荐 <code>toggleActions</code></th></tr></thead><tbody><tr><td>进入播放，离开重置</td><td><code>"play none none reset"</code></td></tr><tr><td>进入播放，反向离开时倒放</td><td><code>"play none none reverse"</code> ← 你的情况</td></tr><tr><td>只播放一次，之后不再动</td><td><code>"play pause pause pause"</code></td></tr><tr><td>来回都播放</td><td><code>"play play play play"</code>（不推荐，会闪烁）</td></tr></tbody></table>
<h2 data-id="heading-3">paused: true是什么意思</h2>
<pre><code class="hljs language-const" lang="const">{
x: 280, 
scale: 0.5,
opacity: 0,
duration: 1,
ease: "power2.out",
paused: true 
});

</code></pre>
<p>在 GSAP（GreenSock Animation Platform）中，<code>paused: true</code> 是一个<strong>动画配置选项</strong>，它的作用是：</p>
<blockquote>
<p><strong>创建动画时立即暂停（不自动播放），等待后续手动控制播放。</strong></p>
</blockquote>
<ul>
<li><code>gsap.from(...)</code> 表示：<strong>从指定的起始状态（x=280, scale=0.5, opacity=0）动画到元素当前的 CSS 状态</strong>。</li>
<li>但由于设置了 <code>paused: true</code>，这个动画<strong>不会立刻执行</strong>，而是被“冻结”在初始状态（即元素保持原样，不会动）。</li>
<li>你需要<strong>手动调用</strong> <code>tween.play()</code> 才会开始播放动画。</li>
</ul>
<h4 data-id="heading-4">✅ 为什么需要 <code>paused: true</code>？</h4>
<p>通常用于以下场景：</p>
<h5 data-id="heading-5">1. <strong>延迟触发动画</strong></h5>
<p>比如点击按钮、滚动到某位置、或满足某个条件后再播放：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#btn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> { 
tween.<span class="hljs-title function_">play</span>(); <span class="hljs-comment">// 点击时才播放</span>
});
</code></pre>
<h5 data-id="heading-6">2. <strong>配合 ScrollTrigger 或其他交互逻辑</strong></h5>
<p>你可能先定义好动画，等 ScrollTrigger 初始化完成后再关联：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">ScrollTrigger</span>.<span class="hljs-title function_">create</span>({
<span class="hljs-attr">trigger</span>: <span class="hljs-string">".section"</span>,
<span class="hljs-attr">start</span>: <span class="hljs-string">"top center"</span>,
<span class="hljs-attr">onEnter</span>: <span class="hljs-function">() =&gt;</span> tween.<span class="hljs-title function_">play</span>()
});
</code></pre>
<h5 data-id="heading-7">3. <strong>复用动画</strong></h5>
<p>同一个 <code>tween</code> 可以多次 <code>play()</code>、<code>reverse()</code>、<code>restart()</code>，而不会重复创建。</p>

































<table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>tween.play()</code></td><td>播放动画</td></tr><tr><td><code>tween.pause()</code></td><td>暂停动画</td></tr><tr><td><code>tween.reverse()</code></td><td>反向播放（从当前进度倒放回起点）</td></tr><tr><td><code>tween.restart()</code></td><td>从头开始播放</td></tr><tr><td><code>tween.seek(0.5)</code></td><td>跳转到动画 50% 进度</td></tr><tr><td><code>tween.progress(1)</code></td><td>瞬间跳到结束状态</td></tr></tbody></table>

















<table><thead><tr><th>配置</th><th>含义</th></tr></thead><tbody><tr><td><code>paused: true</code></td><td>创建动画但不自动播放，需手动调用 <code>.play()</code> 等方法控制</td></tr><tr><td>默认（不写）</td><td>动画创建后立即自动播放</td></tr></tbody></table>
<h2 data-id="heading-8">gsap.set()  set 是什么意思</h2>
<p>在 GSAP（GreenSock Animation Platform）中，<code>gsap.set()</code> 是一个<strong>立即设置元素属性</strong>的方法，<strong>不会产生动画过渡</strong>，而是<strong>瞬间应用指定的样式或属性值</strong>。</p>






























<table><thead><tr><th>方法</th><th>是否动画</th><th>用途</th></tr></thead><tbody><tr><td><code>gsap.set(target, vars)</code></td><td>❌ 否</td><td>立即设置属性（相当于“初始化状态”）</td></tr><tr><td><code>gsap.to(target, vars)</code></td><td>✅ 是</td><td>从当前状态 动画到 指定状态</td></tr><tr><td><code>gsap.from(target, vars)</code></td><td>✅ 是</td><td>从指定状态 动画到 当前状态</td></tr><tr><td><code>gsap.fromTo(target, fromVars, toVars)</code></td><td>✅ 是</td><td>自定义起始和结束状态</td></tr></tbody></table>
<h2 data-id="heading-9">clearProps: "all"是什么意思</h2>
<p>gsap.set([boxA, boxB], { clearProps: "all" });
这行代码的作用是：</p>
<blockquote>
<p><strong>立即清除 <code>boxA</code> 和 <code>boxB</code> 元素上由 GSAP 设置的所有内联样式属性（比如 <code>transform</code>, <code>opacity</code>, <code>backgroundColor</code> 等），让它们恢复到 GSAP 干预之前的状态（即仅受 CSS 类或原始 HTML 样式控制）。</strong></p>
</blockquote>
<hr/>
<h4 data-id="heading-10">✅ <code>clearProps</code> 的作用详解</h4>
<ul>
<li>GSAP 在执行动画（如 <code>gsap.to()</code>、<code>gsap.from()</code>）或 <code>gsap.set()</code> 时，会<strong>直接写入元素的 <code>style</code> 属性</strong>（例如：<code>&lt;div style="transform: translateX(100px); opacity: 0.5;"&gt;</code>）。</li>
<li>这些内联样式优先级很高，会覆盖你写的 CSS 类。</li>
<li>使用 <code>clearProps</code> 可以<strong>清理这些“残留”的内联样式</strong>，避免干扰后续布局或样式。</li>
</ul>

























<table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td><code>"all"</code></td><td>清除 所有 GSAP 设置过的内联样式（最常用）✅</td></tr><tr><td><code>"transform"</code></td><td>仅清除 <code>transform</code> 相关属性（如 <code>x</code>, <code>y</code>, <code>scale</code>, <code>rotation</code> 等）</td></tr><tr><td><code>"opacity,backgroundColor"</code></td><td>清除指定的多个属性（用逗号分隔）</td></tr><tr><td><code>"x,y"</code></td><td>仅清除 <code>x</code> 和 <code>y</code>（即 <code>transform: translateX/Y</code>）</td></tr></tbody></table>
<p>💡 注意：<code>clearProps</code> 只清除 <strong>GSAP 显式设置过</strong> 的属性，不会影响其他 JavaScript 或 HTML 中原本就有的 <code>style</code>。</p>
<h4 data-id="heading-11">🎯 使用场景举例</h4>
<h5 data-id="heading-12">场景 1：重置动画状态</h5>
<p>js</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 先执行一个动画</span>
gsap.<span class="hljs-title function_ invoke__">to</span>(boxA, { <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">"red"</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1</span> });

<span class="hljs-comment">// 后来想让它完全回到原始 CSS 样式</span>
gsap.<span class="hljs-title function_ invoke__">set</span>(boxA, { <span class="hljs-attr">clearProps</span>: <span class="hljs-string">"all"</span> });
<span class="hljs-comment">// 效果相当于：boxA.style.cssText = ""; （但更安全，只清 GSAP 设置的）</span>
</code></pre>
<h5 data-id="heading-13">场景 2：避免 transform 冲突</h5>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.my-box</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">10deg</span>); <span class="hljs-comment">/* 原始 CSS transform */</span>
}
</code></pre>
<p>js</p>
<pre><code class="hljs language-php" lang="php">gsap.<span class="hljs-title function_ invoke__">to</span>(<span class="hljs-string">".my-box"</span>, { <span class="hljs-attr">x</span>: <span class="hljs-number">50</span> }); <span class="hljs-comment">// GSAP 会合并 transform，变成 rotate + translate</span>
gsap.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-string">".my-box"</span>, { <span class="hljs-attr">clearProps</span>: <span class="hljs-string">"transform"</span> }); <span class="hljs-comment">// 清除后，只剩 rotate(10deg)</span>
</code></pre>
<h5 data-id="heading-14">场景 3：组件销毁前清理</h5>
<p>在 React/Vue 组件卸载时，清除 GSAP 添加的样式，防止内存泄漏或样式残留。</p>
<hr/>
<h4 data-id="heading-15">⚠️ 注意事项</h4>
<ol>
<li><strong><code>clearProps: "all"</code> 不会删除非 GSAP 设置的内联样式</strong><br/>
比如你手动写了 <code>&lt;div style="color: blue"&gt;</code>，GSAP 不会动它。</li>
<li><strong><code>transform</code> 是一个整体</strong><br/>
即使你只设置了 <code>x: 100</code>，<code>clearProps: "transform"</code> 也会清除整个 <code>transform</code> 字符串。</li>
<li><strong><code>autoAlpha</code> 会同时影响 <code>opacity</code> 和 <code>visibility</code></strong><br/>
如果你用了 <code>autoAlpha</code>，需要同时清除这两个属性。</li>
</ol>













<table><thead><tr><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><code>gsap.set(el, { clearProps: "all" })</code></td><td>彻底清除 GSAP 对该元素设置的所有内联样式，恢复“干净”状态</td></tr></tbody></table>
<h2 data-id="heading-16">keyframes是什么意思</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> tween = gsap.<span class="hljs-title function_">to</span>(shape, {
        <span class="hljs-attr">keyframes</span>: [
          { <span class="hljs-attr">x</span>: -<span class="hljs-number">160</span>, <span class="hljs-attr">rotation</span>: -<span class="hljs-number">15</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> },
          { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">1.2</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> },
          { <span class="hljs-attr">x</span>: <span class="hljs-number">160</span>, <span class="hljs-attr">rotation</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> },
          { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">rotation</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> }
        ],
        <span class="hljs-attr">ease</span>: <span class="hljs-string">"power1.inOut"</span>,
        <span class="hljs-attr">paused</span>: <span class="hljs-literal">true</span>
      });
</code></pre>
<p>在 GSAP（GreenSock Animation Platform）中，<code>keyframes</code> 是一种<strong>将多个动画步骤串联起来</strong>的方式，类似于 CSS 的 <code>@keyframes</code>，但功能更强大、更灵活。</p>
<p>这段代码的意思是：</p>
<blockquote>
<p><strong>对 <code>shape</code> 元素执行一个由 4 个关键帧组成的复合动画，每个关键帧持续 0.4 秒，总共 1.6 秒。动画被暂停（<code>paused: true</code>），需手动调用 <code>.play()</code> 才会运行。</strong></p>
</blockquote>
<hr/>
<h4 data-id="heading-17">✅ <code>keyframes</code> 的工作原理</h4>
<ul>
<li>每个对象代表一个<strong>动画阶段（关键帧）</strong> 。</li>
<li>GSAP 会<strong>按顺序依次播放</strong>这些关键帧。</li>
<li>每一帧的属性是从<strong>上一帧的结束状态</strong>过渡到当前帧的目标值。</li>
<li>每帧可以有自己的 <code>duration</code>、<code>ease</code>（如果未指定，则继承外层的 <code>ease</code>）。</li>
</ul>
<h5 data-id="heading-18">动画流程分解：</h5>






























<table><thead><tr><th>阶段</th><th>起始状态 → 目标状态</th><th>效果</th></tr></thead><tbody><tr><td>第1帧</td><td>当前状态 → <code>{x: -160, rotation: -15}</code></td><td>向左飞 + 左转</td></tr><tr><td>第2帧</td><td>上一帧结束 → <code>{x: 0, scale: 1.2}</code></td><td>回到中心 + 放大</td></tr><tr><td>第3帧</td><td>上一帧结束 → <code>{x: 160, rotation: 20}</code></td><td>向右飞 + 右转</td></tr><tr><td>第4帧</td><td>上一帧结束 → <code>{x: 0, scale: 1, rotation: 0}</code></td><td>回到原位 + 还原大小和角度</td></tr></tbody></table>
<h4 data-id="heading-19">🔧 <code>keyframes</code> 的高级用法</h4>
<h5 data-id="heading-20">1. <strong>每帧可单独设置缓动（ease）</strong></h5>
<p>js</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">keyframes:</span> [
  { <span class="hljs-attr">x:</span> <span class="hljs-number">100</span>, <span class="hljs-attr">duration:</span> <span class="hljs-number">0.3</span>, <span class="hljs-attr">ease:</span> <span class="hljs-string">"back.out"</span> },
  { <span class="hljs-attr">x:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">duration:</span> <span class="hljs-number">0.3</span>, <span class="hljs-attr">ease:</span> <span class="hljs-string">"elastic.out"</span> }
]
</code></pre>
<h5 data-id="heading-21">2. <strong>支持回调函数</strong></h5>
<p>js</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">keyframes:</span> [
  { <span class="hljs-attr">x:</span> <span class="hljs-number">100</span>, <span class="hljs-attr">duration:</span> <span class="hljs-number">0.5</span> },
  { 
    <span class="hljs-attr">x:</span> <span class="hljs-number">0</span>, 
    <span class="hljs-attr">duration:</span> <span class="hljs-number">0.5</span>,
    <span class="hljs-attr">onComplete:</span> <span class="hljs-string">()</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">console.log("第二帧完成")</span> 
  }
]
</code></pre>
<h5 data-id="heading-22">3. <strong>与 ScrollTrigger、Timeline 结合</strong></h5>
<p>js</p>
<pre><code class="hljs language-php" lang="php">gsap.<span class="hljs-title function_ invoke__">timeline</span>({
  <span class="hljs-attr">scrollTrigger</span>: { <span class="hljs-attr">trigger</span>: <span class="hljs-string">".section"</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">"top center"</span> }
}).<span class="hljs-title function_ invoke__">to</span>(shape, {
  <span class="hljs-attr">keyframes</span>: [ <span class="hljs-comment">/* ... */</span> ]
});
</code></pre>
<hr/>
<h4 data-id="heading-23">⚠️ 注意事项</h4>
<ul>
<li><code>keyframes</code> 是 <strong>GSAP 3.0+</strong>  引入的功能，在旧版本中不可用。</li>
<li>外层的 <code>ease</code>（如你的 <code>"power1.inOut"</code>）会作为<strong>默认缓动</strong>应用到每一帧（除非某帧自己指定了 <code>ease</code>）。</li>
<li>如果某帧没有指定 <code>duration</code>，它会继承前一帧的 <code>duration</code> 或使用默认值（通常为 0.3 秒）。</li>
</ul>
<hr/>
<h4 data-id="heading-24">✅ 为什么用 <code>keyframes</code> 而不用多个 <code>gsap.to()</code>？</h4>
<p>表格</p>

















<table><thead><tr><th>方式</th><th>优点</th></tr></thead><tbody><tr><td><code>keyframes</code></td><td>代码更紧凑，自动串联，易于管理单个动画序列</td></tr><tr><td>多个 <code>gsap.to()</code></td><td>更灵活（可插入延迟、回调等），适合复杂编排（推荐用 <code>gsap.timeline()</code>）</td></tr></tbody></table>
<blockquote>
<p>对于简单的线性多步动画，<code>keyframes</code> 非常简洁；对于复杂时间轴，建议用 <code>gsap.timeline()</code>。</p>
</blockquote>
<hr/>
<blockquote>
<p><strong><code>keyframes</code> = 把多个动画步骤写在一个数组里，GSAP 自动按顺序播放它们。</strong></p>
</blockquote>
<p>你的代码创建了一个“左右晃动 + 缩放”的弹性动画，常用于：</p>
<ul>
<li>按钮点击反馈</li>
<li>错误提示抖动</li>
<li>卡片翻转/弹跳效果</li>
</ul>
<p>配合 <code>paused: true</code>，你可以在需要时（如点击、滚动）通过 <code>tween.play()</code> 触发动画，非常高效！</p>
<h2 data-id="heading-25">stagger 是什么意思</h2>
<p>在 GSAP（GreenSock Animation Platform）中，<strong><code>stagger</code></strong> 是一个非常强大的功能，用于<strong>对多个目标元素（如数组、NodeList）依次错开播放动画</strong>，从而创建出“波浪式”、“逐个入场”等流畅的序列动画效果。</p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-keyword">const</span> tween = gsap.<span class="hljs-title function_">from</span>(cells, {
        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">scale</span>: <span class="hljs-number">0.4</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>,
        <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>,
        <span class="hljs-attr">ease</span>: <span class="hljs-string">"power2.out"</span>,
       <span class="hljs-attr">stagger</span>: { 
           <span class="hljs-attr">each</span>: <span class="hljs-number">0.04</span>, <span class="hljs-comment">// 每个元素之间的延迟时间（秒）</span>
           <span class="hljs-attr">from</span>: <span class="hljs-string">"center"</span> <span class="hljs-comment">// 动画从中间的元素开始，向两边扩散</span>
       },
        <span class="hljs-attr">paused</span>: <span class="hljs-literal">true</span>
      });
</code></pre>
<p>这段代码的作用是：</p>
<blockquote>
<p><strong>对 <code>cells</code>（一组 DOM 元素）执行“从透明、缩小、下移”状态淡入放大的动画，但不是同时播放，而是：</strong></p>
<ul>
<li><strong>从中间的元素开始</strong></li>
<li><strong>相邻元素之间间隔 0.04 秒依次播放</strong></li>
<li>整体形成一种“由中心向外扩散”的入场效果 ✨</li>
</ul>
</blockquote>
<hr/>
<h4 data-id="heading-26">✅ <code>stagger</code> 的核心概念</h4>
<p>当你对<strong>多个元素</strong>（如 <code>document.querySelectorAll('.cell')</code>）使用 GSAP 动画时：</p>
<ul>
<li><strong>不加 <code>stagger</code></strong> → 所有元素<strong>同时</strong>动画。</li>
<li><strong>加上 <code>stagger</code></strong> → 元素<strong>依次错开</strong>动画，产生节奏感。</li>
</ul>
<hr/>
<h4 data-id="heading-27">🔧 <code>stagger</code> 的常见写法</h4>
<h5 data-id="heading-28">1. <strong>最简形式：只指定间隔时间</strong></h5>
<p>js</p>
<pre><code class="hljs language-css" lang="css">stagger: <span class="hljs-number">0.1</span>  // 等价于 { each: <span class="hljs-number">0.1</span> }
</code></pre>
<p>→ 从第一个元素开始，每个间隔 0.1 秒。</p>
<h5 data-id="heading-29">2. <strong>对象形式（你用的方式）：更精细控制</strong></h5>
<p>js</p>
<pre><code class="hljs language-perl" lang="perl">stagger: {
  <span class="hljs-keyword">each</span>: <span class="hljs-number">0</span>.<span class="hljs-number">04</span>,     <span class="hljs-regexp">//</span> 每个元素间隔 <span class="hljs-number">0</span>.<span class="hljs-number">04</span> 秒
  from: <span class="hljs-string">"center"</span>, <span class="hljs-regexp">//</span> 起始位置：可选 <span class="hljs-string">"start"</span>（默认）、<span class="hljs-string">"center"</span>、<span class="hljs-string">"end"</span> 或具体索引（如 <span class="hljs-number">3</span>）
  grid: <span class="hljs-string">"auto"</span>,   <span class="hljs-regexp">//</span> 如果是网格布局，可设为 [rows, cols] 来按行/列交错
  axis: <span class="hljs-string">"x"</span>       // 在网格中限制交错方向（<span class="hljs-string">"x"</span>、<span class="hljs-string">"y"</span> 或 <span class="hljs-string">"xy"</span>）
}
</code></pre>
<hr/>
<h4 data-id="heading-30">🎯 <code>from</code> 的取值说明</h4>

























<table><thead><tr><th>值</th><th>效果</th></tr></thead><tbody><tr><td><code>"start"</code>（默认）</td><td>从第一个元素开始，依次到最后一个</td></tr><tr><td><code>"center"</code></td><td>从中间元素开始，向左右（或上下）同时扩散</td></tr><tr><td><code>"end"</code></td><td>从最后一个元素开始，倒序播放</td></tr><tr><td><code>数字（如 2）</code></td><td>从索引为 2 的元素开始</td></tr></tbody></table>
<p>✅  <code>from: "center"</code> 非常适合<strong>居中对齐的列表、图标阵列、卡片网格</strong>等场景，视觉上更平衡。</p>
<hr/>
<h4 data-id="heading-31">💡 实际效果示例</h4>
<p>假设 <code>cells</code> 有 5 个元素：<code>[A, B, C, D, E]</code></p>
<ul>
<li><code>from: "center"</code> → 播放顺序：<strong>C → B &amp; D → A &amp; E</strong></li>
<li>每个间隔 <code>0.04s</code>，所以整个动画在约 <code>0.04 × 2 = 0.08s</code> 内完成扩散（因为两边并行）</li>
</ul>
<blockquote>
<p>这比线性播放（A→B→C→D→E）更生动！</p>
</blockquote>
<hr/>
<h4 data-id="heading-32">⚠️ 注意事项</h4>
<ul>
<li><code>stagger</code> <strong>只在目标是多个元素时生效</strong>。如果 <code>cells</code> 只有一个元素，<code>stagger</code> 会被忽略。</li>
<li><code>stagger</code> 的延迟是<strong>叠加在 <code>duration</code> 之上的</strong>，不影响单个动画的时长。</li>
<li>可与 <code>paused: true</code> 完美配合，实现“按需触发动画序列”。</li>
</ul>
<hr/>













<table><thead><tr><th>配置</th><th>含义</th></tr></thead><tbody><tr><td><code>stagger: { each: 0.04, from: "center" }</code></td><td><strong>从中间元素开始，以 0.04 秒的间隔向两侧依次播放动画</strong></td></tr></tbody></table>
<p>这是 GSAP 实现<strong>高级交互动效</strong>（如列表加载、菜单展开、数据可视化入场）的核心技巧之一。你的代码就是一个典型的“优雅批量入场”动画！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android VSync 笔记]]></title>    <link>https://juejin.cn/post/7605810996125007906</link>    <guid>https://juejin.cn/post/7605810996125007906</guid>    <pubDate>2026-02-13T02:36:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125007906" data-draft-id="7605542907118862388" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android VSync 笔记"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-13T02:36:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="心源xinyuan"/> <meta itemprop="url" content="https://juejin.cn/user/4283353029151694"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android VSync 笔记
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4283353029151694/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    心源xinyuan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:36:21.000Z" title="Fri Feb 13 2026 02:36:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>关于VSync的产生，你需要彻底更新一个认知：<strong>Android系统里你看到的那些整齐的VSYNC-APP和VSYNC-SF信号，99%的时间里并不是硬件直接产生的，而是SurfaceFlinger用数学公式“算”出来的。</strong></p>
<p>为了把这个“算出来”的过程讲透，我们从<strong>物理源头</strong>、<strong>软件衍生</strong>、<strong>按需开关</strong>三个层面逐步拆解。</p>
<hr/>
<h2 data-id="heading-0">一、物理源头：硬件VSync的“原始脉搏”</h2>
<p>VSync这个概念的诞生比Android早几十年，它源自CRT显示器电子枪的物理动作。</p>
<p><strong>1.1 它最初是显示器“喘口气”的信号</strong></p>
<ul>
<li>电子枪从左到右、从上到下扫描屏幕，扫完一帧后必须<strong>关闭电子束、从右下角瞬间移回左上角</strong>（垂直回扫）。</li>
<li>这段短暂的“空窗期”会触发一个脉冲——<strong>垂直同步信号（VSync）</strong>，告诉显卡：“上一帧已显示完毕，可以送下一帧了”。</li>
<li>现代LCD虽无电子枪，但为了兼容，<strong>显示控制器（Display Controller）会模拟这个时序</strong>，通过硬件定时器产生固定频率的脉冲。这个频率就是屏幕刷新率（60Hz/90Hz/120Hz等）。</li>
</ul>
<p><strong>1.2 Android里谁在制造这个原始脉冲？</strong>
<strong>Hardware Composer（HWC）</strong>。它是显示驱动的一部分，直接与硬件定时器交互。每当屏幕完成一次刷新，HWC就通过回调向SurfaceFlinger发送一个<strong>HW_VSYNC_0</strong>信号。</p>
<p><strong>关键认知</strong>：这个硬件信号极其“原始”——它只是一串准确但<strong>没有任何业务逻辑</strong>的时间戳。它不知道谁是App、谁是SurfaceFlinger，只会每分钟60次（或更高）忠实地发出脉冲。</p>
<hr/>
<h2 data-id="heading-1">二、软件衍生：DispSync的“神算局”</h2>
<p>如果让App和SurfaceFlinger每次都直接响应HW_VSYNC_0，会有两个严重问题：</p>
<ol>
<li><strong>功耗灾难</strong>：即使屏幕静止不动（如看电子书），App和SF也会每16.6ms被唤醒，疯狂空转。</li>
<li><strong>相位死锁</strong>：App绘制、SF合成、屏幕显示三者<strong>挤在同一个时间点开工</strong>，流水线严重阻塞（旧Android版本的痛点）。</li>
</ol>
<p>于是Android 4.1（Project Butter）引入了<strong>DispSync模块</strong>——一个<strong>基于数学预测的软件VSync生成器</strong>。这是整个机制最精妙的部分。</p>
<p><strong>2.1 DispSync的工作原理：锁相环的软件实现</strong></p>
<p>DispSync本质上是一个<strong>数字锁相环（Digital Phase-Locked Loop）</strong>。它不依赖硬件中断实时触发，而是通过采样硬件VSync的历史时间，<strong>拟合出一条精准的“虚拟时钟线”</strong>。</p>
<p><strong>第一步：采样与建模</strong></p>
<ul>
<li>SurfaceFlinger会持续接收HW_VSYNC_0信号，但<strong>并不立刻分发</strong>。</li>
<li>DispSync收集<strong>至少3个、最多32个</strong>硬件VSync时间戳，通过最小二乘法或均值滤波计算出<strong>平均周期（AvgPeriod）<strong>和</strong>平均相位（AvgPhase）</strong>。</li>
<li>数学公式（简化版）：
<ul>
<li>将每个时间戳映射到单位圆角度：<code>ΔPhase = 2π * (timestamp % AvgPeriod) / AvgPeriod</code></li>
<li>计算所有采样点的平均向量 <code>(AvgX, AvgY)</code></li>
<li><code>SW_VSYNC相位 = atan2(AvgY, AvgX)</code></li>
<li>最终：<code>SW_VSYNC时间 = AvgPeriod + AvgPhase</code></li>
</ul>
</li>
</ul>
<p><strong>一旦模型误差收敛（通常6个采样后），DispSync会立即</strong>关闭硬件VSync中断**，完全靠这套数学模型产生后续的软件VSync。这就是“用计算代替中断”的核心节能设计。</p>
<p><strong>2.2 一源双生：VSYNC-APP与VSYNC-SF</strong></p>
<p>硬件只提供一个原始脉冲，但系统需要两个不同用途的节拍器。DispSync在生成软件VSync时，会<strong>直接产出两条相位偏移的时钟流</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VSYNC-APP</span> = SW_VSYNC基准 + phase_app偏移量
<span class="hljs-attr">VSYNC-SF</span>  = SW_VSYNC基准 + phase_sf偏移量
</code></pre>
<ul>
<li><strong>phase_app</strong>：通常为0～2ms（应用先开始绘制）</li>
<li><strong>phase_sf</strong>：通常为4～6ms（SF稍后开始合成，刚好等App画完）</li>
</ul>
<p>这两条信号就是你在Systrace里看到的彩色VSync条。它们的<strong>周期完全一致（16.6ms）</strong>，但<strong>起始时间错开</strong>，形成流水线。</p>
<p><strong>对比总结</strong>（纠正常见误区）：</p>

































<table><thead><tr><th>信号名称</th><th>产生者</th><th>是否硬件直接发出</th><th>用途</th><th>触发方式</th></tr></thead><tbody><tr><td><strong>HW_VSYNC_0</strong></td><td>HWC/显示控制器</td><td>✅ 是</td><td>校准DispSync模型</td><td>硬件定时器，固定频率</td></tr><tr><td><strong>VSYNC-APP</strong></td><td>DispSync（软件）</td><td>❌ 否</td><td>触发Choreographer开始绘制</td><td>按需 + 模型预测</td></tr><tr><td><strong>VSYNC-SF</strong></td><td>DispSync（软件）</td><td>❌ 否</td><td>触发SurfaceFlinger合成</td><td>按需 + 模型预测</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">三、按需触发：没有绘制任务时，VSync去哪了？</h2>
<p>这是Android VSync机制最容易误解的地方：<strong>Systrace里VSync-APP/SF信号并非每16.6ms都有</strong>。它们的出现遵循**按需申请（requestNextVsync）**原则。</p>
<p><strong>3.1 为什么必须按需？</strong>
假设你打开一个静态文本页面：</p>
<ul>
<li>屏幕内容完全没有变化。</li>
<li>如果DispSync仍然每16.6ms向App发送VSYNC-APP，App的主线程会<strong>持续每帧执行doFrame()</strong>，空转测量布局绘制——CPU空耗、发热、掉电。</li>
<li><strong>完全没必要</strong>。</li>
</ul>
<p><strong>3.2 申请-触发机制</strong></p>
<ul>
<li><strong>App侧</strong>：只有当<code>Choreographer.postCallback()</code>被调用（如View.invalidate()、动画启动），才会通过Binder向SF的EventThread<strong>请求下一个VSYNC-APP</strong>。</li>
<li><strong>SF侧</strong>：只有当BufferQueue中有新Buffer入队，或者窗口状态变化，才会<strong>请求下一个VSYNC-SF</strong>。</li>
<li><strong>DispSync侧</strong>：只有当<strong>至少一个客户端在等待</strong>时，它才会在预测的时钟点上发射软件VSync；<strong>如果无人申请，DispSync保持静默</strong>，整个图形系统进入低功耗状态。</li>
</ul>
<p>这就是为什么Systrace里VSync信号<strong>时疏时密</strong>——动态场景（滑动、动画）密集出现；静态场景几乎消失。</p>
<p><strong>3.3 硬件VSync的重校准</strong>
当DispSync长期依靠软件预测，可能会因温漂、时钟偏差而产生相位误差。如何修正？</p>
<ul>
<li>SurfaceFlinger在<code>postComposition()</code>时会检查<strong>Present Fence</strong>（帧实际显示的时间戳）。</li>
<li>将这些Fence时间与SW_VSYNC预测时间对比，<strong>计算误差平方和</strong>。</li>
<li>若误差超过阈值（如1.5ms），DispSync会<strong>临时重新使能硬件VSync</strong>，采集3～6个新样本重新建模，然后再次关闭硬件VSync。</li>
</ul>
<p><strong>这是一套完整的闭环自适应系统：硬件提供基准，软件负责分发，误差触发校准。</strong></p>
<hr/>
<h2 data-id="heading-3">四、全景流程图（建议收藏）</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8084312655994ab488ebba90269caeea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b-D5rqQeGlueXVhbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554981&amp;x-signature=BcMZxv%2BFCG0cUiPpuvlHXgW%2BQMY%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[显示控制器硬件定时器] --&gt;|固定频率脉冲| B[HWC产生HW_VSYNC_0]
    B --&gt; C{SurfaceFlinger DispSync}
    
    C --&gt;|采样至少3个时间戳| D[计算平均周期与相位]
    D --&gt;|模型收敛| E[关闭硬件VSync中断]
    E --&gt; F[软件预测生成SW_VSYNC基准时钟]
    
    F --&gt;|+ phase_app偏移| G[VSYNC-APP]
    F --&gt;|+ phase_sf偏移| H[VSYNC-SF]
    
    G --&gt;|按需：App调用requestNextVsync| I[触发Choreographer绘制]
    H --&gt;|按需：SF有Buffer待合成| J[触发SurfaceFlinger合成]
    
    I --&gt; K[GPU渲染完成]
    K --&gt; L[Buffer入队]
    L --&gt;|触发SF申请下一帧VSYNC-SF| J
    
    J --&gt; M[合成送显]
    M --&gt;|检查Present Fence误差| N{误差超阈值？}
    N --&gt;|是| O[临时开启硬件VSync]
    O --&gt;|重新采样| C
    N --&gt;|否| P[保持软件预测模式]
</code></pre>
<h2 data-id="heading-4">五、回答你最初的问题：“VSync是如何产生的？”</h2>
<p><strong>分三个层次回答：</strong></p>
<ol>
<li><strong>物理层</strong>：显示控制器硬件定时器每16.6ms产生一个脉冲，HWC捕获后作为HW_VSYNC_0上报。</li>
<li><strong>软件层</strong>：SurfaceFlinger的DispSync模块将硬件信号作为“校准样本”，通过锁相环算法<strong>拟合出一条持续运行的虚拟时钟线</strong>，并在这根时钟线上<strong>同时开出两条相位错开的信号通道</strong>（VSYNC-APP/VSYNC-SF）。</li>
<li><strong>策略层</strong>：这两条软件信号<strong>并非周期性自动发射</strong>，而是严格遵循<strong>按需申请</strong>机制——只有App或SF明确“我需要下一帧”，DispSync才在预测时间点发射信号。</li>
</ol>
<p><strong>所以，VSync的最终形态——你在Systrace里看到的那些彩色节拍——是“硬件定时校准 + 软件预测生成 + 按需触发”三者结合的产物。</strong> 它不是纯粹的硬件中断，也不是纯粹的操作系统时钟，而是Android为移动场景定制的<strong>自适应、低功耗同步引擎</strong>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我一个后端,用AI做了个导航页,发现开发模式真的变了]]></title>    <link>https://juejin.cn/post/7605817795628482610</link>    <guid>https://juejin.cn/post/7605817795628482610</guid>    <pubDate>2026-02-13T02:36:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795628482610" data-draft-id="7605848213603778606" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我一个后端,用AI做了个导航页,发现开发模式真的变了"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-02-13T02:36:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HUHA"/> <meta itemprop="url" content="https://juejin.cn/user/875627647347278"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我一个后端,用AI做了个导航页,发现开发模式真的变了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/875627647347278/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HUHA
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:36:13.000Z" title="Fri Feb 13 2026 02:36:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p>说起来,春节前几天,我突然想做个自己的导航页。</p>
<p>为什么?因为浏览器书签太乱了。常用的开发工具、设计资源、AI工具散得到处都是。每次找都要半天。我想有个地方,把常用的链接都集中起来,还能按类别整理。</p>
<p>虽然我已经在用现成的自定义导航页产品了，但是我没法给他们提需求，他们也不可能会听，有些功能我想改，根本不可能！</p>
<p>我想拥有一个符合自己审美的导航页，于是它来了：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdh.huhage.fun%2F" target="_blank" title="https://dh.huhage.fun/" ref="nofollow noopener noreferrer">dh.huhage.fun/</a></p>
<p>作为后端开发,这个需求挺简单的。但问题来了,我不会写前端。</p>
<p>之前也试过学React、Vue,但每次都坚持不下来。组件、状态管理、样式——对我来说就像天书。所以这个想法就一直拖着,直到春节前几天,我突然想:能不能用AI试试?</p>
<p>结果,两天时间就搞定了。</p>
<p>用的工具链也很简单:Lovable做初版前端,Claude Code和Codex打磨,Supabase接入登录注册。整个过程出奇地顺利,几乎没有遇到什么阻碍。</p>
<p>让我先说说我为什么会选这几个工具。</p>
<h2 data-id="heading-0">为什么是Lovable</h2>
<p>一开始,我其实对比了好几个工具。</p>
<p>市面上的AI开发工具挺多的:Gemini、Bolt.new、ClaudeCode...我都试了一圈。</p>
<p>测试方法很简单,我用同样的Prompt让它们生成导航页:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 个性化导航页开发需求</span>
<span class="hljs-section">## 核心定位</span>
开发一款以极致UI设计为核心竞争力的个性化导航页产品“呼哈导航”，所有视觉元素需经过深度打磨，拒绝同质化、俗套化设计，将UI/UX体验作为核心优先级。

<span class="hljs-section">## 1. 设计要求</span>
<span class="hljs-bullet">-</span> 视觉风格：追求高级感与独特性，每个UI元素（按钮、卡片、图标、动效、配色、排版）均需精细化设计，避免通用模板化风格
<span class="hljs-bullet">-</span> 主题色切换：用户可以自己切换喜欢的主题色
<span class="hljs-bullet">-</span> 布局方案：提供至少3种差异化核心布局（如网格瀑布流、分类抽屉式、极简单列式），支持用户一键切换，每种布局需适配不同使用场景（高效查找、视觉沉浸、极简操作）
<span class="hljs-bullet">-</span> 多端兼容：全站采用响应式设计，移动端需做专属适配（如触控交互优化、竖屏布局重构、操作按钮放大），保证移动端体验与PC端一致优质
<span class="hljs-bullet">-</span> 支持暗黑模式和亮色模式切换
<span class="hljs-bullet">-</span> UI设计必须符合大厂设计规范，有大厂的设计风范

<span class="hljs-section">## 2. 核心功能</span>
<span class="hljs-section">### （1）自定义分类管理</span>
<span class="hljs-bullet">-</span> 用户可自主创建/编辑/删除网址分类（支持分类名称、分类图标、分类排序、分类背景自定义）
<span class="hljs-bullet">-</span> 分类支持层级管理（必须包含一级/二级分类），满足多维度整理需求

<span class="hljs-section">### （2）网址个性化管理</span>
<span class="hljs-bullet">-</span> 每个分类下支持用户添加自定义网址，可配置项包括：网址链接、显示名称、自定义图标（支持上传/选择内置图标/自动抓取网站favicon）、备注信息
<span class="hljs-bullet">-</span> 网址展示形式需精美化：支持卡片悬停动效、图标渐变、信息分层展示，避免单调列表式呈现

<span class="hljs-section">### （3）分享功能</span>
<span class="hljs-bullet">-</span> 支持用户生成自定义分享链接（可自定义链接后缀），分享后访客可直接查看该用户的导航页（只读权限）
<span class="hljs-bullet">-</span> 分享页需保持原设计风格，且适配移动端访问

<span class="hljs-section">### （4）用户系统</span>
<span class="hljs-bullet">-</span> 基础登录功能（支持邮箱/手机号验证，优先考虑Supabase Auth集成）
<span class="hljs-bullet">-</span> 登录后数据与用户账号绑定，支持多端同步

<span class="hljs-section">### （5）搜索功能</span>
<span class="hljs-bullet">-</span> 主页顶部展示搜索功能，可以切换搜索引擎，比如bing、百度、google
<span class="hljs-bullet">-</span> 也支持快速检索用户添加的网址

<span class="hljs-section">## 3. 技术与开发规划</span>
<span class="hljs-bullet">-</span> 数据库：使用Supabase，所有数据表统一前缀为dh<span class="hljs-emphasis">_（如dh_</span>users、dh<span class="hljs-emphasis">_categories、dh_</span>bookmarks）
<span class="hljs-bullet">-</span> 开发优先级：先完成前端UI/交互、核心功能逻辑，数据库相关开发后置（需预留数据对接接口）
<span class="hljs-bullet">-</span> 技术要求：前端需保证性能与视觉一致性，交互动效流畅不卡顿

<span class="hljs-section">## 4. 交付期望</span>
<span class="hljs-bullet">-</span> 清晰的设计稿（含多布局方案、移动端适配稿）
<span class="hljs-bullet">-</span> 可运行的前端原型（核心功能可交互）
<span class="hljs-bullet">-</span> 明确的数据库表结构设计（dh<span class="hljs-emphasis">_前缀）
- 功能实现的技术方案说明
</span></code></pre>
<p>Gemini生成的代码能用,但界面有点普通。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13ebfeaefc284b53b51ad845a952e39e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=2ozIquadck479uPx0hvRSIoQivs%3D" alt="" loading="lazy"/></p>
<p>Bolt.new也不错,但默认的设计模板太程序员审美了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b258c59c704547f59ffef5b571c32432~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=ZAeCAS%2BW7sC28mfFzsUKziSqyaE%3D" alt="" loading="lazy"/></p>
<p>Claude Code搭配GLM4.7不知道搞出了个什么玩意。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f5af5a5afa643bca62f7bc8dcddeb29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=aevrZqGEqRQrwQsI5CzpHiQfJss%3D" alt="" loading="lazy"/></p>
<p>最后试了Lovable,一对比就发现了差距——它的UI更美观,默认生成的界面就很有设计感,不是那种"工程师审美"。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e1680820c0448e0829378532e76c8b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=tH5HwrUE1XjNDv1xtnVTTZlzaS8%3D" alt="" loading="lazy"/></p>
<p>这就是我选Lovable的原因:简单直接,好看就够了。</p>
<p>就这样,大概用了2小时,一个能用的导航页初版就出来了。</p>
<h2 data-id="heading-1">为什么用Claude Code和Codex</h2>
<p>初版能用,但还不够好。</p>
<p>比如,响应式布局有问题,在手机上打开会乱掉。还有一些细节:链接点击后的颜色、hover的效果、分类的展开收起动画...这些都需要调整。</p>
<p>这时候就需要Claude Code和Codex了。</p>
<p>Claude Code我之前就常用,它是个终端AI助手,能直接操作你的代码库。我先把Lovable生成的代码导出到本地,然后用Claude Code打开。</p>
<p>这个过程和我之前用Cursor有点像。但Claude Code的优势在于"项目级理解"——它不只是看单个文件,而是理解整个项目的结构,所以它能找到一些隐藏在多个文件之间的关联问题。</p>
<p>Codex的作用更偏向"细节打磨"。比如我想要给每个网站链接加上favicon图标,这个需求比较琐碎,需要逐个处理。</p>
<p>"帮我给所有外部链接加上自动获取favicon的功能",我对Codex说。</p>
<p>Codex自动分析了需求,写了一段JavaScript代码,调用Google的favicon API,自动为每个链接获取图标。</p>
<p>整个过程大概花了3小时,从初版到一个"看起来挺专业"的导航页,就完成了。</p>
<h2 data-id="heading-2">为什么用Supabase</h2>
<p>做到这一步,导航页已经能用了。但我觉得还缺了点什么。</p>
<p>既然是自己用的工具,能不能加上用户系统?这样我可以分享给朋友,大家都可以有自己的收藏夹。</p>
<p>后端这块我比较熟,所以第一反应就是需要一个数据库和用户认证系统。</p>
<p>之前用过Firebase,但配置起来挺麻烦的。后来听说了Supabase,说是开源版的Firebase,而且和AI工具集成得很好。</p>
<p>春节前那天下午,我注册了Supabase,创建了一个新项目。</p>
<p>然后我用Claude Code连接了Supabase的MCP:</p>
<p>"帮我为这个导航页添加登录注册功能,使用邮箱和密码认证。"</p>
<p>Claude Code自动创建了必要的数据库表,配置了认证策略,然后生成了登录和注册的前端组件。</p>
<p>整个过程不到1小时,登录注册功能就搞定了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cee24315fab4e769b1374c2c8d49c85~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=UJ1EGMGfc5e1AQuNrGDoVQ0j1E4%3D" alt="" loading="lazy"/></p>
<p>而且Supabase不仅做了基本的认证,还自动包含了邮箱验证、密码重置这些功能。这些都是现成的,我不用自己写。</p>
<p>这时候我突然意识到,作为一个后端开发,如果是传统开发方式,光是用户认证这块,至少要花大半天时间。但现在用AI,1小时就搞定了。</p>
<h2 data-id="heading-3">2天完成一个全栈项目</h2>
<p>整个项目花了2天。</p>
<p>第一天用Lovable做初版,2小时搞定。</p>
<p>第二天用Claude Code和Codex打磨,3小时;用Supabase加登录注册,1小时。</p>
<p>剩下的时间主要是测试和微调。</p>
<p>而且整个过程没有遇到什么大坑。</p>
<p>这个速度让我有点意外。作为一个后端开发,如果自己从零学前端做这个项目,保守估计也要一周。而且做出来的效果肯定不如现在。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/abff23ab626b422a9f09e7c09354df22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=1OwnV%2B1%2FiSp7xd8hs8XVMLNsTtI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">我学到了什么</h2>
<p>这个项目做完了,但我最大的收获不是导航页本身,而是对AI时代开发模式的思考。</p>
<p>技术门槛真的降低了。</p>
<p>我以前觉得,做全栈开发需要懂前端、后端、数据库、部署...这些东西要学几年。但现在有了AI工具,一个后端开发也能在两天内做出一个像样的全栈项目。</p>
<p>这不是说技术知识不重要了,而是说,AI把很多"重复劳动"和"模板代码"都自动化了。你只需要懂核心概念,剩下的交给AI。</p>
<p>工具的选择也很重要。</p>
<p>这个项目我用了4个AI工具,每个工具都有它擅长的地方:Lovable擅长快速原型,Claude Code擅长代码理解,Codex擅长细节处理,Supabase擅长后端集成。</p>
<p>没有哪个工具是万能的,但组合起来就很强大。</p>
<p>但我依然需要懂技术。</p>
<p>虽然AI帮我写了大部分代码,但我还是得知道什么是响应式布局,什么是JWT认证,什么是数据库表结构。不然我连需求都描述不清楚,更别说验证AI生成的代码对不对了。</p>
<p>AI不是让开发者变懒,而是让开发者把精力花在更重要的事情上。</p>
<h2 data-id="heading-5">给其他后端开发的建议</h2>
<p>如果你也是个后端开发,想做点前端相关的东西,我有几个建议——</p>
<ol>
<li>
<p>从简单项目开始。别一上来就做复杂的SaaS,先做些工具类、展示类的小项目。</p>
</li>
<li>
<p>用好可视化工具。Lovable这类工具能让你快速看到结果,建立信心。</p>
</li>
<li>
<p>AI是助手,不是替代。你依然需要理解基础概念,只是不用抠细节了。</p>
</li>
<li>
<p>多尝试不同的工具。没有最好,只有最适合你项目的工具组合。</p>
</li>
</ol>
<h2 data-id="heading-6">最后说一句</h2>
<p>做这个导航页之前,我以为自己这辈子都不会碰前端了。</p>
<p>但现在发现,有了AI,后端开发也能做全栈项目。这不是说我会转行做前端,而是说,我的可能性变大了。</p>
<p>以后再想做个小工具,不用再"等我先学学前端"了。直接开干,反正有AI帮忙。</p>
<p>这可能就是AI时代最让我兴奋的地方——技术门槛降低了,但创造的门槛反而更高了,因为限制你的不是技术能力,而是你的想法。</p>
<p>所以,别再"等我学会了什么"才开始动手。现在就可以开始了。</p>
<p><strong>相关链接</strong>:</p>
<ul>
<li>我的导航页: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdh.huhage.fun%2F" target="_blank" title="https://dh.huhage.fun/" ref="nofollow noopener noreferrer">dh.huhage.fun/</a></li>
<li>Lovable: <a href="https://link.juejin.cn?target=https%3A%2F%2Flovable.dev%2F" target="_blank" title="https://lovable.dev/" ref="nofollow noopener noreferrer">lovable.dev/</a></li>
<li>Claude Code: <a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fcode" target="_blank" title="https://claude.ai/code" ref="nofollow noopener noreferrer">claude.ai/code</a></li>
<li>Supabase: <a href="https://link.juejin.cn?target=https%3A%2F%2Fsupabase.com%2F" target="_blank" title="https://supabase.com/" ref="nofollow noopener noreferrer">supabase.com/</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android SurfaceFlinger 笔记]]></title>    <link>https://juejin.cn/post/7605782093482770458</link>    <guid>https://juejin.cn/post/7605782093482770458</guid>    <pubDate>2026-02-13T02:19:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605782093482770458" data-draft-id="7605856048360980518" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android SurfaceFlinger 笔记"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-13T02:19:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="心源xinyuan"/> <meta itemprop="url" content="https://juejin.cn/user/4283353029151694"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android SurfaceFlinger 笔记
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4283353029151694/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    心源xinyuan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:19:23.000Z" title="Fri Feb 13 2026 02:19:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>SurfaceFlinger（以下简称SF）与ActivityManagerService（AMS）是Android底层双雄。<strong>AMS管的是“谁活着、谁死去、谁在前台”</strong>，是<strong>生命周期的CEO</strong>；<strong>SF管的是“谁画了什么、怎么拼成一张图、何时送到屏幕”</strong>，是<strong>视觉呈现的总导演</strong>。</p>
<p>如果说AMS是Android多任务的大脑，SF就是Android图形系统的<strong>心脏</strong>。它不生产像素（应用才是生产者），但它决定每一帧像素如何<strong>最终出现在你眼前</strong>。以下从六个维度彻底拆解SF。</p>
<hr/>
<h2 data-id="heading-0">一、核心定位：SF到底是什么？</h2>
<p>SurfaceFlinger是一个<strong>系统级服务</strong>，运行在<code>system_server</code>进程，职责极度聚焦：<strong>接收所有应用和系统的图形缓冲区（Buffer），按Z轴顺序、透明度、裁剪区域等属性合成，通过硬件显示到屏幕</strong> 。</p>
<p><strong>关键认知</strong>：SF本身<strong>不做绘制</strong>（Draw）。应用的<code>onDraw()</code>、OpenGL渲染、视频解码输出——这些都发生在应用进程。SF只做<strong>合成</strong>（Compose）。</p>
<p><strong>一句话定性</strong>：SF是Android的<strong>图形混合器</strong>和<strong>显示调度中心</strong>。</p>
<h2 data-id="heading-1">二、SF与AMS的“双核关系”</h2>
<p>理解SF必须放在Android整体架构中。AMS和SF是SystemServer中<strong>耦合最深</strong>的两个服务：</p>



































<table><thead><tr><th>维度</th><th>ActivityManagerService (AMS)</th><th>SurfaceFlinger (SF)</th></tr></thead><tbody><tr><td><strong>管理对象</strong></td><td>四大组件、进程、任务栈</td><td>Surface/Layer、图形缓冲区、显示设备</td></tr><tr><td><strong>核心问题</strong></td><td>谁应该在前台？哪个进程活着？</td><td>这块Buffer是谁的？怎么叠？何时送显？</td></tr><tr><td><strong>触发信号</strong></td><td>Intent、按键、系统事件</td><td><strong>VSync中断</strong>（硬件时钟）</td></tr><tr><td><strong>通信对象</strong></td><td>应用主线程（ActivityThread）</td><td>应用渲染线程（RenderThread）或ViewRootImpl</td></tr><tr><td><strong>纽带</strong></td><td><strong>WindowManagerService (WMS)</strong> —— AMS通知WMS窗口焦点变化；WMS通过<code>relayoutWindow()</code>与SF交互，创建/更新Surface</td><td/></tr></tbody></table>
<p><strong>核心结论</strong>：<strong>AMS决定“演什么”，WMS决定“怎么摆”，SF决定“怎么拼、何时放”</strong>。</p>
<hr/>
<h2 data-id="heading-2">三、SF的三大核心支柱</h2>
<p>要彻底理解SF，必须啃下三块硬骨头：<strong>Buffer管理架构</strong>、<strong>合成策略（GPU/HWC）</strong>、<strong>VSync驱动模型</strong>。</p>
<h3 data-id="heading-3">1. 架构基石：BufferQueue与生产-消费模型</h3>
<p>这是Android图形系统<strong>最优雅的设计</strong>，没有之一。它实现了<strong>无拷贝、跨进程、异步</strong>的缓冲区流转 。</p>
<h4 data-id="heading-4">1.1 核心角色</h4>
<ul>
<li><strong>生产者（Producer）</strong>：应用进程（UI线程/RenderThread、Camera、视频解码器）。调用<code>dequeueBuffer()</code>获取空闲Buffer，填充数据，<code>queueBuffer()</code>归还。</li>
<li><strong>消费者（Consumer）</strong>：SurfaceFlinger。调用<code>acquireBuffer()</code>获取已就绪的Buffer，合成后<code>releaseBuffer()</code>释放。</li>
<li><strong>缓冲区队列（BufferQueue）</strong>：在<strong>SF进程</strong>创建，<strong>Buffer本身是共享内存（GraphicBuffer）</strong>，通过Binder传递文件描述符实现零拷贝跨进程传递 。</li>
</ul>
<h4 data-id="heading-5">1.2 Buffer的四种生命状态（铁律）</h4>
<ul>
<li><strong>FREE（空闲）</strong>：队列中无人使用。生产者可<code>dequeue</code>。</li>
<li><strong>DEQUEUED（出列）</strong>：生产者正在填充数据（如执行<code>onDraw()</code>）。</li>
<li><strong>QUEUED（入列）</strong>：生产者完成绘制，等待SF消费。</li>
<li><strong>ACQUIRED（获取）</strong>：SF正在合成这一帧。</li>
</ul>
<p><strong>这是SF调度的最小单元。每一帧都是这四个状态的循环。</strong></p>
<h4 data-id="heading-6">1.3 Surface与Layer的“皮肉关系”</h4>
<ul>
<li><strong>Surface（皮）</strong>：应用侧看到的“画布”，本质是<code>IGraphicBufferProducer</code>的代理。应用通过它<code>lockCanvas()</code>或<code>eglSwapBuffers()</code>触发Buffer流转。</li>
<li><strong>Layer（肉）</strong>：SF侧的“窗口代表”。<strong>每个Surface在SF内部对应一个Layer对象</strong>，记录Z-order、透明度、显示区域等元数据。</li>
<li><strong>创建时机</strong>：WMS调用<code>relayoutWindow()</code> -&gt; SF创建Layer -&gt; 将BufferProducer Binder返回给应用 -&gt; 应用构建Surface。</li>
</ul>
<p><strong>这就是窗口系统跨进程的完整握手</strong> 。</p>
<h3 data-id="heading-7">2. 合成引擎：GPU合成 vs. 硬件合成（HWC）</h3>
<p>SF收到各Layer的Buffer后，必须把它们“拼”成一张完整的屏幕图像。怎么拼？<strong>两种模式，动态切换</strong> 。</p>
<h4 data-id="heading-8">2.1 GPU合成（OpenGL合成）</h4>
<ul>
<li><strong>方式</strong>：将所有Layer的Buffer作为纹理上传GPU，通过OpenGL绘制到一个目标FBO（帧缓冲对象）。</li>
<li><strong>优点</strong>：极其灵活，任意层数、任意形状、任意混合效果。</li>
<li><strong>缺点</strong>：耗电、带宽占用高。</li>
<li><strong>场景</strong>：界面复杂（多窗口）、动画效果、无法被HWC处理的图层。</li>
</ul>
<h4 data-id="heading-9">2.2 硬件合成（HWC，Hardware Composer）</h4>
<ul>
<li><strong>方式</strong>：将Layer信息（Buffer句柄、位置、Z-order）打包发给显示硬件，<strong>由显示控制器（Display Controller）硬件完成叠加</strong>，SF完全不碰像素数据 。</li>
<li><strong>优点</strong>：几乎零功耗、极低延迟。</li>
<li><strong>缺点</strong>：硬件叠图层数有限（通常4-8层），超出部分必须由GPU合成。</li>
<li><strong>场景</strong>：状态栏、导航栏、视频全屏层数少的场景。</li>
</ul>
<h4 data-id="heading-10">2.3 HWC HAL契约</h4>
<p>SF通过HAL层与硬件驱动交互。核心契约：</p>
<ul>
<li><code>prepare()</code>：SF告诉HWC“我有这些Layer，你能硬件合成哪些？”</li>
<li><code>set()</code>：SF把需要硬件合成的Layer Buffer句柄传给HWC；需要GPU合成的部分，SF自己画好再传给HWC作为<strong>帧缓冲区（Framebuffer）</strong>。</li>
<li><strong>Fence机制</strong>：为了精确同步，Buffer的访问权通过同步栅栏（Fence FD）传递，避免CPU/GPU/显示控制器互相踩内存 。</li>
</ul>
<h3 data-id="heading-11">3. 节拍器：VSync驱动模型</h3>
<p><strong>如果没有VSync，SF就是一盘散沙。</strong> Android 4.1（Jelly Bean）引入VSync和Project Butter，这是SF调度模型的革命 。</p>
<h4 data-id="heading-12">3.1 硬件节拍</h4>
<p>屏幕以固定频率刷新（通常是60Hz，即每16.6ms一帧）。硬件在每次刷新前会产生<strong>垂直同步中断（VSync）</strong>。SF的工作就是<strong>卡在这个中断点上进行合成</strong>，杜绝“撕裂”（Tearing） 。</p>
<h4 data-id="heading-13">3.2 两条VSync线</h4>
<p>SF内部维护<strong>两个独立的VSync分发通道</strong>：</p>
<ol>
<li><strong>VSync-app</strong>：分发给应用。Choreographer监听此信号，触发应用开始布局、绘制、<code>dequeueBuffer</code>。</li>
<li><strong>VSync-sf</strong>：分发给SF自己。SF监听此信号，开始合成、<code>acquireBuffer</code>、调用HWC。</li>
</ol>
<p><strong>偏移量（Offset）</strong>：VSync-app通常比VSync-sf<strong>提前几毫秒</strong>。这样应用画完Buffer入队时，SF刚好开始合成，<strong>流水线最大化</strong>。</p>
<h4 data-id="heading-14">3.3 软件VSync预测</h4>
<p>为了减少对硬件中断的依赖，SF维护一个<strong>软件VSync预测模型</strong>。<code>VSyncPredictor</code>根据历史采样计算下一次中断时间，<code>VSyncDispatchTimerQueue</code>负责定时回调。这套机制保证了即使硬件暂时不稳定，UI依然流畅 。</p>
<hr/>
<h2 data-id="heading-15">四、一次完整的渲染合成闭环（六步法）</h2>
<p>把以上组件串起来，看一个典型帧的生命周期：</p>
<p><strong>Step 1：硬件心跳（VSync-app）</strong>
屏幕发出VSync中断 -&gt; HWC HAL捕获 -&gt; SF的<code>EventThread</code>唤醒 -&gt; 通过<code>BitTube</code>跨进程通知应用的<code>Choreographer</code> 。</p>
<p><strong>Step 2：应用生产（主线程+RenderThread）</strong>
应用收到VSync-app，执行<code>doTraversal()</code> -&gt; 测量、布局、绘制 -&gt; <strong>DisplayList转OpenGL命令</strong> -&gt; <code>eglSwapBuffers()</code>触发：</p>
<ul>
<li><code>dequeueBuffer</code>：从BufferQueue取空闲Buffer。</li>
<li>GPU渲染填充。</li>
<li><code>queueBuffer</code>：Buffer入队，状态置为QUEUED，通过Binder回调SF的<code>onFrameAvailable()</code>，标记<code>mQueuedFrames++</code> 。</li>
</ul>
<p><strong>Step 3：SF唤醒（VSync-sf）</strong>
硬件发出VSync-sf（或软件定时触发）-&gt; SF MessageQueue收到消息 -&gt; 执行<code>onMessageInvalidate()</code> -&gt; 正式启动合成流水线 。</p>
<p><strong>Step 4：准备阶段（PreComposition &amp; latchBuffer）</strong></p>
<ul>
<li><code>preComposition()</code>：遍历所有Layer，检查<code>mQueuedFrames &gt; 0</code>，标记需要刷新的Layer。</li>
<li><code>latchBuffer()</code>：对标记的Layer调用<code>acquireBuffer()</code>，拿到应用刚刚画好的GraphicBuffer，<strong>所有权从应用转给SF</strong> 。</li>
</ul>
<p><strong>Step 5：合成决策（handleTransaction &amp; rebuildLayerStacks &amp; setUpHWComposer）</strong></p>
<ul>
<li><code>handleTransaction</code>：处理窗口大小、位置、Z轴变化 。</li>
<li><code>rebuildLayerStacks</code>：按Z轴排序当前屏幕可见Layer，计算每个Layer的脏区域、可见区域。</li>
<li><code>setUpHWComposer</code>：调用HWC <code>prepare()</code>，<strong>决策哪些Layer用硬件叠，哪些用GPU合成</strong> 。</li>
</ul>
<p><strong>Step 6：执行与送显（doComposition &amp; postComposition）</strong></p>
<ul>
<li>GPU合成部分：SF通过OpenGL将选中的Layer绘制到目标FBO。</li>
<li>调用HWC <code>set()</code>：将GPU合成结果（Framebuffer）和硬件合成Layer的Buffer句柄一并交给驱动。</li>
<li><strong>释放Fence</strong>：通知应用侧“Buffer已被消费，可以继续画下一帧”。<code>releaseBuffer()</code> -&gt; Buffer状态回FREE。</li>
<li>屏幕刷新显示新帧。</li>
</ul>
<p><strong>至此，一帧结束。下一帧由下一个VSync触发。</strong> 16.6ms倒计时重新开始。</p>
<hr/>
<h2 data-id="heading-16">五、架构演进：从硬编码到高度抽象</h2>
<p>SF的架构并非一成不变。理解演进史有助于读懂老代码。</p>








































<table><thead><tr><th>时期</th><th>关键变化</th><th>技术驱动</th></tr></thead><tbody><tr><td><strong>Android 1.x-4.0</strong></td><td>单缓冲、CPU合成为主</td><td>硬件弱，功能简单</td></tr><tr><td><strong>Android 4.1</strong></td><td><strong>Project Butter</strong>：引入VSync、三缓冲、Choreographer</td><td>解决卡顿、掉帧</td></tr><tr><td><strong>Android 5.0</strong></td><td><strong>RenderThread</strong>：将主线程的OpenGL操作移到单独线程</td><td>减少主线程负载，提高响应</td></tr><tr><td><strong>Android 7.0</strong></td><td><strong>SurfaceView同步优化</strong>、HWC 2.0支持</td><td>配合VR、多屏显示</td></tr><tr><td><strong>Android 8.x+</strong></td><td><strong>Treble</strong>：HAL层稳定化；<strong>AIDL化</strong>（类似AMS）</td><td>解耦Framework与厂商实现</td></tr><tr><td><strong>Android 12+</strong></td><td>可变刷新率（VRR）、游戏模式插帧</td><td>高刷屏普及，追求能效比</td></tr></tbody></table>
<p><strong>当前趋势</strong>：SF越来越像一个<strong>策略分发器</strong>，将具体合成工作下放给HWC，自己专注于状态跟踪和VSync调度。</p>
<hr/>
<h2 data-id="heading-17">六、开发层面的启示（实战价值）</h2>
<p>理解了SF，你在应用开发中的很多“玄学”问题都会有根本性认知：</p>
<p><strong>1. 为什么说“丢帧”本质是SF没等到Buffer？</strong></p>
<blockquote>
<p>如果应用主线程卡顿（GC、复杂布局），<code>queueBuffer</code>延迟，VSync-sf到来时SF无新帧可用，<strong>屏幕必须重复显示上一帧</strong>，这就是掉帧（Jank）。</p>
</blockquote>
<p><strong>2. 为什么SurfaceView播放视频不卡UI？</strong></p>
<blockquote>
<p>SurfaceView拥有<strong>独立的Surface</strong>，其BufferQueue直接入队SF，<strong>不经过View层级</strong>，绕过主线程复杂绘制逻辑，同时常配HWC硬件叠层，效率极高 。</p>
</blockquote>
<p><strong>3. 为什么动画卡顿优先怀疑CPU/GPU，但有时是SF负载高？</strong></p>
<blockquote>
<p>SF虽然是合成者，但<strong>GPU合成非常耗资源</strong>。如果Z轴层数太多、HWC叠层用满，SF回退GPU合成，可能造成GPU过载、SF主线程超时16.6ms，导致下一帧延迟。</p>
</blockquote>
<p><strong>4. 为什么后台进程可能影响前台流畅度？</strong></p>
<blockquote>
<p>SF的Layer列表包含<strong>所有可见/不可见窗口</strong>。后台应用若持有窗口（如无界面的<code>WindowManager</code>悬浮窗），其BufferQueue即使无新帧，Layer仍在列表中。极端情况下大量Layer导致SF <code>rebuildLayerStacks</code>耗时超标。</p>
</blockquote>
<p><strong>5. 终极调试工具</strong></p>
<blockquote>
<pre><code class="hljs language-bash" lang="bash">adb shell dumpsys SurfaceFlinger
</code></pre>
<p>这是SF的<strong>核磁共振报告</strong>，能查看每一层的Buffer申请记录、掉帧统计、HWC合成策略、GPU合成时间。<strong>分析卡顿的第一现场</strong>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-18">结语</h2>
<p>SurfaceFlinger和ActivityManagerService是Android底层架构的<strong>阴阳两面</strong>。AMS维系着应用世界的“存在与时间”，SF维系着像素世界的“空间与流动”。</p>
<p>把AMS和SF放在一起理解，你会发现Android根本不是一个“单进程UI库”，而是一个<strong>分布式、事件驱动、硬件感知的实时系统</strong>。UI渲染不是函数的线性调用，而是<strong>多个特权进程在硬件节拍指挥下的环环相扣</strong>。</p>
<p><strong>每一帧的流畅，都是AMS、WMS、SF、App、GPU、Display硬件在16.6ms内的完美合奏。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++中的引用传参和指针传参]]></title>    <link>https://juejin.cn/post/7605810996125253666</link>    <guid>https://juejin.cn/post/7605810996125253666</guid>    <pubDate>2026-02-13T03:35:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125253666" data-draft-id="7605542907119108148" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++中的引用传参和指针传参"/> <meta itemprop="keywords" content="C++"/> <meta itemprop="datePublished" content="2026-02-13T03:35:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sTone87375"/> <meta itemprop="url" content="https://juejin.cn/user/2946346894764584"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++中的引用传参和指针传参
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2946346894764584/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sTone87375
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:35:55.000Z" title="Fri Feb 13 2026 03:35:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">核心概念对比</h2>

























<table><thead><tr><th>概念</th><th>C++</th><th>前端 (JS/TS)</th></tr></thead><tbody><tr><td><strong>值传递</strong></td><td>默认方式，完整拷贝</td><td>基本类型 (number, string等)</td></tr><tr><td><strong>引用传递</strong></td><td>需显式使用 <code>&amp;</code> 或指针</td><td>对象、数组、函数等引用类型</td></tr><tr><td><strong>指针传递</strong></td><td>传递内存地址</td><td>类似传递对象的引用</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-1">1. 值传递（默认）- 完整拷贝</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
    <span class="hljs-type">int</span> x, y;
    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b) {
        cout &lt;&lt; <span class="hljs-string">"构造: ("</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    }
    <span class="hljs-built_in">Point</span>(<span class="hljs-type">const</span> Point&amp; p) : <span class="hljs-built_in">x</span>(p.x), <span class="hljs-built_in">y</span>(p.y) {
        cout &lt;&lt; <span class="hljs-string">"拷贝构造: ("</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    }
    ~<span class="hljs-built_in">Point</span>() {
        cout &lt;&lt; <span class="hljs-string">"析构: ("</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    }
};

<span class="hljs-comment">// ❌ 值传递：发生完整拷贝</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byValue</span><span class="hljs-params">(Point p)</span> </span>{
    p.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 修改的是副本，不影响原对象</span>
    cout &lt;&lt; <span class="hljs-string">"函数内: ("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;
    cout &lt;&lt; <span class="hljs-string">"--- 调用函数 ---"</span> &lt;&lt; endl;
    <span class="hljs-built_in">byValue</span>(p1);
    cout &lt;&lt; <span class="hljs-string">"--- 函数返回 ---"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"原对象: ("</span> &lt;&lt; p1.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p1.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;  <span class="hljs-comment">// 仍是 (1,2)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">构造: (1,2)</span>
--- 调用函数 ---
<span class="hljs-section">拷贝构造: (1,2)</span>
<span class="hljs-section">函数内: (100,2)</span>
<span class="hljs-section">析构: (100,2)</span>
--- 函数返回 ---
<span class="hljs-section">原对象: (1,2)</span>
<span class="hljs-section">析构: (1,2)</span>
</code></pre>
<blockquote>
<p>⚠️ <strong>性能问题</strong>：大对象会发生昂贵的深拷贝</p>
</blockquote>
<hr/>
<h2 data-id="heading-2">2. 引用传递（类似前端引用类型）</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 引用传递：不拷贝，直接操作原对象（类似前端的对象引用）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byReference</span><span class="hljs-params">(Point&amp; p)</span> </span>{
    p.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接修改原对象！</span>
    cout &lt;&lt; <span class="hljs-string">"函数内: ("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
}

<span class="hljs-comment">// ✅ const 引用：只读访问，不拷贝也不能修改</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byConstReference</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> </span>{
    <span class="hljs-comment">// p.x = 100;  // ❌ 编译错误：不能修改const引用</span>
    cout &lt;&lt; <span class="hljs-string">"只读访问: ("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;
    
    cout &lt;&lt; <span class="hljs-string">"=== 引用传递 ==="</span> &lt;&lt; endl;
    <span class="hljs-built_in">byReference</span>(p1);
    cout &lt;&lt; <span class="hljs-string">"原对象已被修改: ("</span> &lt;&lt; p1.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p1.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;  <span class="hljs-comment">// (100,2)</span>
    
    cout &lt;&lt; <span class="hljs-string">"\n=== const引用 ==="</span> &lt;&lt; endl;
    <span class="hljs-built_in">byConstReference</span>(p1);
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>与前端对比：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// JavaScript - 对象天然是引用传递</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">modify</span>(<span class="hljs-params">obj</span>) {
    obj.<span class="hljs-property">x</span> = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接修改原对象</span>
}
<span class="hljs-keyword">let</span> p = {<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>};
<span class="hljs-title function_">modify</span>(p);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">x</span>);  <span class="hljs-comment">// 100 ✅</span>

<span class="hljs-comment">// C++ 必须显式加 &amp; 才能实现同样效果</span>
</code></pre>
<hr/>
<h2 data-id="heading-3">3. 指针传递（C风格，更灵活但危险）</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 指针传递：传递内存地址</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byPointer</span><span class="hljs-params">(Point* p)</span> </span>{
    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) {  <span class="hljs-comment">// 必须检查空指针！</span>
        p-&gt;x = <span class="hljs-number">200</span>;      <span class="hljs-comment">// 使用 -&gt; 访问成员</span>
    }
}

<span class="hljs-comment">// 指针的const版本</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byConstPointer</span><span class="hljs-params">(<span class="hljs-type">const</span> Point* p)</span> </span>{
    <span class="hljs-comment">// p-&gt;x = 200;  // ❌ 不能修改</span>
    cout &lt;&lt; p-&gt;x &lt;&lt; endl;  <span class="hljs-comment">// ✅ 可以读取</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;
    
    <span class="hljs-built_in">byPointer</span>(&amp;p1);  <span class="hljs-comment">// 必须取地址</span>
    cout &lt;&lt; <span class="hljs-string">"修改后: ("</span> &lt;&lt; p1.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p1.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    
    <span class="hljs-comment">// 可以传 nullptr（这是与引用的重要区别）</span>
    <span class="hljs-built_in">byPointer</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// ✅ 合法</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>引用 vs 指针对比：</strong></p>






























<table><thead><tr><th>特性</th><th>引用 <code>&amp;</code></th><th>指针 <code>*</code></th></tr></thead><tbody><tr><td>语法</td><td>更简洁，像原对象</td><td>需解引用 <code>-&gt;</code> 或 <code>*</code></td></tr><tr><td>空值</td><td>不能为 null</td><td>可以为 nullptr</td></tr><tr><td>重新绑定</td><td>不能改指向其他对象</td><td>可以指向不同对象</td></tr><tr><td>安全性</td><td>更高（必须初始化）</td><td>需检查空指针</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-4">4. 返回值优化（RVO）与移动语义</h2>
<h3 data-id="heading-5">传统返回值（有拷贝）</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ❌ C++11前：返回时会发生拷贝（或编译器RVO优化）</span>
<span class="hljs-function">Point <span class="hljs-title">createPoint</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;
    <span class="hljs-keyword">return</span> p;  <span class="hljs-comment">// 理论上会拷贝，但编译器通常优化掉</span>
}

<span class="hljs-comment">// 接收时再次拷贝</span>
Point p2 = <span class="hljs-built_in">createPoint</span>();
</code></pre>
<h3 data-id="heading-6">现代C++：移动语义（C++11起）</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigData</span> {
    <span class="hljs-type">int</span>* data;
    <span class="hljs-type">size_t</span> size;
    
    <span class="hljs-comment">// 移动构造函数（转移资源所有权，不拷贝数据）</span>
    <span class="hljs-built_in">BigData</span>(BigData&amp;&amp; other) <span class="hljs-keyword">noexcept</span> 
        : <span class="hljs-built_in">data</span>(other.data), <span class="hljs-built_in">size</span>(other.size) {
        cout &lt;&lt; <span class="hljs-string">"移动构造（偷资源）"</span> &lt;&lt; endl;
        other.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 置空源对象</span>
        other.size = <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-comment">// 移动赋值</span>
    BigData&amp; <span class="hljs-keyword">operator</span>=(BigData&amp;&amp; other) <span class="hljs-keyword">noexcept</span> {
        cout &lt;&lt; <span class="hljs-string">"移动赋值"</span> &lt;&lt; endl;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) {
            <span class="hljs-keyword">delete</span>[] data;
            data = other.data;
            size = other.size;
            other.data = <span class="hljs-literal">nullptr</span>;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};

<span class="hljs-function">BigData <span class="hljs-title">createBigData</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">BigData <span class="hljs-title">bd</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;  <span class="hljs-comment">// 分配大量内存</span>
    <span class="hljs-keyword">return</span> bd;  <span class="hljs-comment">// 触发移动语义，而非深拷贝！</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    BigData bd1 = <span class="hljs-built_in">createBigData</span>();  <span class="hljs-comment">// 移动构造，几乎零开销</span>
    BigData bd2;
    bd2 = <span class="hljs-built_in">createBigData</span>();          <span class="hljs-comment">// 移动赋值</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr/>
<h2 data-id="heading-7">5. 最佳实践总结</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 最佳实践速查表</span>

<span class="hljs-comment">// 1. 小对象（int, double, 小结构体）：直接值传递</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, Point p)</span></span>;  

<span class="hljs-comment">// 2. 大对象只读访问：const 引用（性能+安全）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> BigData&amp; data)</span></span>;

<span class="hljs-comment">// 3. 需要修改原对象：非const引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Point&amp; p)</span></span>;

<span class="hljs-comment">// 4. 参数可选（可能为空）：指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maybeProcess</span><span class="hljs-params">(BigData* data)</span></span>;  <span class="hljs-comment">// data可以是nullptr</span>

<span class="hljs-comment">// 5. 转移所有权（C++11）：右值引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">takeOwnership</span><span class="hljs-params">(BigData&amp;&amp; data)</span></span>;

<span class="hljs-comment">// 6. 返回值：优先返回值（依赖RVO/移动），而非输出参数</span>
<span class="hljs-function">BigData <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// ✅ 现代C++推荐</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(BigData&amp; out)</span></span>;  <span class="hljs-comment">// 旧式风格，避免</span>
</code></pre>
<hr/>
<h2 data-id="heading-8">类比总结</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// C++ 显式控制传递方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point p)</span></span>;      <span class="hljs-comment">// 值传递（拷贝）    ← 像 JS 的 structuredClone</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point&amp; p)</span></span>;     <span class="hljs-comment">// 引用传递（别名）   ← 像 JS 的对象引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span></span>; <span class="hljs-comment">// const引用       ← 像 JS 的只读引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point* p)</span></span>;     <span class="hljs-comment">// 指针传递         ← 像 JS 的弱引用/可空引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point&amp;&amp; p)</span></span>;    <span class="hljs-comment">// 右值引用（移动）   ← 像 JS 的 对象转移/解构赋值</span>
</code></pre>
<p><strong>关键区别</strong>：C++ 默认是<strong>值语义</strong>（拷贝），必须显式使用 <code>&amp;</code> 才能获得<strong>引用语义</strong>；而前端（JS）对象默认就是<strong>引用语义</strong>。</p>
<hr/>
<p>以下深入剖析 C++ 中引用传递和指针传递的本质差异。</p>
<h2 data-id="heading-9">核心对比表</h2>








































<table><thead><tr><th>维度</th><th>引用传递 <code>T&amp;</code></th><th>指针传递 <code>T*</code></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>别名（alias），必须绑定有效对象</td><td>内存地址，可独立存在</td></tr><tr><td><strong>空值</strong></td><td>❌ 不能为 null</td><td>✅ 可以为 <code>nullptr</code></td></tr><tr><td><strong>重新绑定</strong></td><td>❌ 终身绑定，不能改指向</td><td>✅ 可随时指向其他对象</td></tr><tr><td><strong>语法</strong></td><td>使用原对象语法 <code>.</code></td><td>需解引用 <code>-&gt;</code> 或 <code>*</code></td></tr><tr><td><strong>初始化</strong></td><td>必须初始化</td><td>可以延迟初始化</td></tr><tr><td><strong>内存占用</strong></td><td>通常优化为无开销</td><td>占用指针大小（4/8字节）</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-10">本质差异图解</h2>
<pre><code class="hljs language-scss" lang="scss">引用 (&amp;)                    指针 (*)
┌─────────┐                ┌─────────┐
│  引用变量  │ ──→ 对象      │ 指针变量  │ ──→ 对象
│  (别名)   │   (必须存在)   │ (地址)   │   或 ──→ nullptr
└─────────┘                └─────────┘
   语法糖，编译器处理           真正的内存实体
</code></pre>
<hr/>
<h2 data-id="heading-11">代码层面深度对比</h2>
<h3 data-id="heading-12">1. 基础语法差异</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> {
    <span class="hljs-type">int</span> port;
    string host;
};

<span class="hljs-comment">// ========== 引用版本 ==========</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupByRef</span><span class="hljs-params">(Config&amp; cfg)</span> </span>{
    <span class="hljs-comment">// 语法：直接使用对象</span>
    cfg.port = <span class="hljs-number">8080</span>;
    cfg.host = <span class="hljs-string">"localhost"</span>;
    
    <span class="hljs-comment">// ❌ 不能检查是否为空（假设一定存在）</span>
    <span class="hljs-comment">// if (&amp;cfg == nullptr) {}  // 无意义，引用不能为null</span>
}

<span class="hljs-comment">// ========== 指针版本 ==========</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupByPtr</span><span class="hljs-params">(Config* cfg)</span> </span>{
    <span class="hljs-comment">// 语法：必须先检查空指针</span>
    <span class="hljs-keyword">if</span> (cfg == <span class="hljs-literal">nullptr</span>) {
        cerr &lt;&lt; <span class="hljs-string">"错误：配置为空"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 解引用方式1：-&gt;</span>
    cfg-&gt;port = <span class="hljs-number">8080</span>;
    
    <span class="hljs-comment">// 解引用方式2：*（获取引用后再用.）</span>
    (*cfg).host = <span class="hljs-string">"localhost"</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Config c{<span class="hljs-number">0</span>, <span class="hljs-string">""</span>};
    
    <span class="hljs-comment">// 引用调用：简单直接</span>
    <span class="hljs-built_in">setupByRef</span>(c);
    
    <span class="hljs-comment">// 指针调用：必须取地址</span>
    <span class="hljs-built_in">setupByPtr</span>(&amp;c);
    <span class="hljs-built_in">setupByPtr</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// ✅ 可以传空，函数内部处理</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 data-id="heading-13">2. 重新绑定能力（关键差异）</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateRebinding</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;
    
    <span class="hljs-comment">// ========== 引用：终身绑定 ==========</span>
    <span class="hljs-type">int</span>&amp; ref = a;
    ref = b;      <span class="hljs-comment">// ❌ 这不是让ref指向b！而是把b的值赋给a</span>
                  <span class="hljs-comment">// 结果：a = 20, ref仍是a的别名</span>
    
    <span class="hljs-comment">// 想改指向？不可能！</span>
    <span class="hljs-comment">// &amp;ref = b;   // 编译错误！</span>
    
    <span class="hljs-comment">// ========== 指针：灵活重定向 ==========</span>
    <span class="hljs-type">int</span>* ptr = &amp;a;
    cout &lt;&lt; *ptr;  <span class="hljs-comment">// 10</span>
    
    ptr = &amp;b;      <span class="hljs-comment">// ✅ 随时改指向</span>
    cout &lt;&lt; *ptr;  <span class="hljs-comment">// 20</span>
    
    ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// ✅ 可以指向空</span>
}
</code></pre>
<h3 data-id="heading-14">3. 多级间接访问</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 指针可以指向指针，引用不行</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pointerChain</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;
    <span class="hljs-type">int</span>* p = &amp;x;
    <span class="hljs-type">int</span>** pp = &amp;p;      <span class="hljs-comment">// ✅ 指针的指针</span>
    <span class="hljs-type">int</span>*** ppp = &amp;pp;   <span class="hljs-comment">// ✅ 可以无限套娃</span>
    
    cout &lt;&lt; ***ppp;     <span class="hljs-comment">// 42</span>
    
    <span class="hljs-comment">// 引用只有一级（引用的引用被折叠）</span>
    <span class="hljs-type">int</span>&amp; r = x;
    <span class="hljs-comment">// int&amp;&amp; rr = r;    // 这是右值引用，不是引用的引用！</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-15">本质差异：编译器视角</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 源代码</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byRef</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; r)</span> </span>{ r = <span class="hljs-number">10</span>; }
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byPtr</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>{ *p = <span class="hljs-number">10</span>; }

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">byRef</span>(x);
    <span class="hljs-built_in">byPtr</span>(&amp;x);
}
</code></pre>
<p><strong>编译后的伪代码：</strong></p>
<pre><code class="hljs language-asm" lang="asm">; 引用版本（编译器优化后，与指针相同）
byRef:
    mov eax, [esp+4]    ; 取地址（与指针一样！）
    mov dword [eax], 10 ; 解引用赋值
    
; 指针版本
byPtr:
    mov eax, [esp+4]    ; 取地址
    test eax, eax       ; ✅ 检查空指针（编译器可能优化掉）
    je .null_handler
    mov dword [eax], 10
    
; 结论：引用是指针的语法糖，但编译器保证非空
</code></pre>
<blockquote>
<p><strong>本质真相</strong>：引用在底层<strong>就是指针</strong>，但编译器添加了<strong>非空约束</strong>和<strong>自动解引用</strong>的语法糖。</p>
</blockquote>
<hr/>
<h2 data-id="heading-16">适用场景详解</h2>
<h3 data-id="heading-17">✅ 引用传递适用场景</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 场景1：参数必须存在（业务逻辑要求）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectDatabase</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionConfig&amp; config)</span> </span>{
    <span class="hljs-comment">// 配置必须提供，不存在"无配置"的情况</span>
    <span class="hljs-comment">// 无需检查空，简化代码</span>
}

<span class="hljs-comment">// 场景2：操作符重载（只能用引用）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 必须返回引用才能链式赋值：v1 = v2 = v3</span>
    Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; other) {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 解引用返回引用</span>
    }
    
    <span class="hljs-comment">// 下标运算符</span>
    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) {
        <span class="hljs-keyword">return</span> data[index];  <span class="hljs-comment">// 必须返回引用才能：v[0] = 10</span>
    }
};

<span class="hljs-comment">// 场景3：函数式编程风格（明确所有权）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span></span>;           <span class="hljs-comment">// 修改原数据</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span></span>;    <span class="hljs-comment">// 只读访问</span>
</code></pre>
<h3 data-id="heading-18">✅ 指针传递适用场景</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 场景1：参数可选（可为空）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> string* prefix = <span class="hljs-literal">nullptr</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (prefix) {
        cout &lt;&lt; <span class="hljs-string">"["</span> &lt;&lt; *prefix &lt;&lt; <span class="hljs-string">"] "</span>;
    }
    cout &lt;&lt; <span class="hljs-string">"日志内容"</span> &lt;&lt; endl;
}
<span class="hljs-comment">// 调用：logMessage(); 或 logMessage(&amp;debugTag);</span>

<span class="hljs-comment">// 场景2：动态内存管理（所有权转移）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLargeFile</span><span class="hljs-params">(unique_ptr&lt;FileData&gt;* filePtr)</span> </span>{
    <span class="hljs-comment">// 可能转移所有权，或释放内存</span>
    <span class="hljs-keyword">if</span> (filePtr &amp;&amp; *filePtr) {
        <span class="hljs-keyword">auto</span> data = std::<span class="hljs-built_in">move</span>(*filePtr);  <span class="hljs-comment">// 接管所有权</span>
        <span class="hljs-comment">// filePtr 现在指向空unique_ptr</span>
    }
}

<span class="hljs-comment">// 场景3：C接口兼容/多态数组</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawShapes</span><span class="hljs-params">(Shape** shapes, <span class="hljs-type">size_t</span> count)</span> </span>{
    <span class="hljs-comment">// 指针数组，支持运行时多态</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) {
        shapes[i]-&gt;<span class="hljs-built_in">draw</span>();  <span class="hljs-comment">// 虚函数调用</span>
    }
}

<span class="hljs-comment">// 场景4：需要重新指向（迭代、遍历）</span>
<span class="hljs-function">Node* <span class="hljs-title">findNode</span><span class="hljs-params">(Node* head, <span class="hljs-type">int</span> value)</span> </span>{
    Node* current = head;      <span class="hljs-comment">// 从head开始</span>
    <span class="hljs-keyword">while</span> (current) {
        <span class="hljs-keyword">if</span> (current-&gt;val == value) <span class="hljs-keyword">return</span> current;
        current = current-&gt;next;  <span class="hljs-comment">// ✅ 指针可以遍历</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}
<span class="hljs-comment">// 如果用引用：Node&amp; current = head; current = ... 会修改原head！</span>
</code></pre>
<hr/>
<h2 data-id="heading-19">现代C++的最佳实践</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 🏆 参数传递决策树</span>

<span class="hljs-comment">// 1. 小对象（&lt;= 2个指针大小）：值传递</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, Point p)</span></span>;

<span class="hljs-comment">// 2. 只读大对象：const 引用（首选）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> BigData&amp; data)</span></span>;

<span class="hljs-comment">// 3. 必须修改原对象：非const 引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Config&amp; cfg)</span></span>;

<span class="hljs-comment">// 4. 参数可选/可为空：指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">(<span class="hljs-type">const</span> Camera* cam = <span class="hljs-literal">nullptr</span>)</span></span>;

<span class="hljs-comment">// 5. 转移所有权（C++11）：右值引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consume</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; data)</span></span>;

<span class="hljs-comment">// 6. 动态数组/多态：智能指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">(shared_ptr&lt;Mesh&gt; mesh)</span></span>;      <span class="hljs-comment">// 共享所有权</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">takeData</span><span class="hljs-params">(unique_ptr&lt;Buffer&gt; buffer)</span></span>;   <span class="hljs-comment">// 独占所有权</span>
</code></pre>
<hr/>
<h2 data-id="heading-20">一句话总结</h2>
<blockquote>
<p><strong>引用是"承诺存在的别名"，指针是"可能为空的地址"。</strong></p>
<p>用引用表达<strong>契约</strong>（必须存在），用指针表达<strong>可选性</strong>（可能为空）。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端侦探：我是如何挖掘出网站里 28 个"隐藏商品"的？]]></title>    <link>https://juejin.cn/post/7605816833191641088</link>    <guid>https://juejin.cn/post/7605816833191641088</guid>    <pubDate>2026-02-13T03:36:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605816833191641088" data-draft-id="7605772919224778786" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端侦探：我是如何挖掘出网站里 28 个&quot;隐藏商品&quot;的？"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2026-02-13T03:36:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小冰球"/> <meta itemprop="url" content="https://juejin.cn/user/2014722836669176"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端侦探：我是如何挖掘出网站里 28 个"隐藏商品"的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2014722836669176/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小冰球
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:36:08.000Z" title="Fri Feb 13 2026 03:36:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前端侦探：我是如何挖掘出网站里 28 个"隐藏商品"的？</h2>
<blockquote>
<p><strong>免责声明</strong>：本文仅供技术交流与学习，请勿利用文中技术手段对他人的服务器造成压力或进行恶意爬取。所有测试数据均来自公开接口。</p>
</blockquote>
<h3 data-id="heading-1">🕵️‍♂️ 从一个好奇心开始</h3>
<p>前几天逛一个数字产品合租平台（nf.video）时，我发现它首页只孤零零地挂着 6 个商品：Netflix、Disney+、Spotify 等常见的全家桶。</p>
<p>作为一个前端开发者，我的直觉告诉我：<strong>事情没这么简单</strong>。</p>
<p>通常这类平台为了 SEO 或者后台管理的统一性，数据库里往往躺着更多商品，只是因为库存、策略原因被前端"隐藏"了。今天就带大家通过<strong>浏览器控制台（Console）</strong>，用几招前端调试技巧，扒出那些藏在代码背后的秘密。</p>
<hr/>
<h3 data-id="heading-2">🔍 第一层：摆在明面上的数据</h3>
<p>首先，我们看看普通用户能看到什么。打开控制台，简单查一下 DOM：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 获取首页所有商品卡片</span>
<span class="hljs-keyword">const</span> cards = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.platFormItem'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`首页可见商品数: <span class="hljs-subst">${cards.length}</span>`</span>);
<span class="hljs-comment">// 输出: 6</span>
</code></pre>
<p>确实只有 6 个。这建立了我们的"基准线"。如果后面我们找到了多于 6 个的数据，那就说明有"隐藏款"。</p>
<hr/>
<h3 data-id="heading-3">🎣 第二层：Vue Router 拦截术</h3>
<p>点击商品卡片会跳转到购买页。通常我们会看 Network 面板找链接，但这个网站是 SPA（单页应用），点击是路由跳转。</p>
<p>为了不真的跳走（跳走就得退回来，麻烦），我们可以利用 Vue Router 的<strong>全局前置守卫</strong>来做一个"钩子"。我们想知道点击卡片后，路由到底想带我们去哪？</p>
<p>我们可以直接在控制台注入这段代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 假设挂载在 app 上的 router 实例（视具体项目而定，通常在 vueApp.config 或 __vue_app__ 中）</span>
<span class="hljs-comment">// 这里演示思路</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#app'</span>).<span class="hljs-property">__vue_app__</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$router</span>;

<span class="hljs-comment">// 👮‍♂️ 注册一个拦截守卫</span>
router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎯 捕获到目标路由: <span class="hljs-subst">${to.fullPath}</span>`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📦 参数 ID: <span class="hljs-subst">${to.params.id}</span>`</span>);
    
    <span class="hljs-comment">// ✋ next(false) 阻止实际跳转，我们就停在当前页</span>
    <span class="hljs-title function_">next</span>(<span class="hljs-literal">false</span>); 
});
</code></pre>
<p>然后在页面上点击一个"苹果商店"的卡片：</p>
<blockquote>
<p>Console 输出:
<code>🎯 捕获到目标路由: /buy/31</code>
<code>📦 参数 ID: 31</code></p>
</blockquote>
<p>Bingo！我们摸清了路由规则：<code>/buy/:id</code>。这意味着商品是以 ID 为索引的。</p>
<hr/>
<h3 data-id="heading-4">🕵️ 第三层：Performance API 里的蛛丝马迹</h3>
<p>页面加载完了，Network 面板里的请求都被冲掉了或者很难找。这时，浏览器原生的 <strong>Performance API</strong> 就像一个黑匣子，记录了所有发生过的资源请求。</p>
<p>我想看看前端到底请求了哪些 API 接口：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 筛选所有 XMLHttpRequest 或 Fetch 请求</span>
<span class="hljs-keyword">const</span> apiRequests = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">'resource'</span>)
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-property">initiatorType</span> === <span class="hljs-string">'xmlhttprequest'</span> || e.<span class="hljs-property">initiatorType</span> === <span class="hljs-string">'fetch'</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-property">name</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(apiRequests);
</code></pre>
<p>在一堆日志里，我发现了这几个有趣的接口：</p>
<ul>
<li><code>/api/applets/goods/get/homeManage</code> (首页数据，估计就那 6 个)</li>
<li><code>/api/applets/goods/get/categoryGoods</code> (分类商品？这个听起来有戏！)</li>
</ul>
<p>我尝试手动调用了一下这个 <code>categoryGoods</code> 接口：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/applets/goods/get/categoryGoods'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`拿到所有商品数: <span class="hljs-subst">${data.data.length}</span>`</span>));
<span class="hljs-comment">// 输出: 27</span>
</code></pre>
<p><strong>27 个！</strong> 远超首页的 6 个。</p>
<p>通过分析返回的 JSON，我看到了大量首页没展示的商品：</p>
<ul>
<li><code>ID 20</code>: MagSafe 三合一无线充</li>
<li><code>ID 96</code>: 银河次时代智能 NAS (这啥黑科技？)</li>
<li><code>ID 111</code>: Typora 正版授权</li>
</ul>
<p>到这里，如果是普通用户可能就满足了。但作为程序员，我注意到 ID 并不连续。最大的 ID 是 113，但中间缺了很多数字。</p>
<p><strong>那些消失的 ID 去哪了？</strong></p>
<hr/>
<h3 data-id="heading-5">🚀 第四层：ID 暴力枚举与深度挖掘</h3>
<p>既然知道了 API 模式是 <code>/api/applets/goods/get/:id</code>，且 ID 是数字。那我能不能写个脚本，把 1 到 200 的 ID 全扫一遍？</p>
<p>这就像是在玩"扫雷"。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 简单的并发探测脚本</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scanHiddenGoods</span>(<span class="hljs-params">maxId</span>) {
    <span class="hljs-keyword">const</span> hiddenGoods = [];
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🚀 开始扫描 ID 1 - <span class="hljs-subst">${maxId}</span>...`</span>);
    
    <span class="hljs-keyword">const</span> promises = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>; id &lt;= maxId; id++) {
        <span class="hljs-keyword">const</span> p = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/8081/api/applets/goods/get/<span class="hljs-subst">${id}</span>`</span>)
            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
                <span class="hljs-comment">// 如果接口返回成功且有数据</span>
                <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> === <span class="hljs-number">10000</span> &amp;&amp; res.<span class="hljs-property">data</span>) {
                    <span class="hljs-keyword">return</span> { id, <span class="hljs-attr">name</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">goodsName</span>, <span class="hljs-attr">price</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">price</span> };
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            })
            .<span class="hljs-keyword">catch</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">null</span>);
        promises.<span class="hljs-title function_">push</span>(p);
    }

    <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);
    <span class="hljs-keyword">return</span> results.<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// 过滤掉 null</span>
}

<span class="hljs-comment">// 让我们跑一下</span>
<span class="hljs-title function_">scanHiddenGoods</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">goods</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(goods);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎉 共发现商品: <span class="hljs-subst">${goods.length}</span> 个`</span>);
});
</code></pre>
<p>几秒钟后，控制台打出了一张长长的表格。</p>
<p><strong>结果令人震惊：</strong></p>
<p>除了刚才分类列表里的 27 个，我又挖出了 <strong>8 个"幽灵商品"</strong>。这些商品连分类 API 都不返回，完全是"隐形"的，只有通过 ID 直达才能看到：</p>






























<table><thead><tr><th>ID</th><th>名称</th><th>这居然也有？</th></tr></thead><tbody><tr><td>18</td><td>GPT Plus</td><td>可能因为合规问题隐藏</td></tr><tr><td>26</td><td>Midjourney</td><td>只能直接访问购买</td></tr><tr><td>50</td><td>Runway</td><td>那个文生视频的 AI</td></tr><tr><td>105</td><td>Codex</td><td>编程神器</td></tr></tbody></table>
<p>这些商品很可能是测试下架的、或者是仅限内部/老客户通过链接购买的。</p>
<hr/>
<h3 data-id="heading-6">📝 总结</h3>
<p>通过这次探索，我们发现了网站里共有 <strong>34</strong> 个有效商品，而首页只展示了 <strong>17%</strong>。</p>
<p>回顾一下我们的"作案工具"：</p>
<ol>
<li><strong>DOM 解析</strong>：看清表象。</li>
<li><strong>Vue Router 守卫</strong>：拦截路由，探知路径规则。</li>
<li><strong>Performance API</strong>：回溯历史请求，定位关键后端接口。</li>
<li><strong>Promise.all 并发探测</strong>：暴力枚举，发现离散数据。</li>
</ol>
<p>前端开发不仅仅是画页面，善用浏览器提供的调试工具，我们可以对正在运行的应用有更深层的理解（或者单纯是为了满足好奇心 😉）。</p>
<hr/>
<p><em>如果你觉得这个分析过程有趣，欢迎点赞收藏！</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让你的代码更整洁：10 个必知的 Kotlin 扩展函数]]></title>    <link>https://juejin.cn/post/7605941424535994422</link>    <guid>https://juejin.cn/post/7605941424535994422</guid>    <pubDate>2026-02-13T03:32:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605941424535994422" data-draft-id="7605807405307396159" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让你的代码更整洁：10 个必知的 Kotlin 扩展函数"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-13T03:32:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Ehtan_Zheng"/> <meta itemprop="url" content="https://juejin.cn/user/413072099642478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让你的代码更整洁：10 个必知的 Kotlin 扩展函数
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/413072099642478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Ehtan_Zheng
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:32:13.000Z" title="Fri Feb 13 2026 03:32:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>扩展函数是 Kotlin 最强大的特性之一，但许多开发者并未充分发挥其潜力。在审阅了数万行 Kotlin 代码后，我发现：恰到好处地使用扩展函数，能将冗长、重复的代码转化为优雅且易读的表达式。</p>
<p>别再写那些工具类（Helper classes）和静态方法（Utility methods）了。这十个扩展函数模式将让你的 Kotlin 代码更整洁、更具表现力，且更易于维护。</p>
<h3 data-id="heading-0">为什么扩展函数至关重要</h3>
<p>扩展函数允许你：</p>
<ul>
<li><strong>无需继承即可扩展功能</strong>：直接为现有类添加新功能。</li>
<li><strong>提升可读性</strong>：通过领域特定语言（DSL）使代码更易理解。</li>
<li><strong>减少样板代码</strong>：彻底消除臃肿的工具类（Utility classes）。</li>
<li><strong>实现自然链式操作</strong>：让代码调用逻辑更顺畅。</li>
</ul>
<p>让我们通过以下十个模式，看看它们是如何重塑你的代码库的。</p>
<h3 data-id="heading-1">模式 1：字符串校验扩展 (String Validation Extensions)</h3>
<p><strong>问题：</strong> 字符串校验逻辑散落在代码库的各个角落。</p>
<h4 data-id="heading-2">基础校验扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✓ 简洁的校验扩展函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">isValidEmail</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> matches(Regex(<span class="hljs-string">"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">isValidPhone</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> matches(Regex(<span class="hljs-string">"^\\+?[1-9]\\d{1,14}$"</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">isValidUrl</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
        java.net.URL(<span class="hljs-keyword">this</span>)
        <span class="hljs-literal">true</span>
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        <span class="hljs-literal">false</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">isAlphanumeric</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> matches(Regex(<span class="hljs-string">"^[a-zA-Z0-9]+$"</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">containsDigit</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> any { it.isDigit() }
}
</code></pre>
<h3 data-id="heading-3">高级字符串扩展</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">truncate</span><span class="hljs-params">(maxLength: <span class="hljs-type">Int</span>, ellipsis: <span class="hljs-type">String</span> = <span class="hljs-string">"..."</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (length &lt;= maxLength) <span class="hljs-keyword">this</span>
    <span class="hljs-keyword">else</span> take(maxLength - ellipsis.length) + ellipsis
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">capitalizeWords</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> split(<span class="hljs-string">" "</span>).joinToString(<span class="hljs-string">" "</span>) { word -&gt;
        word.replaceFirstChar { <span class="hljs-keyword">if</span> (it.isLowerCase()) it.titlecase() <span class="hljs-keyword">else</span> it.toString() }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">removeWhitespace</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> replace(<span class="hljs-string">"\s+"</span>.toRegex(), <span class="hljs-string">""</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">toSlug</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> lowercase()
        .replace(<span class="hljs-string">"\s+"</span>.toRegex(), <span class="hljs-string">"-"</span>)
        .replace(<span class="hljs-string">"[^a-z0-9-]"</span>.toRegex(), <span class="hljs-string">""</span>)
        .replace(<span class="hljs-string">"-+"</span>.toRegex(), <span class="hljs-string">"-"</span>)
        .trim(<span class="hljs-string">'-'</span>)
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> title = <span class="hljs-string">"This is a Long Article Title That Needs Truncation"</span>
<span class="hljs-keyword">val</span> short = title.truncate(<span class="hljs-number">20</span>) <span class="hljs-comment">// 结果: "This is a Long Ar..."</span>

<span class="hljs-keyword">val</span> name = <span class="hljs-string">"john doe"</span>
<span class="hljs-keyword">val</span> formatted = name.capitalizeWords() <span class="hljs-comment">// 结果: "John Doe"</span>

<span class="hljs-keyword">val</span> slug = <span class="hljs-string">"My Blog Post!"</span>.toSlug() <span class="hljs-comment">// 结果: "my-blog-post"</span>

</code></pre>
<hr/>
<h3 data-id="heading-4">模式 2：空安全扩展 (Null Safety Extensions)</h3>
<p><strong>问题：</strong> 代码中充斥着重复的判空检查和 Elvis 操作符（<code>?:</code>）。这是处理空值时最广泛使用的模式之一。</p>
<h4 data-id="heading-5">空安全辅助函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">orDefault</span><span class="hljs-params">(default: <span class="hljs-type">T</span>)</span></span>: T {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> ?: default
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">orThrow</span><span class="hljs-params">(exception: () -&gt; <span class="hljs-type">Exception</span>)</span></span>: T {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> ?: <span class="hljs-keyword">throw</span> exception()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">ifNull</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Unit</span>)</span></span>: T? {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) action()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">ifNotNull</span><span class="hljs-params">(action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T? {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != <span class="hljs-literal">null</span>) action(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> username: String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> display = username.orDefault(<span class="hljs-string">"Guest"</span>) <span class="hljs-comment">// 结果: "Guest"</span>

<span class="hljs-keyword">val</span> userId: String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> id = userId.orThrow { IllegalArgumentException(<span class="hljs-string">"需要用户 ID"</span>) }

<span class="hljs-keyword">var</span> errorShown = <span class="hljs-literal">false</span>
<span class="hljs-keyword">val</span> result: String? = <span class="hljs-literal">null</span>
result.ifNull { errorShown = <span class="hljs-literal">true</span> }

<span class="hljs-keyword">val</span> user: User? = getUser()
user.ifNotNull { println(<span class="hljs-string">"找到用户: <span class="hljs-subst">${it.name}</span>"</span>) }
</code></pre>
<h4 data-id="heading-6">集合空安全扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>?.<span class="hljs-title">orEmpty</span><span class="hljs-params">()</span></span>: List&lt;T&gt; = <span class="hljs-keyword">this</span> ?: emptyList()

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;K, V&gt;</span> Map<span class="hljs-type">&lt;K, V&gt;</span>?.<span class="hljs-title">orEmpty</span><span class="hljs-params">()</span></span>: Map&lt;K, V&gt; = <span class="hljs-keyword">this</span> ?: emptyMap()

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>?.<span class="hljs-title">isNullOrEmpty</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span> || isEmpty()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>?.<span class="hljs-title">isNotNullOrEmpty</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> !isNullOrEmpty()
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> items: List&lt;String&gt;? = <span class="hljs-literal">null</span>
items.orEmpty().forEach { println(it) } <span class="hljs-comment">// 安全遍历</span>

<span class="hljs-keyword">val</span> map: Map&lt;String, <span class="hljs-built_in">Int</span>&gt;? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> count = map.orEmpty().size <span class="hljs-comment">// 结果: 0</span>

<span class="hljs-keyword">if</span> (items.isNotNullOrEmpty()) {
    <span class="hljs-comment">// 处理 items</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-7">模式 3：集合扩展 (Collection Extensions)</h3>
<p><strong>问题：</strong> 常见的集合操作往往需要编写冗长的代码。</p>
<h4 data-id="heading-8">实用集合扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">second</span><span class="hljs-params">()</span></span>: T {
    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">throw</span> NoSuchElementException(<span class="hljs-string">"列表元素不足 2 个"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-number">1</span>]
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">secondOrNull</span><span class="hljs-params">()</span></span>: T? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">this</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">takeIfNotEmpty</span><span class="hljs-params">()</span></span>: List&lt;T&gt;? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (isNotEmpty()) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">split</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: Pair&lt;List&lt;T&gt;, List&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> partition(predicate)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">sumByLong</span><span class="hljs-params">(selector: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Long</span> {
    <span class="hljs-keyword">return</span> fold(<span class="hljs-number">0L</span>) { sum, element -&gt; sum + selector(element) }
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> numbers = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
<span class="hljs-keyword">val</span> secondNum = numbers.secondOrNull() <span class="hljs-comment">// 结果: 2</span>

<span class="hljs-keyword">val</span> empty = emptyList&lt;String&gt;()
empty.takeIfNotEmpty() <span class="hljs-comment">// 结果: null</span>

<span class="hljs-keyword">val</span> (evens, odds) = numbers.split { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }
<span class="hljs-comment">// evens = [2, 4], odds = [1, 3, 5]</span>

<span class="hljs-keyword">val</span> files = listOf(
    File(<span class="hljs-string">"file1.txt"</span>, <span class="hljs-number">100L</span>),
    File(<span class="hljs-string">"file2.txt"</span>, <span class="hljs-number">200L</span>)
)
<span class="hljs-keyword">val</span> totalSize = files.sumByLong { it.size } <span class="hljs-comment">// 结果: 300L</span>
</code></pre>
<h4 data-id="heading-9">高级集合操作</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">replaceAll</span><span class="hljs-params">(oldValue: <span class="hljs-type">T</span>, newValue: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> map { <span class="hljs-keyword">if</span> (it == oldValue) newValue <span class="hljs-keyword">else</span> it }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">chunkedBy</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: List&lt;List&lt;T&gt;&gt; {
    <span class="hljs-keyword">val</span> result = mutableListOf&lt;List&lt;T&gt;&gt;()
    <span class="hljs-keyword">var</span> currentChunk = mutableListOf&lt;T&gt;()
    
    forEach { item -&gt;
        <span class="hljs-keyword">if</span> (predicate(item) &amp;&amp; currentChunk.isNotEmpty()) {
            result.add(currentChunk)
            currentChunk = mutableListOf()
        }
        currentChunk.add(item)
    }
    
    <span class="hljs-keyword">if</span> (currentChunk.isNotEmpty()) {
        result.add(currentChunk)
    }
    
    <span class="hljs-keyword">return</span> result
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">duplicates</span><span class="hljs-params">()</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> groupingBy { it }
        .eachCount()
        .filter { it.value &gt; <span class="hljs-number">1</span> }
        .keys
        .toList()
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> items = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)
<span class="hljs-keyword">val</span> dups = items.duplicates() <span class="hljs-comment">// 结果: [1, 2]</span>

<span class="hljs-keyword">val</span> words = listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"kotlin"</span>)
<span class="hljs-keyword">val</span> unique = words.replaceAll(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"hi"</span>) <span class="hljs-comment">// 结果: ["hi", "world", "hi", "kotlin"]</span>
</code></pre>
<hr/>
<h3 data-id="heading-10">模式 4：Context 扩展 (Context Extensions)</h3>
<p><strong>问题：</strong> Android 中重复繁琐的 Context 相关操作。</p>
<h4 data-id="heading-11">Context 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">toast</span><span class="hljs-params">(message: <span class="hljs-type">String</span>, duration: <span class="hljs-type">Int</span> = Toast.LENGTH_SHORT)</span></span> {
    Toast.makeText(<span class="hljs-keyword">this</span>, message, duration).show()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">showAlertDialog</span><span class="hljs-params">(
    title: <span class="hljs-type">String</span>,
    message: <span class="hljs-type">String</span>,
    positiveButton: <span class="hljs-type">String</span> = <span class="hljs-string">"确定"</span>,
    onPositive: () -&gt; <span class="hljs-type">Unit</span> = {}
)</span></span> {
    AlertDialog.Builder(<span class="hljs-keyword">this</span>)
        .setTitle(title)
        .setMessage(message)
        .setPositiveButton(positiveButton) { _, _ -&gt; onPositive() }
        .show()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">hideKeyboard</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> {
    <span class="hljs-keyword">val</span> imm = getSystemService(Context.INPUT_METHOD_SERVICE) <span class="hljs-keyword">as</span> InputMethodManager
    imm.hideSoftInputFromWindow(view.windowToken, <span class="hljs-number">0</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">showKeyboard</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> {
    view.requestFocus()
    <span class="hljs-keyword">val</span> imm = getSystemService(Context.INPUT_METHOD_SERVICE) <span class="hljs-keyword">as</span> InputMethodManager
    imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">isNetworkAvailable</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) <span class="hljs-keyword">as</span> ConnectivityManager
    <span class="hljs-keyword">val</span> activeNetwork = connectivityManager.activeNetworkInfo
    <span class="hljs-keyword">return</span> activeNetwork?.isConnected == <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// 在 Activity/Fragment 中的用法示例</span>
toast(<span class="hljs-string">"操作成功"</span>)

showAlertDialog(
    title = <span class="hljs-string">"确认"</span>,
    message = <span class="hljs-string">"删除该项目？"</span>,
    positiveButton = <span class="hljs-string">"删除"</span>
) {
    deleteItem()
}

<span class="hljs-keyword">if</span> (isNetworkAvailable()) {
    loadData()
} <span class="hljs-keyword">else</span> {
    toast(<span class="hljs-string">"无网络连接"</span>)
}

hideKeyboard(editText)
</code></pre>
<hr/>
<h3 data-id="heading-12">模式 5：日期与时间扩展 (Date and Time Extensions)</h3>
<p><strong>问题：</strong> 复杂的日期格式化与时间计算逻辑。</p>
<h4 data-id="heading-13">日期扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">formatTo</span><span class="hljs-params">(pattern: <span class="hljs-type">String</span> = <span class="hljs-string">"yyyy-MM-dd"</span>)</span></span>: String {
    <span class="hljs-keyword">val</span> formatter = SimpleDateFormat(pattern, Locale.getDefault())
    <span class="hljs-keyword">return</span> formatter.format(<span class="hljs-keyword">this</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">toCalendar</span><span class="hljs-params">()</span></span>: Calendar {
    <span class="hljs-keyword">return</span> Calendar.getInstance().apply {
        time = <span class="hljs-keyword">this</span><span class="hljs-symbol">@toCalendar</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">addDays</span><span class="hljs-params">(days: <span class="hljs-type">Int</span>)</span></span>: Date {
    <span class="hljs-keyword">return</span> toCalendar().apply {
        add(Calendar.DAY_OF_MONTH, days)
    }.time
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">addHours</span><span class="hljs-params">(hours: <span class="hljs-type">Int</span>)</span></span>: Date {
    <span class="hljs-keyword">return</span> toCalendar().apply {
        add(Calendar.HOUR_OF_DAY, hours)
    }.time
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">isToday</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> today = Calendar.getInstance()
    <span class="hljs-keyword">val</span> dateCalendar = toCalendar()
    <span class="hljs-keyword">return</span> today.<span class="hljs-keyword">get</span>(Calendar.YEAR) == dateCalendar.<span class="hljs-keyword">get</span>(Calendar.YEAR) &amp;&amp;
           today.<span class="hljs-keyword">get</span>(Calendar.DAY_OF_YEAR) == dateCalendar.<span class="hljs-keyword">get</span>(Calendar.DAY_OF_YEAR)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">isFuture</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> time &gt; System.currentTimeMillis()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">isPast</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> time &lt; System.currentTimeMillis()
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> now = Date()
<span class="hljs-keyword">val</span> formatted = now.formatTo(<span class="hljs-string">"MMM dd, yyyy"</span>) <span class="hljs-comment">// 结果: "Jan 08, 2026"</span>

<span class="hljs-keyword">val</span> tomorrow = now.addDays(<span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> inThreeHours = now.addHours(<span class="hljs-number">3</span>)

<span class="hljs-keyword">if</span> (deadline.isFuture()) {
    println(<span class="hljs-string">"还有时间！"</span>)
}
</code></pre>
<h4 data-id="heading-14">现代日期 API 扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDateTime.<span class="hljs-title">formatTo</span><span class="hljs-params">(pattern: <span class="hljs-type">String</span> = <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> format(DateTimeFormatter.ofPattern(pattern))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDate.<span class="hljs-title">isWeekend</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDate.<span class="hljs-title">isWeekday</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> !isWeekend()
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDateTime.<span class="hljs-title">toEpochMillis</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Long</span> {
    <span class="hljs-keyword">return</span> atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Long</span>.<span class="hljs-title">toLocalDateTime</span><span class="hljs-params">()</span></span>: LocalDateTime {
    <span class="hljs-keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(<span class="hljs-keyword">this</span>), ZoneId.systemDefault())
}
<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">val</span> now = LocalDateTime.now()
<span class="hljs-keyword">val</span> display = now.formatTo(<span class="hljs-string">"MMM dd, yyyy HH:mm"</span>) <span class="hljs-comment">// "Jan 08, 2026 15:30"</span>
<span class="hljs-keyword">val</span> date = LocalDate.now()
<span class="hljs-keyword">if</span> (date.isWeekend()) {
    println(<span class="hljs-string">"It's the weekend!"</span>)
}
<span class="hljs-keyword">val</span> timestamp = System.currentTimeMillis()
<span class="hljs-keyword">val</span> dateTime = timestamp.toLocalDateTime()
</code></pre>
<hr/>
<h3 data-id="heading-15">模式 6：视图扩展 (View Extensions)</h3>
<p><strong>问题：</strong> 重复的 View 操作代码。</p>
<h4 data-id="heading-16">视图显示状态扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">visible</span><span class="hljs-params">()</span></span> {
    visibility = View.VISIBLE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">invisible</span><span class="hljs-params">()</span></span> {
    visibility = View.INVISIBLE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">gone</span><span class="hljs-params">()</span></span> {
    visibility = View.GONE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">toggleVisibility</span><span class="hljs-params">()</span></span> {
    visibility = <span class="hljs-keyword">if</span> (visibility == View.VISIBLE) View.GONE <span class="hljs-keyword">else</span> View.VISIBLE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">isVisible</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = visibility == View.VISIBLE

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">isGone</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = visibility == View.GONE

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">visibleIf</span><span class="hljs-params">(condition: <span class="hljs-type">Boolean</span>)</span></span> {
    visibility = <span class="hljs-keyword">if</span> (condition) View.VISIBLE <span class="hljs-keyword">else</span> View.GONE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">goneIf</span><span class="hljs-params">(condition: <span class="hljs-type">Boolean</span>)</span></span> {
    visibility = <span class="hljs-keyword">if</span> (condition) View.GONE <span class="hljs-keyword">else</span> View.VISIBLE
}

<span class="hljs-comment">// 用法示例</span>
loadingSpinner.visible()
errorMessage.gone()
submitButton.visibleIf(form.isValid())
errorView.goneIf(<span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>)
</code></pre>
<h4 data-id="heading-17">视图交互扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">onClick</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    setOnClickListener { action() }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">onLongClick</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Boolean</span>)</span></span> {
    setOnLongClickListener { action() }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">setMargin</span><span class="hljs-params">(left: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, top: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, right: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, bottom: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>)</span></span> {
    <span class="hljs-keyword">val</span> params = layoutParams <span class="hljs-keyword">as</span>? ViewGroup.MarginLayoutParams
    params?.setMargins(left, top, right, bottom)
    layoutParams = params
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">setPadding</span><span class="hljs-params">(padding: <span class="hljs-type">Int</span>)</span></span> {
    setPadding(padding, padding, padding, padding)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">updatePadding</span><span class="hljs-params">(
    left: <span class="hljs-type">Int</span> = paddingLeft,
    top: <span class="hljs-type">Int</span> = paddingTop,
    right: <span class="hljs-type">Int</span> = paddingRight,
    bottom: <span class="hljs-type">Int</span> = paddingBottom
)</span></span> {
    setPadding(left, top, right, bottom)
}

<span class="hljs-comment">// 用法示例</span>
button.onClick {
    performAction()
}

imageView.onLongClick {
    showContextMenu()
    <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// 仅设置左右边距，无需关心其他方向</span>
view.setMargin(left = <span class="hljs-number">16</span>, right = <span class="hljs-number">16</span>)

<span class="hljs-comment">// 一键设置全方向内边距</span>
view.setPadding(<span class="hljs-number">24</span>)
</code></pre>
<hr/>
<h3 data-id="heading-18">模式 7：资源访问扩展 (Resource Extensions)</h3>
<p><strong>问题：</strong> 资源访问代码过于冗长。</p>
<h4 data-id="heading-19">资源访问扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">drawable</span><span class="hljs-params">(<span class="hljs-meta">@DrawableRes</span> id: <span class="hljs-type">Int</span>)</span></span>: Drawable? {
    <span class="hljs-keyword">return</span> ContextCompat.getDrawable(<span class="hljs-keyword">this</span>, id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-meta">@ColorRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> ContextCompat.getColor(<span class="hljs-keyword">this</span>, id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">string</span><span class="hljs-params">(<span class="hljs-meta">@StringRes</span> id: <span class="hljs-type">Int</span>, <span class="hljs-keyword">vararg</span> args: <span class="hljs-type">Any</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> getString(id, *args)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">dimension</span><span class="hljs-params">(<span class="hljs-meta">@DimenRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">return</span> resources.getDimension(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">dimensionPixelSize</span><span class="hljs-params">(<span class="hljs-meta">@DimenRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> resources.getDimensionPixelSize(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">drawable</span><span class="hljs-params">(<span class="hljs-meta">@DrawableRes</span> id: <span class="hljs-type">Int</span>)</span></span>: Drawable? {
    <span class="hljs-keyword">return</span> context.drawable(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-meta">@ColorRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> context.color(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">string</span><span class="hljs-params">(<span class="hljs-meta">@StringRes</span> id: <span class="hljs-type">Int</span>, <span class="hljs-keyword">vararg</span> args: <span class="hljs-type">Any</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> context.string(id, *args)
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> icon = drawable(R.drawable.ic_star)
<span class="hljs-keyword">val</span> primaryColor = color(R.color.primary)
<span class="hljs-keyword">val</span> message = string(R.string.welcome_message, userName)
<span class="hljs-keyword">val</span> spacing = dimensionPixelSize(R.dimen.spacing_medium)

<span class="hljs-comment">// 在 View 中使用</span>
imageView.setImageDrawable(drawable(R.drawable.ic_profile))
textView.setTextColor(color(R.color.text_primary))
</code></pre>
<hr/>
<h3 data-id="heading-20">模式 8：数值扩展 (Number Extensions)</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">formatWithCommas</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"%,d"</span>, <span class="hljs-keyword">this</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Double</span>.<span class="hljs-title">formatAsPrice</span><span class="hljs-params">(currencySymbol: <span class="hljs-type">String</span> = <span class="hljs-string">"$"</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-variable">$currencySymbol</span>%.2f"</span>.format(<span class="hljs-keyword">this</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Float</span>.<span class="hljs-title">roundTo</span><span class="hljs-params">(decimals: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">val</span> multiplier = <span class="hljs-number">10.0</span>.pow(decimals)
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> * multiplier).roundToInt() / multiplier.toFloat()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">toBoolean</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">this</span> != <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Boolean</span>.<span class="hljs-title">toInt</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">isEven</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">this</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">isOdd</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = !isEven()

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> number = <span class="hljs-number">1234567</span>
<span class="hljs-keyword">val</span> formatted = number.formatWithCommas() <span class="hljs-comment">// 结果: "1,234,567"</span>

<span class="hljs-keyword">val</span> price = <span class="hljs-number">49.99</span>
<span class="hljs-keyword">val</span> display = price.formatAsPrice() <span class="hljs-comment">// 结果: "$49.99"</span>

<span class="hljs-keyword">val</span> value = <span class="hljs-number">3.14159f</span>
<span class="hljs-keyword">val</span> rounded = value.roundTo(<span class="hljs-number">2</span>) <span class="hljs-comment">// 结果: 3.14f</span>

<span class="hljs-keyword">val</span> flag = <span class="hljs-number">1</span>
<span class="hljs-keyword">if</span> (flag.toBoolean()) {
    <span class="hljs-comment">// 执行逻辑</span>
}
</code></pre>
<h4 data-id="heading-21">范围与边界扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">clamp</span><span class="hljs-params">(min: <span class="hljs-type">Int</span>, max: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        <span class="hljs-keyword">this</span> &lt; min -&gt; min
        <span class="hljs-keyword">this</span> &gt; max -&gt; max
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">this</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Float</span>.<span class="hljs-title">clamp</span><span class="hljs-params">(min: <span class="hljs-type">Float</span>, max: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        <span class="hljs-keyword">this</span> &lt; min -&gt; min
        <span class="hljs-keyword">this</span> &gt; max -&gt; max
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">this</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">inRange</span><span class="hljs-params">(range: <span class="hljs-type">IntRange</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">in</span> range
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">toPercentage</span><span class="hljs-params">(total: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (total == <span class="hljs-number">0</span>) <span class="hljs-number">0f</span> <span class="hljs-keyword">else</span> (<span class="hljs-keyword">this</span>.toFloat() / total) * <span class="hljs-number">100</span>
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> value = <span class="hljs-number">150</span>
<span class="hljs-keyword">val</span> clamped = value.clamp(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// 结果: 100</span>

<span class="hljs-keyword">val</span> progress = <span class="hljs-number">75</span>
<span class="hljs-keyword">if</span> (progress.inRange(<span class="hljs-number">50.</span><span class="hljs-number">.100</span>)) {
    println(<span class="hljs-string">"进度过半"</span>)
}

<span class="hljs-keyword">val</span> completed = <span class="hljs-number">30</span>
<span class="hljs-keyword">val</span> total = <span class="hljs-number">100</span>
<span class="hljs-keyword">val</span> percentage = completed.toPercentage(total) <span class="hljs-comment">// 结果: 30.0</span>
</code></pre>
<hr/>
<h3 data-id="heading-22">模式 9：Flow 与 LiveData 扩展 (Flow and LiveData Extensions)</h3>
<p><strong>问题：</strong> Flow 和 LiveData 的操作过于繁琐。</p>
<h4 data-id="heading-23">Flow 扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">throttleFirst</span><span class="hljs-params">(windowDuration: <span class="hljs-type">Long</span>)</span></span>: Flow&lt;T&gt; = flow {
    <span class="hljs-keyword">var</span> lastEmissionTime = <span class="hljs-number">0L</span>
    collect { value -&gt;
        <span class="hljs-keyword">val</span> currentTime = System.currentTimeMillis()
        <span class="hljs-keyword">if</span> (currentTime - lastEmissionTime &gt;= windowDuration) {
            lastEmissionTime = currentTime
            emit(value)
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;List&lt;T&gt;</span>&gt;.<span class="hljs-title">filterNotEmpty</span><span class="hljs-params">()</span></span>: Flow&lt;List&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> filter { it.isNotEmpty() }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T?&gt;</span>.<span class="hljs-title">filterNotNull</span><span class="hljs-params">()</span></span>: Flow&lt;T&gt; {
    <span class="hljs-keyword">return</span> mapNotNull { it }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">onEachDebounce</span><span class="hljs-params">(timeoutMillis: <span class="hljs-type">Long</span>, action: <span class="hljs-type">suspend</span> (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: Flow&lt;T&gt; {
    <span class="hljs-keyword">return</span> debounce(timeoutMillis).onEach { action(it) }
}

<span class="hljs-comment">// 用法示例</span>
searchQueryFlow
    .debounce(<span class="hljs-number">300</span>) <span class="hljs-comment">// 防抖</span>
    .filterNotNull()
    .collect { query -&gt;
        performSearch(query)
    }

clickFlow
    .throttleFirst(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 节流，防止连续点击</span>
    .collect {
        handleClick()
    }

itemsFlow
    .filterNotEmpty()
    .collect { items -&gt;
        displayItems(items)
    }
</code></pre>
<h4 data-id="heading-24">LiveData 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> LiveData<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">observeOnce</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>, observer: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    observe(owner, <span class="hljs-keyword">object</span> : Observer&lt;T&gt; {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> {
            observer(value)
            removeObserver(<span class="hljs-keyword">this</span>)
        }
    })
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> LiveData<span class="hljs-type">&lt;T?&gt;</span>.<span class="hljs-title">filterNotNull</span><span class="hljs-params">()</span></span>: LiveData&lt;T&gt; {
    <span class="hljs-keyword">return</span> map { it }.filter { it != <span class="hljs-literal">null</span> } <span class="hljs-keyword">as</span> LiveData&lt;T&gt;
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(transform: (<span class="hljs-type">X</span>) -&gt; <span class="hljs-type">Y</span>)</span></span>: LiveData&lt;Y&gt; {
    <span class="hljs-keyword">return</span> Transformations.map(<span class="hljs-keyword">this</span>, transform)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">switchMap</span><span class="hljs-params">(transform: (<span class="hljs-type">X</span>) -&gt; <span class="hljs-type">LiveData</span>&lt;<span class="hljs-type">Y</span>&gt;)</span></span>: LiveData&lt;Y&gt; {
    <span class="hljs-keyword">return</span> Transformations.switchMap(<span class="hljs-keyword">this</span>, transform)
}

<span class="hljs-comment">// 用法示例</span>
userLiveData.observeOnce(viewLifecycleOwner) { user -&gt;
    initializeUser(user) <span class="hljs-comment">// 仅观察一次</span>
}

<span class="hljs-keyword">val</span> userNameLiveData = userLiveData
    .filterNotNull()
    .map { it.name }
</code></pre>
<hr/>
<h3 data-id="heading-25">模式 10：Intent 与 Bundle 扩展 (Intent and Bundle Extensions)</h3>
<p><strong>问题：</strong> Intent 的创建和 Bundle 的操作代码过于繁琐。</p>
<h4 data-id="heading-26">Intent 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Activity&gt;</span> Context.<span class="hljs-title">startActivity</span><span class="hljs-params">(
    options: <span class="hljs-type">Bundle</span>? = <span class="hljs-literal">null</span>,
    <span class="hljs-keyword">init</span>: <span class="hljs-type">Intent</span>.() -&gt; <span class="hljs-type">Unit</span> = {}
)</span></span> {
    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, T::<span class="hljs-keyword">class</span>.java)
    intent.<span class="hljs-keyword">init</span>()
    startActivity(intent, options)
}

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Activity&gt;</span> Context.<span class="hljs-title">startActivityWithExtras</span><span class="hljs-params">(
    <span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any?&gt;
)</span></span> {
    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, T::<span class="hljs-keyword">class</span>.java)
    params.forEach { (key, value) -&gt;
        <span class="hljs-keyword">when</span> (value) {
            <span class="hljs-keyword">is</span> String -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Boolean</span> -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> Parcelable -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> Serializable -&gt; intent.putExtra(key, value)
        }
    }
    startActivity(intent)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Intent.<span class="hljs-title">clearStack</span><span class="hljs-params">()</span></span> {
    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
}

<span class="hljs-comment">// 用法示例</span>
startActivity&lt;ProfileActivity&gt; {
    putExtra(<span class="hljs-string">"userId"</span>, userId)
    putExtra(<span class="hljs-string">"userName"</span>, userName)
}

startActivityWithExtras&lt;DetailActivity&gt;(
    <span class="hljs-string">"itemId"</span> to itemId,
    <span class="hljs-string">"showComments"</span> to <span class="hljs-literal">true</span>
)

<span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MainActivity::<span class="hljs-keyword">class</span>.java)
intent.clearStack()
startActivity(intent)
</code></pre>
<h4 data-id="heading-27">Bundle 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Parcelable&gt;</span> Bundle.<span class="hljs-title">getParcelableCompat</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: T? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {
        getParcelable(key, T::<span class="hljs-keyword">class</span>.java)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-meta">@Suppress(<span class="hljs-string">"DEPRECATION"</span>)</span>
        getParcelable(key)
    }
}

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Serializable&gt;</span> Bundle.<span class="hljs-title">getSerializableCompat</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: T? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {
        getSerializable(key, T::<span class="hljs-keyword">class</span>.java)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-meta">@Suppress(<span class="hljs-string">"DEPRECATION"</span>)</span>
        getSerializable(key) <span class="hljs-keyword">as</span>? T
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bundleOf</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> pairs: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any?&gt;)</span></span>: Bundle {
    <span class="hljs-keyword">return</span> Bundle().apply {
        pairs.forEach { (key, value) -&gt;
            <span class="hljs-keyword">when</span> (value) {
                <span class="hljs-keyword">is</span> String -&gt; putString(key, value)
                <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; putInt(key, value)
                <span class="hljs-keyword">is</span> <span class="hljs-built_in">Boolean</span> -&gt; putBoolean(key, value)
                <span class="hljs-keyword">is</span> Parcelable -&gt; putParcelable(key, value)
                <span class="hljs-keyword">is</span> Serializable -&gt; putSerializable(key, value)
            }
        }
    }
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> bundle = bundleOf(
    <span class="hljs-string">"userId"</span> to <span class="hljs-number">123</span>,
    <span class="hljs-string">"userName"</span> to <span class="hljs-string">"John"</span>,
    <span class="hljs-string">"isPremium"</span> to <span class="hljs-literal">true</span>
)

<span class="hljs-keyword">val</span> user: User? = arguments?.getParcelableCompat(<span class="hljs-string">"user"</span>)
<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: MyData? = savedInstanceState?.getSerializableCompat(<span class="hljs-string">"data"</span>)
</code></pre>
<hr/>
<p>扩展函数将重复的代码转化为简洁且具表现力的 API。从这十种模式开始尝试，你将见证你的代码库变得更加易于维护。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Agent开发应知应会(Langfuse)：Langfuse Session概念详解和实战应用]]></title>    <link>https://juejin.cn/post/7605807405307625535</link>    <guid>https://juejin.cn/post/7605807405307625535</guid>    <pubDate>2026-02-13T03:27:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605807405307625535" data-draft-id="7605941424535978038" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Agent开发应知应会(Langfuse)：Langfuse Session概念详解和实战应用"/> <meta itemprop="keywords" content="人工智能,Python,LLM"/> <meta itemprop="datePublished" content="2026-02-13T03:27:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="zaizaizhao"/> <meta itemprop="url" content="https://juejin.cn/user/906425682113933"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Agent开发应知应会(Langfuse)：Langfuse Session概念详解和实战应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/906425682113933/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    zaizaizhao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:27:22.000Z" title="Fri Feb 13 2026 03:27:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>最近在做一个 Text-to-SQL 的 Agent 项目 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzaizaizhao%2Feasysql" target="_blank" title="https://github.com/zaizaizhao/easysql" ref="nofollow noopener noreferrer">EasySQL</a>，这篇文章就把我langfuse的session使用整理一下，代码都是从项目里直接搬的，欢迎大佬们高抬贵手点点star，共建、交流。</p>
</blockquote>
<h3 data-id="heading-0">Langfuse官方文档的原文定义</h3>
<blockquote>
<p>Many interactions with LLM applications span multiple traces and observations. Sessions in Langfuse are a special way to group these observations across traces together and see a simple session replay of the entire interaction.
Optionally, traces can be grouped into sessions. Sessions are used to group traces that are part of the same user interaction. A common example is a thread in a chat interface.</p>
</blockquote>
<p>翻译一下：一次用户与 LLM 应用的交互往往不只一个请求。比如用户在聊天界面中连续问了 3 个问题，每个问题是一个独立的 Trace（一次完整的 LLM调用链路），但它们属于同一次会话。Session 就是把这些相关的 Trace 归到一组。</p>
<h5 data-id="heading-1">Session</h5>





















<table><thead><tr><th>session_id 格式</th><th>任意 US-ASCII 字符串，小于 200 字符</th></tr></thead><tbody><tr><td>归组逻辑</td><td>所有携带相同 session_id 的 Trace 自动归入同一个 Session</td></tr><tr><td>创建时机</td><td>无需显式创建 Session 对象，第一个携带该 session_id 的 Trace 出现时自动创建</td></tr><tr><td>Trace 的关系</td><td>一个 Session 包含多个 Trace，一个 Trace 只属于一个 Session</td></tr></tbody></table>
<h3 data-id="heading-2">项目举例</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55cf9fda7f0e4c008d4e55c9059cbbba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=%2FxdHKHN1MMoZ5hOExF9FK8UQwCw%3D" alt="image.png" loading="lazy"/></p>
<p>没有Session时：这两个Trace（一个会话中的两个问答） 在Langfuse Dashboard中是散落的，你不知道它们之间有关联。有Session时：点进某个Session，能看到完整的多次对话回放——用户从第1个问题到第3个问题的完整链路。</p>
<h5 data-id="heading-3">无session的情况下，所有的trace都集中展示无法筛选</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca5242ec11bb449285ce93e36d0543f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=uT22W6CeJDMHnJDVYAu5P%2FlAXJM%3D" alt="image.png" loading="lazy"/></p>
<p>有session的情况，可以根据session展示，我这里就可以通过同个session来观察第二个问题有没有取得第一个问题的历史对话上下文，由此来判断代码中的处理是否合理</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c964b022d921418ca5729b12c8fbbb9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=kGqmnZzZvjsOHWVthFLpIg5RaiY%3D" alt="image.png" loading="lazy"/></p>
<p>也可以在Dashboards中筛选</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea47731103534a73ad8db86c288ad898~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=SfbNp6%2B4JCaWmxXav2h6kH060mk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-4">代码实现</h4>
<p>核心代码在 query_service.py。也就是创建一个会话session id的地方，由于项目中已经设置了session id来区分不同的会话，所以这里可以直接复用，保证langfuse中的session id和数据库中的会话session id一致。这样做的好处是：当在 Langfuse Dashboard 中看到某个Session 有问题时，可以直接用这个 ID 去业务数据库中查对应的会话记录，两边的 ID 是一致的。（这也是我认为最重要的一点）</p>
<pre><code class="hljs language-python" lang="python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_config</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span>, thread_id: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span></span>) -&gt; RunnableConfig:
      effective_thread_id = thread_id <span class="hljs-keyword">or</span> session_id
      config: RunnableConfig = {<span class="hljs-string">"configurable"</span>: {<span class="hljs-string">"thread_id"</span>: effective_thread_id}}
      <span class="hljs-keyword">if</span> self.callbacks:
          config[<span class="hljs-string">"callbacks"</span>] = self.callbacks
          config[<span class="hljs-string">"metadata"</span>] = {                          <span class="hljs-comment"># ← 关键</span>
              <span class="hljs-string">"langfuse_session_id"</span>: session_id,          <span class="hljs-comment"># ← Session 隔离</span>
              <span class="hljs-string">"langfuse_tags"</span>: [<span class="hljs-string">"text2sql"</span>],              <span class="hljs-comment"># ← 标签</span>
          }
          logger.debug(<span class="hljs-string">f"LangFuse callbacks attached: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(self.callbacks)}</span> handler(s)"</span>)
      <span class="hljs-keyword">return</span> config
</code></pre>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> self.graph.astream(
        input_state,
        self._make_config(session.session_id, effective_thread_id),
        stream_mode=[<span class="hljs-string">"updates"</span>, <span class="hljs-string">"custom"</span>],
    ):
</code></pre>
<p>工作原理</p>
<p>这里用的是 Langfuse 官方推荐的 metadata 传参方式。官方文档原文：</p>
<blockquote>
<p>With the Python SDK, you can set trace attributes dynamically via metadata fields in chain invocation by passing a config dictionary.This is the simplest approach for adding trace context to your LangChain executions without additional setup.</p>
</blockquote>
<p>官方示例：</p>
<pre><code class="hljs language-python" lang="python"> response = chain.invoke(
      {<span class="hljs-string">"topic"</span>: <span class="hljs-string">"cats"</span>},
      config={
          <span class="hljs-string">"callbacks"</span>: [langfuse_handler],
          <span class="hljs-string">"metadata"</span>: {
              <span class="hljs-string">"langfuse_user_id"</span>: <span class="hljs-string">"random-user"</span>,
              <span class="hljs-string">"langfuse_session_id"</span>: <span class="hljs-string">"random-session"</span>,     
              <span class="hljs-string">"langfuse_tags"</span>: [<span class="hljs-string">"random-tag-1"</span>, <span class="hljs-string">"random-tag-2"</span>] 
          }
      }
  )
</code></pre>
<h3 data-id="heading-5">Session带来的监控意义</h3>
<h5 data-id="heading-6">Session 级别的聚合分析</h5>

























<table><thead><tr><th>每个 Session 的 Trace 数量</th><th>用户平均问几轮才完成任务</th><th>** 轮次多 = 可能需要优化追问体验**</th></tr></thead><tbody><tr><td>每个 Session 的 总 Token</td><td>一次完整交互的总消耗</td><td>评估单次用户交互的成本</td></tr><tr><td>每个 Session 的 总延迟</td><td>用户完成任务的总等待时间</td><td>评估端到端的用户体验</td></tr><tr><td>每个 Session 的 失败 Trace 比例</td><td>多轮中有几轮出错</td><td>定位哪些类型的追问容易失败</td></tr></tbody></table>
<h5 data-id="heading-7">对比没有session</h5>






























<table><thead><tr><th>场景</th><th>没有 Session</th><th>有 Session</th></tr></thead><tbody><tr><td>查看某用户的完整交互</td><td>需要自己按时间排序、手动关联</td><td>直接点进 Session 看回放</td></tr><tr><td>统计"用户平均几轮完成任务"</td><td>无法统计</td><td>Dashboard 直接提供</td></tr><tr><td>分析"追问时 SQL 质量是否下降"</td><td>需要导出数据写脚本</td><td>按 Session 内的 Trace 顺序直接对比</td></tr><tr><td>定位"用户反馈体验差"的问题</td><td>只能逐条 Trace 查看</td><td>拿到 session_id 直接看全过程</td></tr></tbody></table>
<h3 data-id="heading-8">总结</h3>
<p>session是一个很小的知识点，但是使用的好对我们整个agent开发带来的增益是巨大。</p>
<p>以上所有代码示例均来自我的开源项目 <strong>EasySQL</strong> —— 一个 Text-to-SQL 智能体分析应用，项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzaizaizhao%2Feasysql" target="_blank" title="https://github.com/zaizaizhao/easysql" ref="nofollow noopener noreferrer">github.com/zaizaizhao/…</a>。项目主要技术栈包括：</p>
<ul>
<li><strong>LangGraph</strong>：构建多步骤 Agent 状态机，支持条件路由、Human-in-the-Loop 澄清、SQL 生成→验证→修复的迭代循环</li>
<li><strong>LangChain</strong>：LLM 调用抽象与 RunnableConfig 配置传递</li>
<li><strong>Langfuse</strong>：Callback + 手动 Span 双模式可观测性，实现全链路追踪与业务汇总</li>
<li><strong>PostgreSQL + AsyncPostgresSaver</strong>：LangGraph Checkpointer 状态持久化，支持多轮对话上下文</li>
<li><strong>FastAPI + Uvicorn</strong>：异步 API 服务层，提供流式 SSE 响应</li>
<li><strong>Milvus</strong>：向量数据库，用于 Schema 语义检索</li>
<li><strong>Neo4j</strong>： 图数据库，用于知识图谱构建</li>
<li><strong>Pydantic Settings</strong>：类型安全的配置管理，支持环境变量覆盖</li>
</ul>
<p>项目示例</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64a13c7452a6489eb1a98457a9893b16~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=Isad%2BABbvqYPIB2dxqX9EfW03uo%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d40fae962104a7b83d9a475b45348d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=1IE3mWfiDse08V2zs2U0jjj8Oz0%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d89d860902c4a998c9793028a46a62b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=zYVTbT1aAn2LWsXZsyp6egZu3L4%3D" alt="image.png" loading="lazy"/></p>
<p>欢迎 Star ⭐ 和交流、共建！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[KIE Drools 10.x 规则引擎快速入门]]></title>    <link>https://juejin.cn/post/7605811866908753929</link>    <guid>https://juejin.cn/post/7605811866908753929</guid>    <pubDate>2026-02-13T03:47:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908753929" data-draft-id="7605769126272188462" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="KIE Drools 10.x 规则引擎快速入门"/> <meta itemprop="keywords" content="Java,后端"/> <meta itemprop="datePublished" content="2026-02-13T03:47:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java小卷"/> <meta itemprop="url" content="https://juejin.cn/user/1614502546384749"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            KIE Drools 10.x 规则引擎快速入门
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1614502546384749/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java小卷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:47:17.000Z" title="Fri Feb 13 2026 03:47:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h3 data-id="heading-0">前言</h3>
<p>自Drools加入Apache KIE组织下的项目后，其版本研发向着API标准化、生态更完善的方向不断迭代迈进。从原先Drools团队维护的8.44.x版本过渡到Apache KIE自动化智能决策项目集合大家庭产品的研发条线上来，在项目微服务化、部署云原生化的今天，再结合AI项目赋能的大背景，可以说Drools的学习与应用将迎来新的热潮。鉴于国内这方面的书籍、博客等教程依然停留在老版本，也因老版本的限制，生产实践得不够全面、彻底，本人开设了该技术专栏，与广大技术员一起学习探讨新版Drools的全面实践议题，通过分享从0-1的实践步骤与学习感悟，一起撑起国人使用Drools技术提高IT企业生产力的一片天。一起加油！</p>
<h2 data-id="heading-1">Drools版本说明</h2>
<p>Drools在加入Apache KIE组织之前，文档是由Drools研发团队自己维护的，地址为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.drools.org%2F" target="_blank" title="https://docs.drools.org/" ref="nofollow noopener noreferrer">docs.drools.org/</a>，更新的最后版本为<code>8.44.0.Final</code>。<strong>目前市面上大多教程还是基于drools7的</strong>，而纳入到Apache下的KIE顶级项目后，drools的生态发展变得更全面更完善，文档更规范、API设计也更优雅和健壮，很好的与目前成熟的云原生架构、AI技术体系融合，Drools迎来了脱胎换骨的新发展。相应的Drools文档地址也换了</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83587724703145059485259adb7c6cd2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=Qq2TTr4GEzIRuAwK%2BoqrbtmQH0k%3D" alt="20260210120113.png" loading="lazy"/></p>
<h2 data-id="heading-2">环境准备</h2>
<p>可参考drools官方技术文档的<a href="https://link.juejin.cn?target=https%3A%2F%2Fkie.apache.org%2Fdocs%2F10.1.x%2Fdrools%2Fdrools%2Fgetting-started%2Findex.html%23_prerequisites" target="_blank" title="https://kie.apache.org/docs/10.1.x/drools/drools/getting-started/index.html#_prerequisites" ref="nofollow noopener noreferrer">入门-先决条件</a>小节。<strong>只不过咱们这里的实践不依赖官方指南的命令行操作方式，而是高效的使用idea的集成开发环境来构建应用。</strong></p>
<ul>
<li>jdk17+</li>
<li>Apache Maven3.9.6+</li>
<li>开发工具：idea2025.3.2</li>
<li>规则编辑器：vscode插件（idea插件比较有限）</li>
</ul>
<h3 data-id="heading-3">idea下载安装</h3>
<p>点击<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2Fidea%2Fdownload" target="_blank" title="https://www.jetbrains.com/idea/download" ref="nofollow noopener noreferrer">idea官方下载地址</a>，选择对应操作系统的版本点下载，</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3e61315d94e4c14be2e22d62cf04032~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=%2FxUAB1t7Mti49OmrafsiMRJuFjs%3D" alt="20260209204411.png" loading="lazy"/>
下载的版本：<em>idea-2025.3.2.exe</em>，双击安装，自行设置安装路径，个人设置为：<code>d:\Programs\JetBrains\IntelliJ IDEA 2025.3.2</code>，<em>安装选项</em>界面，勾选创建桌面快捷方式、添加<em>bin</em>目录到<em>path</em>、添加<em>将文件夹打开为项目</em>，执行后续安装。安装成功，点<em>完成</em>前，勾选<em>运行idea</em>。
第一次运行，默认中文环境（如果弹出该界面的话），点不发送数据共享，跳过导入设置（如果弹出该界面的话）</p>
<h3 data-id="heading-4">创建Java项目</h3>
<p>进入idea环境界面，如果界面为英文，这里咱们统一下，点左下角的<em>设置</em>，进入<em>Language and Region</em>设置（可直接搜索定位设置），语言设置为简体中文，点<em>应用</em>设置，重启idea即可。</p>
<p>在欢迎界面点<em>新建项目</em>，左侧项目类型选<em>Java</em>，右侧的设置</p>
<ul>
<li>名称：<em>rule-java-maven</em></li>
<li>位置：<em>E:\code\drools-projects</em></li>
<li>构建系统：<em>Maven</em></li>
<li>JDK
点<em>下载JDK</em>，弹出框中选择你想要下载的jdk版本，个人设置为：</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a321ba4066546c98a3e3501590374fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=GyINhHGs3QM9VokmLIjLT9iR3DE%3D" alt="20260209212651.png" loading="lazy"/></p>
<ul>
<li>取消<em>添加示例代码</em></li>
<li>高级设置
组名可自己定，个人设置为<code>org.zm626</code></li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9e9d50e82ae472da9ff99eef43021b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=8sJVGJYPhRjzpKhg%2Bnezc5PztHw%3D" alt="20260209213028.png" loading="lazy"/></p>
<p>最后点<em>创建</em></p>
<p>项目自动构建成功</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f96e779cfcb494f9d714e7915497cce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=yzhaJNTbrVQEWRiQVXey3d45j34%3D" alt="20260209213556.png" loading="lazy"/></p>
<h4 data-id="heading-5">开启免费使用idea</h4>
<p>在开发主界面右上角点<em>开始免费试用</em>，会打开idea Ultimate版本的订阅页面，点<em>开始免费试用</em>，即可激活各种插件，默认有30天的使用期。对于不想付费的同学，可以在到期前导出idea设置，到期后卸载重装并导入设置，可无限循环使用。</p>
<h4 data-id="heading-6">jdk设置</h4>
<p>安装咱们创建向导所选择的jdk版本，实现了自动下载安装。
点主界面右上角的<em>齿轮图标 | 项目结构 | 项目设置</em>，查看项目使用的jdk，<em>语言级别</em>保持默认的jdk。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d6bccc48f41486bb0eed78ead34ea6c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=BiMjGZdm%2BgLVhxlC8pacLwqd%2BW4%3D" alt="20260209214942.png" loading="lazy"/>
如果需要其他版本的jdk，可在本界面，点<em>平台设置 | SDK</em>，来全局维护jdk版本，并回到<em>项目设置 | 项目 | SDK</em>，选择切换jdk版本。</p>
<h4 data-id="heading-7">maven设置</h4>
<p>打开idea设置，搜索<em>Maven</em>，查看<em>Maven主路径</em>设置，默认为idea捆绑的maven版本，这里可切换为<em>使用Maven包装器</em>，而maven的本地仓库路径和设置默认在用户目录下，保持该设置，</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75002a7b565940099958c5cc1f1a6c58~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=KGoeiRHvzEqkGmfmbZ%2FMpzG0KQc%3D" alt="20260209223347.png" loading="lazy"/>
点<em>确定</em>，回到主界面，会看到右下角的警告：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b5705f3270bb4f3082b31c045fba6ab3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=VacAVwTziEeC7ClaKFvJXcfD89I%3D" alt="20260209220021.png" loading="lazy"/>
在工程的 <em>.mvn</em> 目录下新增目录和文件：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10f09901e33247bcbac434cddad6067c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=7ndmvf%2FthrJ2YC5vJ%2B%2BJQGyfbO0%3D" alt="20260209220142.png" loading="lazy"/>
文件内容如下：</p>
<pre><code class="hljs language-properties" lang="properties">wrapperVersion=3.3.4  
distributionType=only-script  
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.6/apache-maven-3.9.6-bin.zip
</code></pre>
<p>完成编辑后，点右边悬浮的<em>同步Maven更改</em>的小图标，这只是完成Maven配置同步，要重新加载整个maven项目，点Maven工具栏第一个刷新图标，点下拉的第二个选项：<em>重新加载所有的Maven项目</em></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6654158d2ff4cb2a8055be121288e49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=HZ8ee4IOIOcLaTopxVvLE8zH9HE%3D" alt="20260209220900.png" loading="lazy"/>
完成构建后，这种Maven包装器方式会在本地用户路径下自行安装以上配置文件中指定的maven版本，这种wrapper随同工程源码分发的方式，有助于研发团队或者学习小组成员之间协同。看到本地解压的maven软件包：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9698979d00f44904a8082527007b7771~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=g0QiolLG%2FOgETQlKN0WDZB0a7H4%3D" alt="20260210123609.png" loading="lazy"/></p>
<p>可以将其<em>conf</em>目录下的settings.xml配置拷贝出来，放到用户路径的 <em>~/.m2</em> 下，在各个操作系统用户级别维护maven配置。参照<a href="https://link.juejin.cn?target=https%3A%2F%2Fmaven.aliyun.com%2Fmvn%2Fguide" target="_blank" title="https://maven.aliyun.com/mvn/guide" ref="nofollow noopener noreferrer">阿里云maven使用指南</a>中的maven镜像设置，修改下拷贝出来的<em>settings.xml</em>文件以加速maven相关工具、依赖的下载：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">...</span>&gt;</span>
...
  <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">idea设置</h3>
<h4 data-id="heading-9">快捷键设置</h4>
<p>为了方便和统一后续的代码编辑和文件操作，设置idea快捷键为eclipse风格，同时对基本的代码补全操作重设快捷键，移除原先的<kbd>Ctrl</kbd>+<kbd>空格</kbd>（和windows输入法有冲突），这里设为<kbd>Alt</kbd> + <kbd>/</kbd>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21be077982294223a75bd3e435e5a15e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=j5j08tSU80S8fPHlkwNrADKNJMg%3D" alt="20260210072616.png" loading="lazy"/></p>
<h4 data-id="heading-10">类型自动导入设置</h4>
<p>因为官方示例代码基本无需我们手写，方便复制过来可以自动引入类型，做如下设置：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6181a34034349308554242b1834bc24~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=pw1rawLZBNtd3mPvPPk9w7avd7w%3D" alt="20260210075910.png" loading="lazy"/></p>
<h2 data-id="heading-11">构建贷款申请rule示例</h2>
<h3 data-id="heading-12">下载官方示例源代码</h3>
<p>因为Drools并入了Apache的KIE组织，而近年在KIE组织下孵化出一个图标像老爹的Kogito项目，它是 KIE 下的一个云原生业务自动化项目，定位是“<strong>下一代业务自动化平台</strong>”，聚焦云原生开发、部署和执行，当然也提供了示例，github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fincubator-kie-kogito-examples" target="_blank" title="https://github.com/apache/incubator-kie-kogito-examples" ref="nofollow noopener noreferrer">github.com/apache/incu…</a>。这里我们找到最新稳定版分支：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7553bfd29ae8418994f4e363c583d5ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=3RSTm7nYSls6L7OrlVez0Mr6F%2BI%3D" alt="20260210122224.png" loading="lazy"/></p>
<p>从基于最新<code>10.1.x</code>版本的示例：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fincubator-kie-kogito-examples%2Ftree%2F10.1.x" target="_blank" title="https://github.com/apache/incubator-kie-kogito-examples/tree/10.1.x" ref="nofollow noopener noreferrer">incubator-kie-kogito-examples</a>地址下载源代码到本地。
这里咱们找到<em>kogito-java-examples</em>的<em>rules-embedded-mode-example</em>项目，参考它给咱们之前创建的基于maven构建的java项目集成贷款申请规则案例。
<strong>后续的练习以该官方示例代码从头搭建，大家自己动手，直接参考官方示例即可。</strong></p>
<h3 data-id="heading-13">从零开发规则</h3>
<h4 data-id="heading-14">用法院审理案件类比</h4>
<h5 data-id="heading-15">宏观理解规则</h5>
<p>法院系统 = Drools 规则引擎</p>
<ol>
<li>Fact（事实）= 诉讼材料/案件事实
<ul>
<li>原告提交的起诉书、证据材料</li>
<li>被告提交的答辩材料</li>
<li>这些是“事实”，是法官需要审查的内容</li>
</ul>
</li>
<li>规则（Rules）= 法律法规
<ul>
<li>《民法典》条款</li>
<li>《刑法》条文</li>
<li>这些是“规则”，法官用来判断事实是否符合法律</li>
</ul>
</li>
<li>规则引擎 = 法官/法院
<ul>
<li>法官拿到诉讼材料（Fact）</li>
<li>对照法律法规（规则）进行判断</li>
<li>做出判决（执行规则的动作）</li>
</ul>
</li>
</ol>
<h5 data-id="heading-16">法院流程 vs 规则引擎流程</h5>
<p>法院流程</p>
<ol>
<li>立案 → 法院受理案件，建立案件档案</li>
<li>提交材料 → 原告/被告提交诉讼材料</li>
<li>开庭审理 → 法官审查材料，对照法律条文</li>
<li>判决 → 做出判决结果</li>
</ol>
<p>规则引擎流程</p>
<ol>
<li>启动规则引擎（创建 KieSession）→ 相当于立案
<ul>
<li>建立了一个"案件处理流程"</li>
<li>准备开始处理</li>
</ul>
</li>
<li>插入 Fact → 相当于提交诉讼材料
<ul>
<li>把 Applicant(申请人)、LoanApplication(贷款申请) 放入工作内存</li>
</ul>
</li>
<li>执行规则（fireAllRules）→ 相当于开庭审理
<ul>
<li>规则引擎检查 Fact，匹配规则</li>
</ul>
</li>
<li>获取结果 → 相当于判决结果
<ul>
<li>从 Fact 中获取处理后的结果，如 approved(审核结果)、explanation(审核结果说明)</li>
</ul>
</li>
</ol>
<p>对应关系</p>

























<table><thead><tr><th>法院</th><th>规则引擎</th></tr></thead><tbody><tr><td>立案</td><td>启动规则引擎（创建 KieSession）</td></tr><tr><td>提交诉讼材料</td><td>插入 Fact</td></tr><tr><td>开庭审理</td><td>执行规则（fireAllRules）</td></tr><tr><td>判决结果</td><td>获取处理后的 Fact</td></tr></tbody></table>
<h4 data-id="heading-17">定义事实(Fact)类</h4>
<p>该案例中的事实类有两个：<code>Applicant</code>(申请人)和<code>LoanApplication</code>(贷款申请)，它们就是简单的<code>POJO</code>，存储事实数据。
<em>Applicant.java</em></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;  
  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Applicant</span> {  
    <span class="hljs-comment">/** 申请人id */</span>
    <span class="hljs-keyword">private</span> String id;  
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  
  
    <span class="hljs-comment">// 省略无参构造、有参构造、getter和setter</span>
}
</code></pre>
<p><em>LoanApplication.java</em></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;  
  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoanApplication</span> {
	<span class="hljs-comment">/** 申请人id */</span>  
    <span class="hljs-keyword">private</span> String applicantId;
    <span class="hljs-comment">/** 审核结果说明 */</span>  
    <span class="hljs-keyword">private</span> String explanation;  
    <span class="hljs-comment">/** 审核结果 true-通过 false-不通过 */</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> approved;  
  
    <span class="hljs-comment">// 省略无参构造、有参构造、getter、setter和toString方法</span>
  
}
</code></pre>
<h4 data-id="heading-18">定义规则drl文件</h4>
<p>该文件用于定义规则集，也包括规则结果查询等。该<code>.drl</code>后缀的文件需要采用专门的编辑器打开，常见的有idea的drools插件以及vscode的相关插件</p>
<h5 data-id="heading-19">drl编辑器插件</h5>
<p><em>idea的drools插件</em></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e4411ba68f64c6599178479090ac954~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=a%2BGiNV6HSeaySyCmwsXsDaP6mhY%3D" alt="20260210190127.png" loading="lazy"/>
idea的drools插件对类型比较敏感，这种包中定义的类型无需导入，但idea的drl插件就不认账</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1eeda86e71cf47609425e4bef57a80bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=8g17mYbpR2FMOQx0eqhiyjQRtsc%3D" alt="20260210192624.png" loading="lazy"/></p>
<p><em>vscode的drl插件</em></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9392454ec3a64da3aa0079d38ad988b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=%2BdOrSF02P1nrnvTCv1fvPTlDhag%3D" alt="20260210191336.png" loading="lazy"/>
vscode的drl编辑器，有代码高亮和基本结构的输入提示，但不会细化到对类型检查</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/78e28cd1097f4c2dac6a522d12d3f8f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=ky%2F0gA%2FWqQq7kS8aSrRxA0z%2BGV8%3D" alt="20260210192036.png" loading="lazy"/></p>
<blockquote>
<p>[!tip] drl语法问题定位技巧
个人觉得编辑drl不要被编辑器的校验束缚，推荐用语法检查容忍度更高的vscode插件，语法问题则通过kie相关编译插件来检查，看控制台的详细提示。具体后续会实践。</p>
</blockquote>
<h5 data-id="heading-20">drl规则文件示例</h5>
<p><em>resources/com/zm626/rules/loan-application-age-limit.drl</em></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;  
<span class="hljs-comment">/* 以上指定规则文件的逻辑包路径，可以不和所在的资源包的物理包路径一致  
 但做成一致后，且规则包路径和java包路径一致，则可以免去同一个包下的Java类型导入  
 比如下面的类型导入可以不写，但是idea的插件又不能智能识别（要求显示导入）  
 */</span>  
<span class="hljs-keyword">import</span> com.zm626.rules.Applicant;  
<span class="hljs-keyword">import</span> com.zm626.rules.LoanApplication;  
  
<span class="hljs-comment">// 每个规则都有一个名字，名字在同一个规则库(KieBase)中唯一  </span>
<span class="hljs-comment">// 不加引号则不能出现一些特殊字符，变成字符串则无限制  </span>
rule <span class="hljs-string">"Underage"</span>  
  <span class="hljs-comment">// 规则执行的优先级，不加或者数字一样大则按定义顺序  </span>
  <span class="hljs-comment">// 可以显示指定优先级，数字越大越先执行，数值设置在整个KieBase中生效  </span>
  salience <span class="hljs-number">15</span>  
  <span class="hljs-comment">// 给规则分组，便于触发一个分组内的所有规则  </span>
  ruleflow-group <span class="hljs-string">"applicationGroup"</span>  
  when  
    <span class="hljs-comment">// 规则左半边（条件）用来匹配事实对象：$变量名: 类型( 属性声明、匹配表达式 )    // 这里匹配每个贷款申请对象，匹配到小于21岁的申请人，那么就不允许申请，并说明下是未成年人  </span>
    $application : LoanApplication( $applicantId: applicantId )  
    Applicant( id == $applicantId &amp;&amp; age &lt; <span class="hljs-number">21</span> )  
  then  
    <span class="hljs-comment">// 规则右半边（结论），对匹配的申请对象更新属性  </span>
    $application.setApproved( <span class="hljs-literal">false</span> );  
    $application.setExplanation( <span class="hljs-string">"Underage"</span> );  
end <span class="hljs-comment">// 规则单元结束标记，与rule成对出现</span>
</code></pre>
<h3 data-id="heading-21">规则引擎API实战</h3>
<h4 data-id="heading-22">pom中的规则依赖</h4>
<p>drools规则引擎与java项目整合，需要引入相关的依赖，依赖的版本可以由<code>drools-bom</code>来管理，因此可以在<em>pom.xml</em>中通过<code>&lt;dependencyManagement&gt;</code>标签定义要导入的<code>pom</code>类型的<code>bom</code>依赖。</p>
<p><em>pom.xml</em></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">...</span>&gt;</span>
...
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  
	    ...  
	    <span class="hljs-tag">&lt;<span class="hljs-name">version.org.drools</span>&gt;</span>10.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version.org.drools</span>&gt;</span>  
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  
	  
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  
	    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        
		    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            
			    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${version.org.drools}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  
	        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    
	    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<p>运行该示例必备的几个最小依赖如下：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 编译.drl文件，提供 KieContainer、KieSession 等 API --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-compiler<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-comment">&lt;!-- 配合 drools-compiler 进行模型编译 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-model-compiler<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-comment">&lt;!-- 支持规则中的表达式：age &lt; 21、id == $applicantId --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-mvel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-comment">&lt;!--  
    基于kmodule.xml构建KieSession需要，  
    且这里可以传递依赖drools-commands，因为用到相关API  
 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-xml-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>规则引起启动、执行到结果的输出，这里用日志框架向控制台打印信息，需要添加<code>slf4j</code>两个依赖：<code>API</code>依赖和一个简单的实现依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">...</span>&gt;</span>
...
  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  
    ...
    <span class="hljs-tag">&lt;<span class="hljs-name">version.org.slf4j</span>&gt;</span>2.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version.org.slf4j</span>&gt;</span>  
  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  
    ... 
    <span class="hljs-comment">&lt;!-- Logging --&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${version.org.slf4j}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${version.org.slf4j}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<h4 data-id="heading-23">启动规则引擎</h4>
<p>先写一个主类的结构来实践引擎相关的<code>API</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;
<span class="hljs-keyword">import</span> ...
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleMain</span> {
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(RuleMain.class);
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
		...
	}
}
</code></pre>
<h5 data-id="heading-24">KieServices</h5>
<p>看下<code>main</code>方法中的实现，首先获取规则服务的实例，它是API的调用入口，用来开启规则引擎。设计上采用了懒加载的单例创建形式。源码的这种设计值得我们好好学习，使用内部工厂来懒加载实例，后续我们会对其源码的设计做详细的解读。</p>
<p>现在你只需知道该Services组件，类似于法院的接待大厅/服务台，通过服务台统一访问各个部门，而不需要直接找每个部门。也就是利用门面模式来获取Drools规则引擎中的各种组件。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 规则服务入口，相当于到了法院大门口了，大厅服务人员就位</span>
<span class="hljs-type">KieServices</span> <span class="hljs-variable">kieServices</span> <span class="hljs-operator">=</span> KieServices.Factory.get();
</code></pre>
<h5 data-id="heading-25">KieContainer</h5>
<p>如果把Drools整个规则引擎比作法院系统（具有执行法律的能力），那么<code>KieContainer</code>则相当于法律库管理系统/档案管理部门（管理多个法律法规库的容器），这是全局共享的，也可以认为是规则引擎的全局规则容器。构建规则容器是一个重量级的操作，一般在应用启动时构建一次，然后可以被全局使用。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 获取规则容器</span>
<span class="hljs-type">KieContainer</span> <span class="hljs-variable">kieContainer</span> <span class="hljs-operator">=</span> kieServices.getKieClasspathContainer();
</code></pre>
<p><code>KieContainer</code>也是一个单例，内部采用<strong>DCL</strong>双重检查锁来实现的。
在启动时会尝试加载用户定义的规则资源，即便没有加载到也不会有任何报错，而当我们尝试从规则容器获取规则库（KieBase）时才会抛出错误。</p>
<h5 data-id="heading-26">KieBase</h5>
<p>我们说规则引擎这个大的法院系统将所有的规则交给kie容器来管理，而实际的存储规则的对应<em>KieBase</em>类型的对象。也就是说，规则容器(KieContainer)可以包含多个规则存储库(KieBase)。
用户可以对规则分组，分多个库来管理；也可以将所有规则默认放在一个库中。总之，要构建一个<em>KieBase</em>需要有一个规则模块配置文件，路径为<code>META-INFO/kmodule.xml</code>，内容可以为空：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">kmodule</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>  
        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.drools.org/xsd/kmodule"</span>&gt;</span>  
  
<span class="hljs-tag">&lt;/<span class="hljs-name">kmodule</span>&gt;</span>
</code></pre>
<p>这样会得到默认的一个规则库对象，咱们可以获取其信息：</p>
<pre><code class="hljs language-java" lang="java">...
<span class="hljs-comment">// 获取默认的规则库  </span>
<span class="hljs-type">KieBase</span> <span class="hljs-variable">kieBase</span> <span class="hljs-operator">=</span> kieContainer.getKieBase();  
logger.info(<span class="hljs-string">"------ kieBase packages: {}"</span>, kieBase.getKiePackages());
</code></pre>
<p>这里得到的包名会是一个集合，drools推荐对规则文件按包来组织结构，规则文件中头部用<code>package</code>关键字指定的逻辑包名尽量和在<code>resources</code>资源包下存储的物理包路径保持一致，以便交给kieBase进行很好的管理。</p>
<p>也可以对规则按照包路径分组后，划分给不同的规则库来管理，这样当应用中有多个业务模块，可以各自关注跟自己模块相关的业务规则，提高规则的加载和执行效率。比如：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">kmodule</span> <span class="hljs-attr">...</span>&gt;</span>  
  
    <span class="hljs-tag">&lt;<span class="hljs-name">kbase</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loanRules"</span> <span class="hljs-attr">packages</span>=<span class="hljs-string">"com.zm626.rules.loan"</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- 贷款相关规则 --&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">kbase</span>&gt;</span>  
  
    <span class="hljs-tag">&lt;<span class="hljs-name">kbase</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"creditRules"</span> <span class="hljs-attr">packages</span>=<span class="hljs-string">"com.zm626.rules.credit"</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- 信用相关规则 --&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">kbase</span>&gt;</span>  
  
<span class="hljs-tag">&lt;/<span class="hljs-name">kmodule</span>&gt;</span>
</code></pre>
<p>对应的规则文件所在目录结构：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01491c695ecf4effa3530c54b8058cd8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=jMl5FCw5tVL0cbPC9Ohb1uP49cQ%3D" alt="20260211184113.png" loading="lazy"/></p>
<p>练习下获取某个规则库：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 获取规则库名称  </span>
<span class="hljs-comment">// 输出：[loanRules, creditRules]  </span>
logger.info(<span class="hljs-string">"------ 规则库名称：{}"</span>, kieContainer.getKieBaseNames());  
  
<span class="hljs-comment">// 获取某个规则库  </span>
<span class="hljs-type">var</span> <span class="hljs-variable">kb</span> <span class="hljs-operator">=</span> kieContainer.getKieBase(<span class="hljs-string">"loanRules"</span>);  
<span class="hljs-comment">// 输出：[[Package name=com.zm626.rules.loan]]  </span>
logger.info(<span class="hljs-string">"------ kieBase packages: {}"</span>, kb.getKiePackages());
</code></pre>
<h4 data-id="heading-27">执行规则</h4>
<h5 data-id="heading-28">规则会话</h5>
<h6 data-id="heading-29">创建KieSession</h6>
<p>创建好了规则引擎的容器、构建好规则库之后，就可以执行规则了，执行规则需要创建会话对象，就好比法庭审判会依据相关法律法规来开启一次庭审一样，会话的创建可以交给<code>KieBase</code>实例，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">KieBase</span> <span class="hljs-variable">kieBase</span> <span class="hljs-operator">=</span> kieContainer.getKieBase();  
<span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieBase.newKieSession();  
<span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession2</span> <span class="hljs-operator">=</span> kieBase.newKieSession();  
<span class="hljs-comment">// 返回false，说明每次都是新new的一个会话实例  </span>
System.out.println(kieSession == kieSession2);
</code></pre>
<p>除此之外一般更推荐直接用<code>kieContainer</code>来开启会话，因为容器创建的会话，其实内部也是借助<code>kieBase</code>来创建的，但容器创建会开启对会话的监控和管理，这是在实际应用中推荐的做法。
对于默认的<code>kbase</code>，也就是<em>kmodule.xml</em>为空的情况，开启会话如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieContainer.newKieSession();
</code></pre>
<p>对于多<code>kbase</code>定义的情况，比如：
<em>kmodule.xml</em></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">kmodule</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 贷款申请相关规则 --&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">kbase</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loanRules"</span> <span class="hljs-attr">packages</span>=<span class="hljs-string">"com.zm626.rules"</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- 定义会话名称 --&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">ksession</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loanSession"</span> /&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">kbase</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">kmodule</span>&gt;</span>
</code></pre>
<p>按照会话名称来开启会话</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieContainer.newKieSession(<span class="hljs-string">"loanSession"</span>);  
</code></pre>
<p>这意味着创建的会话对象每次都是一个新的实例，要注意：这里创建的<code>KieSession</code>是有状态的会话，关于有状态还是无状态后续会讨论。规则应用中每发一个http请求，后台执行规则前都先创建一个对应的会话，规则执行完成后销毁会话。这不同于Servlet容器中的session会话的概念，session会话可以在多个http请求间通过提交的cookie中的sessionid来实现会话共享，<strong>而这里的规则会话如果创建为全局请求间共享，那么并发执行规则会有线程安全问题</strong>，而做成每个请求对应创建一个规则会话，相比于规则容器和规则库的构建，规则会话的创建则相对会轻量级很多。</p>
<h6 data-id="heading-30">监听运行事件</h6>
<p>一般在规则的开发调试阶段，为了方便调试规则执行流程，比如我们想弄清楚规则执行的细节，查看哪些事实被插入，查看哪些规则被触发，期间发生了哪些事件，排查规则未按预期执行的原因，以便于修复、改进和优化规则定义。为此可以给会话添加如下监听器：</p>
<pre><code class="hljs language-java" lang="java">kieSession.addEventListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugRuleRuntimeEventListener</span>());  
</code></pre>
<p><code>DebugRuleRuntimeEventListener</code> 会监听规则执行过程中的运行时事件，并将这些事件输出到日志，便于调试。监听的事件类型包括：</p>
<ol>
<li>事实对象插入（Fact Inserted）</li>
<li>事实对象更新（Fact Updated）</li>
<li>事实对象删除（Fact Deleted）</li>
<li>规则匹配（Rule Matched）</li>
<li>规则触发（Rule Fired）</li>
<li>规则取消（Rule Cancelled）
等等……
这就像在法庭审判时安装摄像头，记录整个审判过程，方便后续回看和分析。</li>
</ol>
<blockquote>
<p><strong>注意</strong>
这是调试工具，生产环境通常不需要，因为会产生大量日志。</p>
</blockquote>
<h6 data-id="heading-31">无状态会话与有状态会话</h6>
<p><code>kieContainer.newKieSession()</code>方式创建的是有状态的会话，如果要创建无状态的会话，可使用：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 开启无状态会话</span>
<span class="hljs-type">StatelessKieSession</span> <span class="hljs-variable">statelessKieSession</span> <span class="hljs-operator">=</span> kieContainer.newStatelessKieSession();
</code></pre>
<p>这里的“状态”指的是会话中保存的数据，也就是工作内存（Working Memory）中的 <code>Fact</code> 对象。
类比：银行柜台 vs 自动取款机</p>
<ul>
<li>有状态会话 = 银行柜台：柜员会记住你之前办过的业务</li>
<li>无状态会话 = 自动取款机：每次操作都是独立的，不保留之前的信息</li>
</ul>
<p>有状态会话的特点：</p>
<ul>
<li>数据会累积在工作内存中</li>
<li>可以分多次来插入数据并执行规则</li>
<li>适合需要多步骤交互的场景</li>
<li>必须手动调用 dispose() 清理
实际场景比如：添加购物车规则（多步骤），每次添加购物车项后都要重新触发商品促销优惠规则的计算。</li>
</ul>
<p>无状态会话的特点：</p>
<ul>
<li>每次执行完自动清空工作内存</li>
<li>每次执行都是独立的，互不影响</li>
<li>适合一次性规则执行</li>
<li>不需要手动清理
实际场景比如：贷款审批（一次性），用户提交申请，一次性完成审批，执行完就结束，不需要保留状态。
<strong>无状态会话虽然不维护状态，但并发执行时也存在线程安全问题，同样不能全局共享。</strong></li>
</ul>
<h5 data-id="heading-32">用会话执行规则</h5>
<h6 data-id="heading-33">有状态会话的执行</h6>
<p>这里我们先看有状态的会话，有了规则会话，就可以通过会话来向规则引擎发送命令，包括了：</p>
<ul>
<li>插入事实对象</li>
<li>激活规则组</li>
<li>触发规则</li>
<li>……
有状态会话执行时触发规则是手动触发的（调用<code>fireAllRules</code>），而不是一次性执行的，中间可以继续插入事实对象或者更新其状态，再继续触发规则，也是这种分步骤执行规则，才需要保持规则执行上下文的状态。</li>
</ul>
<h6 data-id="heading-34">单条命令</h6>
<p>这种方式通过会话向规则引擎分多次发送命令，每次发送一条，比如：</p>
<pre><code class="hljs language-java" lang="java">...
<span class="hljs-comment">// 直接插入事实对象  </span>
kieSession.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>));  
<span class="hljs-type">LoanApplication</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoanApplication</span>(<span class="hljs-string">"#0001"</span>);  
kieSession.insert(application);  
<span class="hljs-comment">// 激活规则组  </span>
kieSession.getAgenda().getAgendaGroup(<span class="hljs-string">"applicationGroup"</span>).setFocus();  
<span class="hljs-comment">// 触发规则  </span>
<span class="hljs-type">int</span> <span class="hljs-variable">firedRules</span> <span class="hljs-operator">=</span> kieSession.fireAllRules();  
<span class="hljs-comment">// 直接从对象获取结果  </span>
logger.info(<span class="hljs-string">"application: "</span> + application);
</code></pre>
<p>插入事实对象就好比向法庭提交案件材料（证据、文件等），这些材料会被放入工作内存供规则引擎匹配。但要注意卷宗是静态的概念，而规则引擎在执行过程中可以动态地插入甚至修改事实对象，以便重新触发一些规则或查询单元的执行。
之前在规则文件定义时，对规则通过<code>ruleflow-group</code>进行了分组，那这里就只是激活了指定的规则分组，而后通过会话出发了该分组中的所有规则（这里只有一条），返回的是触发的规则条数，这里的事实对象的引用，其实在规则的<code>then</code>中操作的是同一个对象的引用，因此可以直接拿它来看结果。</p>
<h6 data-id="heading-35">批量命令</h6>
<p>先看下示例代码：</p>
<pre><code class="hljs language-java" lang="java">...
<span class="hljs-type">var</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>);  
  
<span class="hljs-type">ExecutionResults</span> <span class="hljs-variable">executionResults</span> <span class="hljs-operator">=</span> kieSession.execute(  
        CommandFactory.newBatchExecution(Arrays.asList(  
                CommandFactory.newInsert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>), <span class="hljs-string">"applicant"</span>),  
                CommandFactory.newInsert(application, <span class="hljs-string">"application"</span>),  
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetActiveAgendaGroup</span>(<span class="hljs-string">"applicationGroup"</span>),  
                CommandFactory.newFireAllRules()  
        ))  
);  
  
logger.info(<span class="hljs-string">"application: "</span> + executionResults.getResults().get(<span class="hljs-string">"application"</span>));  
logger.info(<span class="hljs-string">"application: "</span> + application);
</code></pre>
<p>这里通过命令的静态工厂的创建方式来构建一个批量执行命令的对象，作为参数交给会话来执行。而用户传入的则是用命令模式包装我们前面提到的一组操作，这个效率相比发送单条命令就提高很多。事实对象在插入到规则引擎后,我们可以在外面给它定义好引用变量用于后续查看它,也可以在用命令工厂插入时指定fact对象的name作为标识,因为这种方式会返回执行结果,以便从执行结果中获取到它,两种方式都可以。</p>
<h6 data-id="heading-36">无状态会话的执行</h6>
<p>无状态会话的执行因为是一次性的，不存在分步骤的情况，只适合批量命令的方式，为什么只适合批量命令：因为每次 execute() 都是独立的执行单元，需要在一个批次中完成所有操作。</p>
<p>该实例相比于有状态的会话，只是最后无需手动触发规则：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">StatelessKieSession</span> <span class="hljs-variable">statelessKieSession</span> <span class="hljs-operator">=</span> kieContainer.newStatelessKieSession();  
statelessKieSession.addEventListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugRuleRuntimeEventListener</span>());  
  
<span class="hljs-type">ExecutionResults</span> <span class="hljs-variable">statelessExecutionResults</span> <span class="hljs-operator">=</span> statelessKieSession.execute(  
        CommandFactory.newBatchExecution(Arrays.asList(  
                CommandFactory.newInsert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>), <span class="hljs-string">"applicant"</span>),  
                CommandFactory.newInsert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoanApplication</span>(<span class="hljs-string">"#0001"</span>), <span class="hljs-string">"application"</span>),  
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetActiveAgendaGroup</span>(<span class="hljs-string">"applicationGroup"</span>)            ))  
);  
  
logger.info(<span class="hljs-string">"application: "</span> + statelessExecutionResults.getResults().get(<span class="hljs-string">"application"</span>));
</code></pre>
<h5 data-id="heading-37">销毁会话</h5>
<p>注意这里只适用于有状态的会话，完成规则执行后确实不需要再使用有状态的会话了，此时可以手动的调用：</p>
<pre><code class="hljs language-java" lang="java">kieSession.dispose();
</code></pre>
<p>以便释放规则执行时占用的资源、工作内存空间等。<strong>但要注意，状态会话一旦关闭就不能再执行规则了</strong>。kie会话接口在设计上扩展了<code>AutoCloseable</code>接口，<code>close</code>方法实现为对<code>dispose</code>方法的调用，因此可以使用<code>try-with-resources</code>语法来声明会话的创建：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">try</span> (  
	<span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieContainer.newKieSession();  
) {
    ...
}
</code></pre>
<p>而对于无状态的会话，每次执行完规则后会自动释放资源，后续可以继续执行。</p>
<h3 data-id="heading-38">总结</h3>
<p>本文介绍了 Drools 规则引擎的基础使用：从环境搭建到规则定义，再到通过 KieServices、KieContainer、KieBase、KieSession 执行规则。重点包括 Fact 类、DRL 规则文件、有状态/无状态会话的区别，以及单条命令与批量命令的执行方式。通过法院审理案件的类比，帮助理解规则引擎的核心概念。</p>
<p>以上内容为入门基础。后续将深入规则优先级、规则分组、复杂条件匹配、规则测试、性能优化等进阶主题，以及在实际项目中的应用实践。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 手写 call、apply、bind：深入理解函数上下文绑定]]></title>    <link>https://juejin.cn/post/7605941424535470134</link>    <guid>https://juejin.cn/post/7605941424535470134</guid>    <pubDate>2026-02-12T22:57:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605941424535470134" data-draft-id="7605800124883435526" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 手写 call、apply、bind：深入理解函数上下文绑定"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-12T22:57:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wuhen_n"/> <meta itemprop="url" content="https://juejin.cn/user/4149996261738233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 手写 call、apply、bind：深入理解函数上下文绑定
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4149996261738233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wuhen_n
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T22:57:30.000Z" title="Thu Feb 12 2026 22:57:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>当面试官让我们手写 call、apply、bind 时，他们真正考察的是什么？这三个方法看似简单，却隐藏着 JavaScript 函数执行上下文、原型链、参数处理等核心概念。本文将从零实现，并深入理解它们的差异和应用场景。</p>
</blockquote>
<h2 data-id="heading-0">前言：为什么需要 call、apply、bind？</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>,
  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
};

<span class="hljs-keyword">const</span> sayHelloFunc = obj.<span class="hljs-property">sayHello</span>;
obj.<span class="hljs-title function_">sayHello</span>();     <span class="hljs-comment">// "你好，我是张三" - 正确</span>
<span class="hljs-title function_">sayHelloFunc</span>();     <span class="hljs-comment">// "你好，我是undefined" - this丢失了！</span>
</code></pre>
<p>上述代码，出现问题根源是：函数的 this 在调用时才确定，取决于调用方式。那如何解决呢？使用call、apply、bind 显式绑定 this 。</p>
<h2 data-id="heading-1">call 方法的实现</h2>
<h3 data-id="heading-2">call 的基本使用</h3>
<p>call 方法用于调用一个函数，并显式指定函数的 this 值和参数列表。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">message</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${message}</span>, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>);
}

<span class="hljs-keyword">const</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">'zhangsan'</span> };

<span class="hljs-comment">// 原生 call 的使用</span>
greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">'你好'</span>); <span class="hljs-comment">// "你好, zhangsan!"</span>
</code></pre>
<h3 data-id="heading-3">call 的工作原理</h3>
<ol>
<li>将函数设为对象的属性</li>
<li>使用该对象调用函数</li>
<li>删除该属性</li>
</ol>
<h3 data-id="heading-4">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {
  <span class="hljs-comment">// 如果context是null或undefined，则绑定到全局对象</span>
  <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) {
    context = globalThis;
  }
  <span class="hljs-comment">// 给context对象添加一个临时属性，值为当前函数</span>
  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'fn'</span>); <span class="hljs-comment">// 使用Symbol避免属性名冲突</span>
  context[fnKey] = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// this指向调用myCall的函数</span>
  <span class="hljs-comment">// 使用context对象调用函数</span>
  <span class="hljs-keyword">const</span> result = context[fnKey](...args);
  <span class="hljs-comment">// 删除临时属性</span>
  <span class="hljs-keyword">delete</span> context[fnKey];
  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h3 data-id="heading-5">处理边界情况</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCallEnhanced</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {
  <span class="hljs-comment">// 处理undefined和null</span>
  <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) {
    context = globalThis;
  }

  <span class="hljs-comment">// 原始值需要转换为对象，否则不能添加属性</span>
  <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> context;
  <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span> ||
    contextType === <span class="hljs-string">'number'</span> ||
    contextType === <span class="hljs-string">'boolean'</span> ||
    contextType === <span class="hljs-string">'symbol'</span> ||
    contextType === <span class="hljs-string">'bigint'</span>) {
    context = <span class="hljs-title class_">Object</span>(context); <span class="hljs-comment">// 转换为包装对象</span>
  }

  <span class="hljs-comment">// 使用更安全的Symbol作为key</span>
  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'fn'</span>);
  context[fnKey] = <span class="hljs-variable language_">this</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = context[fnKey](...args);
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 确保总是删除临时属性</span>
    <span class="hljs-keyword">delete</span> context[fnKey];
  }
};

</code></pre>
<h3 data-id="heading-6">完整实现与性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCallFinal</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context = globalThis, ...args</span>) {
  <span class="hljs-comment">// 1. 类型检查：确保调用者是函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.myCallFinal called on non-function'</span>);
  }

  <span class="hljs-comment">// 2. 处理Symbol和BigInt（ES6+）</span>
  <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> context;
  <span class="hljs-keyword">let</span> finalContext = context;

  <span class="hljs-comment">// 3. 处理原始值（非严格模式下的自动装箱）</span>
  <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'number'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'boolean'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'symbol'</span>) {
    <span class="hljs-comment">// Symbol不能通过new创建，使用Object</span>
    finalContext = <span class="hljs-title class_">Object</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'bigint'</span>) {
    <span class="hljs-comment">// BigInt不能通过new创建，使用Object</span>
    finalContext = <span class="hljs-title class_">Object</span>(context);
  }
  <span class="hljs-comment">// null和undefined已经通过默认参数处理</span>

  <span class="hljs-comment">// 4. 使用Symbol创建唯一key，避免属性冲突</span>
  <span class="hljs-keyword">const</span> fnSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'callFn'</span>);

  <span class="hljs-comment">// 5. 将函数绑定到上下文对象</span>
  <span class="hljs-comment">// 使用Object.defineProperty确保属性可配置</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(finalContext, fnSymbol, {
    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
  });

  <span class="hljs-comment">// 6. 执行函数并获取结果</span>
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">try</span> {
    result = finalContext[fnSymbol](...args);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 7. 清理临时属性</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">delete</span> finalContext[fnSymbol];
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 如果上下文不可配置，忽略错误</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'无法删除临时属性:'</span>, error.<span class="hljs-property">message</span>);
    }
  }

  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h2 data-id="heading-7">apply 方法的实现</h2>
<h3 data-id="heading-8">apply 的基本使用</h3>
<p>apply 和 call 的功能基本相同，唯一的区别在于参数的传递方式：</p>
<ul>
<li>call 接受参数列表</li>
<li>apply 接受参数数组</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-comment">// apply：参数以数组形式传递</span>
sum.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
</code></pre>
<h3 data-id="heading-9">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) {
  <span class="hljs-comment">// 如果context是null或undefined，则绑定到全局对象</span>
  <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) {
    context = globalThis;
  }
  <span class="hljs-comment">// 给context对象添加一个临时属性，值为当前函数</span>
  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'fn'</span>); <span class="hljs-comment">// 使用Symbol避免属性名冲突</span>
  context[fnKey] = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// this指向调用myCall的函数</span>
  <span class="hljs-comment">// 使用context对象调用函数</span>
  <span class="hljs-keyword">const</span> result = context[fnKey](...args);
  <span class="hljs-comment">// 删除临时属性</span>
  <span class="hljs-keyword">delete</span> context[fnKey];
  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h3 data-id="heading-10">完整实现与性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context = globalThis, argsArray</span>) {
  <span class="hljs-comment">// 1. 类型检查</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.myApply called on non-function'</span>);
  }

  <span class="hljs-comment">// 2. 参数处理：确保argsArray是数组或类数组对象</span>
  <span class="hljs-keyword">let</span> args = [];
  <span class="hljs-keyword">if</span> (argsArray != <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 检查是否为数组或类数组</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> argsArray !== <span class="hljs-string">'object'</span> ||
      (<span class="hljs-keyword">typeof</span> argsArray.<span class="hljs-property">length</span> !== <span class="hljs-string">'number'</span> &amp;&amp; argsArray.<span class="hljs-property">length</span> !== <span class="hljs-literal">undefined</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'第二个参数必须是数组或类数组对象'</span>);
    }

    <span class="hljs-comment">// 将类数组转换为真实数组</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(argsArray)) {
      args = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(argsArray);
    } <span class="hljs-keyword">else</span> {
      args = argsArray;
    }
  }

  <span class="hljs-comment">// 3. 使用Symbol作为唯一key</span>
  <span class="hljs-keyword">const</span> fnSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'applyFn'</span>);

  <span class="hljs-comment">// 4. 处理原始值（与call相同）</span>
  <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> context;
  <span class="hljs-keyword">let</span> finalContext = context;

  <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'number'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'boolean'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'symbol'</span>) {
    finalContext = <span class="hljs-title class_">Object</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'bigint'</span>) {
    finalContext = <span class="hljs-title class_">Object</span>(context);
  }

  <span class="hljs-comment">// 5. 绑定函数到上下文</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(finalContext, fnSymbol, {
    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
  });

  <span class="hljs-comment">// 6. 执行函数</span>
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">try</span> {
    result = finalContext[fnSymbol](...args);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 7. 清理</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">delete</span> finalContext[fnSymbol];
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 忽略删除错误</span>
    }
  }

  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h2 data-id="heading-11">bind 方法的实现</h2>
<h3 data-id="heading-12">bind 的基本使用</h3>
<p>bind 方法创建一个新的函数，当这个新函数被调用时，它的 this 值会被绑定到指定的对象，并且可以预先传入部分参数。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, name</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, <span class="hljs-subst">${name}</span>! 我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.role}</span>`</span>);
}

<span class="hljs-keyword">const</span> context = { <span class="hljs-attr">role</span>: <span class="hljs-string">'管理员'</span> };

<span class="hljs-comment">// bind：创建新函数，稍后执行</span>
<span class="hljs-keyword">const</span> boundGreet = greet.<span class="hljs-title function_">bind</span>(context, <span class="hljs-string">'你好'</span>);
<span class="hljs-title function_">boundGreet</span>(<span class="hljs-string">'李四'</span>); 
</code></pre>
<h3 data-id="heading-13">bind 的核心特性：</h3>
<ol>
<li>返回一个新函数</li>
<li>可以预设参数（柯里化）</li>
<li>绑定this值</li>
<li>支持new操作符（特殊情况）</li>
</ol>
<h3 data-id="heading-14">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...bindArgs</span>) {
  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>) {
        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, [...args, ...newArgs]);
    };
};
</code></pre>
<h3 data-id="heading-15">处理 new 操作符的特殊情况</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBindEnhanced</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context = globalThis, ...bindArgs</span>) {
  <span class="hljs-keyword">const</span> originalFunc = <span class="hljs-variable language_">this</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originalFunc !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.myBindEnhanced called on non-function'</span>);
  }

  <span class="hljs-comment">// 内部函数，用于判断是否被new调用</span>
  <span class="hljs-keyword">const</span> boundFunc = <span class="hljs-keyword">function</span> (<span class="hljs-params">...callArgs</span>) {
    <span class="hljs-comment">// 关键判断：this instanceof boundFunc</span>
    <span class="hljs-comment">// 如果使用new调用，this会是boundFunc的实例</span>
    <span class="hljs-keyword">const</span> isConstructorCall = <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> boundFunc;

    <span class="hljs-comment">// 确定最终的上下文</span>
    <span class="hljs-comment">// 如果是构造函数调用，使用新创建的对象作为this</span>
    <span class="hljs-comment">// 否则使用绑定的context</span>
    <span class="hljs-keyword">const</span> finalContext = isConstructorCall ? <span class="hljs-variable language_">this</span> : <span class="hljs-title class_">Object</span>(context);

    <span class="hljs-comment">// 合并参数</span>
    <span class="hljs-keyword">const</span> finalArgs = bindArgs.<span class="hljs-title function_">concat</span>(callArgs);

    <span class="hljs-comment">// 执行原函数</span>
    <span class="hljs-comment">// 如果原函数有返回值，需要特殊处理</span>
    <span class="hljs-keyword">const</span> result = originalFunc.<span class="hljs-title function_">apply</span>(finalContext, finalArgs);

    <span class="hljs-comment">// 构造函数调用的特殊处理</span>
    <span class="hljs-comment">// 如果原函数返回一个对象，则使用该对象</span>
    <span class="hljs-comment">// 否则返回新创建的对象（this）</span>
    <span class="hljs-keyword">if</span> (isConstructorCall) {
      <span class="hljs-keyword">if</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'function'</span>)) {
        <span class="hljs-keyword">return</span> result;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    }

    <span class="hljs-keyword">return</span> result;
  };

  <span class="hljs-comment">// 维护原型链</span>
  <span class="hljs-comment">// 方法1：直接设置prototype（有缺陷）</span>
  <span class="hljs-comment">// boundFunc.prototype = originalFunc.prototype;</span>

  <span class="hljs-comment">// 方法2：使用空函数中转（推荐）</span>
  <span class="hljs-keyword">const</span> F = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) { };
  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = originalFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
  boundFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();
  boundFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = boundFunc;

  <span class="hljs-comment">// 添加一些元信息（可选）</span>
  boundFunc.<span class="hljs-property">originalFunc</span> = originalFunc;
  boundFunc.<span class="hljs-property">bindContext</span> = context;
  boundFunc.<span class="hljs-property">bindArgs</span> = bindArgs;

  <span class="hljs-keyword">return</span> boundFunc;
};
</code></pre>
<h3 data-id="heading-16">完整实现与性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBindFinal</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-comment">// 使用闭包保存Slice方法，提高性能</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ArraySlice</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>;

  <span class="hljs-comment">// 空函数，用于原型链维护</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">EmptyFunction</span>(<span class="hljs-params"/>) { }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myBindFinal</span>(<span class="hljs-params">context = globalThis, ...bindArgs</span>) {
    <span class="hljs-keyword">const</span> originalFunc = <span class="hljs-variable language_">this</span>;

    <span class="hljs-comment">// 严格的类型检查</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originalFunc !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.bind called on non-function'</span>);
    }

    <span class="hljs-comment">// 处理原始值的上下文（非严格模式）</span>
    <span class="hljs-keyword">let</span> boundContext = context;
    <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> boundContext;

    <span class="hljs-comment">// 原始值包装（与call/apply保持一致）</span>
    <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span>) {
      boundContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'number'</span>) {
      boundContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'boolean'</span>) {
      boundContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'symbol'</span>) {
      boundContext = <span class="hljs-title class_">Object</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'bigint'</span>) {
      boundContext = <span class="hljs-title class_">Object</span>(boundContext);
    }

    <span class="hljs-comment">// 创建绑定函数</span>
    <span class="hljs-keyword">const</span> boundFunction = <span class="hljs-keyword">function</span> (<span class="hljs-params">...callArgs</span>) {
      <span class="hljs-comment">// 判断是否被new调用</span>
      <span class="hljs-keyword">const</span> isConstructorCall = <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> boundFunction;

      <span class="hljs-comment">// 确定最终上下文</span>
      <span class="hljs-keyword">let</span> finalContext;
      <span class="hljs-keyword">if</span> (isConstructorCall) {
        <span class="hljs-comment">// new调用：忽略绑定的context，使用新实例</span>
        finalContext = <span class="hljs-variable language_">this</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (boundContext == <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 非严格模式：使用全局对象</span>
        finalContext = globalThis;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 普通调用：使用绑定的context</span>
        finalContext = boundContext;
      }

      <span class="hljs-comment">// 合并参数</span>
      <span class="hljs-keyword">const</span> allArgs = bindArgs.<span class="hljs-title function_">concat</span>(callArgs);

      <span class="hljs-comment">// 调用原函数</span>
      <span class="hljs-keyword">const</span> result = originalFunc.<span class="hljs-title function_">apply</span>(finalContext, allArgs);

      <span class="hljs-comment">// 处理构造函数调用的返回值</span>
      <span class="hljs-keyword">if</span> (isConstructorCall) {
        <span class="hljs-comment">// 如果原函数返回对象，则使用该对象</span>
        <span class="hljs-keyword">if</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'function'</span>)) {
          <span class="hljs-keyword">return</span> result;
        }
        <span class="hljs-comment">// 否则返回新创建的实例</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
      }

      <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-comment">// 维护原型链 - 高性能版本</span>
    <span class="hljs-comment">// 避免直接修改boundFunction.prototype，使用中间函数</span>
    <span class="hljs-keyword">if</span> (originalFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) {
      <span class="hljs-title class_">EmptyFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = originalFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
      boundFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyFunction</span>();
      <span class="hljs-comment">// 恢复constructor属性</span>
      boundFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = boundFunction;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 处理没有prototype的情况（如箭头函数）</span>
      boundFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-comment">// 添加不可枚举的原始函数引用（用于调试）</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'__originalFunction__'</span>, {
      <span class="hljs-attr">value</span>: originalFunc,
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-comment">// 添加不可枚举的绑定信息</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'__bindContext__'</span>, {
      <span class="hljs-attr">value</span>: boundContext,
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'__bindArgs__'</span>, {
      <span class="hljs-attr">value</span>: bindArgs,
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-comment">// 设置适当的函数属性</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'length'</span>, {
      <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, originalFunc.<span class="hljs-property">length</span> - bindArgs.<span class="hljs-property">length</span>),
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
    });

    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'name'</span>, {
      <span class="hljs-attr">value</span>: <span class="hljs-string">`bound <span class="hljs-subst">${originalFunc.name || <span class="hljs-string">''</span>}</span>`</span>.<span class="hljs-title function_">trim</span>(),
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
    });

    <span class="hljs-keyword">return</span> boundFunction;
  };
})();
</code></pre>
<h2 data-id="heading-17">面试常见问题与解答</h2>
<h3 data-id="heading-18">问题1：手写call的核心步骤是什么？</h3>
<ol>
<li>步骤1:  将函数设为上下文对象的属性</li>
<li>步骤2:  执行该函数</li>
<li>步骤3:  删除该属性</li>
<li>步骤4:  返回函数执行结果</li>
<li>关键点：
<ul>
<li>使用Symbol避免属性名冲突</li>
<li>处理null/undefined上下文</li>
<li>处理原始值上下文</li>
<li>使用展开运算符处理参数</li>
</ul>
</li>
</ol>
<h3 data-id="heading-19">问题2：bind如何处理new操作符？</h3>
<ol>
<li>通过 this instanceof boundFunction 判断是否被new调用</li>
<li>如果是new调用，忽略绑定的上下文，使用新创建的对象作为this</li>
<li>需要正确设置boundFunction的原型链，以支持instanceof</li>
<li>如果原构造函数返回对象，则使用该对象，否则返回新实例</li>
</ol>
<h3 data-id="heading-20">问题3：call、apply、bind的性能差异？</h3>
<ol>
<li>call通常比apply快，因为apply需要处理数组参数</li>
<li>bind创建新函数有开销，但多次调用时比重复call/apply高效</li>
</ol>
<h2 data-id="heading-21">结语</h2>
<p>通过深入理解call、apply、bind的实现原理，我们不仅能更好地回答面试问题，还能在实际开发中编写出更优雅、更高效的JavaScript代码。对于文章中错误的地方或者有任何问题，欢迎在评论区留言讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 手写 new 操作符：深入理解对象创建]]></title>    <link>https://juejin.cn/post/7605792874173055039</link>    <guid>https://juejin.cn/post/7605792874173055039</guid>    <pubDate>2026-02-13T01:10:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605792874173055039" data-draft-id="7605807405306921023" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 手写 new 操作符：深入理解对象创建"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-13T01:10:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wuhen_n"/> <meta itemprop="url" content="https://juejin.cn/user/4149996261738233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 手写 new 操作符：深入理解对象创建
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4149996261738233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wuhen_n
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T01:10:10.000Z" title="Fri Feb 13 2026 01:10:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>当我们使用 new 关键字时，背后到底发生了什么？这个看似简单的操作，实际上完成了一系列复杂的步骤。理解 new 的工作原理，是掌握 JavaScript 面向对象编程的关键。</p>
</blockquote>
<h2 data-id="heading-0">前言：从 new 的神秘面纱说起</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>，今年<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span>岁`</span>;
};

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">25</span>);
</code></pre>
<p>上述代码中 new 到底创建了什么？为什么 this 指向了新对象？原型链是怎么建立的？如果构造函数有返回值会怎样？我们将通过本篇文章揭开 new 的神秘面纱，从零实现一个自己的 new 操作符。</p>
<h2 data-id="heading-1">理解 new</h2>
<p>new 的四个核心步骤：</p>
<ol>
<li>创建一个空对象</li>
<li>将对象的原型设置为构造函数的 prototype 属性</li>
<li>将构造函数的 this 绑定到新对象，并执行构造函数</li>
<li>判断返回值类型：如果构造函数返回一个对象（包括函数），则返回该对象；否则返回新创建的对象</li>
</ol>
<h2 data-id="heading-2">手写实现 new 操作符</h2>
<h3 data-id="heading-3">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">constructor, ...args</span>) {

  <span class="hljs-comment">// 1. 创建一个空对象</span>
  <span class="hljs-keyword">const</span> obj = {};

  <span class="hljs-comment">// 2. 将对象的原型设置为构造函数的 prototype 属性</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);

  <span class="hljs-comment">// 3. 将构造函数的 this 绑定到新对象，并执行构造函数</span>
  <span class="hljs-keyword">const</span> result = constructor.<span class="hljs-title function_">apply</span>(obj, args);

  <span class="hljs-comment">// 4. 判断返回值类型</span>
  <span class="hljs-comment">// 如果构造函数返回一个对象（包括函数），则返回该对象</span>
  <span class="hljs-comment">// 否则返回新创建的对象</span>
  <span class="hljs-keyword">const</span> isObject = result !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'function'</span>);

  <span class="hljs-keyword">return</span> isObject ? result : obj;
}
</code></pre>
<h3 data-id="heading-4">处理边界情况</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNewEnhanced</span>(<span class="hljs-params">constructor, ...args</span>) {

  <span class="hljs-comment">// 边界情况1：constructor 不是函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">${constructor}</span> is not a constructor`</span>);
  }

  <span class="hljs-comment">// 边界情况2：箭头函数（没有 prototype）</span>
  <span class="hljs-keyword">if</span> (!constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">${constructor.name || constructor}</span> is not a constructor`</span>);
  }

  <span class="hljs-comment">// 1. 创建新对象（改进方法）：使用 Object.create 更优雅地设置原型</span>
  <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);

  <span class="hljs-comment">// 2. 调用构造函数</span>
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">try</span> {
    result = constructor.<span class="hljs-title function_">apply</span>(obj, args);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 如果构造函数抛出异常，直接传播</span>
    <span class="hljs-keyword">throw</span> error;
  }

  <span class="hljs-comment">// 3. 处理返回值</span>
  <span class="hljs-comment">// 注意：null 也是 object 类型，但需要特殊处理</span>
  <span class="hljs-keyword">const</span> resultType = <span class="hljs-keyword">typeof</span> result;
  <span class="hljs-keyword">const</span> isObject = result !== <span class="hljs-literal">null</span> &amp;&amp; (resultType === <span class="hljs-string">'object'</span> || resultType === <span class="hljs-string">'function'</span>);

  <span class="hljs-keyword">return</span> isObject ? result : obj;
}

</code></pre>
<h3 data-id="heading-5">完整实现与原型链优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNewComplete</span>(<span class="hljs-params">constructor, ...args</span>) {
  <span class="hljs-comment">// 1. 参数验证</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`Constructor <span class="hljs-subst">${constructor}</span> is not a function`</span>);
  }

  <span class="hljs-comment">// 2. 检查是否为可构造的函数：箭头函数和部分内置方法没有 prototype</span>
  <span class="hljs-keyword">if</span> (!constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &amp;&amp; !<span class="hljs-title function_">isNativeConstructor</span>(constructor)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">${getFunctionName(constructor)}</span> is not a constructor`</span>);
  }

  <span class="hljs-comment">// 3. 创建新对象并设置原型链</span>
  <span class="hljs-keyword">const</span> proto = constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> || <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
  <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);

  <span class="hljs-comment">// 4. 绑定 constructor 属性</span>
  obj.<span class="hljs-property">constructor</span> = constructor; 

  <span class="hljs-comment">// 5. 执行构造函数</span>
  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(constructor, args, constructor);

  <span class="hljs-comment">// 6. 处理返回值</span>
  <span class="hljs-comment">// Reflect.construct 已经处理了返回值逻辑</span>
  <span class="hljs-comment">// 但我们还是实现自己的逻辑以保持一致</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">processConstructorResult</span>(result, obj, constructor);
}

<span class="hljs-comment">// 辅助函数：检查是否为原生构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isNativeConstructor</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-comment">// 一些内置构造函数如 Symbol、BigInt 没有 prototype</span>
  <span class="hljs-keyword">const</span> nativeConstructors = [
    <span class="hljs-string">'Number'</span>, <span class="hljs-string">'String'</span>, <span class="hljs-string">'Boolean'</span>, <span class="hljs-string">'Symbol'</span>, <span class="hljs-string">'BigInt'</span>,
    <span class="hljs-string">'Date'</span>, <span class="hljs-string">'RegExp'</span>, <span class="hljs-string">'Error'</span>, <span class="hljs-string">'Array'</span>, <span class="hljs-string">'Object'</span>, <span class="hljs-string">'Function'</span>
  ];

  <span class="hljs-keyword">return</span> nativeConstructors.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span>
    fn.<span class="hljs-property">name</span> === name || fn === globalThis[name]
  );
}

<span class="hljs-comment">// 辅助函数：获取函数名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFunctionName</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-keyword">if</span> (fn.<span class="hljs-property">name</span>) <span class="hljs-keyword">return</span> fn.<span class="hljs-property">name</span>;
  <span class="hljs-keyword">const</span> match = fn.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^function\s*([^\s(]+)/</span>);
  <span class="hljs-keyword">return</span> match ? match[<span class="hljs-number">1</span>] : <span class="hljs-string">'anonymous'</span>;
}

<span class="hljs-comment">// 辅助函数：处理构造函数返回值</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processConstructorResult</span>(<span class="hljs-params">result, defaultObj, constructor</span>) {
  <span class="hljs-comment">// 如果 result 是 undefined 或 null，返回 defaultObj</span>
  <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> defaultObj;
  }

  <span class="hljs-comment">// 检查 result 的类型</span>
  <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> result;

  <span class="hljs-comment">// 如果是对象或函数，返回 result</span>
  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'object'</span> || type === <span class="hljs-string">'function'</span>) {
    <span class="hljs-comment">// 额外检查：如果 result 是构造函数本身的实例，确保原型链正确</span>
    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> constructor) {
      <span class="hljs-keyword">return</span> result;
    }
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// 原始值，返回 defaultObj</span>
  <span class="hljs-keyword">return</span> defaultObj;
}
</code></pre>
<h2 data-id="heading-6">深入原型链与继承</h2>
<h3 data-id="heading-7">原型链的建立过程</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-comment">// 父类方法</span>
<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> 叫了`</span>;
};
<span class="hljs-comment">// 子构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, breed</span>) {
  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;
}
<span class="hljs-comment">// 建立原型链</span>
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>;
<span class="hljs-comment">// 子类方法</span>
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> 汪汪叫`</span>;
};
<span class="hljs-comment">// 创建实例</span>
<span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">'旺财'</span>, <span class="hljs-string">'金毛'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">speak</span>()); <span class="hljs-comment">// 旺财 叫了</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">bark</span>());  <span class="hljs-comment">// 旺财 汪汪叫</span>
</code></pre>
<h3 data-id="heading-8">ES6 类与 new 的关系</h3>
<p>ES6 类的本质还是基于原型的语法糖：</p>
<h4 data-id="heading-9">ES6 基本写法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  }

  <span class="hljs-title function_">greet</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;
  }
}
<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">30</span>);
</code></pre>
<h4 data-id="heading-10">对应 ES5 的写法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PersonES5</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-comment">// 类构造器中的代码</span>
  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonES5</span>)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Class constructor Person cannot be invoked without 'new'"</span>);
  }

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 实例方法（添加到原型）</span>
<span class="hljs-title class_">PersonES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;
};
<span class="hljs-keyword">const</span> personES5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonES5</span>(<span class="hljs-string">'李四'</span>, <span class="hljs-number">25</span>);
</code></pre>
<h3 data-id="heading-11">类的重要特性</h3>
<ol>
<li>类必须用 new 调用</li>
<li>类方法不可枚举</li>
<li>类没有变量提升</li>
</ol>
<h3 data-id="heading-12">ES6 实现继承的完整示例</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 叫了'</span>);
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">super</span>(name);
  }

  <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 汪汪叫'</span>);
  }
}
</code></pre>
<h4 data-id="heading-13">ES6 继承的本质</h4>
<p>ES6 通过 <code>extends</code> 关键字实现继承，就等价于 ES5 的寄生组合继承：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AnimalES5</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">AnimalES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 叫了'</span>);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DogES5</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-title class_">AnimalES5</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
}

<span class="hljs-comment">// 设置原型链</span>
<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AnimalES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">DogES5</span>;

<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 汪汪叫'</span>);
};
</code></pre>
<h2 data-id="heading-14">特殊场景与高级应用</h2>
<h3 data-id="heading-15">单例模式与 new</h3>
<h4 data-id="heading-16">方法1：使用静态属性</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonV1</span> {
  <span class="hljs-keyword">static</span> instance = <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">SingletonV1</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">SingletonV1</span>.<span class="hljs-property">instance</span>;
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-title class_">SingletonV1</span>.<span class="hljs-property">instance</span> = <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonV1</span>(name);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>;
  }
}
</code></pre>
<h4 data-id="heading-17">方法2：使用闭包</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SingletonV2</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
      <span class="hljs-keyword">if</span> (instance) {
        <span class="hljs-keyword">return</span> instance;
      }

      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
      instance = <span class="hljs-variable language_">this</span>;
    }
  };
})();
</code></pre>
<h4 data-id="heading-18">方法3：代理模式</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSingletonProxy</span>(<span class="hljs-params">Class</span>) {
  <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">Class</span>, {
    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, args</span>) {
      <span class="hljs-keyword">if</span> (!instance) {
        instance = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, args);
      }
      <span class="hljs-keyword">return</span> instance;
    }
  });
}
</code></pre>
<h3 data-id="heading-19">实现 Object.create 的 polyfill</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> !== <span class="hljs-string">'function'</span>) {
  <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">proto, propertiesObject</span>) {
    <span class="hljs-comment">// 参数验证</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Object prototype may only be an Object or null'</span>);
    }

    <span class="hljs-comment">// 核心实现：使用空函数作为中间构造函数</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"/>) { }
    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;

    <span class="hljs-comment">// 创建新对象，原型指向proto</span>
    <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();

    <span class="hljs-comment">// 处理第二个参数（属性描述符）</span>
    <span class="hljs-keyword">if</span> (propertiesObject !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, propertiesObject);
    }

    <span class="hljs-comment">// 处理 null 原型</span>
    <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) {
      obj.<span class="hljs-property">__proto__</span> = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-comment">// 返回新对象</span>
    <span class="hljs-keyword">return</span> obj;
  };
}
</code></pre>
<h2 data-id="heading-20">常见面试问题与解答</h2>
<h3 data-id="heading-21">问题1：new 操作符做了什么？</h3>
<ol>
<li>创建一个新的空对象',</li>
<li>将这个空对象的原型设置为构造函数的 prototype 属性',</li>
<li>将构造函数的 this 绑定到这个新对象，并执行构造函数',</li>
<li>如果构造函数返回一个对象（包括函数），则返回该对象；否则返回新创建的对象</li>
</ol>
<h3 data-id="heading-22">问题2：如果构造函数有返回值会怎样？</h3>
<ul>
<li>返回对象（包括函数）：忽略 this 绑定的对象，返回该对象</li>
<li>返回原始值（number, string, boolean等）：忽略返回值，返回 this 绑定的对象</li>
<li>没有 return 语句：隐式返回 undefined，返回 this 绑定的对象</li>
</ul>
<h3 data-id="heading-23">问题3：如何判断函数是否被 new 调用？</h3>
<ul>
<li>ES5：检查 this instanceof Constructor'</li>
<li>ES6+：使用 new.target（更准确）</li>
<li>箭头函数：不能作为构造函数，没有 new.target</li>
</ul>
<h2 data-id="heading-24">结语</h2>
<p>通过深入理解 new 操作符的工作原理，我们不仅能在面试中脱颖而出，还能在实际开发中做出更明智的设计决策。对于文章中错误的地方或者有任何问题，欢迎在评论区留言讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[TypeScript 核心基础知识]]></title>    <link>https://juejin.cn/post/7605539194690666496</link>    <guid>https://juejin.cn/post/7605539194690666496</guid>    <pubDate>2026-02-13T01:11:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605539194690666496" data-draft-id="7605772919224320034" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="TypeScript 核心基础知识"/> <meta itemprop="keywords" content="前端,TypeScript,面试"/> <meta itemprop="datePublished" content="2026-02-13T01:11:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            TypeScript 核心基础知识
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T01:11:10.000Z" title="Fri Feb 13 2026 01:11:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>TypeScript（简称 TS）作为 JavaScript 的超集，已成为前端工程化的标配。它通过静态类型检查，提前规避大量运行时错误，让代码更易维护、更具可读性。本文抛开复杂概念，从新手视角梳理 TS 核心基础知识，看完就能上手写 TS 代码。</p>
<h2 data-id="heading-0">一、为什么要学 TypeScript？</h2>
<p>先明确学习的意义，避免盲目跟风：</p>
<ol>
<li><strong>静态类型检查</strong>：编码阶段发现错误（如类型不匹配、属性不存在），而非运行时崩溃；</li>
<li><strong>更好的代码提示</strong>：VS Code 等编辑器能精准提示变量 / 函数的属性和方法，提升开发效率；</li>
<li><strong>代码可读性提升</strong>：类型注解就是 “自文档”，一眼看懂变量 / 函数的用途；</li>
<li><strong>工程化必备</strong>：Vue3、React、Node.js 主流框架 / 环境均推荐 / 支持 TS，大厂项目标配。</li>
</ol>
<h2 data-id="heading-1">二、TS 环境搭建（快速上手）</h2>
<h3 data-id="heading-2">1. 安装 TypeScript</h3>
<pre><code class="hljs language-js" lang="js"># 全局安装 <span class="hljs-variable constant_">TS</span> 编译器
npm install -g typescript
# 验证安装（查看版本）
tsc -v
</code></pre>
<h3 data-id="heading-3">2. 第一个 TS 程序</h3>
<ul>
<li>
<p>创建 <code>hello.ts</code> 文件：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 类型注解：指定变量类型为字符串</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"Hello TypeScript!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);
</code></pre>
</li>
<li>
<p>编译 TS 为 JS：</p>
<pre><code class="hljs language-ts" lang="ts"># 将 hello.<span class="hljs-property">ts</span> 编译为 hello.<span class="hljs-property">js</span>
tsc hello.<span class="hljs-property">ts</span>
</code></pre>
</li>
<li>
<p>运行 JS 文件：</p>
<pre><code class="hljs language-ts" lang="ts">node hello.<span class="hljs-property">js</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-4">3. 简化开发：自动编译 + 热更新（可选）</h3>
<pre><code class="hljs language-ts" lang="ts"># 安装 ts-node（直接运行 <span class="hljs-variable constant_">TS</span>，无需手动编译）
npm install -g ts-node
# 直接运行 <span class="hljs-variable constant_">TS</span> 文件
ts-node hello.<span class="hljs-property">ts</span>
</code></pre>
<h2 data-id="heading-5">三、核心基础：类型注解与类型推断</h2>
<h3 data-id="heading-6">1. 类型注解（手动指定类型）</h3>
<p>语法：<code>变量名: 类型 = 值</code>，告诉 TS 变量的具体类型。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基本类型注解</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"张三"</span>; <span class="hljs-comment">// 字符串</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">25</span>; <span class="hljs-comment">// 数字（整数/浮点数/NaN/Infinity）</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">isAdult</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 布尔值</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">empty</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// null</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">undef</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// 数组注解（两种写法）</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">"苹果"</span>, <span class="hljs-string">"香蕉"</span>]; <span class="hljs-comment">// 推荐</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 泛型写法</span>

<span class="hljs-comment">// 对象注解</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> } = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"李四"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
};

<span class="hljs-comment">// 函数注解（参数 + 返回值）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<h3 data-id="heading-7">2. 类型推断（TS 自动推导类型）</h3>
<p>TS 会根据变量的初始值自动推断类型，无需手动注解（日常开发中优先用推断，减少冗余）。</p>
<p>typescript</p>
<p>运行</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> str = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// TS 自动推断 str 为 string 类型</span>
str = <span class="hljs-number">123</span>; <span class="hljs-comment">// 报错：不能将类型“number”分配给类型“string”</span>

<span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span>; <span class="hljs-comment">// 推断为 number 类型</span>
<span class="hljs-keyword">let</span> bool = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 推断为 boolean 类型</span>
</code></pre>
<p><strong>核心原则</strong>：能靠推断的就不手动注解，需要明确约束时才加注解。</p>
<h2 data-id="heading-8">四、常用基础类型</h2>
<h3 data-id="heading-9">1. 原始类型</h3>
<p>表格</p>













































<table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>string</code></td><td>字符串</td><td><code>let str: string = "TS"</code></td></tr><tr><td><code>number</code></td><td>数字</td><td><code>let num: number = 666</code></td></tr><tr><td><code>boolean</code></td><td>布尔值</td><td><code>let flag: boolean = false</code></td></tr><tr><td><code>null</code></td><td>空值</td><td><code>let n: null = null</code></td></tr><tr><td><code>undefined</code></td><td>未定义</td><td><code>let u: undefined = undefined</code></td></tr><tr><td><code>symbol</code></td><td>唯一值</td><td><code>let s: symbol = Symbol("id")</code></td></tr><tr><td><code>bigint</code></td><td>大整数</td><td><code>let b: bigint = 100n</code></td></tr></tbody></table>
<h3 data-id="heading-10">2. 数组</h3>
<p>两种写法，推荐第一种：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 写法1：类型[]</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">numbers</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 写法2：Array&lt;类型&gt;</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">strings</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-comment">// 禁止混合类型（除非指定联合类型）</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">mix</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>]; <span class="hljs-comment">// 联合类型：字符串或数字</span>
</code></pre>
<h3 data-id="heading-11">3. 元组（Tuple）</h3>
<p>固定长度、固定类型的数组（强约束）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 元组注解：第一个元素是string，第二个是number</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">"张三"</span>, <span class="hljs-number">25</span>];
tuple[<span class="hljs-number">0</span>] = <span class="hljs-string">"李四"</span>; <span class="hljs-comment">// 合法</span>
tuple[<span class="hljs-number">1</span>] = <span class="hljs-number">30</span>; <span class="hljs-comment">// 合法</span>
tuple.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 注意：push 不会报错（TS 设计缺陷），但访问 tuple[2] 会报错</span>
</code></pre>
<h3 data-id="heading-12">4. 任意类型（any）</h3>
<p>关闭 TS 类型检查，慎用（失去 TS 核心价值）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">anyValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">"hello"</span>;
anyValue = <span class="hljs-number">123</span>; <span class="hljs-comment">// 不报错</span>
anyValue = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 不报错</span>
anyValue.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 不报错（运行时可能崩溃）</span>
</code></pre>
<h3 data-id="heading-13">5. 未知类型（unknown）</h3>
<p>安全版 <code>any</code>，必须先类型校验才能使用：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">unknownValue</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-string">"hello"</span>;
<span class="hljs-comment">// unknownValue.toUpperCase(); // 报错：不能直接调用方法</span>

<span class="hljs-comment">// 先校验类型，再使用</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> unknownValue === <span class="hljs-string">"string"</span>) {
  unknownValue.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// 合法</span>
}
</code></pre>
<h3 data-id="heading-14">6. 空类型（void）</h3>
<p>表示函数没有返回值（或返回 <code>undefined</code>）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMsg</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"这是一个无返回值的函数"</span>);
  <span class="hljs-comment">// 省略 return 或 return undefined 均合法</span>
}
</code></pre>
<h3 data-id="heading-15">7. 永不类型（never）</h3>
<p>表示永远不会发生的值（如抛出错误、无限循环）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 抛出错误的函数，返回值为 never</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params"/>): <span class="hljs-built_in">never</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"出错了！"</span>);
}

<span class="hljs-comment">// 无限循环的函数，返回值为 never</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"/>): <span class="hljs-built_in">never</span> {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}
}
</code></pre>
<h2 data-id="heading-16">五、进阶基础：接口与类型别名</h2>
<h3 data-id="heading-17">1. 接口（interface）</h3>
<p>用于约束对象的结构，可扩展、可实现，是 TS 中定义对象类型的核心方式：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 定义接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 必选属性</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 必选属性</span>
  gender?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 可选属性（加 ?）</span>
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 只读属性（不可修改）</span>
}

<span class="hljs-comment">// 使用接口约束对象</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">id</span>: <span class="hljs-number">1001</span>,
  <span class="hljs-comment">// gender 可选，可省略</span>
};

user.<span class="hljs-property">id</span> = <span class="hljs-number">1002</span>; <span class="hljs-comment">// 报错：只读属性不能修改</span>
</code></pre>
<h3 data-id="heading-18">2. 类型别名（type）</h3>
<p>给类型起别名，适用范围更广（可约束任意类型，不止对象）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基本类型别名</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-title class_">Str</span> = <span class="hljs-string">"hello"</span>;

<span class="hljs-comment">// 对象类型别名</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">// 联合类型别名</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">NumberOrString</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-title class_">NumberOrString</span> = <span class="hljs-number">100</span>;
value = <span class="hljs-string">"abc"</span>;
</code></pre>
<h3 data-id="heading-19">3. interface vs type 核心区别</h3>
<p>表格</p>

























<table><thead><tr><th>特性</th><th>interface</th><th>type</th></tr></thead><tbody><tr><td>扩展</td><td>可通过 <code>extends</code> 扩展</td><td>可通过 <code>&amp;</code> 交叉扩展</td></tr><tr><td>重复定义</td><td>支持（自动合并）</td><td>不支持（会报错）</td></tr><tr><td>适用范围</td><td>主要约束对象 / 类</td><td>可约束任意类型（基本类型、联合类型等）</td></tr></tbody></table>
<p><strong>使用建议</strong>：定义对象 / 类的结构用 <code>interface</code>，其他场景用 <code>type</code>。</p>
<h2 data-id="heading-20">六、函数相关类型</h2>
<h3 data-id="heading-21">1. 函数参数与返回值注解</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">const</span> multiply = (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> a * b;
};

<span class="hljs-comment">// 无返回值</span>
<span class="hljs-keyword">const</span> log = (<span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);
};
</code></pre>
<h3 data-id="heading-22">2. 可选参数与默认参数</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 可选参数（加 ?，必须放在必选参数后面）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`姓名：<span class="hljs-subst">${name}</span>，年龄：<span class="hljs-subst">${age || <span class="hljs-string">"未知"</span>}</span>`</span>);
}
<span class="hljs-title function_">greet</span>(<span class="hljs-string">"张三"</span>); <span class="hljs-comment">// 合法</span>
<span class="hljs-title function_">greet</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 合法</span>

<span class="hljs-comment">// 默认参数（自动推断类型，无需加 ?）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span> = <span class="hljs-string">"游客"</span></span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，<span class="hljs-subst">${name}</span>`</span>);
}
<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 输出：你好，游客</span>
</code></pre>
<h3 data-id="heading-23">3. 函数类型别名</h3>
<p>定义函数的 “形状”（参数类型 + 返回值类型）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 定义函数类型</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">AddFn</span> = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;

<span class="hljs-comment">// 实现函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">add</span>: <span class="hljs-title class_">AddFn</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> x + y;
};
</code></pre>
<h2 data-id="heading-24">七、类型守卫</h2>
<p>通过代码逻辑缩小类型范围，让 TS 更精准推断类型：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// typeof 类型守卫（适用于原始类型）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">printValue</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// TS 知道这里 value 是 string</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// TS 知道这里 value 是 number</span>
  }
}

<span class="hljs-comment">// instanceof 类型守卫（适用于类实例）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
  <span class="hljs-title function_">bark</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"汪汪汪"</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeAnimal</span>(<span class="hljs-params">animal: Animal</span>) {
  <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>) {
    animal.<span class="hljs-title function_">bark</span>(); <span class="hljs-comment">// TS 知道这里 animal 是 Dog 实例</span>
  }
}
</code></pre>
<h2 data-id="heading-25">八、TS 配置文件（tsconfig.json）</h2>
<p>项目中通过 <code>tsconfig.json</code> 配置 TS 编译规则，执行 <code>tsc --init</code> 生成默认配置，核心配置说明：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ES6"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 编译目标 JS 版本（ES5/ES6/ESNext）</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 模块系统（CommonJS/ESModule）</span>
    <span class="hljs-attr">"outDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 编译后的 JS 文件输出目录</span>
    <span class="hljs-attr">"rootDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./src"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 源文件目录</span>
    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 开启严格模式（推荐，强制类型检查）</span>
    <span class="hljs-attr">"noImplicitAny"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁止隐式 any 类型</span>
    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-comment">// 兼容 CommonJS 和 ESModule</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src/**/*"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 要编译的文件</span>
  <span class="hljs-attr">"exclude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"node_modules"</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 排除的文件</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-26">九、新手避坑指南</h2>
<ol>
<li><strong>不要滥用 any</strong>：用 <code>unknown</code> 替代 any，保留类型检查；</li>
<li><strong>可选参数放最后</strong>：TS 要求可选参数必须在必选参数之后；</li>
<li><strong>元组 push 不报错</strong>：元组虽固定长度，但 push 不会触发 TS 报错，需手动规避；</li>
<li><strong>严格模式必开</strong>：<code>strict: true</code> 能暴露更多潜在问题，是 TS 核心价值所在；</li>
<li><strong>类型断言要谨慎</strong>：<code>as</code> 语法是 “告诉 TS 我比你更清楚类型”，滥用会导致类型不安全。</li>
</ol>
<h2 data-id="heading-27">总结</h2>
<ol>
<li>TS 核心是<strong>静态类型系统</strong>，通过类型注解 / 推断提前规避错误；</li>
<li>常用基础类型：原始类型、数组、元组、any/unknown、void/never，需掌握各自使用场景；</li>
<li>定义对象结构优先用 <code>interface</code>，其他类型约束用 <code>type</code>；</li>
<li>函数注解要关注参数、返回值、可选参数，类型守卫能提升类型推断精度；</li>
<li>项目中务必开启严格模式（<code>strict: true</code>），发挥 TS 最大价值。</li>
</ol>
<p>从 JS 过渡到 TS 无需一步到位，可先在项目中局部使用，逐步覆盖，重点是理解 “类型” 的核心思想，而非死记语法。掌握本文的基础知识，足以应对日常开发中 80% 的 TS 场景，后续可再深入泛型、装饰器、高级类型等内容。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android事件分发逻辑--针对事件分发相关函数的讲解]]></title>    <link>https://juejin.cn/post/7605542907118354484</link>    <guid>https://juejin.cn/post/7605542907118354484</guid>    <pubDate>2026-02-12T17:15:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605542907118354484" data-draft-id="7605537925150048308" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android事件分发逻辑--针对事件分发相关函数的讲解"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-12T17:15:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Aurora419"/> <meta itemprop="url" content="https://juejin.cn/user/4114811667877977"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android事件分发逻辑--针对事件分发相关函数的讲解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4114811667877977/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Aurora419
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T17:15:18.000Z" title="Thu Feb 12 2026 17:15:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="rainbow">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#474949;color:#d1d9e1}.hljs-comment,.hljs-quote{color:#969896;font-style:italic}.hljs-addition,.hljs-keyword,.hljs-literal,.hljs-selector-tag,.hljs-type{color:#c9c}.hljs-number,.hljs-selector-attr,.hljs-selector-pseudo{color:#f99157}.hljs-doctag,.hljs-regexp,.hljs-string{color:#8abeb7}.hljs-built_in,.hljs-name,.hljs-section,.hljs-title{color:#b5bd68}.hljs-class .hljs-title,.hljs-selector-id,.hljs-template-variable,.hljs-variable{color:#fc6}.hljs-name,.hljs-section,.hljs-strong{font-weight:700}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-subst,.hljs-symbol{color:#f99157}.hljs-deletion{color:#dc322f}.hljs-formula{background:#eee8d5}.hljs-attr,.hljs-attribute{color:#81a2be}.hljs-emphasis{font-style:italic}</style><h2 data-id="heading-0">何为事件分发？</h2>
<p>声明:这是个人的学习笔记，刚学事件分发几天对事件分发的理解没有这么深请见谅
由于这篇文字是在飞书上写的所以一些颜色不对应，请见谅</p>
<p><strong>事件</strong>指的是<strong>屏幕触发事件</strong>——即Android中的<strong>TouchEvent/MotionEvent</strong>。每一次我们触摸屏幕，都会产生一连串的触摸事件，这些一连串的触摸事件合起来就是一个触摸事件序列。</p>
<p>触摸事件在Android官方API中由类MotionEvent来描述，不同的触摸事件对应不同的事件类型。事件类型分别有ACTION_DOWN、ACTION_UP、ACTION_MOVE、ACTION_CANCEL。(这里暂时不讨论多指触控)</p>
<p>那什么叫<strong>分发</strong>呢？我们都知道Android是由View树进行渲染的。假设屏幕坐标为（11，11）的区域既属于一个LinearLayout，又属于LinearLayout下的一个Button，那我这次触碰所产生的触摸事件，是该给LinearLayout还是Button呢？当然，我们很确定这次触摸事件最终会被Button所处理。<strong>那触摸事件是怎么给到Button的呢</strong>？需要经过LinearLayout吗？怎样能让Button不处理呢？这就需要我们了解触摸事件（后文统称为事件）在View树上传递与消费的过程，这就是事件的分发。</p>
<p>以下是 Android 中 <code>onTouchEvent</code> 常见的事件类型及其特性的汇总表格，以及针对各事件的深度解析。</p>
<h3 data-id="heading-1">Android 触摸事件（MotionEvent）核心概览表</h3>








































<table><thead><tr><th>事件类型 (Action)</th><th>触发条件 (Trigger Condition)</th><th>触发频率 (Frequency)</th><th>对事件流的影响</th><th>核心用途</th></tr></thead><tbody><tr><td>ACTION_DOWN</td><td>手指初次接触屏幕</td><td>仅 1 次</td><td>生死关口：若返回 false，后续事件不再传给此 View</td><td>记录起点坐标、重置状态、申明消费意向</td></tr><tr><td>ACTION_MOVE</td><td>手指在屏幕上滑动</td><td>多次 (高频)</td><td>持续更新，反映手指轨迹</td><td>计算位移、实现拖拽、判断是否触发滑动阈值</td></tr><tr><td>ACTION_UP</td><td>手指离开屏幕</td><td>仅 1 次</td><td>正常终点：标志整个手势序列圆满结束</td><td>触发点击事件 (onClick)、执行回弹动画</td></tr><tr><td>ACTION_CANCEL</td><td>事件流被父布局拦截</td><td>最多 1 次</td><td>非正常终点：强制终止当前 View 的事件处理</td><td>状态重置（如取消按钮高亮），防止逻辑出错</td></tr></tbody></table>
<h4 data-id="heading-2">事件详细解析</h4>
<p><strong>ACTION_DOWN：事件流的“敲门砖”</strong></p>
<ul>
<li>
<p><strong>触发条件</strong>：这是所有触摸事件的源头。每当一根手指接触屏幕时触发。</p>
</li>
<li>
<p><strong>消费机制</strong>：这是 View 唯一一次能决定“要不要处理这个序列”的机会。</p>
<ul>
<li><strong>如果你在</strong> <strong><code>ACTION_DOWN</code></strong> <strong>时返回了</strong> <strong><code>false</code></strong> <strong>，系统会认为你对这个任务不感兴趣，接下来的</strong> <strong><code>MOVE</code></strong> <strong>、</strong> <strong><code>UP</code></strong> <strong>统统不会再发给你</strong>。</li>
<li><strong>比喻</strong>：就像公司的派活，如果你拒绝了开头，那后续所有的进度汇报和结尾都没你的事了。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-3">ACTION_MOVE：高频的“过程量”</h4>
<ul>
<li>
<p><strong>触发条件</strong>：只要手指按下后在屏幕上移动，甚至是微小的抖动。</p>
</li>
<li>
<p><strong>多次触发</strong>：它的触发频率极高（通常 16ms 或 8ms 一次，取决于屏幕刷新率）[每刷新一次屏幕就需要计算两次的位移差]。</p>
</li>
<li>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>性能</strong>：不要在 <code>MOVE</code> 里面写大量的计算逻辑、创建大量对象或进行数据库操作，否则会导致 UI 卡顿。</li>
<li><strong>阈值 (TouchSlop)</strong> ：通常我们会判断滑动距离是否超过系统定义的 <code>mTouchSlop</code>（通常是 8dp 左右），来决定这是不是一次有效的“滑动”，还是只是手指的轻微震颤。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-4">ACTION_UP：完美的“收尾”</h4>
<ul>
<li>
<p><strong>触发条件</strong>：最后一根手指离开屏幕。</p>
</li>
<li>
<p><strong>逻辑处理</strong>：</p>
<ul>
<li>Android 的 <code>onClick</code>（点击监听）就是在 <code>UP</code> 里面判断的。如果手指按下到抬起的位移很小，且时长符合要求，系统就会在内部调用 <code>performClick()</code>。</li>
<li>它是释放资源、结束动画的最佳时机。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-5">ACTION_CANCEL：无奈的“被截胡”</h4>
<ul>
<li>
<p><strong>触发条件</strong>：这个事件比较特殊，它不是由用户直接触发的，而是由<strong>父布局</strong>产生的。</p>
<ul>
<li><strong>典型场景</strong>：你在一个 <code>RecyclerView</code>（列表）里按住了一个按钮，刚开始触发了 <code>DOWN</code>。但接着你向上滑动，父容器 <code>RecyclerView</code> 觉得你要滚动列表，于是它强行拦截了事件（<code>onInterceptTouchEvent</code> 返回 <code>true</code>）。</li>
<li>此时，按钮会收到一个 <code>ACTION_CANCEL</code>，告诉它：“活儿被老板接管了，你洗洗睡吧。”</li>
</ul>
</li>
<li>
<p><strong>重要性</strong>：View 收到此事件时必须<strong>重置状态</strong>。比如按钮本来是按压变色的，收到 <code>CANCEL</code> 后必须变回原色，否则按钮会一直卡在“按下”的状态。</p>
</li>
</ul>
<p><strong>也就是说事件从触摸开始，经历滑动，最后以手指抬起结果。也就是说DOWN事件是其他事件的开始没有DOWN事件就没有其他事件的发生</strong></p>
<h2 data-id="heading-6">事件分发的关键函数</h2>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">dispatchTouchEvent</span>()、<span class="hljs-built_in">onInterceptTouchEvent</span>()、<span class="hljs-built_in">onTouchEvent</span>()
</code></pre>
<h2 data-id="heading-7">dispatchTouchEvent</h2>
<p>负责分发事件，View和ViewGroup上有不同的表现</p>
<p>ViewGroup的dispatchTouchEvent会向子View分发事件，如果子View不处理再交给父View处理，此时也会调用ViewGroup父View的disptachTouchEvent方法(ViewGroup继承于View,此时调用的是父类的方法）</p>
<h3 data-id="heading-8">ViewGroup的dispatchTouchEvent</h3>
<p><strong>dispatchTouchEvent是一个返回</strong> <strong>布尔值</strong> <strong>的函数，通过返回临时变量handled值，默认赋值为false</strong></p>
<p><strong>对于DOWN,MOVE,UP事件的会进入不同的分发链</strong></p>
<p>了解分发链前我们需要重点关注的几个变量</p>
<p>intercepted-&gt;判断是否需要拦截</p>
<pre><code class="hljs language-ini" lang="ini">final boolean intercepted<span class="hljs-comment">;</span>
if (<span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
        //这个标黄的标志位，是后面内部拦截法requestDisallowInterceptTouchEvent() 的关键
    final boolean <span class="hljs-attr">disallowIntercept</span> = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    if (!disallowIntercept) {
    //这里调用onInterceptTouchEvent方法
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">on</span>InterceptTouchEvent(ev)<span class="hljs-comment">;</span>
        ev.setAction(action)<span class="hljs-comment">; // restore action in case it was changed</span>
    } else {
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
    }
} else {

    <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}
</code></pre>
<p>mFirstTouchTarget-&gt;消费DOWN事件子View的位置</p>
<p>newTouchTarget-&gt;新手指的触摸位置</p>
<h4 data-id="heading-9"><strong>DOWN事件在dispatchTouchEvent主要流程</strong></h4>
<pre><code class="hljs language-ini" lang="ini">TouchTarget <span class="hljs-attr">newTouchTarget</span> = null<span class="hljs-comment">;//每次循环前清空</span>
boolean <span class="hljs-attr">alreadyDispatchedToNewTouchTarget</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;//注意这个参数</span>
final boolean <span class="hljs-attr">canceled</span> = resetCancelNextUpFlag(this)
        || <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_CANCEL<span class="hljs-comment">;</span>
if (!canceled &amp;&amp; !intercepted) {

    View <span class="hljs-attr">childWithAccessibilityFocus</span> = ev.isTargetAccessibilityFocus()
            ? findChildWithAccessibilityFocus() : null<span class="hljs-comment">;</span>

    if (<span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_DOWN
|| (split &amp;&amp; <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_POINTER_DOWN)
            || <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_HOVER_MOVE) {
        final int <span class="hljs-attr">actionIndex</span> = ev.getActionIndex()<span class="hljs-comment">; // always 0 for down</span>
        final int <span class="hljs-attr">idBitsToAssign</span> = split ? <span class="hljs-number">1</span> &lt;&lt; ev.getPointerId(actionIndex)
                : TouchTarget.ALL_POINTER_IDS<span class="hljs-comment">;</span>

        removePointersFromTouchTargets(idBitsToAssign)<span class="hljs-comment">;</span>

        final int <span class="hljs-attr">childrenCount</span> = mChildrenCount<span class="hljs-comment">;</span>
        if (<span class="hljs-attr">newTouchTarget</span> == null &amp;&amp; childrenCount != <span class="hljs-number">0</span>) {
            final float <span class="hljs-attr">x</span> = ev.getXDispatchLocation(actionIndex)<span class="hljs-comment">;</span>
            final float <span class="hljs-attr">y</span> = ev.getYDispatchLocation(actionIndex)<span class="hljs-comment">;</span>
         
            final ArrayList&lt;View&gt; <span class="hljs-attr">preorderedList</span> = buildTouchDispatchChildList()<span class="hljs-comment">;</span>
            final boolean <span class="hljs-attr">customOrder</span> = preorderedList == null
                    &amp;&amp; isChildrenDrawingOrderEnabled()<span class="hljs-comment">;</span>
            final View<span class="hljs-section">[]</span> <span class="hljs-attr">children</span> = mChildren<span class="hljs-comment">;</span>
            //从右往左遍历
            for (int <span class="hljs-attr">i</span> = childrenCount - <span class="hljs-number">1</span><span class="hljs-comment">; i &gt;= 0; i--) {</span>
                final int <span class="hljs-attr">childIndex</span> = getAndVerifyPreorderedIndex(
                        childrenCount, i, customOrder)<span class="hljs-comment">;</span>
                final View <span class="hljs-attr">child</span> = getAndVerifyPreorderedView(
                        preorderedList, children, childIndex)<span class="hljs-comment">;</span>

              
                if (childWithAccessibilityFocus != null) {
                    if (childWithAccessibilityFocus != child) {
                        continue<span class="hljs-comment">;</span>
                    }
                    <span class="hljs-attr">childWithAccessibilityFocus</span> = null<span class="hljs-comment">;</span>
                    <span class="hljs-attr">i</span> = childrenCount<span class="hljs-comment">;</span>
                }

                if (!child.canReceivePointerEvents()
                        || !isTransformedTouchPointInView(x, y, child, null)) {
                    ev.setTargetAccessibilityFocus(false)<span class="hljs-comment">;</span>
                    continue<span class="hljs-comment">;</span>
                }
//如果这个手指位置已经存在会直接跳出循环
                <span class="hljs-attr">newTouchTarget</span> = getTouchTarget(child)<span class="hljs-comment">;</span>
                if (newTouchTarget != null) {
                    newTouchTarget.pointerIdBits |= idBitsToAssign<span class="hljs-comment">;</span>
                    break<span class="hljs-comment">;</span>
                }

//最关键代码
                resetCancelNextUpFlag(child)<span class="hljs-comment">;</span>
                //这个方法会调用子View的dispatchTouchevent来判断是否消费事件
                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                    // Child wants to receive touch within its <span class="hljs-attr">bounds.
                    mLastTouchDownTime</span> = ev.getDownTime()<span class="hljs-comment">;</span>
                    if (preorderedList != null) {
                        for (int <span class="hljs-attr">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; childrenCount; j++) {</span>
                            if (children<span class="hljs-section">[childIndex]</span> == mChildren<span class="hljs-section">[j]</span>) {
                                <span class="hljs-attr">mLastTouchDownIndex</span> = j<span class="hljs-comment">;</span>
                                break<span class="hljs-comment">;</span>
                            }
                        }
                    } else {
                        <span class="hljs-attr">mLastTouchDownIndex</span> = childIndex<span class="hljs-comment">;</span>
                    }
                    <span class="hljs-attr">mLastTouchDownX</span> = x<span class="hljs-comment">;</span>
                    <span class="hljs-attr">mLastTouchDownY</span> = y<span class="hljs-comment">;</span>
                    //关键调用函数
                    <span class="hljs-attr">newTouchTarget</span> = addTouchTarget(child, idBitsToAssign)<span class="hljs-comment">;</span>
                    //开始提到的参数
                    <span class="hljs-attr">alreadyDispatchedToNewTouchTarget</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
                    break<span class="hljs-comment">;</span>
                }
                
                ev.setTargetAccessibilityFocus(false)<span class="hljs-comment">;</span>
            }
            if (preorderedList != null) preorderedList.clear()<span class="hljs-comment">;</span>
        }
//多指触控逻辑 :既然没找到新的 View 接收这根手指，就把这根手指分配给“最老”的那个负责人
        if (<span class="hljs-attr">newTouchTarget</span> == null &amp;&amp; mFirstTouchTarget != null) {
            <span class="hljs-attr">newTouchTarget</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
            while (newTouchTarget.next != null) {
                <span class="hljs-attr">newTouchTarget</span> = newTouchTarget.next<span class="hljs-comment">;</span>
            }
            newTouchTarget.pointerIdBits |= idBitsToAssign<span class="hljs-comment">;</span>
        }
    }
}
//如果DOWN事件没有被子View消费mFirstTouchTarget就为空此时由父View来处理
    if (<span class="hljs-attr">mFirstTouchTarget</span> == null) {
        <span class="hljs-attr">handled</span> = dispatchTransformedTouchEvent(ev, canceled, null,
                TouchTarget.ALL_POINTER_IDS)<span class="hljs-comment">;</span>
    } else {
    //如果DOWN事件被子View消费
        TouchTarget <span class="hljs-attr">predecessor</span> = null<span class="hljs-comment">;</span>
        TouchTarget <span class="hljs-attr">target</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
        while (target != null) {
            final TouchTarget <span class="hljs-attr">next</span> = target.next<span class="hljs-comment">;</span>
            //DOWN事件并且DOWN被子View消费情况下这里的alreadyDispatchedToNewTouchTarget就为true，返回handled值，防止重复分发
            if (alreadyDispatchedToNewTouchTarget &amp;&amp; <span class="hljs-attr">target</span> == newTouchTarget) {
                <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
            } else {
               ......
    }

   
}
private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
    final TouchTarget <span class="hljs-attr">target</span> = TouchTarget.obtain(child, pointerIdBits)<span class="hljs-comment">;</span>
    <span class="hljs-attr">target.next</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
    //给mFirstTouchTarget赋值 后面会对mFirstTouchTarget的值进行判断这个参数很重要
    <span class="hljs-attr">mFirstTouchTarget</span> = target<span class="hljs-comment">;</span>
    return target<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-10">MOVE事件在dispatchTouchEvent主要流程</h4>
<p>intercepted-&gt;判断是否需要拦截</p>
<p>mFirstTouchTarget-&gt;消费DOWN事件子View的位置</p>
<p>newTouchTarget-&gt;新手指的触摸位置</p>
<pre><code class="hljs language-ini" lang="ini">//如果前面的DOWN事件没有子View消费，这里会直接进入else分支
//即<span class="hljs-attr">intercepted</span> = <span class="hljs-literal">true</span> if (!canceled &amp;&amp; !intercepted) {},巧妙的跳过了这里的遍历流程

final boolean intercepted<span class="hljs-comment">;</span>
if (<span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
        //这个标黄的标志位，是后面内部拦截法requestDisallowInterceptTouchEvent() 的关键
    final boolean <span class="hljs-attr">disallowIntercept</span> = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    if (!disallowIntercept) {
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">on</span>InterceptTouchEvent(ev)<span class="hljs-comment">;</span>
        ev.setAction(action)<span class="hljs-comment">; </span>
    } else {
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
    }
} else {

    <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}
</code></pre>
<pre><code class="hljs language-ini" lang="ini">//------前置参数  这是一个200行的大方法，不要忘了必要的参数
final boolean intercepted<span class="hljs-comment">;</span>
final boolean <span class="hljs-attr">canceled</span> = resetCancelNextUpFlag(this)
        || <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_CANCEL<span class="hljs-comment">;</span>
 boolean <span class="hljs-attr">alreadyDispatchedToNewTouchTarget</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;//注意这个参数</span>
//------正式代码
//MOVE分发下：如果前面的DOWN事件没有子View消费，这里会调用ViewGroup的dispatchTouchEvent(也就是decorView的onTouchEvent方法最后调用activity的onTouchEvent方法)
    if (<span class="hljs-attr">mFirstTouchTarget</span> == null) {
    //这里不仅可以是DOWN的结果也可以是MOVE的结果(结合前文)
       <span class="hljs-attr">1. handled</span> = dispatchTransformedTouchEvent(ev, canceled, null,
                TouchTarget.ALL_POINTER_IDS)<span class="hljs-comment">;</span>
    } else {
//这里MOVE分为两种情况，正常MOVE和MOVE事件被拦截，这里使用两种颜色的字体表示 灰色正常 绿色MOVE拦截    由于这篇文字是在飞书上写的所以颜色不对，请见谅.
        TouchTarget <span class="hljs-attr">predecessor</span> = null<span class="hljs-comment">;</span>
        TouchTarget <span class="hljs-attr">target</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
        //这里的循环是为了做多指触控，本来mFirstTouchTarget就是ViewGruop指向一个View的单向链表，由于有多指的情况，这样的链表有几对
        while (target != null) {
            final TouchTarget <span class="hljs-attr">next</span> = target.next<span class="hljs-comment">;</span>
            //只有在DOWN事件的情况下才有可能为true，所以MOVE事件不会到这里面去
            if (alreadyDispatchedToNewTouchTarget &amp;&amp; <span class="hljs-attr">target</span> == newTouchTarget) {
            <span class="hljs-attr">2.    handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
            } 
//DOWN事件分发所有可能的结果只能到这里 要么是1.  要么是2.           
            else {
            //这里有个误区，这里是不需要考虑前面DOWN事件没有被子View消费的情况的，因为已经被这段代码开头的if判断清除了，所以这里的intercepted是通过 <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">on</span>InterceptTouchEvent(ev)<span class="hljs-comment">;这里得到的</span>
            
            //resetCancelNextUpFlag这里用来避免子View出现的意外情况，一旦子View发生意外，不让子VieW消费事件 比如下面这些情况
            //当一个 View 正在被按下时，它突然被从父容器中移除了（detach）
            //或者 View 的状态发生了剧烈变化，导致系统认为它不应该再产生点击效果
                final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                        || intercepted<span class="hljs-comment">;</span>
                 //根据前面的target定向寻找子View,判断是否消费事件，这个就是我们之前一直说的mFirstTouchTarget
                 //如果这里cancelChild为true,会子View分发CANCEL终止分发
                if (dispatchTransformedTouchEvent(ev, cancelChild,
                        target.child, target.pointerIdBits)) {
                    <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
                }
                //如果cancelChild为true置空链表
                if (cancelChild) {
                    if (<span class="hljs-attr">predecessor</span> == null) {
                        <span class="hljs-attr">mFirstTouchTarget</span> = next<span class="hljs-comment">;</span>
                    } else {
                        <span class="hljs-attr">predecessor.next</span> = next<span class="hljs-comment">;</span>
                    }
                    target.recycle()<span class="hljs-comment">;</span>
                    <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
                    continue<span class="hljs-comment">;</span>
                }
            }
            //循环遍历操作
            <span class="hljs-attr">predecessor</span> = target<span class="hljs-comment">;</span>
            <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
        }
    }

}
</code></pre>
<h4 data-id="heading-11">UP事件在dispatchTouchEvent主要流程</h4>
<p>MOVE事件与UP事件的流程高度重合唯一区别就是UP事件需要清空之前的状态便于迎接下一次事件的到来</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// --- 这段代码处理 UP，但不处理 MOVE ---</span>
if (canceled
        || actionMasked == MotionEvent.ACTION_UP // 【UP 走这里】
        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
    <span class="hljs-built_in">resetTouchState</span>(); <span class="hljs-comment">// 重置所有状态，清空链表</span>
} 
<span class="hljs-comment">// --- 这段处理多指抬起 ---</span>
else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
    <span class="hljs-built_in">removePointersFromTouchTargets</span>(idBitsToRemove);
}
</code></pre>
<h4 data-id="heading-12">CANCEL事件在dispatchTouchEvent主要流程</h4>
<p>CANCEL事件的处理比较简单了，理解了前面MOVE的流程，这里就一目了然了</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">mFirstTouchTarget</span> == null) {
    <span class="hljs-attr">handled</span> = dispatchTransformedTouchEvent(ev, canceled, null,
            TouchTarget.ALL_POINTER_IDS)<span class="hljs-comment">;</span>
} else {

    TouchTarget <span class="hljs-attr">predecessor</span> = null<span class="hljs-comment">;</span>
    TouchTarget <span class="hljs-attr">target</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
    while (target != null) {
        final TouchTarget <span class="hljs-attr">next</span> = target.next<span class="hljs-comment">;</span>
        if (alreadyDispatchedToNewTouchTarget &amp;&amp; <span class="hljs-attr">target</span> == newTouchTarget) {
            <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
        } else {
//这里   cancelChild为true     
            final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                    || intercepted<span class="hljs-comment">;</span>
            if (dispatchTransformedTouchEvent(ev, cancelChild,
                    target.child, target.pointerIdBits)) {
                <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
            }
            //链表清除
            if (cancelChild) {
                if (<span class="hljs-attr">predecessor</span> == null) {
                    <span class="hljs-attr">mFirstTouchTarget</span> = next<span class="hljs-comment">;</span>
                } else {
                    <span class="hljs-attr">predecessor.next</span> = next<span class="hljs-comment">;</span>
                }
                target.recycle()<span class="hljs-comment">;</span>
                <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
                continue<span class="hljs-comment">;</span>
            }
        }
        <span class="hljs-attr">predecessor</span> = target<span class="hljs-comment">;</span>
        <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
    }
}
</code></pre>
<h4 data-id="heading-13">dispatchTransformedTouchEvent</h4>
<p>这个函数在dispatchTouchEvent里面被反复使用我们来看看长什么样</p>
<pre><code class="hljs language-ini" lang="ini">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled<span class="hljs-comment">;</span>

//如果cancel为true，分发CANCEL事件，对应之前MOVE分发代码的片段
/*
 final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                       || intercepted<span class="hljs-comment">;</span>
if (dispatchTransformedTouchEvent(ev, cancelChild,target.child, target.pointerIdBits)) {
                    <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;}</span>
*/                
    final int <span class="hljs-attr">oldAction</span> = event.getAction()<span class="hljs-comment">;</span>
    if (cancel || <span class="hljs-attr">oldAction</span> == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL)<span class="hljs-comment">;</span>
        if (<span class="hljs-attr">child</span> == null) {
            <span class="hljs-attr">handled</span> = super.dispatchTouchEvent(event)<span class="hljs-comment">;</span>
        } else {
            <span class="hljs-attr">handled</span> = child.dispatchTouchEvent(event)<span class="hljs-comment">;</span>
        }
        //这里进行还原事件处理，防止给后面的View分发CANCEL事件
        event.setAction(oldAction)<span class="hljs-comment">;</span>
        return handled<span class="hljs-comment">;</span>
    }
//-----------正常情况 可以看到都是调用dispatchTouchEvent方法的逻辑-----------------
    // Calculate the number of pointers to deliver.
    final int <span class="hljs-attr">oldPointerIdBits</span> = event.getPointerIdBits()<span class="hljs-comment">;</span>
    final int <span class="hljs-attr">newPointerIdBits</span> = oldPointerIdBits &amp; desiredPointerIdBits<span class="hljs-comment">;</span>


    if (<span class="hljs-attr">newPointerIdBits</span> == <span class="hljs-number">0</span>) {
        return false<span class="hljs-comment">;</span>
    }

    final MotionEvent transformedEvent<span class="hljs-comment">;</span>
    if (<span class="hljs-attr">newPointerIdBits</span> == oldPointerIdBits) {
        if (<span class="hljs-attr">child</span> == null || child.hasIdentityMatrix()) {
            if (<span class="hljs-attr">child</span> == null) {
                <span class="hljs-attr">handled</span> = super.dispatchTouchEvent(event)<span class="hljs-comment">;</span>
            } else {
                final float <span class="hljs-attr">offsetX</span> = mScrollX - child.mLeft<span class="hljs-comment">;</span>
                final float <span class="hljs-attr">offsetY</span> = mScrollY - child.mTop<span class="hljs-comment">;</span>
                event.offsetLocation(offsetX, offsetY)<span class="hljs-comment">;</span>

                <span class="hljs-attr">handled</span> = child.dispatchTouchEvent(event)<span class="hljs-comment">;</span>

                event.offsetLocation(-offsetX, -offsetY)<span class="hljs-comment">;</span>
            }
            return handled<span class="hljs-comment">;</span>
        }
        <span class="hljs-attr">transformedEvent</span> = MotionEvent.obtain(event)<span class="hljs-comment">;</span>
    } else {
        <span class="hljs-attr">transformedEvent</span> = event.split(newPointerIdBits)<span class="hljs-comment">;</span>
    }

    // Perform any necessary transformations and dispatch.
    if (<span class="hljs-attr">child</span> == null) {
        <span class="hljs-attr">handled</span> = super.dispatchTouchEvent(transformedEvent)<span class="hljs-comment">;</span>
    } else {
        final float <span class="hljs-attr">offsetX</span> = mScrollX - child.mLeft<span class="hljs-comment">;</span>
        final float <span class="hljs-attr">offsetY</span> = mScrollY - child.mTop<span class="hljs-comment">;</span>
        transformedEvent.offsetLocation(offsetX, offsetY)<span class="hljs-comment">;</span>
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix())<span class="hljs-comment">;</span>
        }

        <span class="hljs-attr">handled</span> = child.dispatchTouchEvent(transformedEvent)<span class="hljs-comment">;</span>
    }

    // Done.
    transformedEvent.recycle()<span class="hljs-comment">;</span>
    return handled<span class="hljs-comment">;</span>
}
</code></pre>
<p>我们发现这个方法也是通过handled变量返回布尔值</p>
<h3 data-id="heading-14">View的dispatchTouchEvent</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> {
    <span class="hljs-comment">// If the event should be handled by accessibility focus first.</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.isTargetAccessibilityFocus()) {
        <span class="hljs-comment">// We don't have focus or no virtual descendant has it, do not handle the event.</span>
        <span class="hljs-keyword">if</span> (!isAccessibilityFocusedViewOrHost()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-comment">// We have focus and got the event, then use normal event dispatch.</span>
        <span class="hljs-keyword">event</span>.setTargetAccessibilityFocus(<span class="hljs-literal">false</span>);
    }
    boolean result = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (mInputEventConsistencyVerifier != <span class="hljs-literal">null</span>) {
        mInputEventConsistencyVerifier.onTouchEvent(<span class="hljs-keyword">event</span>, <span class="hljs-number">0</span>);
    }

    final <span class="hljs-built_in">int</span> actionMasked = <span class="hljs-keyword">event</span>.getActionMasked();
    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) {
        <span class="hljs-comment">// 新手势开始，停止之前的嵌套滚动（如清理之前的滑动惯性）</span>
        stopNestedScroll();
    }
 -----------------------------------关键代码---------------------------------------------
<span class="hljs-comment">//onFilterTouchEventForSecurity：这是一个安全机制。如果系统检测到当前 View 上方覆盖了不安全的窗口（例如透明悬浮窗），为了保护隐私，可能会直接丢弃该事件。</span>
    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(<span class="hljs-keyword">event</span>)) {
       
<span class="hljs-comment">// 如果用户点在滚动条上并尝试拖拽，滚动条逻辑会先“截活”，result 变为 true。       </span>
        <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(<span class="hljs-keyword">event</span>)) {
            result = <span class="hljs-literal">true</span>;
        }
<span class="hljs-comment">/*优先级最高。
只要满足：
设置了 OnTouchListener。
View 处于 Enabled 状态（注意：禁用的 View 无法触发 onTouch）。
onTouch 返回了 true。
那么 result 为 true，后续的 onTouchEvent 就不会被执行了
*/</span>            
        ListenerInfo li = mListenerInfo;
        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span>
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
&amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) {
            result = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(<span class="hljs-keyword">event</span>)) {
            result = <span class="hljs-literal">true</span>;
        }
    }
---------------------------------------------------------------------------------------    
    
<span class="hljs-comment">// 如果没有 View 消费事件，记录到校验器</span>
    <span class="hljs-keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="hljs-literal">null</span>) {
        mInputEventConsistencyVerifier.onUnhandledEvent(<span class="hljs-keyword">event</span>, <span class="hljs-number">0</span>);
    }

<span class="hljs-comment">// 判定手势是否结束</span>
    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>我们看到View的dispatchTouchEvent方法多次调用了<strong>onTouchEvent</strong>方法再看看这个方法</p>
<h2 data-id="heading-15">View的onTouchEvent</h2>
<p>关键代码部分：</p>
<h4 data-id="heading-16"><strong>可点击状态下的处理</strong></h4>
<p>只要可点击，就消费事件</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">final</span> boolean clickable <span class="hljs-operator">=</span> ((viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">CLICKABLE</span>) <span class="hljs-operator">==</span> <span class="hljs-type">CLICKABLE</span>
        <span class="hljs-operator">||</span> (viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">LONG_CLICKABLE</span>) <span class="hljs-operator">==</span> <span class="hljs-type">LONG_CLICKABLE</span>)
        <span class="hljs-operator">||</span> (viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">CONTEXT_CLICKABLE</span>) <span class="hljs-operator">==</span> <span class="hljs-type">CONTEXT_CLICKABLE</span>;

<span class="hljs-comment">// ... 在方法末尾 ...</span>
<span class="hljs-keyword">if</span> (clickable <span class="hljs-operator">||</span> (viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">TOOLTIP</span>) <span class="hljs-operator">==</span> <span class="hljs-type">TOOLTIP</span>) {
    <span class="hljs-comment">// ... switch case ...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要 View 是可点击的，onTouchEvent 就会返回 true</span>
}
</code></pre>
<p>这是 Android 事件分发的一个重要结论：<strong>一个可点击的 View（如</strong> <strong>Button</strong> <strong>）在</strong> <strong><code>onTouchEvent</code></strong> <strong>中默认会消耗掉所有事件</strong>。即使它是 <code>DISABLED</code>（禁用）状态，只要它是 <code>CLICKABLE</code> 的，它依然会返回 <code>true</code>，防止事件穿透到下层</p>
<h5 data-id="heading-17">ACTION_DOWN：</h5>
<pre><code class="hljs language-scss" lang="scss">boolean isInScrollingContainer = <span class="hljs-built_in">isInScrollingContainer</span>();
if (isInScrollingContainer) {
    mPrivateFlags |= PFLAG_PREPRESSED;
    <span class="hljs-comment">// ... 发送一个延时 100ms 的 Tap 任务 ...</span>
    <span class="hljs-built_in">postDelayed</span>(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
} else {
    <span class="hljs-built_in">setPressed</span>(true, x, y); <span class="hljs-comment">// 不在滑动容器，立即显示按下状态</span>
    <span class="hljs-built_in">checkForLongClick</span>(...); <span class="hljs-comment">// 开始长按计时</span>
}
</code></pre>
<ul>
<li>如果 View 在 <code>ScrollView</code> 等滑动容器中，系统会<strong>延迟显示</strong>按下状态（100ms）。这是为了防止用户只是想滑动，结果手指一碰按钮就闪现按下效果。</li>
<li>如果不在滑动容器，立即调用 <code>setPressed(true)</code> 变色，并开启长按定时器。</li>
</ul>
<h5 data-id="heading-18">ACTION_MOVE：</h5>
<pre><code class="hljs language-scss" lang="scss">if (!pointInView(x, y, touchSlop)) {
    <span class="hljs-comment">// 只要手指移出了 View 的范围（加上系统允许的微小偏差 touchSlop）</span>
    <span class="hljs-built_in">removeTapCallback</span>();
    <span class="hljs-built_in">removeLongPressCallback</span>();
    if ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">setPressed</span>(false); <span class="hljs-comment">// 取消按下状态</span>
    }
}
</code></pre>
<p>系统允许用户在点击时有轻微的晃动（<code>touchSlop</code>）。但一旦手指移出 View 范围，长按和点击逻辑都会被取消，按钮也会变回原来的颜色。</p>
<h5 data-id="heading-19">ACTION_UP：</h5>
<pre><code class="hljs language-scss" lang="scss">if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
    <span class="hljs-built_in">removeLongPressCallback</span>(); <span class="hljs-comment">// 移除长按计时</span>
    <span class="hljs-comment">// ...</span>
    if (!post(mPerformClick)) {
        <span class="hljs-built_in">performClickInternal</span>(); <span class="hljs-comment">// 真正触发 OnClickListener.onClick() 的地方</span>
    }
}
</code></pre>
<ul>
<li><strong>优先级判定</strong>：如果已经触发了长按（<code>mHasPerformedLongPress</code> 为 true），那么抬起时就不会再触发点击。</li>
<li><strong>异步执行</strong>：使用 <code>post(mPerformClick)</code> 是为了让 View 先完成视觉上的状态切换（变回原色），然后再执行点击逻辑，避免点击任务阻塞了 UI 的状态更新。</li>
</ul>
<h5 data-id="heading-20">ACTION_CANCEL</h5>
<pre><code class="hljs language-scss" lang="scss">case MotionEvent<span class="hljs-selector-class">.ACTION_CANCEL</span>:
    if (clickable) {
        <span class="hljs-built_in">setPressed</span>(false);
    }
    <span class="hljs-built_in">removeTapCallback</span>();
    <span class="hljs-built_in">removeLongPressCallback</span>();
    <span class="hljs-comment">// ... 重置所有标记位 ...</span>
    break;
</code></pre>
<p>当父容器（如 <code>RecyclerView</code>）拦截了事件时，子 View 会收到 <code>CANCEL</code>。此时必须清理掉所有的计时器和按下状态，否则 View 会一直显示“被按下”的颜色。</p>
<p>我们发现只要子View可以点击，就会返回true，这个判断下的事件状态只是执行不同的操作</p>
<p><strong>为什么是这样的判定？如果是这样的话，事件会不会看起来很容易消费？</strong></p>
<p>其实不然，首先我们要了解View的遍历逻辑，子View是根据根右左的顺序执行，并且是优先调用子View的onTouchEvent方法，如果遍历到的这个子View刚好是可点击的，就会消费事件。之后就不会遍历了，这符合我们对事件消费的期望。</p>
<p>并且在拦截的情况下也不矛盾</p>
<p>在DOWN时拦截:根本不会走遍历的操作，就不会调用子ViewonTouchEvent方法.</p>
<p>在MOVE时拦截:虽然在DOWN时形成了单向链表mFirstTouchTarget，在下一次分发MOVE事件的时候，通过</p>
<pre><code class="hljs language-ini" lang="ini">  final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                       || intercepted<span class="hljs-comment">;</span>
if (dispatchTransformedTouchEvent(ev, cancelChild,target.child, target.pointerIdBits)) {
                    <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;}</span>
</code></pre>
<p>给子View分发CANCEL事件(取消该View的按下状态,计时器等等)，并且清空链表，之后这个View就不会接收事件了</p>
<p>[<strong>对于这一帧“物理上的 MOVE 事件”，它的“移动数据”确实没有被任何 View 消费，被消费的仅仅是由它转化而来的“CANCEL 信号”。</strong> ]</p>
<h4 data-id="heading-21">禁用状态下的处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED ...) {
    <span class="hljs-comment">// ... 抬起时清除按下状态 ...</span>
    <span class="hljs-keyword">return</span> clickable; 
}
</code></pre>
<p>如果 View 是禁用的（Disabled），它不会响应点击逻辑，但如果它原本是可点击的，它依然返回 <code>true</code>。<strong>这解释了为什么点击一个禁用的按钮，下方的布局不会收到点击事件。</strong></p>
<h4 data-id="heading-22">OnTouchListener和OnClickListener</h4>
<p>定位到View的dispatchTouchEvent方法中的这段代码：</p>
<pre><code class="hljs language-ini" lang="ini">if (li != null &amp;&amp; li.mOnTouchListener != null
        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
        &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
    <span class="hljs-attr">result</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}

if (!result &amp;&amp; onTouchEvent(event)) {
    <span class="hljs-attr">result</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}
</code></pre>
<p>在dispatchTouchEvent中，会判断View是否设置了OnTouchListener，如果设置了OnTouchListener，就会直接拦截事件，dispatchTouchEvent方法返回true，调用OnTouchListener的onTouch方法，而不会再触发后续的onTouchEvent方法。</p>
<p>再定位到View的onTouchEvent方法中的这段代码：</p>
<pre><code class="hljs language-scss" lang="scss">if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) {
    switch (action) {          
        case MotionEvent<span class="hljs-selector-class">.ACTION_UP</span>:
            if (!<span class="hljs-built_in">post</span>(mPerformClick)) {
                <span class="hljs-built_in">performClickInternal</span>();
            }
</code></pre>
<p>可以发现是在onTouchEvent方法中，判断了View是否可点击。若可点击且设置了OnClickListener，那么就会调用OnClickListener的onClick方法。</p>
<p><strong>按优先级排序，OnTouchListener&gt;OnTouchEvent&gt;OnClickListener。若设置了OnTouchListener，则不会触发后面两者。OnClickListener在ACTION_UP后触发。</strong></p>
<h2 data-id="heading-23">ViewGroup的onInterceptTouchEvent</h2>
<pre><code class="hljs language-scss" lang="scss">public boolean <span class="hljs-built_in">onInterceptTouchEvent</span>(MotionEvent ev) {
    <span class="hljs-comment">// 条件 1: 事件来源必须是鼠标 (MOUSE)</span>
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            <span class="hljs-comment">// 条件 2: 动作必须是按下 (ACTION_DOWN)</span>
            &amp;&amp; ev<span class="hljs-selector-class">.getAction</span>() == MotionEvent<span class="hljs-selector-class">.ACTION_DOWN</span>
            <span class="hljs-comment">// 条件 3: 必须是鼠标左键 (BUTTON_PRIMARY)</span>
            &amp;&amp; ev<span class="hljs-selector-class">.isButtonPressed</span>(MotionEvent.BUTTON_PRIMARY)
            <span class="hljs-comment">// 条件 4: 点击的位置必须在滚动条的“滑块”上 (Scrollbar Thumb)</span>
            &amp;&amp; <span class="hljs-built_in">isOnScrollbarThumb</span>(ev.getXDispatchLocation(<span class="hljs-number">0</span>), ev<span class="hljs-selector-class">.getYDispatchLocation</span>(<span class="hljs-number">0</span>))) {
        
        <span class="hljs-comment">// 如果上述 4 个条件同时满足，返回 true，表示拦截该事件</span>
        return true;
    }
    
    <span class="hljs-comment">// 默认情况（比如手指触摸、点击非滚动条区域等）返回 false</span>
    return false;
}
</code></pre>
<p>好文章推荐可以和这个做补充
<a href="https://juejin.cn/post/7168445102984003591" target="_blank" title="https://juejin.cn/post/7168445102984003591">Android斩首行动—滑动冲突作为移动开发，我们对滑动冲突可以说是屡见不鲜。这篇文章结合事件分发机制，对常见的滑动冲突 - 掘金</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[openClaw安装飞书插件｜核心踩坑：spawn EINVAL 错误终极解决指南]]></title>    <link>https://juejin.cn/post/7605529884824567871</link>    <guid>https://juejin.cn/post/7605529884824567871</guid>    <pubDate>2026-02-12T16:30:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605529884824567871" data-draft-id="7605807405306675263" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="openClaw安装飞书插件｜核心踩坑：spawn EINVAL 错误终极解决指南"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-12T16:30:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MicRabbit"/> <meta itemprop="url" content="https://juejin.cn/user/4135726601221641"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            openClaw安装飞书插件｜核心踩坑：spawn EINVAL 错误终极解决指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4135726601221641/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MicRabbit
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T16:30:03.000Z" title="Thu Feb 12 2026 16:30:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为经常折腾本地工具的开发者，最近在部署openClaw飞书插件时，被 <code>spawn EINVAL</code> 报错卡了一下午！结合自己的实际操作，整理了这篇<strong>重点聚焦该错误</strong>的踩坑分享，从错误原因、无效误区、详细解决步骤，到兜底方案，全程干货，帮正在踩坑的小伙伴一次性解决，少走弯路！</p>
<p>先说明我的环境：Windows 和 Mac 环境都遇到同样问题，作为偏前端开发两个环境均安装了nvm管理Node版本，核心需求是本地部署openClaw飞书插件（自用机器人调试），无复杂部署场景，所有操作均为本地调试可用，新手也能跟着走。</p>
<p>OpenClaw的安装步骤就不重复了，跟着官网走就可以。</p>
<p>翻阅资料和看其他博主的视频时发现飞书插件安装时都没遇到我的问题，所以在解决问题之后反思了一下，大概率是我的Node环境是安装在nvm内的（该观点并未重复验证），先进入正文</p>
<h2 data-id="heading-0">一、核心报错：spawn EINVAL（必踩坑，先认清错误本质）</h2>
<p>这是openClaw安装飞书插件时最高频、最棘手的错误，很多小伙伴会被网上的过时方案误导，白费功夫。先明确错误的完整现象和核心原因，避免走偏。</p>
<h3 data-id="heading-1">❌ 完整错误现象（对照自查，确认你踩的是同一个坑）</h3>
<p>执行飞书插件安装命令 <code>openclaw plugins install @openclaw/feishu</code> 后，终端立即报错，无法继续安装，完整报错堆栈如下（重点标注核心错误 <code>spawn EINVAL</code>）：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5a9fbc147234a2db8eea1d8e1632e72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=hvl2FtEBBo9C9xpg5rXNE6AGjsI%3D" alt="image.png" loading="lazy"/></p>
<p>核心特征：报错首行提示 <code>Failed to start CLI: Error: spawn EINVAL</code>，后续关联 <code>child_process.spawn</code> 相关堆栈，插件安装直接中断，重复执行命令依然报错。</p>
<h3 data-id="heading-2">🔍 错误核心原因（关键！搞懂原因才不会被误导）</h3>
<p>很多教程说“Node版本过高导致”，其实是错误的！结合我的排查和实操验证，核心原因是：</p>
<p><strong>openClaw飞书插件本地扩展包（feishu文件夹）中的 package.json 配置不兼容</strong> —— 该配置文件中，依赖版本、入口文件路径或脚本命令存在异常，导致Node.js的 <code>child_process.spawn</code> 方法无法正常创建子进程，进而启动CLI失败，报出 <code>spawn EINVAL</code>（无效参数）错误。</p>
<p>补充：该错误与Node版本无关（我用v22，只要修改配置，均可解决），无需降级Node，白费功夫的操作一定要避开。</p>
<h3 data-id="heading-3">❌ 网上常见无效尝试（别再踩！亲测3次均失败）</h3>
<p>一开始看到报错，我跟着网上的教程做了3种尝试，均无效，整理出来帮大家避坑：</p>
<ol>
<li>Node版本降级：用nvm降级到v20、v18，清理npm缓存、重新安装openClaw，报错依然存在；</li>
<li>直接重新安装插件：反复执行 <code>openclaw plugins install @openclaw/feishu</code>，甚至卸载重装openClaw，无法解决配置不兼容问题；</li>
<li>非管理员终端安装：未用管理员身份运行终端，导致权限不足，但即使提升权限，不修改配置依然报错（权限不是核心原因）。</li>
</ol>
<h3 data-id="heading-4">✅ 终极解决方案（亲测有效，分步拆解，新手可跟）</h3>
<p>核心逻辑：找到异常的 package.json 文件 → 备份并修改配置 → 本地重装插件 → 重启验证，步骤清晰，一步到位，全程无需降级Node。</p>
<p><strong>第一步：精准定位目标 package.json 文件（关键第一步，别找错路径）</strong> 该文件在openClaw的飞书插件扩展包中，路径根据你的nvm安装位置调整，我的路径如下（可直接复制，替换用户名即可）：<code>C:\nvm4w\nodejs\node_modules\openclaw\extensions\feishu</code>（MacOS找到对应的nvm目录内的openClaw的插件目录）操作：打开文件资源管理器，将上述路径粘贴到地址栏，回车即可快速定位，文件夹中会看到 <code>package.json</code> 文件（核心修改文件）。</p>
<p><strong>第二步：备份文件+修改配置（避免出错，重中之重）</strong> ① 备份文件：复制一份 <code>package.json</code> 文件，重命名为 <code>package.json.bak</code>（万一修改错误，可直接恢复原文件，避免插件彻底损坏）；② 修改配置：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c098bb4549ab40cf8ad09672c59fe1a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=zjQCWGTQWgMT13w362DTGnlPtT8%3D" alt="image.png" loading="lazy"/></p>
<p>修改这里 将 workspace:* 去掉</p>
<pre><code class="hljs language-json" lang="json">  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
     <span class="hljs-attr">"openclaw"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span> 
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<p>从这里的修改上我怀疑导致报错的根本原因是：我本机环境安装的nvm 导致 workspace:* 的目录检查失败了</p>
<p><strong>第三步：安装openclaw官方文档使用本地代码安装飞书渠道</strong></p>
<p>openclaw官方文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.openclaw.ai%2Fzh-CN%2Fchannels%2Ffeishu" target="_blank" title="https://docs.openclaw.ai/zh-CN/channels/feishu" ref="nofollow noopener noreferrer">docs.openclaw.ai/zh-CN/chann…</a></p>
<p>使用本地安装的方式：
① 打开cmd或者powershell 进入飞书插件目录
② 使用npm i或者pnpm i安装依赖</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5789321323894f08a6a479f0688b9361~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=f2kbfOk9zVnMMiMxwnf8O5L8TCo%3D" alt="image.png" loading="lazy"/></p>
<p>至此 飞书插件安装成功！</p>
<p><strong>第四步：重启openclaw验证错误是否修复，并配置飞书</strong></p>
<p>① 重启openClaw： openclaw onboard 在Select channel时选择飞书</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9327f484e24744ad87db6850d0beb423~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=Qf%2FbMKa68nvDLJRhor67Z39ct9c%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b701b5925588407b97d19e2f77b6149a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=eeu2f5ctaZfiYkwK9iwGldMyDZM%3D" alt="image.png" loading="lazy"/></p>
<p>选择后不报错 可以配置飞书应用的 App ID 和  App Secret，即可在飞书创建应用并链接openclaw进行会话了！</p>
<h3 data-id="heading-5">🔧 兜底方案（若修改配置后仍报错，直接用这个）</h3>
<p>若按上述步骤操作后，依然报 <code>spawn EINVAL</code> 错误，大概率是 package.json 修改不到位，可直接用以下兜底方案，绕开配置修改难题：</p>
<ol>
<li>卸载当前飞书插件：<code>openclaw plugins uninstall @openclaw/feishu</code>；</li>
<li>删除feishu扩展包：删除 <code>C:\nvm4w\nodejs\node_modules\openclaw\extensions\feishu</code> 整个文件夹；</li>
<li>手动克隆插件源码：执行 <code>git clone https://github.com/openclaw/feishu.git</code>，将克隆后的feishu文件夹，复制到上述extensions目录下；</li>
<li>本地安装：进入feishu文件夹，执行 <code>npm install</code> 安装依赖，再执行 <code>openclaw plugins install ./</code>，重启openClaw即可。</li>
</ol>
<h2 data-id="heading-6">二、补充：报错解决后，简单配置（快速适配本地自用）</h2>
<p>重点分享报错处理，配置部分精简核心要点，无需深入，快速完成部署：</p>
<ul>
<li>Feishu DM policy（私信策略）：选<code>Pairing (recommended)</code>（配对模式），用户主动打招呼才能发私信，安全不骚扰；</li>
<li>Group chat policy（群聊策略）：选 <code>Allowlist</code>（白名单模式），只在自己的测试群响应，避免滥用；</li>
<li>Group chat allowlist（群聊白名单）：复制飞书群ID（群设置→最底部），多个群用英文逗号隔开，留空即禁用群聊响应；</li>
<li>feishu account name (default)：直接按回车，用默认账号即可，本地自用无需修改。</li>
</ul>
<h2 data-id="heading-7">三、核心总结（重点牢记，下次遇到直接解决）</h2>
<p>整篇分享聚焦 <code>spawn EINVAL</code> 错误，记住3个核心要点，下次遇到无需查教程：</p>
<ol>
<li>错误本质：飞书插件的 package.json 配置不兼容，与Node版本无关，无需降级；</li>
<li>核心解决：定位 → 备份修改 package.json → 管理员本地重装 → 重启验证；</li>
<li>兜底方案：删除异常扩展包，手动克隆源码安装，100%解决配置问题。</li>
</ol>
<h2 data-id="heading-8">四、最后碎碎念</h2>
<p>其实 <code>spawn EINVAL</code> 报错并不难解决，踩坑主要是因为网上部分解决方案过时，误导大家去降级Node。希望这篇重点聚焦该错误的分享，能帮到正在折腾openClaw飞书插件的小伙伴，避开无效操作，快速解决问题。</p>
<p>如果大家遇到了其他相关报错，或者有更简洁的解决方法，欢迎在评论区交流补充，一起少走弯路～</p>
<p>#openClaw #飞书插件 #飞书机器人 #开发者踩坑 #spawn EINVAL #本地部署 #Node.js #前端工具</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别 LLM 供应商锁定 — SmartChat 的多模型 Provider 抽象层设计实践]]></title>    <link>https://juejin.cn/post/7605811866908000265</link>    <guid>https://juejin.cn/post/7605811866908000265</guid>    <pubDate>2026-02-12T17:17:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908000265" data-draft-id="7605711582430494771" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别 LLM 供应商锁定 — SmartChat 的多模型 Provider 抽象层设计实践"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2026-02-12T17:17:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="梦里寻码"/> <meta itemprop="url" content="https://juejin.cn/user/528241507974520"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别 LLM 供应商锁定 — SmartChat 的多模型 Provider 抽象层设计实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/528241507974520/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    梦里寻码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T17:17:13.000Z" title="Thu Feb 12 2026 17:17:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>做 AI 应用最怕什么？供应商锁定。今天 OpenAI 涨价，明天某个国产模型效果更好，后天客户要求用私有化部署的模型……如果代码和某个 LLM 提供商深度耦合，每次切换都是一次重构。</p>
<p>SmartChat 通过一个 Provider 抽象层，实现了 7+ 个 LLM 提供商的无缝切换。来看看它是怎么设计的。</p>
<blockquote>
<p>🔗 <strong>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsmartchat.nofx.asia%2F" target="_blank" title="https://smartchat.nofx.asia/" ref="nofollow noopener noreferrer">smartchat.nofx.asia/</a></strong></p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a046cdc202874e49b3cbaff7691166a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qKm6YeM5a-756CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771521604&amp;x-signature=4r%2FFuGWUK0PTxlfXi6pEB4AD7lQ%3D" alt="微信图片_20260212194717_45_236.png" loading="lazy"/></p>
<h2 data-id="heading-1">一、问题：LLM 提供商的碎片化</h2>
<p>目前主流的 LLM 提供商各有各的 SDK 和 API 格式：</p>
<ul>
<li><strong>OpenAI</strong>：<code>openai</code> SDK，<code>/v1/chat/completions</code></li>
<li><strong>Anthropic</strong>：<code>@anthropic-ai/sdk</code>，<code>/v1/messages</code>，完全不同的消息格式</li>
<li><strong>国产模型</strong>：大多兼容 OpenAI 格式，但 base URL 和模型名不同</li>
</ul>
<p>如果每个提供商写一套调用逻辑，代码会变成这样：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 反面教材：硬编码每个提供商</span>
<span class="hljs-keyword">if</span> (provider === <span class="hljs-string">'openai'</span>) {
  <span class="hljs-comment">// OpenAI 的调用逻辑</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (provider === <span class="hljs-string">'anthropic'</span>) {
  <span class="hljs-comment">// Anthropic 的调用逻辑</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (provider === <span class="hljs-string">'deepseek'</span>) {
  <span class="hljs-comment">// DeepSeek 的调用逻辑</span>
} <span class="hljs-comment">// ... 无限 if-else</span>
</code></pre>
<h2 data-id="heading-2">二、SmartChat 的 Provider 抽象层</h2>
<p>SmartChat 的核心思路是：<strong>将所有提供商归为两类 SDK（OpenAI 和 Anthropic），通过预设配置 + 统一接口消除差异</strong>。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Provider 预设配置</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROVIDER_PRESETS</span> = {
  <span class="hljs-attr">openai</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.openai.com/v1'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'gpt-4o'</span>, <span class="hljs-string">'gpt-4o-mini'</span>, <span class="hljs-string">'gpt-3.5-turbo'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>
  },
  <span class="hljs-attr">deepseek</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.deepseek.com/v1'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'deepseek-chat'</span>, <span class="hljs-string">'deepseek-reasoner'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>  <span class="hljs-comment">// DeepSeek 兼容 OpenAI 格式</span>
  },
  <span class="hljs-attr">qwen</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://dashscope.aliyuncs.com/compatible-mode/v1'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'qwen-turbo'</span>, <span class="hljs-string">'qwen-plus'</span>, <span class="hljs-string">'qwen-max'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>  <span class="hljs-comment">// 通义千问也兼容 OpenAI 格式</span>
  },
  <span class="hljs-attr">anthropic</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.anthropic.com'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'claude-3-5-sonnet'</span>, <span class="hljs-string">'claude-3-haiku'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'anthropic'</span>
  },
  <span class="hljs-attr">custom</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 用户自定义</span>
    <span class="hljs-attr">models</span>: [],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>  <span class="hljs-comment">// 默认走 OpenAI 兼容协议</span>
  }
};
</code></pre>
<p>关键洞察：<strong>绝大多数国产模型都兼容 OpenAI API 格式</strong>，所以只需要维护两套 SDK 调用逻辑（OpenAI 和 Anthropic），通过切换 <code>baseURL</code> 就能接入不同提供商。</p>
<h2 data-id="heading-3">三、统一的流式输出接口</h2>
<p>不同 SDK 的流式输出格式差异很大，SmartChat 将其统一为一个 <code>streamChat</code> 函数：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">streamChat</span>(<span class="hljs-params">params: {
  provider: <span class="hljs-built_in">string</span>;
  model: <span class="hljs-built_in">string</span>;
  messages: Message[];
  apiKey: <span class="hljs-built_in">string</span>;
  temperature?: <span class="hljs-built_in">number</span>;
}</span>) {
  <span class="hljs-keyword">const</span> preset = <span class="hljs-variable constant_">PROVIDER_PRESETS</span>[params.<span class="hljs-property">provider</span>];

  <span class="hljs-keyword">if</span> (preset.<span class="hljs-property">sdk</span> === <span class="hljs-string">'openai'</span>) {
    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAI</span>({
      <span class="hljs-attr">apiKey</span>: params.<span class="hljs-property">apiKey</span>,
      <span class="hljs-attr">baseURL</span>: preset.<span class="hljs-property">baseURL</span>
    });

    <span class="hljs-keyword">return</span> client.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">model</span>: params.<span class="hljs-property">model</span>,
      <span class="hljs-attr">messages</span>: params.<span class="hljs-property">messages</span>,
      <span class="hljs-attr">temperature</span>: params.<span class="hljs-property">temperature</span>,
      <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>
    });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preset.<span class="hljs-property">sdk</span> === <span class="hljs-string">'anthropic'</span>) {
    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Anthropic</span>({ <span class="hljs-attr">apiKey</span>: params.<span class="hljs-property">apiKey</span> });

    <span class="hljs-keyword">return</span> client.<span class="hljs-property">messages</span>.<span class="hljs-title function_">stream</span>({
      <span class="hljs-attr">model</span>: params.<span class="hljs-property">model</span>,
      <span class="hljs-attr">messages</span>: <span class="hljs-title function_">convertToAnthropicFormat</span>(params.<span class="hljs-property">messages</span>),
      <span class="hljs-attr">max_tokens</span>: <span class="hljs-number">4096</span>,
      <span class="hljs-attr">temperature</span>: params.<span class="hljs-property">temperature</span>
    });
  }
}
</code></pre>
<p>上层业务代码只需要调用 <code>streamChat()</code>，完全不关心底层用的是哪个提供商。</p>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20../docs/images/screenshot-04-bot-settings.png" alt="SmartChat 机器人设置转存失败，建议直接上传图片文件" loading="lazy"/></p>
<h2 data-id="heading-4">四、自定义端点：终极灵活性</h2>
<p>SmartChat 还支持用户配置自定义的 OpenAI 兼容端点，这意味着可以接入：</p>
<ul>
<li><strong>本地部署的模型</strong>：Ollama、vLLM、LocalAI</li>
<li><strong>企业私有化部署</strong>：Azure OpenAI、AWS Bedrock（通过兼容层）</li>
<li><strong>任何 OpenAI 兼容的 API</strong>：各种代理、中转服务</li>
</ul>
<p>用户只需在设置页面填入 base URL、API Key 和模型名称即可。</p>
<h2 data-id="heading-5">五、成本优化策略</h2>
<p>多模型架构带来的一个隐藏好处是<strong>成本优化</strong>：</p>
<pre><code class="hljs">简单问题 → 使用便宜的模型（DeepSeek、Qwen-Turbo）
复杂问题 → 使用强力模型（GPT-4o、Claude Sonnet）
嵌入向量 → 使用本地模型（零成本）
</code></pre>
<p>每个机器人可以独立配置模型和参数，运营者可以根据业务场景灵活调整。</p>
<h2 data-id="heading-6">六、这个设计模式的可复用性</h2>
<p>SmartChat 的 Provider 抽象层设计模式可以直接复用到其他 AI 应用中。核心思路总结：</p>
<ol>
<li><strong>识别 SDK 家族</strong>：大多数提供商属于 OpenAI 兼容或 Anthropic 两个家族</li>
<li><strong>预设配置驱动</strong>：用配置而非代码来区分提供商</li>
<li><strong>统一接口</strong>：上层业务只依赖抽象接口</li>
<li><strong>自定义端点兜底</strong>：覆盖所有长尾场景</li>
</ol>
<h2 data-id="heading-7">总结</h2>
<p>LLM 领域变化太快，今天的最优选择明天可能就不是了。SmartChat 的多模型架构不是过度设计，而是对现实的务实应对。如果你也在做 AI 应用，强烈建议从第一天就做好 Provider 抽象。</p>
<blockquote>
<p>🔗 <strong>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsmartchat.nofx.asia%2F" target="_blank" title="https://smartchat.nofx.asia/" ref="nofollow noopener noreferrer">smartchat.nofx.asia/</a></strong>，MIT 开源协议。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>