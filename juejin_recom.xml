<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[C#/.NET/.NET Core技术前沿周刊 | 第 60 期（2025年11.1-11.9）]]></title>    <link>https://juejin.cn/post/7570902804451475466</link>    <guid>https://juejin.cn/post/7570902804451475466</guid>    <pubDate>2025-11-10T12:03:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804451475466" data-draft-id="7570912420567744522" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C#/.NET/.NET Core技术前沿周刊 | 第 60 期（2025年11.1-11.9）"/> <meta itemprop="keywords" content="后端,.NET"/> <meta itemprop="datePublished" content="2025-11-10T12:03:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="追逐时光者"/> <meta itemprop="url" content="https://juejin.cn/user/2770425031690333"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C#/.NET/.NET Core技术前沿周刊 | 第 60 期（2025年11.1-11.9）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2770425031690333/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    追逐时光者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:03:25.000Z" title="Mon Nov 10 2025 12:03:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/43a29eaf433a41e99b3836c7caf5a516~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=02RmGren4qCBIuicXq0AsqbFjkg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">前言</h2>
<p>C#/.NET/.NET Core技术前沿周刊，你的每周技术指南针！记录、追踪C#/.NET/.NET Core领域、生态的每周最新、最实用、最有价值的技术文章、社区动态、优质项目和学习资源等。让你时刻站在技术前沿，助力技术成长与视野拓宽。</p>
<blockquote>
<p>欢迎投稿、推荐或自荐优质文章、项目、学习资源等。</p>
</blockquote>
<ul>
<li><strong>🏆技术前沿周刊Gitee开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fysgdaydayup%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetWeekly.md" target="_blank" title="https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md" ref="nofollow noopener noreferrer">gitee.com/ysgdaydayup…</a></li>
<li><strong>📰技术前沿周刊GitHub开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYSGStudyHards%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetWeekly.md" target="_blank" title="https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md" ref="nofollow noopener noreferrer">github.com/YSGStudyHar…</a></li>
</ul>
<h2 data-id="heading-1">C#/.NET/.NET Core优秀项目和框架2025年10月简报</h2>
<ul>
<li><strong>文章简介：</strong> 公众号每月定期推广和分享的C#/.NET/.NET Core优秀项目和框架（每周至少会推荐两个优秀的项目和框架当然节假日除外），公众号推文中有项目和框架的详细介绍、功能特点、使用方式以及部分功能截图等（打不开或者打开GitHub很慢的同学可以优先查看公众号推文，文末一定会附带项目和框架源码地址）。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FDB1UBuiS2BvZjf7VlH0_MQ" target="_blank" title="https://mp.weixin.qq.com/s/DB1UBuiS2BvZjf7VlH0_MQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/DB1UBuiS2…</a></li>
</ul>
<h2 data-id="heading-2">事半功倍：.NET 开发者的 Visual Studio 效率技巧！</h2>
<ul>
<li><strong>文章简介：</strong> 本文大姚将为你分享一些 Visual Studio 的使用技巧和建议，旨在帮助 .NET 开发者更加高效地利用 Visual Studio 进行编程开发工作。无论你是 .NET 初学者还是经验丰富的 .NET 开发者，这些技巧都将有助于提升你的工作效率，让你能够更快地编写出高质量的代码。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FyHAK0VvcOR8bqZVqOBizXQ" target="_blank" title="https://mp.weixin.qq.com/s/yHAK0VvcOR8bqZVqOBizXQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/yHAK0VvcO…</a></li>
</ul>
<h2 data-id="heading-3">【拾遗补漏】.NET 常见术语集</h2>
<ul>
<li><strong>文章简介：</strong> .NET 常见术语集旨在为 .NET 初学者提供一份清晰的入门指引，也为经验丰富的 .NET 开发者提供一份便捷的参考，帮助大家更准确地表达、更高效地学习、更深入地探索 .NET 的强大功能（有遗漏的欢迎文末留言）。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2FCan-daydayup%2Fp%2F19193323" target="_blank" title="https://www.cnblogs.com/Can-daydayup/p/19193323" ref="nofollow noopener noreferrer">www.cnblogs.com/Can-daydayu…</a></li>
</ul>
<h2 data-id="heading-4">一款基于 .NET WinForm 开源、轻量且功能强大的节点编辑器</h2>
<ul>
<li><strong>文章简介：</strong> STNodeEditor 是一款基于 .NET WinForm 开源免费（MIT License）、轻量且功能强大的节点编辑器，采用纯 GDI+ 绘制无任何依赖库仅仅100+Kb，提供了丰富的属性以及事件，可以非常方便的完成节点之间数据的交互及通知，编辑器内置了大量虚函数，供开发者根据需求进行重写，赋予了极高的自由度和定制能力。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfMG3iAu1Y0Fkmf6d-fcgiA" target="_blank" title="https://mp.weixin.qq.com/s/fMG3iAu1Y0Fkmf6d-fcgiA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/fMG3iAu1Y…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc08d40683fa477e8650ce425439488d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=vcdiT%2FJjvahnXVpAR%2FRfeU15dtM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">一款 .NET 开源（GPL-3.0 license）、免费、现代的远程会话管理和启动器</h2>
<ul>
<li><strong>文章简介：</strong> 1Remote 是一个现代化的个人远程会话管理和启动器，适用于需要管理多种不同协议远程会话的用户。无论是系统管理员、开发人员还是IT支持人员，都可以通过1Remote在一个集中的地方管理他们的所有远程连接，提高工作效率和便利性。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F4PIKVLGLkOsvSJJO9InvXA" target="_blank" title="https://mp.weixin.qq.com/s/4PIKVLGLkOsvSJJO9InvXA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/4PIKVLGLk…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f16c45ff1bbb482694f0b734b8c887c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=InIjYF7OsUCLt68OEaIhv7ZSPa0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">ASP.NET Core 部署进化史：从 Windows IIS 到 Docker，再到国产 Linux 容器化实践</h2>
<ul>
<li><strong>文章简介：</strong> ASP.NET Core 部署进化史：从 Windows IIS 到 Docker，再到国产 Linux 容器化实践。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqxBAzom3He-Lk7hQr7T7bQ" target="_blank" title="https://mp.weixin.qq.com/s/qxBAzom3He-Lk7hQr7T7bQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/qxBAzom3H…</a></li>
</ul>
<h2 data-id="heading-7">深入探索C# Channels：高级模式与实战指南</h2>
<ul>
<li><strong>文章简介：</strong> 我们已经介绍了基础知识，包括类型、循环，甚至一些实际应用场景。现在，您应该对生产者、消费者、完成和取消操作感到熟悉了。但 Channels 就像一座冰山；您目前所见的仅是冰山一角。其底层隐藏着高级模式，如果能够恰当地运用（或避免使用），它们能让您的系统发挥出卓越的性能。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fjhu0IEk_4D1n-cJocPLMbA" target="_blank" title="https://mp.weixin.qq.com/s/jhu0IEk_4D1n-cJocPLMbA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/jhu0IEk_4…</a></li>
</ul>
<h2 data-id="heading-8">一个开源、精美的 WPF 用户界面</h2>
<ul>
<li><strong>文章简介：</strong> WPFUIDemo 是一个专注于 WPF（Windows Presentation Foundation）用户界面设计与开发的示例项目。该项目旨在为开发者提供一个全面、实用的参考范例，帮助他们快速掌握 WPF 应用开发的核心技巧和最佳实践，提升开发效率与界面设计水平。通过丰富的功能模块和代码示例，开发者可以深入了解 WPF 的强大特性，并将其灵活应用于实际项目中。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F15oTrGmLzGl4AAUV6maIgw" target="_blank" title="https://mp.weixin.qq.com/s/15oTrGmLzGl4AAUV6maIgw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/15oTrGmLz…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a24154ae6baf4a4abe006b250011e0aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=8o%2Bl%2BjX7g6ofRRlwWg7bi7C6q%2BI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">一款基于 .NET 8 + Vue 前后端分离的快速开发框架，解决 70% 的重复工作！</h2>
<ul>
<li><strong>文章简介：</strong> ZrAdminNetCore 是一款基于前后端分离架构、跨平台部署的通用权限管理后台系统，采用 RBAC（Role-Based Access Control） 权限模型设计，支持多租户、动态菜单、细粒度权限控制等功能。项目以 .NET Core 为后端技术栈，结合现代化前端框架构建，适用于企业级中后台管理系统快速开发。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FilK-HScDVxb9tBykwgP_JQ" target="_blank" title="https://mp.weixin.qq.com/s/ilK-HScDVxb9tBykwgP_JQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/ilK-HScDV…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b10e69eb50b34b46a44e7a6e49522c35~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=oPvimKfOYTCAyP03fo7uZ%2FyuBU0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f8875103a4d4b548847114e259a4e5f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=RTruBica7oXG6cFg4A4%2Bvxl8BoI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">【译】Avalonia UI与谷歌Flutter团队合作将Impeller渲染引擎引入.NET</h2>
<ul>
<li><strong>文章简介：</strong> 我们激动地宣布阿瓦洛尼亚在渲染技术道路上迎来一个重要里程碑。我们的团队正与谷歌Flutter工程师合作，将其下一代"GPU优先"渲染器Impeller引入.NET开发者生态。这项技术合作旨在突破跨平台性能边界，展现开源社区如何通过协作创造更大价值。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBQz1GrnknYqlAMujSJQ55A" target="_blank" title="https://mp.weixin.qq.com/s/BQz1GrnknYqlAMujSJQ55A" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/BQz1Grnkn…</a></li>
</ul>
<h2 data-id="heading-11">一款 .NET 开源免费、功能全面的串口调试神器，工控必备效率工具！</h2>
<ul>
<li><strong>文章简介：</strong> BYSerial 是一款功能全面、用户友好的串口调试工具，适用于工控领域、物联网开发、嵌入式系统开发等多种场景。项目开源免费（MIT License），支持多语言切换、自动更新、自定义快捷命令等功能，是工控领域必备的效率工具。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6aJr_eT1kFCgvBvILXHkXQ" target="_blank" title="https://mp.weixin.qq.com/s/6aJr_eT1kFCgvBvILXHkXQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/6aJr_eT1k…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87c8079ad7a34f52857d19b403b3552f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=BMcKIQQlkPErIQrkouOP2Cbq2Fg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-12">.NET 搞 AI 不行？</h2>
<ul>
<li><strong>文章简介：</strong> 今天，我要告诉你一个被严重低估的事实：.NET开发者不仅能做AI，而且可能是最适合把AI落地到生产环境的那群人。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fsheng-jie%2Fp%2F19200934" target="_blank" title="https://www.cnblogs.com/sheng-jie/p/19200934" ref="nofollow noopener noreferrer">www.cnblogs.com/sheng-jie/p…</a></li>
</ul>
<h2 data-id="heading-13">从零开始:C#与C++函数传参——调包侠秘籍</h2>
<ul>
<li><strong>文章简介：</strong> 在日常开发中，C# 和 C++ 都是非常强大的编程语言。C# 有着简洁的语法和强大的框架支持，而 C++ 在性能和底层操作上有着独特的优势。有时候，我们可能需要在 C# 项目中调用 C++ 编写的高性能函数，比如处理复杂的图像算法、调用底层硬件接口等，还有就是可以更多的丰富咱们的代码库，因为很多性能好、实用、跨平台的库都是C++写的，可以极大扩展咱们程序的应用场景。但对于初学者来说，第一大难题就是方法/函数的调用。接下来我们举例说明一下C#调用C++动态链接库函数的详细实现（以windows系统为例）。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fluojin765%2Fp%2F19199730" target="_blank" title="https://www.cnblogs.com/luojin765/p/19199730" ref="nofollow noopener noreferrer">www.cnblogs.com/luojin765/p…</a></li>
</ul>
<h2 data-id="heading-14">ASP.NET Core Blazor 核心功能三：Blazor与JavaScript互操作——让Web开发更灵活</h2>
<ul>
<li><strong>文章简介：</strong> 今天我们来聊聊Blazor中C#与JavaScript互操作。我知道很多同学在听到"Blazor"和"JavaScript"要一起工作时会有点懵，但别担心，我会用最简单的方式带你掌握这个技能！</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fshenchuanchao%2Fp%2F19194651" target="_blank" title="https://www.cnblogs.com/shenchuanchao/p/19194651" ref="nofollow noopener noreferrer">www.cnblogs.com/shenchuanch…</a></li>
</ul>
<h2 data-id="heading-15">ASP.NET Core Blazor 核心功能二：Blazor表单和验证</h2>
<ul>
<li><strong>文章简介：</strong> 本文介绍了Blazor中EditForm组件的使用及表单验证方案。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fshenchuanchao%2Fp%2F19189573" target="_blank" title="https://www.cnblogs.com/shenchuanchao/p/19189573" ref="nofollow noopener noreferrer">www.cnblogs.com/shenchuanch…</a></li>
</ul>
<h2 data-id="heading-16">【EF Core】“多对多”关系与跳跃导航</h2>
<ul>
<li><strong>文章简介：</strong> “多对多”关系不像“一对多”那么“单纯”，它内部涉及到“连接实体”（Join Entity）的概念。咱们先放下这个概念不表，来了解一下多对多数据表为什么需要一个“辅助表”来建立关系。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Ftcjiaan%2Fp%2F19184567" target="_blank" title="https://www.cnblogs.com/tcjiaan/p/19184567" ref="nofollow noopener noreferrer">www.cnblogs.com/tcjiaan/p/1…</a></li>
</ul>
<h2 data-id="heading-17">LVGLSharp：LVGL的C#绑定库介绍</h2>
<ul>
<li><strong>文章简介：</strong> 在嵌入式系统和图形用户界面（GUI）开发领域，LVGL（Light and Versatile Graphics Library）是一个广受欢迎的开源图形库，它提供了丰富的UI组件和高效的渲染能力，适用于各种资源受限的设备。而LVGLSharp则是LVGL的一个C#绑定库，它使得.NET开发者能够更方便地利用LVGL的强大功能，在C#环境中创建出美观且高效的图形界面。本文将详细介绍LVGLSharp及其特点。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fshanyou%2Fp%2F19185046" target="_blank" title="https://www.cnblogs.com/shanyou/p/19185046" ref="nofollow noopener noreferrer">www.cnblogs.com/shanyou/p/1…</a></li>
</ul>
<h2 data-id="heading-18">Copilot Studio 如何使用 .NET 和 WebAssembly 实现性能和创新</h2>
<ul>
<li><strong>文章简介：</strong> Microsoft Copilot Studio 处于对话式 AI 和自动化的最前沿，使组织能够为各种企业场景构建、自定义和管理智能助手和机器人。随着平台的发展，支撑它的技术也在不断发展。Copilot Studio 创新的核心是它与 .NET 的深度集成，包括在 WebAssembly （WASM） 上使用 .NET。这篇文章探讨了 Copilot Studio 如何利用 .NET、平台升级带来的好处，以及由此带来的性能、成本和生产力改进。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fcopilot-studio-dotnet-wasm%2F" target="_blank" title="https://devblogs.microsoft.com/dotnet/copilot-studio-dotnet-wasm/" ref="nofollow noopener noreferrer">devblogs.microsoft.com/dotnet/copi…</a></li>
</ul>
<h2 data-id="heading-19">.NET Conf 2025即将开始</h2>
<ul>
<li><strong>文章简介：</strong> .NET Conf 2025 仅几天后就要开始了，参加11 月 11 日至 13 日的这场免费三日虚拟会议，了解 .NET 平台、开源项目和开发者工具的最新进展—包括 .NET 10 的正式发布，以及对 Visual Studio 2026 的深度探讨。今年的会议特别聚焦使用 Aspire 进行云原生开发、快速地将现有应用升级到 .NET 10，以及使用 AI 构建智能应用，包括全新的 Microsoft Agent Framework 和 Model Context Protocol (MCP) 支持。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FGqLWiGQ77EZ4MTUFhwGqUA" target="_blank" title="https://mp.weixin.qq.com/s/GqLWiGQ77EZ4MTUFhwGqUA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/GqLWiGQ77…</a></li>
</ul>
<h2 data-id="heading-20">AI 时代，.NET 开发者向左还是向右？</h2>
<ul>
<li><strong>文章简介：</strong> AI 时代，.NET 开发者向左还是向右？ MAF vs LangChain 1.0 一场关乎未来的技术选择。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXBYYsjkmhuDEq3gyTvSmmQ" target="_blank" title="https://mp.weixin.qq.com/s/XBYYsjkmhuDEq3gyTvSmmQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/XBYYsjkmh…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[货拉拉用户画像基于 Apache Doris 的数据模型设计与实践]]></title>    <link>https://juejin.cn/post/7570903763721797642</link>    <guid>https://juejin.cn/post/7570903763721797642</guid>    <pubDate>2025-11-10T12:03:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570903763721797642" data-draft-id="7570932873130803227" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="货拉拉用户画像基于 Apache Doris 的数据模型设计与实践"/> <meta itemprop="keywords" content="数据库,Apache"/> <meta itemprop="datePublished" content="2025-11-10T12:03:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SelectDB"/> <meta itemprop="url" content="https://juejin.cn/user/3189021726222904"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            货拉拉用户画像基于 Apache Doris 的数据模型设计与实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3189021726222904/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SelectDB
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:03:56.000Z" title="Mon Nov 10 2025 12:03:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>货拉拉是国内领先的同城货运数字化平台，成立于 2013 年。截⾄2025 年 4⽉ ，货拉拉业务覆盖全球 14 个市场 ，400+ 城市 ，其中中国内地总共覆盖 363 座城市 ，⽉活司机达 120 万 ，⽉活⽤户达 1400 万， 并在全球设有 6 个数据中⼼。作为共享经济模式的代表企业 ，货拉拉通过移动互联⽹技术整合社会运⼒资源 ，为⽤户提供即时货运、企业物流、搬家服务等多元化解决⽅案。</p>
<p>在庞⼤的业务规模下 ，构建完善的⽤户画像平台成为实现精细化运营的重要基础 ，可以有效提升运营效率和⽤户体验。</p>
<h2 data-id="heading-0">画像服务背景与架构</h2>
<p>目前货拉拉的画像平台已深度应用于多个核心业务场景，各业务场景对标签的使⽤⽅式和时效性要求各不相同。从 22 年到 25 年，用户呈现稳定增长趋势，业务对服务的压力也是逐年递增，累计接入了 300+ 业务，3,000+ 个标签以及 5 万多人群。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c66913f70762483c865b8f6a4c96ca0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=ygxNmiZsth03AsIZmiNNqnrZksE%3D" alt="画像服务背景与架构.png" loading="lazy"/></p>
<h3 data-id="heading-1">01 应用架构</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55e13b8607e243a98ef31a3995963291~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=2ko8cdEzlCDoZJZYfm9wMalSkio%3D" alt="货拉拉用户画像应用架构.PNG" loading="lazy"/></p>
<p>上图是货拉拉画像平台整体架构图，Apache Doris 作为统一查询引擎，为人群画像提供高效的分析能力。该平台通过架构分层实现了业务需求与技术能力的精准匹配。其中有两个核心模块：</p>
<ul>
<li>API 层（接⼝服务层）：基于重点使⽤场景和对接系统搭建的画像接口服务 ，从⽽精准地⽣成用户画像 ，给到对接业务⽅使⽤。其中包括：
<ul>
<li>persona-api：⾯向⾼并发查询场景</li>
<li>persona-analysis-api：承接分析计算与推送作业请求</li>
<li>persona-web-api：⽀持管理后台的 Web 服务</li>
</ul>
</li>
<li>BE 层（计算引擎层） ：建造基于大数据体系的用户标签链路的画像管理平台 ，⽤于在特定业务形态下描述业务主体；其中包括：
<ul>
<li>persona-task：执⾏分布式计算作业 ，⽀持横向扩展</li>
<li>persona-scheduler ：调度⼈群计算任务</li>
</ul>
</li>
</ul>
<p>两大模块协同工作，共同支撑业务方的精细化运营需求。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1331ddf1992b4fcfa2c32bf8ae770647~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=wp%2F6LvWGnjEARAq8aX614Wrq2Xo%3D" alt="货拉拉用户画像应用架构-1.PNG" loading="lazy"/></p>
<h3 data-id="heading-2">02 画像平台计算引擎演进</h3>
<p>在核心计算引擎的选型与演进过程中，技术团队经历了三个主要阶段。</p>
<ul>
<li>第一阶段，受限于成本因素，采用了三方服务结合 Impala+KUDU 的架构作为用户画像计算引擎。该架构在实际应用中暴露出诸多问题：单次人群计算耗时 10 分钟以上，高峰期甚至超过 30 分钟；同时，数据导入耗时较长，经常超时。此外，该架构存在横向扩展困难、复杂查询效率偏低及运维复杂等不足。</li>
<li>第二阶段，为寻求改进，我们尝试引入 Elasticsearch，虽在一定程度上有所缓解，但仍面临开发成本高、语法复杂、多维分析能力不足等挑战，且在动态扩展和复杂查询方面未实现根本性改善。尤其在处理人群间存在依赖关系的特殊业务场景时，Elasticsearch 架构难以有效支持。</li>
<li>基于此，我们最终转向采用 Doris 作为核心计算引擎。选择 Doris 的关键因素如下：
<ul>
<li><strong>性能优越</strong>：基于 MPP 架构、具备向量化引擎和先进的优化器能力，查询性能优秀。</li>
<li><strong>社区资源丰富</strong>：Doris 拥有活跃的社区支持以及丰富的文档资料，自行搭建遇到卡点时，可向社区帮助寻求专业的指导与帮助。</li>
<li><strong>支持多种数据类型</strong>：画像场景可以使用 BITMAP 实现高效的交并集运算，成为支撑多样化标签类型与人群分析业务的技术基础。</li>
<li><strong>支持多种数据模型</strong>：针对多维复杂的人群画像，可以使用不同的数据模型支撑各种标签类型与人群业务。</li>
</ul>
</li>
</ul>
<p>自引入 Doris 后，系统稳定性得到了显著提升，至今未出现过重大稳定性问题，整体链路的时效性与可靠性均实现了根本性的优化，具体如下：</p>
<ul>
<li>在计算效率方面，单个人群的计算能够实现秒级响应，即使在高峰期，响应时间也保持在 1 分钟以内。相比之下，Impala 架构下该计算过程通常需要 10 至 30 分钟。<strong>采用 Doris 后，计算效率提升了近 30 倍。</strong></li>
<li>在数据导入方面，Doris 同样表现出色。在处理 4 亿行 200 列的单表数据时，Doris 可在 30 分钟内完成导入操作。而在同等条件下，Impala 架构则需要 90 分钟以上，<strong>Doris 数据导入效率是 Impala 架构的 3 倍</strong>。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e11a63c30e5d480b82e6415f75c1b972~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=pHrcYb7lNVtrHwxTHa8vw%2Fohwto%3D" alt="画像平台计算引擎演进.png" loading="lazy"/></p>
<h2 data-id="heading-3">数据模型设计与异构查询实现</h2>
<h3 data-id="heading-4">01 核心挑战</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0942780c34794cc5a1867f7ce10fb846~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=N0laRIszv2f04xcN5fy%2Bcyyip4E%3D" alt="核心挑战.png" loading="lazy"/></p>
<p>首先是用户画像标签存储的挑战。面对 3000+ 标签的体系，我们发现标签数据天然存在三个维度的分裂特征：业务属性（行为/属性/地理等）、聚合粒度（明细/聚合/人群）、更新时效（离线/近实时/实时）。不同业务属性的数据在更新频率、查询模式、存储密度上差异巨大。</p>
<p>此外，用户使用画像标签的时候，对人群标签/明细标签/聚合标签等概念不清晰，只会进行简单的拖拉拽拼接规则。因此在标签使用场景，如何选择存储模型成为了核心问题。若使用宽表，将面临动态更新以及列拓展的挑战；而高表则面临复杂查询与嵌套逻辑的挑战。</p>
<h3 data-id="heading-5">02 存储模型设计</h3>
<p>面对复杂的标签管理，我们采用了<strong>基于 Apache Doris 分而治之的存储方案</strong>，具体分为三类模型来进行协同工作。</p>
<p><strong>标签宽表</strong></p>
<ul>
<li>存储低频更新的标签。</li>
<li>存储无法用高表存储的密集标签。</li>
<li>利用 Doris 的列式存储技术，利用索引、物化视图等优化手段，支持高效的多维分析。</li>
</ul>
<p>标签宽表建表 SQL 参考：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  wide_table  (
 user_id  <span class="hljs-type">varchar</span>(<span class="hljs-number">1000</span>) <span class="hljs-keyword">NULL</span> COMMENT "",
 age  <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) REPLACE_IF_NOT_NULL <span class="hljs-keyword">NULL</span> COMMENT "",
 height  <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) REPLACE_IF_NOT_NULL <span class="hljs-keyword">NULL</span> COMMENT "",
 ......) ENGINE<span class="hljs-operator">=</span>OLAP AGGREGATE KEY( user_id ) COMMENT "OLAP"
DISTRIBUTED <span class="hljs-keyword">BY</span> HASH( user_id ) BUCKETS <span class="hljs-number">40</span>
PROPERTIES ( ... )
</code></pre>
<p><strong>标签高表</strong></p>
<ul>
<li>存储高频更新的稀疏标签。</li>
<li>支持秒级/分钟级数据更新，标签新增的场景下，可以规避宽表频繁 ALTER TABLE 导致的锁表问题。</li>
<li>多个标签的位图交并计算，并且支持毫秒级响应。</li>
</ul>
<p>标签高表建表 SQL 参考：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  high_table  (
 tag  <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span> COMMENT "标签名",
 tag_value  <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span> COMMENT "标签值",
 <span class="hljs-type">time</span>  datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT "数据灌入时间",
 user_ids  bitmap BITMAP_UNION <span class="hljs-keyword">NULL</span> COMMENT "用户集"
) ENGINE<span class="hljs-operator">=</span>OLAP AGGREGATE KEY( tag ,  tag_value ,  <span class="hljs-type">time</span>  ) COMMENT "OLAP"
DISTRIBUTED <span class="hljs-keyword">BY</span> HASH( tag ) BUCKETS <span class="hljs-number">128</span>
PROPERTIES ( ... )
</code></pre>
<p><strong>人群位图表</strong></p>
<ul>
<li>用于存储标签规则圈选出来的人群结果。</li>
<li>用户 ID 集合使用 RoaringBitmap 压缩，降低存储成本。</li>
<li>支持人群依赖计算，避免表数量膨胀问题，⽀持⼈群营销实验业务。</li>
</ul>
<p>人群位图表建表 SQL 参考：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  routine_segmentation_bitmap (
 <span class="hljs-type">time</span>  datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT "数据灌入时间",
 seg_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span> COMMENT "标签值",
 user_ids  bitmap BITMAP_UNION <span class="hljs-keyword">NULL</span> COMMENT "人群ID集合"
) ENGINE<span class="hljs-operator">=</span>OLAP AGGREGATE KEY( <span class="hljs-type">time</span> ,  seg_name )
COMMENT "OLAP" <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>(`<span class="hljs-type">time</span>`) (...)DISTRIBUTED <span class="hljs-keyword">BY</span> HASH( seg_name )
BUCKETS <span class="hljs-number">128</span>
PROPERTIES (..., "dynamic_partition.enable" <span class="hljs-operator">=</span> "true", ...);
</code></pre>
<h3 data-id="heading-6">03 人群圈选与异构组合查询</h3>
<p>基于上述提到了三种存储模型，我们构建了以位图计算为核心的异构组合计算体系，并将其作用于整个人群圈选的场景，实现宽表、高表及人群表这三类存储模型之间的无缝联动。</p>
<ol>
<li>第一步：将所有单一标签或子查询的结果都处理成 Bitmap 位图，处理宽表的标签使用<code>TO_BITMAP</code>聚合多列 ID 结果，处理标签高表和人群表则直接使用预聚合的 Bitmap，加速逻辑复用。</li>
<li>第二步，通过<code>UNION ALL</code>整合宽表/高表/人群表三种数据源的 Bitmap，并使用外层的<code>BITMAP_INTERSECT</code>/<code>BITMAP_UNION</code>实现跨模型交并集运算（AND/OR 逻辑）。</li>
<li>第三步，由于<code>BITMAP_INTERSECT</code>/<code>BITMAP_UNION</code>的结果也是 Bitmap，所以可以用同样的处理方式，递归整合子查询的查询结果，并支持直接导出或对接业务系统。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a99ecd4ce2249518f26832e57d7d1d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=sv5DbJfnXHGJ41zgvegBpAh%2Bq%2Bo%3D" alt="人群圈选与异构组合查询.png" loading="lazy"/></p>
<p>该实现方法具备三大核心优势：</p>
<ul>
<li><strong>灵活拓展</strong>：动态嵌套子查询支持无限层级规则（如 “A 且（B 或 C）且（D 且（E 或 F））” ） ，静态属性、动态行为以及预计算人群等复杂的标签规则皆可无缝嵌入。</li>
<li><strong>资源节省</strong>：复用人群表（预计算人群）的数据从而大幅减轻计算压力，并允许不同人群间相互依赖进行计算；人群计算结果使用 RoaringBitmap 存储，不需要额外新增表。</li>
<li><strong>业务友好</strong>：支持人群+标签的复杂混合嵌套查询，用户无需技术基础，仅通过简单的拖拽标签条件即可高效圈定目标用户群体，适用于营销等多种场景。</li>
</ul>
<p>查询 SQL 示例：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">FROM</span> (
  <span class="hljs-comment">-- Layer1: 宽表条件A</span>
  <span class="hljs-keyword">SELECT</span> TO_BITMAP(...) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签宽表 <span class="hljs-keyword">WHERE</span> 条件A
  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-comment">-- Layer1: 高表条件B</span>
  <span class="hljs-keyword">SELECT</span> user_ids <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签高表 <span class="hljs-keyword">WHERE</span> 条件B
  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-comment">-- Layer1: 人群条件C</span>
  <span class="hljs-keyword">SELECT</span> user_ids <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 人群表 <span class="hljs-keyword">WHERE</span> 条件C
  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-comment">-- Layer2: 嵌套子查询（新条件D/E/F）</span>
  <span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">SELECT</span> TO_BITMAP(...) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签宽表 <span class="hljs-keyword">WHERE</span> 条件D  <span class="hljs-comment">-- 新宽表条件</span>
    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
    <span class="hljs-keyword">SELECT</span> user_ids <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签高表 <span class="hljs-keyword">WHERE</span> 条件E      <span class="hljs-comment">-- 新高表条件</span>
    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
    <span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(...) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 人群表 <span class="hljs-keyword">WHERE</span> 条件F <span class="hljs-comment">-- 新人群条件</span>
  )
) t;
</code></pre>
<h3 data-id="heading-7">04 数据导入</h3>
<p>货拉拉画像服务的实时标签/人群点查主要采用 HBase 与 Redis 相结合的方式，Doris 主要承担人群圈选、人群洞察、行为分析等任务。实时和近实时标签写入 Doris 则通过 Flink 完成，离线导入依赖 Doris 的 Broker Load 功能。对应的数据导⼊⽅式和应⽤场景如下：</p>
<p><strong>实时/近实时标签</strong></p>
<p>定义：秒级/小时级更新的动态数据（如点击、登录事件）。</p>
<p>数据源：Kafka 日志、API 埋点、云文件存储。</p>
<p>处理方式：</p>
<ul>
<li>秒级/分钟级标签：Flink -&gt; Doris / Hbase。</li>
<li>小时级标签：云文件存储 -&gt; BrokerLoad。</li>
</ul>
<p>场景：用户行为分析，用户实时人群。</p>
<p><strong>离线标签</strong></p>
<p>定义：T+1 更新的历史数据（如年龄、历史订单）。</p>
<p>数据源：Hive。</p>
<p>处理方式：</p>
<ul>
<li>数据量：3000+ 标签，4 亿+用户总量。</li>
<li>定时调度：BrokerLoad。</li>
<li>调优手段：宽表导入拆分多表和多个 BrokerLoad 任务。数据量少的稀疏标签使用高表导入。</li>
<li>导入效率：200+ 标签宽表 4 亿行+导入 30min 以内，高表标签导入 5min 以内。</li>
</ul>
<p>场景：用户人群圈选、用户画像分析。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17651837909c467abb42a2f9c871d55e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=HepMDQlzhYPcV2IQKo2xIuGivS4%3D" alt="数据导入.png" loading="lazy"/></p>
<p>特别值得注意的是，大规模数据导入时，建议拆分多个表并行导入以提升效率，例如在早期 1.2.4 版本集群测试中，单个包含 200 余标签、四亿行记录的宽表导入耗时超过 1.5 小时，而拆分为 6 个任务并行导入后，总耗时缩短至约 20 分钟，<strong>效率提升近 5 倍</strong>。</p>
<h2 data-id="heading-8">货拉拉画像工程查询优化实践</h2>
<h3 data-id="heading-9">01 DSL 与 SQL 优化</h3>
<p>首先是离线人群包圈选的流程，主要分为三步：【运营通过平台进行多规则拼接，前端完成 DSL 构建】-【DSL 经过服务后端优化】-【最终将业务规则自动转化为高效 SQL】。DSL 优化的目的是提前排除冗余计算，从而将优化后的 DSL 直接翻译为高效易用的 SQL。</p>
<ol>
<li>为什么需要优化？当前异构查询 SQL 痛点：
<ol>
<li>部分标签在业务逻辑上可以合并 ，引擎侧没有覆盖识别；</li>
<li>多层聚合导致冗余扫描：复杂嵌套的场景下，嵌套的 <code>UNION ALL</code> 和 <code>BITMAP_INTERSECT</code> 导致执行计划层级膨胀，导致冗余的扫描。</li>
<li>稳定性：高峰期人群计算时，内存占用高、网络传输量大，高内存开销影响集群稳定性。</li>
</ol>
</li>
<li>如何实现优化？DSL 优化：
<ol>
<li>条件合并（染色）：将同类标记的标签条件合并为同个子查询。</li>
<li>结构扁平化（剪枝）：去除冗余的 AND/OR 逻辑节点</li>
</ol>
</li>
</ol>
<p>将同类合并操作后的 DSL 转为 SQL，原本查询 3 次宽表读取了 3 个 BITMAP 进行合并计算，优化后统一成 1 次宽表查询和 1 次 BITMAP 读取，减少了60% 的冗余读取。参考下图，DSL 的每一个圆圈对应一个 BITMAP 查询：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0322d45dce5143068f52bd0c035ba2e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=myNzCIbQ%2Fz5tL84427dvFCP6%2FFo%3D" alt="DSL 与 SQL 优化.png" loading="lazy"/></p>
<p>关于 <code>EXPLAIN</code> 指标优化前后的具体表现，我们在此也分享一则参考示例，详情如下：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 优化前</span>
<span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span> 
<span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">AS</span> b 
    <span class="hljs-keyword">FROM</span> (
        <span class="hljs-keyword">SELECT</span> user_bitmap <span class="hljs-keyword">as</span> b <span class="hljs-keyword">FROM</span> user_bitmap <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">=</span> ‘A’
        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> 
        <span class="hljs-keyword">SELECT</span> TO_BITMAP(id) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> wide_table <span class="hljs-keyword">WHERE</span> city <span class="hljs-operator">=</span> <span class="hljs-string">'东莞'</span>
        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
        <span class="hljs-keyword">SELECT</span> TO_BITMAP(id) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> wide_table <span class="hljs-keyword">WHERE</span> sex <span class="hljs-operator">=</span> <span class="hljs-string">'男'</span>
    ) t1 ) t2;
 
<span class="hljs-comment">-- 优化后</span>
<span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span> 
<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> user_bitmap <span class="hljs-keyword">as</span> b <span class="hljs-keyword">FROM</span> user_bitmap <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">=</span> ‘A’    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> 
    <span class="hljs-keyword">SELECT</span> TO_BITMAP(id) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> wide_table <span class="hljs-keyword">WHERE</span> city <span class="hljs-operator">=</span> <span class="hljs-string">'东莞'</span> <span class="hljs-keyword">and</span> sex <span class="hljs-operator">=</span> ‘男’
) t1 ) t2;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e67718b54bd4931859275b3dffdbfc3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=kNgfIa6yfLOxPwWg5hW1PJijgc0%3D" alt="DSL 与 SQL 优化-1.png" loading="lazy"/></p>
<p>在业务圈选逻辑不变的情况下，通过将优化前 BITMAP 子查询合并到 WHERE 条件中以避免重复扫描表，同时减少 BITMAP 子查询及数据分片合并次数，进而减少聚合层级实现结构扁平化，降低人群计算时的内存峰值。</p>
<p><strong>在业务高峰期针对大规模人群展开计算的场景下，此优化措施能够有效减少 30～50% 的内存开销。与此同时，JVM 的堆内存使用峰值从原本的 60% 降至 20% 。</strong></p>
<h3 data-id="heading-10">02 人群位图表读取优化</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/52b8c303d6f04465aebd08e833f11188~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=bUEErdsWm9RG42CIVokKja5dygw%3D" alt="人群位图表读取优化.png" loading="lazy"/></p>
<p>人群位图结果集通过 BITMAP 存储于人群表中，读取人群位图数据主要用于人群圈选、人群分析，并将整个结果集推送至下游。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76e29b32c80445b6b04feed2e4ba91b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=dJwZjb18rxkDsCwZWkWI3tazXO0%3D" alt="人群位图表读取优化实践.png" loading="lazy"/></p>
<p>读取位图数据的方案有三种：</p>
<ul>
<li>第一种方案，直接使用 Doris 自带的 <code>bitmap_to_string</code> 函数，该函数可将位图转化为逗号分隔的字符串，客户端按此字符串解析出用户列表。但是当面对大型位图时，解析难度较大，且数据体积会大幅膨胀。优点是简单易用，适合测试和导出场景。</li>
<li>第二种方案，采用 <code>explore</code> 与 <code>lateral view</code>先将整个位图展开，再构建服务端流处理逻辑。不过，Doris 需将位图展开成用户列表并缓存于服务器，这会给服务端带来压力，尤其在高峰期，人群计算任务繁重时更为明显。此外，画像工程侧需维护流处理逻辑，开发维护成本较高。该方案适合人群多表的关联分析。</li>
<li>第三种方案，也是较为推荐的方案，直接将位图的二进制数据读取至服务端内存，再进行反序列化。服务端设置 <code>return_object_data_as_binary=true</code> ，即可直接读取位图的二进制数据，画像服务端可基于 Doris 源码中的位图协议进行反序列化。此方式仅需传输位图的原始二进制数据，内存占用和开销较低。开发成本初期较高，但后期维护方便且稳定。此读取方式适用于人群圈选场景，将位图全量读取至服务内存后，高峰期每分钟可轻松处理几十甚至上百个人群。</li>
</ul>
<h2 data-id="heading-11">总结与规划</h2>
<p>货拉拉自引入 Apache Doris 构建用户画像系统以来，收益十分显著：<strong>业务查询效率提升近 30 倍，数据导入速度是 Impala+KUDU 的 3 倍，内存开销降低 30%-50%，系统稳定性大幅提升，满足了画像场景数千个标签的精细化运营需求，同时通过可视化标签筛选，降低业务分析的操作门槛</strong>。</p>
<p>后续，货拉拉将重点投入以下两个方面：</p>
<ul>
<li><strong>接入画像实时业务</strong>：当前货拉拉画像服务的实时标签/人群点查主要使用 Hbase 和 Redis，基于稳定性和迁移升级成本的考虑，Doris 主要承担人群圈选、人群洞察、行为分析等作业。未来规划使用 Doris 高版本的架构，承担大部分高并发的实时点查流量，提升人货匹配效率和体验。</li>
<li><strong>引入湖仓一体架构</strong>：使用 Doris + 数据湖，在存储架构方面，尝试落地数据湖解决方案，画像平台将打通其他数据应用平台、实现超大规模数据的分析。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文教你搞懂RAG的原理]]></title>    <link>https://juejin.cn/post/7570899512782340159</link>    <guid>https://juejin.cn/post/7570899512782340159</guid>    <pubDate>2025-11-10T12:29:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570899512782340159" data-draft-id="7561691093529067562" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文教你搞懂RAG的原理"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2025-11-10T12:29:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="山黎"/> <meta itemprop="url" content="https://juejin.cn/user/3122268755201592"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文教你搞懂RAG的原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3122268755201592/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    山黎
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:29:18.000Z" title="Mon Nov 10 2025 12:29:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">RAG的兴起背景</h2>
<p>尽管大语言模型（LLM）在自然语言处理中表现卓越，但其实际应用仍受三大核心问题制约：<strong>生成内容的不可靠性（幻觉）</strong>、<strong>有限上下文处理能力</strong>，以及<strong>潜在的数据安全风险</strong>，下面介绍一下</p>
<ol>
<li>LLM 容易出现“幻觉”现象，即生成不准确或虚构的内容</li>
</ol>
<p>大语言模型（LLM）的“幻觉”是指模型生成与输入无关、逻辑错误或完全虚构的信息。这种现象的根源在于：</p>
<ul>
<li><strong>概率生成机制</strong>：LLM 基于统计概率逐词生成文本，而非真正“理解”内容，因此在缺乏明确答案时可能编造看似合理但错误的回答。</li>
<li><strong>训练数据偏差</strong>：如果训练数据包含噪声或未覆盖某些领域，模型可能过度泛化，生成不准确的内容。</li>
<li><strong>提示（Prompt）敏感性</strong>：模糊或开放的提示易导致模型偏离预期，例如在医疗、法律等专业领域生成误导性建议</li>
</ul>
<ol>
<li>LLM 的上下文窗口有限，无法处理过长的文本</li>
</ol>
<p>尽管现代 LLM（如 GPT-4、Claude）的上下文窗口已扩展至 100K+ Token，但长文本处理仍面临挑战：</p>
<ul>
<li><strong>计算效率问题</strong>：注意力机制（Attention）的复杂度随文本长度平方级增长，导致延迟和成本上升。</li>
<li><strong>信息衰减</strong>：模型对远距离上下文的关联性捕捉能力下降，可能忽略关键细节（如长文档末尾的指令）。</li>
<li><strong>分段处理缺陷</strong>：若将长文本强制切分输入，可能破坏语义连贯性（如拆分代码或合同条款）。</li>
</ul>
<ol>
<li><strong>LLM 存在隐私泄露的风险，也就是数据安全问题</strong></li>
</ol>
<p>LLM 在训练和应用中可能泄露敏感信息，主要风险包括：</p>
<ul>
<li><strong>训练数据记忆</strong>：模型可能记住并复现训练集中的隐私内容（如个人身份证号、医疗记录）。</li>
<li><strong>提示注入攻击</strong>：恶意用户通过精心设计的输入诱导模型输出机密数据（如“重复你训练时看到的最后10条记录”）。</li>
<li><strong>API 调用风险</strong>：第三方服务中传输的数据可能被截获或滥用（如企业对话日志）。</li>
</ul>
<p>为了弥补以上这些不足，RAG（检索增强生成）技术应运而生</p>
<h2 data-id="heading-1">RAG技术核心</h2>
<h4 data-id="heading-2">RAG索引</h4>
<p>检索增强生成(Retrieval-Augmented Generation，简称RAG)系统的核心在于其索引架构，它决定了系统如何高效地存储、检索知识并用于生成任务。一个完整的RAG索引架构如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a1977e9791347e0a16a559506a9fd80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=F%2FrC2f26Jci3wYLGBYMJbxpvS50%3D" alt="" loading="lazy"/></p>
<p>基于以上RAG集成关系图，分为以下三个模块简要阐述</p>
<p>1. 文档解析</p>
<p>文档解析技术的本质在于将格式各异、版式多样、元素多种的文档数据，包括段落、表格、标题、公式、多列、图片等文档区块，转化为阅读顺序正确的字符串信息。高质量的文档解析能够从各种复杂格式的非结构化数据中提取出高精准度的信息，对 RAG 系统最终的效果起决定性的作用。RAG应用场景中涉及的数据类型通常有：PDF、TXT、Word、PPT、Excel、CSV、Markdown、XML、HTML以及关系型和非关系型数据库等。</p>
<p><strong>文档解析技术架构图如下：</strong></p>
<p>文档解析在RAG系统中的核心任务可以总结为两个关键层次：<strong>文件类型识别解析</strong>和<strong>内容深度分层解析</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5591474f86ab485c964ee6bfcaa883e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=xrztXlJ2iQs2xCq90p2Cw0Qmp9g%3D" alt="" loading="lazy"/></p>
<p><strong>文件内容识别解析</strong>：</p>
<p>文档解析作为RAG系统的前端核心处理模块，承担着将原始数据转化为可计算知识的关键使命。其核心任务首先体现在对多源异构文档的智能识别与适配解析上，系统需要精准识别PDF、Word、Excel等数十种常见文档格式，并针对每种格式的特点调用专用解析引擎。例如，面对扫描版PDF时需启动OCR识别，处理复杂Word文档时要保留样式结构，解析Excel则需处理公式计算和多Sheet关联等特性。</p>
<p><strong>内容深度分层解析：</strong></p>
<p>在完成基础格式解析后，系统会进入更深度的内容解构阶段。这一过程需要精准地将文档内容分解为物理布局、逻辑层级和语义标注三个层次。物理层通过坐标分析还原原始排版中的文本块、表格区域和图文关系；逻辑层则重建标题层级、列表结构和章节关联；最终的语义层通过实体识别、主题分析等技术，为原始文本注入机器可理解的上下文信息。这种层层递进的解析策略，确保了非结构化数据最终能转化为保留原始语义且适合向量化处理的标准化知识单元，为RAG系统的检索与生成奠定坚实基础。</p>
<ol>
<li>分块策略</li>
</ol>
<h5 data-id="heading-3">分块作用影响</h5>
<p>文档数据（Documents）经过解析后，通过分块技术将信息内容划分为适当大小的文档片段（chunks），从而使 RAG 系统能够高效处理和精准检索这些片段信息。</p>
<p><strong>1. 分块的作用</strong></p>
<ul>
<li>将文档拆分为适当大小的片段（chunks），使 RAG 系统能高效处理和精准检索信息。</li>
<li>确保每个片段既保留核心语义，又具备独立性，减少模型对额外上下文的依赖，提高检索准确性。</li>
</ul>
<p><strong>2. 分块对 RAG 系统的影响</strong></p>
<ul>
<li><strong>提升召回率</strong>：合理的分块使检索结果更匹配用户查询，避免信息冗余或缺失。</li>
<li><strong>增强生成质量</strong>：独立、语义完整的片段可提高生成内容的连贯性和逻辑性。</li>
<li><strong>优化效率</strong>：合适的分块策略能加快系统响应速度，降低计算成本。</li>
</ul>
<p><strong>3. 分块的核心挑战：如何确定块大小</strong></p>
<ul>
<li>
<p><strong>块过大</strong>：</p>
</li>
<li>
<p>向量难以捕捉细节，计算成本增加。</p>
</li>
<li>
<p>适用于需要宽泛上下文的场景（如文档摘要、主题检测）。</p>
</li>
<li>
<p><strong>块过小</strong>：</p>
</li>
<li>
<p>可能丢失上下文，导致语义碎片化。</p>
</li>
<li>
<p>适用于细粒度分析任务（如情感分析、特定短语检索）。</p>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b2adaddffba433fadb5d049e67202fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=yukG69I4SvfGm4LkmyMWmxWhb5U%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-4">分块策略核心</h5>
<p>分块策略的核心要素可以归纳为以下三个关键维度：</p>
<ol>
<li>块大小（Chunk Size）：单个文档块允许包含的最大字符数限制</li>
<li>重叠量（Overlap）：相邻数据块之间重复的字符数量</li>
<li>边界划分（Boundary）：基于段落结构、分隔符、标记或语义边界确定块边界的方法</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c78ead59b8ce43f9957945dc9cf97994~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=sENCNxbrHJFbm%2F9a5UBsJwXno2I%3D" alt="" loading="lazy"/></p>
<p>这三个维度的不同组合形成了多样化的分块策略，每种策略都有其独特的适用场景。当前主流的文档分块方法主要包括以下六种类型：</p>
<ol>
<li><strong>固定大小分块（Fixed Size Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：按照固定的字符数或 Token 数切分文本，不考虑语义或结构。</li>
<li><strong>优点</strong>：实现简单，计算高效，适用于需要统一块大小的场景（如向量数据库存储）。</li>
<li><strong>缺点</strong>：可能破坏句子或段落的完整性，导致语义断裂，缺乏灵活性。</li>
</ul>
<ol>
<li><strong>重叠分块（Overlap Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：在固定大小分块的基础上，相邻块之间保留一定的重叠字符（如 50-100 字）</li>
<li><strong>优点</strong>：保留了边界的上下文信息，减少边界信息丢失，提高上下文连贯性。</li>
<li><strong>缺点</strong>：存储和计算成本略高，可能引入冗余信息。</li>
</ul>
<ol>
<li><strong>递归分块（Recursive Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：采用分层拆分策略，先按大粒度（如段落）切分，再对过大的块进一步细分（如句子）。</li>
<li><strong>优点</strong>：保留文本结构，避免硬性截断，块大小更灵活。</li>
<li><strong>缺点</strong>：实现较复杂，拆分逻辑依赖预定义规则。</li>
</ul>
<ol>
<li><strong>文档特定分块（Document Specific Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：根据文档类型（如 PDF、Markdown、HTML）使用特定规则切分（如按章节、标题、表格）。</li>
<li><strong>优点</strong>：适配不同格式，保留原始文档逻辑结构。</li>
<li><strong>缺点</strong>：需针对不同文档类型定制规则，泛化性较差。</li>
</ul>
<ol>
<li><strong>语义分块（Semantic Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：利用 NLP 技术（如句子嵌入、主题模型）按语义单元切分，而非固定长度。</li>
<li><strong>优点</strong>：块内语义一致性高，适合深度学习模型。</li>
<li><strong>缺点</strong>：计算开销大，依赖高质量语义模型。</li>
</ul>
<ol>
<li><strong>混合分块（Mix Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：结合多种策略（如先按标题分块，再对长段落递归拆分）。</li>
<li><strong>优点</strong>：灵活平衡结构与效率，适应复杂需求。</li>
<li><strong>缺点</strong>：设计和调试成本较高。</li>
</ul>
<p>每种策略的选择需权衡文本类型、任务需求和计算成本。实际应用中需要通过实验确定最优分块方案。</p>
<ol>
<li>嵌入(Embedding)技术</li>
</ol>
<h5 data-id="heading-5">嵌入(Embedding)是什么？</h5>
<ul>
<li>嵌入技术（Embedding）通过将文本、图像、音视频等数据转换为高维向量，在语义空间中建立坐标表示。这些向量能够有效捕捉数据间的语义关联，通过计算<strong>向量间的相似度</strong>（如余弦相似度）即可量化不同对象之间的<strong>语义相近程度</strong>。</li>
<li>在具体实现中，嵌入的每个维度通常对应文本的某种特征，例如性别、类别、数量等。通过多维度的数值表示，计算机能够理解并解析文本的复杂语义结构。例如，“man”和“woman”在描述性别维度上具有相似性，而“king”和“queen”则在性别和王室身份等维度上表现出相似的语义特征。</li>
<li>向量是一组在高维空间中定义点的数值数组，而<strong>嵌入则是将文本等信息转化为这种向量表示的技术过程</strong>。这些向量能够捕捉数据的语义及其他重要特征，使得语义相近的对象在向量空间中彼此邻近，而语义相异的对象则相距较远。<strong>向量检索（Vector Retrieval）是一种基于向量表示的搜索技术</strong>，通过计算查询向量与已知文本向量的相似度来识别最相关的文本数据。向量检索的高效性在于，它能在大规模数据集中快速、准确地找到与查询最相关的内容，这得益于向量表示中蕴含的丰富语义信息</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf4058e3d8db43428fca38e9ab721230~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=HLFy1l6XYycmzRW4jcW8PU9HFhA%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-6">Embedding Model 嵌入模型</h5>
<ul>
<li>在 RAG 系统中，Embedding Model 嵌入模型扮演着关键角色，负责将文本数据映射到高维向量空间，以便高效检索和处理。具体而言，<strong>Embedding Model 将输入的文档片段（Chunks）和查询文本（Query）转换为嵌入向量（Vectors）</strong>，这些向量捕捉了文本的语义信息，并可在向量空间中与其他嵌入向量进行比较。</li>
<li>在 RAG 流程中，文档首先被分割成多个片段，每个片段随后通过 Embedding Model 进行嵌入处理。生成的文档嵌入向量被存储在 VectorStore 中，供后续检索使用。用户查询会通过 Embedding Model 转换为查询嵌入向量，这些向量用于在向量数据库中匹配最相似的文档片段，最终组合生成指令（Prompt），大模型生成回答。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e3562acff2cf41c48dfb06f9240dd40d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=qO5V8r2831bSAGvSfQ%2FrthZNXm8%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-7">向量数据库</h5>
<p>在 RAG 系统中，向量数据库起着重要的作用。其主要功能在于索引过程中，<strong>建立高效的向量索引结构</strong>，以便快速定位与查询相关的向量数据。在查询阶段，系统将输入的提示转化为向量表示形式，并从数据库中<strong>检索出与之最相关的向量及其对应的分块数据</strong>。通过这种索引和检索机制，检索到的向量为生成模型提供了必要的上下文信息，使模型能够依据当前的语义上下文生成更加精准和相关的响应。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11a38d4745fb4ebc98bfbceeecda0462~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=kRsrrHLwfxBtKPfabrUtY7M47Mg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-8">RAG检索</h4>
<h5 data-id="heading-9">背景</h5>
<p>当前主流的 RAG 检索方式主要采用<strong>向量检索</strong>，通过语义相似度来匹配文本切块，这种方法在<strong>Embedding Model</strong>小节已经介绍过了。然而，向量检索并非万能，它在某些场景下无法替代传统关键词检索的优势。</p>
<p>例如，当你需要精准搜索某个订单 ID、品牌名称或地址，或者搜索特定人物或物品的名字（如周杰伦、 小米14）时，<strong>向量检索的<strong><strong>准确性</strong></strong>往往不如关键词检索</strong>。此外，当用户输入的问题<strong>非常简短</strong>，仅包含几个单词时，比如搜索缩写词或短语（如 RAG、LLM），<strong>语义匹配的效果也可能不尽理想</strong>。</p>
<p>这些正是传统关键词检索的优势所在。关键词检索（Keyword Search）在几个场景中表现尤为出色：<strong>精确匹配</strong>，如产品名称、姓名、产品编号；少量字符的匹配，用户习惯于输入几个关键词，而少量字符进行向量检索时效果可能较差；以及<strong>低频词汇的匹配</strong>，低频词汇往往承载了关键意义，如在“你想跟我去喝咖啡吗？”这句话中，“喝”“咖啡”比“你”“吗”更具重要性。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/beacdae9ce0c4e92b3a5dd2b0e98acff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=%2Fobn%2BfPKXTm%2BkJoClfPrqQOhvKs%3D" alt="" loading="lazy"/></p>
<p>在上述案例中，虽然依靠<strong>关键词检索可以精确找到与“订单 12345”匹配的特定信息</strong>，<strong>但它无法提供与订单相关的更广泛上下文</strong>。另一方面，<strong>语义匹配</strong>虽然能够识别“订单”和“配送”等相关概念，但在处理具体的订单 ID 时，往往容易出错。</p>
<p><strong>混合检索（Hybrid Search）通过结合关键词检索和语义匹配的优势</strong>，可以首先利用关键词检索精确定位到“订单 12345”的信息，然后通过语义匹配扩展与该订单相关的其他上下文或客户操作的信息，例如“12 开头的订单、包装破损严重”等。这样不仅能够获取精确的订单详情，还能获得与之相关的额外有用信息。</p>
<p>在 RAG 检索场景中，<strong>首要目标是确保最相关的结果能够出现在候选列表中</strong>。向量检索和关键词检索各有其独特优势，混合检索通过结合这多种检索技术，弥补了各自的不足，提供了一种更加全面的搜索方案。</p>
<h5 data-id="heading-10">混合检索(多路召回)</h5>
<p>混合检索是指在检索过程中同时采用多种检索方式，并将各类检索结果进行融合，从而得到最终的检索结果。<strong>混合检索的优势在于能够充分利用不同检索方式的优点，弥补各自的不足，从而提升检索的准确性和效率</strong>。下图展示了混合检索的流程：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/730e27bc39c145d4854617fdceb07354~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=gqQKYo%2BjS%2BVoCtLqQRKtaKwrRHE%3D" alt="" loading="lazy"/></p>
<p>混合检索的本质在于融合多种检索方式的优势，其具体实现并不局限于特定的技术组合。以常见的"<strong>向量检索+关键词检索</strong>"为例，这只是混合检索的一种典型模式，实际上系统可以灵活集成各类检索算法。例如，在更复杂的场景下，可以结合知识图谱技术（如graphRAG）进行实体关系检索，再与向量语义检索协同工作，这种多模态的检索策略同样属于混合检索的范畴。不同检索方式的组合选择应当基于具体业务需求，通过优势互补来提升整体检索效果。</p>
<ol>
<li>重排序</li>
</ol>
<p><strong>重排序（Reranking）的目的是将混合检索的结果进行整合，并将与用户问题语义最契合的结果排在前列</strong>。</p>
<p>下图中仅仅混合检索，由于缺乏有效的排序，我们期望的结果位于第一和第四位，尽管依然可以被检索到，但理想情况下，如果检索方式更为精确，该结果应该被优先排序在前两位。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4f8dd5c2fb54ab98d78b0f8ebcb49c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=shSldxDC6JmV4xFDKNt0eDijQ%2BQ%3D" alt="" loading="lazy"/></p>
<p>在这个案例中，我们通过重排序技术成功找到了与问题语义最契合的结果。系统评分显示，“订单 12345 于 2023 年 8 月 15 日在上海，客户不满意。”与“该 12 开头的订单客户不满意的地方在于包装破损严重。”这两个文档块的相关性分别为 0.9 和 0.8，排序为第一和第二位。</p>
<p>重排序技术在检索系统中扮演着至关重要的角色。即使检索算法已经能够捕捉到所有相关的结果，重排序过程依然不可或缺。它确保最符合用户意图和查询语义的结果优先展示，从而提升用户的搜索体验和结果的准确性。通过重排序，检索系统不仅能找到相关信息，还能智能地将最重要的信息呈现在用户面前。</p>
<p><strong>重排序优势：</strong></p>
<ol>
<li><strong>优化检索结果</strong> RAG系统中的初始检索结果（如向量搜索或关键词检索）往往包含冗余或不完全相关的文档。通过重排序技术，可对这些结果进行精细化筛选和排序，确保最相关、质量最高的文档优先呈现，从而提升后续处理的效率和质量。</li>
<li><strong>增强上下文相关性</strong> 生成模型的输出质量直接受检索文档的影响。重排序通过重新评估文档与查询的匹配度，优先选择高相关性内容作为上下文，显著提高生成答案的准确性和逻辑连贯性，减少无关信息的干扰。</li>
<li><strong>应对复杂查询</strong> 面对复杂或多维度的查询，初始检索可能返回表面相关但实质偏离的文档。重排序技术通过深入分析查询意图和文档价值，优先筛选出提供关键见解的内容，确保系统能够精准响应复杂问题，提升整体可靠性</li>
</ol>
<h4 data-id="heading-11">RAG生成</h4>
<p>在RAG系统的生成阶段，核心流程是将用户查询与检索到的相关信息通过特定指令组合后输入大语言模型，由模型处理后生成最终回复。这一过程看似简单，但有两个关键因素直接影响系统的最终表现：</p>
<ol>
<li><strong>大模型的选择与调优</strong> 大模型作为RAG系统的"大脑"，其选择直接决定了系统的理解能力和生成质量。不同模型在知识广度、推理深度和语言表达上存在显著差异，需要根据具体应用场景选择适合的模型。同时，针对特定领域的微调可以进一步提升模型的专业性表现。</li>
<li><strong>提示词工程优化</strong> 精心设计的提示词（prompt）是连接检索结果和生成模型的关键桥梁。通过优化指令结构、上下文组织和角色设定，可以显著提升模型对检索内容的理解深度，确保生成的回答既准确又符合预期格式。有效的提示词工程需要考虑信息优先级、指令明确性和上下文相关性等多个维度。</li>
</ol>
<p>这两个环节相辅相成，共同决定了RAG系统最终的响应质量和用户体验。在实际应用中，往往需要根据具体需求对这两个方面进行持续调优和平衡。</p>
<ol>
<li>大模型选择</li>
</ol>
<p>大模型的选择直接影响RAG系统的核心能力。在选型时需要综合评估模型的知识广度、推理深度、响应速度等关键指标。通用大模型如Deepseek具备较强的语义理解和泛化能力，适合开放域问答场景；而垂直领域模型经过专业数据微调后，在特定领域往往表现更精准。同时，70亿参数左右的中等规模模型经过优化后，通常能在效果与成本间取得较好平衡。</p>
<ol>
<li>提示词工程</li>
</ol>
<p>提示词工程（Prompt Engineering）是优化生成式AI模型输入输出的关键技术，其核心在于通过精心设计的提示词（Prompt）充分激发语言模型的潜力。作为连接用户需求与AI能力的桥梁，提示词工程通过<strong>结构化输入引导模型更精准地完成各类任务</strong>，包括内容创作、代码生成、智能对话等。</p>
<p><strong>一个高效的提示词通常包含四个关键要素</strong>：</p>
<ul>
<li>明确的指令（Instruction）定义具体任务要求</li>
<li>上下文信息（Context）提供必要的背景知识</li>
<li>输入数据（Input Data）呈现待处理的核心内容</li>
<li>输出指示符（Output Indicator）规范结果的格式与形式</li>
</ul>
<p>这种结构化设计能显著提升模型输出的相关性和可用性，使AI生成结果更符合实际应用需求。随着大模型技术的发展，提示词工程已成为提升AI系统性能的重要方法论。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 OpenSearch 到 Apache Doris：领创集团日志系统升级实践，降本 45%]]></title>    <link>https://juejin.cn/post/7571060853353676810</link>    <guid>https://juejin.cn/post/7571060853353676810</guid>    <pubDate>2025-11-10T12:31:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7571060853353676810" data-draft-id="7571060853353660426" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 OpenSearch 到 Apache Doris：领创集团日志系统升级实践，降本 45%"/> <meta itemprop="keywords" content="大数据,Apache"/> <meta itemprop="datePublished" content="2025-11-10T12:31:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SelectDB"/> <meta itemprop="url" content="https://juejin.cn/user/3189021726222904"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 OpenSearch 到 Apache Doris：领创集团日志系统升级实践，降本 45%
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3189021726222904/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SelectDB
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:31:24.000Z" title="Mon Nov 10 2025 12:31:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>随着业务全球化扩展与数字化运营的深入推进，日志系统的规模和复杂度不断攀升，原有基于 OpenSearch 的日志平台逐渐难以满足成本控制、性能保障和可维护性等多维需求。为应对持续增长的数据压力和更灵活的分析场景，领创集团技术团队启动了日志系统的架构升级实践，并最终选择 Apache Doris 作为新一代日志系统的核心。实现了综合成本下降超 45%、查询性能提升 5 倍、日志写入达到准实时以及灵活的运维策略等一系列显著收益。</p>
<h2 data-id="heading-0">一、业务背景</h2>
<p>领创集团（Advance Intelligence Group）成立于 2016 年，是 AI 技术驱动的科技独角兽企业，致力于建立以 AI 为核心的金融+数据平台，让每个人都能更轻松、公平地获得优质的金融产品与服务。</p>
<p>集团总部位于新加坡，集团旗下拥有两大业务线，ADVANCE.AI 是全球领先的人工智能与金融科技企业，提供数字身份验证、KYC/KYB、合规、风险管理和信用信息等服务。目前，已与银行、金融服务、金融科技、跨境支付、交易平台、零售和电商等行业客户建立了合作伙伴关系，服务遍布六大洲；Atome Financial 是东南亚领先的数字金融平台，为消费者搭建多产品的数字金融服务，实现普惠金融，目前已服务超过 5300 万消费者，累计 GMV 超过 80 亿美元。</p>
<p>集团发展至今拥有超过 1400 名员工，业务遍及六大洲的 80 个国家，已完成 D 轮融资。</p>
<h2 data-id="heading-1">二、早期架构及痛点</h2>
<p>随着公司业务规模的迅猛扩张，系统日志的生成量呈指数级增长，原有基于 OpenSearch 的日志分析平台逐渐暴露出一系列结构性瓶颈，难以支撑日益复杂和高频的日志处理需求，具体体现在以下几个方面：</p>
<ul>
<li><strong>成本飙升快</strong>：随着日志量持续增长，计算和存储压力显著增加，服务器资源消耗、对象存储开销以及节点本地存储需求叠加，导致整体数据成本居高不下。</li>
<li><strong>查询性能慢</strong>：在高并发、复杂多维度查询场景下，OpenSearch 的响应速度明显下降，严重影响业务的实时性与运营效率。</li>
<li><strong>运维复杂度高</strong>：每次系统扩容不仅带来更多的资源消耗，还进一步加剧了运维的复杂性，提升了维护成本和风险。</li>
</ul>
<p>在此背景下，我们启动了日志系统重构项目，目标是在降低总体拥有成本的同时，保证日志系统的高可用性、实时性和查询性能。</p>
<h2 data-id="heading-2">三、选型与对比</h2>
<p>在技术选型阶段，我们评估了多种日志系统解决方案，包括 ClickHouse、Doris、StarRocks 等。经过技术评估与实际测试，最终选择 Doris 作为新一代日志分析平台的核心组件，主要基于 Doris 的高效的列式压缩、准实时写入、灵活的扩缩容机制、强大的查询能力、兼容性好、运维成本低等关键优势。</p>
<p>以下是我们在 OpenSearch 与 Doris 之间进行全面技术对比的核心结论：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7b546fbfbab49b09e82e39f1750ed79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382684&amp;x-signature=g0Pj1upNvnoVVr61U7jJoERgZ40%3D" alt="选型与对比.png" loading="lazy"/></p>
<h2 data-id="heading-3">四、迁移实施步骤</h2>
<p>日志系统的迁移不仅涉及数据和服务迁移，还需要对查询方式和运维流程进行调整。</p>
<p>我们整体分为以下步骤：</p>
<ol>
<li><strong>数据模型设计与映射</strong> ：将原有 JSON 日志结构化，设计对应 Doris 表结构，并结合日志种类进行规范化建模（例如：msg、logger、level 等）。</li>
<li><strong>日志采集通道改造</strong> ：原使用 Kafka → Logstash → OpenSearch 采集链路，我们替换为 Kafka → Logstash →  Doris Stream Load，实现高吞吐、低延迟的数据写入。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4786b7d2867e423fb11a33e666f90f5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382684&amp;x-signature=HuobKmzXh57c5swkCIxqnjJLUfw%3D" alt="迁移实施.png" loading="lazy"/></p>
<ol start="3">
<li><strong>查询语句替换</strong> ：将原 Kibana 上的 DSL 查询语句转换为 SQL 语句，并结合 Doris 的分区裁剪、列裁剪、谓词下推等机制优化执行计划。</li>
<li><strong>系统压测与灰度切换</strong> ：在测试环境对比查询性能与写入压力，验证稳定性后，分阶段迁移各日志模块，最终实现全量替换。</li>
</ol>
<h2 data-id="heading-4">五、成本优化效果</h2>
<p>迁移前后在节点规模、对象存储和查询性能方面均实现显著优化：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d09e9bff85b430385272f0903a0e56a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382684&amp;x-signature=T%2Fbk4hB8sBxvHROT0fSaa00g46w%3D" alt="成本优化效果.png" loading="lazy"/></p>
<p>此外，Doris 支持灵活的弹性扩缩容，并具备高效的数据压缩机制。即便未来日志数据量持续增长，也能显著降低存储与运维成本。</p>
<h2 data-id="heading-5">六、日志系统迁移挑战与经验分享</h2>
<h3 data-id="heading-6">01 查询语义转换</h3>
<p>OpenSearch 支持 DSL 语法和全文搜索，Doris 目前只支持 SQL 语法。</p>
<p><strong>解决方案</strong>：与业务团队协作，将现有的 DSL 查询统一修改为 SQL 查询。</p>
<h3 data-id="heading-7">02 Doris 查询 UI 缺少日志分析视图</h3>
<p>相较于 OpenSearch + Dashboards 的成熟可视化，Doris 原生缺少日志分析视图。</p>
<p><strong>解决方案</strong>：内部开发了日志查询页面替代 Kibana 查询页面。</p>
<p><strong>社区目前对 Kibana 的支持：</strong></p>
<p>考虑到用户对 Kibana 的强依赖，社区经评估后推出了 es2doris 工具。该工具实现了从 Elasticsearch 的 DSL 到 Doris SQL 的自动转换，使得原本调用 Elasticsearch 接口的应用程序（如 Kibana）无需任何改动，即可通过 es2doris 间接访问 Doris。用户可直接将现有的 Kibana 连接至 es2doris 服务，无缝延续使用体验。</p>
<h3 data-id="heading-8">03 扩容期间负载倾斜</h3>
<p>Doris 扩容时会涉及 Tablet  Schedule 和 Balance，若节点过少或数据不均可能短时导致查询卡顿。</p>
<p><strong>解决方案</strong>：在进行扩容时候，需要结合当前的机器负载情况，提前进行资源预估，如果机器负载比较高，在进行 Tablet 迁移的时候可能会占用部分资源，导致节点资源紧张，出现读写性能变面的情况，需要结合调度限流策略和后台迁移节奏控制，避免高峰期触发重负载影响生产业务。</p>
<h2 data-id="heading-9">七、总结与展望</h2>
<p>本次日志系统迁移从 OpenSearch 到 Apache Doris，不仅达成了显著的成本节省目标，更为未来系统扩展、查询效率、可运维性打下了坚实基础。</p>
<p><strong>核心收益包括：</strong></p>
<ul>
<li>大幅减少服务器和对象存储支出，<strong>综合成本下降超 45%</strong>；</li>
<li>查询响应时间<strong>缩短至原系统的 1/5 以下</strong>；</li>
<li>日志写入几乎实时，支持更及时的业务反馈；</li>
<li>系统架构更简单、可维护性更强，支持更灵活的运维策略。</li>
</ul>
<p>通过这次实践，我们验证了在日志系统中“结构化 + 列式存储 + MPP 查询”模式的巨大潜力。在追求性能和成本平衡的场景下，Doris 提供了一条可行且高效的替代路径，为企业日志平台建设提供了新的思路与方向。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude Skills 从零到一：手把手打造专属公众号文风生成器，10 分钟搞定 AI 技能定制]]></title>    <link>https://juejin.cn/post/7570793903848898575</link>    <guid>https://juejin.cn/post/7570793903848898575</guid>    <pubDate>2025-11-10T12:23:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570793903848898575" data-draft-id="7570940025580535848" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude Skills 从零到一：手把手打造专属公众号文风生成器，10 分钟搞定 AI 技能定制"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T12:23:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wwwzhouhui"/> <meta itemprop="url" content="https://juejin.cn/user/3428746411400537"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude Skills 从零到一：手把手打造专属公众号文风生成器，10 分钟搞定 AI 技能定制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3428746411400537/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wwwzhouhui
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:23:29.000Z" title="Mon Nov 10 2025 12:23:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1.前言</h2>
<p>Claude Skills 是 Anthropic 为 Claude 系列大模型推出的 <strong>模块化、可组合、可移植的能力封装体系</strong>。通过把特定任务的指令、脚本、参考资料等组织成一个独立的文件夹（即一个 Skill），Claude 能在需要时 <strong>按需加载</strong> 这些指令，从而在同一模型中实现多种专业化功能，而不必每次都在提示中塞满大量文本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79bd445af4814765bc6bf4a640efb6ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=KRlGbDl8KoIEtHIIR0G4dqQgPeI%3D" alt="image-20251106171719404" loading="lazy"/></p>
<p>上期给大家介绍过关于Claude Skills官方的提供的 Skills 给大家介绍了3个实际的案例。对这块不熟悉的小伙伴可以看我之前的文章《<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOXp_CAusfvMVSjGHhBjQGQ" target="_blank" title="https://mp.weixin.qq.com/s/OXp_CAusfvMVSjGHhBjQGQ" ref="nofollow noopener noreferrer">Claude Skills 实战指南：3 分钟搞定 PPT、海报与 Logo，AI 办公效率翻倍！</a>》</p>
<p>很多小伙伴比较好奇，怎么做一个属于自己的skills呢？今天小编就带大家手把手做一个skills.</p>
<h2 data-id="heading-1">2.Claude  Skills制作</h2>
<p>首先我们需要在Claude 官方文档中查看一下Skills 创建步骤。我们可以打开<a href="https://link.juejin.cn?target=https%3A%2F%2Fsupport.claude.com%2Fen%2Farticles%2F12512198-how-to-create-custom-skills" target="_blank" title="https://support.claude.com/en/articles/12512198-how-to-create-custom-skills" ref="nofollow noopener noreferrer">support.claude.com/en/articles…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94b1bb309edd4dd49ff7d5fbdbdb3aa3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=oMAOAPHmF376DQWOihBf%2BHB9Bj8%3D" alt="image-20251110151034481" loading="lazy"/></p>
<p>全是英文的看得费劲，怎么办？我们借用AI帮我们总结归纳一下。</p>
<h3 data-id="heading-2">创建skill创建帮助文档</h3>
<p>​    我们使用AI帮我总结归纳一下上面是如何创建skill。打开claude code 输入下面的提示词</p>
<pre><code class="hljs language-ruby" lang="ruby">请阅读<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/support.claude.com/en</span><span class="hljs-regexp">/articles/</span><span class="hljs-number">12512198</span>-how-to-create-custom-skills文档的内容，给出整理出一个最简单创建claude skill的操作步骤文档。请输出“skill创建帮助文档.md”
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f46ff6f7429049e48af0584776dcf08b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=2AM3ZUgDxFsYDmvpSctt%2F8oGVcw%3D" alt="image-20251110151346350" loading="lazy"/></p>
<p>AI 很快帮我生成如何创建这个skill，这样我们看到中文就好很理解了。 打开文档看一下。（我们使用markdown工具打开）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bdbd606f162d447ba31d99b255095137~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=Nh7knpU%2BsnsgilKq0knFQu0kRmk%3D" alt="image-20251110151552968" loading="lazy"/></p>
<p>这样看起来就非常容易理解了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e550b5435cab455aac6aa63de58ead2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=zJrcuAMouQINehOLaVmmewvr%2FAY%3D" alt="image-20251110152231822" loading="lazy"/></p>
<p>​    项目的目录结构如下：</p>
<p>​    <img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3004c0b1e55b45819d5c4fcc5daacd33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=czBALF4csv24KPo%2BrUFqVQufDNE%3D" alt="image-20251110152318084" loading="lazy"/></p>
<p>总结就是4个步骤1创建目录结构、2 编写 Skill.md 3 打包 ZIP 文件 4 上传并启用。</p>
<p>通过上面的步骤我们就很容易理解了。原来写一个Skill.md 好像也不是很难。 其中核心的就是如何编写Skill.md。那么问题又来了，这Skill.md 怎么写呢？</p>
<h3 data-id="heading-3">编写一个skill</h3>
<p>我们知道skill 是一项技能，它可以在不同领域 。常见的办公任务(如 Excel 数据分析、PPT 演示生成、文档处理、品牌设计等)封装成可复用的技能模块。</p>
<p>接下来有一个这样的需求，我想做一个自己风格的公众号文章skill，这样我就可以以后输入一段信息让它批量生成各种我的风格的公众号文章了。有了上面的需求接下来我们就开始开干了。</p>
<p>我首先找一些我之前写的一些公众号文章。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6bcf5524ebd47f480068b710d6241ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=iEQOG5ovtCsBn5m81ngXKIcOhXQ%3D" alt="image-20251110161554722" loading="lazy"/></p>
<p>名字太长了我重命令一下。变成11. md 、22.md 、33.md 、44.md 、55.md</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91ae716f2bfb4963a3f627505fe841e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=c0Npz3Fsw1qYNpRs2sssz3gi%2Bwg%3D" alt="image-20251110161718175" loading="lazy"/></p>
<p>同样我们使用claude code 输入下面的提示词</p>
<pre><code class="hljs">请认真阅读“11.md”、“22.md”、“33.md”、“44.md”、“55.md” 文档，以上文档是我之前写的微信公众号的文章。请总结归纳出我微信公众号文档的特点，包括目录结构，语气、开头、结尾等信息。输出“小灰灰公众号特点.md” 文档
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5b5eff209a448479f73283a8d96d569~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=bB1sfY3UV35DPgihUOCmtEUWTlo%3D" alt="image-20251110161918817" loading="lazy"/></p>
<p>这个时候 AI 会学习我提供给它的5篇文章的内容，它总结归纳出我写作的风格输出“小灰灰公众号特点.md” 文档。文档片段如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfc646abcc32459a874549347776414d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=z3cXI7iYB7Ng9l2tgyQVpcCAQZg%3D" alt="image-20251110162310005" loading="lazy"/></p>
<p>嗯 AI总结的还算准确。当然这个如果有哪里不准确 可以手工去修改。</p>
<p>有了上面的小灰灰公众号特点.md 和skill创建帮助文档.md 接下来我们就可以让AI 帮我编写skills.md文档了。</p>
<p>提示词如下：</p>
<pre><code class="hljs">请参考“skill创建帮助文档.md”和“小灰灰公众号特点.md”帮我编写一个小灰灰公众号的skill插件。给出这个插件实现。
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41dc3eea2fb64284a70621ba1500b574~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=qM%2Bvm1TWP2xX3YcJfhuNdbM2VvQ%3D" alt="image-20251110162557839" loading="lazy"/></p>
<p>当然这个过程可能会遇到点问题，我的问题就是生产的skills.md文档乱码，应该是字符集的问题，我让AI 帮我修正。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c53bfd20d66439183124490eeb69d0b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=ibYllCp7JIRx0MdVH7NCJkhVZDA%3D" alt="image-20251110162719384" loading="lazy"/></p>
<p>这样我们就在xiaohuihui-tech-article 文件夹找到生成好的 skills.md</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efa49beab97e489e97c0e3e59c993c15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=8zwngDOx42LTc%2F%2BEY8vm21W8d3E%3D" alt="image-20251110162819428" loading="lazy"/></p>
<p>打开查看一下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f0368f0c84fc4f13934b42a33367266d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=JxOHaJNXsAKbTB0aW7VkrXVN7sg%3D" alt="image-20251110162855796" loading="lazy"/></p>
<p>看起来不错。我们把它也生成网页方便展示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9e4887abd68459ba08d990c9f363745~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=BBZrcVJUiQPqkgBNcOQhmfGoqNU%3D" alt="image-20251110163800267" loading="lazy"/></p>
<p>通过图表格式展示，这样skill.md方便理解多了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dcb06c3bb73645bba2108659e30ad2ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=3IWg2xcbb4H1OIHhP%2B4FZncvhm0%3D" alt="image-20251110163902850" loading="lazy"/></p>
<p>另外程序也基于skill创建帮助文档.md 还帮我把插件打包好了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4bef306a8034463dae348d3c84d5ecb6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=mJVMjTbgYaby4qqIoKgSsWURS3c%3D" alt="image-20251110164106077" loading="lazy"/></p>
<h3 data-id="heading-4">安装skill</h3>
<p>接下来我们需要安装这个自己开发的skill。我们这个这个压缩包复制到~/.claude/skills 文件夹中</p>
<p>输入</p>
<p>如果是windows平台可以手工复制到 C:\Users\xxx.claude\skills</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c94ac40cd51410a9e7af9dce51a41f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=2xvFWBjGr59%2BpVK9c5HeiiQYRNI%3D" alt="image-20251110164730420" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/822658b6aa734d9097df96e7d05e5a42~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=%2FKjS1VdpyIE6VAfQcEilKN%2Froww%3D" alt="image-20251110165041134" loading="lazy"/></p>
<p>我们检查一下这个skills是否可以使用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aab05ae7abff418d8dcd3cf69226ec4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=4ksyGty01WBHq4gYy896aqqnm10%3D" alt="image-20251110170638487" loading="lazy"/></p>
<h2 data-id="heading-5">3.使用skill生成文章</h2>
<p>​     接下来我们使用这个skill来生成一个小灰灰版本的公众号文章测试一下。</p>
<p>​      安装claude skills 我们退出claude  重新进入。</p>
<p>​     <img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a691220c63924640b4d01ced98a66639~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=lbyUmhwAULtaqOdU6dBCfbdEPOg%3D" alt="image-20251110170837560" loading="lazy"/></p>
<p>提示词如下：</p>
<pre><code class="hljs language-bash" lang="bash">请认真分析https://github.com/wwwzhouhui/in_animation开源项目，请帮我使用xiaohuihui-tech-article skill基于这个开源项目生成一个公众号文章。输出<span class="hljs-string">"20251101in_animation公众号文章.md"</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/63029ac38e974868b8a24790f3b28664~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=Alf8y4kqMGbT%2F3KTivGMY3PmRaA%3D" alt="image-20251110171352603" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1524879e10d47ecace8e0d0f27e8cf2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=7JpZBBZXa71h3wI2HW%2BEVvz0vGM%3D" alt="image-20251110174826034" loading="lazy"/></p>
<p>文章写完了，我们检查下生成好的文章。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/611194b1426f4486905272e459e49044~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=WCqrbxgca4wwk1Xh7pYKeGyaO2w%3D" alt="image-20251110175034671" loading="lazy"/></p>
<p>​     目录结构是符合我文章风格的。接下来我看一下文章的内容</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53704604904548a69c812aac14d8c9d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=x6%2Bd5aw7LAUZ9TqbrpBMt4iycAg%3D" alt="image-20251110175146630" loading="lazy"/></p>
<p>​     <img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a69b80864bcc40f6a95a42162cfe02cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=weahj2xEtAsHD63X%2FGLnAQQCQlA%3D" alt="image-20251110175215254" loading="lazy"/></p>
<p>文章前言和总结部分也的确是和我之前写文章风格比较相近。有个问题就是我的文章有大量的截图。这里图是缺失的，不过也是正常的，因为我之前压根就没有让它生成图。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8541841baa341de83cda4c2fb7d70b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=69txxllXyS6x6C8hsn3xORTNMC0%3D" alt="image-20251110175422733" loading="lazy"/></p>
<p>通过上面的方式我们基本上实现了一个基于小灰灰技术文章生成器skill 技能。</p>
<h2 data-id="heading-6">4.总结</h2>
<p>今天主要带大家了解并实现了自定义 Claude Skill 的创建与使用完整流程，该流程以 Anthropic 推出的 Skills 模块化体系为核心，通过分析官方文档的规范要求，结合 AI 辅助生成工具，形成了一套从技能定义到实际应用的实用化解决方案。</p>
<p>通过这套实践方案，用户能够低成本打造专属的 AI 技能模块 —— 借助四个核心步骤（目录结构创建、Skill.md 编写、ZIP 打包、上传启用）的清晰指引，无需复杂的开发经验，就能快速构建符合个人风格的专业化能力封装。无论是公众号文章生成、办公文档处理，还是特定领域的任务自动化，都能通过标准化的 Skill 格式实现，极大降低了开发者定制 Claude 能力的技术门槛。在实际验证中，我们创建的「小灰灰公众号文章生成器」能够稳定复现预设的写作风格，有效解决了重复创作中保持风格一致性的问题。同时，该方案具备良好的扩展性 —— 小伙伴们可以基于此流程扩展更多实用技能，如学术论文格式排版、产品文案批量生成、多语言内容转换等，进一步丰富 Claude 模型在实际业务场景中的应用价值。</p>
<p>感兴趣的小伙伴可以参照文中提供的步骤，结合自身需求创建专属 Skill 进行实践。今天的分享就到这里结束了，我们下一篇文章见。</p>
<p>附件资料</p>
<p>通过网盘分享的文件：小灰灰技术文章生成器+生成文章.zip
链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1xwzBWOkqsYaTg7zf9WsRag" target="_blank" title="https://pan.baidu.com/s/1xwzBWOkqsYaTg7zf9WsRag" ref="nofollow noopener noreferrer">pan.baidu.com/s/1xwzBWOkq…</a> 提取码: vjx9</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MiniMind 模型架构创新技术详解]]></title>    <link>https://juejin.cn/post/7570793903848996879</link>    <guid>https://juejin.cn/post/7570793903848996879</guid>    <pubDate>2025-11-10T12:51:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570793903848996879" data-draft-id="7570793903848980495" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MiniMind 模型架构创新技术详解"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-10T12:51:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="mwq30123"/> <meta itemprop="url" content="https://juejin.cn/user/3403743729030686"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MiniMind 模型架构创新技术详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3403743729030686/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    mwq30123
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:51:41.000Z" title="Mon Nov 10 2025 12:51:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读29分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">MiniMind 模型架构创新技术详解</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAlvinScrp%2Fminimind%2Fblob%2Fmaster%2Fmodel%2Fmodel.py" target="_blank" title="https://github.com/AlvinScrp/minimind/blob/master/model/model.py" ref="nofollow noopener noreferrer">github.com/AlvinScrp/m…</a></p>
<h3 data-id="heading-1">一、核心架构差异</h3>
<h4 data-id="heading-2">1. RMSNorm（Root Mean Square Layer Normalization）</h4>
<h5 data-id="heading-3">代码位置</h5>
<p><code>model/model.py:16-50</code></p>
<h5 data-id="heading-4">实现原理</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_norm</span>(<span class="hljs-params">self, x</span>):
    <span class="hljs-string">"""执行 RMS 归一化计算
    计算公式: x / sqrt(mean(x^2) + eps)
    """</span>
    <span class="hljs-keyword">return</span> x * torch.rsqrt(x.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean(-<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>) + self.eps)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
    <span class="hljs-keyword">return</span> self.weight * self._norm(x.<span class="hljs-built_in">float</span>()).type_as(x)
</code></pre>
<h5 data-id="heading-5">与LayerNorm的对比</h5>








































<table><thead><tr><th>特性</th><th>LayerNorm</th><th>RMSNorm</th></tr></thead><tbody><tr><td><strong>计算公式</strong></td><td><code>(x - mean) / sqrt(var + eps)</code></td><td><code>x / sqrt(mean(x^2) + eps)</code></td></tr><tr><td><strong>减去均值</strong></td><td>✅ 是</td><td>❌ 否</td></tr><tr><td><strong>计算量</strong></td><td>较高</td><td><strong>较低</strong></td></tr><tr><td><strong>内存占用</strong></td><td>较高</td><td><strong>较低</strong></td></tr><tr><td><strong>稳定性</strong></td><td>非常好</td><td>良好</td></tr><tr><td><strong>GPU友好度</strong></td><td>一般</td><td><strong>极好</strong></td></tr></tbody></table>
<h5 data-id="heading-6">选取原因</h5>
<ul>
<li><strong>计算效率</strong>：RMSNorm 消除了减去均值的步骤，减少了计算量</li>
<li><strong>内存效率</strong>：不需要存储均值和方差，内存占用更少</li>
<li><strong>现代LLM标准</strong>：LLaMA、Falcon等最新大模型都采用RMSNorm</li>
<li><strong>GPU优化</strong>：更易被GPU的底层优化内核加速</li>
</ul>
<h5 data-id="heading-7">技术对比系列</h5>
<ul>
<li><strong>L1 Normalization</strong>：固定均值和方差（过时）</li>
<li><strong>BatchNorm</strong>：跨batch维度归一化（不适用序列任务）</li>
<li><strong>LayerNorm</strong>：跨特征维度归一化（标准做法）</li>
<li><strong>GroupNorm</strong>：分组归一化（介于两者之间）</li>
<li><strong>RMSNorm</strong> ⭐：简化的LayerNorm（当前最优实践）</li>
</ul>
<h5 data-id="heading-8">核心优势</h5>
<pre><code class="hljs language-erlang" lang="erlang">计算复杂度降低 <span class="hljs-number">30</span>-<span class="hljs-number">40</span><span class="hljs-comment">%</span>
↓
训练和推理速度更快
↓
显存占用更少
↓
可训练更大模型或更长序列
</code></pre>
<hr/>
<h4 data-id="heading-9">2. RoPE（Rotary Position Embeddings）</h4>
<h5 data-id="heading-10">代码位置</h5>
<p><code>model/model.py:53-74</code> 和 <code>model/model.py:77-113</code></p>
<h5 data-id="heading-11">实现原理</h5>
<p><strong>预计算阶段</strong> (model.py:53-74)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">precompute_pos_cis</span>(<span class="hljs-params">dim: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(<span class="hljs-params"><span class="hljs-number">32</span> * <span class="hljs-number">1024</span></span>), theta: <span class="hljs-built_in">float</span> = <span class="hljs-number">1e6</span></span>):
    <span class="hljs-string">"""预计算旋转位置编码所需的复数值"""</span>
    <span class="hljs-comment"># 计算不同频率的逆频率项</span>
    freqs = <span class="hljs-number">1.0</span> / (theta ** (torch.arange(<span class="hljs-number">0</span>, dim, <span class="hljs-number">2</span>)[: (dim // <span class="hljs-number">2</span>)].<span class="hljs-built_in">float</span>() / dim))
    <span class="hljs-comment"># 生成位置索引</span>
    t = torch.arange(end, device=freqs.device)
    <span class="hljs-comment"># 计算外积得到每个位置对应的每个频率</span>
    freqs = torch.outer(t, freqs).<span class="hljs-built_in">float</span>()
    <span class="hljs-comment"># 使用欧拉公式 e^(i*θ) = cos(θ) + i*sin(θ) 生成复数</span>
    pos_cis = torch.polar(torch.ones_like(freqs), freqs)  <span class="hljs-comment"># complex64</span>
    <span class="hljs-keyword">return</span> pos_cis
</code></pre>
<p><strong>应用阶段</strong> (model.py:77-113)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_rotary_emb</span>(<span class="hljs-params">xq, xk, pos_cis</span>):
    <span class="hljs-comment"># 将Q和K转换为复数形式</span>
    xq_ = torch.view_as_complex(xq.<span class="hljs-built_in">float</span>().reshape(*xq.shape[:-<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
    xk_ = torch.view_as_complex(xk.<span class="hljs-built_in">float</span>().reshape(*xk.shape[:-<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))

    <span class="hljs-comment"># 在复数域中应用旋转（乘以pos_cis）</span>
    xq_out = torch.view_as_real(xq_ * pos_cis).flatten(<span class="hljs-number">3</span>)
    xk_out = torch.view_as_real(xk_ * pos_cis).flatten(<span class="hljs-number">3</span>)
    <span class="hljs-keyword">return</span> xq_out.type_as(xq), xk_out.type_as(xk)
</code></pre>
<h5 data-id="heading-12">与传统位置编码的对比</h5>















































<table><thead><tr><th>特性</th><th>绝对位置编码</th><th>相对位置编码</th><th>RoPE</th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>直接加到嵌入</td><td>相对位置矩阵</td><td>复数旋转</td></tr><tr><td><strong>外推性能</strong></td><td>❌ 极差</td><td>一般</td><td>✅<strong>优秀</strong></td></tr><tr><td><strong>长文本适应</strong></td><td>❌ 无法处理</td><td>中等</td><td>✅<strong>可达32K+</strong></td></tr><tr><td><strong>计算复杂度</strong></td><td>O(1)</td><td>O(n²)</td><td>O(n)</td></tr><tr><td><strong>显存占用</strong></td><td>最少</td><td>中等</td><td>极少</td></tr><tr><td><strong>理论基础</strong></td><td>无</td><td>相对位置偏置</td><td><strong>复数几何</strong></td></tr></tbody></table>
<h5 data-id="heading-13">选取原因</h5>
<p><strong>数学优雅性</strong>：</p>
<ul>
<li>利用复数旋转的几何性质编码位置信息</li>
<li>相邻位置之间的相对距离由旋转角度决定</li>
</ul>
<p><strong>外推能力</strong>：</p>
<ul>
<li>可以处理训练长度之外的序列（外推长度可达10-100倍）</li>
<li>这是LLaMA能处理4K→32K序列的关键</li>
</ul>
<p><strong>硬件友好</strong>：</p>
<ul>
<li>无需额外的位置矩阵存储</li>
<li>计算可完全融合到Q、K的投影中</li>
</ul>
<h5 data-id="heading-14">技术演进线路</h5>
<pre><code class="hljs language-scss" lang="scss">绝对位置编码 (Sin/Cos embedding)
    ↓ <span class="hljs-selector-attr">[问题：外推能力差]</span>
相对位置编码 (Shaw et al., <span class="hljs-number">2018</span>)
    ↓ <span class="hljs-selector-attr">[问题：计算复杂度高]</span>
ALiBi (Press et al., <span class="hljs-number">2022</span>)
    ↓ <span class="hljs-selector-attr">[问题：需要修改注意力计算]</span>
RoPE (Su et al., <span class="hljs-number">2021</span>) ⭐
    ↓ <span class="hljs-selector-attr">[最优方案]</span>
YaRN / NTK-Aware (<span class="hljs-number">2023</span>)
</code></pre>
<h5 data-id="heading-15">核心优势</h5>
<pre><code class="hljs">相对位置不变性
↓
频率分解的自然性
↓
优秀的外推性能
↓
可训练更长序列
</code></pre>
<hr/>
<h4 data-id="heading-16">3. GQA（Grouped-Query Attention）</h4>
<h5 data-id="heading-17">代码位置</h5>
<p><code>model/model.py:142-280</code></p>
<h5 data-id="heading-18">实现原理</h5>
<p><strong>头部配置</strong> (model.py:163-201)：</p>
<pre><code class="hljs language-python" lang="python">self.n_kv_heads = args.n_kv_heads <span class="hljs-keyword">if</span> args.n_kv_heads <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> args.n_heads
<span class="hljs-keyword">assert</span> args.n_heads % self.n_kv_heads == <span class="hljs-number">0</span>  <span class="hljs-comment"># Q头数必须是KV头数的倍数</span>
self.n_rep = self.n_local_heads // self.n_local_kv_heads  <span class="hljs-comment"># 每个KV头对应的Q头数</span>
</code></pre>
<p><strong>重复KV头</strong> (model.py:116-139)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeat_kv</span>(<span class="hljs-params">x: torch.Tensor, n_rep: <span class="hljs-built_in">int</span></span>) -&gt; torch.Tensor:
    <span class="hljs-string">"""将KV头重复n_rep次以匹配Q头数量"""</span>
    bs, slen, n_kv_heads, head_dim = x.shape
    <span class="hljs-keyword">if</span> n_rep == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> x
    <span class="hljs-keyword">return</span> (
        x[:, :, :, <span class="hljs-literal">None</span>, :]
        .expand(bs, slen, n_kv_heads, n_rep, head_dim)
        .reshape(bs, slen, n_kv_heads * n_rep, head_dim)
    )
</code></pre>
<p><strong>注意力计算</strong> (model.py:244-272)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 重复KV头以匹配Q头数量</span>
xq, xk, xv = (
    xq.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
    repeat_kv(xk, self.n_rep).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),  <span class="hljs-comment"># ← 关键：KV被重复</span>
    repeat_kv(xv, self.n_rep).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
)
</code></pre>
<h5 data-id="heading-19">与标准MHA的对比</h5>















































<table><thead><tr><th>特性</th><th>MHA</th><th>MQA</th><th>GQA</th></tr></thead><tbody><tr><td><strong>Q头数</strong></td><td>n</td><td>n</td><td>n</td></tr><tr><td><strong>KV头数</strong></td><td>n</td><td>1</td><td>n/g (可调)</td></tr><tr><td><strong>KV投影参数</strong></td><td>最多</td><td>最少</td><td><strong>中等</strong></td></tr><tr><td><strong>推理显存</strong></td><td>基准</td><td>减少 95%</td><td>减少 50-80%</td></tr><tr><td><strong>推理速度</strong></td><td>基准</td><td><strong>快</strong></td><td><strong>快</strong></td></tr><tr><td><strong>精度损失</strong></td><td>0%</td><td>0-2%</td><td><strong>&lt;0.5%</strong></td></tr></tbody></table>
<h5 data-id="heading-20">配置示例</h5>
<pre><code class="hljs language-ini" lang="ini">标准 MHA：<span class="hljs-attr">Q</span>=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">32</span>头
    ↓
MQA：<span class="hljs-attr">Q</span>=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">1</span>头 (激进，精度可能下降)
    ↓
GQA (<span class="hljs-attr">n_kv_heads</span>=<span class="hljs-number">4</span>)：Q=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">4</span>头 (均衡) ⭐
    ↓
GQA (<span class="hljs-attr">n_kv_heads</span>=<span class="hljs-number">8</span>)：Q=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">8</span>头 (接近MHA)
</code></pre>
<h5 data-id="heading-21">选取原因</h5>
<p><strong>推理性能</strong>：</p>
<ul>
<li>KV缓存大小减少，提高显存利用率</li>
<li>在长序列生成时显著加速</li>
</ul>
<p><strong>训练稳定性</strong>：</p>
<ul>
<li>相比MQA，精度损失极小（&lt;0.5%）</li>
<li>保留了足够的KV多样性</li>
</ul>
<p><strong>工业标准</strong>：</p>
<ul>
<li>Llama 2使用GQA</li>
<li>OpenAI的最新模型采用此方案</li>
</ul>
<h5 data-id="heading-22">技术演进</h5>
<pre><code class="hljs language-scss" lang="scss">Multi-Head Attention (Vaswani et al., <span class="hljs-number">2017</span>)
    ↓ <span class="hljs-selector-attr">[问题：推理时KV缓存太大]</span>
Multi-Query Attention (Shazeer, <span class="hljs-number">2019</span>)
    ↓ <span class="hljs-selector-attr">[问题：精度下降明显]</span>
Grouped-Query Attention (Ainslie et al., <span class="hljs-number">2023</span>) ⭐
    ↓ <span class="hljs-selector-attr">[最优平衡点]</span>
</code></pre>
<h5 data-id="heading-23">核心优势</h5>
<pre><code class="hljs language-erlang" lang="erlang">KV缓存减少 <span class="hljs-number">50</span>-<span class="hljs-number">80</span><span class="hljs-comment">%</span>
↓
推理显存压力减轻
↓
可提高吞吐量或处理更长序列
↓
精度基本无损
</code></pre>
<hr/>
<h4 data-id="heading-24">4. Flash Attention</h4>
<h5 data-id="heading-25">代码位置</h5>
<p><code>model/model.py:254-261</code></p>
<h5 data-id="heading-26">实现原理</h5>
<p><strong>检测与启用</strong> (model.py:194-195)：</p>
<pre><code class="hljs language-python" lang="python">self.flash = <span class="hljs-built_in">hasattr</span>(torch.nn.functional, <span class="hljs-string">'scaled_dot_product_attention'</span>) <span class="hljs-keyword">and</span> args.flash_attn
</code></pre>
<p><strong>调用方式</strong> (model.py:254-261)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> self.flash <span class="hljs-keyword">and</span> seq_len != <span class="hljs-number">1</span>:
    dropout_p = self.dropout <span class="hljs-keyword">if</span> self.training <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>
    output = F.scaled_dot_product_attention(
        xq, xk, xv,
        attn_mask=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># Flash Attention内部处理因果掩码</span>
        dropout_p=dropout_p,
        is_causal=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 指示使用因果掩码</span>
    )
<span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 降级到标准注意力</span>
    scores = (xq @ xk.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) / math.sqrt(self.head_dim)
    scores += self.mask[:, :, :seq_len, :seq_len]
    scores = F.softmax(scores.<span class="hljs-built_in">float</span>(), dim=-<span class="hljs-number">1</span>).type_as(xq)
    scores = self.attn_dropout(scores)
    output = scores @ xv
</code></pre>
<h5 data-id="heading-27">与标准Attention的对比</h5>








































<table><thead><tr><th>特性</th><th>标准Attention</th><th>Flash Attention</th></tr></thead><tbody><tr><td><strong>计算流程</strong></td><td>Q@K→softmax→@V</td><td>优化的融合核</td></tr><tr><td><strong>中间张量</strong></td><td>需要存储N²分数矩阵</td><td>按块流式处理</td></tr><tr><td><strong>IO复杂度</strong></td><td>O(N²)</td><td>O(N)</td></tr><tr><td><strong>计算速度</strong></td><td>基准</td><td><strong>2-4倍快</strong></td></tr><tr><td><strong>显存占用</strong></td><td>基准</td><td><strong>减少 90%</strong></td></tr><tr><td><strong>精度</strong></td><td>FP32</td><td>FP16（自适应）</td></tr></tbody></table>
<h5 data-id="heading-28">工作原理（高层）</h5>
<p>标准方法的问题：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[Q @ K^T]</span> → 生成N×N的分数矩阵（显存瓶颈）
    ↓
<span class="hljs-selector-attr">[softmax]</span> → 每个元素依赖全局信息
    ↓
<span class="hljs-selector-attr">[@ V]</span> → 需要重新读取全N×N矩阵
</code></pre>
<p>Flash Attention解决方案：</p>
<pre><code class="hljs language-markdown" lang="markdown">将注意力计算分块进行：
<span class="hljs-bullet">  1.</span> 将Q、K、V分块加载到快速显存（SRAM）
<span class="hljs-bullet">  2.</span> 对每块计算注意力
<span class="hljs-bullet">  3.</span> 融合softmax和dropout
<span class="hljs-bullet">  4.</span> 直接写入结果，无需存储中间分数
</code></pre>
<h5 data-id="heading-29">选取原因</h5>
<p><strong>性能瓶颈突破</strong>：</p>
<ul>
<li>标准注意力的IO成为主要瓶颈（不是计算）</li>
<li>Flash Attention通过减少IO实现2-4倍加速</li>
</ul>
<p><strong>显存节省</strong>：</p>
<ul>
<li>关键在长序列场景下</li>
<li>可训练更长上下文</li>
</ul>
<p><strong>库支持</strong>：</p>
<ul>
<li>PyTorch 2.0+集成支持</li>
<li>无需额外依赖</li>
</ul>
<h5 data-id="heading-30">核心优势</h5>
<pre><code class="hljs">IO感知的算法设计
↓
充分利用GPU硬件特性
↓
推理和训练都快 2-4 倍
↓
长序列成为可能
</code></pre>
<hr/>
<h4 data-id="heading-31">5. KV Cache 优化</h4>
<h5 data-id="heading-32">代码位置</h5>
<p><code>model/model.py:236-242</code></p>
<h5 data-id="heading-33">实现原理</h5>
<p><strong>缓存保存</strong> (model.py:236-242)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># KV缓存处理：如果有历史KV，则与当前KV拼接</span>
<span class="hljs-keyword">if</span> past_key_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    xk = torch.cat([past_key_value[<span class="hljs-number">0</span>], xk], dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 拼接历史K和当前K</span>
    xv = torch.cat([past_key_value[<span class="hljs-number">1</span>], xv], dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 拼接历史V和当前V</span>

<span class="hljs-comment"># 如果需要缓存，则保存当前KV用于下一步</span>
past_kv = (xk, xv) <span class="hljs-keyword">if</span> use_cache <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
</code></pre>
<p><strong>生成时的使用</strong> (model.py:731-737)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 首次推理或不使用缓存时，处理整个序列</span>
<span class="hljs-keyword">if</span> first_seq <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> use_cache:
    out, first_seq = self(input_ids, past_key_values=past_kvs, use_cache=use_cache, **args), <span class="hljs-literal">False</span>
<span class="hljs-comment"># 后续推理且使用缓存时，只处理最新的token</span>
<span class="hljs-keyword">else</span>:
    out = self(input_ids[:, -<span class="hljs-number">1</span>:], past_key_values=past_kvs, use_cache=use_cache,
               start_pos=input_ids.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, **args)
</code></pre>
<h5 data-id="heading-34">性能影响</h5>



































<table><thead><tr><th>场景</th><th>无KV Cache</th><th>有KV Cache</th></tr></thead><tbody><tr><td><strong>生成速度</strong></td><td>基准 (100%)</td><td><strong>~10倍快</strong></td></tr><tr><td><strong>显存占用</strong></td><td>随长度平方增长</td><td>线性增长</td></tr><tr><td><strong>长序列生成</strong></td><td>不可行</td><td>✅ 可行</td></tr><tr><td><strong>首token延迟</strong></td><td>低</td><td>略高（需要全序列计算）</td></tr><tr><td><strong>后续token延迟</strong></td><td><strong>高</strong></td><td>极低</td></tr></tbody></table>
<h5 data-id="heading-35">原理分析</h5>
<p>无缓存时的计算流程：</p>
<pre><code class="hljs language-perl" lang="perl">生成token <span class="hljs-number">100</span>：
  Q, K, V = self.w<span class="hljs-string">q(seq_0-100)</span>, self.wk(seq_<span class="hljs-number">0</span>-<span class="hljs-number">100</span>), self.wv(seq_<span class="hljs-number">0</span>-<span class="hljs-number">100</span>)
  attn = softmax(Q @ K^T) @ V
  重新计算了seq_<span class="hljs-number">0</span>-<span class="hljs-number">99</span>的K、V（浪费！）

生成token <span class="hljs-number">101</span>：
  Q, K, V = self.w<span class="hljs-string">q(seq_0-101)</span>, self.wk(seq_<span class="hljs-number">0</span>-<span class="hljs-number">101</span>), self.wv(seq_<span class="hljs-number">0</span>-<span class="hljs-number">101</span>)
  attn = softmax(Q @ K^T) @ V
  又重新计算了seq_<span class="hljs-number">0</span>-<span class="hljs-number">100</span>的K、V（二次浪费！）
</code></pre>
<p>有缓存时：</p>
<pre><code class="hljs language-ini" lang="ini">生成token 100：
  Q100, K100, <span class="hljs-attr">V100</span> = self.wq(token_100), self.wk(token_100), self.wv(token_100)
  <span class="hljs-attr">cached_K</span> = [K_0-<span class="hljs-number">99</span>, K100]  ← 保存
  <span class="hljs-attr">cached_V</span> = [V_0-<span class="hljs-number">99</span>, V100]  ← 保存
  <span class="hljs-attr">attn</span> = softmax(Q100 @ cached_K^T) @ cached_V

生成token 101：
  Q101, K101, <span class="hljs-attr">V101</span> = self.wq(token_101), self.wk(token_101), self.wv(token_101)
  <span class="hljs-attr">cached_K</span> = [K_0-<span class="hljs-number">99</span>, K100, K101]  ← 追加（只计算新token）
  <span class="hljs-attr">cached_V</span> = [V_0-<span class="hljs-number">99</span>, V100, V101]  ← 追加
  <span class="hljs-attr">attn</span> = softmax(Q101 @ cached_K^T) @ cached_V
</code></pre>
<h5 data-id="heading-36">选取原因</h5>
<p><strong>自回归生成的必要条件</strong>：</p>
<ul>
<li>不使用KV Cache时，生成100个token需要计算~5000次矩阵乘法</li>
<li>使用KV Cache只需~200次（理论加速50倍）</li>
</ul>
<p><strong>实际场景</strong>：</p>
<ul>
<li>所有LLM推理框架都使用KV Cache</li>
<li>没有KV Cache无法进行实用的文本生成</li>
</ul>
<h5 data-id="heading-37">核心优势</h5>
<pre><code class="hljs">避免重复计算历史token的K、V
↓
生成速度提升 10-50 倍
↓
可进行实时交互式应用
↓
大幅降低推理成本
</code></pre>
<hr/>
<h3 data-id="heading-38">技术总结矩阵</h3>















































<table><thead><tr><th>技术</th><th>改进目标</th><th>相对复杂度</th><th>收益幅度</th><th>现代地位</th></tr></thead><tbody><tr><td><strong>RMSNorm</strong></td><td>计算效率</td><td>⭐ 低</td><td>30-40%</td><td>🔥 标准</td></tr><tr><td><strong>RoPE</strong></td><td>外推能力</td><td>⭐⭐ 中</td><td>10-100倍</td><td>🔥 标准</td></tr><tr><td><strong>GQA</strong></td><td>推理效率</td><td>⭐⭐ 中</td><td>2-4倍</td><td>🔥 标准</td></tr><tr><td><strong>Flash Attention</strong></td><td>计算速度</td><td>⭐⭐⭐ 复杂</td><td>2-4倍</td><td>🔥 推荐</td></tr><tr><td><strong>KV Cache</strong></td><td>生成速度</td><td>⭐ 低</td><td>10-50倍</td><td>🔥 必须</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-39">架构演进对比</h3>
<h4 data-id="heading-40">原始Transformer (Vaswani et al., 2017)</h4>
<pre><code class="hljs language-scss" lang="scss">Embedding + LayerNorm
    ↓
Positional Encoding (绝对位置)
    ↓
Multi-Head Attention (<span class="hljs-number">32</span>头, <span class="hljs-number">32</span>KV)
    ↓
LayerNorm + FFN (<span class="hljs-number">4</span>倍维度)
    ↓
无KV Cache推理
    ↓
外推能力：❌ 极差
推理速度：❌ 极慢
</code></pre>
<h4 data-id="heading-41">GPT-3风格 (Brown et al., 2020)</h4>
<pre><code class="hljs language-scss" lang="scss">Embedding + LayerNorm
    ↓
Positional Encoding (绝对位置)
    ↓
Multi-Head Attention (<span class="hljs-number">96</span>头, <span class="hljs-number">96</span>KV)
    ↓
LayerNorm + FFN (<span class="hljs-number">4</span>倍维度)
    ↓
KV Cache推理
    ↓
外推能力：❌ 无法处理超训练长度
推理速度：中等（有Cache）
</code></pre>
<h4 data-id="heading-42">LLaMA风格 (Meta, 2023) - MiniMind采用</h4>
<pre><code class="hljs language-java" lang="java">Embedding + RMSNorm ⭐
    ↓
RoPE位置编码 ⭐
    ↓
Grouped-Query <span class="hljs-title function_">Attention</span> <span class="hljs-params">(32Q, 8KV)</span> ⭐
    ↓
RMSNorm + SwiGLU FFN
    ↓
Flash Attention + KV Cache ⭐
    ↓
外推能力：✅ 可处理 <span class="hljs-number">10</span>-<span class="hljs-number">100</span>倍长序列
推理速度：✅ 比GPT-<span class="hljs-number">3</span>快 <span class="hljs-number">10</span>-<span class="hljs-number">50</span>倍
显存占用：✅ 减少 <span class="hljs-number">50</span>-<span class="hljs-number">80</span>%
</code></pre>
<hr/>
<h2 data-id="heading-43">MiniMind 前馈网络创新技术详解</h2>
<h3 data-id="heading-44">二、前馈网络差异</h3>
<h4 data-id="heading-45">1. SwiGLU 激活函数</h4>
<h5 data-id="heading-46">代码位置</h5>
<p><code>model/model.py:283-344</code></p>
<h5 data-id="heading-47">实现原理</h5>
<p><strong>类定义和初始化</strong> (model.py:300-324)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: LMConfig</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-comment"># 如果未指定隐藏层维度，则自动计算</span>
        <span class="hljs-keyword">if</span> config.hidden_dim <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            hidden_dim = <span class="hljs-number">4</span> * config.dim  <span class="hljs-comment"># 初始为4倍维度</span>
            hidden_dim = <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span> * hidden_dim / <span class="hljs-number">3</span>)  <span class="hljs-comment"># ← 关键：降到约2.67倍</span>
            <span class="hljs-comment"># 对齐到multiple_of的倍数（通常为256）</span>
            config.hidden_dim = config.multiple_of * ((hidden_dim + config.multiple_of - <span class="hljs-number">1</span>) // config.multiple_of)

        <span class="hljs-comment"># 三个线性投影层</span>
        self.w1 = nn.Linear(config.dim, config.hidden_dim, bias=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 升维</span>
        self.w2 = nn.Linear(config.hidden_dim, config.dim, bias=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 降维</span>
        self.w3 = nn.Linear(config.dim, config.hidden_dim, bias=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 门控</span>
        self.dropout = nn.Dropout(config.dropout)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-string">"""SwiGLU实现：FFN(x) = dropout(W₂ · (SiLU(W₁·x) ⊙ W₃·x))"""</span>
        <span class="hljs-keyword">return</span> self.dropout(self.w2(F.silu(self.w1(x)) * self.w3(x)))
        <span class="hljs-comment">#                                    ↑ 激活函数      ↑ 门控信号</span>
</code></pre>
<h5 data-id="heading-48">数学公式对比</h5>

























<table><thead><tr><th>架构</th><th>公式</th><th>参数数量</th></tr></thead><tbody><tr><td><strong>传统FFN</strong></td><td><code>FFN(x) = W₂ · ReLU(W₁ · x)</code></td><td><code>2D·H</code></td></tr><tr><td><strong>GELU FFN</strong></td><td><code>FFN(x) = W₂ · GELU(W₁ · x)</code></td><td><code>2D·H</code></td></tr><tr><td><strong>SwiGLU</strong></td><td><code>FFN(x) = W₂ · (SiLU(W₁·x) ⊙ W₃·x)</code></td><td><code>3D·H</code></td></tr></tbody></table>
<p>其中：</p>
<ul>
<li><code>D</code> = 模型维度 (通常 768-4096)</li>
<li><code>H</code> = 隐藏维度 (通常 2.67D)</li>
<li><code>⊙</code> = 逐元素乘法（Hadamard积）</li>
<li><code>SiLU(x) = x · sigmoid(x)</code> = Swish激活</li>
</ul>
<h5 data-id="heading-49">SwiGLU的三个关键组件</h5>
<p><strong>1. SiLU激活函数（Swish）</strong></p>
<pre><code class="hljs language-python" lang="python">SiLU(x) = x · sigmoid(x) = x · <span class="hljs-number">1</span>/(<span class="hljs-number">1</span> + e^(-x))
</code></pre>
<p>对比其他激活函数：</p>
<pre><code class="hljs language-scss" lang="scss">ReLU：          <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x)           - 非光滑，梯度为<span class="hljs-number">0</span>或<span class="hljs-number">1</span>
GELU：          x · Φ(x)            - 光滑，类似softmax
Swish/SiLU：    x · <span class="hljs-built_in">sigmoid</span>(x)      - 光滑自门控 ⭐
</code></pre>
<p><strong>2. 门控机制（Gating）</strong></p>
<pre><code class="hljs language-python" lang="python">f(x) = SiLU(W₁·x) ⊙ W₃·x
       ↑ 激活路径    ↑ 门控路径
</code></pre>
<p>门控作用：</p>
<ul>
<li><code>W₃·x</code> 产生的值范围在 [0, 1] 之间（或接近）</li>
<li>通过逐元素乘法来调节信息流</li>
<li>类似于LSTM中的遗忘门</li>
</ul>
<p><strong>3. 参数高效性</strong></p>
<pre><code class="hljs language-r" lang="r">标准FFN：<span class="hljs-built_in">dim</span> → <span class="hljs-number">4</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span>
         参数数：<span class="hljs-number">2</span><span class="hljs-operator">*</span>D<span class="hljs-operator">*</span><span class="hljs-number">4</span>D <span class="hljs-operator">=</span> <span class="hljs-number">8</span>D²

SwiGLU：  <span class="hljs-built_in">dim</span> → <span class="hljs-number">2.67</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span> <span class="hljs-punctuation">(</span>两个分支<span class="hljs-punctuation">)</span>
         参数数：<span class="hljs-punctuation">(</span><span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span>D<span class="hljs-operator">*</span><span class="hljs-number">2.67</span>D ≈ <span class="hljs-number">8</span>D²

↓ 虽然参数相同，但计算量相近，但效果显著更好
</code></pre>
<h5 data-id="heading-50">与其他激活函数的对比</h5>





























































<table><thead><tr><th>特性</th><th>ReLU</th><th>GELU</th><th>Swish/SiLU</th><th>SwiGLU</th></tr></thead><tbody><tr><td><strong>平滑性</strong></td><td>❌ 不平滑</td><td>✅ 平滑</td><td>✅ 平滑</td><td>✅ 平滑</td></tr><tr><td><strong>自门控</strong></td><td>❌ 无</td><td>❌ 无</td><td>✅ 有</td><td>✅ 有</td></tr><tr><td><strong>双路径</strong></td><td>❌ 单路</td><td>❌ 单路</td><td>❌ 单路</td><td>✅ 双路</td></tr><tr><td><strong>梯度流</strong></td><td>差</td><td>好</td><td>优</td><td><strong>优异</strong></td></tr><tr><td><strong>计算成本</strong></td><td>最低</td><td>中等</td><td>中等</td><td>中等</td></tr><tr><td><strong>模型质量</strong></td><td>低</td><td>高</td><td>高</td><td><strong>最高</strong></td></tr><tr><td><strong>现代采用</strong></td><td>过时</td><td>广泛</td><td>常见</td><td><strong>🔥标准</strong></td></tr></tbody></table>
<h5 data-id="heading-51">选取原因</h5>
<p><strong>1. 门控的必要性</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">传统FFN的问题：
<span class="hljs-bullet">  -</span> 激活函数处理所有信息
<span class="hljs-bullet">  -</span> 无法根据上下文调节信息
<span class="hljs-bullet">  -</span> 梯度流受限

SwiGLU的优势：
<span class="hljs-bullet">  -</span> 双路径设计：激活路径 + 门控路径
<span class="hljs-bullet">  -</span> 可动态调节信息流强度
<span class="hljs-bullet">  -</span> 梯度从两条路径流向反向传播
</code></pre>
<p><strong>2. 实验证据（来自原始论文）</strong></p>
<p>使用相同参数量的情况下：</p>

























<table><thead><tr><th>架构</th><th>BLEU评分</th><th>困惑度</th></tr></thead><tbody><tr><td>ReLU FFN</td><td>25.4</td><td>5.20</td></tr><tr><td>GELU FFN</td><td>26.8</td><td>4.95</td></tr><tr><td>SwiGLU</td><td><strong>27.6</strong></td><td><strong>4.71</strong></td></tr></tbody></table>
<p>SwiGLU相比GELU提升 ~3%，相比ReLU提升 ~8%</p>
<p><strong>3. 参数高效性</strong></p>
<pre><code class="hljs language-r" lang="r">关键发现（Shazeer et al.<span class="hljs-punctuation">,</span> <span class="hljs-number">2022</span>）：

使用SwiGLU时，可以减少FFN的隐藏维度，
同时保持相同甚至更好的性能

原始：<span class="hljs-built_in">dim</span> → <span class="hljs-number">4</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span>
现在：<span class="hljs-built_in">dim</span> → <span class="hljs-number">2.67</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span> ⭐

效果：参数减少 <span class="hljs-number">33</span>%，性能持平或更优
</code></pre>
<p><strong>4. 现代LLM标准</strong></p>
<pre><code class="hljs">LLaMA / LLaMA-2：SwiGLU
PaLM / Gemini：SwiGLU
Falcon：SwiGLU
MistralAI：SwiGLU
</code></pre>
<h5 data-id="heading-52">激活函数演进线</h5>
<pre><code class="hljs language-scss" lang="scss">时代 <span class="hljs-number">1</span> (<span class="hljs-number">2012</span>-<span class="hljs-number">2017</span>)：ReLU 主宰
  <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x)
  ↓ <span class="hljs-selector-attr">[梯度消失问题]</span>

时代 <span class="hljs-number">2</span> (<span class="hljs-number">2017</span>-<span class="hljs-number">2020</span>)：GELU 兴起
  x·Φ(x)  <span class="hljs-selector-attr">[更平滑的梯度]</span>
  ↓ <span class="hljs-selector-attr">[缺少自适应门控]</span>

时代 <span class="hljs-number">3</span> (<span class="hljs-number">2020</span>-<span class="hljs-number">2022</span>)：Swish 实验阶段
  x·<span class="hljs-built_in">sigmoid</span>(x)  <span class="hljs-selector-attr">[自门控]</span>
  ↓ <span class="hljs-selector-attr">[门控不够结构化]</span>

时代 <span class="hljs-number">4</span> (<span class="hljs-number">2022</span>+)：SwiGLU 标准化 ⭐
  W₂(SiLU(W₁x) ⊙ W₃x)  <span class="hljs-selector-attr">[最优的表达力+效率]</span>
  ↓

未来可能：MLP-Mixer, GLU Variants
</code></pre>
<h5 data-id="heading-53">核心优势总结</h5>
<pre><code class="hljs language-markdown" lang="markdown">双路径设计
<span class="hljs-code">    ↓
更好的梯度流
    ↓
更强的表达能力
    ↓
可减少参数同时保持性能
    ↓
成为现代LLM标准激活函数
</span></code></pre>
<hr/>
<h4 data-id="heading-54">2. MoE（Mixture of Experts）混合专家模型</h4>
<h5 data-id="heading-55">代码位置</h5>
<p><code>model/model.py:347-459</code></p>
<h5 data-id="heading-56">实现原理</h5>
<p><strong>MoE门控网络</strong> (model.py:347-401)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoEGate</span>(nn.Module):
    <span class="hljs-string">"""门控网络：决定每个token由哪些专家处理"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: LMConfig</span>):
        <span class="hljs-built_in">super</span>().__init__()
        self.top_k = config.num_experts_per_tok  <span class="hljs-comment"># 每个token选择的专家数</span>
        self.n_routed_experts = config.n_routed_experts  <span class="hljs-comment"># 路由专家总数</span>
        self.scoring_func = config.scoring_func  <span class="hljs-comment"># 评分函数（softmax）</span>
        self.alpha = config.aux_loss_alpha  <span class="hljs-comment"># 辅助损失权重</span>
        self.weight = nn.Parameter(torch.empty((self.n_routed_experts, self.gating_dim)))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states</span>):
        <span class="hljs-comment"># 计算每个专家的得分</span>
        logits = F.linear(hidden_states, self.weight, <span class="hljs-literal">None</span>)
        scores = logits.softmax(dim=-<span class="hljs-number">1</span>)  <span class="hljs-comment"># 转换为概率</span>

        <span class="hljs-comment"># 选择top-k个专家</span>
        topk_weight, topk_idx = torch.topk(scores, k=self.top_k, dim=-<span class="hljs-number">1</span>, <span class="hljs-built_in">sorted</span>=<span class="hljs-literal">False</span>)

        <span class="hljs-comment"># 归一化top-k权重</span>
        <span class="hljs-keyword">if</span> self.top_k &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.norm_topk_prob:
            denominator = topk_weight.<span class="hljs-built_in">sum</span>(dim=-<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>) + <span class="hljs-number">1e-20</span>
            topk_weight = topk_weight / denominator

        <span class="hljs-comment"># 计算辅助损失（平衡专家负载）</span>
        aux_loss = self._compute_aux_loss(...)

        <span class="hljs-keyword">return</span> topk_idx, topk_weight, aux_loss
</code></pre>
<p><strong>MoE前馈网络</strong> (model.py:404-436)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MOEFeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: LMConfig</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-comment"># 创建多个专家（每个都是一个独立的FFN）</span>
        self.experts = nn.ModuleList([
            FeedForward(config)
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(config.n_routed_experts)
        ])
        self.gate = MoEGate(config)  <span class="hljs-comment"># 门控网络</span>

        <span class="hljs-comment"># 可选的共享专家（所有token都经过）</span>
        <span class="hljs-keyword">if</span> config.n_shared_experts <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.shared_experts = FeedForward(config)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        identity = x
        <span class="hljs-comment"># 1. 使用门控网络选择专家</span>
        topk_idx, topk_weight, aux_loss = self.gate(x)

        <span class="hljs-comment"># 2. 分发token给选中的专家</span>
        <span class="hljs-keyword">if</span> self.training:
            <span class="hljs-comment"># 训练时：循环分发（更简单的实现）</span>
            y = torch.empty_like(x, dtype=torch.float16)
            <span class="hljs-keyword">for</span> i, expert <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.experts):
                y[flat_topk_idx == i] = expert(x[flat_topk_idx == i])
            y = (y.view(*topk_weight.shape, -<span class="hljs-number">1</span>) * topk_weight.unsqueeze(-<span class="hljs-number">1</span>)).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># 推理时：优化的推理流程</span>
            y = self.moe_infer(x, flat_topk_idx, topk_weight.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))

        <span class="hljs-comment"># 3. 可选：添加共享专家的输出</span>
        <span class="hljs-keyword">if</span> self.config.n_shared_experts <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            y = y + self.shared_experts(identity)

        <span class="hljs-comment"># 保存辅助损失用于反向传播</span>
        self.aux_loss = aux_loss
        <span class="hljs-keyword">return</span> y
</code></pre>
<p><strong>高效推理</strong> (model.py:438-459)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@torch.no_grad()</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">moe_infer</span>(<span class="hljs-params">self, x, flat_expert_indices, flat_expert_weights</span>):
    <span class="hljs-string">"""推理时的高效MoE计算"""</span>
    expert_cache = torch.zeros_like(x)

    <span class="hljs-comment"># 按专家索引排序token</span>
    idxs = flat_expert_indices.argsort()

    <span class="hljs-comment"># 计算每个专家处理的token数</span>
    tokens_per_expert = flat_expert_indices.bincount().cpu().numpy().cumsum(<span class="hljs-number">0</span>)
    token_idxs = idxs // self.config.num_experts_per_tok

    <span class="hljs-comment"># 为每个专家处理对应的tokens</span>
    <span class="hljs-keyword">for</span> i, end_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tokens_per_expert):
        start_idx = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> tokens_per_expert[i - <span class="hljs-number">1</span>]
        <span class="hljs-keyword">if</span> start_idx == end_idx:
            <span class="hljs-keyword">continue</span>
        expert = self.experts[i]
        exp_token_idx = token_idxs[start_idx:end_idx]
        expert_tokens = x[exp_token_idx]
        expert_out = expert(expert_tokens)
        expert_out.mul_(flat_expert_weights[idxs[start_idx:end_idx]])
        expert_cache.scatter_add_(<span class="hljs-number">0</span>, exp_token_idx.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).repeat(<span class="hljs-number">1</span>, x.shape[-<span class="hljs-number">1</span>]), expert_out)

    <span class="hljs-keyword">return</span> expert_cache
</code></pre>
<h5 data-id="heading-57">MoE工作流程详解</h5>
<p><strong>步骤 1：门控路由</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">token</span> <span class="hljs-string">sequence</span> [<span class="hljs-string">seq_len</span>, <span class="hljs-string">dim</span>]
            <span class="hljs-string">↓</span>
<span class="hljs-attr">Gate Network:</span> <span class="hljs-string">计算每个token</span> <span class="hljs-string">→</span> <span class="hljs-string">每个专家的概率</span>
            <span class="hljs-string">↓</span>
<span class="hljs-attr">Top-k Selection:</span> <span class="hljs-string">为每个token选择top-k个专家</span>
            <span class="hljs-string">↓</span>
<span class="hljs-attr">Output:</span> <span class="hljs-string">(token_to_expert_mapping,</span> <span class="hljs-string">expert_weights)</span>
</code></pre>
<p><strong>步骤 2：专家分发</strong></p>
<pre><code class="hljs language-python" lang="python">输入：Token序列 [B, S, D]
         ↓
Gate: [B*S, num_experts] → 每个token的专家权重
         ↓
TopK: 为每个token选择 top_k=<span class="hljs-number">2</span> 个专家
         ↓
分发：
  Token <span class="hljs-number">0</span> → Expert <span class="hljs-number">3</span>, Expert <span class="hljs-number">7</span>  (权重: <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>)
  Token <span class="hljs-number">1</span> → Expert <span class="hljs-number">1</span>, Expert <span class="hljs-number">5</span>  (权重: <span class="hljs-number">0.7</span>, <span class="hljs-number">0.3</span>)
  Token <span class="hljs-number">2</span> → Expert <span class="hljs-number">7</span>, Expert <span class="hljs-number">9</span>  (权重: <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)
         ↓
汇聚：对每个token的多个专家输出加权求和
</code></pre>
<p><strong>步骤 3：输出合并</strong></p>
<pre><code class="hljs language-ini" lang="ini">Expert 1 output: <span class="hljs-section">[0.7 * token_1_output, ...]</span>
Expert 3 output: <span class="hljs-section">[0.6 * token_0_output, ...]</span>
Expert 5 output: <span class="hljs-section">[0.3 * token_1_output, ...]</span>
Expert 7 output: <span class="hljs-section">[0.4 * token_0_output, 0.5 * token_2_output, ...]</span>
Expert 9 output: <span class="hljs-section">[0.5 * token_2_output, ...]</span>
         ↓ <span class="hljs-section">[合并到原始位置]</span>
Final output: <span class="hljs-section">[token_0_out, token_1_out, token_2_out, ...]</span>
</code></pre>
<h5 data-id="heading-58">MoE vs 标准FFN</h5>













































<table><thead><tr><th>特性</th><th>标准FFN</th><th>MoE</th></tr></thead><tbody><tr><td><strong>参数数量</strong></td><td>基准 (8D²)</td><td><strong>稍高</strong> (~10D²)</td></tr><tr><td><strong>计算量</strong></td><td>所有token都经过所有神经元</td><td><strong>只经过top-k专家</strong></td></tr><tr><td><strong>激活参数</strong></td><td>基准</td><td><strong>减少 80-90%</strong></td></tr><tr><td><strong>模型容量</strong></td><td>固定</td><td><strong>动态可扩展</strong></td></tr><tr><td><strong>泛化能力</strong></td><td>基准</td><td><strong>更强</strong></td></tr><tr><td><strong>训练稳定性</strong></td><td>良好</td><td>需要负载均衡</td></tr><tr><td><strong>推理速度</strong></td><td>基准</td><td><strong>取决于top-k</strong></td></tr></tbody></table>
<h5 data-id="heading-59">详细对比分析</h5>
<p><strong>计算量对比（以Transformer块为例）</strong></p>
<p>标准FFN：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[B, S, D]</span> → <span class="hljs-selector-attr">[B, S, 4D]</span> → <span class="hljs-selector-attr">[B, S, D]</span>

总计算量 = <span class="hljs-selector-tag">B</span>*S*D * <span class="hljs-number">4</span>D + <span class="hljs-selector-tag">B</span>*S*<span class="hljs-number">4</span>D * D = <span class="hljs-number">8</span>*<span class="hljs-selector-tag">B</span>*S*D²
（每个token都经过全部计算）
</code></pre>
<p>MoE (num_experts=8, top_k=2)：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[B, S, D]</span> → Gate → 选择<span class="hljs-attribute">top</span>-<span class="hljs-number">2</span>专家 (共<span class="hljs-number">8</span>个专家)

每个专家大小 = D → D/<span class="hljs-number">2</span> → D  (为了保持总参数量)

单个token的计算 = D * (D/<span class="hljs-number">2</span>) * <span class="hljs-number">2</span> = <span class="hljs-selector-tag">B</span>*S*D²
                  (只处理<span class="hljs-number">2</span>个专家)

总计算量 ≈ <span class="hljs-number">2</span>*<span class="hljs-selector-tag">B</span>*S*D²
（相比标准FFN减少 <span class="hljs-number">75%</span>！）
</code></pre>
<p><strong>实际性能数据</strong> (来自GLaM论文)</p>





























<table><thead><tr><th>配置</th><th>参数</th><th>计算</th><th>困惑度</th></tr></thead><tbody><tr><td>标准 175B</td><td>175B</td><td>基准</td><td>10.5</td></tr><tr><td>MoE 64E 2K</td><td>175B</td><td>基准</td><td><strong>9.8</strong></td></tr><tr><td>MoE 1024E 2K</td><td>175B</td><td>基准</td><td><strong>9.2</strong></td></tr></tbody></table>
<p><strong>关键发现</strong>：</p>
<ul>
<li>相同参数量，MoE显著超过标准模型</li>
<li>可以用更少计算达到相同精度</li>
<li>或用相同计算达到更高精度</li>
</ul>
<h5 data-id="heading-60">MoE的四大挑战与解决方案</h5>
<p><strong>挑战 1：负载不均衡</strong></p>
<pre><code class="hljs language-ini" lang="ini">问题：某些专家被频繁选中，某些很少被选中
      ↓ 浪费了参数和计算资源

解决方案：Auxiliary Loss（辅助损失）
  <span class="hljs-attr">aux_loss</span> = alpha * (专家使用概率 * 专家容量)
  ↓ 鼓励均匀分布
</code></pre>
<p><strong>挑战 2：路由碰撞</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">问题：某些token想去的专家都满了（容量限制）
<span class="hljs-code">      ↓ 需要丢弃或降级处理
</span>
解决方案：
<span class="hljs-bullet">  1.</span> Expert Capacity：为每个专家设定容量阈值
<span class="hljs-bullet">  2.</span> Drop Tokens：超过容量的token丢弃
<span class="hljs-bullet">  3.</span> Shared Experts：所有token都经过的后备专家
</code></pre>
<p><strong>挑战 3：训练不稳定</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">问题：Gate网络突然改变路由决策
<span class="hljs-code">      ↓ 梯度不稳定
</span>
解决方案：
<span class="hljs-bullet">  1.</span> Sticky Gate：添加随机噪声平滑路由
<span class="hljs-bullet">  2.</span> Temperature Annealing：逐步降低温度
<span class="hljs-bullet">  3.</span> Load Balancing：强制均衡专家负载
</code></pre>
<p><strong>挑战 4：推理延迟</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">问题：不规则的内存访问模式
<span class="hljs-code">      ↓ GPU利用率低
</span>
解决方案：Token Reordering（代码中的moe<span class="hljs-emphasis">_infer）
  1. 按专家排序token
  2. 连续处理相同专家的token
  3. 提高GPU缓存命中率
</span></code></pre>
<h5 data-id="heading-61">选取原因</h5>
<p><strong>1. 稀疏性的力量</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">在极大规模模型中：
<span class="hljs-bullet">  -</span> 标准模型每个token都要经过每个参数 → 计算量巨大
<span class="hljs-bullet">  -</span> MoE让每个token只经过部分参数 → 大幅减少计算

例子：Google GLaM
<span class="hljs-bullet">  -</span> 1.2 万亿参数的MoE模型
<span class="hljs-bullet">  -</span> 计算量仅相当于100B标准模型
</code></pre>
<p><strong>2. 模型缩放的新方向</strong></p>
<pre><code class="hljs language-erlang" lang="erlang">参数缩放：基本饱和（<span class="hljs-number">10</span>B→<span class="hljs-number">100</span>B效果递减）

计算缩放：有效但不够快（计算<span class="hljs-number">4</span>倍→性能仅提升~<span class="hljs-number">40</span><span class="hljs-comment">%）</span>

稀疏缩放（MoE）：极有效（计算<span class="hljs-number">4</span>倍→性能提升~<span class="hljs-number">60</span><span class="hljs-comment">%）⭐</span>
             可以用更少计算得到更强模型
</code></pre>
<p><strong>3. 工业级应用的可行性</strong></p>
<pre><code class="hljs language-r" lang="r">有了MoE，才能在实际中训练<span class="hljs-operator">/</span>运行最强大的模型

Switch Transformer：<span class="hljs-number">1.6</span><span class="hljs-built_in">T</span>参数，但激活参数仅相当于<span class="hljs-number">30</span>B
Google<span class="hljs-string">'s Gemini MoE：参数巨大，但高效可用
</span></code></pre>
<h5 data-id="heading-62">共享专家（Shared Experts）设计</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> config.n_shared_experts <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    y = y + self.shared_experts(identity)
</code></pre>
<p>为什么需要共享专家？</p>






























<table><thead><tr><th>特性</th><th>纯MoE</th><th>共享+MoE</th></tr></thead><tbody><tr><td><strong>容量</strong></td><td>所有专家都路由</td><td>共享专家始终活跃</td></tr><tr><td><strong>稳定性</strong></td><td>需要强制均衡</td><td>自然更均衡</td></tr><tr><td><strong>泛化</strong></td><td>可能过专化</td><td>更一般化</td></tr><tr><td><strong>计算</strong></td><td>最少</td><td>略高</td></tr></tbody></table>
<pre><code class="hljs language-markdown" lang="markdown">共享专家的作用：
<span class="hljs-bullet">  -</span> 所有token都经过共享专家 → 提供基础特征
<span class="hljs-bullet">  -</span> 路由专家基于token的特殊性 → 提供特化特征
<span class="hljs-bullet">  -</span> 合并：y = y<span class="hljs-emphasis">_routed + y_</span>shared ⭐

类比：
  共享专家 ≈ 通用骨架
  路由专家 ≈ 特化模块
</code></pre>
<h5 data-id="heading-63">核心优势总结</h5>
<pre><code class="hljs language-markdown" lang="markdown">模型参数巨大但计算精简
<span class="hljs-code">    ↓
稀疏激活的力量
    ↓
用更少计算达到更强性能
    ↓
可以训练超大规模模型
    ↓
适合实际工业应用
</span></code></pre>
<hr/>
<h3 data-id="heading-64">前馈网络架构演进</h3>
<pre><code class="hljs language-scss" lang="scss">时代 <span class="hljs-number">1</span> (<span class="hljs-number">2017</span>)：标准FFN
  dim → <span class="hljs-number">4</span>*dim → dim
  激活：ReLU
  参数：<span class="hljs-number">8</span>D²

         ↓ <span class="hljs-selector-attr">[质量瓶颈]</span>

时代 <span class="hljs-number">2</span> (<span class="hljs-number">2018</span>-<span class="hljs-number">2020</span>)：GELU激活函数
  dim → <span class="hljs-number">4</span>*dim → dim
  激活：GELU
  参数：<span class="hljs-number">8</span>D²
  质量提升：~<span class="hljs-number">15%</span>

         ↓ <span class="hljs-selector-attr">[容量瓶颈]</span>

时代 <span class="hljs-number">3</span> (<span class="hljs-number">2020</span>-<span class="hljs-number">2022</span>)：门控和SwiGLU
  dim → <span class="hljs-number">2.67</span>*dim → dim (两分支)
  激活：SiLU + 门控
  参数：<span class="hljs-number">8</span>D²（但效果更好）
  质量提升：+<span class="hljs-number">3%</span> vs GELU

         ↓ <span class="hljs-selector-attr">[缩放瓶颈]</span>

时代 <span class="hljs-number">4</span> (<span class="hljs-number">2022</span>+)：MoE混合专家 ⭐
  dim → 多个专家 → dim
  激活：SwiGLU + 稀疏路由
  参数：<span class="hljs-number">10</span>D² (但激活仅<span class="hljs-number">2</span>/<span class="hljs-number">8</span>)
  质量提升：+<span class="hljs-number">60%</span> vs 标准FFN（相同计算）
  可扩展：到数万亿参数
</code></pre>
<hr/>
<h3 data-id="heading-65">与标准FFN的完整对比</h3>
<h4 data-id="heading-66">标准FFN (原始Transformer)</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 简单线性变换</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardFFN</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):
        self.w1 = nn.Linear(dim, <span class="hljs-number">4</span>*dim)
        self.w2 = nn.Linear(<span class="hljs-number">4</span>*dim, dim)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">return</span> self.w2(F.relu(self.w1(x)))

效果：基准
计算：基准
参数：8D²
</code></pre>
<h4 data-id="heading-67">SwiGLU FFN (MiniMind采用)</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 门控双路径设计</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):
        self.w1 = nn.Linear(dim, hidden_dim)
        self.w2 = nn.Linear(hidden_dim, dim)
        self.w3 = nn.Linear(dim, hidden_dim)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">return</span> self.w2(F.silu(self.w1(x)) * self.w3(x))

效果：+<span class="hljs-number">3</span>% vs GELU
计算：中等
参数：8D²（但更高效）
</code></pre>
<h4 data-id="heading-68">MoE FFN (可选)</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 稀疏专家路由</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MOEFeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):
        self.experts = [FeedForward(config) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_experts)]
        self.gate = MoEGate(config)
        self.shared_experts = FeedForward(config)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        idx, weight, aux_loss = self.gate(x)  <span class="hljs-comment"># 路由</span>
        y = self._route(x, idx, weight)       <span class="hljs-comment"># 分发</span>
        y = y + self.shared_experts(x)        <span class="hljs-comment"># 共享</span>
        <span class="hljs-keyword">return</span> y

效果：+<span class="hljs-number">60</span>% vs 标准FFN（相同计算）
计算：减少 <span class="hljs-number">75</span>%（激活参数）
参数：10D²（但仅<span class="hljs-number">2</span>/<span class="hljs-number">8</span>活跃）
可扩展：最好
</code></pre>
<hr/>
<h3 data-id="heading-69">对标原始GPT论文的改进</h3>
<p>原始GPT论文中的FFN：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-string">"We employed a position-wise feed-forward network
which consists of two linear transformations with a
ReLU activation in between."</span>

<span class="hljs-keyword">dim</span> → <span class="hljs-number">4</span>*<span class="hljs-keyword">dim</span> → <span class="hljs-keyword">dim</span> <span class="hljs-keyword">with</span> ReLU
</code></pre>
<p>MiniMind的改进：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 激活函数升级：ReLU → GELU → SwiGLU
   质量提升：+30% (相同参数)

<span class="hljs-bullet">2.</span> 智能门控：添加第三个投影 (W3)
   参数相同，表达力大幅提升

<span class="hljs-bullet">3.</span> 可选稀疏化：标准FFN → MoE
   计算减少：75%（推理）
   性能：+60%（相同计算）
</code></pre>
<hr/>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> <strong>优化技术</strong> (参数共享, 生成采样策略)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> <strong>完整总结</strong> (所有技术综合评分)</li>
</ul>
<h2 data-id="heading-70">MiniMind 优化技术详解</h2>
<h3 data-id="heading-71">三、优化技术</h3>
<h4 data-id="heading-72">1. 参数共享（Weight Tying）</h4>
<h5 data-id="heading-73">代码位置</h5>
<p><code>model/model.py:562-578</code></p>
<h5 data-id="heading-74">实现原理</h5>
<p><strong>初始化阶段</strong> (model.py:562-578)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiniMindLM</span>(<span class="hljs-title class_ inherited__">PreTrainedModel</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, params: LMConfig = <span class="hljs-literal">None</span></span>):
        <span class="hljs-comment"># ... 其他初始化代码 ...</span>

        <span class="hljs-comment"># 词元嵌入层：将token ID映射为向量表示</span>
        self.tok_embeddings = nn.Embedding(params.vocab_size, params.dim)

        <span class="hljs-comment"># 输出层：将隐藏状态映射为词汇表大小的logits</span>
        self.output = nn.Linear(params.dim, params.vocab_size, bias=<span class="hljs-literal">False</span>)

        <span class="hljs-comment"># ⭐ 关键：参数共享</span>
        <span class="hljs-comment"># 让输出层的权重与嵌入层权重指向同一个参数张量</span>
        self.tok_embeddings.weight = self.output.weight
</code></pre>
<h5 data-id="heading-75">数学原理</h5>
<pre><code class="hljs language-r" lang="r">标准方式：
  嵌入矩阵：W_emb <span class="hljs-punctuation">[</span>vocab_size<span class="hljs-punctuation">,</span> <span class="hljs-built_in">dim</span><span class="hljs-punctuation">]</span>
  输出矩阵：W_out <span class="hljs-punctuation">[</span><span class="hljs-built_in">dim</span><span class="hljs-punctuation">,</span> vocab_size<span class="hljs-punctuation">]</span>
  总参数：vocab_size <span class="hljs-operator">*</span> <span class="hljs-built_in">dim</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span>

参数共享：
  共享矩阵：W <span class="hljs-punctuation">[</span>vocab_size<span class="hljs-punctuation">,</span> <span class="hljs-built_in">dim</span><span class="hljs-punctuation">]</span>
  嵌入：token_id → W<span class="hljs-punctuation">[</span>token_id<span class="hljs-punctuation">,</span> <span class="hljs-operator">:</span><span class="hljs-punctuation">]</span> ∈ ℝ<span class="hljs-operator">^</span><span class="hljs-built_in">dim</span>
  输出：h ∈ ℝ<span class="hljs-operator">^</span><span class="hljs-built_in">dim</span> → h <span class="hljs-operator">@</span> W<span class="hljs-operator">^</span><span class="hljs-built_in">T</span> ∈ ℝ<span class="hljs-operator">^</span>vocab_size
  总参数：vocab_size <span class="hljs-operator">*</span> <span class="hljs-built_in">dim</span>（减少<span class="hljs-number">50</span>%！）
</code></pre>
<h5 data-id="heading-76">前向计算对比</h5>
<p><strong>标准方式</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 嵌入阶段</span>
h = embedding_matrix[input_ids]  <span class="hljs-comment"># [B, S, dim]</span>

<span class="hljs-comment"># 输出阶段</span>
logits = h @ output_matrix       <span class="hljs-comment"># [B, S, vocab_size]</span>
</code></pre>
<p><strong>参数共享</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 嵌入和输出共用同一个矩阵W [vocab_size, dim]</span>

<span class="hljs-comment"># 嵌入阶段</span>
h = W[input_ids, :]              <span class="hljs-comment"># [B, S, dim]</span>

<span class="hljs-comment"># 输出阶段（W是嵌入层权重的引用）</span>
logits = h @ W.T                 <span class="hljs-comment"># [B, S, vocab_size]</span>
</code></pre>
<h5 data-id="heading-77">影响分析</h5>








































<table><thead><tr><th>方面</th><th>标准方式</th><th>参数共享</th></tr></thead><tbody><tr><td><strong>参数数量</strong></td><td>vocab_size × dim × 2</td><td>vocab_size × dim ⭐</td></tr><tr><td><strong>参数减少</strong></td><td>基准</td><td><strong>50%</strong></td></tr><tr><td><strong>显存占用</strong></td><td>基准</td><td><strong>减少 50%</strong></td></tr><tr><td><strong>计算量</strong></td><td>基准</td><td>相同</td></tr><tr><td><strong>精度</strong></td><td>基准</td><td>相同</td></tr><tr><td><strong>训练稳定性</strong></td><td>基准</td><td>稍差（但可接受）</td></tr></tbody></table>
<h5 data-id="heading-78">参数量估算示例</h5>
<p>以Llama-7B为例：</p>
<pre><code class="hljs language-ini" lang="ini">Vocabulary size: 32,000
Hidden dimension: 4,096

标准方式：
  嵌入参数：32,000 × 4,<span class="hljs-attr">096</span> = <span class="hljs-number">131.1</span>M
  输出参数：4,096 × 32,<span class="hljs-attr">000</span> = <span class="hljs-number">131.1</span>M
  总计：262.2M 参数（占模型约3.8%）

参数共享：
  共享参数：32,000 × 4,<span class="hljs-attr">096</span> = <span class="hljs-number">131.1</span>M
  总计：131.1M 参数（减少 50%）

节省显存：
  32-bit: 262.2M × <span class="hljs-attr">4B</span> = <span class="hljs-number">1.05</span>GB
  半精度: 262.2M × <span class="hljs-attr">2B</span> = <span class="hljs-number">0.52</span>GB
</code></pre>
<h5 data-id="heading-79">选取原因</h5>
<p><strong>1. 嵌入和输出的对称性</strong></p>
<pre><code class="hljs">语言模型的本质是：token编码 → 中间表示 → token解码

嵌入层：token_id → 向量
输出层：向量 → token_id

这两个操作在数学上应该互为转置关系！
</code></pre>
<p><strong>语言模型假设</strong>：</p>
<pre><code class="hljs language-css" lang="css">一个token的嵌入向量应该与输出时的得分向量相近

即：
  token <span class="hljs-selector-tag">i</span> 的嵌入向量 ≈ 模型预测token <span class="hljs-selector-tag">i</span>时的权重向量

如果使用同一个矩阵，这个关系会更强！
</code></pre>
<p><strong>2. 参数高效性</strong></p>
<pre><code class="hljs language-erlang" lang="erlang">模型的显存瓶颈：
  总参数数 = n_layers × (注意力参数 + FFN参数) + 嵌入+输出

对于大词汇表模型（如中文，词汇表&gt;<span class="hljs-number">50</span>K）：
  嵌入+输出可占总参数的 <span class="hljs-number">3</span>-<span class="hljs-number">10</span><span class="hljs-comment">%</span>
  参数共享可节省 <span class="hljs-number">1.5</span>-<span class="hljs-number">5</span><span class="hljs-comment">% 的总参数量</span>
</code></pre>
<p><strong>3. 现代LLM标准</strong></p>
<pre><code class="hljs">BERT：✅ 使用参数共享
GPT：✅ 使用参数共享
ALBERT：✅ 设计的核心特性
LLaMA：✅ 使用参数共享
T5：✅ 使用参数共享
</code></pre>
<h5 data-id="heading-80">潜在的缺点与应对</h5>
<p><strong>缺点 1：嵌入和输出学习目标不同</strong></p>
<pre><code class="hljs">嵌入需要编码：token的语义、语法信息
输出需要判别：不同token的区别

强制使用同一个矩阵可能引入冲突
</code></pre>
<p>应对：<strong>隐层变换</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 使用一个额外的线性层解耦</span>
self.output = nn.Linear(params.dim, params.vocab_size, bias=<span class="hljs-literal">False</span>)
<span class="hljs-comment"># 但不再使用共享权重</span>
<span class="hljs-comment"># 而是使用投影层进行变换</span>
</code></pre>
<p><strong>缺点 2：词汇表增长时问题</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">如果需要扩展词汇表（如添加新语言token）：
<span class="hljs-bullet">  -</span> 嵌入矩阵需要扩展：[vocab<span class="hljs-emphasis">_size_</span>old, dim] → [vocab<span class="hljs-emphasis">_size_</span>new, dim]
<span class="hljs-bullet">  -</span> 输出矩阵也需要扩展
<span class="hljs-bullet">  -</span> 如果参数共享，嵌入和输出同时扩展（没问题）
</code></pre>
<h5 data-id="heading-81">代码实现要点</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 正确的参数共享方式</span>
self.tok_embeddings = nn.Embedding(params.vocab_size, params.dim)
self.output = nn.Linear(params.dim, params.vocab_size, bias=<span class="hljs-literal">False</span>)

<span class="hljs-comment"># 关键：使嵌入层权重和输出层权重指向同一个参数</span>
self.tok_embeddings.weight = self.output.weight

<span class="hljs-comment"># 为什么这样做有效？</span>
<span class="hljs-comment"># 1. 嵌入：token_id → self.tok_embeddings.weight[token_id]</span>
<span class="hljs-comment"># 2. 输出：hidden → hidden @ self.output.weight.T</span>
<span class="hljs-comment">#        = hidden @ self.tok_embeddings.weight.T</span>
</code></pre>
<h5 data-id="heading-82">核心优势</h5>
<pre><code class="hljs language-erlang" lang="erlang">参数减少 <span class="hljs-number">50</span><span class="hljs-comment">%（嵌入+输出）</span>
    ↓
显存节省 <span class="hljs-number">1</span>-<span class="hljs-number">3</span><span class="hljs-comment">%（总模型）</span>
    ↓
训练速度稍快
    ↓
对齐嵌入和输出的学习目标
    ↓
成本收益比极高
</code></pre>
<hr/>
<h4 data-id="heading-83">2. 生成采样策略</h4>
<h5 data-id="heading-84">代码位置</h5>
<p><code>model/model.py:710-773</code></p>
<h5 data-id="heading-85">实现原理</h5>
<p><strong>流式生成的完整流程</strong> (model.py:710-773)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_stream</span>(<span class="hljs-params">self, input_ids, eos_token_id, max_new_tokens,
            temperature, top_p, rp, use_cache, **args</span>):
    <span class="hljs-string">"""
    逐token生成的流式采样函数
    """</span>
    start, first_seq, past_kvs = input_ids.shape[<span class="hljs-number">1</span>], <span class="hljs-literal">True</span>, <span class="hljs-literal">None</span>

    <span class="hljs-keyword">while</span> input_ids.shape[<span class="hljs-number">1</span>] &lt; max_new_tokens - <span class="hljs-number">1</span>:
        <span class="hljs-comment"># 推理：获取logits</span>
        <span class="hljs-keyword">if</span> first_seq <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> use_cache:
            out = self(input_ids, past_key_values=past_kvs, use_cache=use_cache)
        <span class="hljs-keyword">else</span>:
            out = self(input_ids[:, -<span class="hljs-number">1</span>:], past_key_values=past_kvs,
                      use_cache=use_cache, start_pos=input_ids.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)

        logits, past_kvs = out.logits[:, -<span class="hljs-number">1</span>, :], out.past_key_values

        <span class="hljs-comment"># ⭐ 策略 1：重复惩罚（Repetition Penalty）</span>
        logits[:, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(input_ids.tolist()[<span class="hljs-number">0</span>]))] /= rp

        <span class="hljs-comment"># ⭐ 策略 2：温度缩放（Temperature Scaling）</span>
        logits /= (temperature + <span class="hljs-number">1e-9</span>)

        <span class="hljs-comment"># ⭐ 策略 3：核采样（Top-p/Nucleus Sampling）</span>
        <span class="hljs-keyword">if</span> top_p <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> top_p &lt; <span class="hljs-number">1.0</span>:
            sorted_logits, sorted_indices = torch.sort(logits, descending=<span class="hljs-literal">True</span>, dim=-<span class="hljs-number">1</span>)
            sorted_probs = F.softmax(sorted_logits, dim=-<span class="hljs-number">1</span>)
            cumulative_probs = torch.cumsum(sorted_probs, dim=-<span class="hljs-number">1</span>)

            <span class="hljs-comment"># 找出超过threshold的位置</span>
            sorted_indices_to_remove = cumulative_probs &gt; top_p
            sorted_indices_to_remove[:, <span class="hljs-number">1</span>:] = sorted_indices_to_remove[:, :-<span class="hljs-number">1</span>].clone()
            sorted_indices_to_remove[:, <span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>

            indices_to_remove = sorted_indices_to_remove.scatter(<span class="hljs-number">1</span>, sorted_indices,
                                                                  sorted_indices_to_remove)
            logits[indices_to_remove] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">'Inf'</span>)

        <span class="hljs-comment"># ⭐ 策略 4：多项式采样（Multinomial Sampling）</span>
        input_ids_next = torch.multinomial(F.softmax(logits, dim=-<span class="hljs-number">1</span>), num_samples=<span class="hljs-number">1</span>)
        input_ids = torch.cat((input_ids, input_ids_next), dim=<span class="hljs-number">1</span>)

        <span class="hljs-keyword">yield</span> input_ids[:, start:]

        <span class="hljs-keyword">if</span> input_ids_next.item() == eos_token_id:
            <span class="hljs-keyword">break</span>
</code></pre>
<h5 data-id="heading-86">四大采样策略详解</h5>
<p><strong>策略 1：重复惩罚（Repetition Penalty）</strong> [model.py:742]</p>
<pre><code class="hljs language-python" lang="python">logits[:, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(input_ids.tolist()[<span class="hljs-number">0</span>]))] /= rp
</code></pre>
<p><strong>目的</strong>：避免生成重复文本</p>
<p><strong>工作原理</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">已生成的token：<span class="hljs-section">[我, 是, 一, 个, AI]</span>

重复惩罚（<span class="hljs-attr">rp</span> = <span class="hljs-number">1.2</span>）：
  对已经出现过的token，降低其logit值
  logit<span class="hljs-section">[我]</span> = logit<span class="hljs-section">[我]</span> / 1.2
  logit<span class="hljs-section">[是]</span> = logit<span class="hljs-section">[是]</span> / 1.2
  ...

效果：
  这些token被选中的概率下降
  → 新的token被选中的概率上升
  → 避免"我我我"或"是是是"
</code></pre>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>rp = 1.0</code>：无惩罚（允许重复）</li>
<li><code>rp = 1.2</code>：轻度惩罚（推荐）</li>
<li><code>rp = 2.0</code>：强度惩罚（可能失去必要的重复）</li>
</ul>






























<table><thead><tr><th>值</th><th>效果</th><th>使用场景</th></tr></thead><tbody><tr><td>1.0</td><td>允许重复</td><td>列表、枚举</td></tr><tr><td>1.2</td><td><strong>轻度限制</strong></td><td><strong>通用对话</strong> ⭐</td></tr><tr><td>1.5</td><td>中等限制</td><td>创意写作</td></tr><tr><td>2.0+</td><td>严格禁止</td><td>多样性要求高</td></tr></tbody></table>
<hr/>
<p><strong>策略 2：温度缩放（Temperature Scaling）</strong> [model.py:744]</p>
<pre><code class="hljs language-python" lang="python">logits /= (temperature + <span class="hljs-number">1e-9</span>)
</code></pre>
<p><strong>目的</strong>：控制生成的随机性/确定性程度</p>
<p><strong>工作原理</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">Softmax 概率计算：
  <span class="hljs-selector-tag">P</span>(token_i) = <span class="hljs-built_in">exp</span>(logits_i / temperature) / Σ <span class="hljs-built_in">exp</span>(logits_j / temperature)

temperature = <span class="hljs-number">0.1</span>（低温）：
  <span class="hljs-built_in">exp</span>(logits_i / <span class="hljs-number">0.1</span>) 放大了logits的差异
  → 分布尖锐，概率高的token更容易被选中
  → 生成结果确定、连贯

temperature = <span class="hljs-number">1.0</span>（常温）：
  标准 softmax
  → 平衡的随机性

temperature = <span class="hljs-number">2.0</span>（高温）：
  <span class="hljs-built_in">exp</span>(logits_i / <span class="hljs-number">2.0</span>) 缩小了logits的差异
  → 分布平坦，所有token概率接近
  → 生成结果随意、多样
</code></pre>
<p><strong>可视化</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">Logits: <span class="hljs-section">[2.0, 1.0, 0.5]</span>

<span class="hljs-attr">Temperature</span> = <span class="hljs-number">0.1</span> (确定模式):
  <span class="hljs-attr">P</span> = softmax([<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]) ≈ [<span class="hljs-number">0.999</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0</span>]
  ↓ 高概率token几乎必中

<span class="hljs-attr">Temperature</span> = <span class="hljs-number">1.0</span> (平衡模式):
  <span class="hljs-attr">P</span> = softmax([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>]) ≈ [<span class="hljs-number">0.659</span>, <span class="hljs-number">0.242</span>, <span class="hljs-number">0.099</span>]
  ↓ 保留一定的随机性

<span class="hljs-attr">Temperature</span> = <span class="hljs-number">2.0</span> (随机模式):
  <span class="hljs-attr">P</span> = softmax([<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.25</span>]) ≈ [<span class="hljs-number">0.409</span>, <span class="hljs-number">0.326</span>, <span class="hljs-number">0.265</span>]
  ↓ 所有token概率接近，高度随意
</code></pre>






























<table><thead><tr><th>温度</th><th>行为</th><th>使用场景</th></tr></thead><tbody><tr><td>0.1-0.5</td><td>确定、保守</td><td>代码、数据、事实问答</td></tr><tr><td>0.7-0.8</td><td><strong>平衡</strong></td><td><strong>通用对话</strong> ⭐</td></tr><tr><td>1.0-1.5</td><td>创意、多样</td><td>故事创作、诗歌</td></tr><tr><td>2.0+</td><td>极度随意</td><td>数据增强、探索</td></tr></tbody></table>
<hr/>
<p><strong>策略 3：核采样（Top-p/Nucleus Sampling）</strong> [model.py:747-763]</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> top_p <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> top_p &lt; <span class="hljs-number">1.0</span>:
    sorted_logits, sorted_indices = torch.sort(logits, descending=<span class="hljs-literal">True</span>, dim=-<span class="hljs-number">1</span>)
    sorted_probs = F.softmax(sorted_logits, dim=-<span class="hljs-number">1</span>)
    cumulative_probs = torch.cumsum(sorted_probs, dim=-<span class="hljs-number">1</span>)

    sorted_indices_to_remove = cumulative_probs &gt; top_p
    sorted_indices_to_remove[:, <span class="hljs-number">1</span>:] = sorted_indices_to_remove[:, :-<span class="hljs-number">1</span>].clone()
    sorted_indices_to_remove[:, <span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>

    indices_to_remove = sorted_indices_to_remove.scatter(<span class="hljs-number">1</span>, sorted_indices,
                                                          sorted_indices_to_remove)
    logits[indices_to_remove] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">'Inf'</span>)
</code></pre>
<p><strong>目的</strong>：动态选择候选token集合，避免选择低概率token</p>
<p><strong>工作原理</strong>（示例）：</p>
<pre><code class="hljs language-ini" lang="ini">概率分布（已排序）：
  P(token_A) = 0.50 → 累积: 0.50 ✅ 保留
  P(token_B) = 0.25 → 累积: 0.75 ✅ 保留
  P(token_C) = 0.15 → 累积: 0.90 ✅ 保留
  P(token_D) = 0.08 → 累积: 0.98 ❌ 移除（超过<span class="hljs-attr">top_p</span>=<span class="hljs-number">0.9</span>）
  P(token_E) = 0.02 → 累积: 1.00 ❌ 移除

Top-p采样：从<span class="hljs-section">[A, B, C]</span>中随机选择
          P(A|selected) = 0.50/<span class="hljs-attr">0.90</span> = <span class="hljs-number">0.556</span>
          P(B|selected) = 0.25/<span class="hljs-attr">0.90</span> = <span class="hljs-number">0.278</span>
          P(C|selected) = 0.15/<span class="hljs-attr">0.90</span> = <span class="hljs-number">0.167</span>
</code></pre>
<p><strong>与Top-k的对比</strong>：</p>



































<table><thead><tr><th>特性</th><th>Top-k采样</th><th>Top-p采样</th></tr></thead><tbody><tr><td><strong>原理</strong></td><td>保留概率最高的k个token</td><td>保留累积概率达p的token</td></tr><tr><td><strong>候选数</strong></td><td>固定k</td><td>动态（取决于分布）</td></tr><tr><td><strong>低置信度情况</strong></td><td>可能包含低分token</td><td>自动过滤</td></tr><tr><td><strong>高置信度情况</strong></td><td>可能过度限制</td><td>自动放松</td></tr><tr><td><strong>推荐值</strong></td><td>k=50</td><td><strong>p=0.9</strong> ⭐</td></tr></tbody></table>
<p><strong>工作场景对比</strong>：</p>
<pre><code class="hljs language-css" lang="css">高置信情况（模型很确定答案）：
  <span class="hljs-attribute">Top</span>-k (k=<span class="hljs-number">50</span>)：强制选择<span class="hljs-number">50</span>个token
               可能包含不相关的token

  <span class="hljs-attribute">Top</span>-<span class="hljs-selector-tag">p</span> (<span class="hljs-selector-tag">p</span>=<span class="hljs-number">0.9</span>)：可能只需<span class="hljs-number">5</span>个token就达到<span class="hljs-number">0.9</span>
                自动缩小候选集
                更优！✅

低置信情况（模型不确定答案）：
  <span class="hljs-attribute">Top</span>-k (k=<span class="hljs-number">50</span>)：保留<span class="hljs-number">50</span>个token
               可能包含很低分的

  <span class="hljs-attribute">Top</span>-<span class="hljs-selector-tag">p</span> (<span class="hljs-selector-tag">p</span>=<span class="hljs-number">0.9</span>)：需要<span class="hljs-number">50</span>个token才能达到<span class="hljs-number">0.9</span>
                自动放松限制
                更优！✅
</code></pre>
<hr/>
<p><strong>策略 4：多项式采样（Multinomial Sampling）</strong> [model.py:766]</p>
<pre><code class="hljs language-python" lang="python">input_ids_next = torch.multinomial(F.softmax(logits, dim=-<span class="hljs-number">1</span>), num_samples=<span class="hljs-number">1</span>)
</code></pre>
<p><strong>目的</strong>：按概率分布随机采样下一个token</p>
<p><strong>与贪心解码的对比</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">贪心解码（Greedy Decoding）：
  selected_token = <span class="hljs-built_in">argmax</span>(logits)
  ↓ 总是选择概率最高的token
  ↓ 确定但可能陷入局部最优

多项式采样（Multinomial Sampling）：
  <span class="hljs-selector-tag">P</span>(token_i) ∝ <span class="hljs-built_in">exp</span>(logits_i)
  selected_token ~ <span class="hljs-built_in">Multinomial</span>(P)
  ↓ 按概率随机选择
  ↓ 保留一定随机性，发现更多可能性
</code></pre>
<p><strong>概率示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">logits</span> = [<span class="hljs-number">2.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">0.5</span>]
<span class="hljs-attr">P</span> = softmax(logits) = [<span class="hljs-number">0.659</span>, <span class="hljs-number">0.242</span>, <span class="hljs-number">0.099</span>]

多项式采样：
  - 65.9% 概率选token_0
  - 24.2% 概率选token_1
  - 9.9% 概率选token_2

而不是总是选token_0（贪心）
</code></pre>
<hr/>
<h5 data-id="heading-87">采样策略的完整流程</h5>
<pre><code class="hljs language-scss" lang="scss">logits <span class="hljs-selector-attr">[vocab_size]</span>
    ↓
<span class="hljs-selector-attr">[1]</span> 重复惩罚
    对已出现的token：logits /= rp
    ↓ logits_penalized

<span class="hljs-selector-attr">[2]</span> 温度缩放
    logits /= temperature
    ↓ logits_scaled

<span class="hljs-selector-attr">[3]</span> 核采样（可选）
    <span class="hljs-attribute">mask</span> out low-probability tokens
    ↓ logits_filtered

<span class="hljs-selector-attr">[4]</span> 多项式采样
    <span class="hljs-selector-tag">P</span> = <span class="hljs-built_in">softmax</span>(logits_filtered)
    token ~ <span class="hljs-built_in">Multinomial</span>(P)
    ↓
next_token
</code></pre>
<h5 data-id="heading-88">采样参数的推荐配置</h5>






















































<table><thead><tr><th>场景</th><th>temperature</th><th>top_p</th><th>rp</th><th>特点</th></tr></thead><tbody><tr><td><strong>代码生成</strong></td><td>0.1</td><td>0.95</td><td>1.0</td><td>确定、无重复限制</td></tr><tr><td><strong>事实问答</strong></td><td>0.7</td><td>0.90</td><td>1.2</td><td>准确、避免重复</td></tr><tr><td><strong>对话交互</strong></td><td>0.8</td><td>0.90</td><td>1.2</td><td><strong>平衡</strong> ⭐</td></tr><tr><td><strong>故事创作</strong></td><td>1.2</td><td>0.85</td><td>1.1</td><td>创意、连贯</td></tr><tr><td><strong>数据增强</strong></td><td>1.5</td><td>0.80</td><td>1.0</td><td>多样、自由</td></tr><tr><td><strong>极度创意</strong></td><td>2.0</td><td>0.75</td><td>1.0</td><td>随意、无约束</td></tr></tbody></table>
<h5 data-id="heading-89">选取原因</h5>
<p><strong>1. 解决模式坍塌（Mode Collapse）</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">在生成任务中，如果只使用贪心解码：
<span class="hljs-bullet">  -</span> 模型总是选择概率最高的token
<span class="hljs-bullet">  -</span> 生成的文本虽然通顺，但极其单调
<span class="hljs-bullet">  -</span> 重复某些短语："我很高兴...我很高兴...我很高兴"

采样策略可以：
<span class="hljs-bullet">  -</span> 保留多样性
<span class="hljs-bullet">  -</span> 让"合理但不是最优"的token有机会被选中
<span class="hljs-bullet">  -</span> 生成更自然的文本
</code></pre>
<p><strong>2. 平衡质量和多样性</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">贪心：高质量 ✅，低多样性 ❌
采样：中等质量，高多样性 ✅

采样策略的组合：
<span class="hljs-bullet">  -</span> 温度：控制随机性程度
<span class="hljs-bullet">  -</span> Top-p：动态选择候选集
<span class="hljs-bullet">  -</span> 重复惩罚：避免冗余
<span class="hljs-bullet">  -</span> 多项式采样：最终选择

四者结合 → 既保持质量，又保留多样性 ⭐
</code></pre>
<p><strong>3. 实用性</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">所有先进LLM都使用采样生成：
<span class="hljs-bullet">  -</span> ChatGPT
<span class="hljs-bullet">  -</span> Claude
<span class="hljs-bullet">  -</span> Gemini
<span class="hljs-bullet">  -</span> LLaMA

都是 temperature + top<span class="hljs-emphasis">_p + 重复惩罚 的组合
</span></code></pre>
<h5 data-id="heading-90">核心优势</h5>
<pre><code class="hljs language-markdown" lang="markdown">避免生成单调重复文本
<span class="hljs-code">    ↓
保持多样性和创意性
    ↓
平衡质量和随机性
    ↓
适应不同应用场景
    ↓
提升用户体验
</span></code></pre>
<hr/>
<h3 data-id="heading-91">优化技术对比总结</h3>















































<table><thead><tr><th>技术</th><th>改进目标</th><th>实现复杂度</th><th>收益</th><th>现状</th></tr></thead><tbody><tr><td><strong>参数共享</strong></td><td>模型大小</td><td>⭐ 极简</td><td>参数减少50%</td><td>🔥 标准</td></tr><tr><td><strong>重复惩罚</strong></td><td>生成质量</td><td>⭐ 极简</td><td>避免重复</td><td>🔥 必需</td></tr><tr><td><strong>温度缩放</strong></td><td>生成多样性</td><td>⭐ 极简</td><td>可调随机性</td><td>🔥 必需</td></tr><tr><td><strong>核采样</strong></td><td>生成效率</td><td>⭐⭐ 简单</td><td>动态候选集</td><td>🔥 推荐</td></tr><tr><td><strong>多项式采样</strong></td><td>生成方式</td><td>⭐ 极简</td><td>保留多样性</td><td>🔥 标准</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-92">与标准GPT的改进对比</h3>
<h4 data-id="heading-93">原始GPT论文</h4>
<pre><code class="hljs language-scss" lang="scss">参数：嵌入矩阵 + 输出矩阵（分开）
生成：贪心解码 <span class="hljs-built_in">argmax</span>(logits)
      → 单调、重复
</code></pre>
<h4 data-id="heading-94">MiniMind的改进</h4>
<pre><code class="hljs language-css" lang="css">参数：参数共享
      → 减少 <span class="hljs-number">50%</span> 的嵌入+输出参数

生成：四阶段采样策略
      <span class="hljs-selector-attr">[重复惩罚]</span> → <span class="hljs-selector-attr">[温度缩放]</span> → <span class="hljs-selector-attr">[核采样]</span> → <span class="hljs-selector-attr">[多项式采样]</span>
      → 多样、流畅、自然
</code></pre>
<hr/>
<h3 data-id="heading-95">优化技术的实际效果</h3>
<h4 data-id="heading-96">参数共享的显存节省</h4>
<pre><code class="hljs language-ini" lang="ini">词汇表大小：32,000
模型维度：4,096

节省显存：32,000 × 4,096 × <span class="hljs-attr">4bytes</span> = <span class="hljs-number">0.52</span> GB（F32）
         32,000 × 4,096 × <span class="hljs-attr">2bytes</span> = <span class="hljs-number">0.26</span> GB（F16）

对于一个7B模型来说：节省 1-3% 显存
</code></pre>
<h4 data-id="heading-97">采样策略的生成质量对比</h4>















































<table><thead><tr><th>设置</th><th>文本流畅度</th><th>重复率</th><th>多样性</th><th>推荐度</th></tr></thead><tbody><tr><td><strong>贪心解码</strong></td><td>高</td><td>高</td><td>低</td><td>❌</td></tr><tr><td><strong>Temperature=0.8</strong></td><td>高</td><td>低</td><td>中</td><td>⭐⭐</td></tr><tr><td><strong>Top-p=0.9</strong></td><td>高</td><td>中</td><td>高</td><td>⭐⭐⭐</td></tr><tr><td><strong>T=0.8 + p=0.9</strong></td><td>高</td><td>低</td><td>高</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>T=0.8 + p=0.9 + rp=1.2</strong></td><td><strong>最优</strong></td><td><strong>最低</strong></td><td><strong>高</strong></td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Elasticsearch 避坑指南：我在项目中总结的 14 条实用经验]]></title>    <link>https://juejin.cn/post/7569959427879567370</link>    <guid>https://juejin.cn/post/7569959427879567370</guid>    <pubDate>2025-11-09T13:45:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7569959427879567370" data-draft-id="7567249547006607387" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Elasticsearch 避坑指南：我在项目中总结的 14 条实用经验"/> <meta itemprop="keywords" content="Elasticsearch,后端,性能优化"/> <meta itemprop="datePublished" content="2025-11-09T13:45:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="红尘旅人"/> <meta itemprop="url" content="https://juejin.cn/user/3485898277388519"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Elasticsearch 避坑指南：我在项目中总结的 14 条实用经验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3485898277388519/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    红尘旅人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T13:45:03.000Z" title="Sun Nov 09 2025 13:45:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>刚开始接触 Elasticsearch 时，我觉得它就像个黑盒子——数据往里一扔，查询语句一写，结果就出来了。直到负责公司核心业务的搜索模块后，我才发现这个黑盒子里面藏着无数需要注意的细节。</p>
</blockquote>
<hr/>
<p>今天就把我在实际项目中积累的 ES 使用经验分享给大家，主要从<strong>索引设计</strong>、<strong>字段类型</strong>、<strong>查询优化</strong>、<strong>集群管理</strong>和<strong>架构设计</strong>这几个方面来展开。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed326ed06d3f41ec9c1ee1010da01c42~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57qi5bCY5peF5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763300702&amp;x-signature=kA3%2FCjHgK3B0Ze8upiBaoF5nBzE%3D" alt="20251102-4.jpg" loading="lazy"/></p>
<h2 data-id="heading-0">索引设计：从基础到进阶</h2>
<h3 data-id="heading-1">1. 索引别名（alias）：为变更留条后路</h3>
<p>刚开始做项目时，我习惯直接用索引名。直到有一次需要修改字段类型，才发现 <strong>ES 不支持直接修改映射，也不支持修改主分片数</strong>，必须重建索引。（**新增字段是可以的）</p>
<p><strong>解决方案很简单</strong>：使用<strong>索引别名</strong>。业务代码中永远使用别名，重建索引时只需要切换别名的指向，整个过程用户无感知。</p>
<p>这就好比给索引起了个"外号"，里面怎么换内容都不影响外面的人称呼它。</p>
<h3 data-id="heading-2">2. Routing 路由：让查询更精准</h3>
<p>在做 <strong>SaaS 电商系统</strong>时，我发现查询某个商家的订单数据特别慢。原来，<strong>默认情况下ES根据文档ID的哈希值分配分片</strong>，导致同一个商家的数据分散在不同分片上。</p>
<p><strong>优化方案</strong>：使用商家 ID 作为 <strong>routing key</strong>，存储和查询数据时指定routing key。这样，同一个商家的所有数据都会存储在同一个分片上。</p>
<p><strong>效果对比</strong>：</p>
<ul>
<li>优化前：查询要扫描所有分片（比如3个分片都要查）</li>
<li>优化后：只需要查1个分片</li>
<li><strong>结果</strong>：查询速度直接翻倍，资源消耗还更少</li>
</ul>
<h3 data-id="heading-3">3. 分片拆分：应对数据增长</h3>
<p>当单个索引数据量持续增长时，单纯增加分片数并不是最佳方案。</p>
<p><strong>我的经验是</strong>：</p>
<ul>
<li><strong>业务索引</strong>：单个分片控制在 10-30GB</li>
<li><strong>搜索索引</strong>：10GB 以内更合适</li>
<li><strong>日志索引</strong>：可以放宽到 20-50GB</li>
</ul>
<p>对于 SaaS 系统，ES单索引数据较大，且存在“超级大商户”，导致数据倾斜严重时，可以按<strong>商家ID%64取模</strong>进行索引拆分，比如 <code>orders_001</code> 到 <code>orders_064</code>，每个索引包含部分商家的数据，然后再根据商户ID指定routing key。</p>
<blockquote>
<p>请根据<strong>业务数据量</strong>和<strong>业务要求</strong>，选择最适合的<strong>分片拆分规则</strong> 和<strong>routing key路由算法</strong>，同时不要因为拆分不合理，导致ES节点中存在大量分片。</p>
<p>ES默认<strong>单节点分片最大值为1000</strong>(7.0版本后)，可以参考ES官方建议，<strong>堆内存分片数量</strong>维持大约<strong>1:20</strong>的比例</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">字段类型：选择比努力重要</h2>
<h3 data-id="heading-5">4. Text vs Keyword：理解它们的本质区别</h3>
<p>曾经有个坑：用户手机号用 <strong>text 类型</strong>存储，结果搜索完整的手机号却搜不到。原来 text 类型会被分词，<code>13800138000</code> 可能被拆成 <code>138</code>、<code>0013</code>、<code>8000</code> 等片段。</p>
<p><strong>正确做法</strong>：</p>
<ul>
<li>需要分词搜索的用 <strong>text</strong>（如商品描述）</li>
<li>需要精确匹配的用 <strong>keyword</strong>（如订单号、手机号），适合 <strong>term、terms</strong> 等精确查询</li>
<li><strong>效果</strong>：keyword 类型的 term 查询速度更快，存储空间更小</li>
</ul>
<h3 data-id="heading-6">5. 多字段映射（multi-fields）：按需使用不浪费</h3>
<p>ES 默认会为 text 字段创建 keyword 子字段，但这并不总是必要的。</p>
<p><strong>我的选择</strong>：</p>
<ul>
<li>确定字段需要<strong>精确匹配和聚合</strong>时：启用 <strong>multi-fields</strong></li>
<li>只用于全文搜索时：禁用 multi-fields</li>
<li><strong>好处</strong>：节省存储空间，提升写入速度</li>
</ul>
<h3 data-id="heading-7">6. 排序字段：选对类型提升性能</h3>
<p>用 keyword 字段做数值排序是个常见误区。比如价格排序，<code>100</code> 会排在 <code>99</code> 前面，因为它是按字符串顺序比较的。</p>
<p><strong>推荐做法</strong>：</p>
<ul>
<li>数值排序：用 <strong>long、integer</strong> 类型</li>
<li>时间排序：用 <strong>date</strong> 类型</li>
<li><strong>提升效果</strong>：排序速度提升明显，内存占用也更少</li>
</ul>
<hr/>
<h2 data-id="heading-8">查询优化：平衡速度与精度</h2>
<h3 data-id="heading-9">7. 模糊查询：了解正确的打开方式</h3>
<p>在 <strong>ES 7.9 之前</strong>，<strong>wildcard 查询</strong>是个性能陷阱。它基于正则表达式引擎，前导通配符会导致全量词项扫描。</p>
<p><strong>现在的方案</strong>：</p>
<ul>
<li><strong>ES7.9+</strong>：使用 <strong>wildcard 字段类型</strong></li>
<li><strong>优势</strong>：底层使用优化的 <strong>n-gram</strong> + <strong>二进制 doc value</strong> 机制，性能提升显著</li>
</ul>
<blockquote>
<p>提示：ES7.9前后版本wildcard的具体介绍，可以参考我的上一篇文章</p>
<p><a href="https://juejin.cn/post/7567581946144522291" target="_blank" title="https://juejin.cn/post/7567581946144522291">《与产品经理的“模糊”对决：Elasticsearch实现MySQL LIKE '%xxx%'》</a></p>
</blockquote>
<h3 data-id="heading-10">8. 分页查询：避免深度分页的坑</h3>
<p>产品经理曾要求实现"无限滚动"，我展示了深度分页的性能数据后，大家达成共识：<strong>业务层面避免深度分页才是根本解决方案</strong>。就像淘宝、Google 这样的大厂，也都对分页做了限制，这不仅是技术考量，更是用户体验的最优选择。</p>
<p><strong>技术方案</strong>（仅在确实无法避免时考虑）：</p>
<ul>
<li><strong>浅分页</strong>：使用 <code>from/size</code>，适合前几页的常规分页</li>
<li><strong>Scroll</strong>：适合大数据量导出，但需要维护 scroll_id 和历史快照，对服务器资源消耗较大</li>
<li><strong>search_after</strong>：基于上一页最后一条记录进行分页，但无法跳转任意页面，且频繁查询会增加服务器压力</li>
</ul>
<p>需要强调的是，这些技术方案都存在各自的局限性，<strong>业务设计上的规避始终是最佳选择</strong>。</p>
<hr/>
<h2 data-id="heading-11">集群管理：保障稳定运行</h2>
<h3 data-id="heading-12">9. 索引生命周期：自动化运维</h3>
<p>日志数据的特点是源源不断，如果不加管理，磁盘很快就会被撑满。</p>
<p><strong>我的做法</strong>：</p>
<ul>
<li>按天创建索引（如 log_20231201）</li>
<li>设置保留策略（保留7天或30天）</li>
<li>结合模板自动化管理</li>
</ul>
<h3 data-id="heading-13">10. 准实时性：理解刷新机制</h3>
<p>很多新手会困惑：为什么数据写入后不能立即搜索？</p>
<p><strong>原理</strong>：<strong>ES 默认 1 秒刷新一次索引</strong>，这是为了在实时性和写入性能之间取得平衡。</p>
<p><strong>调整建议</strong>：</p>
<ul>
<li>实时性要求高：保持 1s</li>
<li>写入量大：适当调大 refresh_interval</li>
</ul>
<blockquote>
<p><strong>补充说明</strong>：如果需要更新后立即能查询到，通常有两种方案：</p>
<ol>
<li>让前端直接展示刚提交的数据，等下一次调用接口时再查询 ES</li>
<li>更新完后，前端延迟 1.5 秒后再查询</li>
</ol>
<p><strong>关键点</strong>：业务需求不一定都要后端实现，可以结合前端一起考虑解决方案。</p>
</blockquote>
<h3 data-id="heading-14">11. 内存配置：32G 限制的真相</h3>
<p>为什么 ES 官方建议不要超过 32G 内存？</p>
<p><strong>技术原因</strong>：Java 的<strong>压缩指针技术</strong>在 32G 以内有效，超过这个限制会浪费大量内存。</p>
<p><strong>实践建议</strong>：单个节点配置约50%内存，留出部分给操作系统。</p>
<hr/>
<h2 data-id="heading-15">架构设计：合理的分工协作</h2>
<h3 data-id="heading-16">12. ES 与数据库：各司其职</h3>
<p>曾经试图在 ES 里存储完整的业务数据，结果遇到<strong>数据一致性</strong>问题。</p>
<p><strong>现在的方案</strong>：</p>
<ul>
<li><strong>ES</strong>：存储搜索条件和文档 ID</li>
<li><strong>数据库</strong>：存储完整业务数据</li>
<li><strong>查询</strong>：ES 找 ID，数据库取详情</li>
</ul>
<p><strong>好处</strong>：既享受 ES 的搜索能力，又保证数据的强一致性。</p>
<h3 data-id="heading-17">13. 嵌套对象：保持数据关联性</h3>
<p>处理商品规格这类数组数据时，用普通的 <strong>object 类型</strong>会导致数据扁平化，破坏对象间的关联。</p>
<p><strong>解决方案</strong>：使用 <strong>nested 类型</strong>，保持数组内对象的独立性，确保查询结果的准确性。</p>
<h3 data-id="heading-18">14. 副本配置：读写平衡的艺术</h3>
<p>副本可以提升查询能力，但也不是越多越好。</p>
<p><strong>经验值</strong>：</p>
<ul>
<li>大多数场景：<strong>1 个副本</strong>足够</li>
<li>高查询压力：可适当增加</li>
<li><strong>注意</strong>：副本越多，写入压力越大</li>
</ul>
<hr/>
<h2 data-id="heading-19">写在最后</h2>
<p>这些经验都是在解决实际问题中慢慢积累的。就像修路一样，开始可能只是简单铺平，随着车流量的增加，需要不断优化——设置红绿灯、划分车道、建立立交桥。使用 ES 也是同样的道理，随着业务的发展，需要不断调整和优化。</p>
<p>最大的体会是：<strong>理解原理比记住命令更重要</strong>。只有明白了为什么这样设计，才能在遇到新问题时找到合适的解决方案。</p>
<blockquote>
<p>如果有人问我："ES 怎么才能用得更好？"我的回答是："先理解业务场景，再选择技术方案。就像我们之前做的模糊搜索，不是简单地用 wildcard，而是根据 ES 版本选择最优解。"</p>
</blockquote>
<p><strong>技术的价值不在于多复杂，而在于能否优雅地解决实际问题。与大家共勉。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter 拖拉对比组件，换装图片前后对比必备]]></title>    <link>https://juejin.cn/post/7570197010885034030</link>    <guid>https://juejin.cn/post/7570197010885034030</guid>    <pubDate>2025-11-09T12:28:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570197010885034030" data-draft-id="7568699551101075508" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter 拖拉对比组件，换装图片前后对比必备"/> <meta itemprop="keywords" content="Flutter,前端,开源"/> <meta itemprop="datePublished" content="2025-11-09T12:28:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LinXunFeng"/> <meta itemprop="url" content="https://juejin.cn/user/1820446984512392"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter 拖拉对比组件，换装图片前后对比必备
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1820446984512392/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LinXunFeng
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T12:28:38.000Z" title="Sun Nov 09 2025 12:28:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>欢迎关注微信公众号：<a href="https://link.juejin.cn?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" target="_blank" title="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" ref="nofollow noopener noreferrer">FSA全栈行动</a> 👋</p>
</blockquote>
<h2 data-id="heading-0">一、前言</h2>
<p>最近一个需求，需要在 <code>photo_view</code> 中实现拖拉对比两张图片的功能，要求不影响左右翻页及缩放手势。</p>
<p>其中前后图片上需要显示一些额外的信息，所以更准确来说，要对比的是两个视图，而不单单只是图片。</p>
<p>市面上几个现有的组件库，要么只能传入 <code>Image</code>，要么只允许全屏拖拽，且无法满足我们高自定义的需要，所以我自己做了一个。</p>
<p>相应的 <code>Demo</code> 可科学上网后在线体验:
<a href="https://link.juejin.cn?target=https%3A%2F%2Flinxunfeng.github.io%2Fflutter_compare_slider%2F" target="_blank" title="https://linxunfeng.github.io/flutter_compare_slider/" ref="nofollow noopener noreferrer">linxunfeng.github.io/flutter_com…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e582ebd2385247bdbfb966509bcdc5c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGluWHVuRmVuZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763296117&amp;x-signature=b6xhOjYJqMvCSsqTxQRu%2BLK7nRo%3D" alt="" loading="lazy"/></p>
<p>OK，接下来我们就来看看具体使用</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLinXunFeng%2Fflutter_compare_slider" target="_blank" title="https://github.com/LinXunFeng/flutter_compare_slider" ref="nofollow noopener noreferrer">github.com/LinXunFeng/…</a></p>
<h2 data-id="heading-1">二、使用</h2>
<p>添加依赖</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-attr">compare_slider:</span> <span class="hljs-string">latest_version</span>
</code></pre>
<p>导入</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:compare_slider/compare_slider.dart'</span>;
</code></pre>
<p>使用</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-built_in">double</span> value = <span class="hljs-number">0.5</span>;
<span class="hljs-built_in">double</span> thickness = <span class="hljs-number">1</span>;
<span class="hljs-built_in">bool</span> dragOnlyOnSlider = <span class="hljs-keyword">true</span>;

CompareSlider(
  <span class="hljs-comment">// 当前值 [0, 1]</span>
  value: value,
  <span class="hljs-comment">// 是否只允许在滑块区域拖拽</span>
  dragOnlyOnSlider: dragOnlyOnSlider,
  <span class="hljs-comment">// 原图视图（接收类型为 Widget，不局限于图片）</span>
  before: _buildImageView(isBefore: <span class="hljs-keyword">true</span>),
  <span class="hljs-comment">// 换装后的视图</span>
  after: _buildImageView(isBefore: <span class="hljs-keyword">false</span>),
  <span class="hljs-comment">// 分割线厚度</span>
  thickness: thickness,
  <span class="hljs-comment">// 拖拽的滑块和分割线</span>
  thumb: _buildThumb(),
  <span class="hljs-comment">// 滑块值改变时触发的回调</span>
  onValueChanged: (<span class="hljs-built_in">double</span> value) {
    <span class="hljs-keyword">this</span>.value = value;
    setState(() {});
  },
);
</code></pre>
<p>分割线与滑块</p>
<pre><code class="hljs language-dart" lang="dart">Widget _buildThumb() {
  <span class="hljs-keyword">return</span> Stack(
    clipBehavior: Clip.none,
    alignment: Alignment.center,
    children: [
      <span class="hljs-comment">// 分割线</span>
      _buildSliderLine(),
      <span class="hljs-comment">// 滑块</span>
      Positioned(
        left: -(thumbSize - thickness) / <span class="hljs-number">2</span>,
        child: _buildSliderThumb(),
      ),
    ],
  );
}

Widget _buildSliderLine() {
  <span class="hljs-keyword">return</span> Container(
    width: thickness,
    color: Colors.white.withValues(alpha: <span class="hljs-number">0.5</span>),
  );
}
</code></pre>
<p><code>thickness</code> 是分割线的宽度，传入用于提前计算其偏移量。</p>
<p><code>dragOnlyOnSlider</code> 默认为 <code>false</code>，即全区域拖动，如果设置为 <code>true</code>，则默认情况下，交互区域为 <code>_buildSliderLine()</code> 视图。</p>
<p>有时分割线的宽度较小，而你想扩大交互范围时，则可以通过 <code>extraHitTestArea</code> 来实现，结合 <code>debugHitTestAreaColor</code> 可清晰知道交互范围，如文章顶部动图中半透明红色。</p>
<p>为了不影响 <code>photo_view</code> 的缩放手势，可以在开始触摸滑块时（<code>onSliderThumbTouchBegin</code> 回调）禁用手势，在结束触摸滑块时（<code>onSliderThumbTouchEnd</code> 回调）恢复手势即可。</p>
<h2 data-id="heading-2">三、最后</h2>
<p>好了，开源不易，如果你也觉得这个库好用，请不吝给个 <code>Star</code>  👍 ，并多多支持！</p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLinXunFeng%2Fflutter_compare_slider" target="_blank" title="https://github.com/LinXunFeng/flutter_compare_slider" ref="nofollow noopener noreferrer">github.com/LinXunFeng/…</a></strong></p>
<p>本篇到此结束，感谢大家的支持，我们下次再见！ 👋</p>
<blockquote>
<p>如果文章对您有所帮助, 请不吝点击关注一下我的微信公众号：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" title="https://link.juejin.cn/?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" target="_blank">FSA全栈行动</a>, 这将是对我最大的激励. 公众号不仅有 <code>iOS</code> 技术，还有 <code>Android</code>，<code>Flutter</code>，<code>Python</code> 等文章, 可能有你想要了解的技能知识点哦~</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript + Web Audio API 打造炫酷音乐可视化效果，让你的网页跟随音乐跳起来]]></title>    <link>https://juejin.cn/post/7569904733718380563</link>    <guid>https://juejin.cn/post/7569904733718380563</guid>    <pubDate>2025-11-09T07:40:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7569904733718380563" data-draft-id="7564589390656208930" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript + Web Audio API 打造炫酷音乐可视化效果，让你的网页跟随音乐跳起来"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-09T07:40:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="刘大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript + Web Audio API 打造炫酷音乐可视化效果，让你的网页跟随音乐跳起来
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    刘大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T07:40:02.000Z" title="Sun Nov 09 2025 07:40:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大家好！我是大华！今天分享一下怎么用<code>Web Audio API</code>和<code>JavaScript</code>实现一个音乐旋律波长可视化效果。</p>
<h3 data-id="heading-1">效果预览</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bdac7a16d0640c8b70da8229b5ae462~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YiY5aSn5Y2O:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763278802&amp;x-signature=H8H5cyOds0MvrrN2Yr45e3oCoL4%3D" alt="20251017_115321.gif" loading="lazy"/></p>
<p>实现的效果：一个动态响应音乐频率的可视化界面，音频条会随着音乐的节奏和旋律起伏变化，形成波形图效果。</p>
<p><strong>完整源码在文末~</strong></p>
<h3 data-id="heading-2">技术核心：Web Audio API</h3>
<p>要实现音乐可视化，我们需要用到浏览器的<strong>Web Audio API</strong>。这个强大的API允许我们在浏览器中处理和分析音频数据。</p>
<h2 data-id="heading-3">代码实现详解</h2>
<p>在开始编码前，我们先理解Web Audio API的工作流程：</p>
<pre><code class="hljs">音频输入 → AudioContext → AnalyserNode → 频率数据 → 可视化渲染
</code></pre>
<h3 data-id="heading-4">关键组件：</h3>
<p><strong>1.AudioContext</strong>：音频处理的上下文环境
<strong>2.AnalyserNode</strong>：分析音频数据的节点
<strong>3.Frequency Data</strong>：频率数据数组
<strong>4.requestAnimationFrame</strong>：实现平滑动画</p>
<h3 data-id="heading-5">1. 创建基础HTML结构</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>音乐可视化<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-comment">/* CSS样式 */</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>音乐旋律波长可视化<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!-- 可视化区域 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"visualizer-container"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bars-container"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"barsContainer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!-- 控制区域 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"controls"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"startBtn"</span>&gt;</span>开始可视化<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"audioFile"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"audio/*"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"audioFile"</span>&gt;</span>选择音频文件<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"stopBtn"</span>&gt;</span>停止<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!-- 音频信息显示 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"audio-info"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"trackInfo"</span>&gt;</span>未选择音频文件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"frequency-info"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>低频: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lowFreq"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> Hz<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>中频: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"midFreq"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> Hz<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>高频: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"highFreq"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> Hz<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// JavaScript代码</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>设计思路：</strong></p>
<ul>
<li>模块化布局：标题、可视化区、控制区、信息区</li>
<li>语义化ID命名：便于JavaScript操作</li>
</ul>
<h3 data-id="heading-6">2. 动态创建音频条</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 获取DOM元素</span>
<span class="hljs-keyword">const</span> barsContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'barsContainer'</span>);

<span class="hljs-comment">// 创建64个音频条</span>
<span class="hljs-keyword">const</span> barCount = <span class="hljs-number">64</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; barCount; i++) {
    <span class="hljs-keyword">const</span> bar = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
    bar.<span class="hljs-property">className</span> = <span class="hljs-string">'bar'</span>;
    bar.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">'5px'</span>;  <span class="hljs-comment">// 初始高度</span>
    barsContainer.<span class="hljs-title function_">appendChild</span>(bar);
}
<span class="hljs-keyword">const</span> bars = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.bar'</span>);
</code></pre>
<p><strong>技术要点：</strong></p>
<ul>
<li>为什么选择64个音频条？这是性能与效果的平衡点</li>
<li>初始高度5px确保音频条始终可见</li>
<li>使用CSS Flex布局自动排列</li>
</ul>
<h3 data-id="heading-7">3. 音频条样式设计</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.bar</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span>;
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to top, <span class="hljs-number">#ff6b6b</span>, <span class="hljs-number">#ffde7d</span>, <span class="hljs-number">#6a98f0</span>);
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span> <span class="hljs-number">6px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
    <span class="hljs-attribute">transition</span>: height <span class="hljs-number">0.1s</span> ease-out;
    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">106</span>, <span class="hljs-number">152</span>, <span class="hljs-number">240</span>, <span class="hljs-number">0.5</span>);
}

<span class="hljs-selector-class">.bars-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: flex-end;  <span class="hljs-comment">/* 关键：从底部向上生长 */</span>
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">4px</span>;
}
</code></pre>
<p><strong>设计原理：</strong></p>
<ul>
<li><code>align-items: flex-end</code>：让柱子从底部开始生长</li>
<li><code>transition: height 0.1s</code>：平滑的高度变化动画</li>
<li>渐变背景：从红色到黄色到蓝色的视觉层次</li>
</ul>
<h3 data-id="heading-8">4. 创建音频上下文和分析器</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> audioContext;
<span class="hljs-keyword">let</span> analyser;
<span class="hljs-keyword">let</span> source;
<span class="hljs-keyword">let</span> dataArray;
<span class="hljs-keyword">let</span> bufferLength;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">initAudioContext</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!audioContext) {
        <span class="hljs-comment">// 创建音频上下文（兼容不同浏览器）</span>
        audioContext = <span class="hljs-keyword">new</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">AudioContext</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitAudioContext</span>)();
        
        <span class="hljs-comment">// 创建分析器节点</span>
        analyser = audioContext.<span class="hljs-title function_">createAnalyser</span>();
        
        <span class="hljs-comment">// 设置FFT大小，影响频率分析的精细度</span>
        analyser.<span class="hljs-property">fftSize</span> = <span class="hljs-number">256</span>;
        
        <span class="hljs-comment">// 获取频率数据数组长度</span>
        bufferLength = analyser.<span class="hljs-property">frequencyBinCount</span>;  <span class="hljs-comment">// 128</span>
        
        <span class="hljs-comment">// 创建用于存储频率数据的数组</span>
        dataArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(bufferLength);
    }
}
</code></pre>
<p><strong>核心概念解析：</strong></p>
<p><strong>FFT（快速傅里叶变换）</strong></p>
<ul>
<li>作用：将时域信号转换为频域信号</li>
<li>fftSize=256：将音频分成256个采样点进行分析</li>
<li>frequencyBinCount=128：得到128个频率区间数据</li>
</ul>
<p><strong>Uint8Array</strong></p>
<ul>
<li>8位无符号整数数组</li>
<li>取值范围：0-255</li>
<li>每个值代表对应频率区间的振幅</li>
</ul>
<h3 data-id="heading-9">5. 动画循环函数</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!isPlaying) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-comment">// 获取实时频率数据</span>
    analyser.<span class="hljs-title function_">getByteFrequencyData</span>(dataArray);
    
    <span class="hljs-comment">// 更新所有音频条</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bars.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">const</span> value = dataArray[i];
        <span class="hljs-keyword">const</span> percent = value / <span class="hljs-number">256</span>;  <span class="hljs-comment">// 转换为百分比</span>
        <span class="hljs-keyword">const</span> height = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(percent * <span class="hljs-number">200</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 计算高度</span>
        
        bars[i].<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${height}</span>px`</span>;
        
        <span class="hljs-comment">// 动态颜色：根据频率位置变化</span>
        <span class="hljs-keyword">const</span> hue = i * <span class="hljs-number">360</span> / bars.<span class="hljs-property">length</span>;
        bars[i].<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">`linear-gradient(to top, 
            hsl(<span class="hljs-subst">${hue}</span>, 100%, 50%), 
            hsl(<span class="hljs-subst">${hue + <span class="hljs-number">30</span>}</span>, 100%, 70%), 
            hsl(<span class="hljs-subst">${hue + <span class="hljs-number">60</span>}</span>, 100%, 50%))`</span>;
    }
    
    <span class="hljs-comment">// 更新频率信息显示</span>
    <span class="hljs-title function_">updateFrequencyInfo</span>();
    
    <span class="hljs-comment">// 循环调用</span>
    <span class="hljs-title function_">requestAnimationFrame</span>(animate);
}
</code></pre>
<p><strong>技术深度解析：</strong></p>
<p><strong>getByteFrequencyData()</strong></p>
<ul>
<li>功能：将当前音频的频率数据填充到指定数组</li>
<li>数据分布：低频在数组开头，高频在数组末尾</li>
<li>实时性：每帧获取的都是最新数据</li>
</ul>
<p><strong>HSL色彩模型</strong></p>
<ul>
<li>H（色相）：0-360度，实现彩虹效果</li>
<li>S（饱和度）：100%，鲜艳的颜色</li>
<li>L（亮度）：50%，适中的亮度</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li><code>Math.max(percent * 200, 5)</code>：确保最小高度，避免闪烁</li>
<li><code>requestAnimationFrame</code>：浏览器优化的60fps动画</li>
</ul>
<h3 data-id="heading-10">6. 频率信息显示</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFrequencyInfo</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 低频：索引2，约0-250Hz（鼓声、贝斯）</span>
    <span class="hljs-keyword">const</span> lowFreqValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(dataArray[<span class="hljs-number">2</span>] * <span class="hljs-number">2</span>);
    
    <span class="hljs-comment">// 中频：索引8，约250-2000Hz（人声、主旋律）</span>
    <span class="hljs-keyword">const</span> midFreqValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(dataArray[<span class="hljs-number">8</span>] * <span class="hljs-number">4</span>);
    
    <span class="hljs-comment">// 高频：索引20，约2000Hz以上（镲片、细节）</span>
    <span class="hljs-keyword">const</span> highFreqValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(dataArray[<span class="hljs-number">20</span>] * <span class="hljs-number">8</span>);
    
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'lowFreq'</span>).<span class="hljs-property">textContent</span> = lowFreqValue;
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'midFreq'</span>).<span class="hljs-property">textContent</span> = midFreqValue;
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'highFreq'</span>).<span class="hljs-property">textContent</span> = highFreqValue;
}
</code></pre>
<p><strong>频率分布原理：</strong></p>
<ul>
<li>数组索引对应不同的频率范围</li>
<li>乘数系数用于放大显示效果</li>
<li>实际应用中可以调整这些参数来匹配不同音乐类型</li>
</ul>
<h3 data-id="heading-11">7. 文件上传处理</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'audioFile'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">const</span> file = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (file) {
        <span class="hljs-keyword">const</span> objectUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(file);
        <span class="hljs-title function_">playAudioFile</span>(objectUrl);
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'trackInfo'</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">`正在播放: <span class="hljs-subst">${file.name}</span>`</span>;
    }
});

<span class="hljs-keyword">function</span> <span class="hljs-title function_">playAudioFile</span>(<span class="hljs-params">url</span>) {
    <span class="hljs-title function_">initAudioContext</span>();
    
    <span class="hljs-comment">// 停止之前的音频</span>
    <span class="hljs-keyword">if</span> (source &amp;&amp; source.<span class="hljs-property">stop</span>) {
        source.<span class="hljs-title function_">stop</span>();
    }
    
    <span class="hljs-comment">// 创建音频元素</span>
    <span class="hljs-keyword">const</span> audio = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audio</span>();
    audio.<span class="hljs-property">src</span> = url;
    audio.<span class="hljs-property">crossOrigin</span> = <span class="hljs-string">"anonymous"</span>;  <span class="hljs-comment">// 解决CORS问题</span>
    
    <span class="hljs-comment">// 连接到Web Audio API</span>
    source = audioContext.<span class="hljs-title function_">createMediaElementSource</span>(audio);
    source.<span class="hljs-title function_">connect</span>(analyser);
    analyser.<span class="hljs-title function_">connect</span>(audioContext.<span class="hljs-property">destination</span>);
    
    <span class="hljs-comment">// 开始播放</span>
    audio.<span class="hljs-title function_">play</span>();
    isPlaying = <span class="hljs-literal">true</span>;
    
    <span class="hljs-comment">// 开始动画</span>
    <span class="hljs-title function_">animate</span>();
}
</code></pre>
<p><strong>关键技术点：</strong></p>
<p><strong>createObjectURL()</strong></p>
<ul>
<li>创建指向本地文件的临时URL</li>
<li>避免直接文件路径访问的安全限制</li>
</ul>
<p><strong>createMediaElementSource()</strong></p>
<ul>
<li>将普通Audio元素转换为Web Audio节点</li>
<li>建立音频处理管道</li>
</ul>
<p><strong>CORS处理</strong></p>
<ul>
<li><code>crossOrigin="anonymous"</code>解决跨域资源访问</li>
<li>必要的安全措施</li>
</ul>
<h3 data-id="heading-12">8. 控制按钮逻辑</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'startBtn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!isPlaying) {
        <span class="hljs-keyword">if</span> (!source) {
            <span class="hljs-title function_">createOscillator</span>();  <span class="hljs-comment">// 默认演示音频</span>
        }
        <span class="hljs-title function_">initAudioContext</span>();
        isPlaying = <span class="hljs-literal">true</span>;
        <span class="hljs-title function_">animate</span>();
    }
});

<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'stopBtn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (isPlaying) {
        isPlaying = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (source &amp;&amp; source.<span class="hljs-property">stop</span>) {
            source.<span class="hljs-title function_">stop</span>();
            source = <span class="hljs-literal">null</span>;
        }
        <span class="hljs-comment">// 重置音频条</span>
        bars.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">bar</span> =&gt;</span> {
            bar.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">'5px'</span>;
        });
    }
});
</code></pre>
<h3 data-id="heading-13">9. 创建演示音频源</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createOscillator</span>(<span class="hljs-params"/>) {
    <span class="hljs-title function_">initAudioContext</span>();
    
    <span class="hljs-keyword">const</span> oscillator = audioContext.<span class="hljs-title function_">createOscillator</span>();
    oscillator.<span class="hljs-property">type</span> = <span class="hljs-string">'sawtooth'</span>;  <span class="hljs-comment">// 锯齿波，谐波丰富</span>
    oscillator.<span class="hljs-property">frequency</span>.<span class="hljs-title function_">setValueAtTime</span>(<span class="hljs-number">220</span>, audioContext.<span class="hljs-property">currentTime</span>);  <span class="hljs-comment">// A3音</span>
    
    <span class="hljs-keyword">const</span> gainNode = audioContext.<span class="hljs-title function_">createGain</span>();
    gainNode.<span class="hljs-property">gain</span>.<span class="hljs-property">value</span> = <span class="hljs-number">0.1</span>;  <span class="hljs-comment">// 音量控制</span>
    
    oscillator.<span class="hljs-title function_">connect</span>(gainNode);
    gainNode.<span class="hljs-title function_">connect</span>(analyser);
    analyser.<span class="hljs-title function_">connect</span>(audioContext.<span class="hljs-property">destination</span>);
    
    oscillator.<span class="hljs-title function_">start</span>();
    source = oscillator;
}
</code></pre>
<p><strong>音频合成原理：</strong></p>
<ul>
<li>振荡器类型影响音色特性</li>
<li>增益节点控制输出音量</li>
<li>220Hz对应钢琴的A3音</li>
</ul>
<h2 data-id="heading-14">原理解析：音频可视化是如何工作的？</h2>
<h3 data-id="heading-15">1. 音频分析基础</h3>
<p>当声音通过麦克风或音频文件进入Web Audio API时，它实际上是一系列连续的波形。AnalyserNode将这些波形通过<strong>傅里叶变换</strong>转换为频率数据。</p>
<p>简单来说，傅里叶变换可以将复杂的波形分解为不同频率的简单正弦波组合。</p>
<h3 data-id="heading-16">2. 频率数据</h3>
<p><code>getByteFrequencyData</code>方法返回一个Uint8Array（8位无符号整数数组），其中每个元素代表一个特定频率区间的振幅值，范围从0到255。</p>
<h3 data-id="heading-17">3. 可视化映射</h3>
<p>我们将这些数值映射到音频条的高度和颜色：</p>
<ul>
<li>值越大，音频条越高</li>
<li>不同的频率区间对应不同的颜色</li>
</ul>
<h2 data-id="heading-18">项目总结</h2>
<p><strong>已实现功能</strong></p>
<ul>
<li>音频文件上传和播放</li>
<li>实时频率分析和可视化</li>
<li>动态颜色变化效果</li>
<li>频率分区信息显示</li>
<li>响应式交互控制</li>
</ul>
<p><strong>通过这个项目，我们学习了：</strong></p>
<ul>
<li>Web Audio API的基本使用</li>
<li>如何获取和分析音频频率数据</li>
<li>使用JavaScript和CSS创建动态可视化效果</li>
<li>处理用户上传的文件</li>
</ul>
<p>完整代码在我的Github仓库，你可以直接复制使用。</p>
<p>Github地址：
<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F1344160559-lch%2Fdh-vue3-component%2Fblob%2Fmain%2FAudioVisualization%2Findex.html" target="_blank" title="https://github.com/1344160559-lch/dh-vue3-component/blob/main/AudioVisualization/index.html" ref="nofollow noopener noreferrer">github.com/1344160559-…</a></strong></p>
<blockquote>
<p>本文首发于公众号：程序员刘大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote>
<h4 data-id="heading-19">📌往期精彩</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP7SMincYFKERZbNKAFtzGQ" target="_blank" title="https://mp.weixin.qq.com/s/P7SMincYFKERZbNKAFtzGQ" ref="nofollow noopener noreferrer">《这20条SQL优化方案，让你的数据库查询速度提升10倍》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fy-GJ26kl0-yT6hE3fy2KjQ" target="_blank" title="https://mp.weixin.qq.com/s/y-GJ26kl0-yT6hE3fy2KjQ" ref="nofollow noopener noreferrer">《MySQL 为什么不推荐用雪花ID 和 UUID 做主键？》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1Th3DuMqYpt4Xg5hEywIww" target="_blank" title="https://mp.weixin.qq.com/s/1Th3DuMqYpt4Xg5hEywIww" ref="nofollow noopener noreferrer">《用html写了个超好用的网页主题切换插件》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfSMv8b_2Z-kozaBeiCgqrA" target="_blank" title="https://mp.weixin.qq.com/s/fSMv8b_2Z-kozaBeiCgqrA" ref="nofollow noopener noreferrer">《SpringBoot3+Vue3实现的数据库文档工具，自动生成Markdown/HTML》</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Webpack：从构建流程到性能优化的深度探索]]></title>    <link>https://juejin.cn/post/7569960869960368174</link>    <guid>https://juejin.cn/post/7569960869960368174</guid>    <pubDate>2025-11-09T12:35:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7569960869960368174" data-draft-id="7570201730991505434" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Webpack：从构建流程到性能优化的深度探索"/> <meta itemprop="keywords" content="Webpack,前端工程化,JavaScript"/> <meta itemprop="datePublished" content="2025-11-09T12:35:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="answerball"/> <meta itemprop="url" content="https://juejin.cn/user/209320781557531"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Webpack：从构建流程到性能优化的深度探索
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/209320781557531/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    answerball
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T12:35:37.000Z" title="Sun Nov 09 2025 12:35:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p><strong>引言：为什么我们需要构建工具？</strong></p>
<p>想象一下，你正在开发一个复杂的前端应用，有几十个JavaScript文件、几十个CSS文件、各种图片和字体资源。如果手动管理这些文件的依赖关系、合并、压缩，那将是一场噩梦。这就是Webpack等构建工具诞生的原因——它们像一位细心的管家，帮我们打理前端项目中的各种资源，让开发变得高效而愉快。</p>
<p>作为前端开发领域最流行的构建工具之一，Webpack已经成为了现代Web开发不可或缺的一部分。本文将带你深入探索Webpack的构建机制，并分享一系列提升开发效率的实用技巧。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a3c1fcfc332450c8738452b7fcd9f3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYW5zd2VyYmFsbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763296537&amp;x-signature=fs9CxMtzbLXdGwebCmHIQ8%2BpNkg%3D" alt="image.png" width="50%" loading="lazy"/></p>
<h2 data-id="heading-0">一、Webpack构建流程：一场精心编排的演出</h2>
<p>Webpack的构建过程就像一场精心编排的演出，每个环节都有明确的职责和顺序。让我们揭开这场演出的幕后秘密。</p>
<h3 data-id="heading-1">1.1 初始化阶段：准备舞台</h3>
<p>一切始于参数初始化。Webpack会从配置文件（通常是webpack.config.js）和Shell命令中读取参数，然后合并这些参数，得出最终的配置。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js 示例</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  },
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>
};
</code></pre>
<p>在这个阶段，Webpack会初始化Compiler对象——这是整个构建过程的大脑，负责调度和执行各个构建任务。同时，所有配置的插件会被加载，并注册到对应的事件钩子上。</p>
<h3 data-id="heading-2">1.2 编译阶段：演员就位</h3>
<p>编译阶段是构建过程的核心，它又可以分为几个关键步骤：</p>
<p><strong>确定入口</strong></p>
<p>Webpack从配置的entry开始，像侦探一样追踪每一个依赖。假设我们的入口文件是这样的：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> { utils } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./styles.css'</span>;

utils.<span class="hljs-title function_">sayHello</span>();
</code></pre>
<p>Webpack会先处理index.js，然后发现它依赖utils.js和styles.css，接着去处理这些文件，再发现这些文件的依赖...如此递归下去，最终形成一个完整的依赖图。</p>
<p><strong>编译模块</strong></p>
<p>对于每个模块，Webpack会根据配置的loader对其进行"翻译"。比如，对于CSS文件，css-loader会处理其中的@import和url()，style-loader则会将CSS注入到DOM中。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack配置中的loader部分</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>]
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>
      }
    ]
  }
};
</code></pre>
<p>这个过程就像把各种语言的书籍（不同类型的模块）翻译成统一的语言（JavaScript），让浏览器这个"读者"能够理解。</p>
<p><strong>完成模块编译</strong></p>
<p>经过loader的处理，每个模块都被转换成了浏览器能够理解的形式，同时Webpack也清晰地掌握了模块之间的依赖关系。</p>
<h3 data-id="heading-3">1.3 输出阶段：演出开始</h3>
<p><strong>输出资源</strong></p>
<p>Webpack会将相关的模块分组到不同的chunk中。比如，通过splitChunks优化，可以将第三方库单独打包：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">cacheGroups</span>: {
        <span class="hljs-attr">vendor</span>: {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">'vendors'</span>,
          <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>
        }
      }
    }
  }
};
</code></pre>
<p>每个chunk最终会被转换成单独的文件，加入到输出列表中。这时，插件还有最后一次机会修改输出内容。</p>
<p><strong>输出完成</strong></p>
<p>最后，Webpack根据配置的输出路径和文件名，将文件写入到文件系统中。至此，构建过程圆满完成。</p>
<h3 data-id="heading-4">1.4 插件系统：演出的特效团队</h3>
<p>Webpack的插件系统就像演出的特效团队，在特定时刻为演出增添亮点。插件通过监听Webpack在生命周期中广播的各种事件，在合适的时机执行自定义逻辑。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 一个简单的插件示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">'MyPlugin'</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'构建完成，准备输出资源！'</span>);
    });
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;
</code></pre>
<h2 data-id="heading-5">二、提升开发效率：Webpack的好帮手</h2>
<p>在了解了Webpack的构建流程后，让我们看看如何通过各种工具和技巧提升开发效率。</p>
<h3 data-id="heading-6">2.1 可视化工具：让构建过程一目了然</h3>
<p><strong>webpack-dashboard：构建仪表盘</strong></p>
<p>传统的命令行输出信息有限且不够直观。webpack-dashboard提供了一个全新的终端可视化界面，让你对构建状态、资源大小、错误信息等一目了然。</p>
<p>安装和使用非常简单：</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev webpack-dashboard
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">DashboardPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-dashboard/plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...其他配置</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DashboardPlugin</span>()
  ]
};
</code></pre>
<p><strong>speed-measure-webpack-plugin：性能分析专家</strong></p>
<p>这个插件可以测量各个loader和插件的耗时，帮你找出构建过程中的性能瓶颈。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SpeedMeasurePlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"speed-measure-webpack-plugin"</span>);
<span class="hljs-keyword">const</span> smp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpeedMeasurePlugin</span>();

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = smp.<span class="hljs-title function_">wrap</span>({
  <span class="hljs-comment">// 原来的webpack配置</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>] <span class="hljs-comment">// 这里会显示每个loader的耗时</span>
      }
    ]
  }
});
</code></pre>
<h3 data-id="heading-7">2.2 配置管理：让配置更清晰</h3>
<p><strong>webpack-merge：配置合并利器</strong></p>
<p>在大型项目中，我们通常需要针对不同环境（开发、测试、生产）使用不同的配置。webpack-merge可以帮助我们提取公共配置，避免重复代码。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { merge } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>);

<span class="hljs-comment">// 公共配置</span>
<span class="hljs-keyword">const</span> commonConfig = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [{
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
      <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>
    }]
  }
};

<span class="hljs-comment">// 开发环境配置</span>
<span class="hljs-keyword">const</span> devConfig = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'cheap-module-source-map'</span>
};

<span class="hljs-comment">// 生产环境配置  </span>
<span class="hljs-keyword">const</span> prodConfig = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'source-map'</span>
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (env === <span class="hljs-string">'production'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonConfig, prodConfig);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonConfig, devConfig);
};
</code></pre>
<h3 data-id="heading-8">2.3 热更新：开发者的福音</h3>
<p><strong>HotModuleReplacementPlugin</strong></p>
<p>热模块替换（HMR）是开发过程中极其有用的功能。它允许在运行时更新各种模块，而无需进行完全刷新，这意味着你可以在不丢失应用状态的情况下看到代码更改的效果。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...其他配置</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启热更新</span>
    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">'./dist'</span>
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()
  ]
};
</code></pre>
<p>对于CSS，HMR体验尤为出色 - 样式更改会立即反映在页面上。对于JavaScript，你可能需要手动处理模块更新：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) {
  <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-string">'./myModule'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 模块更新后的回调</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'myModule更新了！'</span>);
  });
}
</code></pre>
<h2 data-id="heading-9">三、文件指纹：精准控制缓存策略</h2>
<p>文件指纹是打包后输出文件名的后缀，用于控制浏览器缓存，是性能优化中的重要一环。</p>
<h3 data-id="heading-10">3.1 三种文件指纹策略</h3>
<p><strong>Hash：项目级别</strong></p>
<p>Hash与整个项目构建相关，只要项目文件有修改，整个项目构建的hash值就会改变。这种策略比较"粗放"，任何文件改动都会导致所有输出文件的hash变化。</p>
<p><strong>ChunkHash：代码块级别</strong></p>
<p>ChunkHash与webpack打包的chunk相关，不同的entry会生成不同的chunkhash。这种方式更为精准，只有属于同一chunk的文件发生变化时，该chunk的hash才会改变。</p>
<p><strong>ContentHash：内容级别</strong></p>
<p>ContentHash根据文件内容来定义hash，文件内容不变，contenthash就不变。这是最精确的缓存控制策略，特别适用于CSS等资源文件。</p>
<h3 data-id="heading-11">3.2 实战文件指纹配置</h3>
<p><strong>JavaScript的文件指纹</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">app</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">search</span>: <span class="hljs-string">'./src/search.js'</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name]-[chunkhash:8].js'</span> <span class="hljs-comment">// 使用8位chunkhash</span>
  }
};
</code></pre>
<p>这样会生成类似app-a1b2c3d4.js和search-e5f6g7h8.js的文件。</p>
<p><strong>CSS的文件指纹</strong></p>
<p>CSS的文件指纹需要借助MiniCssExtractPlugin：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">app</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">search</span>: <span class="hljs-string">'./src/search.js'</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name]-[chunkhash:8].js'</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-comment">// 使用MiniCssExtractPlugin的loader</span>
          <span class="hljs-string">'css-loader'</span>
        ]
      }
    ]
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name]-[contenthash:8].css'</span> <span class="hljs-comment">// 使用8位contenthash</span>
    })
  ]
};
</code></pre>
<p><strong>图片资源的文件指纹</strong></p>
<p>对于图片等静态资源，我们通常使用file-loader或url-loader来处理：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>)
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'file-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">name</span>: <span class="hljs-string">'images/[name]-[hash:8].[ext]'</span> <span class="hljs-comment">// 图片使用hash</span>
            }
          }
        ]
      }
    ]
  }
};
</code></pre>
<p>file-loader提供了丰富的占位符：</p>
<ul>
<li><code>[name]</code>：文件原名</li>
<li><code>[path]</code>：文件相对路径</li>
<li><code>[folder]</code>：文件所在文件夹</li>
<li><code>[hash]</code>：文件内容hash</li>
<li><code>[contenthash]</code>：内容hash（与hash通常相同）</li>
</ul>
<h2 data-id="heading-12">四、构建性能优化：让打包速度飞起来</h2>
<p>随着项目规模的增长，构建时间可能会成为开发效率的瓶颈。下面是一些实用的优化策略。</p>
<h3 data-id="heading-13">4.1 使用最新工具</h3>
<p>始终使用最新版本的Webpack和Node.js。每个新版本通常都会带来性能改进和新特性。Webpack 5相比Webpack 4在构建性能上有显著提升。</p>
<h3 data-id="heading-14">4.2 多进程构建</h3>
<p><strong>thread-loader</strong></p>
<p>将这个loader放在其他loader之前，其后的loader就会在单独的worker池中运行，充分利用多核CPU的优势。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'thread-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">workers</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 开启2个worker</span>
            }
          },
          <span class="hljs-string">'babel-loader'</span>
        ]
      }
    ]
  }
};
</code></pre>
<p>注意：thread-loader有一定启动开销，在小型项目中可能不太划算。</p>
<h3 data-id="heading-15">4.3 优化压缩过程</h3>
<p><strong>并行压缩JavaScript</strong></p>
<p>使用TerserWebpackPlugin开启多进程并行压缩：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>({
        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启多进程</span>
        <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 开启缓存</span>
      })
    ]
  }
};
</code></pre>
<p><strong>CSS压缩和提取</strong></p>
<p>使用MiniCssExtractPlugin配合优化器：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-minimizer-webpack-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">'css-loader'</span>]
      }
    ]
  },
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>()
    ]
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()]
};
</code></pre>
<h3 data-id="heading-16">4.4 图片优化</h3>
<p>使用image-webpack-loader自动压缩图片：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg)$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'file-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">name</span>: <span class="hljs-string">'images/[name]-[hash:8].[ext]'</span>
            }
          },
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'image-webpack-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">mozjpeg</span>: {
                <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">quality</span>: <span class="hljs-number">65</span>
              },
              <span class="hljs-attr">optipng</span>: {
                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>
              },
              <span class="hljs-attr">pngquant</span>: {
                <span class="hljs-attr">quality</span>: [<span class="hljs-number">0.65</span>, <span class="hljs-number">0.90</span>],
                <span class="hljs-attr">speed</span>: <span class="hljs-number">4</span>
              }
            }
          }
        ]
      }
    ]
  }
};
</code></pre>
<h3 data-id="heading-17">4.5 缩小打包作用域</h3>
<p>通过精确配置，减少Webpack的搜索范围，可以显著提升构建速度。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-comment">// 明确告诉webpack搜索哪些目录</span>
    <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'node_modules'</span>)],
    <span class="hljs-comment">// 使用别名减少查找过程</span>
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-string">'@'</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>)
    },
    <span class="hljs-comment">// 减少尝试的扩展名</span>
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.json'</span>]
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-comment">// 只对src目录下的js文件使用babel-loader</span>
        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>),
        <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>
      }
    ]
  }
};
</code></pre>
<h3 data-id="heading-18">4.6 提取公共资源</h3>
<p><strong>分离第三方库</strong></p>
<p>将不常变动的第三方库单独打包，可以利用浏览器缓存：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">cacheGroups</span>: {
        <span class="hljs-attr">vendor</span>: {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">'vendors'</span>,
          <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>
        }
      }
    }
  }
};
</code></pre>
<p><strong>使用CDN</strong></p>
<p>通过externals配置，将一些大型库排除在打包之外，通过CDN引入：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">externals</span>: {
    <span class="hljs-attr">react</span>: <span class="hljs-string">'React'</span>,
    <span class="hljs-string">'react-dom'</span>: <span class="hljs-string">'ReactDOM'</span>
  }
};
</code></pre>
<p>然后在HTML中通过script标签引入CDN资源。</p>
<h3 data-id="heading-19">4.7 充分利用缓存</h3>
<p>缓存是提升二次构建速度的利器。</p>
<p><strong>babel-loader缓存</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 开启babel缓存</span>
          }
        }
      }
    ]
  }
};
</code></pre>
<p><strong>持久化缓存</strong></p>
<p>Webpack 5提供了内置的持久化缓存：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">cache</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'filesystem'</span> <span class="hljs-comment">// 使用文件系统缓存</span>
  }
};
</code></pre>
<p>对于Webpack 4，可以使用hard-source-webpack-plugin：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hard-source-webpack-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span>()]
};
</code></pre>
<h3 data-id="heading-20">4.8 Tree Shaking：消除无用代码</h3>
<p>Tree Shaking就像园丁修剪树木一样，去除代码中未被使用的部分，让最终打包体积更小。</p>
<p>ES6模块系统是Tree Shaking的基础，因为ES6模块是静态的，可以在编译时确定依赖关系。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// math.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x * x;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x * x * x;
}

<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> { cube } <span class="hljs-keyword">from</span> <span class="hljs-string">'./math.js'</span>; <span class="hljs-comment">// 只引入了cube</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">cube</span>(<span class="hljs-number">5</span>));
</code></pre>
<p>在这个例子中，square函数不会被包含在最终的bundle中。</p>
<p>确保在package.json中设置sideEffects属性，帮助Webpack识别哪些文件有副作用：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"your-project"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"sideEffects"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"*.css"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"*.scss"</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-21">五、自定义Loader和Plugin：扩展Webpack能力</h2>
<p>当Webpack内置功能无法满足需求时，我们可以通过编写自定义loader和plugin来扩展其能力。</p>
<h3 data-id="heading-22">5.1 编写Loader：模块转换器</h3>
<p>Loader就像一个翻译官，负责将各种类型的模块"翻译"成Webpack能够理解的JavaScript。</p>
<p><strong>Loader开发原则</strong></p>
<ul>
<li>单一职责：每个loader只做一件事</li>
<li>链式调用：loader支持链式调用，前一个loader的输出作为后一个loader的输入</li>
<li>模块化：确保loader输出的是JavaScript模块</li>
<li>无状态：在多次构建之间，loader不应该保留状态</li>
</ul>
<p><strong>一个简单的Loader示例</strong></p>
<p>假设我们要开发一个简单的markdown loader：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">'marked'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-comment">// 获取loader的配置选项</span>
  <span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOptions</span>();
  
  <span class="hljs-comment">// 使用marked解析markdown</span>
  <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">marked</span>(source, options);
  
  <span class="hljs-comment">// 返回JavaScript模块</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`module.exports = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(html)}</span>`</span>;
};
</code></pre>
<p>使用这个loader：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'markdown-loader.js'</span>),
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">pedantic</span>: <span class="hljs-literal">true</span>
            }
          }
        ]
      }
    ]
  }
};
</code></pre>
<p><strong>Loader工具库</strong></p>
<p>官方提供的loader-utils和schema-utils可以简化loader开发：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { getOptions } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'loader-utils'</span>);
<span class="hljs-keyword">const</span> { validate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'schema-utils'</span>);

<span class="hljs-keyword">const</span> schema = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>,
  <span class="hljs-attr">properties</span>: {
    <span class="hljs-attr">test</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>
    }
  }
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-keyword">const</span> options = <span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>);
  
  <span class="hljs-comment">// 验证options是否符合schema</span>
  <span class="hljs-title function_">validate</span>(schema, options, <span class="hljs-string">'Example Loader'</span>);
  
  <span class="hljs-comment">// loader逻辑...</span>
  <span class="hljs-keyword">return</span> source;
};
</code></pre>
<h3 data-id="heading-23">5.2 编写Plugin：构建过程增强器</h3>
<p>如果说Loader处理的是单个模块，那么Plugin则是在整个构建过程中起作用，可以监听Webpack构建生命周期中的事件，在合适的时机执行自定义逻辑。</p>
<p><strong>Plugin基本结构</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    <span class="hljs-comment">// 注册钩子</span>
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">someHook</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">'MyPlugin'</span>, <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> {
      <span class="hljs-comment">// 插件逻辑</span>
    });
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;
</code></pre>
<p><strong>一个实用的Plugin示例</strong></p>
<p>让我们创建一个在构建完成后显示构建信息的插件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildInfoPlugin</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options || {};
  }

  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">'BuildInfoPlugin'</span>, <span class="hljs-function">(<span class="hljs-params">stats</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> { compilation } = stats;
      <span class="hljs-keyword">const</span> { outputOptions } = compilation;
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🎉 构建完成！'</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📁 输出目录: <span class="hljs-subst">${outputOptions.path}</span>`</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📦 文件数量: <span class="hljs-subst">${compilation.assets.length}</span>`</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`⏱ 构建时间: <span class="hljs-subst">${stats.endTime - stats.startTime}</span>ms`</span>);
      
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">showAssets</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'📄 生成文件:'</span>);
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(compilation.<span class="hljs-property">assets</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">assetName</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> asset = compilation.<span class="hljs-property">assets</span>[assetName];
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`   <span class="hljs-subst">${assetName}</span> (<span class="hljs-subst">${asset.size()}</span> bytes)`</span>);
        });
      }
    });
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">BuildInfoPlugin</span>;
</code></pre>
<p>使用这个插件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BuildInfoPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build-info-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildInfoPlugin</span>({
      <span class="hljs-attr">showAssets</span>: <span class="hljs-literal">true</span>
    })
  ]
};
</code></pre>
<p><strong>理解Compiler和Compilation</strong></p>
<p>在Plugin开发中，有两个核心概念需要理解：</p>
<ul>
<li>compiler：代表了配置完备的Webpack环境，从启动到关闭的整个生命周期</li>
<li>compilation：代表了一次单一的构建，包含了当前的模块资源、编译生成资源、变化的文件等信息</li>
</ul>
<p><strong>常用的钩子时机</strong></p>
<ul>
<li>entryOption：处理entry配置</li>
<li>compile：开始编译</li>
<li>emit：生成资源到output目录之前</li>
<li>done：编译完成</li>
</ul>
<h2 data-id="heading-24">结语</h2>
<p>Webpack作为现代前端开发的基石，其重要性不言而喻。通过深入了解其构建流程、掌握性能优化技巧、甚至能够编写自定义的loader和plugin，我们不仅能够提升开发效率，还能更好地应对复杂项目的构建需求。</p>
<p>记住，Webpack配置没有绝对的"最佳实践"，最适合项目需求的配置就是最好的配置。希望本文能帮助你在Webpack的学习和使用道路上走得更远，让构建工具真正成为提升开发体验的利器，而不是令人头疼的负担。</p>
<p>构建愉快！</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/310f9fafebf248d2bcd0e307983f15d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYW5zd2VyYmFsbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763296537&amp;x-signature=hd5FmxDyvnYgqcpe4eXd1FJ9zhg%3D" alt="image.png" width="50%" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++双向链表删除操作：由浅入深完全指南]]></title>    <link>https://juejin.cn/post/7570899512782176319</link>    <guid>https://juejin.cn/post/7570899512782176319</guid>    <pubDate>2025-11-10T11:17:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570899512782176319" data-draft-id="7570885801478144041" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++双向链表删除操作：由浅入深完全指南"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T11:17:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="oioihoii"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++双向链表删除操作：由浅入深完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    oioihoii
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:17:08.000Z" title="Mon Nov 10 2025 11:17:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>双向链表是一种基础且重要的数据结构，每个节点不仅包含数据，还包含指向前一个节点和后一个节点的指针。这种结构使得双向链表在插入和删除操作上，尤其是在已知节点位置时，比单向链表更具优势。</p>
<p>本文将聚焦于<strong>删除操作</strong>，带你从基本概念出发，逐步深入到边界处理和应用实践。</p>
<hr/>
<h3 data-id="heading-0"><strong>第一部分：基础篇 —— 删除节点的核心逻辑</strong></h3>
<p>在双向链表中删除一个节点，核心在于“重新布线”，将被删除节点前后两个节点连接起来，然后安全地释放该节点。</p>
<p>假设我们有一个简单的节点定义：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {
    <span class="hljs-type">int</span> val;
    ListNode* prev; <span class="hljs-comment">// 指向前一个节点</span>
    ListNode* next; <span class="hljs-comment">// 指向后一个节点</span>
    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) {}
};
</code></pre>
<p>现在，假设我们要在链表中删除一个已知的节点 <code>delNode</code>。下图清晰地展示了这一过程：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e15fa6831ca4695a50edf681093c273~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgb2lvaWhvaWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763378228&amp;x-signature=4X8IV%2FJbTfw%2F%2Bt5w0hC4DnX8Ajo%3D" alt="deepseek_mermaid_20251110_5ac562.png" loading="lazy"/></p>
<p>根据图示，我们可以将其转化为代码：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 前提：delNode 不是空指针，且存在于链表中</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* delNode)</span> </span>{
    <span class="hljs-comment">// 1. 处理前驱节点的next指针</span>
    <span class="hljs-keyword">if</span> (delNode-&gt;prev != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;prev-&gt;next = delNode-&gt;next;
    }
    <span class="hljs-comment">// 2. 处理后继节点的prev指针</span>
    <span class="hljs-keyword">if</span> (delNode-&gt;next != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;next-&gt;prev = delNode-&gt;prev;
    }
    <span class="hljs-comment">// 3. 安全删除节点</span>
    <span class="hljs-keyword">delete</span> delNode;
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>我们必须检查 <code>delNode-&gt;prev</code> 和 <code>delNode-&gt;next</code> 是否为空，因为要删除的节点可能是头节点或尾节点。</li>
<li>操作顺序很重要，但在此例中，只要在解除链接前获取了必要的信息，顺序可以调整。</li>
</ul>
<hr/>
<h3 data-id="heading-1"><strong>第二部分：进阶篇 —— 处理边界情况与设计封装</strong></h3>
<p>基础的删除逻辑很简单，但一个健壮的链表实现需要 meticulously (一丝不苟地) 处理各种边界情况。</p>
<h4 data-id="heading-2"><strong>情况一：删除头节点</strong></h4>
<p>如果 <code>delNode</code> 是链表的头节点，在删除后，链表的头指针需要被更新。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode** head_ref, ListNode* delNode)</span> </span>{
    <span class="hljs-comment">// 检查空指针</span>
    <span class="hljs-keyword">if</span> (*head_ref == <span class="hljs-literal">nullptr</span> || delNode == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 如果删除的是头节点，则需要更新头指针</span>
    <span class="hljs-keyword">if</span> (*head_ref == delNode) {
        *head_ref = delNode-&gt;next; <span class="hljs-comment">// 新的头节点是原头的下一个</span>
    }

    <span class="hljs-comment">// ... (接下来的连接操作与基础篇相同)</span>
    <span class="hljs-keyword">if</span> (delNode-&gt;next != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;next-&gt;prev = delNode-&gt;prev;
    }
    <span class="hljs-keyword">if</span> (delNode-&gt;prev != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;prev-&gt;next = delNode-&gt;next;
    }

    <span class="hljs-keyword">delete</span> delNode;
}
</code></pre>
<h4 data-id="heading-3"><strong>情况二：删除尾节点</strong></h4>
<p>如果 <code>delNode</code> 是尾节点，我们只需要更新它前一个节点的 <code>next</code> 指针为 <code>nullptr</code>。基础代码中的 <code>if (delNode-&gt;next != nullptr)</code> 已经完美处理了这种情况，防止了访问空指针的 <code>prev</code>。</p>
<h4 data-id="heading-4"><strong>情况三：删除唯一节点</strong></h4>
<p>如果链表只有一个节点，那么删除它后，头指针需要被置为 <code>nullptr</code>。上面的代码同样可以处理：它首先将 <code>*head_ref</code> 设置为 <code>delNode-&gt;next</code>（也就是 <code>nullptr</code>），然后进行连接操作（因为 <code>prev</code> 和 <code>next</code> 都是 <code>nullptr</code>，所以 <code>if</code> 内的语句不会执行）。</p>
<hr/>
<h3 data-id="heading-5"><strong>第三部分：实践篇 —— 完整的链表类与复杂删除</strong></h3>
<p>让我们在一个简单的双向链表类中实现删除功能，并探讨更复杂的场景。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> {
<span class="hljs-keyword">private</span>:
    ListNode* head;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">DoublyLinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) {}

    <span class="hljs-comment">// 删除指定值的第一个节点</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{
        ListNode* current = head;
        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-keyword">if</span> (current-&gt;val == value) {
                <span class="hljs-comment">// 找到节点，调用删除逻辑</span>
                <span class="hljs-keyword">if</span> (current == head) {
                    head = head-&gt;next;
                }
                <span class="hljs-keyword">if</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) {
                    current-&gt;next-&gt;prev = current-&gt;prev;
                }
                <span class="hljs-keyword">if</span> (current-&gt;prev != <span class="hljs-literal">nullptr</span>) {
                    current-&gt;prev-&gt;next = current-&gt;next;
                }
                <span class="hljs-keyword">delete</span> current;
                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 只删除第一个找到的</span>
            }
            current = current-&gt;next;
        }
    }

    <span class="hljs-comment">// 删除指定位置的节点 (索引从0开始)</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteByPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span> </span>{
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || position &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

        ListNode* current = head;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; current != <span class="hljs-literal">nullptr</span> &amp;&amp; i &lt; position; i++) {
            current = current-&gt;next;
        }

        <span class="hljs-comment">// 如果current为空，说明位置超出链表长度</span>
        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-comment">// 复用删除节点的核心逻辑</span>
        <span class="hljs-keyword">if</span> (current == head) {
            head = head-&gt;next;
        }
        <span class="hljs-keyword">if</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) {
            current-&gt;next-&gt;prev = current-&gt;prev;
        }
        <span class="hljs-keyword">if</span> (current-&gt;prev != <span class="hljs-literal">nullptr</span>) {
            current-&gt;prev-&gt;next = current-&gt;next;
        }
        <span class="hljs-keyword">delete</span> current;
    }

    <span class="hljs-comment">// 清空整个链表</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) {
            ListNode* temp = head;
            head = head-&gt;next;
            <span class="hljs-keyword">delete</span> temp;
        }
    }

    <span class="hljs-comment">// ... 其他成员函数，如push_front, push_back, print等</span>
};
</code></pre>
<p><strong>复杂删除场景：</strong></p>
<ol>
<li><strong>清空链表：</strong> 如 <code>clear()</code> 函数所示，它反复删除头节点，直到链表为空。这是一种高效且安全的方法。</li>
<li><strong>在析构函数中调用：</strong> 一个良好的 C++ 链表类必须在析构函数中清理所有节点，防止内存泄漏。
<pre><code class="hljs language-cpp" lang="cpp">~<span class="hljs-built_in">DoublyLinkedList</span>() {
    <span class="hljs-built_in">clear</span>();
}
</code></pre>
</li>
</ol>
<hr/>
<h3 data-id="heading-6"><strong>第四部分：深入理解 —— 与单向链表删除的对比</strong></h3>
<p>这是理解双向链表优势的关键。</p>

























<table><thead><tr><th align="left">特性</th><th align="left">单向链表</th><th align="left">双向链表</th></tr></thead><tbody><tr><td align="left"><strong>删除给定节点</strong></td><td align="left"><strong>O(n)</strong>。需要从头遍历以找到该节点的前驱节点。</td><td align="left"><strong>O(1)</strong>。因为通过 <code>prev</code> 指针可以直接找到前驱节点。</td></tr><tr><td align="left"><strong>删除头节点</strong></td><td align="left">O(1)</td><td align="left">O(1)</td></tr><tr><td align="left"><strong>删除尾节点</strong></td><td align="left">O(n)。需要找到倒数第二个节点。</td><td align="left">O(1)。通过尾节点的 <code>prev</code> 直接找到前驱。</td></tr></tbody></table>
<p><strong>结论：</strong> 当操作涉及到反向遍历或已知节点位置而非仅值时的删除，双向链表的效率远高于单向链表。</p>
<h3 data-id="heading-7"><strong>总结</strong></h3>
<p>从最基础的“重新布线”逻辑，到处理头节点、尾节点等边界情况，再到封装成完整的类并与单向链表进行对比，我们对C++双向链表的删除操作进行了一次由浅入深的探索。</p>
<p>记住成为一名优秀C++程序员的关键：</p>
<ul>
<li><strong>始终注意内存管理</strong>：<code>new</code> 和 <code>delete</code> 要成对出现。</li>
<li><strong>严谨处理边界</strong>：头节点、尾节点、空链表是bug的高发区。</li>
<li><strong>理解底层原理</strong>：明白指针是如何被操作的，才能写出正确、高效的代码。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[软件生产的“高速公路网”：深入浅出理解CI/CD的核心流程]]></title>    <link>https://juejin.cn/post/7570885801478160425</link>    <guid>https://juejin.cn/post/7570885801478160425</guid>    <pubDate>2025-11-10T11:18:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570885801478160425" data-draft-id="7570899512782192703" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="软件生产的“高速公路网”：深入浅出理解CI/CD的核心流程"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T11:18:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="oioihoii"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            软件生产的“高速公路网”：深入浅出理解CI/CD的核心流程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    oioihoii
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:18:19.000Z" title="Mon Nov 10 2025 11:18:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代软件开发中，我们追求的是快速、频繁且可靠地发布新功能。而实现这一目标的基石，就是CI/CD。很多人把CI/CD简单理解为一条“流水线”，但其内部实则有一套精密的“交通系统”，由多种不同的“流”构成。本文将为您拆解CI/CD中各种“流”的概念与作用。</p>
<h3 data-id="heading-0"><strong>一、 核心主干道：按流程阶段划分的“流”</strong></h3>
<p>这是理解CI/CD最经典的视角，描绘了代码从提交到上线的完整旅程。</p>
<h4 data-id="heading-1"><strong>1. CI（持续集成）流：代码的“质量检测线”</strong></h4>
<p>这条流的核心是<strong>快速反馈，确保代码质量</strong>。</p>
<ul>
<li><strong>触发信号</strong>：开发者向代码仓库（如Git）推送了新的代码。</li>
<li><strong>流水线工序</strong>：
<ol>
<li><strong>拉取代码</strong>：自动抓取最新的代码变更。</li>
<li><strong>静态检查</strong>：如同代码的“语法检查”，运行自动化工具扫描代码风格、潜在漏洞和复杂度。</li>
<li><strong>编译打包</strong>：将源代码“翻译”成可执行的软件包（如Docker镜像、JAR包）。</li>
<li><strong>单元测试</strong>：运行大量细粒度的测试，验证每个代码单元的正确性。</li>
</ol>
</li>
<li><strong>最终目标</strong>：生成一个<strong>可信的、可随时部署的软件制品</strong>，并存入“制品库”。如果此流程任何一步失败，团队会立即收到警报。</li>
</ul>
<h4 data-id="heading-2"><strong>2. CD流：软件的“发布之旅”</strong></h4>
<p>CI流确保了“货物”质量合格，CD流则负责将其“安全送达用户手中”。CD又分为两种模式：</p>
<p><strong>a) 持续交付流：整装待发，一键部署</strong></p>
<ul>
<li><strong>核心特征</strong>：<strong>自动化一切，但生产部署需要手动批准</strong>。</li>
<li><strong>流水线工序</strong>：
<ol>
<li><strong>自动部署到测试环境</strong>：将CI产生的制品部署到类生产环境。</li>
<li><strong>全面测试</strong>：进行更严格的集成测试、端到端测试和安全扫描。</li>
<li><strong>等待手动批准</strong>：在最终部署前，项目经理或运维人员点击“确认”按钮。</li>
<li><strong>一键部署</strong>：经批准后，自动化部署到生产环境。</li>
</ol>
</li>
<li><strong>适用场景</strong>：对发布有严格管控要求的企业，是目前最主流的模式。</li>
</ul>
<p><strong>b) 持续部署流：全程自动驾驶</strong></p>
<ul>
<li><strong>核心特征</strong>：<strong>完全自动化，无需手动干预</strong>。</li>
<li><strong>流水线工序</strong>：在持续交付的基础上，<strong>移除了手动批准环节</strong>。只要代码通过所有自动化测试关卡，就会像坐上滑梯一样，<strong>自动、直接地发布到生产环境</strong>。</li>
<li><strong>适用场景</strong>：追求极致效率、测试文化非常成熟的团队。</li>
</ul>
<blockquote>
<p><strong>简单比喻</strong>：持续交付像是把火箭发射按钮放在玻璃罩里，需要时再砸碎按下；持续部署则是程序自动判断最佳时机并直接发射。</p>
</blockquote>
<h3 data-id="heading-3"><strong>二、 分支策略流：代码管理的“交通规则”</strong></h3>
<p>在多人协作开发中，代码存放在不同的分支上，就像城市有不同的道路。不同的分支对应着不同的CI/CD流程。</p>
<ul>
<li>
<p><strong>特性分支流（城市小道）</strong>：</p>
<ul>
<li><strong>场景</strong>：开发者在自己的分支上开发新功能。</li>
<li><strong>流程</strong>：触发一个<strong>轻量级CI流</strong>，只进行编译和基础测试，目的是给开发者快速反馈，<strong>不部署</strong>。</li>
</ul>
</li>
<li>
<p><strong>主干/开发分支流（城市主干道）</strong>：</p>
<ul>
<li><strong>场景</strong>：代码合并到主分支或开发分支。</li>
<li><strong>流程</strong>：触发<strong>完整的CI流</strong>和后续的<strong>CD流</strong>，自动部署到测试或预发布环境。这是最重要的流程之一。</li>
</ul>
</li>
<li>
<p><strong>发布/热修复分支流（应急车道）</strong>：</p>
<ul>
<li><strong>场景</strong>：为发布版本或修复线上紧急Bug创建的分支。</li>
<li><strong>流程</strong>：触发一个<strong>稳定、快速的CI/CD流</strong>，旨在用最简路径将代码安全可靠地交付上线。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4"><strong>三、 发布模式流：上线时的“交通疏导方案”</strong></h3>
<p>当软件包抵达生产环境门口，如何让用户无感知、平滑地切换到新版本？这就需要智能的“交通疏导”策略。</p>
<ul>
<li>
<p><strong>蓝绿部署：整体切换</strong></p>
<ul>
<li><strong>描述</strong>：准备两套完全相同的环境（蓝和绿）。当前用户流量在蓝色（旧版本）。新版本在绿色环境部署测试完毕后，<strong>瞬间将全部流量从蓝色切换到绿色</strong>。</li>
<li><strong>优点</strong>：发布和回滚（切回蓝色）都极快，几乎零风险。</li>
</ul>
</li>
<li>
<p><strong>金丝雀发布：逐步放行</strong></p>
<ul>
<li><strong>描述</strong>：像矿工用金丝雀探测瓦斯一样，先将新版本部署到一小部分服务器，引入少量用户流量（如2%）。确认无误后，再逐步扩大范围，直至完全替换旧版本。</li>
<li><strong>优点</strong>：能最大限度地控制新版本故障的影响范围，是风险最低的发布策略。</li>
</ul>
</li>
<li>
<p><strong>滚动更新：渐进替换</strong></p>
<ul>
<li><strong>描述</strong>：在Kubernetes等平台中常见。逐步停止旧版本的实例，同时启动新版本的实例，直到所有实例都更新完毕。</li>
<li><strong>优点</strong>：服务不会中断，资源利用高效。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-5"><strong>总结：一张交织的智能网络</strong></h3>
<p>CI/CD中的这些“流”并非孤立存在，它们共同构成了一张智能高效的软件交付网络：</p>
<ul>
<li><strong>特性分支流</strong> 保障了开发过程的敏捷。</li>
<li><strong>CI流</strong> 作为质量基石，是所有后续流程的信任来源。</li>
<li><strong>主干分支流</strong> 驱动着 <strong>持续交付/部署流</strong>，实现了集成的自动化。</li>
<li><strong>蓝绿部署/金丝雀发布</strong> 等策略，则确保了发布最终用户时的平滑与安全。</li>
</ul>
<p>理解并巧妙组合这些流程，就如同为您的软件项目规划了一套完美的交通系统，能让您的创意以安全、稳定、极速的方式，抵达用户的指尖。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么在 JavaScript 中 NaN !== NaN？背后藏着 40 年的技术故事]]></title>    <link>https://juejin.cn/post/7570932873130901531</link>    <guid>https://juejin.cn/post/7570932873130901531</guid>    <pubDate>2025-11-10T11:54:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570932873130901531" data-draft-id="7570912420567662602" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 为什么在 JavaScript 中 NaN !== NaN？背后藏着 40 年的技术故事"/> <meta itemprop="keywords" content="前端,JavaScript,Node.js"/> <meta itemprop="datePublished" content="2025-11-10T11:54:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冴羽"/> <meta itemprop="url" content="https://juejin.cn/user/712139234359182"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             为什么在 JavaScript 中 NaN !== NaN？背后藏着 40 年的技术故事
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/712139234359182/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冴羽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:54:37.000Z" title="Mon Nov 10 2025 11:54:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 前言</h2>
<p>初学 JavaScript 的时候，经常会遇到一些令人困惑的现象，比如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> !== <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// true</span>
</code></pre>
<p>为什么一个值会不等于它自己呢？</p>
<p>今天，我们就来深入探究这个问题。</p>
<h2 data-id="heading-1">2. NaN 的本质：一个特殊的“数字”</h2>
<p>NaN 其实是 <code>Not a Number</code> 的缩写，表示它不是一个数字。但 NaN 的类型却是 <code>number</code></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// "number"</span>
</code></pre>
<p>所以你可以把 NaN 理解为一个数字类型的特殊值。</p>
<p>当你尝试将非数字字符串转换为数字，或者进行无效的数学运算时，就会得到 NaN：</p>
<pre><code class="hljs language-javascript" lang="javascript">+<span class="hljs-string">"oops"</span>; <span class="hljs-comment">// NaN</span>
<span class="hljs-number">0</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// NaN</span>
</code></pre>
<p>而当 NaN 出现在数学运算中时，它会导致所有运算结果都是 NaN：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> - <span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// NaN</span>
</code></pre>
<h2 data-id="heading-2">3. 深入底层：IEEE 754 标准的故事</h2>
<p>要理解 NaN !== NaN 的根源，我们需要回到 1985 年。</p>
<p>当时，IEEE 发布了 <strong>754 号标准</strong>——<a href="https://juejin.cn/post/6844904093601759239#heading-1" target="_blank" title="https://juejin.cn/post/6844904093601759239#heading-1">二进制浮点数算术标准</a>。</p>
<p>这个标准定义了浮点数的表示格式，包括一些特殊值：无穷大（Infinity）、负零（-0）和 NaN。</p>
<p><strong>IEEE 754 标准规定，当指数部分为 0x7FF 而尾数部分非零时，这个值表示 NaN。</strong></p>
<p><strong>更重要的是，标准明确要求 NaN 不等于自身。</strong></p>
<h3 data-id="heading-3">3.1. 为什么会这样设计呢？</h3>
<p>这其实是一种<strong>深思熟虑的设计</strong>，而非错误。主要原因是：</p>
<ol>
<li><strong>提供错误检测机制</strong>：在早期没有 <code>isNaN()</code> 函数的编程环境中，<code>x != x</code>是检测 NaN 的唯一方法</li>
<li><strong>逻辑一致性</strong>：NaN 代表“不是数字”，一个非数值确实不应该等于另一个非数值，这在逻辑上也是通畅的</li>
</ol>
<h3 data-id="heading-4">3.2. 跨语言的一致性</h3>
<p>因此 <code>NaN !== NaN</code> 的行为不仅存在于 JavaScript，而是贯穿所有遵循 IEEE 754 标准的编程语言：</p>
<p><strong>以 Python 为例：</strong></p>
<hr/>
<pre><code class="hljs language-plain" lang="plain">#Python

import math

nan = float('nan')
print(nan != nan)  # True
print(nan == nan)  # False
print(math.isnan(nan))  # True
</code></pre>
<hr/>
<p><strong>以 C++ 为例：</strong></p>
<hr/>
<pre><code class="hljs language-plain" lang="plain">//C++

#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main() {
    double nan = NAN;
    std::cout &lt;&lt; (nan != nan) &lt;&lt; std::endl;  // 1 (true)
    std::cout &lt;&lt; (nan == nan) &lt;&lt; std::endl;  // 0 (false)
    std::cout &lt;&lt; std::isnan(nan) &lt;&lt; std::endl;  // 1 (true, proper way)
    return 0;
}
</code></pre>
<p>以 Rust 为例：</p>
<pre><code class="hljs language-plain" lang="plain">//Rust

fn main() {
    let nan = f64::NAN;
    println!("{}", nan != nan);  // true
    println!("{}", nan == nan);  // false
    println!("{}", nan.is_nan());  // true (proper way)
}
</code></pre>
<h3 data-id="heading-5">3.3. 硬件级别的实现</h3>
<p>有趣的是，NaN 的比较行为不是在 JavaScript 引擎层面实现的，而是<strong>直接由 CPU 硬件提供</strong>的支持。想一想也很合逻辑，我们想要对数字进行运算，CPU 也是在操作数字，所以在 CPU 中进行运算会是最快的!</p>
<p>当我们查看 JavaScript 引擎源码时，会发现它们依赖底层系统的标准库：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Firefox</span>
bool <span class="hljs-built_in">isNaN</span>() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> <span class="hljs-title function_">isDouble</span>() &amp;&amp; <span class="hljs-attr">std</span>::<span class="hljs-title function_">isnan</span>(<span class="hljs-title function_">toDouble</span>()); }

<span class="hljs-comment">// V8</span>
<span class="hljs-keyword">if</span> (<span class="hljs-title class_">IsMinusZero</span>(value)) <span class="hljs-keyword">return</span> <span class="hljs-title function_">has_minus_zero</span>();
<span class="hljs-keyword">if</span> (<span class="hljs-attr">std</span>::<span class="hljs-title function_">isnan</span>(value)) <span class="hljs-keyword">return</span> <span class="hljs-title function_">has_nan</span>();
</code></pre>
<p>那 CPU 是如何识别 NaN 的呢？</p>
<p>以 x86 架构的 CPU 为例，它会用专门的 “浮点寄存器（xmm0）” 处理浮点数运算，还会用一条叫 ucomisd 的指令比较两个浮点数 —— 如果比较的是 NaN，这条指令会设置一个 “奇偶标志位（PF=1）”，相当于给 CPU 发信号：“这是 NaN，不能正常比较！”</p>
<p>简单来说：当你写 NaN === NaN 时，底层 CPU 其实已经判断出 “这两个值特殊”，所以返回 false。</p>
<p>再直观一点，我们可以用 C 语言直接操作硬件寄存器，计算 “0.0/0.0”（这会生成 NaN）：</p>
<pre><code class="hljs language-plain" lang="plain">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main() {
    double x = 0.0 / 0.0;
    // 直接读取 x 在内存中的二进制位
    uint64_t bits = *(uint64_t*)&amp;x;
    printf("NaN 的十六进制表示：0x%016lx\n", bits);
    return 0;
}
</code></pre>
<p>运行结果会是 <code>0xfff8000000000000</code>—— 这正是 IEEE 754 标准规定的 NaN 存储格式，和 CPU 的处理逻辑完全对应。</p>
<h2 data-id="heading-6">4. JavaScript 不能没有 NaN</h2>
<p>在 IEEE 754 标准之前，各硬件厂商有自己处理无效运算的方式。大多数情况下，像 0/0 这样的操作会直接导致<strong>程序崩溃</strong>。</p>
<p>想象一下，如果没有 NaN：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 我们需要对每个数学运算进行防御性检查</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">safeDivide</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">if</span> (b === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Division by zero!"</span>);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"number"</span> || <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"number"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Arguments must be numbers!"</span>);
  }
  <span class="hljs-keyword">return</span> a / b;
}

<span class="hljs-comment">// 使用try-catch包围每个可能出错的运算</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">safeDivide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-comment">// 处理错误...</span>
}
</code></pre>
<p>而有了 NaN，代码变得简洁而安全：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a / b; <span class="hljs-comment">// 让硬件处理边界情况</span>
}

<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// Infinity</span>
<span class="hljs-keyword">const</span> invalidResult = <span class="hljs-number">0</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// NaN</span>

<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(invalidResult)) {
  <span class="hljs-comment">// 在合适的地方统一处理错误</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"检测到无效计算"</span>);
}
</code></pre>
<h2 data-id="heading-7">5. 实际开发中如何检测？</h2>
<p>在日常开发中，我们应该如何使用 NaN 呢？</p>
<h3 data-id="heading-8">5.1. 使用 isNaN() 函数（不推荐）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"hello"</span>)); <span class="hljs-comment">// true - 注意：字符串会被先转换为数字</span>
</code></pre>
<p><code>isNaN()</code> 函数会先尝试将参数转换为数字，这可能导致意外的结果。</p>
<h3 data-id="heading-9">5.2. 使用 Number.isNaN()（推荐）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"hello"</span>)); <span class="hljs-comment">// false - 不会进行类型转换</span>
</code></pre>
<p>ES6 引入的 <code>Number.isNaN()</code> 只会对真正的 NaN 值返回 true，是更安全的选择。</p>
<h3 data-id="heading-10">5.3. 使用 Object.is() 方法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
</code></pre>
<p>ES6 的 <code>Object.is()</code> 方法能正确识别 NaN，但它使用严格相等比较，适用于特殊场景。</p>
<h2 data-id="heading-11">6. 总结</h2>
<p>NaN !== NaN 是 JavaScript 中一个看似奇怪但却<strong>设计合理</strong>的特性。它背后是 IEEE 754 标准的深思熟虑，目的是为浮点数运算提供一致且可靠的错误处理机制。</p>
<p>在实际开发中，记住以下几点：</p>
<ol>
<li><strong>始终使用<code>Number.isNaN()</code> 而不是 <code>isNaN()</code> 来检测 NaN 值</strong></li>
<li><strong>含有 NaN 的数学运算总会产生 NaN</strong></li>
<li><strong>利用这一特性**</strong>在代码中优雅地处理错误情况**</li>
<li><strong>记住 NaN 是数字类型的特殊值，这在类型检查时很重要</strong></li>
</ol>
<h2 data-id="heading-12">7. 参考链接</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpiccalil.li%2Fblog%2Fnan-the-not-a-number-number-that-isnt-nan%2F" target="_blank" title="https://piccalil.li/blog/nan-the-not-a-number-number-that-isnt-nan/" ref="nofollow noopener noreferrer">NaN, the not-a-number number that isn’t NaN</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpzarycki.com%2Fen%2Fposts%2Fjs-nan%2F" target="_blank" title="https://pzarycki.com/en/posts/js-nan/" ref="nofollow noopener noreferrer">Why NaN !== NaN in JavaScript (and the IEEE 754 story behind it)</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin泛型位置规律与设计考量]]></title>    <link>https://juejin.cn/post/7570902804451409930</link>    <guid>https://juejin.cn/post/7570902804451409930</guid>    <pubDate>2025-11-10T11:56:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804451409930" data-draft-id="7570932873130770459" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin泛型位置规律与设计考量"/> <meta itemprop="keywords" content="GitHub"/> <meta itemprop="datePublished" content="2025-11-10T11:56:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风冷"/> <meta itemprop="url" content="https://juejin.cn/user/3843548379091742"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin泛型位置规律与设计考量
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3843548379091742/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风冷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:56:17.000Z" title="Mon Nov 10 2025 11:56:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Kotlin泛型位置规律与设计考量</h2>
<h3 data-id="heading-1">1. 泛型出现的位置分类</h3>
<p>在Kotlin中，泛型可以出现在以下几个主要位置：</p>
<h4 data-id="heading-2">1.1 类声明中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt;(
    <span class="hljs-keyword">val</span> pagerId: String,
    <span class="hljs-keyword">val</span> nativeRef: <span class="hljs-built_in">Int</span>
) {
    <span class="hljs-keyword">val</span> view: T?
        <span class="hljs-keyword">get</span>() = PagerManager.getPager(pagerId)
            .getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
}
</code></pre>
<p><strong>规律</strong>：</p>
<ul>
<li>泛型参数<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>紧跟在类名后面</li>
<li>用于定义整个类的类型参数</li>
<li>可以在类的任何地方使用这个类型参数</li>
</ul>
<p><strong>设计考量</strong>：</p>
<ul>
<li>类型安全：确保ViewRef只能引用特定类型的视图</li>
<li>代码复用：一个类可以处理多种类型，但保持类型安全</li>
<li>API一致性：所有ViewRef实例都有相同的方法签名，但类型不同</li>
</ul>
<h4 data-id="heading-3">1.2 函数声明中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    ref(ViewRef&lt;T&gt;(pagerId, nativeRef))
}
</code></pre>
<p><strong>规律</strong>：</p>
<ul>
<li>泛型参数<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>在fun关键字和函数名之间</li>
<li>用于定义函数的类型参数</li>
<li>可以在函数的参数、返回值和函数体中使用这个类型参数</li>
</ul>
<p><strong>设计考量</strong>：</p>
<ul>
<li>扩展函数：为特定类型的所有子类提供统一方法</li>
<li>类型推断：编译器可以自动推断T的类型</li>
<li>灵活性：同一个函数可以处理多种类型，但保持类型安全</li>
</ul>
<h4 data-id="heading-4">1.3 接口声明中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IViewPublicApi</span>&lt;<span class="hljs-type">A : Attr, E : Event</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">attr</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">A</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">event</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">E</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>
}
</code></pre>
<p><strong>规律</strong>：</p>
<ul>
<li>接口级别的泛型<code>&lt;A : Attr, E : Event&gt;</code>在接口名后</li>
<li>方法级别的泛型<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>在方法名前</li>
</ul>
<p><strong>设计考量</strong>：</p>
<ul>
<li>接口泛型：定义接口的类型参数，影响整个接口</li>
<li>方法泛型：只影响特定方法的类型参数</li>
</ul>
<h3 data-id="heading-5">2. 泛型位置的设计规律</h3>
<h4 data-id="heading-6">2.1 作用域规律</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 类级别泛型：作用域是整个类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-keyword">val</span> view: T? <span class="hljs-comment">// T在整个类中可用</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>: T? { <span class="hljs-keyword">return</span> view } <span class="hljs-comment">// T在方法中可用</span>
}

<span class="hljs-comment">// 函数级别泛型：作用域是整个函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T只在函数内可用</span>
    ref(ViewRef&lt;T&gt;(pagerId, nativeRef))
}
</code></pre>
<h4 data-id="heading-7">2.2 生命周期规律</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 类泛型：与类实例生命周期相同</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> items = mutableListOf&lt;T&gt;()
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> { items.add(item) }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T = items[index]
}

<span class="hljs-comment">// 函数泛型：只存在于函数调用期间</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">createList</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> items: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> listOf(*items) <span class="hljs-comment">// T只在函数执行期间有效</span>
}
</code></pre>
<h3 data-id="heading-8">3. 泛型约束的位置规律</h3>
<h4 data-id="heading-9">3.1 上界约束</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 类泛型约束</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; { <span class="hljs-comment">// T必须是DeclarativeBaseView的子类</span>
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 函数泛型约束</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(...)</span></span> { <span class="hljs-comment">// T必须是DeclarativeBaseView的子类</span>
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 多重约束</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">process</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> <span class="hljs-keyword">where</span> T : DeclarativeBaseView&lt;*, *&gt;, T : Cloneable {
    <span class="hljs-comment">// T必须同时满足两个约束</span>
}
</code></pre>
<h4 data-id="heading-10">3.2 型变约束</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 生产者位置（out）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T { ... }
}

<span class="hljs-comment">// 消费者位置（in）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> { ... }
}

<span class="hljs-comment">// 不变位置</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>: T { ... }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> { ... }
}
</code></pre>
<h3 data-id="heading-11">4. 泛型在Kotlin中的特殊位置</h3>
<h4 data-id="heading-12">4.1 扩展函数中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 扩展函数泛型：T是接收者类型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T既是泛型参数，也是接收者类型</span>
}

<span class="hljs-comment">// 扩展属性中的泛型</span>
<span class="hljs-keyword">val</span> &lt;T : DeclarativeBaseView&lt;*, *&gt;&gt; T.refCount: <span class="hljs-built_in">Int</span>
    <span class="hljs-keyword">get</span>() = <span class="hljs-number">1</span>
</code></pre>
<h4 data-id="heading-13">4.2 高阶函数中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 函数类型中的泛型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">execute</span><span class="hljs-params">(operation: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>, param: <span class="hljs-type">T</span>)</span></span> {
    operation(param)
}

<span class="hljs-comment">// 函数类型参数中的泛型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T在函数类型参数中使用</span>
}
</code></pre>
<h4 data-id="heading-14">4.3 泛型型变</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 协变（out）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T
}

<span class="hljs-comment">// 逆变（in）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>
}

<span class="hljs-comment">// 星投影</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;*&gt;)</span></span> {
    <span class="hljs-comment">// List&lt;*&gt; 表示未知类型的List</span>
}
</code></pre>
<h3 data-id="heading-15">5. 实际项目中的泛型位置选择</h3>
<h4 data-id="heading-16">5.1 类泛型 vs 函数泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 使用类泛型的情况：类型需要在整个类中保持一致</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-keyword">val</span> view: T? <span class="hljs-comment">// 需要在多个地方使用T</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>: T? { <span class="hljs-keyword">return</span> view }
}

<span class="hljs-comment">// 使用函数泛型的情况：类型只在函数中使用</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T只在函数内使用</span>
}
</code></pre>
<h4 data-id="heading-17">5.2 多层泛型嵌套</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 多层泛型嵌套</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PagerManager</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; <span class="hljs-title">getView</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>, nativeRef: <span class="hljs-type">Int</span>)</span></span>: T? {
        <span class="hljs-keyword">return</span> PagerManager.getPager(pagerId)
            .getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
    }
}

<span class="hljs-comment">// 使用时</span>
<span class="hljs-keyword">val</span> textView: TextView? = PagerManager.getView&lt;TextView&gt;(<span class="hljs-string">"pager1"</span>, <span class="hljs-number">123</span>)
<span class="hljs-keyword">val</span> buttonView: Button? = PagerManager.getView&lt;Button&gt;(<span class="hljs-string">"pager1"</span>, <span class="hljs-number">456</span>)
</code></pre>
<h3 data-id="heading-18">6. 泛型位置的设计原则</h3>
<h4 data-id="heading-19">6.1 最小作用域原则</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 好的设计：泛型作用域最小化</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">process</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> item.toString()
}

<span class="hljs-comment">// 避免：不必要的类泛型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Processor</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: String {
        <span class="hljs-keyword">return</span> item.toString()
    }
}
</code></pre>
<h4 data-id="heading-20">6.2 类型安全原则</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 好的设计：明确的类型约束</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-comment">// 确保T是DeclarativeBaseView的子类</span>
}

<span class="hljs-comment">// 避免：无约束的泛型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-comment">// T可以是任何类型，可能导致运行时错误</span>
}
</code></pre>
<h4 data-id="heading-21">6.3 可读性原则</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 好的设计：有意义的泛型参数名</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">TView : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getView</span><span class="hljs-params">()</span></span>: TView? { ... }
}

<span class="hljs-comment">// 避免：无意义的泛型参数名</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getView</span><span class="hljs-params">()</span></span>: T? { ... }
}
</code></pre>
<h3 data-id="heading-22">7. 总结</h3>
<p>Kotlin中泛型位置的选择遵循以下规律和原则：</p>
<ol>
<li>
<p><strong>作用域决定位置</strong>：</p>
<ul>
<li>类泛型：需要在整个类中使用</li>
<li>函数泛型：只在函数中使用</li>
<li>接口泛型：影响整个接口</li>
</ul>
</li>
<li>
<p><strong>生命周期决定位置</strong>：</p>
<ul>
<li>长生命周期：使用类泛型</li>
<li>短生命周期：使用函数泛型</li>
</ul>
</li>
<li>
<p><strong>类型安全决定约束</strong>：</p>
<ul>
<li>明确约束：使用上界约束</li>
<li>多重约束：使用where子句</li>
</ul>
</li>
<li>
<p><strong>使用场景决定型变</strong>：</p>
<ul>
<li>生产者：使用out</li>
<li>消费者：使用in</li>
<li>读写操作：不变</li>
</ul>
</li>
</ol>
<p>在ViewRef的设计中：</p>
<ul>
<li>类泛型<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>确保类型安全</li>
<li>函数泛型<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt; T.ref(...)</code>提供扩展能力</li>
<li>泛型约束确保只能引用正确的视图类型</li>
<li>泛型位置的选择平衡了灵活性、安全性和可读性</li>
</ul>
<p>这种设计使得ViewRef既类型安全又使用灵活，是Kotlin泛型系统在实际项目中的优秀应用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Agent】生成式隐式记忆 MemGen 源码解读]]></title>    <link>https://juejin.cn/post/7570940025580486696</link>    <guid>https://juejin.cn/post/7570940025580486696</guid>    <pubDate>2025-11-10T11:58:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570940025580486696" data-draft-id="7569864390942425139" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Agent】生成式隐式记忆 MemGen 源码解读"/> <meta itemprop="keywords" content="算法,人工智能"/> <meta itemprop="datePublished" content="2025-11-10T11:58:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="罗西的思考"/> <meta itemprop="url" content="https://juejin.cn/user/351470467691175"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Agent】生成式隐式记忆 MemGen 源码解读
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/351470467691175/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    罗西的思考
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:58:10.000Z" title="Mon Nov 10 2025 11:58:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">【Agent】生成式隐式记忆 MemGen 源码解读</h2>
<p>[toc]</p>
<h3 data-id="heading-1">0x00 概要</h3>
<p>MemGen旨在构建一个动态、生成式的记忆框架，其核心由两个协同工作的轻量级模块构成：一个基于强化学习（RL）训练的记忆触发器（Memory Trigger）和一个记忆编织器（Memory Weaver）。</p>
<p>论文：MemGen: Weaving Generative Latent Memory for Self-Evolving Agents</p>
<p>链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2509.24704" target="_blank" title="https://arxiv.org/abs/2509.24704" ref="nofollow noopener noreferrer">arxiv.org/abs/2509.24…</a></p>
<p>代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKANABOON1%2FMemGen" target="_blank" title="https://github.com/KANABOON1/MemGen" ref="nofollow noopener noreferrer">github.com/KANABOON1/M…</a></p>
<h3 data-id="heading-2">0x01 背景</h3>
<p>MemGen 提出动态生成式记忆框架，由记忆触发器与记忆编织器两个轻量模块协同构成，旨在突破现有智能体记忆范式的局限。</p>
<p>当前主流的记忆实现路径为：</p>
<ul>
<li>参数化记忆通过微调将经验编码进模型参数，虽能深度内化知识却易引发灾难性遗忘；</li>
<li>基于检索的记忆将经验外化存储，虽规避了遗忘问题，但静态的一次性检索机制无法体现记忆与推理动态交互的认知特性。</li>
</ul>
<p>这一现状引出两大核心问题：如何实现记忆与推理在每一步思考中的无缝耦合，以及如何让记忆从提取式升级为满足当前需求的生成式重构，而动态生成式隐式记忆正是应对这些挑战的第三种探索路径。</p>
<h3 data-id="heading-3">0x02 源码解析</h3>
<p>MemGen项目旨在创建一个动态且自生成的记忆框架，该框架由两个协同工作的轻量级模块组成：一个基于强化学习训练的记忆触发器和一个记忆编织器。这一框架的核心思想是解决大型语言模型（LLM）智能体能力涌现时对“自进化”机制的探索需求，其中记忆扮演关键角色。</p>
<h4 data-id="heading-4">2.1 模型</h4>
<p>LatentMemoryModel 是 MemGen 框架的核心实现，旨在构建动态生成式隐式记忆系统，解决传统记忆范式的局限性。通过整合推理器（Reasoner）、记忆编织器（Weaver）和记忆触发器（Trigger），实现记忆与推理过程的无缝耦合，让智能体在任务执行中动态生成、使用记忆，而非依赖静态检索或参数化存储。</p>
<h5 data-id="heading-5">2.1.1  核心特色</h5>
<p>模型的核心特色如下：</p>
<ul>
<li><strong>模块化协同设计</strong>：由推理器（核心推理）、编织器（生成潜在记忆）、触发器（控制记忆触发）三大模块构成，模块间通过投影层实现嵌入空间映射，结构清晰且解耦。</li>
<li><strong>动态记忆增强</strong>：在推理过程中自动识别分隔符位置作为记忆增强点，动态插入编织器生成的潜在记忆，突破静态记忆注入的局限，贴合人类认知中记忆与推理的动态交互特性。</li>
<li><strong>精度与效率优化</strong>：默认使用 bfloat16 精度，推理器采用 Flash Attention 2 提升计算效率；冻结推理器参数，仅训练编织器和触发器，实现参数高效学习。</li>
<li><strong>灵活配置与兼容性</strong>：支持自定义触发器模型、PEFT 微调配置、记忆增强次数等参数；自动处理 Tokenizer 缺失 pad token 的问题，标准化对话模板，提升跨场景兼容性。</li>
<li><strong>损失计算精准过滤</strong>：通过潜在记忆掩码排除记忆嵌入对应的位置，仅对原始输入位置计算损失，确保训练目标聚焦于核心任务性能，避免记忆生成过程干扰主任务学习。</li>
</ul>
<h5 data-id="heading-6">2.1.2  网络结构</h5>
<p>关键说明（核心设计亮点）</p>
<ol>
<li><strong>三大模块协同逻辑</strong>：
<ul>
<li>推理器（Reasoner）：核心推理组件，权重冻结以保留基础能力，仅通过潜在记忆调整解码路径。</li>
<li>触发器（MemGenTrigger）：动态判断记忆插入时机，输出二分类触发概率，决定是否调用编织器。</li>
<li>编织器（MemGenWeaver）：生成针对性潜在记忆，分提示词 / 推理两阶段设计，支持 PEFT 高效微调。</li>
</ul>
</li>
<li><strong>核心流程闭环</strong>：输入 → 推理器生成原始嵌入 → 触发器 + 增强点选择模块确定插入位置 → 编织器生成潜在记忆 → 投影层适配维度 → 重组增强序列 → 推理器完成最终推理 → 过滤无效位置输出。</li>
<li><strong>关键技术细节</strong>：
<ul>
<li>跨模块投影：通过 <code>reasoner_to_weaver</code> 和 <code>weaver_to_reasoner</code> 解决推理器与编织器嵌入维度不匹配问题。</li>
<li>动态记忆增强：按分隔符拆分序列，逐段插入记忆，避免长序列冗余，贴合人类 “思考 - 记忆” 交互模式。</li>
<li>精度与效率：全流程采用 bfloat16 精度，推理器 / 编织器启用 Flash Attention 2，平衡性能与速度。</li>
</ul>
</li>
<li><strong>训练与推理适配</strong>：
<ul>
<li>训练时：通过 <code>labels</code> 和 <code>valid_logits</code> 计算损失，仅优化编织器、触发器及投影层参数。</li>
<li>推理时：无需 <code>labels</code>，自动完成 “触发判断 - 记忆生成 - 推理增强” 全流程，实现动态自进化。</li>
</ul>
</li>
</ol>
<p>具体网络结构如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fedf1bee4f404d00b60b5ade066b5dd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=udJwW4ZcYOdkSaA%2FuS5q7k6%2FUAc%3D" alt="MemGen-1.png" loading="lazy"/></p>
<h5 data-id="heading-7">2.1.3 代码</h5>
<p>LatentMemoryModel 的代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@registry.register_model(<span class="hljs-params"><span class="hljs-string">"latmem"</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LatentMemoryModel</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):  <span class="hljs-comment"># 定义了一个名为 LatentMemoryModel 的类，继承自 BaseModel</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">
        self, 
        reasoner_model_name: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 推理模型名称</span>
        weaver_model_name: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 记忆编织器模型名称</span>
        prompt_latents_len: <span class="hljs-built_in">int</span>,  <span class="hljs-comment"># 提示长度</span>
        inference_latents_len: <span class="hljs-built_in">int</span>,  <span class="hljs-comment"># 推理长度</span>
        weaver_peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 记忆编织器配置，可选</span>
        trigger_model_name: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 触发模型名称，可选</span>
        trigger_peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 触发器配置，可选</span>
        max_prompt_aug_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,  <span class="hljs-comment"># 最大提示增强数量</span>
        max_inference_aug_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span>,  <span class="hljs-comment"># 最大推理增强数量</span>
    </span>):   
        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类构造函数</span>

        <span class="hljs-comment"># 构建推理模型</span>
        self.model = AutoModelForCausalLM.from_pretrained(  <span class="hljs-comment"># 从预训练模型加载推理模型</span>
            reasoner_model_name, torch_dtype=torch.bfloat16, attn_implementation=<span class="hljs-string">"flash_attention_2"</span>)
        self.tokenizer = AutoTokenizer.from_pretrained(reasoner_model_name)  <span class="hljs-comment"># 加载入分词器</span>
        self.config = self.model.config  <span class="hljs-comment"># 获取模型配置</span>
        
        <span class="hljs-comment"># 构建记忆编织器</span>
        self.weaver = MemGenWeaver(  <span class="hljs-comment"># 初始化记忆编织器</span>
            weaver_model_name, prompt_latents_len, inference_latents_len, weaver_peft_config
        )
        
        <span class="hljs-comment"># 构建触发器</span>
        self.trigger = NanoTrigger()  <span class="hljs-comment"># 默认触发器，始终返回 true</span>
        <span class="hljs-keyword">if</span> trigger_model_name <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.trigger = MemGenTrigger(  <span class="hljs-comment"># 如果指定了触发模型，则加载相应的触发器</span>
                trigger_model_name, trigger_peft_config
            )
            logging.info(<span class="hljs-string">f"Use Trigger: <span class="hljs-subst">{trigger_model_name}</span>"</span>)  <span class="hljs-comment"># 记录日志</span>
        
        <span class="hljs-comment"># 投影层，用于在推理模型和记忆编织器之间映射嵌入</span>
        <span class="hljs-comment"># 将推理模型输入嵌入映射到记忆编织器输入嵌入</span>
        self.reasoner_to_weaver = nn.Linear(  <span class="hljs-comment"># 线性层，从推理模型隐藏层到记忆编织器隐藏层</span>
            self.model.config.hidden_size, self.weaver.config.hidden_size, dtype=torch.bfloat16
        )
        <span class="hljs-comment"># 将记忆编织器隐藏状态映射回推理模型输入嵌入</span>
        self.weaver_to_reasoner = nn.Linear(  <span class="hljs-comment"># 线性层，从记忆编织器隐藏层到推理模型隐藏层</span>
            self.weaver.config.hidden_size, self.model.config.hidden_size, dtype=torch.bfloat16
        )
        
        self.delimiters: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = [<span class="hljs-string">","</span>, <span class="hljs-string">"."</span>, <span class="hljs-string">"\n"</span>]  <span class="hljs-comment"># 用于检测增强点的分隔符</span>
        self.max_prompt_aug_num = max_prompt_aug_num  <span class="hljs-comment"># 提示后提示中插入潜在数量</span>
        self.max_inference_aug_num = max_inference_aug_num  <span class="hljs-comment"># 指定分隔符后插入潜在数量</span>

        <span class="hljs-comment"># 后处理</span>
        self._postprocess_models()  <span class="hljs-comment"># 后处理模型</span>

        self.warnings_issued = {}  <span class="hljs-comment"># 存储发出的警告</span>
        self.model_tags = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 存储模型标签</span>
        log_trainable_params(self)  <span class="hljs-comment"># 记录可训练参数</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_model_tags</span>(<span class="hljs-params">self, tags: <span class="hljs-type">Union</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 添加模型标签</span>
        <span class="hljs-string">r"""
        向模型添加自定义标签，这些标签将被推送到 Hugging Face Hub。不会覆盖模型中现有的标签。

        参数：
            tags (`Union[list[str], str]`)：
                要添加到模型的标签

        例子：

        ```python
        from transformers import AutoModel

        model = AutoModel.from_pretrained("google-bert/bert-base-cased")

        model.add_model_tags(["custom", "custom-bert"])

        # 将模型推送到您的命名空间，名称为 "my-custom-bert"。
        model.push_to_hub("my-custom-bert")
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(tags, <span class="hljs-built_in">str</span>):
            tags = [tags]

        <span class="hljs-keyword">if</span> self.model_tags <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.model_tags = []

        <span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> tags:
            <span class="hljs-keyword">if</span> tag <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.model_tags:
                self.model_tags.append(tag)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_postprocess_models</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""
        后处理记忆模型的组件：推理模型、记忆编织器、触发器和分词器。

        步骤：
            1. 冻结推理模型的所有参数（不更新梯度）。
            2. 将所有模型转换为 bfloat16 以提高内存和计算效率。
            3. 确保分词器有一个有效的填充符：
                - 如果缺少填充符，使用 EOS 符作为填充符。
                - 设置 `padding_side` 为 "left" 以兼容生成任务。
            4. 标准化分词器的模板为 `CONVERSATION_TEMPLATE`。
        """</span>
        <span class="hljs-comment"># 默认冻结推理模型的所有参数</span>
        fix_model_parameters(self.model)

        <span class="hljs-comment"># 将所有子模型转换为 bfloat16</span>
        self.model = self.model.bfloat16()
        self.weaver = self.weaver.bfloat16()
        self.trigger = self.trigger.bfloat16()

        <span class="hljs-comment"># 确保分词器有一个填充符</span>
        <span class="hljs-keyword">if</span> self.tokenizer.pad_token <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.tokenizer.pad_token = self.tokenizer.eos_token
            self.tokenizer.pad_token_id = self.tokenizer.eos_token_id
            self.tokenizer.padding_side = <span class="hljs-string">"left"</span>
            logging.info(
                <span class="hljs-string">f"Tokenizer has no pad token. Using EOS token (<span class="hljs-subst">{self.tokenizer.eos_token}</span>) as pad token."</span>
            )

        <span class="hljs-comment"># 标准化分词器的模板</span>
        self.tokenizer.chat_template = CONVERSATION_TEMPLATE
</code></pre>
<h5 data-id="heading-8">2.1.4 插入阶段</h5>
<p>LatentMemoryModel 的两个关键函数 forward 和  generate 区别如下：</p>
<ul>
<li>forward 函数
<ul>
<li>训练时候计算损失，由训练循环自动调用。</li>
</ul>
</li>
<li>generate 函数
<ul>
<li>推理时候生成文本，由代码显式调用。</li>
</ul>
</li>
</ul>
<h6 data-id="heading-9">forward</h6>
<p>forward 函数的主体如下：</p>
<pre><code class="hljs language-python" lang="python">    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_forward</span>(<span class="hljs-params">
        self, 
        input_ids: torch.Tensor,
        attention_mask: torch.Tensor,
        labels: torch.Tensor,   
        **kwargs
    </span>) -&gt; torch.Tensor:
        <span class="hljs-comment"># 预处理输入</span>
        <span class="hljs-keyword">assert</span> input_ids.shape == attention_mask.shape == labels.shape
        
        tokenizer = self.tokenizer
        reasoner = self.model
        weaver = self.weaver
        delimiters = self.delimiters
        max_augment_num = self.max_inference_aug_num  <span class="hljs-comment"># 限制推理增强点的数量以避免过度增强</span>
        device = self.device
        embeds_dtype = reasoner.get_input_embeddings().weight.dtype
        B, _ = input_ids.shape
        hidden_size = reasoner.config.hidden_size

        <span class="hljs-comment"># 选择增强索引</span>
        augmentation_indices = self._select_augment_points_after_delimiter(
            input_ids, labels, delimiters, tokenizer, max_augment_num
        )
        
        <span class="hljs-comment"># 输入嵌入</span>
        inputs_embeds = reasoner.get_input_embeddings()(input_ids)
                 
        <span class="hljs-comment"># 初始化开始索引和空张量以累积处理的段</span>
        current_start_idx = <span class="hljs-number">0</span>
        current_inputs_embeds = torch.empty(B, <span class="hljs-number">0</span>, hidden_size).to(device, dtype=embeds_dtype)
        current_attention_mask = torch.empty(B, <span class="hljs-number">0</span>).to(device, dtype=attention_mask.dtype)
        current_latents_mask = torch.empty(B, <span class="hljs-number">0</span>).to(device, dtype=torch.<span class="hljs-built_in">bool</span>)

        <span class="hljs-comment"># 遍历所选增强点</span>
        <span class="hljs-keyword">for</span> aug_idx <span class="hljs-keyword">in</span> augmentation_indices:
            <span class="hljs-comment"># 切片原始嵌入和注意力掩码</span>
            segment_inputs_embeds = inputs_embeds[:, current_start:aug_idx]
            segment_attention_mask = attention_mask[:, current_start:aug_idx]
            segment_latents_mask = torch.zeros(B, segment_inputs_embeds.size(<span class="hljs-number">1</span>).to(device, dtype=torch.<span class="hljs-built_in">bool</span>)

            <span class="hljs-comment"># 连接当前段到累积嵌入和掩码</span>
            current_inputs_embeds = torch.cat([current_inputs_embeds, segment_inputs_embeds], dim=<span class="hljs-number">1</span>)
            current_mask = torch.cat([current_mask, segment_attention_mask], dim=<span class="hljs-number">1</span>)
            current_position_ids = generate_position_ids(current_mask)
            current_latents = torch.cat([current_latents, segment_latents], dim=<span class="hljs-number">1</span>)

            <span class="hljs-comment"># 将推理模型嵌入映射到记忆编织器嵌入</span>
            weaver_inputs_embeds = self.reasoner_to_weaver(current_inputs_embeds)

            <span class="hljs-comment"># 确定此点是否为提示（增强）的结束</span>
            is_prompt_end_aug = (labels[:, aug_idx] != -<span class="hljs-number">100</span>).<span class="hljs-built_in">all</span>() <span class="hljs-keyword">and</span> (labels[:, aug_idx-<span class="hljs-number">1</span>] == -<span class="hljs-number">100</span>).<span class="hljs-built_in">all</span>().item()
            <span class="hljs-comment"># 根据类型，使用记忆编织器增强提示或推理</span>
            <span class="hljs-keyword">if</span> is_prompt_end_aug:
                weaver_hidden_states, attn_mask, pos_ids = weaver.augment_prompt(
                    weaver_inputs, current_attention_mask, current_position_ids
                )
            <span class="hljs-keyword">else</span>:
                weaver_hidden_states, attn_mask, pos_ids = weaver.augment_inference(
                    weaver_inputs, current_attention_mask, current_position_ids
                ) 

            <span class="hljs-comment"># 将记忆编织器隐藏状态映射回推理模型嵌入</span>
            latent_inputs_embeds = self.weaver_to_reasoner(weaver_hidden_states)

            <span class="hljs-comment"># 更新累积嵌入和掩码与新增强段</span>
            current_inputs_embeds = torch.cat
</code></pre>
<h6 data-id="heading-10">generate</h6>
<h6 data-id="heading-11">核心作用</h6>
<p>该 <code>generate</code> 方法是 MemGen 模型的推理核心，实现了<strong>动态记忆增强与序列生成的无缝融合</strong>。通过迭代生成新 token，每步自适应判断是否插入编织器生成的潜在记忆，让推理器在生成过程中实时利用动态记忆调整解码路径，最终输出增强后的序列（可选返回记忆增强位置掩码）。</p>
<h6 data-id="heading-12">核心特色</h6>
<ul>
<li><strong>双阶段记忆增强</strong>：先执行提示词阶段记忆增强（初始化全局记忆），再在迭代生成中动态触发推理阶段增强（补充实时记忆），适配不同生成阶段的记忆需求。</li>
<li><strong>自适应触发机制</strong>：通过 <code>_should_augment</code> 结合触发器决策，仅对需要记忆支持的序列执行增强，避免无意义的计算开销。</li>
<li><strong>维度对齐优化</strong>：非增强序列采用左填充（<code>_left_pad</code>）方式对齐增强序列维度，确保批次内所有序列格式统一，不影响批量生成效率。</li>
<li>高效推理设计：
<ul>
<li>禁用梯度计算（<code>@torch.no_grad()</code>），节省内存并加速推理；</li>
<li>启用推理器缓存（<code>use_cache=True</code>），减少重复计算；</li>
<li>仅在必要时输出隐藏状态，降低计算成本。</li>
</ul>
</li>
<li><strong>灵活配置与可解释性</strong>：支持控制最大生成 token 数、采样策略等参数；可选返回 <code>augmentation_pos</code> 掩码，标记记忆插入位置，提升模型可解释性。</li>
<li><strong>鲁棒性保障</strong>：提前终止机制（所有序列生成 EOS 或达最大增强次数时终止），避免无效迭代；重构生成配置固定关键参数，确保生成稳定性。</li>
</ul>
<h6 data-id="heading-13">推理生成流程图</h6>
<p>潜在记忆插入的完整流程：</p>
<ul>
<li>初始化阶段：对输入提示进行增强，插入初始潜在记忆。</li>
<li>生成循环：逐个生成token。</li>
<li>条件检查：在每个步骤检查是否满足插入条件。</li>
<li>决策判断：使用trigger模型决定是否插入潜在记忆。</li>
<li>潜在记忆生成：通过weaver模型生成潜在记忆表示。</li>
<li>嵌入连接：将潜在记忆嵌入连接到当前输入序列。</li>
<li>继续生成：使用增强后的序列继续生成下一个token。</li>
</ul>
<p>具体流程如下图所示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51a1177007e14bdd916d4e2ea501c2c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=aylwPhRKpttlymB%2BFRIe5TqKJmg%3D" alt="MemGen-2.png" loading="lazy"/></p>
<p>代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@torch.no_grad()  </span><span class="hljs-comment"># 禁用梯度计算，适用于推理阶段，提升效率并节省内存</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">
    self, 
    input_ids: torch.Tensor,  <span class="hljs-comment"># 输入token ID序列，形状[batch_size, prompt_len]</span>
    attention_mask: torch.Tensor,  <span class="hljs-comment"># 注意力掩码，形状与input_ids一致</span>
    generation_config: GenerationConfig = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 生成配置（如最大新token数、采样策略等）</span>
    return_augmentation_mask: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,  <span class="hljs-comment"># 是否返回记忆增强位置掩码</span>
    **kwargs
</span>) -&gt; <span class="hljs-type">Union</span>[torch.Tensor, <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor]]: 
    <span class="hljs-string">"""
    执行MemGen模型的推理生成流程：动态融合潜在记忆与推理器，生成增强后的输出序列。
    
    核心逻辑：
    1. 初始化提示词阶段的记忆增强
    2. 迭代生成新token，每步判断是否触发推理阶段记忆增强
    3. 对需增强的序列插入编织器生成的潜在记忆，非增强序列左填充对齐维度
    4. 生成完成后返回结果（可选返回增强位置掩码）
    """</span>
    tokenizer = self.tokenizer
    reasoner = self.model
    weaver = self.weaver
    trigger = self.trigger
    delimiters = self.delimiters
    max_augment_num = self.max_inference_aug_num  <span class="hljs-comment"># 单序列最大推理阶段增强次数</span>
    invalid_token_id = -<span class="hljs-number">100</span>  <span class="hljs-comment"># 无效位置标记（用于增强位置掩码）</span>

    <span class="hljs-comment"># 预处理输入：转移到模型所在设备</span>
    input_ids = input_ids.to(self.device)
    attention_mask = attention_mask.to(self.device)
    <span class="hljs-comment"># 提取生成配置关键参数</span>
    max_new_tokens = generation_config.max_new_tokens  <span class="hljs-comment"># 最大生成新token数</span>
    do_sample = generation_config.do_sample  <span class="hljs-comment"># 是否启用采样生成</span>
    temperature = generation_config.temperature  <span class="hljs-comment"># 采样温度（控制随机性）</span>
    pad_token_id = tokenizer.pad_token_id  <span class="hljs-comment"># pad token ID</span>
    eos_token_id = tokenizer.eos_token_id  <span class="hljs-comment"># 结束token ID</span>
    prompt_len = input_ids.size(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 提示词长度</span>
    <span class="hljs-comment"># 重构生成配置（固定必要参数，确保生成稳定性）</span>
    generation_config = GenerationConfig(
        do_sample=do_sample,
        temperature=temperature,
        pad_token_id=pad_token_id,
        eos_token_id=eos_token_id,
        use_cache=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 启用缓存加速生成</span>
    )

    <span class="hljs-comment"># 将输入token ID转换为嵌入向量</span>
    inputs_embeds = reasoner.get_input_embeddings()(input_ids)
    B, _, hidden_size = inputs_embeds.shape  <span class="hljs-comment"># B=batch_size，hidden_size=推理器隐藏层维度</span>
    device = inputs_embeds.device  <span class="hljs-comment"># 模型所在设备（CPU/GPU）</span>

    <span class="hljs-comment"># 初始化生成过程中的关键张量</span>
    current_inputs_embeds = inputs_embeds  <span class="hljs-comment"># 当前输入嵌入（含原始提示词+潜在记忆）</span>
    current_attention_mask = attention_mask  <span class="hljs-comment"># 当前注意力掩码</span>
    current_position_ids = generate_position_ids(current_attention_mask)  <span class="hljs-comment"># 当前位置ID</span>
    current_input_ids = input_ids  <span class="hljs-comment"># 当前已生成的token ID序列</span>
    
    <span class="hljs-comment"># 提示词阶段记忆增强：生成并插入提示词专用潜在记忆</span>
    weaver_inputs_embeds = self.reasoner_to_weaver(current_inputs_embeds)  <span class="hljs-comment"># 映射到编织器嵌入空间</span>
    weaver_hidden_states, attn_mask, pos_ids = weaver.augment_prompt(
        weaver_inputs_embeds, current_attention_mask, current_position_ids
    )
    latent_inputs_embeds = self.weaver_to_reasoner(weaver_hidden_states)  <span class="hljs-comment"># 映射回推理器嵌入空间</span>

    <span class="hljs-comment"># 拼接提示词与增强记忆</span>
    current_inputs_embeds = torch.cat([current_inputs_embeds, latent_inputs_embeds], dim=<span class="hljs-number">1</span>)
    current_attention_mask = torch.cat([current_attention_mask, attn_mask], dim=<span class="hljs-number">1</span>)
    current_position_ids = torch.cat([current_position_ids, pos_ids], dim=<span class="hljs-number">1</span>)

    <span class="hljs-comment"># 生成循环初始化</span>
    sentence_augment_count = torch.zeros(B, dtype=torch.<span class="hljs-built_in">int</span>, device=device)  <span class="hljs-comment"># 各序列已增强次数</span>
    augmentation_pos = torch.full((B, max_new_tokens), fill_value=invalid_token_id, device=device)  <span class="hljs-comment"># 增强位置掩码</span>
    inserted_embeds: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[torch.Tensor]] = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(B)]  <span class="hljs-comment"># 记录插入的潜在记忆（用于后处理）</span>
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_new_tokens):
        <span class="hljs-comment"># 若所有序列均已生成EOS token，提前终止</span>
        <span class="hljs-keyword">if</span> (current_input_ids[:, -<span class="hljs-number">1</span>] == eos_token_id).<span class="hljs-built_in">all</span>():
            <span class="hljs-keyword">break</span>   

        <span class="hljs-comment"># 若所有序列均已达到最大增强次数，一次性生成剩余token</span>
        <span class="hljs-keyword">if</span> (sentence_augment_count &gt;= max_augment_num).<span class="hljs-built_in">all</span>():
            <span class="hljs-comment"># 调整剩余生成长度</span>
            generation_config.max_new_tokens = max_new_tokens - i
            <span class="hljs-comment"># 推理器生成剩余token</span>
            generated = reasoner.generate(
                inputs_embeds=current_inputs_embeds,
                attention_mask=current_attention_mask,
                generation_config=generation_config,
            )
            current_input_ids = torch.cat([current_input_ids, generated], dim=<span class="hljs-number">1</span>)
            <span class="hljs-keyword">break</span>

        <span class="hljs-comment"># 推理器前向传播，获取当前步输出</span>
        outputs = reasoner(
            inputs_embeds=current_inputs_embeds,
            attention_mask=current_attention_mask,
            position_ids=current_position_ids,
            output_hidden_states=<span class="hljs-literal">False</span>,  <span class="hljs-comment"># 推理阶段无需输出隐藏状态，提升效率</span>
        )
        <span class="hljs-comment"># 生成并追加一个新token，更新关键张量</span>
        current_inputs_embeds, current_attention_mask, current_position_ids, current_input_ids = self._append_one_step(
            outputs, current_inputs_embeds, current_attention_mask, current_position_ids, current_input_ids, do_sample, temperature
        )
 
        <span class="hljs-comment"># 若为最后一步生成，终止循环</span>
        <span class="hljs-keyword">if</span> i == max_new_tokens - <span class="hljs-number">1</span>:  
            <span class="hljs-keyword">break</span> 

        <span class="hljs-comment"># 判断当前批次中哪些序列需要进行推理阶段记忆增强</span>
        augment_decision = self._should_augment(
            current_input_ids, current_attention_mask, sentence_augment_count=sentence_augment_count, 
            do_sample=do_sample, temperature=temperature  
        )
        augmentation_pos[:, i + <span class="hljs-number">1</span>] = augment_decision  <span class="hljs-comment"># 记录增强位置（1=增强，0=不增强，-100=无效）</span>
        augment_indices = torch.where(augment_decision == <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 需增强的序列索引</span>

        <span class="hljs-comment"># 对需增强的序列执行记忆增强，非增强序列左填充对齐维度</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(augment_indices) &gt; <span class="hljs-number">0</span>:
            <span class="hljs-comment"># 递增需增强序列的增强次数计数</span>
            sentence_augment_count[augment_indices] += <span class="hljs-number">1</span>

            <span class="hljs-comment"># 提取需增强序列的嵌入、掩码和位置ID</span>
            candidate_inputs_embeds = current_inputs_embeds[augment_indices]
            candidate_attention_mask = current_attention_mask[augment_indices]
            candidate_position_ids = current_position_ids[augment_indices]
            
            <span class="hljs-comment"># 编织器生成推理阶段潜在记忆</span>
            weaver_inputs_embeds = self.reasoner_to_weaver(candidate_inputs_embeds)
            weaver_hidden_states, attn_mask, _ = weaver.augment_inference(
                weaver_inputs_embeds, candidate_attention_mask, candidate_position_ids
            )
            latent_inputs_embeds = self.weaver_to_reasoner(weaver_hidden_states)  <span class="hljs-comment"># 映射回推理器空间</span>
            
            <span class="hljs-comment"># 拼接原始嵌入与潜在记忆</span>
            candidate_inputs_embeds = torch.cat([candidate_inputs_embeds, latent_inputs_embeds], dim=<span class="hljs-number">1</span>)
            candidate_attention_mask = torch.cat([candidate_attention_mask, attn_mask], dim=<span class="hljs-number">1</span>)
            
            <span class="hljs-comment"># 构建合并张量（适配所有序列，包括增强和非增强）</span>
            new_len = candidate_inputs_embeds.size(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 增强后序列长度</span>
            merged_inputs_embeds = torch.zeros((B, new_len, hidden_size), device=device, dtype=current_inputs_embeds.dtype)
            merged_attention_mask = torch.zeros((B, new_len), device=device, dtype=current_attention_mask.dtype)
            
            <span class="hljs-comment"># 填充增强序列</span>
            merged_inputs_embeds[augment_indices] = candidate_inputs_embeds
            merged_attention_mask[augment_indices] = candidate_attention_mask
            
            <span class="hljs-comment"># 填充非增强序列（左填充对齐长度）</span>
            non_augment_indices = torch.where(augment_decision != <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(non_augment_indices) &gt; <span class="hljs-number">0</span>:
                non_aug_inputs_embeds = current_inputs_embeds[non_augment_indices]
                non_aug_attention_mask = current_attention_mask[non_augment_indices]
                non_aug_inputs_embeds, non_aug_attention_mask, _ = self._left_pad(
                    non_aug_inputs_embeds, non_aug_attention_mask, <span class="hljs-literal">None</span>, weaver.inference_latents_num
                )
                merged_inputs_embeds[non_augment_indices] = non_aug_inputs_embeds
                merged_attention_mask[non_augment_indices] = non_aug_attention_mask
            
            <span class="hljs-comment"># 更新当前关键张量</span>
            current_inputs_embeds = merged_inputs_embeds
            current_attention_mask = merged_attention_mask
            current_position_ids = generate_position_ids(current_attention_mask)  <span class="hljs-comment"># 重新生成位置ID</span>
            
            <span class="hljs-comment"># 记录插入的潜在记忆（用于后处理或可解释性分析）</span>
            <span class="hljs-keyword">for</span> idx, embed <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(augment_indices, latent_inputs_embeds):
                inserted_embeds[idx].append(embed.clone().detach().cpu())
        
        <span class="hljs-comment"># 后处理：调整增强位置掩码长度与生成结果一致</span>
        new_generated_len = current_input_ids.size(<span class="hljs-number">1</span>) - prompt_len
        augmentation_pos = augmentation_pos[:, :new_generated_len]
         
        <span class="hljs-comment"># 根据配置返回结果：仅生成序列 或 序列+增强位置掩码</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> return_augmentation_mask:
            <span class="hljs-keyword">return</span> current_input_ids
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> current_input_ids, augmentation_pos
</code></pre>
<h4 data-id="heading-14">2.2 Trigger</h4>
<h5 data-id="heading-15">2.2.1. 核心作用</h5>
<p>该模块定义了 MemGen 框架中记忆触发器的核心接口与两种具体实现，核心作用是<strong>动态决策记忆增强的时机</strong>—— 即在推理过程中判断何时插入编织器生成的潜在记忆，实现记忆与推理的动态耦合，突破传统静态记忆注入的局限。</p>
<h5 data-id="heading-16">2.2.2. 核心特色</h5>
<ul>
<li><strong>抽象接口统一规范</strong>：<code>Trigger</code>抽象基类定义了触发器的核心接口，确保后续扩展新触发器时遵循统一标准，提升代码可扩展性。</li>
<li>双实现适配不同场景：
<ul>
<li><code>NanoTrigger</code>：极简实现，始终触发记忆增强，无需训练，适用于快速测试、基线对比或无需动态控制的简单场景。</li>
<li><code>MemGenTrigger</code>：基于预训练 LLM 的智能触发器，通过二分类头适配决策任务，支持 PEFT 参数高效微调，能根据输入序列动态判断是否触发，适配复杂真实场景。</li>
</ul>
</li>
<li>高效适配与灵活扩展：
<ul>
<li>采用 bfloat16 精度和 Flash Attention 2 优化计算效率；</li>
<li>支持 PEFT 微调，在不冻结基础模型的前提下实现参数高效学习；</li>
<li>替换 LLM 原始输出头为二分类头，精准适配 "是否插入记忆" 的决策需求。</li>
</ul>
</li>
<li><strong>模块解耦设计</strong>：触发器决策独立于编织器模块，仅基于输入序列和数据分布做出判断，保证了模块间的低耦合和高内聚。</li>
</ul>
<h5 data-id="heading-17">2.2.3 网络架构</h5>
<p>网络架构图如下。</p>
<p>说明如下：</p>
<ol>
<li>模型支持PEFT参数高效微调（如LoRA），适配于Transformer Blocks层</li>
<li>整体精度采用bfloat16，平衡计算效率与数值稳定性</li>
<li>注意力计算通过Flash Attention 2优化，提升长序列处理速度</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34dd418dca1746b69160336bafae5e6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=Av9etmryf2cwP7Mw6AaiNNc%2FzO4%3D" alt="MemGen-3.png" loading="lazy"/></p>
<h5 data-id="heading-18">2.2.4 代码</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trigger</span>(torch.nn.Module, ABC):
    <span class="hljs-string">"""
    记忆触发器的抽象基类（Trigger）。
    定义了触发器的核心接口，用于决定在推理过程中何时触发记忆增强（插入潜在记忆）。
    所有具体触发器实现都需继承此类并实现forward方法。
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类Module的初始化方法</span>
    
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, **kwargs</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""
        抽象前向传播方法：接收输入数据，返回是否触发记忆增强的决策。
        子类必须实现此方法，定义具体的触发逻辑。
        
        Args:
            **kwargs: 可变关键字参数，包含输入序列、注意力掩码等模型所需数据
            
        Returns:
            bool: 触发决策（True表示触发记忆增强，False表示不触发）
        """</span>
        ...


<span class="hljs-keyword">class</span> <span class="hljs-title class_">NanoTrigger</span>(torch.nn.Module):
    <span class="hljs-string">"""
    极简触发器（NanoTrigger）：始终触发记忆增强的基础实现。
    无需复杂逻辑，固定返回触发决策，适用于基础测试或无需动态控制的场景。
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()  
        <span class="hljs-comment"># 注册一个缓冲区张量，用于获取模型所在设备（无实际计算意义）</span>
        self.register_buffer(<span class="hljs-string">"_device"</span>, torch.tensor(<span class="hljs-number">0.0</span>))
    
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">device</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""获取模型所在设备（CPU/GPU）"""</span>
        <span class="hljs-keyword">return</span> self._device.device
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_ids: torch.Tensor, attention_mask: torch.Tensor, **kwargs</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-comment"># 该"极简触发器"始终预测需要插入记忆</span>
        <span class="hljs-comment"># 输出logits张量，其中插入决策（索引=1）的概率被设为1.0</span>
        <span class="hljs-comment"># 适用于批次中的每个token位置</span>
        batch_size, seq_len = input_ids.shape

        <span class="hljs-comment"># 初始化logits张量：形状为[batch_size, seq_len, 2]，2表示"不插入"（0）和"插入"（1）两类</span>
        logits = torch.zeros(batch_size, seq_len, <span class="hljs-number">2</span>, device=input_ids.device)
        logits[..., <span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 将所有位置的"插入"决策概率设为1.0</span>
        <span class="hljs-keyword">return</span> logits


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemGenTrigger</span>(torch.nn.Module):
    <span class="hljs-string">"""
    MemGen框架的专用触发器模块（MemGenTrigger）。
    - 输入：接收推理器模型当前解码序列的`inputs_embeds`（或input_ids）
    - 输出：生成形状为[batch_size, seq_len, 2]的logits张量，
      表示每个位置"不插入"（0）和"插入"（1）记忆的概率，用于动态决策记忆增强时机。
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">
        self, 
        pretrained_model_name_or_path: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 预训练模型名称或路径（用于初始化触发器LLM）</span>
        peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># PEFT配置（可选，用于参数高效微调）</span>
    </span>):
        <span class="hljs-built_in">super</span>().__init__()
        
        <span class="hljs-comment"># 构建基础LLM模型（作为触发器的核心推理组件）</span>
        self.model = AutoModelForCausalLM.from_pretrained(
            pretrained_model_name_or_path, 
            torch_dtype=torch.bfloat16,  <span class="hljs-comment"># 使用bfloat16精度提升效率</span>
            attn_implementation=<span class="hljs-string">"flash_attention_2"</span>  <span class="hljs-comment"># 启用Flash Attention 2优化注意力计算</span>
        )
        self.tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path)  <span class="hljs-comment"># 对应的Tokenizer</span>
        
        <span class="hljs-comment"># 对基础模型进行后处理（设置可训练、替换输出头）</span>
        self.model = self._postprocess(self.model)
        <span class="hljs-comment"># 若提供PEFT配置，应用参数高效微调</span>
        <span class="hljs-keyword">if</span> peft_config <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.model = get_peft_model(self.model, peft_config)
        
        self.config = self.model.config  <span class="hljs-comment"># 保存模型配置</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">device</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""获取模型所在设备（CPU/GPU）"""</span>
        <span class="hljs-keyword">return</span> self.model.device
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_postprocess</span>(<span class="hljs-params">self, model: PreTrainedModel</span>):
        <span class="hljs-string">"""
        对基础模型进行后处理，适配触发器的二分类任务需求。
        
        Args:
            model: 原始预训练LLM模型
            
        Returns:
            处理后的模型（可训练、替换为二分类输出头）
        """</span>
        <span class="hljs-comment"># 设置所有模型参数为可训练</span>
        <span class="hljs-keyword">for</span> parameter <span class="hljs-keyword">in</span> model.parameters():
            parameter.requires_grad = <span class="hljs-literal">True</span>
        
        <span class="hljs-comment"># 将原始语言模型的输出头（lm_head）替换为二分类头</span>
        hidden_size = model.config.hidden_size  <span class="hljs-comment"># 模型隐藏层维度</span>
        classification_head = nn.Linear(hidden_size, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 输出维度为2（不插入/插入）</span>
        model.lm_head = classification_head
        
        <span class="hljs-comment"># 确保新的二分类头参数可训练</span>
        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.lm_head.parameters():
            param.requires_grad = <span class="hljs-literal">True</span>

        <span class="hljs-keyword">return</span> model

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">
        self, 
        input_ids: <span class="hljs-type">Optional</span>[torch.LongTensor] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 生成序列的token ID，形状[batch_size, seq_len]</span>
        attention_mask: <span class="hljs-type">Optional</span>[torch.Tensor] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 注意力掩码，避免关注填充token</span>
        **kwargs: Unpack[TransformersKwargs],  <span class="hljs-comment"># 传递给底层模型的额外参数</span>
    </span>) -&gt; torch.Tensor:
        <span class="hljs-string">"""
        序列生成的触发决策机制。
        触发器基于已生成的`input_ids`做出决策，受数据分布影响，但独立于编织器模块。

        Args:
            input_ids (Optional[torch.LongTensor]): 生成序列的token ID张量
            attention_mask (Optional[torch.Tensor]): 注意力掩码，默认None
            **kwargs: 传递给底层模型的额外关键字参数

        Returns:
            torch.Tensor: Logits张量，形状为`(batch_size, seq_len, num_classes)`
                        num_classes=2，分别对应"不插入"（索引0）和"插入"（索引1）的概率
        """</span>   
        <span class="hljs-comment"># 调用基础模型前向传播，返回二分类logits</span>
        <span class="hljs-keyword">return</span> self.model(
            input_ids=input_ids, 
            attention_mask=attention_mask, 
            **kwargs
        ).logits
</code></pre>
<h4 data-id="heading-19">2.3  MemGenWeaver</h4>
<h5 data-id="heading-20">2.3.1 核心作用</h5>
<p>MemGenWeaver 是 MemGen 框架的核心组件之一，负责生成动态潜在记忆并将其与推理器的输入序列融合，从而实现记忆与推理过程的无缝交织。它通过可学习的潜在记忆查询向量，在提示词阶段和推理阶段分别生成针对性的记忆表示，引导推理器调整解码路径，提升智能体的动态决策能力。</p>
<h5 data-id="heading-21">2.3.2 核心特色</h5>
<ul>
<li>双阶段记忆生成：区分提示词阶段（<code>augment_prompt</code>）和推理阶段（<code>augment_inference</code>），使用各自独立的可学习潜在记忆查询向量，适配不同阶段的记忆需求，增强记忆生成的针对性。</li>
<li>灵活的潜在记忆融合：通过<code>_augment</code>方法统一实现潜在记忆与输入序列的融合，包括嵌入拼接、注意力掩码扩展和位置 ID 计算，确保记忆与原始输入在语义空间和时序上的一致性。</li>
<li>高效的模型设计：
<ul>
<li>基于预训练 LLM 构建，支持 PEFT 参数高效微调，在保留基础能力的同时降低训练成本；</li>
<li>采用 bfloat16 精度和 Flash Attention 2 优化，提升计算效率和内存利用率。</li>
</ul>
</li>
<li>动态记忆编织机制：生成的潜在记忆并非静态检索结果，而是基于当前输入序列动态生成的隐藏状态，能够捕捉实时上下文信息，实现 “生成式记忆” 的核心特性。</li>
<li>模块化与可扩展性：与推理器、触发器解耦，通过标准化接口交互；潜在记忆的数量可通过参数灵活配置，适配不同任务对记忆容量的需求。</li>
</ul>
<h5 data-id="heading-22">2.3.3 网络架构</h5>
<p>网络架构图如下。</p>
<p>说明如下：</p>
<ol>
<li>
<p>核心组件：</p>
<ul>
<li>可学习潜在记忆向量：分阶段设计（P=提示词阶段数量，I=推理阶段数量），支持动态生成记忆</li>
<li>预训练LLM：作为记忆生成核心，默认启用bfloat16精度和Flash Attention 2优化</li>
<li>序列融合层：确保输入与记忆在语义、掩码、时序上的一致性</li>
</ul>
</li>
<li>
<p>核心流程：</p>
<ul>
<li>输入 → 选择对应阶段的潜在记忆 → 融合序列 → LLM生成隐藏状态 → 提取潜在记忆输出</li>
<li>支持PEFT参数高效微调（如LoRA），适配于Transformer Blocks层</li>
</ul>
</li>
<li>
<p>输出用途：</p>
<ul>
<li>生成的潜在记忆将通过投影层映射到推理器的嵌入空间，与原始输入融合以引导解码</li>
</ul>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/171332decb0c4154ba66ca9f7de013db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=MkDfTVSJzZAmLMpyyKdipXchpbw%3D" alt="MemGen-4.png" loading="lazy"/></p>
<h5 data-id="heading-23">2.3.4 代码</h5>
<p>两个关键变量如下：</p>
<ul>
<li>prompt_query_latents。
<ul>
<li>作用：增强模型在处理prompt时候的表现。 在模型处理完原始提示之后会被注入到序列中，为模型提供额外的上下文信息。</li>
<li>使用场景：在 augment_prompt 方法中使用，在生成阶段的开始阶段使用一次。</li>
</ul>
</li>
<li>inference_query_latents。
<ul>
<li>作用：在生成过程中动态增强模型的推理能力。可以在生成过程中的多个点被注入，以提供实时上下文增强。</li>
<li>使用场景：在 augment_inference 方法中使用，在生成阶段中多次被使用。通常在遇到特定分隔符（逗号，句号等）后触发插入。</li>
</ul>
</li>
</ul>
<p>这两个变量都通过_augment 方法获得（获取学习到的潜在向量，并将其附加到输入嵌入中）。其流程如下：</p>
<ul>
<li>将潜在变量附加到当前输入嵌入序列的末尾。</li>
<li>更新注意力掩码和位置ID，以考虑新增的潜在向量。</li>
<li>将增强后的序列通过Weaver模型处理。</li>
<li>提供于潜在向量位置对应的隐状态作为增强表示。</li>
</ul>
<p>判断是否插入是通过函数 _should_augment 完成的。</p>
<ul>
<li>检查当前生成的文本是否是特殊字符（逗号等）</li>
<li>使用触发模型（trigger model）进一步判断是否应该增强。</li>
<li>考虑最大增强次数限制。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemGenWeaver</span>(torch.nn.Module):
    <span class="hljs-string">"""
    MemGen模型的编织器模块（MemGenWeaver）。
    - 输入：接收接收来自推理器模型当前当前解码序列的`inputs_embeds`（输入嵌入入）
    - 输出：生成长度为K的隐藏状态序列，
这些状态将与原始`inputs_embeds`拼接，以改变推理器的解码路径
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">
        self, 
        pretrained_model_name_or_path: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 预训练模型的名称或路径</span>
        prompt_latents_num: <span class="hljs-built_in">int</span>,    <span class="hljs-comment"># 提示词阶段生成的潜在记忆数量</span>
        inference_latents_num: <span class="hljs-built_in">int</span>, <span class="hljs-comment"># 推理阶段生成的潜在记忆数量</span>
        peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># PEFT配置（可选）</span>
    </span>):
        <span class="hljs-built_in">super</span>().__init__()
        
        <span class="hljs-comment"># 基础模型初始化</span>
        self.model = AutoModelForCausalLM.from_pretrained(
            pretrained_model_name_or_path,
            torch_dtype=torch.bfloat16,  <span class="hljs-comment"># 使用bfloat16精度以提高效率</span>
            attn_implementation=<span class="hljs-string">"flash_attention_2"</span>  <span class="hljs-comment"># 启用Flash Attentionention 2优化</span>
        )
        self.tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path)  <span class="hljs-comment"># 对应的分词器</span>
        <span class="hljs-comment"># 若提供PEFT配置，则应用参数高效微调</span>
        <span class="hljs-keyword">if</span> peft_config <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.model = get_peft_model(self.model, peft_config)
        
        self.config = self.model.config  <span class="hljs-comment"># 保存模型配置</span>
        
        <span class="hljs-comment"># 提示词阶段的潜在记忆查询向量（可学习参数）</span>
        self.prompt_query_latents = nn.Parameter(
            torch.randn(prompt_latents_num, self.config.hidden_size),  <span class="hljs-comment"># 形状：[prompt_latents_num, hidden_size]</span>
            requires_grad=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 允许反向传播更新</span>
        )

        <span class="hljs-comment"># 推理阶段的潜在记忆查询向量（可学习参数）</span>
        self.inference_query_latents = nn.Parameter(
            torch.randn(inference_latents_num, self.config.hidden_size),  <span class="hljs-comment"># 形状：[inference_latents_num, hidden_size]</span>
            requires_grad=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 允许反向传播更新</span>
        )
    
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prompt_latents_num</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">"""返回提示词阶段的潜在记忆数量"""</span>
        <span class="hljs-keyword">return</span> self.prompt_query_latents.size(<span class="hljs-number">0</span>)

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inference_latents_num</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">"""返回推理阶段的潜在记忆数量"""</span>
        <span class="hljs-keyword">return</span> self.inference_query_latents.size(<span class="hljs-number">0</span>)

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">device</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""返回模型所在的设备（CPU/GPU）"""</span>
        <span class="hljs-keyword">return</span> self.model.device

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_augment</span>(<span class="hljs-params">
        self, 
        latents: torch.Tensor,                <span class="hljs-comment"># 潜在记忆查询向量，形状：[latents_num, hidden_size]</span>
        inputs_embeds: torch.Tensor,          <span class="hljs-comment"># 输入嵌入，形状：[batch_size, seq_len, hidden_size]</span>
        attention_mask: torch.Tensor,         <span class="hljs-comment"># 注意力掩码，形状：[batch_size, seq_len]</span>
        position_ids: torch.Tensor            <span class="hljs-comment"># 位置ID，形状：[batch_size, seq_len]</span>
    </span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor, torch.Tensor]:
        <span class="hljs-string">"""
        通用的潜在记忆增强方法：将潜在记忆与输入序列融合，生成增强后的隐藏状态。
        
        参数：
            latents: 潜在记忆查询向量
            inputs_embeds: 输入序列的嵌入表示
            attention_mask: 输入序列的注意力掩码
            position_ids: 输入序列的位置ID
        
        返回：
            三元组 (latents_hidden_states, latents_mask, latents_position_ids)
            - latents_hidden_states: 生成的潜在记忆隐藏状态，形状：[batch_size, latents_num, hidden_size]
            - latents_mask: 潜在记忆的注意力掩码，形状：[batch_size, latents_num]
            - latents_position_ids: 潜在记忆的位置ID，形状：[batch_size, latents_num]
        """</span>
        batch_size = attention_mask.shape[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取批次大小</span>
        latents_num = latents.size(<span class="hljs-number">0</span>)         <span class="hljs-comment"># 获取潜在记忆数量</span>
        
        <span class="hljs-comment"># 扩展潜在记忆维度以匹配批次大小：[1, latents_num, hidden_size] → [batch_size, latents_num, hidden_size]</span>
        latents = latents.unsqueeze(<span class="hljs-number">0</span>).repeat(batch_size, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
        
        <span class="hljs-comment"># 将潜在记忆嵌入与输入嵌入拼接：[batch_size, seq_len + latents_num, hidden_size]</span>
        inputs_embeds = torch.cat([inputs_embeds, latents], dim=<span class="hljs-number">1</span>)

        <span class="hljs-comment"># 构建潜在记忆的注意力掩码（全为1，表示有效）并与输入掩码拼接</span>
        latents_mask = torch.ones(latents.shape[:-<span class="hljs-number">1</span>], dtype=attention_mask.dtype, device=attention_mask.device)
        attention_mask = torch.cat([attention_mask, latents_mask], dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 形状：[batch_size, seq_len + latents_num]</span>
        
        <span class="hljs-comment"># 生成潜在记忆的位置ID（在输入序列最后位置的基础上递增）</span>
        last_position_ids = position_ids.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取输入序列的最大位置ID</span>
        latents_relative_positions = torch.arange(latents_num, device=attention_mask.device)  <span class="hljs-comment"># 潜在记忆的相对位置</span>
        <span class="hljs-comment"># 计算绝对位置：输入序列最大位置 + 相对位置 + 1（避免重叠）</span>
        latents_position_ids = last_position_ids.unsqueeze(<span class="hljs-number">1</span>) + latents_relative_positions + <span class="hljs-number">1</span>
        <span class="hljs-comment"># 拼接位置ID：[batch_size, seq_len + latents_num]</span>
        position_ids = torch.cat([position_ids.long(), latents_position_ids.long()], dim=<span class="hljs-number">1</span>) 

        <span class="hljs-comment"># 验证拼接后的维度是否一致</span>
        <span class="hljs-keyword">assert</span> inputs_embeds.shape[:<span class="hljs-number">2</span>] == attention_mask.shape == position_ids.shape

        <span class="hljs-comment"># 模型前向传播，获取隐藏状态</span>
        outputs = self.model(
            inputs_embeds=inputs_embeds,
            attention_mask=attention_mask,
            position_ids=position_ids,  
            output_hidden_states=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 输出所有层的隐藏状态</span>
        )
        <span class="hljs-comment"># 取最后一层的隐藏状态，并提取潜在记忆部分（序列末尾的latents_num个位置）</span>
        hidden_states = outputs.hidden_states[-<span class="hljs-number">1</span>]
        latents_hidden_states = hidden_states[:, -latents_num:, :]

        <span class="hljs-keyword">return</span> latents_hidden_states, latents_mask, latents_position_ids

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">augment_prompt</span>(<span class="hljs-params">
        self, 
        inputs_embeds: torch.Tensor, 
        attention_mask: torch.Tensor, 
        position_ids: torch.Tensor
    </span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor, torch.Tensor]:
        <span class="hljs-string">"""
        提示词阶段的潜在记忆增强：使用提示词专用的潜在记忆查询向量。
        
        参数与返回值同_augment方法
        """</span>
        <span class="hljs-keyword">return</span> self._augment(
            latents=self.prompt_query_latents,
            inputs_embeds=inputs_embeds,
            attention_mask=attention_mask,
            position_ids=position_ids
        )


    <span class="hljs-keyword">def</span> <span class="hljs-title function_">augment_inference</span>(<span class="hljs-params">
        self, 
        inputs_embeds: torch.Tensor, 
        attention_mask: torch.Tensor, 
        position_ids: torch.Tensor
    </span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor, torch.Tensor]:
        <span class="hljs-string">"""
        推理阶段的潜在记忆增强：使用推理专用的潜在记忆查询向量。
        
        参数与返回值同_augment方法
        """</span>
        <span class="hljs-keyword">return</span> self._augment(
            latents=self.inference_query_latents,
            inputs_embeds=inputs_embeds,
            attention_mask=attention_mask,
            position_ids=position_ids
        )
</code></pre>
<h3 data-id="heading-24">0xFF 参考</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FpqCPoUw0p2oTsnMUj9t2mw" target="_blank" title="https://mp.weixin.qq.com/s/pqCPoUw0p2oTsnMUj9t2mw" ref="nofollow noopener noreferrer">最新成果！Agent记忆的第三种可能：生成式隐式记忆</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring AI 实战——评估生成结果]]></title>    <link>https://juejin.cn/post/7570901172526858275</link>    <guid>https://juejin.cn/post/7570901172526858275</guid>    <pubDate>2025-11-10T09:40:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526858275" data-draft-id="7570866247980187700" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring AI 实战——评估生成结果"/> <meta itemprop="keywords" content="Spring,AI编程,LLM"/> <meta itemprop="datePublished" content="2025-11-10T09:40:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="数据智能老司机"/> <meta itemprop="url" content="https://juejin.cn/user/430664289626439"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring AI 实战——评估生成结果
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664289626439/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    数据智能老司机
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:40:14.000Z" title="Mon Nov 10 2025 09:40:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">本章内容</h2>
<ul>
<li>初识 Spring AI 的评估器（evaluators）</li>
<li>检查相关性（relevancy）</li>
<li>判断回答的正确性（correctness）</li>
<li>在运行时应用评估器</li>
</ul>
<p>为你的代码编写测试是一种重要实践。自动化测试不仅能确保应用没有被破坏，还能提供有助于设计与实现的反馈。对应用中的<strong>生成式 AI 组件</strong>进行测试，丝毫不比其他部分的测试不重要。</p>
<p>只有一个问题：如果你把相同的提示多次发送给一个 LLM，你很可能每次都会得到不同的答案。生成式 AI 的<strong>非确定性</strong>意味着测试中无法采用“断言相等（assert equals）”的套路。</p>
<p>在第 1 章里，你看到如何使用 <strong>WireMock</strong> 来模拟 API 的响应，从而在测试中获得<strong>确定性的</strong>结果。这种测试方式非常适合测试“围绕向生成式 AI API 发起请求”的代码，但它并不能测试<strong>提示本身</strong>以及模型如何对该提示作出响应。幸运的是，Spring AI 提供了另一种判断“生成响应是否可接受”的方式：<strong>评估器（Evaluators）</strong> 。</p>
<p>一个<strong>评估器</strong>会拿到提交给 LLM 的提示中的用户文本，以及模型返回的内容，然后据此判断这份响应内容是否通过某些准则。从内部机制看，评估器可以用任何适合其评估类型的方式实现。但如图 2.1 所示，评估器通常会**借助一个 LLM（通过 ChatClient）**来判断生成的响应与所提交提示之间的契合度。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f81731ace774ceb9bf9b4be09adc02b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763372413&amp;x-signature=y30vXdbCZqbHl%2FEgAco4CH6BmiA%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 2.1</strong> Spring AI 评估器把提示与生成的响应一并发送给 LLM，以评估响应质量。</p>
<p>接下来我们看看如何使用评估器，为 <strong>BoardGameService</strong>（Board Game Buddy 应用中使用生成式 AI 的那个组件）编写一份<strong>集成测试</strong>。</p>
<h2 data-id="heading-1">2.1 确保答案相关（Ensuring relevant answers）</h2>
<p>最基础的评估形式，就是判断 LLM 是否回答了<strong>所提的问题</strong>。也就是：生成的响应<strong>至少与提示同一话题</strong>吗？</p>
<p>例如，用户问 “Why is the sky blue?”，LLM 回答 “Because of Rayleigh scattering”（或类似回答），那么这个答案是<strong>相关的</strong>。反之，若 LLM 回答 “The moon is approximately 239,900 miles from Earth.”，尽管它可能是正确事实，但<strong>与天空为何是蓝色</strong>这一问题<strong>不相关</strong>。</p>
<p>判断答案是否与给定问题相关，正是 Spring AI 的 <strong>RelevancyEvaluator</strong> 要做的事。为了理解它如何工作，让我们用它来为 <strong>BoardGameService</strong> 写一个测试。下面的清单展示了该测试类。</p>
<p><strong>清单 2.1 测试 LLM 的响应是否与问题相关</strong></p>
<pre><code class="hljs language-typescript" lang="typescript">package com.<span class="hljs-property">example</span>.<span class="hljs-property">boardgamebuddy</span>;

<span class="hljs-keyword">import</span> org.<span class="hljs-property">assertj</span>.<span class="hljs-property">core</span>.<span class="hljs-property">api</span>.<span class="hljs-property">Assertions</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">junit</span>.<span class="hljs-property">jupiter</span>.<span class="hljs-property">api</span>.<span class="hljs-property">BeforeEach</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">junit</span>.<span class="hljs-property">jupiter</span>.<span class="hljs-property">api</span>.<span class="hljs-property">Test</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">chat</span>.<span class="hljs-property">client</span>.<span class="hljs-property">ChatClient</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">chat</span>.<span class="hljs-property">evaluation</span>.<span class="hljs-property">RelevancyEvaluator</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">evaluation</span>.<span class="hljs-property">EvaluationRequest</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">evaluation</span>.<span class="hljs-property">EvaluationResponse</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">test</span>.<span class="hljs-property">context</span>.<span class="hljs-property">SpringBootTest</span>;

<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameServiceTests</span> {

  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title class_">BoardGameService</span> boardGameService;

  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title class_">ChatClient</span>.<span class="hljs-property">Builder</span> chatClientBuilder;

  <span class="hljs-keyword">private</span> <span class="hljs-title class_">RelevancyEvaluator</span> relevancyEvaluator;

  <span class="hljs-meta">@BeforeEach</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">relevancyEvaluator</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelevancyEvaluator</span>(chatClientBuilder);
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">evaluateRelevancy</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">String</span> userText = <span class="hljs-string">"Why is the sky blue?"</span>;
    <span class="hljs-title class_">Question</span> question = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Question</span>(userText);
    <span class="hljs-title class_">Answer</span> answer = boardGameService.<span class="hljs-title function_">askQuestion</span>(question);

    <span class="hljs-title class_">EvaluationRequest</span> evaluationRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvaluationRequest</span>(
        userText, answer.<span class="hljs-title function_">answer</span>());

    <span class="hljs-title class_">EvaluationResponse</span> response = relevancyEvaluator
        .evaluate(evaluationRequest);

    <span class="hljs-title class_">Assertions</span>.<span class="hljs-title function_">assertThat</span>(response.<span class="hljs-title function_">isPass</span>())
        .<span class="hljs-title function_">withFailMessage</span>(<span class="hljs-string">""</span><span class="hljs-string">"
          ========================================
          The answer "</span>%s<span class="hljs-string">"
          is not considered relevant to the question
          "</span>%s<span class="hljs-string">".
          ========================================
          "</span><span class="hljs-string">""</span>, answer.<span class="hljs-title function_">answer</span>(), userText)
        .<span class="hljs-title function_">isTrue</span>();
  }

}
</code></pre>
<p>阅读 <code>SpringAiBoardGameServiceTests</code> 可以看到，测试前几行在做<strong>评估所需的准备</strong>。类上标注了 <code>@SpringBootTest</code>，表明这是<strong>集成测试</strong>：会创建一个 Spring 应用上下文（包含应用中的所有 bean）。从该上下文中，通过 <code>@Autowired</code> 注入了 <code>BoardGameService</code> 与 <code>ChatClient.Builder</code>。随后在 <code>setup()</code> 方法里，用 <code>ChatClient.Builder</code> 创建了一个 <code>RelevancyEvaluator</code>，以供测试方法使用。</p>
<p><code>evaluateRelevancy()</code> 测试方法首先创建一个 <code>Question</code>，并将其发送给注入的 <code>BoardGameService#askQuestion()</code> 来获得 <code>Answer</code>。接着用原始用户文本与答案创建 <code>EvaluationRequest</code>，传给 <code>RelevancyEvaluator#evaluate()</code>。其内部会向 LLM 发送一个提示，要求它判断<strong>答案与问题的相关性</strong>。</p>
<p><code>evaluate()</code> 返回 <code>EvaluationResponse</code>，随后调用 <code>isPass()</code> 判断评估是否通过。若返回 <code>true</code>，说明答案被认为与问题相关；否则返回 <code>false</code>，表示不相关，断言失败。</p>
<p>有了这个测试，你就能<strong>快速、自动</strong>检查：通过 <code>SpringAiBoardGameService#askQuestion()</code> 提出的一个问题是否得到<strong>契合话题</strong>的回答。当然，<strong>相关</strong>并不等于<strong>正确</strong>。我们再把测试提升一档，检查答案是否<strong>正确</strong>。</p>
<h2 data-id="heading-2">2.2 测试事实正确性（Testing for factual accuracy）</h2>
<p>假设当被问到“天空为什么是蓝色”时，LLM 回答：“The sky is blue because there are a gazillion tiny bubbles filled with blueberry jam floating in the atmosphere.”（天空之所以蓝，是因为大气中漂浮着无数装满蓝莓酱的小气泡。）这个回答看起来<strong>相关</strong>，但显然<strong>不正确</strong>。它也许能“躲过” <code>RelevancyEvaluator</code> 的法眼，但并不适合直接展示给你的用户。</p>
<p>Spring AI 的 <strong>FactCheckingEvaluator</strong> 与 <code>RelevancyEvaluator</code> 类似，但它不是让 LLM 判断<strong>相关性</strong>，而是让 LLM 判断这个回答是否<strong>正确地回答</strong>了问题。</p>
<p>在把事实正确性测试加进 <code>SpringAiBoardGameServiceTests</code> 之前，需要稍微调整一下 <code>setup()</code> 方法，创建一个 <code>FactCheckingEvaluator</code> 并赋给实例变量：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">FactCheckingEvaluator</span> factCheckingEvaluator;

  <span class="hljs-meta">@BeforeEach</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">relevancyEvaluator</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelevancyEvaluator</span>(chatClientBuilder);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">factCheckingEvaluator</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactCheckingEvaluator</span>(
        chatClientBuilder);
  }
</code></pre>
<p>现在编写事实核查测试方法：</p>
<pre><code class="hljs language-ini" lang="ini">@Test
  public void evaluateFactualAccuracy() {
    var <span class="hljs-attr">userText</span> = <span class="hljs-string">"Why is the sky blue?"</span><span class="hljs-comment">;</span>
    var <span class="hljs-attr">question</span> = new Question(userText)<span class="hljs-comment">;</span>
    var <span class="hljs-attr">answer</span> = boardGameService.askQuestion(question)<span class="hljs-comment">;</span>

    var <span class="hljs-attr">evaluationRequest</span> =
            new EvaluationRequest(userText, answer.answer())<span class="hljs-comment">;</span>

    var <span class="hljs-attr">response</span> =
            factCheckingEvaluator.evaluate(evaluationRequest)<span class="hljs-comment">;</span>

    Assertions.assertThat(response.isPass())
        .withFailMessage("<span class="hljs-attr">""</span>

          ========================================
          The answer "%s"
          is not considered correct for the question
          "%s".
          ========================================
          """, answer.answer(), userText)
        .isTrue()<span class="hljs-comment">;</span>
  }
</code></pre>
<p><code>evaluateFactualAccuracy()</code> 与之前的 <code>evaluateRelevancy()</code> 很相似。与相关性测试一样，仍然通过 <code>EvaluationResponse#isPass()</code> 进行断言：若生成的答案被判定为<strong>不正确</strong>，断言就会失败。</p>
<p>当 <code>isPass()</code> 返回 <code>false</code> 导致断言失败时，失败信息会解释原因。举例来说，如果生成的答案是 “There are tiny bubbles filled with blueberry jam high in the atmosphere.”，那么 <code>FactCheckingEvaluator</code> 会判定该回答<strong>不正确</strong>，断言失败，输出的失败信息可能如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">========================================
The answer <span class="hljs-string">"The sky is blue because there are a gazillion tiny bubbles filled
with blueberry jam floating in the atmosphere."</span>
<span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> considered correct <span class="hljs-keyword">for</span> the question
<span class="hljs-string">"Why is the sky blue?"</span>.
========================================
</code></pre>
<p>在通读本书的过程中，你会对<strong>发送给 LLM 的提示</strong>做出许多改动。借助 <code>evaluateRelevancy()</code> 与 <code>evaluateFactualAccuracy()</code> 这样的测试，你可以确保：<strong>无论提示如何调整</strong>，依然能获得<strong>恰当且正确</strong>的回答。</p>
<p>即便如此，还有一点可能不那么显而易见：你也许会希望在<strong>测试之外（运行时）<strong>使用评估器，以确保实际运行中返回给用户的回答同样</strong>相关</strong>且<strong>正确</strong>。接下来我们看看如何在应用代码中<strong>直接应用评估器</strong>。</p>
<h2 data-id="heading-3">2.3 在运行时应用自评估（Applying self-evaluation at runtime）</h2>
<p>即使在构建应用时基于评估器的测试全部通过，<strong>运行时</strong>仍可能出现<strong>不相关</strong>或<strong>不正确</strong>的回答。生成式 AI 的<strong>非确定性</strong>意味着：测试阶段也许“运气不错”拿到了好回答，但到生产环境时情况却可能“跑偏”。在运行时应用评估器，可以帮助避免把糟糕答案返回给应用用户。</p>
<p>事实证明，评估器并<strong>不限于</strong>用于集成测试。下面的清单展示了如何把 <strong>RelevancyEvaluator</strong> 与 <strong>Spring Retry</strong> 结合，避免返回与用户问题<strong>不相关</strong>的答案。</p>
<p><strong>清单 2.2 在运行时代码中校验相关性（Verifying relevancy in runtime code）</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.evaluation.RelevancyEvaluator;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.prompt.ChatOptions;
<span class="hljs-keyword">import</span> org.springframework.ai.evaluation.EvaluationRequest;
<span class="hljs-keyword">import</span> org.springframework.ai.evaluation.EvaluationResponse;
<span class="hljs-keyword">import</span> org.springframework.retry.annotation.Recover;
<span class="hljs-keyword">import</span> org.springframework.retry.annotation.Retryable;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfEvaluatingBoardGameService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RelevancyEvaluator evaluator;

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SelfEvaluatingBoardGameService</span><span class="hljs-params">(ChatClient.Builder chatClientBuilder)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">chatOptions</span> <span class="hljs-operator">=</span> ChatOptions.builder()
        .model(<span class="hljs-string">"gpt-4o-mini"</span>)
        .build();

    <span class="hljs-built_in">this</span>.chatClient = chatClientBuilder
        .defaultOptions(chatOptions)
        .build();

    <span class="hljs-built_in">this</span>.evaluator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelevancyEvaluator</span>(chatClientBuilder);
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-meta">@Retryable(retryFor = AnswerNotRelevantException.class)</span>
  <span class="hljs-keyword">public</span> Answer <span class="hljs-title function_">askQuestion</span><span class="hljs-params">(Question question)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">answerText</span> <span class="hljs-operator">=</span> chatClient.prompt()
        .user(question.question())
        .call()
        .content();

    evaluateRelevancy(question, answerText);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(answerText);
  }

  <span class="hljs-meta">@Recover</span>
  <span class="hljs-keyword">public</span> Answer <span class="hljs-title function_">recover</span><span class="hljs-params">(AnswerNotRelevantException e)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(<span class="hljs-string">"I'm sorry, I wasn't able to answer the question."</span>);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">evaluateRelevancy</span><span class="hljs-params">(Question question, String answerText)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">evaluationRequest</span> <span class="hljs-operator">=</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvaluationRequest</span>(question.question(), answerText);
    <span class="hljs-type">var</span> <span class="hljs-variable">evaluationResponse</span> <span class="hljs-operator">=</span> evaluator.evaluate(evaluationRequest);
    <span class="hljs-keyword">if</span> (!evaluationResponse.isPass()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnswerNotRelevantException</span>(question.question(), answerText);
    }
  }

}
</code></pre>
<p><code>SelfEvaluatingBoardGameService</code> 与 <code>SpringAiBoardGameService</code> 很相似，只是 <code>askQuestion()</code> 方法上添加了 <code>@Retryable</code> 注解。这个来自 <strong>Spring Retry</strong> 的注解表示：如果该方法抛出了 <code>AnswerNotRelevantException</code>，则<strong>重试</strong>该方法。</p>
<p>在 <code>askQuestion()</code> 中，会调用 <code>evaluateRelevancy()</code> 来进行相关性评估。<code>evaluateRelevancy()</code> 使用构造器里创建的 <code>RelevancyEvaluator</code>。若 <code>isPass()</code> 返回 <code>false</code>，<code>evaluateRelevancy()</code> 会抛出 <code>AnswerNotRelevantException</code>，该异常向外传播至 <code>askQuestion()</code>，从而触发重试。</p>
<p>至于 <code>AnswerNotRelevantException</code>，它是一个简单的<strong>非受检</strong>异常，类似如下：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnswerNotRelevantException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>{
    public <span class="hljs-type">AnswerNotRelevantException</span>(<span class="hljs-type">String</span> question, <span class="hljs-type">String</span> answer) {
        <span class="hljs-keyword">super</span>(<span class="hljs-string">"The answer '"</span> + answer + <span class="hljs-string">"' is not relevant to the question '"</span> + question + <span class="hljs-string">"'."</span>);
    }
}
</code></pre>
<p>默认情况下，带有 <code>@Retryable</code> 的方法会<strong>最多重试三次</strong>。你可以通过 <code>maxAttempts</code> 属性进行调整。例如，将重试上限设为 5 次：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@Retryable(<span class="hljs-params">retryFor = AnswerNotRelevantException.<span class="hljs-keyword">class</span>, maxAttempts=<span class="hljs-number">5</span></span>)</span>
</code></pre>
<p>尽管可以通过 <code>maxAttempts</code> 增加重试次数，但要注意：每次重试都意味着对 <strong>LLM</strong> 多发送一次提示，同时评估器也会反复向 LLM 发送评估提示。这会<strong>增加费用</strong>（因为在得到相关答案前可能发送了更多 token），并且如果在短时间内连续发送同样的提示，也可能触发<strong>限流</strong>。因此把 <code>maxAttempts</code> 设得较低可以避免这些问题。</p>
<p>如果在三次（或你通过 <code>maxAttempts</code> 指定的次数）尝试后仍未生成相关答案，控制流程会进入 <code>recover()</code> 方法。<code>recover()</code> 用 <code>@Recover</code> 注解标注，是 Spring Retry 提供的<strong>兜底</strong>机制：当重试持续失败时调用。在 <code>SelfEvaluatingBoardGameService</code> 中，<code>recover()</code> 只是返回一个表示<strong>无法回答</strong>的 <code>Answer</code>。</p>
<p>关于 Spring AI 的评估器，还有最后一点：虽然开箱即用的只有 <code>RelevancyEvaluator</code> 与 <code>FactCheckingEvaluator</code>，但它们都是基于 Spring AI 的如下 <strong>Evaluator</strong> 接口构建的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> org.springframework.ai.evaluation;

<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.stream.Collectors;

<span class="hljs-keyword">import</span> org.springframework.ai.document.Document;
<span class="hljs-keyword">import</span> org.springframework.util.StringUtils;

<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Evaluator</span> {

    EvaluationResponse <span class="hljs-title function_">evaluate</span><span class="hljs-params">(EvaluationRequest evaluationRequest)</span>;

    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">doGetSupportingData</span><span class="hljs-params">(EvaluationRequest evaluationRequest)</span> {
        List&lt;Document&gt; data = evaluationRequest.getDataList();
        <span class="hljs-keyword">return</span> data.stream()
            .map(Document::getText)
            .filter(StringUtils::hasText)
            .collect(Collectors.joining(System.lineSeparator()));
    }

}
</code></pre>
<p>若 <code>RelevancyEvaluator</code> 或 <code>FactCheckingEvaluator</code> <strong>不能满足</strong>你的评估需求，你可以实现 <code>Evaluator</code> 接口<strong>自定义评估器</strong>。</p>
<h2 data-id="heading-4">小结（Summary）</h2>
<ul>
<li>生成式 AI 的<strong>非确定性</strong>使测试变得棘手。</li>
<li>Spring AI 提供<strong>评估器</strong>，可用于对生成的响应进行<strong>断言</strong>。</li>
<li>评估器通过向 LLM 发送提示，来判断响应的<strong>相关性</strong>与<strong>事实正确性</strong>。</li>
<li>评估器可在<strong>运行时</strong>应用；若返回不满意的结果，可以<strong>重试</strong>提示。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[线上python问题排查思路]]></title>    <link>https://juejin.cn/post/7570896170920951871</link>    <guid>https://juejin.cn/post/7570896170920951871</guid>    <pubDate>2025-11-10T10:02:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570896170920951871" data-draft-id="7570793903848407055" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="线上python问题排查思路"/> <meta itemprop="keywords" content="后端,Python"/> <meta itemprop="datePublished" content="2025-11-10T10:02:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沙虫一号"/> <meta itemprop="url" content="https://juejin.cn/user/4427059249293504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            线上python问题排查思路
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4427059249293504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沙虫一号
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:02:13.000Z" title="Mon Nov 10 2025 10:02:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>下面把检查线程阻塞和排查内存增长的工具与典型用法按要点列清楚。</p>
<h2 data-id="heading-0">线程阻塞与死锁排查</h2>
<ul>
<li>
<p>观测点：进程响应变慢或完全停滞，CPU/IO 异常或日志显示线程等待。</p>
</li>
<li>
<p>日志检查：抓取线程相关日志、异常堆栈、阻塞/等待信息。先定位时间窗口和可疑线程ID。</p>
</li>
<li>
<p>gdb（动态附加查看线程栈）</p>
</li>
</ul>
<p>用法要点：<code>gdb -p &lt;pid&gt;</code>，然后 <code>thread apply all bt</code> 查看每个线程的调用栈，定位互斥锁/等待点。</p>
<p>快速流程：附加 → 列出线程 → 对可疑线程打印 backtrace。</p>
<ul>
<li>strace（跟踪系统调用/阻塞在 syscall）</li>
</ul>
<p>用法要点：<code>strace -f -p &lt;pid&gt;</code> 或 <code>strace -ff -o out -p &lt;pid&gt;</code>。看是否在 futex、poll、read/write 等系统调用上长时间阻塞。</p>
<ul>
<li>综合策略：先从日志缩小时间段和线程；用 gdb 看 Python 层调用栈（若是 C 扩展或解释器死锁也能看出）；用 strace 判断是用户态等待还是系统调用层面阻塞。</li>
</ul>
<h2 data-id="heading-1">内存泄漏/内存增长排查</h2>
<ul>
<li>
<p>观测点：长期运行进程内存占用持续上涨，GC 后未回落，或 OOM 频繁。</p>
</li>
<li>
<p>监控：<code>top</code>/<code>ps</code>/<code>smem</code>/<code>pmap</code> 定期采样记录 RSS/VSZ。结合应用日志标记时间点。</p>
</li>
<li>
<p>tracemalloc（Python 标准库，跟踪内存分配地点）</p>
</li>
</ul>
<p>用法要点：</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">import</span> tracemalloc

tracemalloc.start()

<span class="hljs-comment"># 在关键点取快照</span>

snap1 = tracemalloc.take_snapshot()

<span class="hljs-comment"># 运行一段时间后</span>

snap2 = tracemalloc.take_snapshot()

stats = snap2.compare_to(snap1, <span class="hljs-string">'lineno'</span>)

<span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> stats[:<span class="hljs-number">20</span>]:

<span class="hljs-built_in">print</span>(stat)

</code></pre>
<p>能找出按文件行号分配增长最多的地方。</p>
<ul>
<li>objgraph（分析对象引用关系）</li>
</ul>
<p>用法要点：</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">import</span> objgraph

objgraph.show_most_common_types(limit=<span class="hljs-number">20</span>)

obj = objgraph.by_type(<span class="hljs-string">'YourTypeName'</span>)[:<span class="hljs-number">10</span>]

objgraph.show_backrefs(obj, max_depth=<span class="hljs-number">10</span>, filename=<span class="hljs-string">'leak.png'</span>)

</code></pre>
<p>用来发现哪些对象数量异常和它们的引用路径（可生成图片）。</p>
<ul>
<li>pympler（运行时内存概览与分配追踪）</li>
</ul>
<p>用法要点：</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">from</span> pympler <span class="hljs-keyword">import</span> muppy, summary

all_objs = muppy.get_objects()

<span class="hljs-built_in">print</span>(summary.summarize(all_objs))

</code></pre>
<p>可结合 <code>asizeof</code> 或 <code>tracker</code> 做更细粒度的分配追踪。</p>
<ul>
<li>实战流程建议：先用系统工具确认增长曲线 → 用 tracemalloc 找到热点分配位置 → 用 objgraph 可视化引用链确认根对象 → 用代码修复并验证（重复采样对比快照）。</li>
</ul>
<h2 data-id="heading-2">快速检查清单（按优先级）</h2>
<ol>
<li>
<p>采集日志与进程内存/线程快照。</p>
</li>
<li>
<p>若线程疑似阻塞，先 gdb 打栈，再用 strace 确认是 syscall 层阻塞。</p>
</li>
<li>
<p>若内存增长，先采样 RSS，再用 tracemalloc 定位分配源，最后用 objgraph 验证引用链。</p>
</li>
<li>
<p>修复后做回归采样对比快照。</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🧭 使用历史记录 API - SPA导航与状态管理的完整指南]]></title>    <link>https://juejin.cn/post/7570598043298758719</link>    <guid>https://juejin.cn/post/7570598043298758719</guid>    <pubDate>2025-11-10T10:08:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570598043298758719" data-draft-id="7570908785292951571" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🧭 使用历史记录 API - SPA导航与状态管理的完整指南"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T10:08:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Bug_Constructer"/> <meta itemprop="url" content="https://juejin.cn/user/254742426830856"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🧭 使用历史记录 API - SPA导航与状态管理的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/254742426830856/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Bug_Constructer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:08:35.000Z" title="Mon Nov 10 2025 10:08:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>🎯 <strong>学习目标</strong>：掌握 <code>pushState</code> / <code>replaceState</code> / <code>popstate</code> 的核心用法；在不刷新页面的情况下同步 URL 与 UI 状态；设计轻量、可序列化的 <code>state</code> 对象；为用户的前进/后退提供可控的导航体验。</p>
<p>📊 <strong>难度等级</strong>：初级-中级<br/>
🏷️ <strong>技术标签</strong>：<code>#WebAPI</code> <code>#HistoryAPI</code> <code>#SPA</code> <code>#路由</code><br/>
⏱️ <strong>阅读时间</strong>：约9分钟</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">🌟 引言</h2>
<p>在日常 SPA 开发中，你是否遇到过这些困扰：</p>
<ul>
<li>内容更新却不改变 URL，刷新或分享后无法到达当前视图</li>
<li>用户点击后退/前进导致状态丢失，体验不一致</li>
<li>页面刷新后无法恢复视图与数据，需重新操作</li>
<li>路由实现复杂，状态对象难以维护与序列化</li>
</ul>
<p>这篇文章围绕 History API，讲透如何无刷新地同步 URL 与状态，并提供经测试的最佳实践。</p>
<hr/>
<h2 data-id="heading-1">💡 核心技巧详解</h2>
<h3 data-id="heading-2">1. 无刷新导航封装：URL 与 UI 同步</h3>
<h4 data-id="heading-3">🔍 应用场景</h4>
<p>菜单切换、分页/筛选、可分享的视图定位。</p>
<h4 data-id="heading-4">❌ 常见问题</h4>
<p>只更新内容不更新 URL；未校验同源导致错误导航。</p>
<h4 data-id="heading-5">✅ 推荐方案</h4>
<p>统一封装导航函数，集中处理 <code>pushState</code> 与渲染。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 使用 History API 进行无刷新导航
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span> - 目标同源 URL（可包含查询参数）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{view:string, params?:Record&lt;string,string&gt;, scrollY?:number</span>}} state - 轻量页面状态
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">navigate</span> = (<span class="hljs-params">url, state</span>) =&gt; {
  <span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(url, <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>);
  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">origin</span> !== <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 同源校验</span>
  history.<span class="hljs-title function_">pushState</span>(state ?? {}, <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>, target.<span class="hljs-property">href</span>);
  <span class="hljs-title function_">renderFromState</span>(state ?? {});
};

<span class="hljs-comment">/**
 * 根据 state 渲染页面（视图与参数）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{view?:string, params?:Record&lt;string,string&gt;, scrollY?:number</span>}} state
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">renderFromState</span> = (<span class="hljs-params">state = {}</span>) =&gt; {
  <span class="hljs-keyword">const</span> view = state.<span class="hljs-property">view</span> || <span class="hljs-string">'home'</span>;
  <span class="hljs-keyword">const</span> params = state.<span class="hljs-property">params</span> || {};
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#app'</span>).<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'data-view'</span>, view);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#params'</span>).<span class="hljs-property">textContent</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params);
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>({ <span class="hljs-attr">top</span>: state.<span class="hljs-property">scrollY</span> ?? <span class="hljs-number">0</span>, <span class="hljs-attr">behavior</span>: <span class="hljs-string">'instant'</span> });
};
</code></pre>
<h4 data-id="heading-6">💡 核心要点</h4>
<ul>
<li><code>pushState</code> 不触发 <code>popstate</code>，需主动渲染当前视图</li>
<li>同源校验避免跨源导航错误</li>
<li>仅保存必要参数，保持状态轻量可序列化</li>
</ul>
<h4 data-id="heading-7">🎯 实际应用</h4>
<p>在导航点击事件中调用 <code>navigate</code>，实现无刷新路由与状态同步。</p>
<hr/>
<h3 data-id="heading-8">2. 初始化首条历史记录：避免回退丢失</h3>
<h4 data-id="heading-9">🔍 应用场景</h4>
<p>应用启动、直达链接、首次加载查询参数。</p>
<h4 data-id="heading-10">❌ 常见问题</h4>
<p>未设置初始条目，回退后无法正确恢复视图。</p>
<h4 data-id="heading-11">✅ 推荐方案</h4>
<p>用 <code>replaceState</code> 写入首条历史记录并渲染。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 用 replaceState 初始化首条历史记录
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">initHistoryState</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> state = {
    <span class="hljs-attr">view</span>: <span class="hljs-string">'home'</span>,
    <span class="hljs-attr">params</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(location.<span class="hljs-property">search</span>)),
    <span class="hljs-attr">scrollY</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>
  };
  history.<span class="hljs-title function_">replaceState</span>(state, <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>, location.<span class="hljs-property">href</span>);
  <span class="hljs-title function_">renderFromState</span>(state);
};
</code></pre>
<h4 data-id="heading-12">💡 核心要点</h4>
<ul>
<li><code>replaceState</code> 替换当前条目，避免生成多余历史记录</li>
<li>初始渲染从 URL 查询参数推导状态</li>
</ul>
<h4 data-id="heading-13">🎯 实际应用</h4>
<p>应用入口处调用 <code>initHistoryState</code>，保障后退/前进行为一致。</p>
<hr/>
<h3 data-id="heading-14">3. 监听 popstate：浏览器导航状态恢复</h3>
<h4 data-id="heading-15">🔍 应用场景</h4>
<p>用户使用浏览器后退/前进或 <code>history.go()</code>。</p>
<h4 data-id="heading-16">❌ 常见问题</h4>
<p>未监听 <code>popstate</code> 导致状态无法恢复，页面闪烁或重载。</p>
<h4 data-id="heading-17">✅ 推荐方案</h4>
<p>绑定 <code>popstate</code>，根据历史条目恢复 UI。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 绑定 popstate 事件以恢复 UI
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">bindPopState</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'popstate'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> state = e.<span class="hljs-property">state</span> || {};
    <span class="hljs-title function_">renderFromState</span>(state);
  });
};
</code></pre>
<h4 data-id="heading-18">💡 核心要点</h4>
<ul>
<li><code>popstate</code> 仅在用户导航或 <code>history.go()</code> 时触发</li>
<li>历史条目中的 <code>state</code> 应足以推导并渲染 UI</li>
</ul>
<h4 data-id="heading-19">🎯 实际应用</h4>
<p>应用启动后立即绑定，保证导航一致性。</p>
<hr/>
<h3 data-id="heading-20">4. 轻量状态对象：可序列化且可推导 UI</h3>
<h4 data-id="heading-21">🔍 应用场景</h4>
<p>分页、筛选、详情视图定位。</p>
<h4 data-id="heading-22">❌ 常见问题</h4>
<p>状态过度复杂，无法序列化或跨会话恢复。</p>
<h4 data-id="heading-23">✅ 推荐方案</h4>
<p>仅保存视图标识、查询参数与滚动位置。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 生成可序列化的轻量状态对象
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">view</span> - 视图标识
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Record&lt;string,string&gt;</span>} <span class="hljs-variable">params</span> - 查询参数
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">{view:string, params:Record&lt;string,string&gt;, scrollY:number</span>}}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">makeState</span> = (<span class="hljs-params">view, params = {}</span>) =&gt; ({
  view,
  params,
  <span class="hljs-attr">scrollY</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>
});
</code></pre>
<h4 data-id="heading-24">💡 核心要点</h4>
<ul>
<li>复杂对象转 ID 或可重建的引用</li>
<li>保持状态小而清晰，提升兼容与维护性</li>
</ul>
<h4 data-id="heading-25">🎯 实际应用</h4>
<p>与路由服务结合，统一生成并持久化轻量 <code>state</code>。</p>
<hr/>
<h2 data-id="heading-26">📊 技巧对比总结</h2>



































<table><thead><tr><th>技巧</th><th>使用场景</th><th>优势</th><th>注意事项</th></tr></thead><tbody><tr><td>无刷新导航封装</td><td>菜单切换、分页/筛选</td><td>URL 与 UI 同步、无刷新</td><td>同源校验、轻量状态</td></tr><tr><td>初始化首条记录</td><td>应用启动、直达链接</td><td>回退行为一致、可恢复</td><td>使用 replaceState</td></tr><tr><td>监听 popstate</td><td>后退/前进导航</td><td>状态恢复、体验一致</td><td>仅用户导航触发</td></tr><tr><td>轻量状态对象</td><td>分页、筛选、详情</td><td>可序列化、可推导 UI</td><td>复杂对象转 ID</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-27">🎯 实战应用建议</h2>
<h3 data-id="heading-28">最佳实践</h3>
<ol>
<li>将导航封装为服务模块，统一同源校验与状态构建</li>
<li>分享/收藏的场景更新 URL；内部微调可不产生历史条目</li>
<li>将分页/筛选写入查询串，便于直达同一视图</li>
<li>结合滚动位置与焦点管理，提升返回体验连贯性</li>
</ol>
<h3 data-id="heading-29">性能考虑</h3>
<ul>
<li>避免在 <code>popstate</code> 中做重计算，优先使用已保存的轻量状态</li>
<li>校验 URL 同源后再构建状态，减少异常与重渲染</li>
<li>必要时提供 Hash 降级兼容旧环境或跨源路径</li>
</ul>
<hr/>
<h2 data-id="heading-30">💡 总结</h2>
<p>这 4 个 History API 技巧能让 SPA 在不刷新页面的前提下实现“可导航、可恢复、可分享”的能力：</p>
<ol>
<li>无刷新导航封装：统一 <code>pushState</code> 与渲染</li>
<li>初始化首条历史记录：用 <code>replaceState</code> 保证回退一致</li>
<li>监听 <code>popstate</code>：用户导航时恢复 UI</li>
<li>轻量状态对象：仅保存必要信息，保持可序列化与可维护</li>
</ol>
<p>希望这些技巧能帮助你在 SPA 路由与状态管理中写出更优雅的代码！</p>
<hr/>
<h2 data-id="heading-31">🔗 相关资源</h2>
<ul>
<li>MDN（中文）：Working with the History API<br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FHistory_API%2FWorking_with_the_History_API" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API/Working_with_the_History_API" ref="nofollow noopener noreferrer">developer.mozilla.org/zh-CN/docs/…</a></li>
</ul>
<hr/>
<blockquote>
<p>💡 <strong>今日收获</strong>：掌握了History API的多个核心技巧，这些知识点在实际开发中非常实用。</p>
</blockquote>
<p><strong>如果这篇文章对你有帮助，欢迎点赞、收藏和分享！有任何问题也欢迎在评论区讨论。</strong> 🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[年处理约 1.4 万亿美元：从支付基础设施到 ACP 协议，拆解 Stripe 如何搭建AI智能体经济的商业标准？]]></title>    <link>https://juejin.cn/post/7570793903848521743</link>    <guid>https://juejin.cn/post/7570793903848521743</guid>    <pubDate>2025-11-10T10:02:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570793903848521743" data-draft-id="7570901172526956579" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="年处理约 1.4 万亿美元：从支付基础设施到 ACP 协议，拆解 Stripe 如何搭建AI智能体经济的商业标准？"/> <meta itemprop="keywords" content="产品经理"/> <meta itemprop="datePublished" content="2025-11-10T10:02:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="莫尔索"/> <meta itemprop="url" content="https://juejin.cn/user/518625218016504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            年处理约 1.4 万亿美元：从支付基础设施到 ACP 协议，拆解 Stripe 如何搭建AI智能体经济的商业标准？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/518625218016504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    莫尔索
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:02:36.000Z" title="Mon Nov 10 2025 10:02:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在这期播客中，Stripe（几乎所有出海产品都在用的全球性支付平台）的数据与 AI 负责人 Emily 深入探讨了 AI 如何从根本上重塑经济基础设施。AI 不仅在创造新的商业模式（如 Agent 服务商），也带来全新的经济挑战，特别是高昂的边际成本和新型欺诈。Stripe 正在通过扩展其反欺诈系统 (Radar)、<strong>推出 Token Billing（按推理时 token 计费）</strong> 等创新支付工具，以及与 OpenAI 联合发布 <strong>ACP (Agentic Commerce Protocol，代理式电商协议)</strong> 来应对这些挑战，旨在为即将到来的 AI Agent 经济建立一个开放、高效且安全的商业标准。</p>
</blockquote>
<p>欢迎订阅合集 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4221297752417992707%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FX1JwNWhO9tjVQfh9Qq9uJw%26nolastread%3D1%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4221297752417992707&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FX1JwNWhO9tjVQfh9Qq9uJw&amp;nolastread=1&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">AI 播客捕手</a>：专门面向文字内容爱好者分享 AI 领域优质播客，其他合集：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243230891033935893%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FZcMiAmfNkmYLDgAu0rlb1Q%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243230891033935893&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZcMiAmfNkmYLDgAu0rlb1Q&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 冷思考</a>：个人在 AI 狂欢下的冷思考，聚焦 AI 工程化、Agent Infra 产品、效率型 AI 工具和人机协作话题，寻找可持续的产业价值。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243205243418624006%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252F0Tdan3R8juUlj-Lh-QMmew%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243205243418624006&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0Tdan3R8juUlj-Lh-QMmew&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 博客精选</a>：精心编译海外技术厂商发布的高质量 AI 领域博客文章。</li>
</ul>
<h2 data-id="heading-0">目录</h2>
<ul>
<li>Stripe 的 AI 演进：从反欺诈到支付基础模型</li>
<li>AI 时代的经济挑战：高昂的边际成本与新型欺诈</li>
<li>为 AI 经济构建基础设施：从 Radar 扩展到支付创新</li>
<li>ACP：定义 AI Agent 的商业未来</li>
<li>AI 经济分析：泡沫还是繁荣？</li>
<li>个人思考</li>
</ul>
<h2 data-id="heading-1">Stripe 的 AI 演进：从反欺诈到支付基础模型</h2>
<p>Stripe 的使命是构建互联网的金融基础设施，作为数据与 AI 负责人，Emily 的职责是帮助 Stripe 有效利用其庞大的数据——每年处理约 1.4 万亿美元（占全球 GDP 约 1.3%）的交易量，这些数据不仅用于理解经济动态，更被反馈到产品中，以优化支付体验、减少欺诈、提高授权率。</p>
<p>Emily 领导的组织涵盖了从数据平台、机器学习基础设施到应用层的整个技术栈。其中一个特色是实验项目团队，这个小而精的团队专注于探索那些跨越单一产品线的、由用户需求拉动的从 0 到 1 的机会，近期的 ACP 和 Token Billing 项目均源于此团队。（编注：这个小团队约 20 多人，由数据部门主导，具备跨部门的数据获取权限，高效挖掘业务数据价值，将 AI 深度融入到企业业务模式和工作流程中，大企业试验性探索 AI 原生组织模式的有效思路）</p>
<p>谈到 AI 在 Stripe 的演进，Emily 指出，Stripe 使用 ML 的历史已超过十年，远早于当下的 AI 浪潮。最初，ML 被用于核心产品 Radar（Stripe 的欺诈检测系统）以及内部运营。Stripe 每天需要审核数千名新用户，确保他们的可支持性、信用价值和非欺诈性，这从一开始就离不开 ML。</p>
<p>真正的转变发生在 GPT-3.5 出现时，Stripe 意识到需要为所有人提供高质量、安全、易用的 LLM 访问权限，不仅是为日常工作，更是为了构建生产级的 AI 体验。在过去一年半中，Stripe 的策略从<strong>使用多个单任务、点解决方案的 ML 模型，转向构建自己特定领域的支付基础模型 (Foundation Model, FM)</strong> 。</p>
<p>这个基础模型在 Stripe 的支付处理中扮演着至关重要的角色，每分钟处理高达 50,000 笔交易，并且每一笔交易都会流经这个 FM 进行实时评估，延迟必须控制在 100 毫秒以内。FM 的强大之处在于它能处理所有事情——它被输入了数百亿笔交易的全部细节，而不像传统 ML 模型那样依赖人类工程师的手工特征工程。</p>
<p>更关键的是，<strong>FM 引入了序列的概念，将支付数据类比为语言数据。一个支付行为就像一个词，其意义取决于上下文（即周围的词）。FM 能够捕捉到复杂的序列模式，例如某个 IP 在某个特定时间、使用某种卡在特定商家进行交易。</strong> 这好比观看一部电影，FM 能够识别出哪些场景组合起来构成了异常。</p>
<p>这种能力在盗刷测试监测上取得了显著成果。传统的盗刷者会隐藏在大型电商的巨大流量中，进行大量 1 美分、2 美分的小额测试。传统 ML 很难捕捉到这种撒胡椒面式的攻击。而 FM 通过分析嵌入向量，能实时发现这些异常簇，并将大型用户的盗刷检测率从 59% 提升到了 97%。</p>
<p>FM 的另一个优势是快速适应性。一些 AI 公司向 Stripe 反映，他们面临大量可疑交易，这些交易虽然最终没有导致欺诈性争议（商家能收到钱），但它们来自机器人，会干扰数据，属于不良流量。Stripe 利用 FM 快速识别并聚类了这些新型可疑行为（例如，枚举登录流程中的某些组件），并在几天内就为 AI 公司提供了标记这些流量的能力，允许它们自行决定是否阻止这些交易。</p>
<h2 data-id="heading-2">AI 时代的经济挑战：高昂的边际成本与新型欺诈</h2>
<p>在 AI 时代，欺诈的形态发生了根本性的变化。Emily 指出，一种被称为友好欺诈的问题正变得尤为突出。这并非指盗用他人信用卡，而是用户使用自己的凭证进行“非支付滥用”，例如免费试用滥用 、退款滥用或“先用后不付”。</p>
<p>在传统的 SaaS 时代，这个问题并不致命。因为 SaaS 产品的边际成本几乎为零。即使用户滥用了免费试用，SaaS 公司损失的也只是潜在的收入，而没有产生实际的、高昂的交付成本。</p>
<p>在 AI 时代，情况完全不同。GPU 非常昂贵，推理成本很高。当一个用户滥用 AI 产品的免费试用时，他们是在消耗实实在在的算力资源。这种高昂的边际成本使得欺诈变为对 AI 企业生死存亡的威胁。</p>
<p>Emily 分享了一个案例：她与一位小型 AI 创始人交流，对方称欺诈不是问题。Emily 追问后发现，这位创始人为了解决欺诈问题，不得不完全关闭了免费试用，并且在新用户证明其支付能力之前，极大地限制了他们的积分或使用额度。Emily 犀利地指出：“你不是解决了欺诈问题，你是在扼杀你自己的收入。”</p>
<p>这种痛苦是真实存在的，它迫使企业在增长和风险之间做出艰难的权衡。这个问题不仅限于 AI 公司，也存在于广告平台（广告商投放了广告却不付钱，占用了本可以付费的广告位）等领域。</p>
<p>Emily 甚至提到，她的朋友最近获得了 Robin Hood 信用卡，该卡甚至在营销中提供“免费试用卡”——这种卡 24 小时后即过期，专门用于注册免费试用。这对善意的消费者来说很方便，但对欺诈者而言，这是对 AI 经济极具破坏性的工具。</p>
<p>Stripe 正在构建一套 Radar 扩展套件，专门针对这些新型欺诈。例如，Stripe 的免费试用产品声称可以在源头捕获大多数免费试用滥用。对于退款滥用，Stripe 也正在开发类似的解决方案。退款滥用在企业级套餐（如每月 10,000 美元购买数十万积分）中尤为严重。Stripe 的系统可以看到这些用户在使用服务（例如，在极短时间内用完所有积分），并能验证使用者身份，从而帮助商家识别并阻止这种滥用。</p>
<p>.... 更多内容</p>
<p>欢迎订阅合集 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4221297752417992707%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FX1JwNWhO9tjVQfh9Qq9uJw%26nolastread%3D1%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4221297752417992707&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FX1JwNWhO9tjVQfh9Qq9uJw&amp;nolastread=1&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">AI 播客捕手</a>：专门面向文字内容爱好者分享 AI 领域优质播客，其他合集：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243230891033935893%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FZcMiAmfNkmYLDgAu0rlb1Q%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243230891033935893&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZcMiAmfNkmYLDgAu0rlb1Q&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 冷思考</a>：个人在 AI 狂欢下的冷思考，聚焦 AI 工程化、Agent Infra 产品、效率型 AI 工具和人机协作话题，寻找可持续的产业价值。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243205243418624006%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252F0Tdan3R8juUlj-Lh-QMmew%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243205243418624006&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0Tdan3R8juUlj-Lh-QMmew&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 博客精选</a>：精心编译海外技术厂商发布的高质量 AI 领域博客文章。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[setTimeout 和 setInterval：看似简单，但你不知道的使用误区]]></title>    <link>https://juejin.cn/post/7570902473432973312</link>    <guid>https://juejin.cn/post/7570902473432973312</guid>    <pubDate>2025-11-10T10:14:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902473432973312" data-draft-id="7563194864416210979" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="setTimeout 和 setInterval：看似简单，但你不知道的使用误区"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-11-10T10:14:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="矢心"/> <meta itemprop="url" content="https://juejin.cn/user/4441682709588525"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            setTimeout 和 setInterval：看似简单，但你不知道的使用误区
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4441682709588525/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    矢心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:14:05.000Z" title="Mon Nov 10 2025 10:14:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">不那么准时的setTimeout和setInterval</h2>
<h3 data-id="heading-1">setTimeout和setInterval的执行时间误差</h3>
<p>在我们常见观念中，<strong>setTimeout</strong> 和 <strong>setInterval</strong> 都是用来在指定时间定时执行代码的函数。
setTimeout用于在指定的时间后执行一次代码，而setInterval则用于在指定的时间间隔内重复执行代码。</p>
<p>如题，下面的代码，很多人会下意识的认为 setTimeout 会在1秒后输出，setInterval 每1秒输出一次</p>
<p>但是实际情况中，setTimeout和setInterval的执行时间是有一定误差的。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 记录开始时间</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`setTimeout实际执行时间：<span class="hljs-subst">${end - start}</span>ms`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 记录开始时间</span>
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`setInterval实际执行时间：<span class="hljs-subst">${end - start}</span>ms`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<p><code>实际上执行时间会大于等于指定的延迟时间</code></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87e579e21f4e4fc382585b162fe576a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-i5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763374445&amp;x-signature=FTjApNmeB08XiZXzFZeSTan5k6A%3D" alt="GIF2.gif" loading="lazy"/></p>
<p>这是为什么呢？定时器始终存在实际最小执行间隔，即使指定的延迟时间为<strong>0ms</strong>，也会存在一定的延迟。</p>
<h4 data-id="heading-2">1、JS 引擎机制</h4>
<p>这是因为JavaScript是单线程执行的，而 setTimeout 和 setInterval 都是异步函数，
当JavaScript引擎执行到 setTimeout 或 setInterval 时，会将其放入事件队列中，定时器的回调函数必须等待主线程空闲时才能执行。而主线程空闲的时间是不确定的，取决于当前执行的代码的耗时。
即使主线程空闲，浏览器也需要一定时间调度回调函数（属于引擎内部的 “调度开销”），这个开销通常在 <strong>1ms~4ms</strong> 之间</p>
<h4 data-id="heading-3">2、HTML5 规范</h4>
<ol>
<li>
<p>HTML5 规范明确规定了<strong>定时器的最小延迟限制为4ms</strong>，嵌套层级较浅时最小延迟可能低至1ms。</p>
</li>
<li>
<p>对于嵌套层级 ≥ 5 的定时器（即定时器回调中再次创建定时器，形成嵌套），浏览器会强制将最小延迟限制为 4ms。</p>
</li>
<li>
<p>处于后台标签页中的计时器也可能会被限制为1秒的最小延迟</p>
</li>
</ol>
<p>因此，对于实际应用中，我们不能依赖 setTimeout 和 setInterval 的精确执行时间，而应该根据实际需求来调整定时器的延迟时间。</p>
<p>因此，对于实际应用中，我们不能依赖 <code>0ms</code> 延迟实现高精度逻辑（比如动画帧）</p>
<p>推荐使用 <code>requestAnimationFrame</code>（专门为动画设计，与浏览器刷新频率同步）</p>
<h3 data-id="heading-4">解决方法</h3>
<p>1、调整延迟时间
根据实际需求，合理调整定时器的延迟时间。如果对执行时间有严格要求，建议使用 Date.now() 或performance.now() 来计算实际执行时间，而不是依赖定时器的回调函数。</p>
<p>2、使用 requestAnimationFrame
requestAnimationFrame 是浏览器提供的用于动画循环的函数，它会在浏览器下一次重绘之前执行回调函数。与浏览器刷新频率同步，使用 requestAnimationFrame 可以实现更精确的动画效果。</p>
<h2 data-id="heading-5">setInterval存在的问题</h2>
<p>除了最小延迟时间外，setInterval 还存在一些额外问题，主要表现在以下几个方面：</p>
<h3 data-id="heading-6">1、任务堆叠（执行耗时  &gt;  设定间隔）</h3>
<p>如果回调中的执行耗时超过间隔时间，setInterval 可不会等你，而是会立即执行下一个回调，它会无视上次回调是否执行完毕，将新的回调推入队列，导致任务在队列中堆积，主线程空闲后，这些回调会连续地执行，失去间隔意义</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  count++;
  <span class="hljs-comment">// 每秒先输出当前执行信息</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行第<span class="hljs-subst">${count}</span>次，累计运行<span class="hljs-subst">${((<span class="hljs-built_in">Date</span>.now() - startTime) / <span class="hljs-number">1000</span>).toFixed(<span class="hljs-number">1</span>)}</span>s`</span>);
  <span class="hljs-comment">// 模拟耗时操作（阻塞2s）</span>
  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">2000</span>) {} <span class="hljs-comment">// 阻塞2000ms</span>
  <span class="hljs-comment">// 输出任务完成信息，并标记时间点</span>
  <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"第一次任务执行完成（约3秒后）"</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"任务执行完成（间隔约2秒）"</span>);
  }
}, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 间隔1000ms</span>
<span class="hljs-comment">// 实际为除了第一次是3s后执行完成，后续都是2s后执行完成，不会按照预设的1s间隔执行</span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c6101b8b3274d47ba40309ea75e3aa0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-i5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763374445&amp;x-signature=WmNqYk7xjPs6fCFTbT%2Fv3aQVK88%3D" alt="GIF.gif" loading="lazy"/>
<code>如果回调中的执行耗时超过间隔时间，实际间隔时间就是执行任务消耗的时间，而不是设定的值</code></p>
<h3 data-id="heading-7">2、误差累积（时间不准）</h3>
<p>上面说过，由于js的单线程机制，setInterval 无法保证精确间隔​，实际输出时间间隔可能大于设定的时间，因为js是单线程的，游览器最小间隔限制：浏览器通常有 ​4ms 最小延迟​（即使设 0ms），没有0延时定时器，包括setTimeout。</p>
<p>因此，在使用 setInterval 时，需要注意任务的执行耗时，避免耗时过长导致误差累积。</p>
<h3 data-id="heading-8">3、内存泄漏（忘记清除）</h3>
<p>忘记清理 setTimeout 只会导致一个多余的回调执行。但忘记 clearInterval 会导致回调函数无限执行，造成严重的内存泄漏，且页面跳转也不会自动停止（在 SPA 中最为明显）</p>
<h3 data-id="heading-9">解决办法</h3>
<p>手动写一个 <strong>setTimeout 递归封装的「安全版定时器」</strong>，解决 setInterval 可能出现的任务堆叠等问题，确保前一次回调完全执行完毕后，才触发下一次</p>
<p>简单示例：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInterval</span>(<span class="hljs-params">fn, delay</span>) {
  <span class="hljs-comment">// 递归执行函数</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行任务</span>
    <span class="hljs-built_in">setTimeout</span>(run, delay); <span class="hljs-comment">// 任务完成后，才触发下一次</span>
  };
  <span class="hljs-comment">// 启动首次执行</span>
  <span class="hljs-built_in">setTimeout</span>(run, delay);
}
</code></pre>
<p>使用效果</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-title function_">myInterval</span>(<span class="hljs-function">() =&gt;</span> {
  count++;
  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">1000</span>) {} <span class="hljs-comment">// 阻塞1000ms</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行第<span class="hljs-subst">${count}</span>次，累计运行<span class="hljs-subst">${((<span class="hljs-built_in">Date</span>.now() - startTime) / <span class="hljs-number">1000</span>).toFixed(<span class="hljs-number">1</span>)}</span>s`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d2d37d3144d4bba9c4b359bd8d8c7d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-i5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763374445&amp;x-signature=5697PMBvazkcfsfN2il0H%2F5ZsVM%3D" alt="GIF3.gif" loading="lazy"/>
每<strong>2s</strong>间隔执行，这样确保了每次回调执行完毕后，才会触发下一次，避免了任务堆叠问题。</p>
<h2 data-id="heading-10">总结</h2>
<p>在开发中，在大多数需要轮询定时器的场景下，使用递归的 setTimeout 相对更安全、更可控，使用 setInterval 时要做到心中有数，避免产生bug。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android 渲染机制深度解析（一个Crash引发的思考）]]></title>    <link>https://juejin.cn/post/7570903763721453578</link>    <guid>https://juejin.cn/post/7570903763721453578</guid>    <pubDate>2025-11-10T10:11:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570903763721453578" data-draft-id="7570932873130557467" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android 渲染机制深度解析（一个Crash引发的思考）"/> <meta itemprop="keywords" content="性能优化"/> <meta itemprop="datePublished" content="2025-11-10T10:11:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="范特蛟"/> <meta itemprop="url" content="https://juejin.cn/user/3773179636744205"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android 渲染机制深度解析（一个Crash引发的思考）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3773179636744205/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    范特蛟
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:11:12.000Z" title="Mon Nov 10 2025 10:11:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Android 渲染机制深度解析</h2>
<blockquote>
<p>起因：androidx.recyclerview.widget.RecyclerView$Recycler.validateViewHolderForOffsetPosition</p>
</blockquote>
<blockquote>
<p>包含 RecyclerView、GapWorker 和 Choreographer 的完整工作原理</p>
</blockquote>
<h3 data-id="heading-1">目录</h3>
<ul>
<li><a href="#%E4%B8%80recyclerview-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" title="#%E4%B8%80recyclerview-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">一、RecyclerView 工作原理</a></li>
<li><a href="#%E4%BA%8Cgapworker-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90" title="#%E4%BA%8Cgapworker-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">二、GapWorker 深度解析</a></li>
<li><a href="#%E4%B8%89choreographer-%E8%AF%A6%E8%A7%A3" title="#%E4%B8%89choreographer-%E8%AF%A6%E8%A7%A3">三、Choreographer 详解</a></li>
</ul>
<hr/>
<h2 data-id="heading-2">一、RecyclerView 工作原理</h2>
<p>RecyclerView 是 Android 中用于高效显示大量数据的组件。</p>
<h3 data-id="heading-3">核心设计理念</h3>
<p><strong>复用（Recycle）+ 视图持有者（ViewHolder）= 高性能列表</strong></p>
<p>传统的 ListView 每次滚动都要 <code>findViewById</code>，非常耗时。RecyclerView 通过缓存和复用机制大幅提升性能。</p>
<h3 data-id="heading-4">核心组件</h3>
<h4 data-id="heading-5">1. ViewHolder（视图持有者）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewHolder</span>(itemView: View) : RecyclerView.ViewHolder(itemView) {
    <span class="hljs-keyword">val</span> textView = itemView.findViewById&lt;TextView&gt;(R.id.text)
    <span class="hljs-comment">// 缓存子View的引用，避免重复 findViewById</span>
}
</code></pre>
<p><strong>作用</strong>：</p>
<ul>
<li>缓存 itemView 中的子 View 引用</li>
<li>携带 position、itemId 等元数据</li>
<li>一个 ViewHolder 对应一个列表项</li>
</ul>
<h4 data-id="heading-6">2. Adapter（适配器）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">MyViewHolder</span>&gt;() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> { ... }          <span class="hljs-comment">// 数据总数</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(...)</span></span>: MyViewHolder <span class="hljs-comment">// 创建ViewHolder</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder, position)</span></span>    <span class="hljs-comment">// 绑定数据</span>
}
</code></pre>
<p><strong>作用</strong>：</p>
<ul>
<li>管理数据源</li>
<li>创建和绑定 ViewHolder</li>
<li>通知 RecyclerView 数据变化</li>
</ul>
<h4 data-id="heading-7">3. LayoutManager（布局管理器）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">LinearLayoutManager    <span class="hljs-comment">// 线性布局</span>
GridLayoutManager      <span class="hljs-comment">// 网格布局</span>
StaggeredGridLayoutManager <span class="hljs-comment">// 瀑布流</span>
</code></pre>
<p><strong>作用</strong>：</p>
<ul>
<li>决定 item 如何摆放（垂直、横向、网格等）</li>
<li>处理滚动逻辑</li>
<li>决定哪些 item 可见</li>
</ul>
<h4 data-id="heading-8">4. Recycler（回收器）</h4>
<p>核心复用机制的实现者，管理多级缓存。</p>
<h3 data-id="heading-9">四级缓存机制</h3>
<p>这是 RecyclerView 性能的核心！</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────┐
│          RecyclerView 缓存池             │
├─────────────────────────────────────────┤
│ <span class="hljs-number">1</span>. mAttachedScrap (屏幕内缓存)           │  ← 最快，无需绑定
│    - 保存正在显示的 ViewHolder            │
│    - 用于布局期间临时分离的 ViewHolder     │
├─────────────────────────────────────────┤
│ <span class="hljs-number">2</span>. mCachedViews (离屏缓存)               │  ← 快，无需绑定
│    - 默认大小：<span class="hljs-number">2</span>                          │
│    - 保存刚滚出屏幕的 ViewHolder           │
│    - <span class="hljs-attribute">position</span> 和数据完全匹配才能复用       │
├─────────────────────────────────────────┤
│ <span class="hljs-number">3</span>. ViewCacheExtension (自定义缓存)       │  ← 开发者自定义
│    - 几乎不用                             │
├─────────────────────────────────────────┤
│ <span class="hljs-number">4</span>. RecycledViewPool (回收池)            │  ← 需要重新绑定
│    - 默认每种 type 缓存 <span class="hljs-number">5</span> 个               │
│    - 按 viewType 分类存储                 │
│    - ViewHolder 会清除 <span class="hljs-attribute">position</span> 信息      │
│    - 需要重新 <span class="hljs-built_in">onBindViewHolder</span>()          │
└─────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-10">缓存查找优先级</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 伪代码展示缓存查找流程</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryGetViewHolderForPositionByDeadline</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: ViewHolder? {
    <span class="hljs-comment">// 1. 先从 mAttachedScrap 找（精确匹配 position）</span>
    holder = mAttachedScrap.findByPosition(position)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> holder  <span class="hljs-comment">// 直接使用，无需 bind</span>

    <span class="hljs-comment">// 2. 从 mCachedViews 找（精确匹配 position）</span>
    holder = mCachedViews.findByPosition(position)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> holder  <span class="hljs-comment">// 直接使用，无需 bind</span>

    <span class="hljs-comment">// 3. 从自定义缓存找</span>
    holder = mViewCacheExtension?.getViewForPosition(position)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> holder

    <span class="hljs-comment">// 4. 从 RecycledViewPool 找（按 viewType 查找）</span>
    holder = mRecyclerPool.getRecycledView(viewType)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) {
        holder.resetInternal()  <span class="hljs-comment">// 清除旧数据</span>
        adapter.bindViewHolder(holder, position)  <span class="hljs-comment">// 需要重新绑定</span>
        <span class="hljs-keyword">return</span> holder
    }

    <span class="hljs-comment">// 5. 所有缓存都没有，创建新的</span>
    holder = adapter.createViewHolder(parent, viewType)
    adapter.bindViewHolder(holder, position)
    <span class="hljs-keyword">return</span> holder
}
</code></pre>
<h3 data-id="heading-11">工作流程</h3>
<h4 data-id="heading-12">1. 初始化阶段</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">recyclerView.layoutManager = LinearLayoutManager(context)
recyclerView.adapter = myAdapter
</code></pre>
<p>RecyclerView 会：</p>
<ol>
<li>测量自己的尺寸</li>
<li>让 LayoutManager 布局子 View</li>
<li>根据可见区域创建足够的 ViewHolder</li>
</ol>
<h4 data-id="heading-13">2. 滚动阶段</h4>
<pre><code class="hljs language-arduino" lang="arduino">用户向上滚动：

┌──────────────────┐
│ position <span class="hljs-number">0</span>       │ ← 滚出屏幕，进入 mCachedViews
├──────────────────┤
│ position <span class="hljs-number">1</span>       │ ← 可见
├──────────────────┤
│ position <span class="hljs-number">2</span>       │ ← 可见
├──────────────────┤
│ position <span class="hljs-number">3</span>       │ ← 可见
├──────────────────┤
│ position <span class="hljs-number">4</span>       │ ← 即将可见，从缓存中取 ViewHolder
└──────────────────┘
</code></pre>
<p><strong>流程</strong>：</p>
<ol>
<li>position 0 滚出屏幕 → detach → 放入 <code>mCachedViews</code></li>
<li>position 4 即将进入屏幕 → 从缓存查找 ViewHolder</li>
<li>如果 <code>mCachedViews</code> 满了（超过2个）→ 最旧的移到 <code>RecycledViewPool</code></li>
</ol>
<h4 data-id="heading-14">3. 数据更新阶段</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误：notifyDataSetChanged()</span>
adapter.notifyDataSetChanged()
<span class="hljs-comment">// 所有缓存失效，全部重新 bind，性能差</span>

<span class="hljs-comment">// ✅ 正确：精确通知</span>
adapter.notifyItemRemoved(position)      <span class="hljs-comment">// 删除</span>
adapter.notifyItemInserted(position)     <span class="hljs-comment">// 插入</span>
adapter.notifyItemChanged(position)      <span class="hljs-comment">// 更新</span>
adapter.notifyItemMoved(from, to)        <span class="hljs-comment">// 移动</span>
</code></pre>
<h3 data-id="heading-15">notify 方法对比</h3>








































<table><thead><tr><th>方法</th><th>缓存失效范围</th><th>重新 bind</th><th>动画</th><th>性能</th></tr></thead><tbody><tr><td><code>notifyDataSetChanged()</code></td><td>全部失效</td><td>全部重新 bind</td><td>❌ 无</td><td>⚠️ 差</td></tr><tr><td><code>notifyItemRemoved(pos)</code></td><td>仅一个</td><td>仅一个</td><td>✅ 有</td><td>✅ 好</td></tr><tr><td><code>notifyItemChanged(pos)</code></td><td>仅一个</td><td>仅一个</td><td>✅ 有</td><td>✅ 好</td></tr><tr><td><code>notifyItemInserted(pos)</code></td><td>后续位置 +1</td><td>仅新的</td><td>✅ 有</td><td>✅ 好</td></tr></tbody></table>
<h3 data-id="heading-16">位置信息管理</h3>
<p>RecyclerView 维护了复杂的位置映射：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewHolder</span> {
    <span class="hljs-keyword">var</span> mPosition: <span class="hljs-built_in">Int</span> = NO_POSITION        <span class="hljs-comment">// 当前位置</span>
    <span class="hljs-keyword">var</span> mOldPosition: <span class="hljs-built_in">Int</span> = NO_POSITION     <span class="hljs-comment">// 旧位置</span>
    <span class="hljs-keyword">var</span> mPreLayoutPosition: <span class="hljs-built_in">Int</span> = NO_POSITION <span class="hljs-comment">// 布局前位置</span>
    <span class="hljs-comment">// ... 其他位置信息</span>
}
</code></pre>
<p><strong>为什么需要这么多位置</strong>：</p>
<ul>
<li>动画期间，item 的位置会变化</li>
<li>需要记录动画前后的位置</li>
<li>预取机制需要预测位置</li>
</ul>
<h3 data-id="heading-17">完整的删除流程对比</h3>
<h4 data-id="heading-18">❌ 错误方式</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">datas.remove(<span class="hljs-keyword">data</span>)
notifyDataSetChanged()

<span class="hljs-comment">// 问题：</span>
<span class="hljs-comment">// 1. 所有 ViewHolder 的 position 信息立即失效</span>
<span class="hljs-comment">// 2. GapWorker 可能使用过期的 position</span>
<span class="hljs-comment">// 3. 所有可见 item 都要重新 bind（性能差）</span>
<span class="hljs-comment">// 4. 没有删除动画</span>
</code></pre>
<h4 data-id="heading-19">✅ 正确方式</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> position = datas.indexOf(<span class="hljs-keyword">data</span>)
<span class="hljs-keyword">if</span> (position != -<span class="hljs-number">1</span>) {
    datas.remove(<span class="hljs-keyword">data</span>)
    notifyItemRemoved(position)
    notifyItemRangeChanged(position, datas.size - position)
}

<span class="hljs-comment">// 优点：</span>
<span class="hljs-comment">// 1. RecyclerView 立即更新内部位置映射</span>
<span class="hljs-comment">// 2. GapWorker 获得准确的 position 信息</span>
<span class="hljs-comment">// 3. 只有被删除的 item 需要处理</span>
<span class="hljs-comment">// 4. 有流畅的删除动画</span>
<span class="hljs-comment">// 5. 后续 item 的 position 自动更新</span>
</code></pre>
<hr/>
<h2 data-id="heading-20">二、GapWorker 深度解析</h2>
<p>GapWorker 是 RecyclerView 在 Android Support Library 25.1.0 引入的预取（Prefetch）机制，用于在 UI 空闲时提前准备即将显示的 ViewHolder。</p>
<h3 data-id="heading-21">为什么需要 GapWorker？</h3>
<h4 data-id="heading-22">传统滚动的性能问题</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">用户滚动时的帧时间分布（没有</span> <span class="hljs-string">GapWorker）：</span>

<span class="hljs-attr">Frame 1:</span> <span class="hljs-string">████████████████</span> <span class="hljs-string">(16ms</span> <span class="hljs-bullet">-</span> <span class="hljs-string">流畅)</span>
         <span class="hljs-string">只需要渲染已有的</span> <span class="hljs-string">ViewHolder</span>

<span class="hljs-attr">Frame 2:</span> <span class="hljs-string">████████████████████████████</span> <span class="hljs-string">(28ms</span> <span class="hljs-bullet">-</span> <span class="hljs-string">卡顿！⚠️)</span>
         <span class="hljs-string">需要创建新的</span> <span class="hljs-string">ViewHolder：</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">inflate</span> <span class="hljs-string">XML</span> <span class="hljs-string">(8ms)</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">onCreateViewHolder</span> <span class="hljs-string">(2ms)</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">onBindViewHolder</span> <span class="hljs-string">(5ms)</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">measure</span> <span class="hljs-string">+</span> <span class="hljs-string">layout</span> <span class="hljs-string">(3ms)</span>
         <span class="hljs-string">总计超过</span> <span class="hljs-string">16ms</span> <span class="hljs-string">→</span> <span class="hljs-string">掉帧！</span>

<span class="hljs-attr">Frame 3:</span> <span class="hljs-string">████████████████</span> <span class="hljs-string">(16ms</span> <span class="hljs-bullet">-</span> <span class="hljs-string">流畅)</span>
</code></pre>
<h4 data-id="heading-23">有了 GapWorker 之后</h4>
<pre><code class="hljs language-markdown" lang="markdown">Frame 1: ████████████████ (16ms - 流畅)
<span class="hljs-code">         渲染 + GapWorker 在空闲时间预取
</span>
Frame 2: ████████████████ (14ms - 流畅！✅)
<span class="hljs-code">         直接使用预取好的 ViewHolder
</span>
空闲时间: ░░░ (2ms)
<span class="hljs-code">         GapWorker 继续预取下一个
</span></code></pre>
<h3 data-id="heading-24">GapWorker 架构</h3>
<pre><code class="hljs language-arduino" lang="arduino">┌─────────────────────────────────────────────────┐
│              <span class="hljs-built_in">GapWorker</span> (单例)                    │
├─────────────────────────────────────────────────┤
│  管理多个 RecyclerView 的预取任务                 │
│                                                 │
│  ┌──────────────────────────────────────┐      │
│  │   RecyclerView A 的预取任务           │      │
│  │   - 预取 position <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>            │      │
│  │   - 优先级: 高                        │      │
│  └──────────────────────────────────────┘      │
│                                                 │
│  ┌──────────────────────────────────────┐      │
│  │   RecyclerView B 的预取任务           │      │
│  │   - 预取 position <span class="hljs-number">10</span>                 │      │
│  │   - 优先级: 中                        │      │
│  └──────────────────────────────────────┘      │
│                                                 │
│  通过 Choreographer 在每一帧执行               │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-25">工作时机</h3>
<p>GapWorker 通过 <code>Choreographer</code> 在每一帧的特定时机工作：</p>
<pre><code class="hljs language-scss" lang="scss">Android 每一帧的时间分配（<span class="hljs-number">60</span>fps = <span class="hljs-number">16.67ms</span>）：

<span class="hljs-number">0ms</span> ─────────────────────────────── <span class="hljs-number">16.67ms</span>
│                                    │
├─ <span class="hljs-selector-tag">Input</span> (触摸事件)                   │
│  约 <span class="hljs-number">2ms</span>                             │
│                                    │
├─ <span class="hljs-attribute">Animation</span> (动画)                   │
│  约 <span class="hljs-number">2ms</span>                             │
│                                    │
├─ Traversal (测量、布局、绘制)        │
│  约 <span class="hljs-number">8ms</span>                             │
│                                    │
├─ 空闲时间 ░░░░░░                    │ ← GapWorker 在这里工作！
│  约 <span class="hljs-number">4ms</span>                             │
│                                    │
└─ VSync 下一帧开始                   │
</code></pre>
<h3 data-id="heading-26">预取策略</h3>
<h4 data-id="heading-27">1. 预测下一个可见的位置</h4>
<pre><code class="hljs language-scss" lang="scss">用户向下滚动，dy &gt; <span class="hljs-number">0</span>：

┌──────────────────┐
│ <span class="hljs-attribute">position</span> <span class="hljs-number">5</span>  ✅   │ ← 完全可见
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>  ✅   │ ← 完全可见
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">7</span>  ✅   │ ← 完全可见
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">8</span>  ⚠️   │ ← 部分可见，继续滚动会完全显示
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">9</span>  🎯   │ ← 即将可见，需要预取！
└──────────────────┘
│ <span class="hljs-attribute">position</span> <span class="hljs-number">10</span> 🎯   │ ← 可能可见，也预取
  （屏幕外）

预取优先级：
<span class="hljs-number">1</span>. <span class="hljs-attribute">position</span> <span class="hljs-number">9</span>  (紧急，马上要显示)
<span class="hljs-number">2</span>. <span class="hljs-attribute">position</span> <span class="hljs-number">10</span> (次要，可能要显示)
</code></pre>
<h4 data-id="heading-28">2. LayoutManager 的预取实现</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// LinearLayoutManager 的预取逻辑</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectInitialPrefetchPositions</span><span class="hljs-params">(
    adapterItemCount: <span class="hljs-type">Int</span>,
    layoutPrefetchRegistry: <span class="hljs-type">LayoutPrefetchRegistry</span>
)</span></span> {
    <span class="hljs-comment">// 初始布局时的预取</span>
    <span class="hljs-keyword">val</span> prefetchCount = Math.min(
        adapterItemCount,
        mInitialPrefetchItemCount <span class="hljs-comment">// 默认 2 个</span>
    )

    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until prefetchCount) {
        layoutPrefetchRegistry.addPosition(i, <span class="hljs-number">0</span>)
    }
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectAdditionalPrefetchPositions</span><span class="hljs-params">(
    dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>,
    state: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">State</span>,
    layoutPrefetchRegistry: <span class="hljs-type">LayoutPrefetchRegistry</span>
)</span></span> {
    <span class="hljs-comment">// 滚动时的预取</span>
    <span class="hljs-keyword">val</span> layoutDirection = <span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span> <span class="hljs-comment">// 滚动方向</span>
    <span class="hljs-keyword">val</span> scrollingOffset = Math.abs(dy)

    <span class="hljs-comment">// 计算需要预取的位置</span>
    <span class="hljs-keyword">val</span> prefetchPosition = getCurrentPosition() + layoutDirection

    <span class="hljs-comment">// 注册预取任务</span>
    layoutPrefetchRegistry.addPosition(prefetchPosition, scrollingOffset)
}
</code></pre>
<h4 data-id="heading-29">3. 预取任务的数据结构</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// GapWorker 内部任务队列</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GapWorker</span> {

    <span class="hljs-comment">// 任务类</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> {
        <span class="hljs-keyword">var</span> view: RecyclerView? = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">var</span> position: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
        <span class="hljs-keyword">var</span> immediate: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 是否紧急</span>
        <span class="hljs-keyword">var</span> viewVelocity: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>       <span class="hljs-comment">// 滚动速度</span>
        <span class="hljs-keyword">var</span> distanceToItem: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>     <span class="hljs-comment">// 距离当前位置的距离</span>
    }

    <span class="hljs-comment">// 任务优先级队列（按紧急程度排序）</span>
    <span class="hljs-keyword">val</span> mTasks = ArrayList&lt;Task&gt;()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sortTasks</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 按以下优先级排序：</span>
        <span class="hljs-comment">// 1. immediate 任务优先</span>
        <span class="hljs-comment">// 2. 距离近的优先</span>
        <span class="hljs-comment">// 3. 滚动速度快的优先</span>
        mTasks.sortWith { task1, task2 -&gt;
            <span class="hljs-keyword">when</span> {
                task1.immediate &amp;&amp; !task2.immediate -&gt; -<span class="hljs-number">1</span>
                !task1.immediate &amp;&amp; task2.immediate -&gt; <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span> -&gt; task1.distanceToItem - task2.distanceToItem
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-30">预取执行流程</h3>
<h4 data-id="heading-31">详细的执行步骤</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 简化的源码逻辑</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GapWorker</span> : <span class="hljs-type">Runnable</span> {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 1. 获取截止时间（当前帧结束时间）</span>
        <span class="hljs-keyword">val</span> deadlineNs = TimeUtils.currentAnimationTimeMillis() * <span class="hljs-number">1_000_000</span> + <span class="hljs-number">4_000_000</span>
        <span class="hljs-comment">// 留 4ms 给 GapWorker，其他时间留给渲染</span>

        <span class="hljs-comment">// 2. 执行预取任务</span>
        prefetch(deadlineNs)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prefetch</span><span class="hljs-params">(deadlineNs: <span class="hljs-type">Long</span>)</span></span> {
        <span class="hljs-comment">// 按优先级处理任务</span>
        <span class="hljs-keyword">for</span> (task <span class="hljs-keyword">in</span> mTasks) {
            <span class="hljs-comment">// 检查是否还有时间</span>
            <span class="hljs-keyword">if</span> (System.nanoTime() &gt;= deadlineNs) {
                <span class="hljs-keyword">break</span> <span class="hljs-comment">// 时间用完，停止预取</span>
            }

            <span class="hljs-comment">// 执行预取</span>
            prefetchPositionWithDeadline(
                task.view,
                task.position,
                deadlineNs
            )
        }

        <span class="hljs-comment">// 清空任务队列</span>
        mTasks.clear()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prefetchPositionWithDeadline</span><span class="hljs-params">(
        view: <span class="hljs-type">RecyclerView</span>?,
        position: <span class="hljs-type">Int</span>,
        deadlineNs: <span class="hljs-type">Long</span>
    )</span></span>: ViewHolder? {
        <span class="hljs-comment">// 这里就是崩溃发生的地方！⚠️</span>

        <span class="hljs-keyword">val</span> holder = view?.mRecycler?.tryGetViewHolderForPositionByDeadline(
            position,
            <span class="hljs-literal">false</span>,
            deadlineNs
        )

        <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (holder.isBound &amp;&amp; !holder.isInvalid) {
                <span class="hljs-comment">// 成功预取，放入缓存</span>
                view.mRecycler.recycleView(holder.itemView)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 预取失败，回收</span>
                view.mRecycler.addViewHolderToRecycledViewPool(holder, <span class="hljs-literal">false</span>)
            }
        }

        <span class="hljs-keyword">return</span> holder
    }
}
</code></pre>
<h3 data-id="heading-32">与 Recycler 缓存的配合</h3>
<pre><code class="hljs language-bash" lang="bash">GapWorker 预取的 ViewHolder 放在哪里？

┌─────────────────────────────────────────┐
│         Recycler 缓存系统                 │
├─────────────────────────────────────────┤
│                                         │
│  GapWorker 预取                          │
│      ↓                                  │
│  创建/绑定 ViewHolder                     │
│      ↓                                  │
│  放入 mCachedViews (离屏缓存)             │  ← 优先放这里
│      │                                  │
│      ├─ 如果 mCachedViews 满了           │
│      └─→ 放入 RecycledViewPool           │  ← 次选
│                                         │
│  当 item 滚动进屏幕时：                   │
│      从 mCachedViews 直接取出 ✅          │
│      无需重新 <span class="hljs-built_in">bind</span>！                     │
└─────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-33">IndexOutOfBoundsException 崩溃场景详细分析</h3>
<h4 data-id="heading-34">崩溃的时序图</h4>
<pre><code class="hljs language-scss" lang="scss">主线程（UI Thread）                   GapWorker（后台任务）
    │                                      │
    │ 用户滚动到 <span class="hljs-attribute">position</span> <span class="hljs-number">5</span>                │
    │ LayoutManager 布局完成                │
    │                                      │
    ├─ <span class="hljs-built_in">collectPrefetchPositions</span>()          │
    │  决定预取 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>                 │
    │                                      │
    │ post GapWorker<span class="hljs-selector-class">.run</span>()                 │
    │ ─────────────────────────────────→  │
    │                                      │
    │ 继续渲染界面                          │  GapWorker<span class="hljs-selector-class">.run</span>() 开始
    │                                      │  读取任务：预取 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>
    │                                      │
    │ 用户点击删除 <span class="hljs-attribute">position</span> <span class="hljs-number">2</span> ⚠️            │
    │                                      │
    ├─ <span class="hljs-built_in">onClick</span>() {                         │
    │    datas<span class="hljs-selector-class">.remove</span>(position <span class="hljs-number">2</span>)          │  ← adapter 现在只有 <span class="hljs-number">9</span> 条数据
    │    <span class="hljs-built_in">notifyDataSetChanged</span>()            │  ← 只是标记，未立即生效！
    │  }                                   │
    │                                      │
    │                                      ├─ <span class="hljs-built_in">prefetchPositionWithDeadline</span>(<span class="hljs-number">6</span>)
    │                                      │  调用 adapter<span class="hljs-selector-class">.getItemCount</span>()
    │                                      │  返回 <span class="hljs-number">9</span>（已经删除了一条）
    │                                      │
    │                                      ├─ <span class="hljs-built_in">validateViewHolderForOffsetPosition</span>()
    │                                      │  检查 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span> 是否有效
    │                                      │
    │                                      │  GapWorker 认为：
    │                                      │  - 之前计划预取 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>
    │                                      │  - 但现在 adapter 只有 <span class="hljs-number">9</span> 条数据
    │                                      │  - ViewHolder 的位置信息不一致
    │                                      │
    │                                      │  抛出异常：⚠️
    │  ←────────────────────────────────── │  IndexOutOfBoundsException:
    │                                      │  Inconsistency detected!
    │                                      │
    │ CRASH! ☠️                            │
</code></pre>
<h4 data-id="heading-35">关键代码路径</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// RecyclerView.Recycler</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryGetViewHolderForPositionByDeadline</span><span class="hljs-params">(
    position: <span class="hljs-type">Int</span>,
    dryRun: <span class="hljs-type">Boolean</span>,
    deadlineNs: <span class="hljs-type">Long</span>
)</span></span>: ViewHolder? {

    <span class="hljs-comment">// ... 省略缓存查找逻辑</span>

    <span class="hljs-comment">// 关键检查点：验证 ViewHolder 的位置是否有效</span>
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (!holder.isValid || holder.position != position) {
            <span class="hljs-comment">// 这里检测到不一致！⚠️</span>
            <span class="hljs-keyword">throw</span> IndexOutOfBoundsException(
                <span class="hljs-string">"Inconsistency detected. Invalid view holder "</span> +
                <span class="hljs-string">"adapter position <span class="hljs-variable">$holder</span>"</span>
            )
        }
    }

    <span class="hljs-keyword">return</span> holder
}

<span class="hljs-comment">// 为什么会不一致？</span>
<span class="hljs-comment">// 1. GapWorker 计划预取时：adapter.getItemCount() = 10</span>
<span class="hljs-comment">// 2. 用户删除后：adapter.getItemCount() = 9</span>
<span class="hljs-comment">// 3. 但 GapWorker 还在用旧的 position 6</span>
<span class="hljs-comment">// 4. position 6 在新的数据集中可能越界或指向错误的数据</span>
</code></pre>
<h3 data-id="heading-36">为什么精确通知能解决？</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误方式</span>
datas.remove(<span class="hljs-keyword">data</span>)
notifyDataSetChanged()

<span class="hljs-comment">// notifyDataSetChanged() 做了什么？</span>
<span class="hljs-comment">// 1. 标记所有 ViewHolder 为 FLAG_INVALID</span>
<span class="hljs-comment">// 2. 标记 adapter 为 hasStableIds = false</span>
<span class="hljs-comment">// 3. 触发 requestLayout()</span>
<span class="hljs-comment">// 4. 但这些都是异步的！不会立即生效！</span>
<span class="hljs-comment">// 5. GapWorker 还在使用旧的位置信息 ⚠️</span>
</code></pre>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确方式</span>
<span class="hljs-keyword">val</span> position = datas.indexOf(<span class="hljs-keyword">data</span>)
<span class="hljs-keyword">if</span> (position != -<span class="hljs-number">1</span>) {
    datas.remove(<span class="hljs-keyword">data</span>)
    notifyItemRemoved(position)
    notifyItemRangeChanged(position, datas.size - position)
}

<span class="hljs-comment">// notifyItemRemoved() 做了什么？</span>
<span class="hljs-comment">// 1. 立即更新 RecyclerView 的内部 AdapterHelper</span>
<span class="hljs-comment">// 2. AdapterHelper 维护位置更新操作队列</span>
<span class="hljs-comment">// 3. 告诉 RecyclerView：position 被移除了</span>
<span class="hljs-comment">// 4. RecyclerView 立即更新所有 ViewHolder 的位置</span>
<span class="hljs-comment">// 5. GapWorker 查询位置时，获得的是更新后的正确位置 ✅</span>
</code></pre>
<h4 data-id="heading-37">AdapterHelper 的作用</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// RecyclerView 内部的 AdapterHelper</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterHelper</span> {

    <span class="hljs-comment">// 保存所有的数据变更操作</span>
    <span class="hljs-keyword">val</span> mPendingUpdates = ArrayList&lt;UpdateOp&gt;()

    <span class="hljs-comment">// 操作类型</span>
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ADD = <span class="hljs-number">1</span>      <span class="hljs-comment">// 插入</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REMOVE = <span class="hljs-number">2</span>   <span class="hljs-comment">// 删除</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> UPDATE = <span class="hljs-number">3</span>   <span class="hljs-comment">// 更新</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MOVE = <span class="hljs-number">4</span>     <span class="hljs-comment">// 移动</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onItemRangeRemoved</span><span class="hljs-params">(positionStart: <span class="hljs-type">Int</span>, itemCount: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 创建删除操作</span>
        <span class="hljs-keyword">val</span> op = UpdateOp(REMOVE, positionStart, itemCount)
        mPendingUpdates.add(op)

        <span class="hljs-comment">// 立即应用到位置映射</span>
        applyRemove(op)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applyRemove</span><span class="hljs-params">(op: <span class="hljs-type">UpdateOp</span>)</span></span> {
        <span class="hljs-comment">// 更新后续所有 ViewHolder 的位置</span>
        <span class="hljs-keyword">for</span> (holder <span class="hljs-keyword">in</span> mCachedViews) {
            <span class="hljs-keyword">if</span> (holder.position &gt;= op.positionStart) {
                holder.offsetPosition(-op.itemCount, <span class="hljs-literal">false</span>)
            }
        }

        <span class="hljs-comment">// GapWorker 读取位置时，会经过这个映射 ✅</span>
        <span class="hljs-comment">// 所以获得的是正确的位置</span>
    }
}
</code></pre>
<h3 data-id="heading-38">GapWorker 的优缺点</h3>
<h4 data-id="heading-39">优点 ✅</h4>
<ol>
<li><strong>显著提升滚动流畅度</strong>：避免滚动时创建 ViewHolder 导致的卡顿</li>
<li><strong>智能预测</strong>：根据滚动方向和速度预测</li>
<li><strong>时间控制</strong>：不会占用太多帧时间（默认 4ms）</li>
<li><strong>多 RecyclerView 支持</strong>：一个 GapWorker 管理多个列表</li>
</ol>
<h4 data-id="heading-40">缺点和风险 ⚠️</h4>
<ol>
<li><strong>数据不一致崩溃</strong>：如遇到的 IndexOutOfBoundsException</li>
<li><strong>过度预取</strong>：可能预取用不到的 ViewHolder，浪费资源</li>
<li><strong>复杂性增加</strong>：增加了调试难度</li>
<li><strong>内存占用</strong>：预取的 ViewHolder 会占用额外内存</li>
</ol>
<h3 data-id="heading-41">最佳实践</h3>
<h4 data-id="heading-42">1. 始终使用精确通知</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确</span>
adapter.notifyItemRemoved(position)
adapter.notifyItemInserted(position)
adapter.notifyItemChanged(position)

<span class="hljs-comment">// ❌ 避免</span>
adapter.notifyDataSetChanged()
</code></pre>
<h4 data-id="heading-43">2. 在主线程修改数据</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确</span>
lifecycleScope.launch(Dispatchers.Main) {
    adapter.removeItem(position)
}

<span class="hljs-comment">// ❌ 错误：后台线程修改</span>
lifecycleScope.launch(Dispatchers.IO) {
    adapter.removeItem(position) <span class="hljs-comment">// 可能与 GapWorker 冲突</span>
}
</code></pre>
<h4 data-id="heading-44">3. 使用 DiffUtil</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// DiffUtil 会自动计算差异并调用精确的 notify 方法</span>
<span class="hljs-keyword">val</span> diffResult = DiffUtil.calculateDiff(MyDiffCallback(oldList, newList))
diffResult.dispatchUpdatesTo(adapter)
</code></pre>
<h4 data-id="heading-45">4. 优化 onBindViewHolder</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// GapWorker 会调用 bind，所以要保持高效</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">ViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
    <span class="hljs-comment">// ✅ 快速绑定</span>
    holder.textView.text = <span class="hljs-keyword">data</span>[position].title

    <span class="hljs-comment">// ❌ 避免耗时操作</span>
    <span class="hljs-comment">// loadImageFromNetwork()</span>
    <span class="hljs-comment">// complexCalculation()</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-46">三、Choreographer 详解</h2>
<p>Choreographer 是 Android 4.1（API 16）引入的核心类，用于协调动画、输入和绘制的时间。它的名字来自法语"Chorégraphe"，意为"编舞者"，负责编排 UI 线程的各种操作。</p>
<h3 data-id="heading-47">为什么需要 Choreographer？</h3>
<h4 data-id="heading-48">Android 4.1 之前的问题</h4>
<pre><code class="hljs language-markdown" lang="markdown">没有 Choreographer 的渲染（混乱）：

时间轴：
0ms     5ms     10ms    15ms    20ms
│       │       │       │       │
├─ 动画更新
│       ├─ 绘制操作
│               ├─ 触摸事件
│                       ├─ 绘制操作
│                               └─ 动画更新

问题：
<span class="hljs-bullet">1.</span> 渲染时机不统一，随机触发
<span class="hljs-bullet">2.</span> 可能在屏幕刷新的任何时刻绘制
<span class="hljs-bullet">3.</span> 造成画面撕裂（Tearing）
<span class="hljs-bullet">4.</span> 无法保证 60fps
</code></pre>
<h4 data-id="heading-49">有了 Choreographer 之后</h4>
<pre><code class="hljs language-css" lang="css">VSync 信号对齐（整齐）：

时间轴（<span class="hljs-number">60</span>fps = <span class="hljs-number">16.67ms</span>一帧）：
<span class="hljs-number">0ms</span>           <span class="hljs-number">16.67ms</span>        <span class="hljs-number">33.34ms</span>
│             │              │
VSync ────────VSync ──────── VSync
│             │              │
├─ <span class="hljs-selector-tag">Input</span>      ├─ <span class="hljs-selector-tag">Input</span>       ├─ <span class="hljs-selector-tag">Input</span>
├─ <span class="hljs-attribute">Animation</span>  ├─ <span class="hljs-attribute">Animation</span>   ├─ <span class="hljs-attribute">Animation</span>
├─ Traversal  ├─ Traversal   ├─ Traversal
└─ Commit     └─ Commit      └─ Commit

优点：
<span class="hljs-number">1</span>. 所有渲染操作对齐到 VSync 信号
<span class="hljs-number">2</span>. 画面流畅，无撕裂
<span class="hljs-number">3</span>. 可预测的帧率
</code></pre>
<h3 data-id="heading-50">VSync（垂直同步）机制</h3>
<h4 data-id="heading-51">什么是 VSync？</h4>
<pre><code class="hljs language-ini" lang="ini">屏幕刷新原理：

LCD/OLED 屏幕的电子枪从上到下逐行扫描：

第1行  ═══════════════════════
第2行  ═══════════════════════
第3行  ═══════════════════════
...    ...
第N行  ═══════════════════════

扫描完一屏后，回到顶部（垂直回扫）
此时发出 VSync 信号 📡

<span class="hljs-attr">VSync</span> = Vertical Synchronization（垂直同步）
</code></pre>
<h4 data-id="heading-52">屏幕撕裂（Tearing）问题</h4>
<pre><code class="hljs">没有 VSync 同步：

GPU 正在渲染 Frame 2      屏幕正在显示
┌─────────────┐           ┌─────────────┐
│             │           │ Frame 1 上半│ ← 显示旧帧
│  Frame 2    │ ────→     ├─────────────┤ ← 撕裂线！
│             │           │ Frame 2 下半│ ← 显示新帧
└─────────────┘           └─────────────┘

用户看到的画面不连贯 ⚠️
</code></pre>
<pre><code class="hljs language-scss" lang="scss">有了 VSync 同步：

等待 VSync 信号才提交新帧

GPU 渲染 Frame <span class="hljs-number">2</span>          VSync 信号      屏幕显示
┌─────────────┐           │              ┌─────────────┐
│             │           │              │             │
│  Frame <span class="hljs-number">2</span>    │ ─────等待─┤ VSync 📡 ───→│  Frame <span class="hljs-number">2</span>    │
│             │           │              │  (完整)     │
└─────────────┘           │              └─────────────┘

画面流畅无撕裂 ✅
</code></pre>
<h4 data-id="heading-53">双缓冲（Double Buffering）</h4>
<pre><code class="hljs language-markdown" lang="markdown">Android 的双缓冲机制：

┌──────────────┐  显示      ┌──────────┐
│ Front Buffer │ ─────────→ │  Screen  │
└──────────────┘            └──────────┘
<span class="hljs-code">       ↑
       │ VSync 时交换
       │
┌──────────────┐  绘制
│ Back Buffer  │ ←──── GPU 在这里绘制下一帧
└──────────────┘
</span>
工作流程：
<span class="hljs-bullet">1.</span> GPU 在 Back Buffer 绘制
<span class="hljs-bullet">2.</span> VSync 信号到来
<span class="hljs-bullet">3.</span> 交换 Front 和 Back Buffer
<span class="hljs-bullet">4.</span> 屏幕显示 Front Buffer
<span class="hljs-bullet">5.</span> GPU 继续在新的 Back Buffer 绘制
</code></pre>
<h3 data-id="heading-54">Choreographer 架构</h3>
<h4 data-id="heading-55">核心组件</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│           Choreographer (编舞者)                 │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │  CallbackQueue (回调队列)                │   │
│  │                                         │   │
│  │  CALLBACK_INPUT      (触摸输入)         │   │
│  │  CALLBACK_ANIMATION  (动画)             │   │
│  │  CALLBACK_TRAVERSAL  (测量/布局/绘制)    │   │
│  │  CALLBACK_COMMIT     (提交)             │   │
│  └─────────────────────────────────────────┘   │
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │  FrameDisplayEventReceiver              │   │
│  │  (接收 VSync 信号)                       │   │
│  └─────────────────────────────────────────┘   │
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │  FrameHandler                           │   │
│  │  (主线程 Handler，处理回调)              │   │
│  └─────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘
           ↑
           │ VSync 信号
           │
    ┌──────────────┐
    │  SurfaceFlinger  │ ← 系统服务
    │  (屏幕合成器)     │
    └──────────────┘
</code></pre>
<h4 data-id="heading-56">Choreographer 是单例</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Choreographer 每个线程一个实例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Choreographer</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(looper: Looper) {

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-comment">// ThreadLocal 保证每个线程独立</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sThreadInstance = ThreadLocal&lt;Choreographer&gt;()

        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>: Choreographer {
            <span class="hljs-keyword">return</span> sThreadInstance.<span class="hljs-keyword">get</span>() ?: synchronized(Choreographer::<span class="hljs-keyword">class</span>.java) {
                Choreographer(Looper.myLooper()).also {
                    sThreadInstance.<span class="hljs-keyword">set</span>(it)
                }
            }
        }
    }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-comment">// 主线程的 Choreographer</span>
<span class="hljs-keyword">val</span> mainChoreographer = Choreographer.getInstance() <span class="hljs-comment">// UI 线程</span>

<span class="hljs-comment">// 其他线程需要先创建 Looper</span>
thread {
    Looper.prepare()
    <span class="hljs-keyword">val</span> threadChoreographer = Choreographer.getInstance() <span class="hljs-comment">// 独立实例</span>
    Looper.loop()
}
</code></pre>
<h3 data-id="heading-57">四种回调类型</h3>
<p>Choreographer 定义了四种回调类型，按执行顺序：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Choreographer 的回调类型</span>
<span class="hljs-keyword">object</span> Choreographer {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_INPUT = <span class="hljs-number">0</span>      <span class="hljs-comment">// 输入事件</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_ANIMATION = <span class="hljs-number">1</span>  <span class="hljs-comment">// 动画</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_TRAVERSAL = <span class="hljs-number">2</span>  <span class="hljs-comment">// 遍历（测量、布局、绘制）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_COMMIT = <span class="hljs-number">3</span>     <span class="hljs-comment">// 提交</span>
}
</code></pre>
<h4 data-id="heading-58">执行顺序和时间分配</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">一帧的完整生命周期（16.67ms</span> <span class="hljs-string">@</span> <span class="hljs-string">60fps）：</span>

<span class="hljs-string">VSync</span> <span class="hljs-string">信号到达</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">0-2ms:</span> <span class="hljs-string">CALLBACK_INPUT</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">处理触摸事件</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">分发点击事件</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">更新触摸状态</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">2-4ms:</span> <span class="hljs-string">CALLBACK_ANIMATION</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">ValueAnimator.animateValue()</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">ObjectAnimator</span> <span class="hljs-string">更新属性</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">视图动画更新</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">GapWorker.postFromTraversal()</span> <span class="hljs-string">←</span> <span class="hljs-string">在这里注册预取</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">4-14ms:</span> <span class="hljs-string">CALLBACK_TRAVERSAL</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">ViewRootImpl.performTraversals()</span>
<span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">measure</span> <span class="hljs-string">(测量)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">layout</span> <span class="hljs-string">(布局)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">draw</span> <span class="hljs-string">(绘制)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">生成</span> <span class="hljs-string">DisplayList</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">14-16ms:</span> <span class="hljs-string">CALLBACK_COMMIT</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">提交渲染数据到</span> <span class="hljs-string">RenderThread</span>
<span class="hljs-string">│</span>
<span class="hljs-string">└─</span> <span class="hljs-attr">16ms:</span> <span class="hljs-string">空闲时间</span>
   <span class="hljs-string">└─</span> <span class="hljs-string">GapWorker.run()</span> <span class="hljs-string">←</span> <span class="hljs-string">RecyclerView</span> <span class="hljs-string">预取在这里执行！</span>
</code></pre>
<h4 data-id="heading-59">详细说明每种回调</h4>
<h5 data-id="heading-60">1. CALLBACK_INPUT（输入）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 触摸事件的分发</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRootImpl</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deliverInputEvent</span><span class="hljs-params">(event: <span class="hljs-type">InputEvent</span>)</span></span> {
        <span class="hljs-comment">// 触摸事件会在 CALLBACK_INPUT 阶段处理</span>
        Choreographer.getInstance().postCallback(
            Choreographer.CALLBACK_INPUT,
            { processInputEvent(event) },
            <span class="hljs-literal">null</span>
        )
    }
}

<span class="hljs-comment">// 优先级最高，保证触摸响应快速</span>
</code></pre>
<h5 data-id="heading-61">2. CALLBACK_ANIMATION（动画）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ValueAnimator 的实现</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueAnimator</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 注册动画回调</span>
        AnimationHandler.getInstance().addAnimationFrameCallback(<span class="hljs-keyword">this</span>)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAnimationFrame</span><span class="hljs-params">(frameTime: <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-comment">// 每一帧更新动画值</span>
        <span class="hljs-keyword">val</span> fraction = (frameTime - mStartTime) / mDuration
        <span class="hljs-keyword">val</span> animatedValue = mInterpolator.getInterpolation(fraction)

        <span class="hljs-comment">// 更新属性</span>
        mUpdateListeners.forEach { it.onAnimationUpdate(<span class="hljs-keyword">this</span>) }

        <span class="hljs-keyword">return</span> fraction &lt; <span class="hljs-number">1.0</span> <span class="hljs-comment">// 是否继续动画</span>
    }
}

<span class="hljs-comment">// AnimationHandler 内部使用 CALLBACK_ANIMATION</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimationHandler</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            <span class="hljs-comment">// 执行所有动画</span>
            mAnimationCallbacks.forEach {
                it.doAnimationFrame(frameTimeNanos)
            }

            <span class="hljs-comment">// 如果还有动画，注册下一帧</span>
            <span class="hljs-keyword">if</span> (mAnimationCallbacks.isNotEmpty()) {
                Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addAnimationFrameCallback</span><span class="hljs-params">(callback: <span class="hljs-type">AnimationFrameCallback</span>)</span></span> {
        <span class="hljs-keyword">if</span> (mAnimationCallbacks.isEmpty()) {
            <span class="hljs-comment">// 第一个动画，开始监听帧回调</span>
            Choreographer.getInstance().postFrameCallback(mFrameCallback)
        }
        mAnimationCallbacks.add(callback)
    }
}
</code></pre>
<h5 data-id="heading-62">3. CALLBACK_TRAVERSAL（遍历）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ViewRootImpl 的绘制流程</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRootImpl</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (!mTraversalScheduled) {
            mTraversalScheduled = <span class="hljs-literal">true</span>

            <span class="hljs-comment">// 注册遍历回调</span>
            mChoreographer.postCallback(
                Choreographer.CALLBACK_TRAVERSAL,
                mTraversalRunnable,  <span class="hljs-comment">// 执行 performTraversals</span>
                <span class="hljs-literal">null</span>
            )
        }
    }

    <span class="hljs-keyword">val</span> mTraversalRunnable = Runnable {
        doTraversal()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span></span> {
        performTraversals()
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 1. 测量</span>
        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec)

        <span class="hljs-comment">// 2. 布局</span>
        performLayout(lp, mWidth, mHeight)

        <span class="hljs-comment">// 3. 绘制</span>
        performDraw()
    }
}
</code></pre>
<h5 data-id="heading-63">4. CALLBACK_COMMIT（提交）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 提交渲染数据到 RenderThread</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedRenderer</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_COMMIT 阶段提交</span>
        updateRootDisplayList(view, callbacks)

        <span class="hljs-comment">// 注册 commit 回调</span>
        mChoreographer.postCallback(
            Choreographer.CALLBACK_COMMIT,
            {
                <span class="hljs-comment">// 同步渲染数据</span>
                nSyncAndDrawFrame(mNativeProxy, frameInfo)
            },
            <span class="hljs-literal">null</span>
        )
    }
}
</code></pre>
<h3 data-id="heading-64">Choreographer 工作流程</h3>
<h4 data-id="heading-65">完整的执行流程</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 简化的 Choreographer 源码</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Choreographer</span> {

    <span class="hljs-comment">// 1. 注册回调</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postCallback</span><span class="hljs-params">(callbackType: <span class="hljs-type">Int</span>, action: <span class="hljs-type">Runnable</span>, token: <span class="hljs-type">Any</span>?)</span></span> {
        postCallbackDelayed(callbackType, action, token, <span class="hljs-number">0</span>)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postCallbackDelayed</span><span class="hljs-params">(
        callbackType: <span class="hljs-type">Int</span>,
        action: <span class="hljs-type">Runnable</span>,
        token: <span class="hljs-type">Any</span>?,
        delayMillis: <span class="hljs-type">Long</span>
    )</span></span> {
        <span class="hljs-comment">// 添加到对应类型的队列</span>
        mCallbackQueues[callbackType].addCallbackLocked(action, token)

        <span class="hljs-comment">// 请求 VSync 信号</span>
        scheduleFrameLocked()
    }

    <span class="hljs-comment">// 2. 请求 VSync</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleFrameLocked</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (!mFrameScheduled) {
            mFrameScheduled = <span class="hljs-literal">true</span>

            <span class="hljs-keyword">if</span> (USE_VSYNC) {
                <span class="hljs-comment">// 请求下一个 VSync 信号</span>
                scheduleVsyncLocked()
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 降级：使用普通消息</span>
                <span class="hljs-keyword">val</span> msg = mHandler.obtainMessage(MSG_DO_FRAME)
                mHandler.sendMessageAtTime(msg, nextFrameTime)
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleVsyncLocked</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 向 SurfaceFlinger 请求 VSync 信号</span>
        mDisplayEventReceiver.scheduleVsync()
    }

    <span class="hljs-comment">// 3. 接收 VSync 信号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameDisplayEventReceiver</span> : <span class="hljs-type">DisplayEventReceiver</span>() {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onVsync</span><span class="hljs-params">(
            timestampNanos: <span class="hljs-type">Long</span>,    <span class="hljs-comment">// VSync 时间戳</span>
            physicalDisplayId: <span class="hljs-type">Long</span>,  <span class="hljs-comment">// 显示器 ID</span>
            frame: <span class="hljs-type">Long</span>              <span class="hljs-comment">// 帧号</span>
        )</span></span> {
            <span class="hljs-comment">// VSync 信号到了！</span>
            mTimestampNanos = timestampNanos
            mFrame = frame

            <span class="hljs-comment">// 发送消息到主线程</span>
            <span class="hljs-keyword">val</span> msg = Message.obtain(mHandler, <span class="hljs-keyword">this</span>)
            msg.setAsynchronous(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// 异步消息，优先处理</span>
            mHandler.sendMessageAtTime(msg, timestampNanos / <span class="hljs-number">1_000_000</span>)
        }

        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
            <span class="hljs-comment">// 在主线程执行</span>
            doFrame(mTimestampNanos, mFrame)
        }
    }

    <span class="hljs-comment">// 4. 执行一帧</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>, frame: <span class="hljs-type">Long</span>)</span></span> {
        <span class="hljs-keyword">val</span> startNanos = System.nanoTime()

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 按顺序执行四种回调</span>
            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos)
            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos)
            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos)
            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos)
        } <span class="hljs-keyword">finally</span> {
            mFrameScheduled = <span class="hljs-literal">false</span>
        }

        <span class="hljs-comment">// 检查是否掉帧</span>
        <span class="hljs-keyword">val</span> endNanos = System.nanoTime()
        <span class="hljs-keyword">val</span> durationMillis = (endNanos - startNanos) / <span class="hljs-number">1_000_000</span>

        <span class="hljs-keyword">if</span> (durationMillis &gt; mFrameIntervalNanos / <span class="hljs-number">1_000_000</span>) {
            <span class="hljs-comment">// 超过一帧时间，掉帧了！</span>
            <span class="hljs-keyword">val</span> skippedFrames = (durationMillis / (mFrameIntervalNanos / <span class="hljs-number">1_000_000</span>)).toInt()
            Log.w(TAG, <span class="hljs-string">"Skipped <span class="hljs-variable">$skippedFrames</span> frames! The application may be doing too much work on its main thread."</span>)
        }
    }

    <span class="hljs-comment">// 5. 执行回调队列</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doCallbacks</span><span class="hljs-params">(callbackType: <span class="hljs-type">Int</span>, frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
        <span class="hljs-keyword">val</span> callbacks = mCallbackQueues[callbackType]

        <span class="hljs-comment">// 执行该类型的所有回调</span>
        <span class="hljs-keyword">while</span> (callbacks.hasNext()) {
            <span class="hljs-keyword">val</span> callback = callbacks.next()
            callback.run(frameTimeNanos)
        }
    }
}
</code></pre>
<h4 data-id="heading-66">时序图</h4>
<pre><code class="hljs language-scss" lang="scss">应用进程                          SurfaceFlinger 进程
    │                                   │
    │ <span class="hljs-built_in">scheduleTraversals</span>()              │
    ├─ <span class="hljs-built_in">postCallback</span>(TRAVERSAL)          │
    │                                   │
    │ <span class="hljs-built_in">scheduleVsyncLocked</span>()             │
    ├─────── <span class="hljs-built_in">requestVsync</span>() ──────────→ │
    │                                   │
    │ 等待 VSync...                      │ 下一个 VSync 周期到来
    │                                   │
    │ ←────── <span class="hljs-built_in">onVsync</span>() ────────────── │ 📡 VSync 信号
    │                                   │
    │ <span class="hljs-built_in">doFrame</span>()                         │
    ├─ <span class="hljs-built_in">doCallbacks</span>(INPUT)               │
    ├─ <span class="hljs-built_in">doCallbacks</span>(ANIMATION)           │
    ├─ <span class="hljs-built_in">doCallbacks</span>(TRAVERSAL)           │
    │  └─ <span class="hljs-built_in">performTraversals</span>()           │
    │     ├─ measure                    │
    │     ├─ layout                     │
    │     └─ draw                       │
    ├─ <span class="hljs-built_in">doCallbacks</span>(COMMIT)              │
    │  └─ <span class="hljs-built_in">nSyncAndDrawFrame</span>() ─────────→│ 提交渲染数据
    │                                   │
    │                                   ├─ 合成图层
    │                                   └─ 显示到屏幕
</code></pre>
<h3 data-id="heading-67">掉帧（Jank）分析</h3>
<h4 data-id="heading-68">什么是掉帧？</h4>
<pre><code class="hljs">正常情况（60fps）：

Frame 1      Frame 2      Frame 3      Frame 4
├────────────├────────────├────────────├────────
0ms         16.67ms      33.34ms      50ms

每帧耗时 &lt; 16.67ms ✅
</code></pre>
<pre><code class="hljs">掉帧情况：

Frame 1      Frame 2                    Frame 3
├────────────├─────────────────────────├────────
0ms         16.67ms                   50ms

Frame 2 耗时 33.34ms（跨越 2 个 VSync）⚠️
用户感觉卡顿
</code></pre>
<h4 data-id="heading-69">掉帧检测</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Choreographer 内部的掉帧检测</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>, frame: <span class="hljs-type">Long</span>)</span></span> {
    <span class="hljs-keyword">val</span> startNanos = System.nanoTime()

    <span class="hljs-comment">// 计算应该执行的时间</span>
    <span class="hljs-keyword">val</span> intendedFrameTimeNanos = mLastFrameTimeNanos + mFrameIntervalNanos

    <span class="hljs-comment">// 检查延迟</span>
    <span class="hljs-keyword">val</span> jitterNanos = frameTimeNanos - intendedFrameTimeNanos
    <span class="hljs-keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) {
        <span class="hljs-comment">// 掉帧了！</span>
        <span class="hljs-keyword">val</span> skippedFrames = jitterNanos / mFrameIntervalNanos

        <span class="hljs-keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) {  <span class="hljs-comment">// 默认 30 帧</span>
            Log.i(TAG, <span class="hljs-string">"Skipped <span class="hljs-variable">$skippedFrames</span> frames! "</span> +
                  <span class="hljs-string">"The application may be doing too much work on its main thread."</span>)
        }
    }

    <span class="hljs-comment">// 执行回调...</span>

    <span class="hljs-keyword">val</span> endNanos = System.nanoTime()
    <span class="hljs-keyword">val</span> frameDuration = (endNanos - startNanos) / <span class="hljs-number">1_000_000</span>

    Log.d(<span class="hljs-string">"FrameTime"</span>, <span class="hljs-string">"Frame took <span class="hljs-subst">${frameDuration}</span>ms"</span>)
}
</code></pre>
<h4 data-id="heading-70">常见掉帧原因</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 主线程耗时操作 ❌</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
    <span class="hljs-comment">// 不要在主线程做这些：</span>
    <span class="hljs-keyword">val</span> bitmap = BitmapFactory.decodeFile(<span class="hljs-string">"/sdcard/large_image.jpg"</span>)  <span class="hljs-comment">// IO 操作</span>
    <span class="hljs-keyword">val</span> result = complexCalculation()  <span class="hljs-comment">// 复杂计算</span>
    Thread.sleep(<span class="hljs-number">100</span>)  <span class="hljs-comment">// 阻塞线程</span>

    <span class="hljs-comment">// 必然掉帧！⚠️</span>
}

<span class="hljs-comment">// 2. 布局层级过深 ❌</span>
&lt;LinearLayout&gt;
  &lt;RelativeLayout&gt;
    &lt;FrameLayout&gt;
      &lt;LinearLayout&gt;
        &lt;RelativeLayout&gt;
          &lt;!-- <span class="hljs-number">5</span>层嵌套，measure 和 layout 很慢 --&gt;
        &lt;/RelativeLayout&gt;
      &lt;/LinearLayout&gt;
    &lt;/FrameLayout&gt;
  &lt;/RelativeLayout&gt;
&lt;/LinearLayout&gt;

<span class="hljs-comment">// 3. 过度绘制 ❌</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> {
    <span class="hljs-comment">// 多次绘制同一区域</span>
    canvas.drawColor(Color.WHITE)   <span class="hljs-comment">// 背景</span>
    canvas.drawBitmap(bitmap1, ...)  <span class="hljs-comment">// 图层1</span>
    canvas.drawBitmap(bitmap2, ...)  <span class="hljs-comment">// 图层2</span>
    canvas.drawBitmap(bitmap3, ...)  <span class="hljs-comment">// 图层3（完全覆盖）</span>
    <span class="hljs-comment">// 前面的绘制都浪费了！</span>
}

<span class="hljs-comment">// 4. RecyclerView 创建 ViewHolder ❌</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(...)</span></span>: ViewHolder {
    <span class="hljs-comment">// inflate 很慢（8-10ms）</span>
    <span class="hljs-keyword">val</span> view = LayoutInflater.from(context).inflate(R.layout.complex_item, parent, <span class="hljs-literal">false</span>)
    <span class="hljs-comment">// 滚动时创建会掉帧 ← GapWorker 就是解决这个问题！</span>
}
</code></pre>
<h3 data-id="heading-71">与 RecyclerView 的关系</h3>
<p>RecyclerView 和 GapWorker 如何配合：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// RecyclerView 的渲染流程</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RecyclerView</span> {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(changed: <span class="hljs-type">Boolean</span>, l: <span class="hljs-type">Int</span>, t: <span class="hljs-type">Int</span>, r: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 布局子 View</span>
        dispatchLayout()

        <span class="hljs-comment">// 布局完成后，通知 GapWorker 可以预取了</span>
        <span class="hljs-keyword">if</span> (mPrefetchRegistry != <span class="hljs-literal">null</span>) {
            mPrefetchRegistry.collectPrefetchPositions(
                mLayout,
                mState,
                mGapWorker
            )
        }
    }
}

<span class="hljs-comment">// LayoutManager 收集预取位置</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearLayoutManager</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectAdditionalPrefetchPositions</span><span class="hljs-params">(
        dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>,
        state: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">State</span>,
        layoutPrefetchRegistry: <span class="hljs-type">LayoutPrefetchRegistry</span>
    )</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_ANIMATION 阶段被调用</span>
        <span class="hljs-keyword">val</span> prefetchPosition = getCurrentPosition() + (<span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)
        layoutPrefetchRegistry.addPosition(prefetchPosition, Math.abs(dy))
    }
}

<span class="hljs-comment">// GapWorker 注册回调</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GapWorker</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postFromTraversal</span><span class="hljs-params">(recyclerView: <span class="hljs-type">RecyclerView</span>, dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_TRAVERSAL 完成后被调用</span>

        <span class="hljs-comment">// 注册到下一帧的消息队列（不是 Choreographer 回调）</span>
        recyclerView.post(<span class="hljs-keyword">this</span>)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_COMMIT 之后的空闲时间执行</span>
        <span class="hljs-comment">// 此时一帧的主要工作已完成，可以预取了</span>

        <span class="hljs-keyword">val</span> deadlineNs = System.nanoTime() + <span class="hljs-number">4_000_000</span> <span class="hljs-comment">// 留 4ms</span>
        prefetch(deadlineNs)
    }
}
</code></pre>
<h4 data-id="heading-72">完整的一帧时间线（包含 RecyclerView）</h4>
<pre><code class="hljs language-css" lang="css">VSync 信号
│
├─ <span class="hljs-number">0</span>-<span class="hljs-number">2ms</span>: CALLBACK_INPUT
│  └─ 处理触摸滚动事件
│
├─ <span class="hljs-number">2</span>-<span class="hljs-number">4ms</span>: CALLBACK_ANIMATION
│  ├─ 动画更新
│  └─ LayoutManager.<span class="hljs-built_in">collectPrefetchPositions</span>() ← 收集预取位置
│
├─ <span class="hljs-number">4</span>-<span class="hljs-number">14ms</span>: CALLBACK_TRAVERSAL
│  ├─ RecyclerView.<span class="hljs-built_in">onLayout</span>()
│  ├─ 布局可见的子 View
│  └─ GapWorker.<span class="hljs-built_in">postFromTraversal</span>() ← 注册预取任务
│
├─ <span class="hljs-number">14</span>-<span class="hljs-number">16ms</span>: CALLBACK_COMMIT
│  └─ 提交渲染数据
│
└─ <span class="hljs-number">16ms</span>+: 空闲时间（下一帧之前）
   └─ GapWorker.<span class="hljs-built_in">run</span>() ← 执行预取！✅
      ├─ 创建 ViewHolder (如需要)
      ├─ 绑定数据
      └─ 放入缓存
</code></pre>
<h3 data-id="heading-73">实际应用</h3>
<h4 data-id="heading-74">1. 监控帧率</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FpsMonitor</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mFrameCount = <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mLastTime = <span class="hljs-number">0L</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            mFrameCount++

            <span class="hljs-keyword">val</span> currentTime = System.currentTimeMillis()
            <span class="hljs-keyword">if</span> (currentTime - mLastTime &gt;= <span class="hljs-number">1000</span>) {
                <span class="hljs-comment">// 每秒统计一次</span>
                <span class="hljs-keyword">val</span> fps = mFrameCount
                Log.d(<span class="hljs-string">"FPS"</span>, <span class="hljs-string">"当前帧率: <span class="hljs-variable">$fps</span> fps"</span>)

                <span class="hljs-keyword">if</span> (fps &lt; <span class="hljs-number">55</span>) {
                    Log.w(<span class="hljs-string">"FPS"</span>, <span class="hljs-string">"帧率过低，可能卡顿！"</span>)
                }

                mFrameCount = <span class="hljs-number">0</span>
                mLastTime = currentTime
            }

            <span class="hljs-comment">// 注册下一帧</span>
            Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        mLastTime = System.currentTimeMillis()
        Choreographer.getInstance().postFrameCallback(mFrameCallback)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> {
        Choreographer.getInstance().removeFrameCallback(mFrameCallback)
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">val</span> monitor = FpsMonitor()
monitor.start()
</code></pre>
<h4 data-id="heading-75">2. 检测掉帧</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JankDetector</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mLastFrameTimeNanos = <span class="hljs-number">0L</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameIntervalNanos = <span class="hljs-number">16_666_666L</span> <span class="hljs-comment">// 60fps</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            <span class="hljs-keyword">if</span> (mLastFrameTimeNanos != <span class="hljs-number">0L</span>) {
                <span class="hljs-keyword">val</span> frameDuration = frameTimeNanos - mLastFrameTimeNanos
                <span class="hljs-keyword">val</span> skippedFrames = (frameDuration / mFrameIntervalNanos) - <span class="hljs-number">1</span>

                <span class="hljs-keyword">if</span> (skippedFrames &gt; <span class="hljs-number">0</span>) {
                    Log.w(<span class="hljs-string">"Jank"</span>, <span class="hljs-string">"掉帧 <span class="hljs-variable">$skippedFrames</span> 帧！"</span> +
                          <span class="hljs-string">"耗时: <span class="hljs-subst">${frameDuration / <span class="hljs-number">1</span>_000_000}</span>ms"</span>)

                    <span class="hljs-comment">// 上报到性能监控平台</span>
                    reportJank(skippedFrames, frameDuration)
                }
            }

            mLastFrameTimeNanos = frameTimeNanos

            <span class="hljs-comment">// 继续监听</span>
            Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        Choreographer.getInstance().postFrameCallback(mFrameCallback)
    }
}
</code></pre>
<h4 data-id="heading-76">3. 延迟执行（等待下一帧）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 等待下一帧再执行</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doOnNextFrame</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    Choreographer.getInstance().postFrameCallback {
        action()
    }
}

<span class="hljs-comment">// 使用场景：View 刚创建，等布局完成再操作</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyView</span> : <span class="hljs-type">View</span> {
    <span class="hljs-keyword">init</span> {
        doOnNextFrame {
            <span class="hljs-comment">// 此时 View 已经测量和布局完成</span>
            <span class="hljs-keyword">val</span> width = measuredWidth
            <span class="hljs-keyword">val</span> height = measuredHeight
            <span class="hljs-comment">// 可以安全使用尺寸了</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-77">4. 优化动画</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmoothAnimator</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mStartValue = <span class="hljs-number">0f</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mEndValue = <span class="hljs-number">0f</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mStartTime = <span class="hljs-number">0L</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mDuration = <span class="hljs-number">0L</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            <span class="hljs-keyword">val</span> elapsed = (frameTimeNanos - mStartTime) / <span class="hljs-number">1_000_000</span>
            <span class="hljs-keyword">val</span> fraction = (elapsed.toFloat() / mDuration).coerceIn(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>)

            <span class="hljs-comment">// 计算当前值</span>
            <span class="hljs-keyword">val</span> value = mStartValue + (mEndValue - mStartValue) * fraction

            <span class="hljs-comment">// 更新 UI</span>
            onAnimationUpdate(value)

            <span class="hljs-keyword">if</span> (fraction &lt; <span class="hljs-number">1f</span>) {
                <span class="hljs-comment">// 继续下一帧</span>
                Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">(from: <span class="hljs-type">Float</span>, to: <span class="hljs-type">Float</span>, duration: <span class="hljs-type">Long</span>)</span></span> {
        mStartValue = from
        mEndValue = to
        mDuration = duration
        mStartTime = System.nanoTime()

        Choreographer.getInstance().postFrameCallback(mFrameCallback)
    }

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(value: <span class="hljs-type">Float</span>)</span></span> {
        <span class="hljs-comment">// 子类实现</span>
    }
}
</code></pre>
<h3 data-id="heading-78">高刷新率屏幕支持</h3>
<h4 data-id="heading-79">90Hz / 120Hz / 144Hz 屏幕</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Android 11+ 可以获取屏幕刷新率</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshRateDetector</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRefreshRate</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: <span class="hljs-built_in">Float</span> {
        <span class="hljs-keyword">val</span> display = <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) {
            context.display
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">val</span> wm = context.getSystemService(Context.WINDOW_SERVICE) <span class="hljs-keyword">as</span> WindowManager
            wm.defaultDisplay
        }

        <span class="hljs-keyword">return</span> display?.refreshRate ?: <span class="hljs-number">60f</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getFrameIntervalNanos</span><span class="hljs-params">(refreshRate: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Long</span> {
        <span class="hljs-keyword">return</span> (<span class="hljs-number">1_000_000_000</span> / refreshRate).toLong()
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">val</span> refreshRate = detector.getRefreshRate(context)
Log.d(<span class="hljs-string">"Display"</span>, <span class="hljs-string">"屏幕刷新率: <span class="hljs-variable">$refreshRate</span> Hz"</span>)

<span class="hljs-keyword">when</span> {
    refreshRate &gt;= <span class="hljs-number">120f</span> -&gt; {
        <span class="hljs-comment">// 120Hz: 每帧 8.33ms</span>
        <span class="hljs-comment">// 需要更严格的性能优化</span>
    }
    refreshRate &gt;= <span class="hljs-number">90f</span> -&gt; {
        <span class="hljs-comment">// 90Hz: 每帧 11.11ms</span>
    }
    <span class="hljs-keyword">else</span> -&gt; {
        <span class="hljs-comment">// 60Hz: 每帧 16.67ms</span>
    }
}
</code></pre>
<h3 data-id="heading-80">性能优化建议</h3>
<h4 data-id="heading-81">1. 避免在回调中做耗时操作</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误</span>
Choreographer.getInstance().postFrameCallback {
    <span class="hljs-keyword">val</span> bitmap = loadLargeBitmap()  <span class="hljs-comment">// IO 操作，很慢</span>
    imageView.setImageBitmap(bitmap)
}

<span class="hljs-comment">// ✅ 正确</span>
lifecycleScope.launch {
    <span class="hljs-keyword">val</span> bitmap = withContext(Dispatchers.IO) {
        loadLargeBitmap()  <span class="hljs-comment">// 在后台线程</span>
    }
    imageView.setImageBitmap(bitmap)  <span class="hljs-comment">// 在主线程</span>
}
</code></pre>
<h4 data-id="heading-82">2. 使用 Systrace 分析</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 抓取 Systrace</span>
python systrace.py -a com.your.package -t 10 -o trace.html \
  gfx view res dalvik <span class="hljs-built_in">sched</span> freq idle

<span class="hljs-comment"># 分析要点：</span>
<span class="hljs-comment"># 1. 查看每一帧的耗时</span>
<span class="hljs-comment"># 2. 找出超过 16.67ms 的帧</span>
<span class="hljs-comment"># 3. 分析是哪个阶段慢（input/animation/traversal/commit）</span>
<span class="hljs-comment"># 4. 定位具体的慢方法</span>
</code></pre>
<h4 data-id="heading-83">3. 减少布局层级</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ❌ 过深的层级 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>

<span class="hljs-comment">&lt;!-- ✅ 扁平化 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ConstraintLayout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ConstraintLayout</span>&gt;</span>
</code></pre>
<h4 data-id="heading-84">4. 使用硬件加速</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 在 AndroidManifest.xml 中启用 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 为特定 View 启用</span>
view.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="hljs-literal">null</span>)
</code></pre>
<hr/>
<h3 data-id="heading-85">总结</h3>
<h4 data-id="heading-86">RecyclerView 核心要点</h4>
<ol>
<li><strong>四级缓存</strong>：极致的复用机制</li>
<li><strong>ViewHolder</strong>：避免重复 findViewById</li>
<li><strong>精确通知</strong>：告诉 RecyclerView 具体哪里变了</li>
<li><strong>位置管理</strong>：维护复杂的位置映射关系</li>
</ol>
<h4 data-id="heading-87">GapWorker 核心要点</h4>
<ol>
<li><strong>预取机制</strong>：在空闲时间提前准备 ViewHolder</li>
<li><strong>优先级调度</strong>：按距离和紧急程度排序</li>
<li><strong>时间控制</strong>：默认最多占用 4ms</li>
<li><strong>数据一致性</strong>：必须使用精确的 notify 方法</li>
</ol>
<h4 data-id="heading-88">Choreographer 核心要点</h4>
<ol>
<li><strong>编舞者</strong>：协调输入、动画、绘制的时间</li>
<li><strong>VSync 同步</strong>：所有渲染操作对齐到 VSync 信号</li>
<li><strong>四种回调</strong>：INPUT → ANIMATION → TRAVERSAL → COMMIT</li>
<li><strong>掉帧检测</strong>：超过 16.67ms 就会掉帧</li>
</ol>
<h4 data-id="heading-89">三者关系</h4>
<pre><code class="hljs language-objectivec" lang="objectivec">Choreographer (编舞者)
    │
    ├─ <span class="hljs-built_in">CALLBACK_INPUT</span>: 处理触摸滚动
    │
    ├─ <span class="hljs-built_in">CALLBACK_ANIMATION</span>: 收集预取位置
    │
    ├─ <span class="hljs-built_in">CALLBACK_TRAVERSAL</span>: RecyclerView 布局
    │   └─ 使用四级缓存快速复用 ViewHolder
    │
    ├─ <span class="hljs-built_in">CALLBACK_COMMIT</span>: 提交渲染
    │
    └─ 空闲时间: GapWorker 预取
        └─ 避免下一帧创建 ViewHolder 导致掉帧
</code></pre>
<h4 data-id="heading-90">崩溃根本原因</h4>
<p><strong>数据改变和通知不同步，导致位置信息不一致</strong></p>
<ul>
<li>GapWorker 在空闲时间预取</li>
<li>主线程同时删除数据</li>
<li>使用 <code>notifyDataSetChanged()</code> 异步通知</li>
<li>GapWorker 使用旧的位置信息 → 崩溃</li>
</ul>
<p><strong>解决方案</strong>：使用 <code>notifyItemRemoved()</code> 同步更新位置</p>
<hr/>
<blockquote>
<p>文档生成时间：2025-11-10
文档版本：1.0
适用于：Android 开发者深入理解渲染机制</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring AI 实战——提交用于生成的提示词]]></title>    <link>https://juejin.cn/post/7570901172526940195</link>    <guid>https://juejin.cn/post/7570901172526940195</guid>    <pubDate>2025-11-10T09:57:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526940195" data-draft-id="7570909641682321448" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring AI 实战——提交用于生成的提示词"/> <meta itemprop="keywords" content="Spring,AI编程,LLM"/> <meta itemprop="datePublished" content="2025-11-10T09:57:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="数据智能老司机"/> <meta itemprop="url" content="https://juejin.cn/user/430664289626439"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring AI 实战——提交用于生成的提示词
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664289626439/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    数据智能老司机
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:57:05.000Z" title="Mon Nov 10 2025 09:57:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">本章内容</h2>
<ul>
<li>定义提示模板（prompt templates）</li>
<li>提供上下文</li>
<li>格式化响应输出</li>
<li>流式传输响应</li>
<li>访问响应元数据</li>
</ul>
<p>在第 1 章中，你创建了一个非常简单的 Spring AI 应用：它在 POST 请求里接收一个问题，并通过注入的 <code>ChatClient</code> 直接提交给 LLM。它运行良好，但随着你的生成式 AI 需求变得更高级，你发给 LLM 的提示也会随之复杂化。此时，基于 <code>String</code> 的提示可能就不够用了。</p>
<p>另外，生成的响应也不仅仅是一个简单的字符串。结果中可能包含有用的<strong>元数据</strong>，例如<strong>用量数据</strong>，帮助你评估每次生成对计费的影响。响应还可以<strong>分片流式返回</strong>给客户端，而不是一次性返回完整结果。</p>
<p>本章将把你的提示与响应处理提升到新水平。先从<strong>如何定义提示模板</strong>开始。</p>
<h2 data-id="heading-1">3.1 使用提示模板（Working with prompt templates）</h2>
<p>Spring AI 支持<strong>从模板创建提示</strong>。模板由固定文本与一个或多个<strong>占位符</strong>组成。如图 3.1 所示，这些模板的占位符将由“模型数据”在每次调用时填充，以生成要发送给 LLM 的提示。模型数据被填入占位符，外层由提示文本包裹，引导 LLM 应当如何作答。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe4e4863ad35460fa114d776132969b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=2FSRnk0GhyxxCAGTmkdzD7RccC8%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.1</strong> 使用提示模板由模型数据生成提示</p>
<p>为了演示提示模板如何工作，我们从第 1 章的示例出发，把它扩展为能回答各类<strong>桌面游戏</strong>（如跳棋、Monopoly，或更现代的欧式桌游如 Catan、Wingspan）的问答。</p>
<p>首先，需要在 <code>Question</code> 记录类型中加入<strong>游戏标题</strong>：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.boardgamebuddy</span>;

<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">jakarta</span><span class="hljs-selector-class">.validation</span><span class="hljs-selector-class">.constraints</span><span class="hljs-selector-class">.NotBlank</span>;

<span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">record</span> <span class="hljs-selector-tag">Question</span>(
    <span class="hljs-variable">@NotBlank</span>(message = <span class="hljs-string">"Game title is required"</span>) String gameTitle,
    <span class="hljs-variable">@NotBlank</span>(message = <span class="hljs-string">"Question is required"</span>) String question) {
}
</code></pre>
<p>这个新版 <code>Question</code> 增加了 <code>gameTitle</code> 属性，用于承载游戏名。这样即便问题本身未提到游戏名，也能提供足够上下文来回答关于某款游戏的提问。</p>
<p>你也会注意到两个属性都标注了 <code>@NotBlank</code>。虽然<strong>校验</strong>不是 Spring AI 的特性，但它是 Spring 本身非常重要且有用的功能。用 <code>@NotBlank</code> 声明它们都是<strong>必填</strong>的，且不能为 <code>null</code> 或去空白后变成空字符串。</p>
<p>要启用 <code>@NotBlank</code> 以及 Spring 的校验支持，需要在构建中加入如下 starter 依赖：</p>
<pre><code class="hljs language-arduino" lang="arduino">implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-validation'</span>
</code></pre>
<p>同时，需要在控制器的 <code>ask()</code> 方法里给 <code>Question</code> 参数添加 <code>@Valid</code>，以便 Spring 在处理该控制器的请求时执行校验：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@PostMapping</span>(path=<span class="hljs-string">"/ask"</span>, produces=<span class="hljs-string">"application/json"</span>)
public Answer <span class="hljs-built_in">ask</span>(<span class="hljs-variable">@RequestBody</span> <span class="hljs-variable">@Valid</span> Question question) {
  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">boardGameService</span><span class="hljs-selector-class">.askQuestion</span>(question);
}
</code></pre>
<p>最后，为了把校验错误<strong>整齐地</strong>以 JSON 形式返回，下面的控制器增强（advice）类利用了 Spring 对 <strong>Problem Details（RFC-7807）</strong> 的支持（<a href="https://link.juejin.cn?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc7807" target="_blank" title="https://datatracker.ietf.org/doc/html/rfc7807" ref="nofollow noopener noreferrer">datatracker.ietf.org/doc/html/rf…</a>）。</p>
<p><strong>清单 3.1 使用 Problem Details 优雅返回校验错误</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.context.MessageSourceResolvable;
<span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;
<span class="hljs-keyword">import</span> org.springframework.http.ProblemDetail;
<span class="hljs-keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ExceptionHandler;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestControllerAdvice;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@RestControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandlerAdvice</span> {

  <span class="hljs-meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span>
  <span class="hljs-keyword">public</span> ProblemDetail handleValidationExceptions(
                              MethodArgumentNotValidException ex) {
    <span class="hljs-keyword">var</span> problemDetail =  ProblemDetail
        .forStatusAndDetail(HttpStatus.BAD_REQUEST, <span class="hljs-string">"Validation failed"</span>);

    <span class="hljs-keyword">var</span> validationMessages = ex.getBindingResult().getAllErrors()
        .stream()
        .map(MessageSourceResolvable::getDefaultMessage)
        .toList();

    problemDetail.setProperty(<span class="hljs-string">"validationErrors"</span>, validationMessages);
    <span class="hljs-keyword">return</span> problemDetail;
  }

}
</code></pre>
<p>简而言之，<strong>Problem Details</strong> 是一种对 HTTP API 错误进行<strong>标准化结构化</strong>的规范。自 Spring 6.0 起，Spring 就提供了一等的 Problem Details 支持。当应用了 Problem Details 且<strong>校验失败</strong>（例如请求未提供游戏名）时，客户端会收到类似这样的标准响应：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"detail"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Validation failed"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"instance"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/ask"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">400</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"title"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Bad Request"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"about:blank"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"validationErrors"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"Game title is required"</span>
    <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>现在把注意力转向<strong>响应</strong>。与 <code>Question</code> 一样，你还希望在 <code>Answer</code> 记录类型中加入<strong>游戏标题</strong>，让 API 客户端知道这条答案对应的是哪款游戏：</p>
<pre><code class="hljs language-arduino" lang="arduino">package com.example.boardgamebuddy;

<span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Answer</span><span class="hljs-params">(<span class="hljs-type">String</span> gameTitle, <span class="hljs-type">String</span> answer)</span> </span>{
}
</code></pre>
<p>既然 <code>Question</code> 与 <code>Answer</code> 都包含了游戏名，你可以把 <code>SpringAiBoardGameService</code> 中的 <code>askQuestion()</code> 简化为<strong>字符串拼接</strong>生成提示：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">Answer</span> <span class="hljs-title function_">askQuestion</span>(<span class="hljs-params">Question question</span>) {
  <span class="hljs-title class_">String</span> prompt =
      <span class="hljs-string">"Answer this question about "</span> + question.<span class="hljs-title function_">gameTitle</span>() +
      <span class="hljs-string">": "</span> + question.<span class="hljs-title function_">question</span>();

  <span class="hljs-title class_">String</span> answerText = chatClient.<span class="hljs-title function_">prompt</span>()
      .<span class="hljs-title function_">user</span>(prompt)
      .<span class="hljs-title function_">call</span>()
      .<span class="hljs-title function_">content</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(question.<span class="hljs-title function_">gameTitle</span>(), answerText);
}
</code></pre>
<p>现在可以在请求中带上游戏名来提问了。比如用 HTTPie 向经典的 <strong>checkers（跳棋）</strong> 提问：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"checkers"</span> \
question=<span class="hljs-string">"How many pieces are there?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"In checkers, there are a total of 24 pieces-12 for each player."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"checkers"</span>
}
</code></pre>
<p>底层 LLM 能基于自身训练回答关于跳棋的问题。这种方式适用于<strong>知名游戏</strong>（如跳棋、国际象棋）；但对于<strong>较新/不那么出名</strong>的游戏可能会吃力。下一章我们会看到如何让 LLM 回答<strong>超出其训练范围</strong>的问题。</p>
<p>虽然能用，但通过<strong>字符串拼接</strong>来构建提示很笨拙。即便是 <code>askQuestion()</code> 中这样简单的提示，也会让代码读写不便。</p>
<h3 data-id="heading-2">3.1.1 定义提示模板（Defining a prompt template）</h3>
<p>与其用字符串拼接，不如创建一个<strong>提示模板</strong>，把“原始、未渲染的提示”写成带占位符的模板。下面清单展示了修改后的 <code>SpringAiBoardGameService</code>，它使用了模板化提示。</p>
<p><strong>清单 3.2 使用提示模板，避免笨拙的字符串拼接</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringAiBoardGameService</span><span class="hljs-params">(ChatClient.Builder chatClientBuilder)</span> {
    <span class="hljs-built_in">this</span>.chatClient = chatClientBuilder.build();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">questionPromptTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""
      Answer this question about {game}: {question}
      """</span>;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Answer <span class="hljs-title function_">askQuestion</span><span class="hljs-params">(Question question)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">answerText</span> <span class="hljs-operator">=</span> chatClient.prompt()
        .user(userSpec -&gt; userSpec
            .text(questionPromptTemplate)
            .param(<span class="hljs-string">"gameTitle"</span>, question.gameTitle())
            .param(<span class="hljs-string">"question"</span>, question.question()))
        .call()
        .content();

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(question.gameTitle(), answerText);
  }

}
</code></pre>
<p>如你所见，名为 <code>questionPromptTemplate</code> 的提示模板看起来与此前拼接出来的提示很像，但它不仅仅是文本。它是一个 <strong>StringTemplate</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.stringtemplate.org%2F" target="_blank" title="https://www.stringtemplate.org/" ref="nofollow noopener noreferrer">www.stringtemplate.org/</a>），其中包含每个参数的占位符<code>{game}</code> 与 <code>{question}</code>。</p>
<p>由于存在占位符，这个模板<strong>不能</strong>直接作为普通字符串提交；你还必须<strong>提供用于填充占位符的值</strong>。</p>
<p>因此，在 <code>askQuestion()</code> 中，<code>user()</code> 不是接收模板字符串本身，而是接收一个<strong>lambda</strong>。更具体地说，这个 lambda 实现了 <code>Consumer&lt;UserSpec&gt;</code> 接口，让你能<strong>定制</strong>要发送给 LLM 的消息。</p>
<p>在本例中，通过在 <code>userSpec</code> 上调用 <code>text()</code> 指定用户消息的正文（也就是提示模板），再通过多次调用 <code>param()</code> 为每个参数设置值。在提示发送给 LLM 之前，占位符会被这些参数值<strong>填充</strong>，从而形成完整的提示消息。图 3.2 演示了这个过程。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3796ed3650564abf8d3a03690500a0dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=y%2F72E1HNRGn4RHmbAwIYaQxATuQ%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.2</strong> 提示模板把模型数据渲染进提示，再提交给 LLM</p>
<p><code>askQuestion()</code> 余下的代码与之前相同：<code>call()</code> 表示提示已准备就绪并发送；<code>content()</code> 返回答案文本。</p>
<p>重新启动应用，再次提交请求，它应当像之前一样工作（由于生成式 AI 的<strong>非确定性</strong>，回答的措辞可能略有变化）。你也可以试着询问<strong>其他桌游</strong>来看看回答情况。</p>
<p>现在，提示的核心集中在一个地方——那个<strong>静态字符串常量</strong>——可读且易维护，尽管在 <code>askQuestion()</code> 里多了几行代码。既然更易维护了，我们就做点<strong>提示工程（prompt engineering）</strong> ，把模板再优化一下。例如改为：</p>
<pre><code class="hljs language-ini" lang="ini">private static final String <span class="hljs-attr">questionPromptTemplate</span> = <span class="hljs-string">"""
    You are a helpful assistant, answering questions about tabletop games.
    If you don't know anything about the game or don't know the answer,
    say "I don't know".

    The game is {game}.

    The question is: {question}.
    """</span><span class="hljs-comment">;</span>
</code></pre>
<p>这个新模板为 LLM 设置了更多<strong>角色与期望上下文</strong>：告诉它自己是一个有用的助手、要回答<strong>桌面游戏</strong>相关的问题；还要求它在不知道答案或不了解该游戏时<strong>明确承认不知道</strong>。</p>
<p>像这样的小小提示工程技巧，能帮助你从提示中获得更好的结果。更多提示工程建议可参考 <strong>Prompt Engineering Guide</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.promptingguide.ai%2F" target="_blank" title="https://www.promptingguide.ai/" ref="nofollow noopener noreferrer">www.promptingguide.ai/</a>）。</p>
<h3 data-id="heading-3">3.1.2 将模板作为资源导入（Importing the template as a resource）</h3>
<p>把提示模板的字符串提取成常量，有助于整理 <code>askQuestion()</code> 方法，让代码更易读、也更便于调整提示。但你还能再进一步：把模板<strong>抽到外部文件</strong>。这样既能让模板与 Java 源码分离，又仍可将模板纳入代码仓库管理。</p>
<p>为此，先在项目的 <code>src/main/resources</code> 目录下创建名为 <strong><code>promptTemplates</code></strong> 的新目录。在新目录里创建文件 <strong><code>questionPromptTemplate.st</code></strong>，内容如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">You are a helpful assistant, answering questions about tabletop games.
<span class="hljs-keyword">If</span> you don<span class="hljs-comment">'t know anything about the game or don't know the answer,</span>
say <span class="hljs-string">"I don't know"</span>.

Answer <span class="hljs-keyword">in</span> complete sentences.

The game <span class="hljs-built_in">is</span> {gameTitle}.

The question <span class="hljs-built_in">is</span>: {question}.
</code></pre>
<p><strong>NOTE</strong> 目录名与模板文件名可以随意取；只要在把模板注入到 <code>SpringAiBoardGameService</code> 时<strong>正确引用</strong>即可。</p>
<p>（尽管你把代码提交到 GitHub 时它可能会提示别的），扩展名 <strong><code>.st</code></strong> 表示这是一个 <strong>StringTemplate</strong> 文件（并不是 Smalltalk 文件）。可以看到，这个 StringTemplate 文件的文本与之前定义的静态字符串常量相同。但现在模板在独立文件中，模板的细节可与“提交提示的代码”分开维护。</p>
<p>基于此，你需要修改 <code>SpringAiBoardGameService</code> 来引用该模板文件。删除静态字符串常量，改为如下字段：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/questionPromptTemplate.st"</span>)</span>
Resource questionPromptTemplate;
</code></pre>
<p><code>@Value</code> 注解使用 <code>classpath:</code> 前缀来引用模板文件，本质上是把它注入到一个 <code>Resource</code> 属性中。注意，这个 <code>Resource</code> 属性的名字与原先的字符串常量相同。<code>user</code> 规格的 <code>text()</code> 方法是<strong>重载</strong>的，既可接受 <code>String</code>，也可接受 <code>Resource</code>。因此把该 <code>Resource</code> 命名为 <code>questionPromptTemplate</code> 后，你<strong>无需修改</strong> <code>askQuestion()</code> 方法里对模板的使用。</p>
<p>重启应用，继续就游戏提问；行为依旧与之前相同。尽管应用外在行为没变，但内部实现更整洁；对模板的任何调整，都可以与 <code>SpringAiBoardGameService</code> 代码<strong>解耦</strong>地完成。</p>
<p>如果你询问 checkers、chess 或其他知名游戏，很可能会得到正确答案。但假设你问的是模型未被训练过的游戏。例如试着询问纸牌游戏 <strong>Burger Battle</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.burgerbattlegame.com%2F" target="_blank" title="https://www.burgerbattlegame.com/" ref="nofollow noopener noreferrer">www.burgerbattlegame.com/</a>）。理想情况下，如果它不知道答案，它会说 “I don't know”：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
question=<span class="hljs-string">"What is the Grave Digger card?"</span> -b
{
    <span class="hljs-string">"answer"</span>: <span class="hljs-string">"I don't know."</span>,
    <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"Burger Battle"</span>
}
</code></pre>
<p>尽管模板明确要求“不会就说 I don't know”，你仍有相当概率得到<strong>瞎编</strong>的答案：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
question=<span class="hljs-string">"What is the Destroy card?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"In Burger Battle, the Destroy card is a special card that allows
      players to eliminate one ingredient card from an opponent's burger."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"Burger Battle"</span>
}
</code></pre>
<p>如果你玩过——或读过——Burger Battle 的规则，你会知道这答案是<strong>错误的</strong>。这就是与 LLM 共事时一个不太妙、但有时颇具“喜剧效果”的特性：当它对某话题训练不足时，可能<strong>编造</strong>一个完全不真实的答案——通常称为<strong>幻觉（hallucinations）</strong> 。</p>
<p>避免幻觉的几种方式包括：</p>
<ul>
<li>训练你自己的模型</li>
<li>对现有模型进行微调（fine-tuning）</li>
<li>在提示中提供<strong>额外上下文</strong></li>
</ul>
<p>从根本上说，训练或微调（更不用说能基于私有数据定制模型）是避免幻觉的上策，但这很难，且需要<strong>数据科学</strong>领域的技能而非软件开发技能。此外，训练/微调要想做得好，需要<strong>大量数据</strong>，也非常耗时——可能是数小时、数天，甚至数周。以我们构建的桌游示例为例，因应新品发布<strong>立即</strong>为其“加入一个游戏”的做法就不可行。</p>
<p>相较之下，在提示中添加<strong>一些上下文</strong>几乎就像添加问题本身那样简单——在提交提示的<strong>即时</strong>阶段完成。因此，它比训练/微调要<strong>简单得多</strong>。</p>
<p>下面看看如何在提示中连同问题一起提供<strong>额外上下文</strong>。这将为下一章的 <strong>RAG（检索增强生成）</strong> 做铺垫——RAG 是一种更高级的方法，能在不超限的情况下为提示添加相关上下文。</p>
<h2 data-id="heading-4">3.2 用上下文“填充”提示（Stuffing the prompt with context）</h2>
<p>回想你上学时，可能遇到过<strong>开卷考试</strong>。这时，你不必把所有内容<strong>死记</strong>在脑子里：即便你没复习，也能翻书找到过关所需的答案。</p>
<p>在生成式 AI 中，常被称为 <strong>“stuffing the prompt（填充提示）”</strong> 的技巧，就像给 LLM 进行一次“开卷考试”。除了把问题提交给 LLM 生成外，你还提供一段<strong>额外文本</strong>供它参考。这样，LLM 即便未在该主题上预训练，也能回答相关问题。</p>
<p>为了让 <strong>Board Game Buddy</strong> 能准确回答 <strong>Burger Battle</strong>（LLM 未训练过的游戏）的问题，我们给它来一场“开卷”：把<strong>游戏规则</strong>作为上下文加入提示。最直接的方式是创建一个<strong>纯文本文件</strong>来存放该游戏规则。</p>
<p><strong>Burger Battle</strong> 的规则（<a href="https://link.juejin.cn?target=https%3A%2F%2Fmng.bz%2FyNKo" target="_blank" title="https://mng.bz/yNKo" ref="nofollow noopener noreferrer">mng.bz/yNKo</a>）相对较短，但仍然太长，不适合原文印在书里。至少，为了让 LLM 能回答 Destroy 卡或其他战斗卡相关问题，创建一个包含以下内容的文件：</p>
<pre><code class="hljs language-python" lang="python">* Burger Bomb: Blow up another playe<span class="hljs-string">r's Burger by sending their ingredients
to the Graveyard.
* Burger Force Field: Your Burger is now protected from all Battle Cards
* Burgerpocalypse: Obliterate all players'</span> ingredients, including your own,
<span class="hljs-keyword">and</span> toss them <span class="hljs-keyword">in</span> the Graveyard.
* Destroy!: Destroy <span class="hljs-built_in">any</span> Battle Card of yours <span class="hljs-keyword">or</span> another playe<span class="hljs-string">r's and toss
it in the Graveyard.
* Gonna Eat That?: Steal another player'</span>s ingredient <span class="hljs-keyword">and</span> add it to your
Burger.
* Grave Digger: Dig through the Graveyard <span class="hljs-keyword">for</span> <span class="hljs-built_in">any</span> needed ingredient <span class="hljs-keyword">and</span> add
it to your Burger.
* I Got Nothin<span class="hljs-string">': Toss your hand in the Graveyard and draw 5 new cards
* More Meat!: Make another player'</span>s Burger a double-decker by adding an
extra Meat to their ingredients <span class="hljs-built_in">list</span>.
* Pickle Plague: Rain vengeance down upon another player by adding Pickles
to their ingredients <span class="hljs-built_in">list</span>.
* Picky Eater: Throw another playe<span class="hljs-string">r's Lettuce, Tomato, or Onion in the
Graveyard.
* The Old Switcheroo: Trade hands with another player.
* Yours Looks Good!: Trade your Burger and all of your ingredients with
another player, including added Battle Cards.
</span></code></pre>
<p>把这个文件放到 <code>src/main/resources</code> 下新建的 <strong><code>gameRules</code></strong> 目录，命名为 <strong><code>burger_battle.txt</code></strong>。</p>
<p>接下来，需要修改模板，加入一个<strong>规则占位符</strong>：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">You are a helpful assistant, answering questions about tabletop games.
<span class="hljs-keyword">If</span> available, use the rules <span class="hljs-keyword">in</span> the RULES section below.
<span class="hljs-keyword">If</span> you don<span class="hljs-comment">'t know anything about the game or don't know the answer,</span>
say <span class="hljs-string">"I don't know"</span>.

Answer <span class="hljs-keyword">in</span> complete sentences.

The game <span class="hljs-built_in">is</span> {gameTitle}.

The question <span class="hljs-built_in">is</span>: {question}.

<span class="hljs-symbol">RULES:</span>
{rules}
</code></pre>
<p>注意，除了新增 <code>{rules}</code> 占位符之外，文本中还加入了<strong>指令</strong>，告诉 LLM：如果有规则可用，请使用它们。</p>
<p>在把规则注入提示之前，需要先把规则<strong>读入一个字符串</strong>。为此，创建一个类似下方清单的服务类。</p>
<p><strong>清单 3.3 <code>GameRulesService</code> 将游戏规则加载为字符串</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.core.io.DefaultResourceLoader;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameRulesService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span>
      LoggerFactory.getLogger(GameRulesService.class);

  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRulesFor</span><span class="hljs-params">(String gameName)</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-type">var</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> String.format(
          <span class="hljs-string">"classpath:/gameRules/%s.txt"</span>,
          gameName.toLowerCase().replace(<span class="hljs-string">" "</span>, <span class="hljs-string">"_"</span>));

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResourceLoader</span>()
          .getResource(filename)
          .getContentAsString(Charset.defaultCharset()); \
           } <span class="hljs-keyword">catch</span> (IOException e) {
      LOG.info(<span class="hljs-string">"No rules found for game: "</span> + gameName);
      <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    }
  }

}
</code></pre>
<p>简而言之，<code>getRulesFor()</code> 会通过 <code>Resource</code> 把某个游戏的规则<strong>加载为字符串</strong>。由于资源路径会随游戏名变化，无法像模板那样用 <code>@Value</code> 固定注入，因此 <code>getRulesFor()</code> 借助了一些 Spring 的工具类来构造 <code>Resource</code>。</p>
<p>在构造规则路径时，<code>getRulesFor()</code> 会把游戏标题<strong>转为小写</strong>并把空格替换为下划线，避免因大小写或空格差异导致标题与文件名不一致。例如如果 <code>Question</code> 中传入的游戏名是 “Burger battle”，它会被规范化为 <code>burger_battle</code>。</p>
<p>现在可以修改 <code>SpringAiBoardGameService</code>，把规则加入提示。首先把 <code>GameRulesService</code> 注入进来：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-title">implements</span> <span class="hljs-title">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GameRulesService gameRulesService;

  <span class="hljs-keyword">public</span> SpringAiBoardGameService(
      ChatClient.Builder chatClientBuilder,
      GameRulesService gameRulesService) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
    <span class="hljs-keyword">this</span>.gameRulesService = gameRulesService;
  }

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>然后，修改 <code>askQuestion()</code>，调用 <code>GameRulesService</code> 读取规则，并通过再调用一次 <code>param()</code> 把规则作为参数加入用户消息规格：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Override</span>
public Answer <span class="hljs-built_in">askQuestion</span>(Question question) {
  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">gameRules</span> = <span class="hljs-selector-tag">gameRulesService</span><span class="hljs-selector-class">.getRulesFor</span>(question.<span class="hljs-built_in">gameTitle</span>());

  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">answerText</span> = <span class="hljs-selector-tag">chatClient</span><span class="hljs-selector-class">.prompt</span>()
      <span class="hljs-selector-class">.user</span>(userSpec -&gt; userSpec
          .<span class="hljs-built_in">text</span>(questionPromptTemplate)
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"gameTitle"</span>, question.<span class="hljs-built_in">gameTitle</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"question"</span>, question.<span class="hljs-built_in">question</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"rules"</span>, gameRules))
      <span class="hljs-selector-class">.call</span>()
      <span class="hljs-selector-class">.content</span>();

  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Answer</span>(question.<span class="hljs-built_in">gameTitle</span>(), answerText);
}
</code></pre>
<p>现在可以试一试了。重启应用，再次询问 Burger Battle 的 <strong>Destroy</strong> 卡：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
question=<span class="hljs-string">"What is the Destroy card?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"The Destroy card in Burger Battle allows you to destroy any
      Battle Card, whether it belongs to you or another player, and then
      place it in the Graveyard."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"Burger Battle"</span>
}
</code></pre>
<p>太棒了！这次答案<strong>正确</strong>，而且显然是从提示中给定的<strong>上下文</strong>抽取出来的。</p>
<p>为确保其他游戏也能正常回答，再试一次。这次问 <strong>chess</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"chess"</span> \
question=<span class="hljs-string">"How are knights allowed to move?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"In chess, knights move in an L-shape: two squares in one
      direction, and then one square perpendicular to that. Knights are the
      only pieces that can jump over other pieces on the board."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"chess"</span>
}
</code></pre>
<p>即使应用<strong>没有</strong>从资源中加载国际象棋的规则，模型也能回答，因为它已在训练中学过国际象棋规则。</p>
<p>需要理解的是：<strong>更多上下文</strong>意味着提示中会有<strong>更多输入 token</strong>。例如提问国际象棋时没有额外上下文，提示只有 <strong>75 个 token</strong>；而 Burger Battle 的问题（即便只包含一小段规则）提示 token 数是 <strong>315</strong> —— 是无上下文时的 <strong>4 倍多</strong>。</p>
<p>至少，token 数会影响<strong>成本</strong>：提示（以及响应）中的 token 越多，付费就越多。很多 LLM（如 GPT-4o）在每 1,000 token 的价格上非常便宜，但随着使用时间增长，也会累积。</p>
<p>更进一步，如果提示里 token 太多，可能会<strong>超出上下文窗口</strong>的限制。以 GPT-4o 为例，窗口为 <strong>128K</strong> token，远超我们这个简单示例的需求。大多数桌游的规则都能轻松落在 128K 内，但在其他领域，把大体量文档作为上下文就<strong>很可能</strong>超限。</p>
<p>在下一章里，你将学习如何使用 <strong>RAG（检索增强生成）</strong> ，在不超限的情况下，为提示提供<strong>相关的上下文</strong>。在引入 RAG 之前，关于提示我们还有一些内容要探索，比如<strong>提示角色（prompt roles）</strong> 的用法。</p>
<h2 data-id="heading-5">3.3 为提示分配角色（Assigning prompt roles）</h2>
<p>包括 OpenAI、MistralAI、Anthropic 在内的许多 LLM，都支持把一个提示切分为多条<strong>消息</strong>，每条消息都归属于某个<strong>角色</strong>，模型应按该角色来理解这段内容。常见的角色包括：</p>
<ul>
<li><strong>User（用户）</strong> ——来自应用用户（或代表用户）的提问或陈述。</li>
<li><strong>System（系统）</strong> ——应用本身给 LLM 的指令。</li>
<li><strong>Assistant（助手）</strong> ——LLM 的响应内容。</li>
<li><strong>Tool（工具）</strong> ——调用外部工具以执行某些操作或获取额外上下文的指令。</li>
</ul>
<p>现在我们先聚焦 <strong>user</strong> 与 <strong>system</strong> 消息。<strong>assistant</strong> 消息在与 LLM 的<strong>多轮对话</strong>中才会用到，第 5 章会详细讨论。第 6 章则会看到 <strong>tool</strong> 消息如何通过对接 API 让 AI 交互更具动态性。</p>
<blockquote>
<p><strong>NOTE</strong> 并非所有 LLM API 都支持相同的消息角色选择。如果某个 API 不支持 <strong>System</strong> 角色，Spring AI 会把原本用于 System 角色的文本直接合并进 <strong>User</strong> 消息里。</p>
</blockquote>
<p>到目前为止，我们一直通过 <code>user()</code> 方法来指定提示，也就是说，这些提示在语义上都属于<strong>用户消息</strong>。例如，在当前代码基础上询问“checkers（跳棋）有多少棋子”，Spring AI 会向 OpenAI 发送如下 JSON（作为 POST 请求体）：</p>
<pre><code class="hljs language-swift" lang="swift">{
  <span class="hljs-string">"messages"</span>: [
    {
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"You are a helpful assistant, answering questions about
          tabletop games.<span class="hljs-subst">\n</span>If available, use the rules in the RULES section
          below.<span class="hljs-subst">\n</span>If you don't know anything about the game or don't know the
          answer,<span class="hljs-subst">\n</span>say "</span><span class="hljs-type">I</span> don't know<span class="hljs-string">".<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>The game is checkers.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>The
          question is: How many pieces are there?.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>RULES:<span class="hljs-subst">\n</span>"</span>,
      <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>
    }
  ],
  <span class="hljs-string">"model"</span>: <span class="hljs-string">"gpt-4o"</span>,
  <span class="hljs-string">"stream"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.7</span>
}
</code></pre>
<p>可以看到这里只有一条消息，内容是整个提示，角色是 <strong>user</strong>。这能工作，但<strong>还能更好</strong>。</p>
<h4 data-id="heading-6">检查 Spring AI 的请求与响应</h4>
<p>如果你想查看使用 Spring AI 提交提示时的<strong>原始请求与响应 JSON</strong>，可以在项目里加入 Logbook（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzalando%2Flogbook" target="_blank" title="https://github.com/zalando/logbook" ref="nofollow noopener noreferrer">github.com/zalando/log…</a>）依赖：</p>
<pre><code class="hljs language-arduino" lang="arduino">implementation <span class="hljs-string">'org.zalando:logbook-spring-boot-starter:3.9.0'</span>
</code></pre>
<p>该依赖会为 Spring 自动配置一些组件，用来拦截并记录通过这些组件发起的 HTTP 请求与返回的响应。</p>
<p>Spring AI 的 <code>ChatClient</code> 底层用的是 Spring 的 <strong>RestClient</strong>，因此你需要声明一个 <code>RestClientCustomizer</code> bean，把 Logbook 的 <code>LogbookClientHttpRequestInterceptor</code> 加为请求拦截器：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Bean</span>
<span class="hljs-title class_">RestClientCustomizer</span> <span class="hljs-title function_">logbookCustomizer</span>(<span class="hljs-params">
        LogbookClientHttpRequestInterceptor interceptor</span>) {
  <span class="hljs-keyword">return</span> restClient -&gt; restClient.<span class="hljs-title function_">requestInterceptor</span>(interceptor);
}
</code></pre>
<p>Logbook 以 <strong>TRACE</strong> 级别记录请求与响应细节，因此需要在 <code>application.properties</code> 中设置日志级别：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">logging.level.org.zalando.logbook: TRACE</span>
</code></pre>
<p>默认情况下，Logbook 以 <strong>JSON</strong> 格式输出日志，可读性一般；可选地，你可以把 <code>logbook.format.style</code> 设为 <code>http</code> 来提升可读性：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">logbook.format.style</span>=http
</code></pre>
<p>配置完成后，Spring AI 与各 AI API 之间的请求与响应都会被记录，便于检查。需要注意：Spring AI 的 <strong>Gemini</strong> 模块使用 Google 自有的 HTTP 客户端库而非 RestClient，因此如果选择 Google Gemini 作为 LLM，Logbook 将<strong>无法</strong>拦截其请求。</p>
<p>如图 3.3 所示，我们可以把消息内容拆成两条：其中大部分文本实际是<strong>给 LLM 的指令</strong>，用于指导它如何回答用户问题，因此更合适做成 <strong>system</strong> 消息；真正来自用户的只有<strong>那个问题本身</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6dd859ae2d244eb3aacee01c0b90cc0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=JCS2SqX8wZpL0QS%2FP%2BvHkWaPFcs%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.3</strong> 将原先的用户消息拆分为独立的 system 与 user 消息</p>
<p>要把这个变更应用到项目中，先在模板目录新增一个 <strong><code>systemPromptTemplate.st</code></strong> 文件，用它替代原先的 <code>questionPromptTemplate.st</code>（后者不再使用，可以删除）。新的 system 模板内容如下：</p>
<pre><code class="hljs language-markdown" lang="markdown">You are a helpful assistant, answering questions about the tabletop
game named {gameTitle}. If available, use the rules in the RULES 
section below.

Answer in complete sentences.

<span class="hljs-section">RULES
-----</span>
{rules}
</code></pre>
<p>接下来需要调整 <code>SpringAiBoardGameService</code>，让它使用这个<strong>新模板</strong>而非旧的 question 模板。用下面的字段替换掉类中现有的模板 <code>Resource</code> 属性：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/systemPromptTemplate.st"</span>)</span>
Resource promptTemplate;
</code></pre>
<p>最后，对 <code>askQuestion()</code> 方法做一些变更以使用新模板。新版本如下（<strong>清单 3.4 将提示拆分为独立的 user 与 system 消息</strong>）：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Override</span>
public Answer <span class="hljs-built_in">askQuestion</span>(Question question) {
  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">gameRules</span> = <span class="hljs-selector-tag">gameRulesService</span><span class="hljs-selector-class">.getRulesFor</span>(question.<span class="hljs-built_in">gameTitle</span>());

  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">answerText</span> = <span class="hljs-selector-tag">chatClient</span><span class="hljs-selector-class">.prompt</span>()
      <span class="hljs-selector-class">.system</span>(systemSpec -&gt; systemSpec      #<span class="hljs-number">1</span>
          .<span class="hljs-built_in">text</span>(promptTemplate)
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"gameTitle"</span>, question.<span class="hljs-built_in">gameTitle</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"rules"</span>, gameRules))
      <span class="hljs-selector-class">.user</span>(question.<span class="hljs-built_in">question</span>())             <span class="hljs-selector-id">#2</span>
      <span class="hljs-selector-class">.call</span>()
      <span class="hljs-selector-class">.content</span>();

  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Answer</span>(question.<span class="hljs-built_in">gameTitle</span>(), answerText);
}
</code></pre>
<p>具体而言：模板通过 <strong>system</strong> 消息规格的 <code>text()</code> 提供（而不是先前的 <strong>user</strong> 规格），用于填充占位符的参数也同理。至于 <strong>user</strong> 消息，再次仅使用<strong>用户问题的文本</strong>本身。</p>
<p><strong>user 与 system 消息的先后顺序并不重要</strong>；无论顺序如何，它们最终都会出现在发给 LLM 的请求中。</p>
<p>完成这些修改后，重启应用再试一次。表面上仍与之前一致，但底层发往 OpenAI 的请求现在包含两条明确分离的消息：一条是 <strong>system 指令</strong>，一条是 <strong>user 提问</strong>：</p>
<pre><code class="hljs language-swift" lang="swift">{
  <span class="hljs-string">"messages"</span>: [
    {
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"How many pieces are there?"</span>,
      <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>
    },
    {
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"You are a helpful assistant, answering questions about the
          tabletop<span class="hljs-subst">\n</span>game named checkers. If available, use the rules in the
          RULES section below.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>RULES<span class="hljs-subst">\n</span>-----<span class="hljs-subst">\n</span>"</span>,
      <span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>
    }
  ],
  <span class="hljs-string">"model"</span>: <span class="hljs-string">"gpt-4o"</span>,
  <span class="hljs-string">"stream"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.7</span>
}
</code></pre>
<p>尽管我们目前的示例可能过于简单，不足以体现“角色”带来的明显差异，但总体而言，<strong>合理使用角色有助于 LLM 生成更优的响应</strong>。随着提示复杂度提高，这种积极作用会更加显著。</p>
<p>到现在为止，我们关注的是如何<strong>创建并发送</strong>提示给 LLM 进行生成。接下来把注意力转到对话的另一端：学习<strong>如何告知 LLM 我们希望以何种形式接收生成的响应</strong>。</p>
<h2 data-id="heading-7">3.4 影响响应生成（Influencing response generation）</h2>
<p>Spring AI 提供了几项很实用的功能，用来影响响应返回的方式，包括：</p>
<ul>
<li><strong>设置生成选项</strong>：在生成响应时，对“下一枚 token 的选择”施加一定控制。</li>
<li><strong>输出转换（output conversion）</strong> ：在提示中加入格式化指令，告诉 LLM 按特定格式返回，以便把文本响应转换成 Java 对象。</li>
<li><strong>流式传输</strong>：让结果<strong>一点点</strong>返回，而不是等待<strong>一次性</strong>返回完整响应。</li>
</ul>
<p>下面从把响应绑定为 Java 对象开始，逐一介绍这些功能。</p>
<h3 data-id="heading-8">3.4.1 指定聊天选项（Specifying chat options）</h3>
<p>在使用生成式 AI 时，你可能会发现 LLM 的回答并不总如预期。模型巨大的训练规模，加上生成过程的<strong>非确定性</strong>，有时会产生不那么理想的结果。</p>
<p>Spring AI 提供了若干属性，让你“调参”以影响 LLM 处理提示的方式。你已在第 1 章见过一个：在 <code>application.properties</code> 中覆盖默认模型为 <code>gpt-4.1-nano</code>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.openai.chat.options.model</span>=gpt-<span class="hljs-number">4.1</span>-na<span class="hljs-literal">no</span>
</code></pre>
<p>Spring AI 支持的各类 API 都有类似属性来指定模型。例如，使用 Ollama 时选择 <strong>Llama 3.2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.ollama.chat.options.model</span>=llama3.<span class="hljs-number">2</span>
</code></pre>
<p>这两行的关键区别（除模型名外）在于：一行对应 <strong>OpenAI</strong> 的 API，另一行对应 <strong>Ollama</strong> 的 API。以这种方式设置聊天选项时，请确保使用<strong>与你所用 API 匹配</strong>的属性前缀。</p>
<p>多数聊天选项都可以在 <code>application.properties</code> 里设置；也可以在创建 <code>ChatClient</code> 时通过 <code>defaultOptions()</code> 设为默认值。例如，创建 <code>ChatClient</code> 时指定 <code>gpt-4.1-nano</code>：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .model("gpt-4.1-nano")
    .build()<span class="hljs-comment">;</span>

ChatClient <span class="hljs-attr">chatClient</span> = chatClientBuilder
    .defaultOptions(chatOptions)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<p>通过 <code>defaultOptions()</code> 设置的选项会<strong>覆盖</strong>在 <code>application.properties</code> 里同名的配置；而这些默认选项又可以在<strong>创建提示</strong>时通过 <code>options()</code> <strong>继续覆盖</strong>，例如：</p>
<pre><code class="hljs language-scss" lang="scss">String answerText = chatClient<span class="hljs-selector-class">.prompt</span>()
    <span class="hljs-selector-class">.user</span>(question.question())
    <span class="hljs-selector-class">.options</span>(chatOptions)
    <span class="hljs-selector-class">.call</span>()
    <span class="hljs-selector-class">.content</span>();
</code></pre>
<p>选择模型只是众多聊天选项之一。不同生成式 API 支持的选项并不完全相同，但有若干<strong>核心选项</strong>是普遍存在的。先看一组会影响“如何逐 token 选取”的选项。</p>
<h4 data-id="heading-9">调整“多样性/随机性”（Adjusting variability）</h4>
<p>响应生成是<strong>逐 token</strong>进行的：先考虑原始提示，然后由 API 基于模型选择<strong>下一枚 token</strong>；接着再选下一枚，直到完整响应生成完毕。</p>
<p>选择“下一枚 token”的方法可理解为<strong>统计概率 + 随机选择</strong>的组合。模型会给出若干候选 token，每个都有成为下一枚 token 的概率。以概率为权重做一次随机选择：概率高的更容易被选中，但<strong>所有候选</strong>都有被选中的可能。</p>
<p>例如提示为：“Finish this sentence: I have a large collection of.” 为了便于理解，我们先用<strong>词</strong>代替 <strong>token</strong> 来思考。假设候选词及其概率如下：</p>
<ul>
<li>“books” - 0.475</li>
<li>“coins” - 0.236</li>
<li>“records” - 0.129</li>
<li>“arts” - 0.096</li>
<li>“stamps” - 0.064</li>
</ul>
<p>基于以上权重，<strong>books</strong> 被选中的概率约是 <strong>coins</strong> 的两倍、是 <strong>stamps</strong> 的七倍多。多次提交相同提示，大多数结果会以 <strong>books</strong> 完成句子，<strong>coins/records/arts/stamps</strong> 偶尔出现，且频率逐步降低。</p>
<p>通过 <strong>temperature、Top-p、Top-k</strong> 等选项，你可以影响选择的随机性以及不同 token 被选中的相对可能性：</p>
<ul>
<li><strong>temperature（温度）</strong> ：范围 <strong>0–2</strong>，对概率施加缩放。直觉上，<strong>温度越高</strong>，结果越<strong>随机</strong>；<strong>温度越低</strong>，结果越<strong>确定</strong>（见图 3.4）。当温度趋近 2，各 token 概率趋于平均；当温度趋近 0，最高概率 token 的概率趋近 1，其他趋近 0；温度为 1 时概率不变。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e8f90d1d94e44d8b5cc06fb315ebcc9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=NGma5BUEeQGB5ddFaWaOFdGLSm8%3D" alt="image.png" loading="lazy"/></li>
</ul>
<p><strong>图 3.4</strong> 温度越高，概率越均匀，结果更随机；温度越低，概率差异被放大，结果更确定。</p>
<p>在 <code>application.properties</code> 中可按所用 API 设置温度。例如 OpenAI 设为 0.7：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.openai.chat.options.temperature</span>=<span class="hljs-number">0.7</span>
</code></pre>
<p>或在代码里通过 <code>ChatOptions</code> 指定：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .temperature(0.7)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><strong>Top-P（核采样）</strong> ：范围 <strong>0–1</strong>，保留<strong>累计概率</strong>达到阈值的<strong>最小候选集合</strong>，其余全部剔除。<br/>
例如 Top-P=0.8，如图 3.5，<code>books+coins+records</code> 的累计概率为 0.84，达到阈值，于是 <strong>arts/stamps</strong> 被剔除；随后对保留集合的概率<strong>归一化</strong>再做加权随机选择。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3c4e6ef45ee4464ae14ccbe0748fbeb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=wbWngSrSb0rM2AmIlA22YsjCdC4%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.5</strong> Top-P 根据高排名 token 的累计概率阈值，剔除其余候选。</p>
<p>在 OpenAI 下用属性设置：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.openai.chat.options.top-p</span>=<span class="hljs-number">0.8</span>
</code></pre>
<p>或代码设置：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .topP(0.8)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<p>通常建议<strong>二选一</strong>：使用 <strong>temperature</strong> 或 <strong>Top-P</strong>。两者同时使用是允许的，但不一定更好。</p>
<ul>
<li><strong>Top-K</strong>：与 Top-P 类似，但用<strong>计数</strong>而非累计概率，直接保留<strong>前 K 个</strong>候选。<strong>OpenAI 不支持 Top-K</strong>，因此无法在 OpenAI 上调整它；<strong>Ollama 支持</strong>，可在配置中设置：</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.ollama.chat.options.top-k</span>=<span class="hljs-number">4</span>
</code></pre>
<p>或在代码中：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .topK(4)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<p>若你在 <code>ChatOptions</code> 里设置了 Top-K 却把提示发给 OpenAI，将会收到“不支持 Top-K”的错误。</p>
<p>应用到前述“收藏”示例上，若 <code>top-k=4</code>，则 <strong>books/coins/records/arts</strong> 被保留，<strong>stamps</strong> 被剔除；随后同样进行概率归一化并随机选择。</p>
<p>像 <strong>temperature、Top-P、Top-K</strong> 这样的选项，可以在 LLM 生成响应时对其“选择过程”施加一定控制。接下来我们看看<strong>输出转换（output conversion）</strong> ，如何让生成结果直接落地为一个 <strong>Java 对象</strong>。</p>
<h3 data-id="heading-10">3.4.2 格式化响应输出（Formatting response output）</h3>
<p>到目前为止，我们的应用会显式地从 LLM 返回的响应中提取<strong>文本内容</strong>，并据此创建一个 <code>Answer</code> 对象。就目前这个简单的 <code>Answer</code> 记录类型而言，这并不难。但可以想见，若响应更复杂，“先提取再实例化”的代码会变得臃肿。幸运的是，Spring AI 提供了**输出转换（output conversion）**辅助，用于把 LLM 的响应映射为 Java 对象。</p>
<p>为了演示输出转换如何工作，先看看如何让 <code>ChatClient</code> <strong>直接返回 <code>Answer</code> 对象</strong>，而不是字符串。为此，需要把 <code>askQuestion()</code> 方法改为请求实体对象。</p>
<p><strong>清单 3.5 将 LLM 结果直接获取为 <code>Answer</code> 对象</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;
<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-title">implements</span> <span class="hljs-title">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GameRulesService gameRulesService;

  <span class="hljs-keyword">public</span> SpringAiBoardGameService(
      ChatClient.Builder chatClientBuilder,
      GameRulesService gameRulesService) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
    <span class="hljs-keyword">this</span>.gameRulesService = gameRulesService;
  }

  <span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/systemPromptTemplate.st"</span>)</span>
  Resource promptTemplate;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Answer askQuestion(Question question) {
    <span class="hljs-keyword">var</span> gameRules = gameRulesService.getRulesFor(question.gameTitle());

    <span class="hljs-keyword">return</span> chatClient.prompt()
        .system(systemSpec -&gt; systemSpec
            .text(promptTemplate)
            .param(<span class="hljs-string">"gameTitle"</span>, question.gameTitle())
            .param(<span class="hljs-string">"rules"</span>, gameRules))
        .user(question.question())
        .call()
        .entity(Answer.<span class="hljs-keyword">class</span>);
  }

}
</code></pre>
<p><code>askQuestion()</code> 的工作方式几乎与之前完全相同，只是有一个不太显眼的变化：不再调用 <code>content()</code>，而是调用 <code>entity()</code>，并传入 <code>Answer.class</code> 指明期望的响应类型。</p>
<p>这个小改动带来两点变化：</p>
<ol>
<li><strong>格式化指令</strong>会被加入到提示中；</li>
<li>返回的响应会被<strong>解析为对象</strong>。</li>
</ol>
<p>在提示发送给 LLM 之前，Spring AI 会<strong>装饰</strong>提示，加入<strong>格式化指令</strong>，告诉模型响应应采用何种格式。该格式由 <code>Answer</code> 记录及其属性<strong>推导</strong>而来。如果你拦截请求并查看细节，会看到类似如下的格式化指令：</p>
<pre><code class="hljs language-vbscript" lang="vbscript">Your <span class="hljs-built_in">response</span> should be <span class="hljs-keyword">in</span> JSON format.
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> include any explanations, only provide a RFC8259 compliant JSON
<span class="hljs-built_in">response</span> following this format without deviation.
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> include markdown code blocks <span class="hljs-keyword">in</span> your <span class="hljs-built_in">response</span>.
Here <span class="hljs-keyword">is</span> the JSON Schema instance your output must adhere <span class="hljs-keyword">to</span>:
```{
  <span class="hljs-string">"$schema"</span> : <span class="hljs-string">"https://json-schema.org/draft/2020-12/schema"</span>,
  <span class="hljs-string">"type"</span> : <span class="hljs-string">"object"</span>,
  <span class="hljs-string">"properties"</span> : {
    <span class="hljs-string">"answer"</span> : {
      <span class="hljs-string">"type"</span> : <span class="hljs-string">"string"</span>
    },
    <span class="hljs-string">"gameTitle"</span> : {
      <span class="hljs-string">"type"</span> : <span class="hljs-string">"string"</span>
    }
  }
}```
</code></pre>
<p>这里的格式说明<strong>精确</strong>告知 LLM：应按 JSON 对象返回，并附上了 JSON Schema。</p>
<p>当响应返回时，这个 JSON 对象会被<strong>转换</strong>成所需类型——此处为 <code>Answer</code>。</p>
<blockquote>
<p><strong>NOTE</strong> 即使 Spring AI 的输出转换负责生成了格式化指令，也<strong>不保证</strong>一定有效。有些 LLM 并不遵循格式要求，仍会随意返回答案。OpenAI 的 GPT 模型通常执行得不错，但其他模型（如 <strong>Mistral 7B</strong>）可能不行。如果所用 LLM 不遵守格式，结果就<strong>无法可靠</strong>地转换并绑定到对象；这种情况下，当 Spring AI 尝试把“非 JSON 响应”绑定到对象时，会抛出 <strong>JsonParseException</strong>。</p>
</blockquote>
<p>就是这样！现在 Spring AI 的输出转换会负责创建 <code>Answer</code> 对象——它之所以能做到，是因为它首先生成了<strong>指令</strong>，告诉 LLM 按 JSON 对象格式返回结果。</p>
<h4 data-id="heading-11">将输出解析为列表（Parsing output to a list）</h4>
<p>Spring AI 也能把响应解析为 <code>List&lt;String&gt;</code>。当你预期响应是一个“条目列表”时，这很适合，比如游乐园景点清单、联赛球队名单、或 Billboard Hot 100 的年度十大金曲。</p>
<p>为演示如何拿到列表响应，我们创建一个新的控制器（如下清单），按给定年份返回前 10 首歌曲：</p>
<p><strong>清单 3.6 返回某年份热门歌曲 Top 10 的控制器</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.topsongs;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;
<span class="hljs-keyword">import</span> org.springframework.core.ParameterizedTypeReference;
<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestParam;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopSongsController</span> {

  <span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/top-songs-prompt.st"</span>)</span>
  Resource topSongPromptTemplate;  #<span class="hljs-number">1</span>

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;

  <span class="hljs-keyword">public</span> TopSongsController(ChatClient.Builder chatClientBuilder) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
  }

  <span class="hljs-meta">@GetMapping(path = <span class="hljs-string">"/topSongs"</span>, produces = <span class="hljs-string">"application/json"</span>)</span>
  <span class="hljs-keyword">public</span> List&lt;String&gt; topSongs(<span class="hljs-meta">@RequestParam(<span class="hljs-string">"year"</span>)</span> String year) {
    <span class="hljs-keyword">return</span> chatClient.prompt()
        .user(userSpec -&gt; userSpec
            .text(topSongPromptTemplate)
            .param(<span class="hljs-string">"year"</span>, year))
        .call()
        .entity(new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {});  #<span class="hljs-number">2</span>
  }

}
</code></pre>
<p>为简单起见，这里直接在控制器中使用 <code>ChatClient</code>，而不是像 <code>SpringAiBoardGameService</code> 那样抽到单独的服务类。</p>
<p>提示模板定义在 <code>src/main/resources/top-songs-prompt.st</code>，并作为 <code>Resource</code> 注入控制器。模板内容如下：</p>
<pre><code class="hljs language-sql" lang="sql">What were the top <span class="hljs-number">10</span> songs <span class="hljs-keyword">on</span> the Billboard Hot <span class="hljs-number">100</span> <span class="hljs-keyword">in</span> {<span class="hljs-keyword">year</span>}?

<span class="hljs-keyword">Each</span> item should <span class="hljs-keyword">only</span> include the song title.
</code></pre>
<p>该控制器与之前在 <code>SpringAiBoardGameService</code> 中见到的代码很相似，但有一点不同：调用 <code>entity()</code> 时传入了 <code>new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {}</code>。我们期望的结果是 <code>List&lt;String&gt;</code>，但不能直接把 <code>List</code> 或 <code>List&lt;String&gt;</code> 传给 <code>entity()</code>。<code>ParameterizedTypeReference</code> 是一种特殊的类型引用，能在 Java 的<strong>类型擦除</strong>下，仍携带<strong>泛型实参</strong>传给方法（如 <code>entity()</code>）。</p>
<p>由于向 <code>entity()</code> 传入了 <code>new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {}</code>，提示会被赋予如下的<strong>格式化指令</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">FORMAT: Your response should be a list of comma separated values</span>
<span class="hljs-section">eg: `foo, bar, baz`</span>
</code></pre>
<p>运行应用后，可用 HTTPie 试试，例如：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/topSongs?year=1981 -b
[
    <span class="hljs-string">"Bette Davis Eyes"</span>,
    <span class="hljs-string">"Endless Love"</span>,
    <span class="hljs-string">"Lady"</span>,
    <span class="hljs-string">"(Just Like) Starting Over"</span>,
    <span class="hljs-string">"Jessie's Girl"</span>,
    <span class="hljs-string">"Celebration"</span>,
    <span class="hljs-string">"Kiss On My List"</span>,
    <span class="hljs-string">"I Love A Rainy Night"</span>,
    <span class="hljs-string">"9 To 5"</span>,
    <span class="hljs-string">"Keep On Loving You"</span>
]
</code></pre>
<p>太好了！快速搜一下可确认这些确实是 1981 年的前十热单。当然，<strong>准确性</strong>取决于你所选 LLM 的训练质量（上述列单由 OpenAI 的 <code>gpt-4o</code> 返回）。但更重要的是，得益于<strong>列表输出转换</strong>，响应被格式化为一个值列表。</p>
<p>虽然把响应格式化为 Java 对象或列表很有用，但有时候<strong>纯文本</strong>就够了，只是你希望它在生成时<strong>逐步返回</strong>。接下来看看如何使用另一种 Spring AI 聊天客户端，把结果<strong>流式</strong>返回给调用方。</p>
<h3 data-id="heading-12">3.4.3 流式返回响应（Streaming the response）</h3>
<p>如果你用过 OpenAI 的 ChatGPT、微软 Copilot 等聊天客户端，你就体验过“聊天式界面”的 LLM 交互。你也会注意到：LLM 的回答像“在打字”一样，<strong>逐步流入</strong>对话窗口。</p>
<p>流式响应的关键好处是：<strong>提升聊天应用的用户体验</strong>。简单回答可能很快返回，但复杂回答需要更长的生成时间。如果能在生成过程中<strong>逐步渲染</strong>，用户就能确信应用<strong>在工作</strong>而非“卡住”。</p>
<p>Spring AI 在使用 <code>ChatClient</code> 时支持这种<strong>流式风格</strong>。下面的清单展示了：只需对 <code>askQuestion()</code> 做少量修改，就能以<strong>流</strong>的方式取回结果。</p>
<p><strong>清单 3.7 流式返回的棋盘游戏服务</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Override</span>
public Flux&lt;String&gt; <span class="hljs-built_in">askQuestion</span>(Question question) {    <span class="hljs-selector-id">#1</span>
  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">gameRules</span> = <span class="hljs-selector-tag">gameRulesService</span><span class="hljs-selector-class">.getRulesFor</span>(question.<span class="hljs-built_in">gameTitle</span>());

  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">chatClient</span><span class="hljs-selector-class">.prompt</span>()
      <span class="hljs-selector-class">.system</span>(systemSpec -&gt; systemSpec
          .<span class="hljs-built_in">text</span>(promptTemplate)
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"gameTitle"</span>, question.<span class="hljs-built_in">gameTitle</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"rules"</span>, gameRules))
      <span class="hljs-selector-class">.user</span>(question.<span class="hljs-built_in">question</span>())
      <span class="hljs-selector-class">.stream</span>()         <span class="hljs-selector-id">#2</span>
      <span class="hljs-selector-class">.content</span>();
}
</code></pre>
<p>与先前版本相比，关键差异在于：该方法的返回类型是 <code>Flux&lt;String&gt;</code>，且不再调用 <code>call()</code>，而是调用 <code>stream()</code>。等等，<code>Flux</code> 是什么？</p>
<p><code>Flux</code> 来自 <strong>Project Reactor</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fprojectreactor.io%2F" target="_blank" title="https://projectreactor.io/" ref="nofollow noopener noreferrer">projectreactor.io/</a>），是 Spring 响应式栈的基础库。更多内容可参考《Spring in Action》（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.manning.com%2Fbooks%2Fspring-in-action-sixth-edition" target="_blank" title="https://www.manning.com/books/spring-in-action-sixth-edition" ref="nofollow noopener noreferrer">www.manning.com/books/sprin…</a>），从第 5 版起其中就有专章讲解 Reactor 以及 <code>Flux</code> / <code>Mono</code>。</p>
<p>此处只需理解：<code>Flux</code> 是一种<strong>响应式类型</strong>，会在数据可用时<strong>流式</strong>地产生 0 到多条数据。对 LLM 的生成响应而言，<code>Flux</code> 通常会按<strong>词粒度</strong>（或短片段）不断推送内容。</p>
<p>你还需要修改 <code>AskController</code>，让它返回服务方法返回的 <code>Flux</code>。如下：</p>
<p><strong>清单 3.8 流式的 <code>AskController</code></strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestBody;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;
<span class="hljs-keyword">import</span> reactor.core.publisher.Flux;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AskController</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BoardGameService boardGameService;

  <span class="hljs-keyword">public</span> AskController(BoardGameService boardGameService) {
    <span class="hljs-keyword">this</span>.boardGameService = boardGameService;
  }

  <span class="hljs-meta">@PostMapping(path=<span class="hljs-string">"/ask"</span>, produces=<span class="hljs-string">"application/json"</span>)</span>
  <span class="hljs-keyword">public</span> Flux&lt;String&gt; ask(<span class="hljs-meta">@RequestBody</span> Question question) {
    <span class="hljs-keyword">return</span> boardGameService.askQuestion(question);
  }

}
</code></pre>
<p><code>ask()</code> 方法还有一个小改动：<code>@PostMapping</code> 需声明返回<strong>流式响应</strong>，其 <strong>MIME</strong> 一般设为 <code>text/event-stream</code>。这一点很重要：如果仍是 <code>application/json</code>，结果会<strong>一次性</strong>返回，而不是流式返回。</p>
<p>你可以像之前一样用 HTTPie 试试。因为流式响应通常很快返回，除非答案较长，否则你可能不明显地感受到“流动”。比如询问 Burger Battle 的<strong>战斗卡</strong>列表：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">$ http :<span class="hljs-number">8080</span>/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
       question=<span class="hljs-string">"What battle cards are there?"</span> -b
       <span class="hljs-keyword">data</span>:

       <span class="hljs-keyword">data</span>:Here

       <span class="hljs-keyword">data</span>: <span class="hljs-keyword">is</span>

       <span class="hljs-keyword">data</span>: a

       <span class="hljs-keyword">data</span>: list

       <span class="hljs-keyword">data</span>: of

       <span class="hljs-keyword">data</span>: the

       <span class="hljs-keyword">data</span>: Battle

       <span class="hljs-keyword">data</span>: Cards
...
</code></pre>
<p>为避免篇幅过长，这里只展示前几项。显然，响应是<strong>逐词</strong>流回，而非一次性返回。尽管输出不容易看出，但每个词之间有<strong>小延迟</strong>，就像 LLM 正在“打字”。</p>
<p><code>text/event-stream</code> 的一个副作用是：每个词前会带上 <code>data:</code> 前缀，因此调用方需要能够<strong>剥离</strong>该前缀以取出真正的词。</p>
<p>为了避免对每个词做特殊处理，可以把 <code>@PostMapping</code> 的 <code>produces</code> 改为 <code>application/ndjson</code>（换行分隔 JSON）：</p>
<pre><code class="hljs language-ini" lang="ini">@PostMapping(<span class="hljs-attr">path</span> = <span class="hljs-string">"/ask"</span>, produces = <span class="hljs-string">"application/ndjson"</span>)
</code></pre>
<p>此时，LLM 仍会<strong>逐词</strong>流回，但不再带 <code>data:</code> 前缀。</p>
<p>如果用 HTTPie 测试这个 MIME，更可能会以为“流式坏了”。因为 HTTPie 遇到 <code>text/event-stream</code> 时会<strong>默认</strong>按流处理，但对 <code>application/ndjson</code> 并不会。要启用流式显示，需加 <code>--stream</code>：</p>
<pre><code class="hljs language-ini" lang="ini">$ http :8080/ask <span class="hljs-attr">gameTitle</span>=<span class="hljs-string">"Burger Battle"</span> \
       <span class="hljs-attr">question</span>=<span class="hljs-string">"What battle cards are there?"</span> -b --stream --pretty none <span class="hljs-comment">#1</span>
</code></pre>
<p>输出（此处为节选）类似：</p>
<pre><code class="hljs language-python" lang="python">In Burger Battle there are several Battle Cards that players can use. Here 
<span class="hljs-keyword">is</span> a <span class="hljs-built_in">list</span> of the standard Battle Cards:

<span class="hljs-number">1.</span> **Burger Bomb**: Blow up another playe<span class="hljs-string">r's Burger by sending their
ingredients to the Graveyard.
2. **Burger Force Field**: Your Burger is now protected from all Battle 
Cards.
3. **Burgerpocalypse**: Obliterate all players'</span> ingredients, including your
own, <span class="hljs-keyword">and</span> toss them <span class="hljs-keyword">in</span> the Graveyard.
<span class="hljs-number">4.</span> **Destroy!**: Destroy <span class="hljs-built_in">any</span> Battle Card of yours <span class="hljs-keyword">or</span> another playe<span class="hljs-string">r's and 
toss it in the Graveyard.
5. **Gonna Eat That?**: Steal another player'</span>s ingredient <span class="hljs-keyword">and</span> add it to your
Burger.
...
</code></pre>
<p>再次强调：书页静态展示不明显，但实际使用 HTTPie 时，响应是<strong>带小延迟</strong>地流回的。虽然底层仍是<strong>逐词</strong>流式，HTTPie 会<strong>缓冲</strong>这些词，直到凑成一整行再打印。</p>
<p>你也许会问：能否把<strong>流式响应</strong>与前面用到的<strong>输出转换</strong>结合起来？理论上，流式客户端可以像处理纯文本一样流式返回<strong>JSON 文本</strong>；但流回的 JSON 会被<strong>拆成词或符号</strong>，在<strong>完整</strong>响应结束前，你并没有一个<strong>完备的 JSON 文档</strong>可以解析。</p>
<p>因此，你必须<strong>先收集</strong>完整的流式 JSON 字符串，再交给输出转换去处理——这等于<strong>违背</strong>了使用流式的初衷。简言之，<strong>不要混用</strong>“流式 + 输出转换”。</p>
<p>在本章中，你已经看到如何使用 Spring AI 将提示提交给 LLM 进行生成；使用<strong>提示模板</strong>实现“填空式”提示；用<strong>上下文填充</strong>提示；利用<strong>提示角色</strong>；以及<strong>影响响应生成</strong>的方式。收尾之前，我们再看看如何检查模型可能随响应一并返回的<strong>响应元数据</strong>。</p>
<h2 data-id="heading-13">3.5 使用响应元数据（Working with response metadata）</h2>
<p>除了拿到生成结果外，<code>ChatClient</code> 还可以提供与 LLM 交互的一些有用<strong>元数据</strong>。其中最有用的是<strong>用量（usage）统计</strong>。每个提示和每段生成的响应最终都会被拆分成若干 <strong>token</strong>。这些 token（以及其他因素）会用于计算你向 AI 服务支付的费用。因此，了解每次请求消耗了多少 token，有助于你评估与 LLM 的交互成本。</p>
<p>如何使用 token 用量信息取决于你自己。最基本的做法是把这些信息简单地<strong>写入应用日志</strong>。在第 9 章，你会看到如何借助 Spring AI 的<strong>可观测性</strong>功能，对外暴露 token 用量与其他指标。</p>
<p><strong>清单 3.9 记录 token 用量到日志</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ResponseEntity;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.metadata.ChatResponseMetadata;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.metadata.Usage;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.model.ChatResponse;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;
<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-title">implements</span> <span class="hljs-title">BoardGameService</span> {

  <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> Logger log =
      LoggerFactory.getLogger(SpringAiBoardGameService.<span class="hljs-keyword">class</span>);

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GameRulesService gameRulesService;

  <span class="hljs-keyword">public</span> SpringAiBoardGameService(
      ChatClient.Builder chatClientBuilder,
      GameRulesService gameRulesService) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
    <span class="hljs-keyword">this</span>.gameRulesService = gameRulesService;
  }

  <span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/systemPromptTemplate.st"</span>)</span>
  Resource promptTemplate;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Answer askQuestion(Question question) {
    <span class="hljs-keyword">var</span> gameRules = gameRulesService.getRulesFor(question.gameTitle());

    <span class="hljs-keyword">var</span> responseEntity = chatClient.prompt()
        .system(systemSpec -&gt; systemSpec
            .text(promptTemplate)
            .param(<span class="hljs-string">"gameTitle"</span>, question.gameTitle())
            .param(<span class="hljs-string">"rules"</span>, gameRules))
        .user(question.question())
        .call()
        .responseEntity(Answer.<span class="hljs-keyword">class</span>);

    <span class="hljs-keyword">var</span> response = responseEntity.response();

    <span class="hljs-keyword">var</span> metadata = response.getMetadata();
    logUsage(metadata.getUsage());


    <span class="hljs-keyword">return</span> responseEntity.entity();
  }

  <span class="hljs-keyword">private</span> void logUsage(Usage usage) {
    log.info(<span class="hljs-string">"Token usage: prompt={}, generation={}, total={}"</span>,
        usage.getPromptTokens(),
        usage.getCompletionTokens(),
        usage.getTotalTokens());
  }

}
</code></pre>
<p><code>askQuestion()</code> 方法和之前相比略有不同。关键差异在于：它不再调用 <code>content()</code> 或 <code>entity()</code> 获取响应，而是调用 <code>responseEntity()</code>。该方法与 <code>entity()</code> 类似，会把响应<strong>绑定</strong>为指定类型的对象（这里是 <code>Answer</code>）；但不同的是，它返回的是一个 <code>ResponseEntity&lt;ChatResponse, Answer&gt;</code>，其中既包含 <code>Answer</code>，也携带一个 <code>ChatResponse</code> 对象。</p>
<p><code>ChatResponse</code> 对象中可以找到<strong>元数据</strong>。调用 <code>getMetadata()</code> 可获取用量信息，从而在 <code>ask()</code> 方法（此处为 <code>askQuestion()</code>）中把它传给 <code>logUsage()</code> 进行日志记录。随后，<code>askQuestion()</code> 返回 <code>ResponseEntity</code> 中承载的 <code>Answer</code>。</p>
<p>完成这些修改后，像之前一样启动应用并向 <code>/ask</code> 发送请求。你应该会在日志里看到类似如下的记录：</p>
<pre><code class="hljs language-ini" lang="ini">Token usage: <span class="hljs-attr">prompt</span>=<span class="hljs-number">1618</span>, generation=<span class="hljs-number">35</span>, total=<span class="hljs-number">1653</span>
</code></pre>
<p>为突出重点，这里只展示了日志消息本身。实际的 token 数会因提问与回答而变化。但可以看到，日志为你提供了有价值的洞察：使用了多少 token（进而可用于<strong>估算费用</strong>）。</p>
<p>需要注意：并非所有 AI 服务都会返回用量指标。例如，发送给本地 <strong>Ollama</strong> 的 LLM 提示不会提供用量数据。<strong>Mistral AI</strong> 也是一个似乎不返回用量数据的服务。但你通常可以从 <strong>OpenAI、Anthropic、Google</strong>（以及可能的其他服务）拿到用量数据。</p>
<h2 data-id="heading-14"><strong>总结</strong></h2>
<ul>
<li><strong>提示模板</strong>让你可以定义并外部化通用提示，在提交生成前用具体内容填充。</li>
<li>模板也支持向提示中提供<strong>额外上下文</strong>，以使生成更聚焦、更准确。</li>
<li>上下文可包含<strong>输出格式化指令</strong>，例如要求以 JSON 返回，以便绑定到 Java 对象。</li>
<li><strong>输出转换</strong>可以把 LLM 的生成结果解析为 <strong>Java 对象</strong>或<strong>列表</strong>。</li>
<li>响应可以<strong>流式</strong>返回给客户端，模拟“思考与打字”的体验。</li>
<li>生成响应中可能包含<strong>有用的元数据</strong>，如 <strong>token 用量</strong> 等指标。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MGPIC 初赛提交倒计时 4 天！]]></title>    <link>https://juejin.cn/post/7570902473433071616</link>    <guid>https://juejin.cn/post/7570902473433071616</guid>    <pubDate>2025-11-10T10:41:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902473433071616" data-draft-id="7570793903848718351" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" MGPIC 初赛提交倒计时 4 天！"/> <meta itemprop="keywords" content="后端,算法,编程语言"/> <meta itemprop="datePublished" content="2025-11-10T10:41:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MoonBit"/> <meta itemprop="url" content="https://juejin.cn/user/3609050528885565"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             MGPIC 初赛提交倒计时 4 天！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3609050528885565/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MoonBit
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:41:52.000Z" title="Mon Nov 10 2025 10:41:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong/></p><p align="center"><strong>距离作品提交截止</strong></p><p/>
<p><strong/></p><p align="center"><strong>剩余4天</strong></p><p/>
<p><strong/></p><p align="center"><strong>截止日期：11月14日 18:30</strong></p><p/>
<p>随着 2025 MoonBit 全球编程创新挑战赛的临近尾声，我们见证了「程序语言设计与实现赛道」和「游戏开发与设计」两个赛道的激烈竞争。截至目前，「程序语言设计与实现赛道」已有158支队伍报名、「游戏开发与设计」赛道也吸引了163支队伍的报名。<br/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/883cff72e1eb4ac987295ab76fae8380~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9vbkJpdA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376112&amp;x-signature=%2B0AjPWAgQ8GIItQfiQ5S2FoKFbM%3D" alt="图片" loading="lazy"/></p>
<p>作品提交入口：</p>
<ul>
<li>
<p>编译赛道：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftianchi.aliyun.com%2Fcompetition%2Fentrance%2F532402" target="_blank" title="https://tianchi.aliyun.com/competition/entrance/532402" ref="nofollow noopener noreferrer">tianchi.aliyun.com/competition…</a></p>
</li>
<li>
<p>游戏赛道：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmoonbitlang%2FMoonBit-Code-JAM-2025" target="_blank" title="https://github.com/moonbitlang/MoonBit-Code-JAM-2025" ref="nofollow noopener noreferrer">github.com/moonbitlang…</a></p>
</li>
</ul>
<p>赛程升级，奖励多多</p>
<ul>
<li>
<p>编译赛道 开设了10名表现优异奖，奖金为500元（一个队伍），即除去入围决赛的队伍前6名，排行榜的第7-16名队伍都有机会获得此现金奖励~</p>
<p>P.S.进入排行榜不等于直接入围决赛，赛事组会根据评测机器以及作品完成度决定最后入围决赛名单！所以抓紧时间优化作品完成度！</p>
</li>
</ul>

<ul>
<li>游戏赛道 开设月度动态评比以及更多特别单元奖，现在提交每个队伍还有机会获得阳光普照奖（500元）！</li>
</ul>
<p>目前，双赛道的作品提交已进入最后冲刺阶段，<strong>提交作品端口将于11月14日18:30关闭</strong>，尚未提交初赛作品的队伍请抓紧时间哦！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f8930919711464598096e7247259c6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9vbkJpdA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376112&amp;x-signature=QZ86CTABch9z0bwUregJQrw7YQI%3D" alt="图片" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用高阶函数实现递归：从匿名函数到通用递归生成器]]></title>    <link>https://juejin.cn/post/7570940025580388392</link>    <guid>https://juejin.cn/post/7570940025580388392</guid>    <pubDate>2025-11-10T10:45:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570940025580388392" data-draft-id="7570793903848652815" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用高阶函数实现递归：从匿名函数到通用递归生成器"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T10:45:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="pe7er"/> <meta itemprop="url" content="https://juejin.cn/user/905653310988445"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用高阶函数实现递归：从匿名函数到通用递归生成器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653310988445/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    pe7er
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:45:30.000Z" title="Mon Nov 10 2025 10:45:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>阅读时间：约 10 分钟</strong><br/>
<strong>适合人群：</strong> 具备 JavaScript 基础、想深入理解函数式编程与高阶函数实战的前端工程师。</p>
<p><strong>本文目标：</strong></p>
<ul>
<li>了解如何在没有函数名的情况下实现递归</li>
<li>掌握构建通用递归生成器的思路</li>
<li>学会在真实项目中使用高阶函数递归处理复杂逻辑</li>
</ul>
</blockquote>
<hr/>
<p>从匿名递归开始</p>
<p>先看一段看似难以理解的代码：</p>
<pre><code class="hljs language-scss" lang="scss">(g =&gt; g(g))(f =&gt; n =&gt; n &lt; <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : n * f(f)(n - <span class="hljs-number">1</span>))(<span class="hljs-number">6</span>);
</code></pre>
<p>执行结果是：</p>
<pre><code class="hljs">720
</code></pre>
<p>即 <code>6!</code>(6 的阶乘（factorial of 6）)。</p>
<p>在数学中，<strong>阶乘（factorial）</strong> 是指一个正整数与它所有比它小的正整数的乘积：</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mo>⋯</mo><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n! = n \times (n - 1) \times (n - 2) \times \cdots \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">1</span></span></span></span></span></p>
<p>拆解原理：</p>
<ul>
<li><code>(f =&gt; n =&gt; n &lt; 2 ? 1 : n * f(f)(n - 1))</code>：定义阶乘逻辑；</li>
<li><code>(g =&gt; g(g))</code>：<strong>自应用函数（Self-Application Function）</strong> ；</li>
<li><code>(g =&gt; g(g))(f =&gt; ...)</code>：将函数传入自身，让匿名函数内部实现递归。</li>
</ul>
<p>这种方式实现了<strong>没有名字的递归函数</strong>。</p>
<hr/>
<h2 data-id="heading-0">提取为可复用的函数</h2>
<p>为了可读性更高，我们提取一个通用的封装函数：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">fn</span> = (f) =&gt; {
  return (<span class="hljs-attr">g</span> =&gt; g(g))(f)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">fn1</span> = fn(f =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt; n === <span class="hljs-number">0</span> ? acc : f(f)(n - <span class="hljs-number">1</span>, n * acc))<span class="hljs-comment">;</span>
console.log(fn1(6))<span class="hljs-comment">; // 720</span>
</code></pre>
<p><code>fn()</code> 封装了匿名递归结构，传入的函数只需要关心逻辑。</p>
<hr/>
<h2 data-id="heading-1">构建通用的递归函数生成器</h2>
<p>我们进一步封装成更通用的写法：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createRecursiveFunction</span> = (<span class="hljs-params">f</span>) =&gt; {
  <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> <span class="hljs-title function_">g</span>(g))(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">h</span>(h)(...args)));
};
</code></pre>
<p>解释：</p>
<ul>
<li><code>f</code> 是接收 <code>self</code> 参数的函数；</li>
<li><code>self</code> 表示递归自身；</li>
<li><code>(g =&gt; g(g))</code> 让函数可以引用自身。</li>
</ul>
<hr/>
<h2 data-id="heading-2">例 1：阶乘（factorial）</h2>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">factorialLogic</span> = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt; {
  return <span class="hljs-attr">n</span> === <span class="hljs-number">0</span> ? acc : self(n - <span class="hljs-number">1</span>, n * acc)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">factorial</span> = createRecursiveFunction(factorialLogic)<span class="hljs-comment">;</span>

console.log(factorial(6))<span class="hljs-comment">; // 720</span>
</code></pre>
<p>这是一种尾递归写法，性能更优。</p>
<hr/>
<h2 data-id="heading-3">例 2：斐波那契数列（fibonacci）</h2>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">fibonacciLogic</span> = (self) =&gt; (n) =&gt; {
  return n &lt;= 1 ? n : self(n - 1) + self(n - 2)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">fibonacci</span> = createRecursiveFunction(fibonacciLogic)<span class="hljs-comment">;</span>

console.log(fibonacci(6))<span class="hljs-comment">; // 8</span>
</code></pre>
<hr/>
<h2 data-id="heading-4">例 3：爬楼梯问题（climbStairs）</h2>
<blockquote>
<p>每次可以爬 1 或 2 阶，问总共有多少种爬法？</p>
</blockquote>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">climbStairsLogic</span> = (self) =&gt; n =&gt; {
  return n &lt;= 2 ? n : self(n - 1) + self(n - 2)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">climbStairs</span> = createRecursiveFunction(climbStairsLogic)<span class="hljs-comment">;</span>

console.log(climbStairs(6))<span class="hljs-comment">; // 13</span>
</code></pre>
<hr/>
<h2 data-id="heading-5">例 4：棋盘麦粒问题（chessGrains）</h2>
<blockquote>
<p>棋盘第一个格子放 1 颗麦子，每下一个格子是前一个的 2 倍。问第 64 个格子上有多少颗？</p>
</blockquote>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">chessGrainsLogic</span> = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt; {
  return <span class="hljs-attr">n</span> === <span class="hljs-number">0</span> ? acc : self(n - <span class="hljs-number">1</span>, acc * <span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">chessGrains</span> = createRecursiveFunction(chessGrainsLogic)<span class="hljs-comment">;</span>

console.log(chessGrains(63))<span class="hljs-comment">; // 9223372036854775808</span>
</code></pre>
<hr/>
<h2 data-id="heading-6">完整代码</h2>
<pre><code class="hljs language-scss" lang="scss">const createRecursiveFunction = (f) =&gt; {
  return (g =&gt; g(g))(h =&gt; f((...args) =&gt; <span class="hljs-built_in">h</span>(h)(...args)));
};

<span class="hljs-comment">// 阶乘</span>
const factorialLogic = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt;
  n === <span class="hljs-number">0</span> ? acc : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>, n * acc);
const factorial = <span class="hljs-built_in">createRecursiveFunction</span>(factorialLogic);
console<span class="hljs-selector-class">.log</span>('factorial(<span class="hljs-number">6</span>) =', <span class="hljs-built_in">factorial</span>(<span class="hljs-number">6</span>));

<span class="hljs-comment">// 斐波那契</span>
const fibonacciLogic = (self) =&gt; (n) =&gt;
  n &lt;= <span class="hljs-number">1</span> ? n : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">self</span>(n - <span class="hljs-number">2</span>);
const fibonacci = <span class="hljs-built_in">createRecursiveFunction</span>(fibonacciLogic);
console<span class="hljs-selector-class">.log</span>('fibonacci(<span class="hljs-number">6</span>) =', <span class="hljs-built_in">fibonacci</span>(<span class="hljs-number">6</span>));

<span class="hljs-comment">// 爬楼梯</span>
const climbStairsLogic = (self) =&gt; n =&gt;
  n &lt;= <span class="hljs-number">2</span> ? n : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">self</span>(n - <span class="hljs-number">2</span>);
const climbStairs = <span class="hljs-built_in">createRecursiveFunction</span>(climbStairsLogic);
console<span class="hljs-selector-class">.log</span>('climbStairs(<span class="hljs-number">6</span>) =', <span class="hljs-built_in">climbStairs</span>(<span class="hljs-number">6</span>));

<span class="hljs-comment">// 棋盘麦粒</span>
const chessGrainsLogic = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt;
  n === <span class="hljs-number">0</span> ? acc : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>, acc * <span class="hljs-number">2</span>);
const chessGrains = <span class="hljs-built_in">createRecursiveFunction</span>(chessGrainsLogic);
console<span class="hljs-selector-class">.log</span>('chessGrains(<span class="hljs-number">63</span>) =', <span class="hljs-built_in">chessGrains</span>(<span class="hljs-number">63</span>));
</code></pre>
<hr/>
<h2 data-id="heading-7">总结：高阶函数的力量</h2>

























<table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>高阶函数</td><td>接收或返回函数的函数</td></tr><tr><td>匿名递归</td><td>无需函数名即可递归</td></tr><tr><td>自应用函数 <code>(g =&gt; g(g))</code></td><td>实现匿名自引用的关键</td></tr><tr><td>通用递归生成器</td><td>可动态生成任意递归逻辑</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-8">思考练习</h2>
<p>尝试使用 <code>createRecursiveFunction</code> 实现以下函数：</p>
<ol>
<li>非尾递归版阶乘</li>
<li>求数组和</li>
<li>二分查找</li>
</ol>
<p>好的，我帮你把这一节整理成 <strong>掘金文章的新一章</strong>，保持和前文一致的 Markdown 风格，标题、代码、说明都完整，方便直接发布。</p>
<hr/>
<h2 data-id="heading-9">十、递归练习与思维扩展</h2>
<p>在前文中，我们学习了如何用高阶函数和通用递归生成器 <code>createRecursiveFunction</code> 构建各种递归函数。<br/>
为了加深理解，可以尝试一些练习题，实践不同类型的递归逻辑。</p>
<p>本章给出三个示例：</p>
<ol>
<li>非尾递归版阶乘</li>
<li>求数组和</li>
<li>二分查找</li>
</ol>
<hr/>
<h3 data-id="heading-10">1. 非尾递归版阶乘</h3>
<p>非尾递归的特点是<strong>递归调用不是最后一步</strong>，返回值还要参与计算。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">factorialLogic</span> = (self) =&gt; (n) =&gt; {
  if (<span class="hljs-attr">n</span> === <span class="hljs-number">0</span>) return <span class="hljs-number">1</span><span class="hljs-comment">;</span>
  return n * self(n - 1)<span class="hljs-comment">; // 非尾递归</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">factorial</span> = createRecursiveFunction(factorialLogic)<span class="hljs-comment">;</span>

console.log(factorial(6))<span class="hljs-comment">; // 输出 720</span>
</code></pre>
<blockquote>
<p>解析：</p>
<ul>
<li>每次递归返回一个值参与乘法计算；</li>
<li>调用栈会随着 <code>n</code> 增大而增加。</li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-11">2. 求数组和</h3>
<p>利用递归求数组所有元素的和。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">sumArrayLogic</span> = (self) =&gt; (arr) =&gt; {
  if (<span class="hljs-attr">arr.length</span> === <span class="hljs-number">0</span>) return <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  const <span class="hljs-section">[head, ...tail]</span> = arr<span class="hljs-comment">;</span>
  return head + self(tail)<span class="hljs-comment">; // 非尾递归</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">sumArray</span> = createRecursiveFunction(sumArrayLogic)<span class="hljs-comment">;</span>

console.log(sumArray(<span class="hljs-section">[1, 2, 3, 4, 5]</span>))<span class="hljs-comment">; // 输出 15</span>
</code></pre>
<blockquote>
<p>解析：</p>
<ul>
<li>每次取数组的第一个元素 <code>head</code>，递归计算剩余元素 <code>tail</code> 的和；</li>
<li>递归调用返回值与 <code>head</code> 相加得到最终结果。</li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-12">3. 二分查找</h3>
<p>在有序数组中高效查找目标元素索引。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">binarySearchLogic</span> = (self) =&gt; (arr, target, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>) =&gt; {
  if (left &gt; right) return -1<span class="hljs-comment">; // 未找到</span>

  const <span class="hljs-attr">mid</span> = Math.floor((left + right) / <span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">value</span> = arr[mid]<span class="hljs-comment">;</span>

  if (<span class="hljs-attr">value</span> === target) return mid<span class="hljs-comment">;</span>
  if (value &gt; target) return self(arr, target, left, mid - 1)<span class="hljs-comment">;</span>
  return self(arr, target, mid + 1, right)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">binarySearch</span> = createRecursiveFunction(binarySearchLogic)<span class="hljs-comment">;</span>

const <span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<span class="hljs-comment">;</span>
console.log(binarySearch(arr, 7))<span class="hljs-comment">;  // 输出 3</span>
console.log(binarySearch(arr, 4))<span class="hljs-comment">;  // 输出 -1</span>
</code></pre>
<blockquote>
<p>解析：</p>
<ul>
<li>每次递归缩小查找范围；</li>
<li>递归结束条件是 <code>left &gt; right</code>；</li>
<li>返回目标元素索引或 -1。</li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-13">特征</h3>

























<table><thead><tr><th>函数</th><th>类型</th><th>递归特点</th></tr></thead><tbody><tr><td>阶乘</td><td>非尾递归</td><td>调用后还有乘法操作</td></tr><tr><td>数组求和</td><td>非尾递归</td><td>每次取头递尾</td></tr><tr><td>二分查找</td><td>非尾递归</td><td>分治思想，递归缩小范围</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-14">核心思路</h3>
<ul>
<li>只需提供递归逻辑，<code>createRecursiveFunction</code> 负责自引用；</li>
<li>递归逻辑模板统一：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">logic</span> = (<span class="hljs-params">self</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
  <span class="hljs-comment">// ...递归逻辑</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">self</span>(...args); <span class="hljs-comment">// 调用自身</span>
};
<span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">createRecursiveFunction</span>(logic);
</code></pre>
<p>通过练习，可以更好理解<strong>高阶函数 + 递归</strong>的组合思维，并能应用于实际项目中的树结构、异步任务等场景。</p>
<hr/>
<h2 data-id="heading-15">项目中的实际应用场景</h2>
<p>在真实项目中，高阶函数递归能让代码更灵活、更模块化。<br/>
常见的实战场景包括：</p>
<ul>
<li>树结构遍历（菜单、评论、权限等）</li>
<li>异步重试机制（API 调用失败重试）</li>
<li>动态轮询（等待异步任务完成）</li>
</ul>
<hr/>
<h3 data-id="heading-16">遍历树形菜单</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">createRecursiveFunction</span> = (f) =&gt; {
  return (<span class="hljs-attr">g</span> =&gt; g(g))(h =&gt; f((...args) =&gt; h(h)(...args)))<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

// 扁平化树
const <span class="hljs-attr">flattenTreeLogic</span> = (self) =&gt; (nodes, result = []) =&gt; {
  for (const node of nodes) {
    result.push({ id: node.id, name: node.name })<span class="hljs-comment">;</span>
    if (node.children?.length) self(node.children, result)<span class="hljs-comment">;</span>
  }
  return result<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">flattenTree</span> = createRecursiveFunction(flattenTreeLogic)<span class="hljs-comment">;</span>

const <span class="hljs-attr">menu</span> = [
  { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'首页'</span> },
  {
    id: <span class="hljs-number">2</span>,
    name: <span class="hljs-string">'用户管理'</span>,
    children: [
      { id: <span class="hljs-number">3</span>, name: <span class="hljs-string">'用户列表'</span> },
      { id: <span class="hljs-number">4</span>, name: <span class="hljs-string">'用户详情'</span> },
    ],
  },
]<span class="hljs-comment">;</span>

console.log(flattenTree(menu))<span class="hljs-comment">;</span>
</code></pre>
<p>输出：</p>
<pre><code class="hljs language-bash" lang="bash">[
  { <span class="hljs-built_in">id</span>: 1, name: <span class="hljs-string">'首页'</span> },
  { <span class="hljs-built_in">id</span>: 2, name: <span class="hljs-string">'用户管理'</span> },
  { <span class="hljs-built_in">id</span>: 3, name: <span class="hljs-string">'用户列表'</span> },
  { <span class="hljs-built_in">id</span>: 4, name: <span class="hljs-string">'用户详情'</span> }
]
</code></pre>
<hr/>
<h3 data-id="heading-17">异步重试机制</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createRecursiveFunction</span> = (<span class="hljs-params">f</span>) =&gt; {
  <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> <span class="hljs-title function_">g</span>(g))(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">h</span>(h)(...args)));
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">retryLogic</span> = (<span class="hljs-params">self</span>) =&gt; <span class="hljs-keyword">async</span> (fn, retries = <span class="hljs-number">3</span>, delay = <span class="hljs-number">1000</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn</span>();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">if</span> (retries &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> err;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`重试中，还剩 <span class="hljs-subst">${retries}</span> 次...`</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(r, delay));
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">self</span>(fn, retries - <span class="hljs-number">1</span>, delay);
  }
};

<span class="hljs-keyword">const</span> retry = <span class="hljs-title function_">createRecursiveFunction</span>(retryLogic);

<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">unstableApi</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  count++;
  <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'失败'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">'成功'</span>;
};

<span class="hljs-title function_">retry</span>(unstableApi, <span class="hljs-number">5</span>, <span class="hljs-number">500</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'结果：'</span>, res))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'最终失败:'</span>, err.<span class="hljs-property">message</span>));
</code></pre>
<p>输出：</p>
<pre><code class="hljs language-erlang" lang="erlang">重试中，还剩 <span class="hljs-number">5</span> 次...
重试中，还剩 <span class="hljs-number">4</span> 次...
结果： 成功
</code></pre>
<hr/>
<h3 data-id="heading-18">动态轮询任务</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createRecursiveFunction</span> = (<span class="hljs-params">f</span>) =&gt; {
  <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> <span class="hljs-title function_">g</span>(g))(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">h</span>(h)(...args)));
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">pollingLogic</span> = (<span class="hljs-params">self</span>) =&gt; <span class="hljs-keyword">async</span> (checkFn, interval = <span class="hljs-number">1000</span>, maxTries = <span class="hljs-number">10</span>) =&gt; {
  <span class="hljs-keyword">const</span> done = <span class="hljs-keyword">await</span> <span class="hljs-title function_">checkFn</span>();
  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (maxTries &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`未完成，<span class="hljs-subst">${interval}</span>ms 后再次检查...`</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(r, interval));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">self</span>(checkFn, interval, maxTries - <span class="hljs-number">1</span>);
};

<span class="hljs-keyword">const</span> polling = <span class="hljs-title function_">createRecursiveFunction</span>(pollingLogic);

<span class="hljs-keyword">let</span> progress = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">checkTask</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  progress += <span class="hljs-number">30</span>;
  <span class="hljs-keyword">return</span> progress &gt;= <span class="hljs-number">100</span>;
};

<span class="hljs-title function_">polling</span>(checkTask, <span class="hljs-number">1000</span>, <span class="hljs-number">5</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">done</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(done ? <span class="hljs-string">'任务完成！'</span> : <span class="hljs-string">'超时未完成'</span>);
});
</code></pre>
<hr/>
<h2 data-id="heading-19">从抽象到实用</h2>





















<table><thead><tr><th>场景</th><th>应用优势</th></tr></thead><tbody><tr><td>树结构处理</td><td>灵活定义逻辑，便于复用</td></tr><tr><td>异步重试</td><td>自动化错误恢复</td></tr><tr><td>动态轮询</td><td>可配置、可扩展</td></tr></tbody></table>
<p>高阶函数递归不仅是理论技巧，更是函数式思维在工程化中的体现。<br/>
当逻辑复杂、变化频繁时，用函数组合取代命名函数，可以极大提升灵活性。</p>
<hr/>
<h2 data-id="heading-20">结语</h2>
<p>本文从匿名递归出发，一步步构建了一个通用的递归生成器，并结合项目实战展示了高阶函数递归的实用价值。</p>
<p>这类模式的核心思想是：<br/>
<strong>将递归结构与逻辑解耦，让函数更通用、更可组合。</strong></p>
<p>如果你觉得本文对你有帮助，欢迎点赞、收藏或分享，让更多人了解高阶函数的实际应用。<br/>
你的点赞，就是我继续写作的最大动力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI也能像人一样拥有长时记忆了！谷歌最新研究攻克AI核心难题]]></title>    <link>https://juejin.cn/post/7570885801478111273</link>    <guid>https://juejin.cn/post/7570885801478111273</guid>    <pubDate>2025-11-10T10:44:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570885801478111273" data-draft-id="7570899512782078015" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI也能像人一样拥有长时记忆了！谷歌最新研究攻克AI核心难题"/> <meta itemprop="keywords" content="人工智能,资讯,机器学习"/> <meta itemprop="datePublished" content="2025-11-10T10:44:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="算家计算"/> <meta itemprop="url" content="https://juejin.cn/user/1426490793396571"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI也能像人一样拥有长时记忆了！谷歌最新研究攻克AI核心难题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1426490793396571/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    算家计算
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:44:38.000Z" title="Mon Nov 10 2025 10:44:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>谷歌的新研究，让AI也能像人类一样持续学习而不遗忘了。</p>
</blockquote>
<p>一般情况下，当我们学会一项新技能后，并不会忘记如何走路、说话这些基本能力。然而，这正是人工智能长期面临的困境。当AI学习新知识时，往往会像覆盖旧磁带一样，<strong>损害甚至完全抹去已经掌握的旧技能</strong>，这种现象被称为 <strong>“灾难性遗忘”。</strong></p>
<p>现在，谷歌研究院带来了一项突破性解决方案。11月7日，谷歌正式发布了全新的机器学习范式——<strong>嵌套学习（Nested Learning）</strong> ，直指这个困扰AI领域数十年的根本性难题。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2ada2ecf61d469b9df440ef6799f730~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg566X5a626K6h566X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376278&amp;x-signature=P63QdnOIfCp%2BduDQl0j6o5sGe0w%3D" alt="图表比较了生物脑电波和神经可塑性与嵌套学习模型中使用的均匀结构和多频更新。" loading="lazy"/></p>
<p>灾难性遗忘并非新问题。在传统机器学习中，模型在固定数据集上完成训练后便进入部署阶段。一旦需要学习新任务，模型往往需要重新训练或微调，而这极易导致旧知识被覆盖。</p>
<p>这就好比一个原本精通图像分类的AI系统，在学习目标检测后可能完全丧失原有的识别能力；或者一个语音助手在升级方言理解功能后，反而忘记了标准普通话的处理逻辑。</p>
<p>研究表明，在连续学习超过五个任务后，传统模型的平均性能下降幅度高达<strong>60%以上</strong>。这种局限性严重阻碍了AI在需要长期经验积累的领域应用，如医疗诊断、自动驾驶等。</p>
<p><strong>嵌套学习：统一架构与算法的全新范式</strong></p>
<p>谷歌提出的嵌套学习范式带来了根本性的变革。其核心理念是将模型架构与优化算法统一起来，将复杂模型视为一系列相互嵌套或并行的优化问题。</p>
<p>在嵌套学习框架下，模型中的每个组件都有自己的“上下文流”和更新速率。这就像人脑的学习机制——我们对眼前事物的瞬时记忆更新极快，为考试而进行的短期记忆更新速度次之，而构成世界观、价值观的长期知识则更新得非常缓慢。</p>
<p>谷歌研究团队基于这一范式开发了名为Hope的概念验证模型，它基于Titans架构的自修改循环网络，深度集成了连续体内存系统（CMS）。这种设计使模型能够通过自我参照机制优化自身内存结构，支持近乎无限层级的上下文学习。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f41d1ff4fbbe4408a6f7d2ae57e1c700~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg566X5a626K6h566X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376278&amp;x-signature=RYIj2arIptxlQWMCdzYlVVDQado%3D" alt="图片" loading="lazy"/></p>
<p><strong>技术突破：从深度优化器到连续内存系统</strong></p>
<p>嵌套学习范式的创新体现在三个关键技术突破上。</p>
<p>首先，深度优化器将优化器本身作为可学习模块，改进了目标函数，提升了对不完美数据的鲁棒性。传统优化器如Adam中的动量项，在嵌套学习视角下可被看作是微型的关联记忆模块。</p>
<p>同时，连续体内存系统（CMS）构建了由不同更新频率模块组成的内存光谱，实现了从短期到长期记忆的平滑过渡。CMS由一系列神经网络块连接而成，每个块关联着特定的更新频率，彻底改变了传统AI模型中短期记忆和长期记忆的二元划分。</p>
<p>自修改架构则使模型能够根据任务动态调整自身的学习算法，包括注意力机制中的键、值、查询投影等关键部分。这让模型拥有了在使用过程中不断优化自己学习策略的能力。</p>
<p><strong>实验结果</strong></p>
<p>在实验评估中，Hope模型在语言建模与常识推理任务中表现出<strong>更低的困惑度和更高的准确性</strong>，优于现代循环模型和标准Transformer架构。</p>
<p>特别引人注目的是，在“大海捞针”测试中，Hope展示出了卓越的长文本记忆与检索能力，验证了CMS在处理超长序列信息中的有效性。这一测试结果证明了嵌套学习范式在解决灾难性遗忘问题上的潜力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e51b47fd09a40c38d8de12a878a98fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg566X5a626K6h566X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376278&amp;x-signature=ynKoPRwgsLVhsEfgTNTUw3T5nV4%3D" alt="条形图显示 Hope 和 Titans 模型在三个难度级别的长上下文任务中始终优于 TTT 和 Mamba2。" loading="lazy"/></p>
<p>研究团队在340M、760M和1.3B三种参数规模的Hope模型上进行了全面测试，Hope的平均分超越了所有对比模型。这表明嵌套学习范式在不同规模的模型上都能发挥积极作用。</p>
<p>嵌套学习的意义远不止于技术层面的突破。它为实现持续学习的人工智能系统开辟了全新路径。</p>
<p>这一技术将可能很大程度上改变那些需要终身学习的应用领域，比如机器人、自动驾驶、个性化AI助手等。这些系统将不再需要昂贵的、从头开始的再训练，而是能够像人类一样，在保留已有知识的基础上，不断学习和成长。</p>
<p>正如谷歌研究人员所言：“我们相信嵌套学习范式为弥补当前大语言模型有限、易遗忘的特性与人脑卓越的持续学习能力之间的差距奠定了坚实基础。”</p>
<p>当然，这项研究仍在发展之中。研究人员指出，目前的工作主要聚焦于记忆的在线巩固过程，对类似人脑睡眠时的离线重放和整理机制探索有限。但这无疑让我们距离那个能像人类一样持续学习、不断进化的通用人工智能又近了一步。</p>
<p>大家怎么看？欢迎交流讨论~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析]]></title>    <link>https://juejin.cn/post/7570500819889258539</link>    <guid>https://juejin.cn/post/7570500819889258539</guid>    <pubDate>2025-11-10T07:42:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570500819889258539" data-draft-id="7570339961909936171" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-10T07:42:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="_摘星_"/> <meta itemprop="url" content="https://juejin.cn/user/2228036358374227"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2228036358374227/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    _摘星_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T07:42:20.000Z" title="Mon Nov 10 2025 07:42:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbf8c323836144e0a235cdd139b387df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=NqRjTiwbrXaLr8NSHXVb96vu55g%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析</h2>
<h3 data-id="heading-1">摘要</h3>
<p>本文详细介绍了在共绩算力平台上部署通义千问2.5-7B-Instruct大模型的全流程实践。共绩算力作为清华背景创业团队打造的创新平台，通过整合全国分散的闲置算力资源（包括个人电脑、网吧空闲机时和企业未充分利用的算力），构建了极具价格优势的算力网络。平台提供两种核心服务：适合长期开发的Server云主机（4090单卡仅1.68元/小时，关机环境持久保存）和面向生产的Serverless弹性部署（秒级冷启动，零运维）。文章详细记录了从算力选择、镜像配置到模型下载、基准测试的完整过程，实测证明单张4090显卡即可高效运行7B级别大模型，为AI开发者提供了高性价比的云部署方案。</p>
<h3 data-id="heading-2">共绩算力</h3>
<h4 data-id="heading-3">平台概述</h4>
<p>共绩科技 2023 年成立于清华，专注于构建融合算力与电力的智能调度网络，旨在提供平价、可靠、绿色的算力服务，使 AI 技术真正普及至每个人。通过精细调度算法，已为多家 AIGC 领军企业及科研机构提供高效算力，目标提升资源利用率 60%。作为一群清华背景的年轻创新者，我们在 2023 年秋季获得奇绩创坛等投资，正引领算力革命，开启普惠科技新篇章。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d802b6b0c7845e4b528723d3c447f9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=l%2Bd5MxbBzx2rbGlWxVEfn0qtptk%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-4">核心功能</h4>
<p>共绩算力平台为开发者和企业提供两大核心服务模式：<strong>Server 云主机</strong> 和 <strong>Serverless 弹性部署</strong>，满足不同场景下的算力需求。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a77e2f330bf48239050207668482dfc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=j36Mru%2BXnwssw%2ByMAEHLX53IjMY%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-5">Server 云主机</h5>
<p>专为需要稳定、持久开发环境的用户设计。平台拥有上万块高性能4090显卡随时待命，让每个开发者都能轻松拥有顶级算力，无需为数万元的硬件投入望而却步。</p>
<p>核心优势：</p>
<ul>
<li><strong>告别硬件投资</strong>：无需购买昂贵的GPU服务器，按需租用即可。</li>
<li><strong>环境永久保存</strong>：关机后开发环境不会丢失，下次开机即恢复，省去重复搭建环境的烦恼。</li>
<li><strong>专注代码开发</strong>：将精力完全集中在算法和业务逻辑上，而非基础设施管理。</li>
</ul>
<p>关键参数：</p>
<ul>
<li><strong>10万+ 显卡数量</strong>：海量资源池，保障随时可用。</li>
<li><strong>1.68元/时 起步价</strong>：极具竞争力的价格，让高性能计算触手可及。</li>
<li><strong>关机保存 持久化</strong>：支持关机状态下的环境持久化，保障开发连续性。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>开发测试</li>
<li>学习训练</li>
<li>长期项目研发</li>
</ul>
<p><strong>选择 Server 云主机，当您面临以下困扰时：</strong></p>
<ul>
<li>每次重新搭建开发环境太麻烦</li>
<li>需要一个稳定的长期开发环境</li>
<li>不需要对外提供在线服务</li>
</ul>
<hr/>
<h5 data-id="heading-6">Serverless 弹性部署</h5>
<p>面向生产级应用和流量波动场景，提供零运维、秒级冷启动的极致体验。写完代码，10秒内即可上线，按实际使用量付费，真正做到“用多少付多少”，实现0运维成本。</p>
<p>核心优势：</p>
<ul>
<li><strong>告别运维烦恼</strong>：无需关心服务器运维、扩容、监控等底层问题。</li>
<li><strong>弹性应对流量</strong>：智能自动扩缩容，从容应对突发流量高峰。</li>
<li><strong>专注产品开发</strong>：开发者只需关注产品本身，基础设施由平台全权托管。</li>
</ul>
<p>关键指标：</p>
<ul>
<li><strong>99.9% 可用性</strong>：高可靠性保障线上服务稳定运行。</li>
<li><strong>秒级冷启动</strong>：从代码提交到服务上线仅需10秒，响应迅速。</li>
<li><strong>0运维 零负担</strong>：无服务器管理负担，释放团队生产力。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>生产服务部署</li>
<li>突发流量应对（如营销活动、热点事件）</li>
<li>在线用户访问服务</li>
</ul>
<p><strong>选择 Serverless 弹性部署，当您面临以下挑战时：</strong></p>
<ul>
<li>担心突发流量导致服务宕机</li>
<li>不想花时间在服务器运维上</li>
<li>希望严格控制云服务成本</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bb5dddc68d8427a9965c18dbea91488~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=h3Ti9u3hbRR3MYJ1%2BDxn5j6LGjw%3D" alt="" loading="lazy"/></p>
<p>无论是追求环境稳定、适合长期开发的 <strong>Server 云主机</strong>，还是追求极致效率、零运维负担的 <strong>Serverless 弹性部署</strong>，共绩算力平台都提供了针对性强、性价比极高的解决方案，帮助开发者和企业摆脱基础设施束缚，专注于价值创造。</p>
<h4 data-id="heading-7">技术架构</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b8f2f05d8124544ab16b65434e3ac30~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=4i1Du2UiYkO%2FaFw7w6R3VoCdkPg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-8">降本增效</h4>
<p>共绩算力平台的核心优势之一在于其极具竞争力的价格体系，真正实现了“降本增效”，让每一分钱都花在刀刃上。与传统云服务商动辄数十元甚至上百元每小时的GPU算力相比，共绩平台提供的4090显卡算力价格低至<strong>1.68元/小时（单卡）</strong> ，双卡配置仅需<strong>3.36元/小时</strong>，四卡集群也仅为<strong>6.72元/小时</strong>。这种按秒计费的精细化模式，意味着用户只需为实际使用的每一秒付费，避免了传统按小时计费带来的资源浪费和成本冗余。</p>
<p>更重要的是，这些价格背后是平台创新的商业模式——通过整合全国范围内的个人闲置电脑、网吧空闲机时以及企业未充分利用的算力资源，构建了一个庞大的分布式算力网络。这种“共享经济”模式大幅降低了基础设施的边际成本，从而将节省下来的费用直接回馈给终端用户。无论是AI初创团队进行模型训练，还是个人开发者部署推理服务，都能以极低的成本获得高性能的4090 GPU算力支持，彻底告别“算力焦虑”，把宝贵的预算集中投入到核心算法研发和业务创新上，而非昂贵的硬件投入或云服务账单中。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6e01e0cc712464c85604d7598c94cb2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=ibNJ0SSn9l8wUWGMS5%2BGYi0HagU%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-9">平台对比分析</h4>



























































<table><thead><tr><th>对比维度</th><th>共绩算力平台</th><th>传统云服务商</th><th>自建GPU集群</th></tr></thead><tbody><tr><td><strong>成本模式</strong></td><td>按秒级精准计费，只为使用时间付费</td><td>按小时/月计费，存在资源浪费</td><td>高额前期投入，固定成本高</td></tr><tr><td><strong>资源弹性</strong></td><td>秒级扩容缩容，动态适应业务需求</td><td>分钟级扩容，存在一定延迟</td><td>无法弹性扩展，需提前规划</td></tr><tr><td><strong>资源来源</strong></td><td>整合全国分散闲时算力，包括个人/网吧/智算中心</td><td>自有数据中心，资源集中</td><td>企业自购硬件，资源固定</td></tr><tr><td><strong>部署速度</strong></td><td>3分钟快速部署AI服务</td><td>10-30分钟创建实例</td><td>数天到数周的部署周期</td></tr><tr><td><strong>技术门槛</strong></td><td>一站式GPU开发环境，降低配置复杂度</td><td>需要一定云服务使用经验</td><td>需要专业运维团队支持</td></tr><tr><td><strong>绿色节能</strong></td><td>利用闲置算力，提高资源利用率，更环保</td><td>数据中心能耗较高</td><td>能源利用率低，存在浪费</td></tr><tr><td><strong>适用场景</strong></td><td>AI推理/训练、科研计算、临时高算力需求</td><td>通用云计算、企业应用</td><td>长期稳定的大规模计算需求</td></tr><tr><td><strong>价格优势</strong></td><td>价格更低，性价比高</td><td>价格中等，按量付费</td><td>长期使用成本高</td></tr></tbody></table>
<h3 data-id="heading-10">魔搭社区和通义千问2.5-7B-Instruct</h3>
<h4 data-id="heading-11">概述</h4>
<p>魔搭社区（ModelScope）是阿里巴巴推出的<strong>模型开放平台</strong>，致力于打造“<strong>模型即服务</strong>（MaaS）”的生态体系。该平台提供海量高质量机器学习和深度学习模型，覆盖自然语言处理、计算机视觉、语音识别、多模态等多个技术领域。</p>
<h4 data-id="heading-12">魔搭社区核心特点：</h4>
<ul>
<li><strong>模型丰富</strong>：汇聚数千个开源模型，包括阿里自研模型及社区贡献模型</li>
<li><strong>开箱即用</strong>：提供一键推理、在线体验、Notebook实例等功能，降低使用门槛</li>
<li><strong>全链路支持</strong>：从模型探索、训练、推理到部署，提供完整工具链</li>
<li><strong>社区活跃</strong>：支持模型分享、评测、讨论，促进AI技术交流与创新</li>
<li><strong>企业级能力</strong>：支持私有化部署、模型定制和商业化服务</li>
</ul>
<p>魔搭不仅是模型仓库，更是连接模型开发者与使用者的桥梁，推动AI技术的普惠化和产业化。</p>
<h4 data-id="heading-13">通义千问2.5-7B-Instruct模型下载指南</h4>
<p>在魔搭社区模型库中找到通义千问2.5-7B-Instruct并进入详情</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b8f05ac2bad48848afe62960ffaa508~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Sv6QfNlYdwG7P0pu5amKyuWrGqM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3172b3d49c6d49b1a613f0845d3d2f9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=VP4IRFBtateMToNutMJMeG9lLGk%3D" alt="" loading="lazy"/></p>
<p>按照官方给出的下载模型配置待会到共绩算力平台中进行部署</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e703a892ad674e6dba3125822a71503f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=s2dA7VtXpU6XImque8IxWY8vfy0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-14">云主机部署实践</h3>
<h4 data-id="heading-15">算力选择</h4>
<p>进入共绩算力云主机页面中：<a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.suanli.cn%2Fserver" target="_blank" title="https://console.suanli.cn/server" ref="nofollow noopener noreferrer">console.suanli.cn/server</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c10156d327248e3820a85285f80009e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=W6y2Y2PGkWgp8acJwmYSsK7FbRk%3D" alt="" loading="lazy"/></p>
<p>可以看到价格和算力性价比真的是十分高，这里分别展示1核、2核、4核、8核的价格对比</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87e253990f864fcd84491b31901bc1be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=RNYefLeymLnk6qVOxc8cpkKck20%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8448a7f942524b948bdcfe048c88aa3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Vfhr7mH%2F7R479pBQR2gULKcblvQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2b7c30dc8ed4e4dbba7b47597cac949~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=SOvjaYzIaegW%2FwS7NMGVY9K21wI%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3408630133fa4a74b19ab67eab1c10c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=NVOrKOOf1bULkW911fnSmGWALEA%3D" alt="" loading="lazy"/></p>
<p>那么我们之类选择单核即可</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3a2fbb8eb46489d8ccbc460d8ab311e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=WLks5riAzzenWgyUOsWwejbnQRM%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-16">镜像选择</h4>
<p>共绩算力的基础镜像中为我们提供了三种框架的选择</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5beac96bc43c41ccb7cd063dfbea6566~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Oy%2FO1gaOcvk%2FPiEfqGiZDMCtQFM%3D" alt="" loading="lazy"/></p>
<p>我们这里的配置如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bdcab40750f549f5b27f204d0941579b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=8A5LZdhflFjnGU9MtBvbQNpXq%2F0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/074b0e59c4464e38b393fd2613235454~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=UBChD193HNeOxEwDEUAcn6ZXqv4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae67f7624e2f471985318452ff926797~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=YdR6Kwjxo2DmxldzyY7uUZJMNzQ%3D" alt="" loading="lazy"/></p>
<p>🖥️ 云服务器实例配置详情</p>

































<table><thead><tr><th>配置类别</th><th>详细参数</th></tr></thead><tbody><tr><td><strong>设备型号</strong></td><td>NVIDIA GeForce RTX 4090 / 24GB 显存</td></tr><tr><td><strong>所属区域</strong></td><td>重庆一区</td></tr><tr><td><strong>CPU 核心数</strong></td><td>20 核</td></tr><tr><td><strong>内存容量</strong></td><td>101 GB</td></tr><tr><td><strong>CUDA 支持</strong></td><td>11.3 ~ 12.8（驱动版本：470.82.01+）</td></tr><tr><td><strong>系统硬盘</strong></td><td>50 GB</td></tr></tbody></table>
<p>🐍 系统镜像配置</p>





























<table><thead><tr><th>组件类型</th><th>版本/规格</th></tr></thead><tbody><tr><td>框架名称</td><td>PyTorch</td></tr><tr><td>框架版本</td><td>2.7.1</td></tr><tr><td>Python 版本</td><td>3.12 (Ubuntu 22.04)</td></tr><tr><td>CUDA 版本</td><td>12.8</td></tr><tr><td>镜像类型</td><td>基础镜像（含深度学习框架、Miniconda等常用工具）</td></tr></tbody></table>
<p>同时共绩算力中还提供了社区用户自己开发的镜像，我也会在后续的文章中进行试用</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/09585e47df4044f080d42df65465c080~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Z8Qtp%2FDRqs3ManOcs%2BkFSFYgb8w%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-17">创建实例</h4>
<p>点击创建实例之后，共绩算力就会在后台自动为我们创建刚刚选好的云主机</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3201969bfb5e4567931c1ca39cdd9096~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=8nGwcN4VvV0Lps2YgwB29mm1LoA%3D" alt="" loading="lazy"/></p>
<p>并且共绩算力这里提供了三种快捷操作方式，这里我选择Jupyter Lab</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd22f0a6068a4d018c50a3e011bcdb6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=sgE9Y3cQdBqpT0jWn3emxzU0uqE%3D" alt="" loading="lazy"/></p>
<p>进入Jupyter Lab之后进入到终端</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3120ee067a7945a6b110060ea1ff474a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=sypDz00V78EViwbSg2Di%2BJEP%2BdE%3D" alt="" loading="lazy"/></p>
<p>执行下方命令从魔搭社区中下载Qwen/Qwen2.5-7B-Instruct模型</p>
<pre><code class="hljs language-css" lang="css">pip install modelscope
modelscope download <span class="hljs-attr">--model</span> Qwen/Qwen2.<span class="hljs-number">5</span>-<span class="hljs-number">7</span>B-Instruct
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9e9c2d95dc947a983c4c80e57e8402d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=bBl7e3dokCD80CPylBWrwHSbseg%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs">pip install transformers torch tqdm accelerate
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6535f72961114d409ba02c756cf7a9c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=%2BV6Je5FRRJxGsEHw1n%2BUWMVKzzQ%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-18">基准测试</h4>
<p>准备好下方的基准测试脚本</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM
<span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> os

<span class="hljs-comment"># ========== 配置参数 ==========</span>
MODEL_NAME = <span class="hljs-string">"/root/.cache/modelscope/hub/models/Qwen/Qwen2.5-7B-Instruct"</span>
WARMUP_STEPS = <span class="hljs-number">1</span>
TEST_STEPS = <span class="hljs-number">3</span>
BATCH_SIZES = [<span class="hljs-number">1</span>]  <span class="hljs-comment"># 简化测试</span>
MAX_NEW_TOKENS = <span class="hljs-number">128</span>

<span class="hljs-comment"># 🌐 五种测试场景的提示词</span>
TEST_SCENARIOS = {
    <span class="hljs-string">"🇨🇳 中文生成"</span>: <span class="hljs-string">"今天天气真好，我想去"</span>,
    <span class="hljs-string">"🇺🇸 英文生成"</span>: <span class="hljs-string">"The capital of France is"</span>,
    <span class="hljs-string">"🧠 逻辑推理"</span>: <span class="hljs-string">"如果所有的A都是B，而所有的B都是C，那么所有的A是C吗？请详细解释。"</span>,
    <span class="hljs-string">"💻 代码生成"</span>: <span class="hljs-string">"用Python写一个快速排序算法"</span>,
    <span class="hljs-string">"📖 知识问答"</span>: <span class="hljs-string">"量子力学中的薛定谔方程是用来描述什么的？"</span>
}

<span class="hljs-comment"># ========== 工具函数 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">print_gpu_memory</span>():
    <span class="hljs-string">"""📊 打印当前GPU内存使用情况"""</span>
    allocated = torch.cuda.memory_allocated() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    reserved = torch.cuda.memory_reserved() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    max_allocated = torch.cuda.max_memory_allocated() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"💽 GPU内存: 已分配 <span class="hljs-subst">{allocated:<span class="hljs-number">.2</span>f}</span>GB | 预留 <span class="hljs-subst">{reserved:<span class="hljs-number">.2</span>f}</span>GB | 峰值 <span class="hljs-subst">{max_allocated:<span class="hljs-number">.2</span>f}</span>GB"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">format_time</span>(<span class="hljs-params">seconds</span>):
    <span class="hljs-string">"""⏱️ 格式化时间显示"""</span>
    <span class="hljs-keyword">if</span> seconds &lt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{seconds*<span class="hljs-number">1000</span>:<span class="hljs-number">.2</span>f}</span> ms"</span>
    <span class="hljs-keyword">elif</span> seconds &lt; <span class="hljs-number">60</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{seconds:<span class="hljs-number">.2</span>f}</span> 秒"</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{seconds/<span class="hljs-number">60</span>:<span class="hljs-number">.2</span>f}</span> 分钟"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">display_banner</span>(<span class="hljs-params">title</span>):
    <span class="hljs-string">"""🎉 显示漂亮的标题横幅"""</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{<span class="hljs-string">'='</span> * <span class="hljs-number">60</span>}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✨ <span class="hljs-subst">{title}</span> ✨"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">'='</span> * <span class="hljs-number">60</span>}</span>"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_with_stats</span>(<span class="hljs-params">model, tokenizer, prompt, max_new_tokens=MAX_NEW_TOKENS</span>):
    <span class="hljs-string">"""⚡ 执行单次生成并收集统计信息"""</span>
    <span class="hljs-comment"># 准备输入</span>
    inputs = tokenizer(prompt, return_tensors=<span class="hljs-string">"pt"</span>).to(model.device)
    input_length = inputs.input_ids.shape[<span class="hljs-number">1</span>]

    <span class="hljs-comment"># 生成</span>
    start_time = time.perf_counter()
    <span class="hljs-keyword">with</span> torch.no_grad():
        outputs = model.generate(
            **inputs,
            max_new_tokens=max_new_tokens,
            do_sample=<span class="hljs-literal">True</span>,
            temperature=<span class="hljs-number">0.7</span>,
            top_p=<span class="hljs-number">0.9</span>
        )
    end_time = time.perf_counter()

    <span class="hljs-comment"># 计算指标</span>
    generation_time = end_time - start_time
    generated_tokens = outputs[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>] - input_length
    tokens_per_second = generated_tokens / generation_time <span class="hljs-keyword">if</span> generation_time &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>

    <span class="hljs-comment"># 解码生成的文本</span>
    generated_text = tokenizer.decode(outputs[<span class="hljs-number">0</span>][input_length:], skip_special_tokens=<span class="hljs-literal">True</span>)

    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"time"</span>: generation_time,
        <span class="hljs-string">"tokens_generated"</span>: generated_tokens,
        <span class="hljs-string">"tokens_per_second"</span>: tokens_per_second,
        <span class="hljs-string">"output_text"</span>: generated_text,
        <span class="hljs-string">"memory_used"</span>: torch.cuda.max_memory_allocated() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    }

<span class="hljs-comment"># ========== 主测试函数 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">benchmark_model</span>():
    display_banner(<span class="hljs-string">"🚀 模型加载中"</span>)

    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 加载模型和tokenizer</span>
        tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME, trust_remote_code=<span class="hljs-literal">True</span>)
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_NAME,
            device_map=<span class="hljs-string">"auto"</span>,
            torch_dtype=torch.bfloat16,
            trust_remote_code=<span class="hljs-literal">True</span>
        )
        model.<span class="hljs-built_in">eval</span>()

        <span class="hljs-comment"># 打印模型信息</span>
        device = <span class="hljs-built_in">next</span>(model.parameters()).device
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ 模型加载成功！"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🧠 模型: <span class="hljs-subst">{MODEL_NAME}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🖥️  设备: <span class="hljs-subst">{device}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🔧 数据类型: <span class="hljs-subst">{model.dtype}</span>"</span>)
        print_gpu_memory()
        
        <span class="hljs-comment"># ========== 预热 ==========</span>
        display_banner(<span class="hljs-string">"🔥 预热阶段"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"预热模型中..."</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(WARMUP_STEPS):
            _ = generate_with_stats(model, tokenizer, <span class="hljs-string">"你好"</span>, max_new_tokens=<span class="hljs-number">32</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"预热步骤 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>/<span class="hljs-subst">{WARMUP_STEPS}</span> 完成"</span>)
        
        <span class="hljs-comment"># ========== 五种场景测试 ==========</span>
        all_results = {}
        
        <span class="hljs-keyword">for</span> scenario_name, prompt <span class="hljs-keyword">in</span> TEST_SCENARIOS.items():
            display_banner(<span class="hljs-string">f"🔍 <span class="hljs-subst">{scenario_name}</span> 测试"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📝 测试提示: "</span>{prompt}<span class="hljs-string">""</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🔄 执行 <span class="hljs-subst">{TEST_STEPS}</span> 次迭代..."</span>)
            
            scenario_results = []
            
            <span class="hljs-comment"># 预先清除GPU缓存</span>
            torch.cuda.empty_cache()
            torch.cuda.reset_peak_memory_stats()
            
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(TEST_STEPS), desc=<span class="hljs-string">f"⏳ <span class="hljs-subst">{scenario_name}</span>"</span>):
                result = generate_with_stats(model, tokenizer, prompt)
                scenario_results.append(result)
                        
                <span class="hljs-comment"># 打印单次结果</span>
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{scenario_name}</span> - 迭代 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>/<span class="hljs-subst">{TEST_STEPS}</span>:"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   ⏱️  生成时间: <span class="hljs-subst">{format_time(result[<span class="hljs-string">'time'</span>])}</span>"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📏 生成长度: <span class="hljs-subst">{result[<span class="hljs-string">'tokens_generated'</span>]}</span> tokens"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🚀 生成速度: <span class="hljs-subst">{result[<span class="hljs-string">'tokens_per_second'</span>]:<span class="hljs-number">.2</span>f}</span> tokens/秒"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   💾 峰值内存: <span class="hljs-subst">{result[<span class="hljs-string">'memory_used'</span>]:<span class="hljs-number">.2</span>f}</span> GB"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🎯 生成内容: <span class="hljs-subst">{result[<span class="hljs-string">'output_text'</span>][:<span class="hljs-number">50</span>]}</span>..."</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result[<span class="hljs-string">'output_text'</span>]) &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">else</span> <span class="hljs-string">f"   🎯 生成内容: <span class="hljs-subst">{result[<span class="hljs-string">'output_text'</span>]}</span>"</span>)
            
            <span class="hljs-comment"># 计算平均值</span>
            avg_time = <span class="hljs-built_in">sum</span>(r[<span class="hljs-string">"time"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results) / TEST_STEPS
            avg_tokens = <span class="hljs-built_in">sum</span>(r[<span class="hljs-string">"tokens_generated"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results) / TEST_STEPS
            avg_speed = <span class="hljs-built_in">sum</span>(r[<span class="hljs-string">"tokens_per_second"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results) / TEST_STEPS
            max_memory = <span class="hljs-built_in">max</span>(r[<span class="hljs-string">"memory_used"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results)
            
            all_results[scenario_name] = {
                <span class="hljs-string">"avg_time"</span>: avg_time,
                <span class="hljs-string">"avg_tokens"</span>: avg_tokens,
                <span class="hljs-string">"avg_speed"</span>: avg_speed,
                <span class="hljs-string">"max_memory"</span>: max_memory,
                <span class="hljs-string">"sample_output"</span>: scenario_results[-<span class="hljs-number">1</span>][<span class="hljs-string">"output_text"</span>],
                <span class="hljs-string">"prompt"</span>: prompt
            }
            
            <span class="hljs-comment"># 显示该场景的平均结果</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{scenario_name}</span> - 平均性能:"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   ⏱️  平均时间: <span class="hljs-subst">{format_time(avg_time)}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📏 平均长度: <span class="hljs-subst">{avg_tokens:<span class="hljs-number">.1</span>f}</span> tokens"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🚀 平均速度: <span class="hljs-subst">{avg_speed:<span class="hljs-number">.2</span>f}</span> tokens/秒"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   💾 峰值内存: <span class="hljs-subst">{max_memory:<span class="hljs-number">.2</span>f}</span> GB"</span>)
    
        <span class="hljs-keyword">return</span> all_results, model, tokenizer
    
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 基准测试失败: <span class="hljs-subst">{<span class="hljs-built_in">str</span>(e)}</span>"</span>)
        <span class="hljs-keyword">import</span> traceback
        traceback.print_exc()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>

<span class="hljs-comment"># ========== 结果可视化 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">display_results</span>(<span class="hljs-params">all_results</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all_results:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 无测试结果"</span>)
        <span class="hljs-keyword">return</span>
    
    display_banner(<span class="hljs-string">"📈 基准测试结果汇总"</span>)
    
    <span class="hljs-comment"># 创建结果表格</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n📊 性能对比:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> * <span class="hljs-number">90</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"| <span class="hljs-subst">{<span class="hljs-string">'测试场景'</span>:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'平均时间'</span>:&lt;<span class="hljs-number">12</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'平均速度'</span>:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'平均长度'</span>:&lt;<span class="hljs-number">10</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'峰值内存'</span>:&lt;<span class="hljs-number">10</span>}</span> |"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">14</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">13</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">16</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">11</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">11</span> + <span class="hljs-string">"|"</span>)
    
    <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
        time_str = format_time(metrics[<span class="hljs-string">"avg_time"</span>])
        speed_str = <span class="hljs-string">f"<span class="hljs-subst">{metrics[<span class="hljs-string">'avg_speed'</span>]:<span class="hljs-number">.2</span>f}</span> t/s"</span>
        tokens_str = <span class="hljs-string">f"<span class="hljs-subst">{metrics[<span class="hljs-string">'avg_tokens'</span>]:<span class="hljs-number">.1</span>f}</span>"</span>
        mem_str = <span class="hljs-string">f"<span class="hljs-subst">{metrics[<span class="hljs-string">'max_memory'</span>]:<span class="hljs-number">.2</span>f}</span> GB"</span>
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"| <span class="hljs-subst">{scenario:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{time_str:&lt;<span class="hljs-number">12</span>}</span> | <span class="hljs-subst">{speed_str:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{tokens_str:&lt;<span class="hljs-number">10</span>}</span> | <span class="hljs-subst">{mem_str:&lt;<span class="hljs-number">10</span>}</span> |"</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> * <span class="hljs-number">90</span>)
    
    <span class="hljs-comment"># 显示详细输出样本</span>
    display_banner(<span class="hljs-string">"🎨 生成示例"</span>)
    <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{scenario}</span> 示例:"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📝 提示: "</span>{metrics[<span class="hljs-string">'prompt'</span>]}<span class="hljs-string">""</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✏️  生成: <span class="hljs-subst">{metrics[<span class="hljs-string">'sample_output'</span>]}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> * <span class="hljs-number">60</span>)

<span class="hljs-comment"># ========== 保存结果 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">save_results</span>(<span class="hljs-params">all_results</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all_results:
        <span class="hljs-keyword">return</span>
    
    <span class="hljs-comment"># 保存详细结果</span>
    timestamp = time.strftime(<span class="hljs-string">"%Y%m%d_%H%M%S"</span>)
    filename = <span class="hljs-string">f"benchmark_results_<span class="hljs-subst">{timestamp}</span>.json"</span>
    
    serializable_results = {}
    <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
        serializable_results[scenario] = {
            <span class="hljs-string">"avg_time"</span>: metrics[<span class="hljs-string">"avg_time"</span>],
            <span class="hljs-string">"avg_tokens"</span>: metrics[<span class="hljs-string">"avg_tokens"</span>],
            <span class="hljs-string">"avg_speed"</span>: metrics[<span class="hljs-string">"avg_speed"</span>],
            <span class="hljs-string">"max_memory"</span>: metrics[<span class="hljs-string">"max_memory"</span>],
            <span class="hljs-string">"sample_output"</span>: metrics[<span class="hljs-string">"sample_output"</span>],
            <span class="hljs-string">"prompt"</span>: metrics[<span class="hljs-string">"prompt"</span>]
        }
    
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">"w"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
        json.dump(serializable_results, f, indent=<span class="hljs-number">2</span>, ensure_ascii=<span class="hljs-literal">False</span>)
    
    <span class="hljs-comment"># 保存简化报告</span>
    report_file = <span class="hljs-string">f"benchmark_report_<span class="hljs-subst">{timestamp}</span>.txt"</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(report_file, <span class="hljs-string">"w"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
        f.write(<span class="hljs-string">"通义千问2.5-7B-Instruct 基准测试报告\n"</span>)
        f.write(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span> + <span class="hljs-string">"\n"</span>)
        f.write(<span class="hljs-string">f"测试时间: <span class="hljs-subst">{time.ctime()}</span>\n"</span>)
        f.write(<span class="hljs-string">f"模型路径: <span class="hljs-subst">{MODEL_NAME}</span>\n"</span>)
        f.write(<span class="hljs-string">f"测试迭代: <span class="hljs-subst">{TEST_STEPS}</span> 次\n"</span>)
        f.write(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span> + <span class="hljs-string">"\n\n"</span>)
        
        <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
            f.write(<span class="hljs-string">f"<span class="hljs-subst">{scenario}</span> 测试:\n"</span>)
            f.write(<span class="hljs-string">f"  - 平均生成时间: <span class="hljs-subst">{format_time(metrics[<span class="hljs-string">'avg_time'</span>])}</span>\n"</span>)
            f.write(<span class="hljs-string">f"  - 平均生成速度: <span class="hljs-subst">{metrics[<span class="hljs-string">'avg_speed'</span>]:<span class="hljs-number">.2</span>f}</span> tokens/秒\n"</span>)
            f.write(<span class="hljs-string">f"  - 平均生成长度: <span class="hljs-subst">{metrics[<span class="hljs-string">'avg_tokens'</span>]:<span class="hljs-number">.1</span>f}</span> tokens\n"</span>)
            f.write(<span class="hljs-string">f"  - 峰值内存使用: <span class="hljs-subst">{metrics[<span class="hljs-string">'max_memory'</span>]:<span class="hljs-number">.2</span>f}</span> GB\n"</span>)
            f.write(<span class="hljs-string">f"  - 测试提示: "</span>{metrics[<span class="hljs-string">'prompt'</span>]}<span class="hljs-string">"\n"</span>)
            f.write(<span class="hljs-string">f"  - 生成示例: <span class="hljs-subst">{metrics[<span class="hljs-string">'sample_output'</span>]}</span>\n"</span>)
            f.write(<span class="hljs-string">"-"</span> * <span class="hljs-number">60</span> + <span class="hljs-string">"\n\n"</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n✅ 结果已保存至:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📁 详细数据: <span class="hljs-subst">{filename}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📝 简明报告: <span class="hljs-subst">{report_file}</span>"</span>)

<span class="hljs-comment"># ========== 主程序 ==========</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"🌟 通义千问2.5-7B-Instruct 基准测试工具 🌟"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"🔧 配置参数:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🧪 模型路径: <span class="hljs-subst">{MODEL_NAME}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🔥 预热次数: <span class="hljs-subst">{WARMUP_STEPS}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📊 测试迭代: <span class="hljs-subst">{TEST_STEPS}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📏 生成长度: <span class="hljs-subst">{MAX_NEW_TOKENS}</span> tokens"</span>)
    
    <span class="hljs-comment"># 执行基准测试</span>
    results, model, tokenizer = benchmark_model()
    
    <span class="hljs-comment"># 显示和保存结果</span>
    <span class="hljs-keyword">if</span> results:
        display_results(results)
        save_results(results)
        
        <span class="hljs-comment"># 清理资源</span>
        <span class="hljs-keyword">if</span> model:
            <span class="hljs-keyword">del</span> model
        <span class="hljs-keyword">if</span> tokenizer:
            <span class="hljs-keyword">del</span> tokenizer
        torch.cuda.empty_cache()
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n🎉 基准测试完成! GPU内存已清理."</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n❌ 基准测试未能完成，请检查错误信息。"</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n💡 提示: 要获得更准确的结果，可增加TEST_STEPS的值。"</span>)
</code></pre>
<p>执行基准测试脚本</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c9a61d23ac54cbbb9430645b4d2f273~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=nHNV0k8jayxdAUbiWFTEICXxvzk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/225e4d803a3e4919a20cf4dec5f85971~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=EJEazrVPHB7KuONBZIbak9OCpaI%3D" alt="" loading="lazy"/></p>
<p>生成的基准测试报告：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b908b4676974ad6938954be98f7d16b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=ejsMvMqU%2BWJCKPTT%2Fr16XL8pHKM%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-19">基准测试分析报告</h4>
<h5 data-id="heading-20">📌 概览摘要</h5>
<p><strong>测试时间</strong>：2025年11月10日 06:58:01<br/>
<strong>测试模型</strong>：Qwen2.5-7B-Instruct<br/>
<strong>硬件环境</strong>：NVIDIA RTX 4090 (24GB显存)<br/>
<strong>测试轮次</strong>：3次迭代/场景</p>
<p>💡 <strong>关键发现</strong>：该模型在各种任务类型中表现均衡，平均推理速度达 <strong>55.72 tokens/秒</strong>，内存占用稳定在 <strong>14.21GB</strong>，中文与英文处理能力相当，适合多场景部署。</p>
<hr/>
<h5 data-id="heading-21">🧪 测试环境与方法</h5>





























<table><thead><tr><th>项目</th><th>配置</th></tr></thead><tbody><tr><td><strong>模型路径</strong></td><td><code>/root/.cache/modelscope/hub/models/Qwen/Qwen2.5-7B-Instruct</code></td></tr><tr><td><strong>计算设备</strong></td><td>NVIDIA GeForce RTX 4090 (24GB VRAM)</td></tr><tr><td><strong>数据类型</strong></td><td>bfloat16</td></tr><tr><td><strong>最大生成长度</strong></td><td>128 tokens</td></tr><tr><td><strong>采样参数</strong></td><td>temperature=0.7, top_p=0.9</td></tr></tbody></table>
<h5 data-id="heading-22">测试方法</h5>
<ul>
<li><strong>预热步骤</strong>：1次预热运行，排除首次加载开销</li>
<li><strong>正式测试</strong>：3次迭代，取平均值</li>
<li><strong>内存监控</strong>：记录峰值GPU内存占用</li>
<li><strong>多场景覆盖</strong>：5种不同任务类型，全面评估模型能力</li>
</ul>
<hr/>
<h5 data-id="heading-23">📈 性能指标汇总</h5>






















































<table><thead><tr><th>测试场景</th><th>平均时间</th><th>生成速度</th><th>生成长度</th><th>内存占用</th></tr></thead><tbody><tr><td>🇨🇳 中文生成</td><td>2.24秒</td><td>55.63 t/s</td><td>124.7 tokens</td><td>14.21 GB</td></tr><tr><td>🇺🇸 英文生成</td><td>2.20秒</td><td>55.79 t/s</td><td>123.0 tokens</td><td>14.21 GB</td></tr><tr><td>🧠 逻辑推理</td><td>2.30秒</td><td>55.66 t/s</td><td>128.0 tokens</td><td>14.21 GB</td></tr><tr><td>💻 代码生成</td><td>2.30秒</td><td>55.77 t/s</td><td>128.0 tokens</td><td>14.21 GB</td></tr><tr><td>📖 知识问答</td><td>2.30秒</td><td>55.75 t/s</td><td>128.0 tokens</td><td>14.21 GB</td></tr><tr><td><strong>平均值</strong></td><td><strong>2.27秒</strong></td><td><strong>55.72 t/s</strong></td><td><strong>126.3 tokens</strong></td><td><strong>14.21 GB</strong></td></tr></tbody></table>
<h5 data-id="heading-24">📊 性能分析图表</h5>
<pre><code class="hljs language-scss" lang="scss">生成速度对比 (tokens/秒)
🇺🇸 英文生成   ████████████████████████████████ <span class="hljs-number">55.79</span>
💻 代码生成   ████████████████████████████████ <span class="hljs-number">55.77</span>
📖 知识问答   ████████████████████████████████ <span class="hljs-number">55.75</span>
🧠 逻辑推理   ████████████████████████████████ <span class="hljs-number">55.66</span>
🇨🇳 中文生成   ███████████████████████████████ <span class="hljs-number">55.63</span>
</code></pre>
<hr/>
<h5 data-id="heading-25">🔍 详细场景分析</h5>
<ol>
<li>🇨🇳 中文生成能力</li>
</ol>
<p><strong>测试提示</strong>："今天天气真好，我想去"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>生成内容自然流畅，符合中文表达习惯</li>
<li>能进行多轮对话式回应，保持上下文连贯性</li>
<li>生成速度：55.63 tokens/秒（接近整体平均值）</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★☆<br/>
内容连贯、实用，展示了良好的中文对话能力，但在细节上（如户外活动建议）可更具体。</p>
<hr/>
<ol start="2">
<li>🇺🇸 英文生成能力</li>
</ol>
<p><strong>测试提示</strong>："The capital of France is"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>5种场景中速度最快（55.79 tokens/秒）</li>
<li>能提供准确信息并自动纠正错误（指出巴黎在法国北部中区而非纯北部）</li>
<li>展示了良好的地理知识</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★★<br/>
内容准确、信息丰富，表现出优秀的英文知识型文本生成能力。</p>
<hr/>
<ol start="3">
<li>🧠 逻辑推理能力</li>
</ol>
<p><strong>测试提示</strong>："如果所有的A都是B，而所有的B都是C，那么所有的A是C吗？请详细解释。"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>能正确识别逻辑传递原则</li>
<li>提供结构化解释（前提条件、传递性分析）</li>
<li>生成内容条理清晰，展示了良好的逻辑思维能力</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★☆<br/>
逻辑严谨，条理分明，但解释可更深入，例如举例说明。</p>
<hr/>
<ol start="4">
<li>💻 代码生成能力</li>
</ol>
<p><strong>测试提示</strong>："用Python写一个快速排序算法"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>能提供完整的算法框架</li>
<li>包含必要的注释说明</li>
<li>遵循Python最佳实践</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>生成在128 tokens限制处被截断，未展示完整算法</li>
<li>需要更大生成长度以评估完整代码能力</li>
</ul>
<p><strong>生成质量评估</strong>：★★★☆☆<br/>
代码结构正确，但受长度限制未能展示完整实现。</p>
<hr/>
<ol start="5">
<li>📖 知识问答能力</li>
</ol>
<p><strong>测试提示</strong>："量子力学中的薛定谔方程是用来描述什么的？"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>能区分非相对论性与相对论性薛定谔方程</li>
<li>尝试使用数学公式表达（虽然被截断）</li>
<li>内容专业性强，显示出良好的科学知识基础</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>同样受128 tokens长度限制，关键公式未能完整展示</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★☆<br/>
专业准确，但需要更长生成长度以充分展示知识深度。</p>
<hr/>
<h5 data-id="heading-26">💎 关键结论与建议</h5>
<p>核心优势</p>
<ol>
<li><strong>性能均衡</strong>：所有测试场景表现稳定，无明显短板</li>
<li><strong>多语言能力</strong>：中英文处理能力接近，均超过55 tokens/秒</li>
<li><strong>内存效率高</strong>：稳定使用14.21GB显存，适合24GB显存设备部署</li>
<li><strong>任务适应性强</strong>：从对话到专业知识均有良好表现</li>
</ol>
<p>优化建议</p>
<ol>
<li><strong>调整生成长度</strong>：针对知识型和代码生成任务，建议增加最大生成长度至256+ tokens</li>
<li><strong>批处理优化</strong>：当前测试为batch_size=1，可测试更大批次提升吞吐量</li>
<li><strong>量化部署</strong>：考虑INT8/INT4量化，在保持性能的同时进一步降低内存占用</li>
<li><strong>场景特定微调</strong>：对代码生成和专业问答场景可进行针对性微调，提升专业能力</li>
</ol>
<p>部署推荐</p>
<ul>
<li><strong>开发测试环境</strong>：完全适用，响应速度快</li>
<li><strong>生产环境</strong>：适合中等流量API服务，单实例可支撑约20-30 QPS（取决于请求长度）</li>
<li><strong>最佳应用场景</strong>：聊天助手、知识问答系统、内容创作辅助、基础代码生成</li>
</ul>
<p>✅ <strong>总结</strong>：通义千问2.5-7B-Instruct展现出了强大的综合能力，在保持高效推理速度的同时，能够胜任多种任务类型，是7B级别模型中的优秀选择，特别适合中文场景的AI应用部署。</p>
<h3 data-id="heading-27">总结</h3>
<p>共绩算力平台代表了算力资源分配模式的创新突破，其核心价值在于通过"共享经济"模式重构了AI算力市场格局。不同于传统云服务商的高成本和自建集群的重资产模式，共绩算力实现了三个维度的革命性变革：经济维度上，将顶级GPU算力成本降至1.68元/小时，按秒计费避免资源浪费；技术维度上，通过智能调度算法整合碎片化算力，达成60%的资源利用率提升；生态维度上，将闲置算力转化为普惠AI基础设施，践行"使AI技术真正普及至每个人"的使命。这种模式不仅解决了中小企业和个人开发者的"算力焦虑"，更为中国AI产业构建了更具韧性和可持续性的底层基础设施。当一台普通电脑的闲置算力也能参与大模型推理，算力民主化的新时代已然到来。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[双十一将至，用Rules玩转电商场景提效]]></title>    <link>https://juejin.cn/post/7570901172526628899</link>    <guid>https://juejin.cn/post/7570901172526628899</guid>    <pubDate>2025-11-10T09:11:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526628899" data-draft-id="7570651893870968884" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="双十一将至，用Rules玩转电商场景提效"/> <meta itemprop="keywords" content="人工智能,前端,后端"/> <meta itemprop="datePublished" content="2025-11-10T09:11:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="文心快码BaiduComate"/> <meta itemprop="url" content="https://juejin.cn/user/992209294070809"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            双十一将至，用Rules玩转电商场景提效
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/992209294070809/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    文心快码BaiduComate
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:11:24.000Z" title="Mon Nov 10 2025 09:11:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>双十一将至，结合电商场景，来聊聊如何 <strong>“让AI写代码更省心”</strong> ——<strong>使用Rules帮助解决 “AI写代码总跑偏”</strong> 的问题。</p>
<h2 data-id="heading-0">01 什么是Rules&amp;如何使用Rules</h2>
<p><strong>Rules是什么呢——</strong> 是⼀组规则/指令，⽤来教AI在特定项⽬或框架中应该遵守的模式、最佳实践和约束，做好这个规则⽂件，可以显著提升AI⽣成代码的质量、⼀致性，减少之后⼈⼯修正的⼯作。</p>
<p>可以把Rules想象成 <strong>“行为说明书”或者“工作守则”：</strong></p>
<ul>
<li>对人来说，Rules就像“公司员工手册”👉 让新同事知道要遵守什么流程、不能乱改配置；</li>
<li><strong>对AI来说，Rules就是“编程导航图”</strong> 👉 让 AI 明白项目结构在哪、该用什么命令启动、要注意哪些细节。</li>
</ul>
<p>实际开发中，Rules可以理解为一套<strong>项目级的“开发约束与规范”</strong> ，帮助统一AI的编码行为，<strong>让生成的代码更符合团队习惯、项目架构和业务场景</strong>。来看看电商团队在实际工作中是如何应用Rules的：</p>
<p>1、在Rules中定义环境依赖、启动命令、目录结构等，避免AI “自由发挥”；</p>
<p>2、针对电商业务，<strong>设置业务规则</strong>，比如所有的价格展示统一使用一个组件、涉及到的订单状态统一维护一个组件等；</p>
<p>3、<strong>加入团队代码规范和安全要求</strong>，例如在代码中不能随意引用npm包、写法风格生成一致等；</p>
<p>4、定义<strong>错误处理机制</strong>，比如所有可能出错的地方，都使用统一的机制处理（例如统一弹出错误信息、异常捕获等）。</p>
<p><strong>Rules就像是团队的“AI导师”：</strong></p>
<p><strong>1）对新人友好：</strong> 即使是不熟悉项目的新同学，也能通过 Rules 快速了解项目规范和最佳实践。</p>
<p><strong>2）对AI可控：</strong> 让AI生成的代码“开箱即用”，减少人工review和修改成本。</p>
<p><strong>3）架构一致：</strong> 确保代码风格、目录结构、技术栈统一，维护性更强。</p>
<h2 data-id="heading-1">02 电商场景下，未配置Rules的问题</h2>
<p>相信大家平时都有网购经验，肯定要关注所购买商品的状态，以订单详情页为例：根据设计稿，通过Figma to Code模式生成一个订单详情页。</p>
<blockquote>
<p>说明：Figma to Code是Zulu针对前端场景开发的功能，在传统开发中，设计师出图、前端再手写页面的流程被大大简化了。如“订单详情页”设计稿，通过Figma to Code模式，只需要将设计稿导入系统，就能自动生成可运行的页面原型。</p>
</blockquote>
<p>生成视频👉<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQaZL34zk094i-BYWT_l55g" target="_blank" title="https://mp.weixin.qq.com/s/QaZL34zk094i-BYWT_l55g" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/QaZL34zk0…</a></p>
<p>以上的生成过程，<strong>在没有Rules的情况下有什么问题？</strong></p>
<p>当前，数据是按一个一个渲染的，而不是数组形式渲染；存在CSS文件的style没有用到lang="less”,生成的文件默认用了“原始px”的写法；图标用的是符号，而不是组件icon。Comate<strong>生成的代码没有合理使用团队所引用的组件库、也没有拆成特别细的组件，CSS的写法也不是研发所要求的</strong>。此外，还会有一些通用性问题，<strong>例如样式没有按要求的规范去写、组件的颗粒度不够等。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df1a72d8ec13401ba509c38e7ec31870~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=i%2FSJ26B2jIxa3JIT9x8e31JJn0M%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>未配置Rules，订单详情页生成的结果</p>
<p>那么，如何解决这些问题呢？切换到当前的代码生成界面，输入对话并引导改善。在没有Rules的场景下，模型并不知道具体的业务规则、代码规范或者样式要求。想要修改一些问题（比如代码格式不对、CSS写法不规范、布局跑偏等），只能依靠和模型的对话交互（Prompt）来一步步引导它调整，<strong>每次改动都需要重新输入Prompt，明确告诉模型要改哪里、怎么改。</strong></p>
<p>一次次“人工指导”——虽然灵活，但成本也比较高。随着上下文越来越多，Prompt的长度也会增加，<strong>token消耗变高，模型响应速度也会变慢</strong>。如果问题过多，使用自然语言交互就会比较困难。</p>
<p>有没有一种更好的方式，能让模型“记住”这些通用规范？<strong>是不是可以通过配置Rules的方式，让这些交互自动化？</strong> 从而实现<strong>一次配置，长期生效</strong>。</p>
<h2 data-id="heading-2">03 电商场景下，配置Rules的效果</h2>
<p>在没有配置Rules的情况下，修改问题得靠一轮轮和模型对话。<strong>如果配置了Rules，会发生什么样的质变呢？</strong> 可以<strong>把Rules想象成是给大模型配的一本「行为规范手册」</strong>，它的效果主要分几个层面：</p>
<p><strong>1.命名约定 —— 代码界的“起名大会”</strong></p>
<p>命名约定模板就像在代码界开了一场“起名大会”。变量不能随便叫“张三”，函数也别整成“李四”。有了命名规则之后，模型就能统一风格、保证可读性。不再出现一堆奇怪的名字。<strong>从此团队协作更顺畅，调试也不再像拆盲盒。</strong></p>
<p><strong>2.代码结构 —— 给模型戴上“紧箍咒”</strong></p>
<p>代码结构约束就像是给模型戴了个“紧箍咒”。不允许模型写“俄罗斯套娃”式的嵌套结构，也不允许函数变成一团“意大利面条式”的灾难代码。<strong>有了结构约束后，代码层次清晰、逻辑明了，就像写作文有大纲，模型不会乱飙自由发挥。</strong></p>
<p><strong>3.业务逻辑层 —— 模型的“逻辑交警”</strong></p>
<p>业务逻辑层是大模型的“脑回路”，而Rules在这里扮演的角色，就像一个“逻辑交警”。它负责指挥——“这个流程该往哪跑”、“那个判断在哪停”。<strong>防止模型乱开车、逻辑撞车，让业务流转更顺畅、更可控。</strong></p>
<p><strong>有了Rules，模型就像从“自由创作”变成了“规范生产”</strong> ，<strong>既能理解设计意图，又能按照标准稳定输出。</strong></p>
<p>目前有两种配置Rules的方式，一种是采用编译器，根据某个标准页面生成：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ae56464f5464388bcc8f441700f16db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=9TTBlvUJ9zrrL5m0YT6d2g0qYHk%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>第二种是手动更新项目Rules，找到入口，然后进行更新：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3651a215734141bc92a6a016627dfe2e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=W1wwm7COgFabwD1dItXbC8yUZlI%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2fa31e4c3bbf492fb47757ab271bd93b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=t020TB7xK4ilBhUj8p4nBehCpDg%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e8581a62337f40d7b29895f3c4e61d81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=6cDFqn%2Fubb6%2BswxegW5bvRHlWEk%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>Rule具体内容如下：</p>
<pre><code class="hljs language-markdown" lang="markdown">---
description:
globs:
<span class="hljs-section">alwaysApply: true
---</span>
<span class="hljs-section">## 项目概述</span>
自动解析项目框架版本，这是一个移动端的项目，所有的样式需要参考移动端来实现。
<span class="hljs-section">## 开发指南</span>
<span class="hljs-bullet">1.</span> <span class="hljs-strong">**class 类名处理**</span>
<span class="hljs-bullet">    -</span> 所有 class 名应可读、可猜测功能 统一采用 - 拼接法，如：content-title
<span class="hljs-bullet">    -</span> 去除多余复杂的 class 类名
<span class="hljs-bullet">    -</span> 保持 class 层级扁平，尽量最多嵌套三层
<span class="hljs-bullet">2.</span> <span class="hljs-strong">**css 写法**</span>
<span class="hljs-bullet">    -</span> 尺寸单位优先把 PX 改成 * @rex414 的写法; （例如 1px 变成 1* @rex414），这一点一定要执行，不要使用 @rpx414。
<span class="hljs-bullet">    -</span> 组件样式必须加 lang="less"
<span class="hljs-bullet">    -</span> 每个新写的 style 文件 必须引入 @import 'src/lib/style/common.less';，这个只需要在<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>标签里面引入就行
<span class="hljs-bullet">3.</span> <span class="hljs-strong">**组件开发**</span>
<span class="hljs-bullet">    -</span> 事件命名采用 handleXxx 格式。
<span class="hljs-bullet">    -</span> 组件请帮我写在 src/routes/components 下，不要生成组件使用示例，直接生成组件。
<span class="hljs-bullet">4.</span> <span class="hljs-strong">**页面开发**</span>
<span class="hljs-bullet">    -</span> 根据设计稿，并且根据页面的模块，请务必合理拆分组件！帮我把页面写在 src/routes/ 下。
<span class="hljs-bullet">    -</span> 页面的组件写在 src/routes/components 下。
<span class="hljs-bullet">5.</span> <span class="hljs-strong">**图片资源管理**</span>
<span class="hljs-bullet">    -</span> 所有的图片都采取占位符的方式实现。
<span class="hljs-bullet">    -</span> 图片的所有资源都要放在 assets 下，例如 list-demo 的图片都放在 src/routes/list-demo/assets 下。
<span class="hljs-bullet">    -</span> 例如，组件在 src/routes/list-demo/components 路径下 组件使用图片引入方式都需要按照 /assets/list-demo/image<span class="hljs-emphasis">_1.png 这样实现。
</span></code></pre>
<p>配置完Rules，下一步会打开设计稿，根据约束的方式自动生成代码。</p>
<p>有了Rules的约束后，会有什么样的效果呢? 以上文提到的订单详情页为例，<strong>可以明显看出配置后项目代码层级的优化（如CSS格式等）。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5fe899166104da4b9ca5f3f1774d5d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=wM%2BQQSq64sqa4GbX1eK%2BJgp3Ffo%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>配置Rules后，订单详情页代码展示</p>
<p><strong>电商场景下，配置Rules的效果视频</strong>👉<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQaZL34zk094i-BYWT_l55g" target="_blank" title="https://mp.weixin.qq.com/s/QaZL34zk094i-BYWT_l55g" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/QaZL34zk0…</a></p>
<h2 data-id="heading-3">04 Q&amp;A</h2>
<p><strong>Q1: 在实际场景中，如何配置符合项目的Rules？</strong></p>
<p><strong>A：</strong> 不要把AI看作一个能独立完成工作的程序员，而应视为一个<strong>知识渊博但缺决策能力</strong>的程序员。Rules，就是给这位“队友”的<strong>工作指引和边界说明</strong>。首先要明确几点：</p>
<ul>
<li>明确不引入外部依赖确保生成代码安全可控；</li>
<li>明确告知AI项目的架构与模式，确保数据的正确引入与使用；</li>
<li>告知AI项目使用的技术栈语法，保证生成代码在项目中可用。</li>
</ul>
<p>最好的方式，就是让AI先生成一段代码，发现不足后，总结成一个通用规范。如果项目有已存在文件，按照已有文件的代码风格，自定义Rules的规则并逐步改善，最终使生成代码与原有代码风格保持一致。</p>
<p><strong>Q2：没有Rules时，AI输出的代码会出现哪些问题？</strong></p>
<p><strong>A：</strong> 比如格式不统一、命名不规范、CSS或接口写法不符合项目标准等，AI会“凭自己理解”生成，容易出现<strong>跑偏或低质量代码</strong>。</p>
<p><strong>Q3：没有Rules时，有没有快速让AI输出符合规范的方法？</strong></p>
<p><strong>A：</strong> 在没有配置Rules的情况下，可以通过一些方式<strong>尽量让AI输出符合规范</strong>，不过每种方法都有优劣。最直接的就是<strong>多轮对话逐步引导，</strong> 每次都要手动下指令，对写提示词的能力要求比较高、效率低，且容易出错。除了多轮对话，还有一些辅助办法：</p>
<p><strong>1）Few-shot 示例：</strong> 给AI看几个标准示例，让它模仿好例子输出；</p>
<p><strong>2）RAG（检索增强生成）</strong> ：把公司的规范文档或者参考代码库检索进来，让模型在生成时参考，这样可以减少偏离规范的情况。</p>
<p>但说到底，这些都是<strong>权宜之计</strong>，<strong>效率和稳定性都不如一次性建立Rules</strong>。一旦把规则配置好，模型就像有了“行动指南”，以后生成的代码基本能自动符合规范，这才是真正<strong>一劳永逸</strong>的办法。</p>
<p><strong>Q4：Rules是不是只针对前端项目有效？</strong></p>
<p><strong>A：Rules可以用在任何编程场景。</strong> 本质上，它就是给模型定规范、定边界，告诉它“该怎么做”、“不能乱做”。前端用它可以规范命名、组件风格、CSS写法；后端可以约束函数命名、接口设计、数据库操作、日志格式；文档、报告、甚至Markdown，也能规定模板、格式和用词。甚至在多模型协作或者Agent场景，Rules也可以帮助明确输入输出、调用顺序、任务边界。<strong>只要你的任务有规范可遵循，Rules就能发挥作用</strong>，绝对不局限于前端。针对不同的场景，可以写不同的Rules去规范模型的输出。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演【金仓数据库】]]></title>    <link>https://juejin.cn/post/7570902804450705418</link>    <guid>https://juejin.cn/post/7570902804450705418</guid>    <pubDate>2025-11-10T09:20:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804450705418" data-draft-id="7570903763721093130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演【金仓数据库】"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T09:20:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CodeJourney"/> <meta itemprop="url" content="https://juejin.cn/user/3558441089502232"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演【金仓数据库】
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3558441089502232/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CodeJourney
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:20:19.000Z" title="Mon Nov 10 2025 09:20:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演</h2>
<p>随着国产数据库的不断成熟，越来越多企业开始将核心业务系统从 Oracle、SQL Server 等传统商业数据库迁移到国产数据库。而在迁移项目中，<strong>最终能否安全上线</strong>，往往不取决于“是否成功导入数据”，而是取决于<strong>迁移后的系统是否能承受真实业务场景下的负载压力</strong>。</p>
<p>许多团队在迁移过程中都会遇到类似的困惑：</p>
<ul>
<li>测试阶段业务看起来一切正常</li>
<li>上线后在高峰时段突然性能告警、TPS下降、锁竞争飙升</li>
<li>最终不得不紧急回退或加班调参救火</li>
</ul>
<p>问题往往不是测试做得不够，而是：</p>
<blockquote>
<p><strong>测试环境的行为不等于生产环境的行为</strong>。</p>
</blockquote>
<p>本文将介绍一种能够真实还原生产业务运行状态的迁移验证方法：<strong>生产负载回放（Workload Replay）</strong>，并结合实际落地项目分享其技术流程与效果提升。</p>
<hr/>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2adaa60338414266a36f75c8521032c5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29kZUpvdXJuZXk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371219&amp;x-signature=8Il9G6OHLjpJ%2Bk2llW6iKLzhF38%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-1">一、为什么传统迁移测试难以保障上线稳定性？</h3>
<p>迁移测试阶段通常包含：功能测试、手工用例验证、压力测试、回归测试等环节，看似覆盖全面，但仍难以避免迁移后出现性能或并发问题，其根本原因在于：</p>
<h4 data-id="heading-2">1. 手工测试与真实业务行为有“不可弥合差距”</h4>
<p>人工测试用例往往聚焦在“功能正确性”，但真实业务中存在大量“边缘行为”：</p>






























<table><thead><tr><th>类型</th><th>举例</th><th>特征</th></tr></thead><tbody><tr><td>高并发事务</td><td>批量订单生成、账务结算</td><td>对锁、事务隔离高度敏感</td></tr><tr><td>复杂长查询</td><td>多表关联的历史报表 / 月度结算</td><td>执行计划受索引状态影响</td></tr><tr><td>突发性访问峰值</td><td>节假日促销投放</td><td>QPS 呈指数波动，难以预测</td></tr><tr><td>异常行为链路</td><td>回滚、多次重试、局部失败</td><td>人工用例几乎无法构造</td></tr></tbody></table>
<p>这些行为往往不是“每天都发生”，但<strong>一旦发生就可能造成致命问题</strong>。</p>
<h4 data-id="heading-3">2. 压测脚本无法真实反映用户访问特征</h4>
<p>压测工具能造“压力”，但造不出“真实用户行为”：</p>
<ul>
<li>QPS 是写死的，而真实系统中是波峰波谷交替</li>
<li>SQL 执行比例通常不固定，而测试脚本是固定的参数模板</li>
<li>同一 SQL 在数据量变化后会触发不同执行计划，这是许多迁移翻车的根源</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>压测告诉你系统“能跑”，但不能告诉你系统“会不会在真实环境下卡住”。</strong></p>
</blockquote>
<h4 data-id="heading-4">3. 制度性痛点：回归测试成本巨大</h4>
<p>一旦：</p>
<ul>
<li>数据库参数调了</li>
<li>索引加了 / 删了</li>
<li>执行计划变了</li>
</ul>
<p>理论上都要重新回归测试。</p>
<p>这导致测试团队在迁移中长期疲于<strong>重复劳动</strong>，而不是优化策略。</p>
<hr/>
<h3 data-id="heading-5">二、生产负载回放：让迁移测试从“模拟”变成“重演”</h3>
<p>为了解决“测试不真实”的核心矛盾，我们使用了**生产负载回放（Workload Replay）**技术，其思路非常直接：</p>
<blockquote>
<p><strong>不再构造测试场景，而是直接把真实生产环境中发生过的所有数据库请求，完整复制到迁移后的数据库上执行。</strong></p>
</blockquote>
<p>这样一来：</p>
<ul>
<li>测试场景不再依赖经验 → 而是由真实历史业务驱动</li>
<li>性能行为不再估计 → 而是可量化比对</li>
<li>回归测试不再重新造数据 → 而是直接重复回放</li>
</ul>
<h4 data-id="heading-6">核心流程</h4>
<pre><code class="hljs language-sql" lang="sql">Capture（生产流量采集）
→ <span class="hljs-keyword">Convert</span>（语句与类型兼容转换）
→ Replay（按原始时间序列回放）
→ Validate（结果与数据一致性比对）
</code></pre>
<p>下面逐步展开。</p>
<hr/>
<h3 data-id="heading-7">三、技术流程详解</h3>
<h4 data-id="heading-8">1. Capture：采集真实数据库请求流</h4>
<p>采集目标是捕获某一时段内的<strong>完整业务行为链路</strong>，包括：</p>
<ul>
<li>SQL语句本体</li>
<li>绑定变量</li>
<li>事务开始 / 提交 / 回滚标记</li>
<li>会话来源（IP / 应用名 / 用户会话）</li>
<li>每条语句执行的时间戳（用于还原并发节奏）</li>
</ul>
<p>采集方式为<strong>低侵入设计</strong>，不会阻塞线上业务。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">BEGIN</span>
  DBMS_WORKLOAD_CAPTURE.START_CAPTURE(
    name <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">'workload_24h_snapshot'</span>,
    dir <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">'CAPTURE_DIR'</span>
  );
<span class="hljs-keyword">END</span>;
<span class="hljs-operator">/</span>
</code></pre>
<p>采集周期建议选择<strong>一个具有代表性的业务日</strong>，例如：</p>
<ul>
<li>月底财务对账日</li>
<li>高客流业务日</li>
<li>大促活动日</li>
</ul>
<p>这样后续测试的可靠性才有意义。</p>
<hr/>
<h4 data-id="heading-9">2. Convert：语句兼容、执行计划适配</h4>
<p>由于数据库语法、函数、存储过程语言存在差异，需要自动化进行语义转换：</p>









































<table><thead><tr><th>内容</th><th>Oracle → KingbaseES 示例</th><th/><th/></tr></thead><tbody><tr><td>分页语法</td><td><code>ROWNUM</code> → <code>LIMIT OFFSET</code></td><td/><td/></tr><tr><td>函数替换</td><td><code>NVL()</code> → <code>COALESCE()</code></td><td/><td/></tr><tr><td>字符串拼接</td><td>`</td><td/><td><code>→</code>concat()`</td></tr><tr><td>时间类型精度</td><td>DATE → TIMESTAMP(6)</td><td/><td/></tr><tr><td>存储过程调用</td><td>PL/SQL → 仿真包接口适配</td><td/><td/></tr></tbody></table>
<p>关键在于：</p>
<blockquote>
<p>转换不仅是“能执行”，而是保证<strong>语义一致</strong>。</p>
</blockquote>
<hr/>
<h4 data-id="heading-10">3. Replay：按原始并发节奏回放</h4>
<p>不同于压测脚本制造的“固定压力模型”，回放系统会：</p>
<ul>
<li>严格还原原始执行顺序和事务隔离关系</li>
<li>恢复真实并发强度与访问扇出特征</li>
<li>支持原速 / 加速 / 降速三种模式切换</li>
</ul>
<p>特别适合：</p>





















<table><thead><tr><th>场景</th><th>回放方式</th></tr></thead><tbody><tr><td>稳定性验证</td><td>原速回放</td></tr><tr><td>能力上限评估</td><td>加速回放（2x、5x）</td></tr><tr><td>性能瓶颈定位</td><td>降速回放观察锁链和计划</td></tr></tbody></table>
<p>回放期间会生成完整性能画像：</p>
<ul>
<li>Top SQL 排序</li>
<li>计划变更检测</li>
<li>CPU / IO 热点</li>
<li>行、表、索引级锁竞争分布</li>
</ul>
<p>这是迁移调优的核心依据。</p>
<hr/>
<h4 data-id="heading-11">4. Validate：自动化结果一致性比对</h4>
<p>比对范围包括：</p>

























<table><thead><tr><th>比对内容</th><th>示例</th></tr></thead><tbody><tr><td>表级一致性</td><td>行数一致 / 无缺失或冗余</td></tr><tr><td>字段级一致性</td><td>支持 BLOB / CLOB 二进制对比</td></tr><tr><td>元数据一致性</td><td>索引、触发器、约束一致性</td></tr><tr><td>返回结果一致性</td><td>相同请求返回相同结果</td></tr></tbody></table>
<p>系统会自动生成差异报告，定位到<strong>具体表、行、字段、值差异类型</strong>，无需 DBA 手工查表。</p>
<hr/>
<h3 data-id="heading-12">四、实际项目效果：迁移周期减少一半，风险显著下降</h3>
<p>以某制造集团 ERP 系统迁移为例：</p>



































<table><thead><tr><th>指标</th><th>传统测试方式</th><th>基于负载回放方案</th></tr></thead><tbody><tr><td>测试总体周期</td><td>6 周</td><td><strong>3 周</strong></td></tr><tr><td>覆盖业务场景</td><td>依赖测试经验</td><td><strong>完全真实业务场景</strong></td></tr><tr><td>数据回归成本</td><td>每次都要重构测试场景</td><td><strong>直接复用回放数据</strong></td></tr><tr><td>性能风险</td><td>上线后才能暴露</td><td><strong>上线前发现并修复</strong></td></tr><tr><td>上线稳定性</td><td>取决于“运气”</td><td><strong>上线即平稳运行</strong></td></tr></tbody></table>
<p>迁移负责人总结得很直白：</p>
<blockquote>
<p>“以前我们是在猜测试是否足够，现在我们是在验证系统是否真实可承载。”</p>
</blockquote>
<hr/>
<h3 data-id="heading-13">五、结语</h3>
<p>数据库迁移不是把库搬走，而是要让业务无感平滑切换。</p>
<p>传统测试方法<strong>验证的是功能可用</strong>；
生产负载回放<strong>验证的是系统能否在真实业务场景中稳定运行</strong>。</p>
<p>因此：</p>
<blockquote>
<p><strong>真实负载回放，是数据库迁移从“可用”走向“可信”的关键一步。</strong></p>
</blockquote>
<p>未来，结合机器学习对执行计划差异、锁冲突链路、访问热点自动分析，迁移验证将从“经验驱动”走向“智能优化”。</p>
<p>迁移，不再是一次冒险。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[机器人“会用手”了！银河通用首破手掌任意朝向旋转难题，拧螺丝、砸钉子样样精通]]></title>    <link>https://juejin.cn/post/7570866247980105780</link>    <guid>https://juejin.cn/post/7570866247980105780</guid>    <pubDate>2025-11-10T09:30:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570866247980105780" data-draft-id="7570909641682206760" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="机器人“会用手”了！银河通用首破手掌任意朝向旋转难题，拧螺丝、砸钉子样样精通"/> <meta itemprop="keywords" content="AIGC,人工智能"/> <meta itemprop="datePublished" content="2025-11-10T09:30:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="量子位"/> <meta itemprop="url" content="https://juejin.cn/user/2858385963484488"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            机器人“会用手”了！银河通用首破手掌任意朝向旋转难题，拧螺丝、砸钉子样样精通
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2858385963484488/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    量子位
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:30:59.000Z" title="Mon Nov 10 2025 09:30:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>做灵巧手如果不会用工具，跟咸鱼（夹爪）有什么区别？</p>
<p>别急，能拧螺丝、抡锤子，玩 “转” 各类工具的灵巧手，这就来了。</p>
<p>这位拧螺丝的 “老师傅”，出自<strong>银河通用</strong>最新推出的灵巧手神经动力学模型 <strong>DexNDM</strong>。</p>
<p>在 DexNDM 的加持下，灵巧手实现了从能动到能用的飞跃，通过分布有偏的真实数据训练，无需成功示例，即可精准弥合 Sim2Real 鸿沟，首次让通用灵巧手能够对多类物体实现稳定、多姿态、多轴向的旋转操作。</p>
<ul>
<li><strong>跨物体精准操控：从微小零件到大书本、长棍、复杂几何体，首次实现跨类别、跨尺寸、跨姿态的稳定旋转。</strong></li>
<li><strong>任意姿态多轴旋转：无论手掌朝上、朝下或侧向，均能沿任意轴向进行稳定、持续的旋转。</strong></li>
<li><strong>高灵巧高鲁棒遥操作：可自如地抓、转、拧各类工具，胜任拧螺丝、家具组装等长程、复杂操作任务。</strong></li>
<li><strong>弥合 Sim2Real 的鸿沟：无需成功操作数据，仅凭分布有偏的真实数据即可完成高精度学习，克服灵巧操作 Sim2Real 的差距，实现了 “从 0 到 1” 的突破。</strong></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9aadf8e1f9794b41af5665dd5d0e4e9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=1h5BbiCCctMG25%2Fmc9lS%2FQBIxjs%3D" alt="" loading="lazy"/></p>
<p>这下，离流水线和厨房里的灵巧机器人，真不远了！</p>
<h2 data-id="heading-0">手内操作的通用策略</h2>
<p>如上所述，DexNDM 的核心突破在于<strong>首次在真实世界中突破了手掌任意朝向的物体旋转限制</strong>，实现了跨物体、跨姿态的稳定<strong>手内旋转 (In-Hand Rotation)</strong> 与<strong>工具操作 (Tool Use)</strong>。</p>
<p>具体来说，DexNDM 能在极具挑战的手腕姿态下（如手掌朝下或侧向），实现长物体沿长边的连续旋转，以及小物体在多种转轴下的稳定旋转。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c43bad4c828441891ba20d6f0c78c90~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=4TdbeXXKhHhsXrBGloyqWN6l4pA%3D" alt="" loading="lazy"/></p>
<p>在操作对象上，DexNDM 能处理从小型到细长、从简单几何到复杂结构的多种物体。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a16dfc30b9674ecab9e79598829a3989~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=3Rp0keo%2Fqr6cyooR360rgYID7hc%3D" alt="" loading="lazy"/></p>
<p>那么，这是怎么做到的呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61b0a26a35954d55bf96a146c0df5395~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=25MuvWJ7HGBbMagimE5Rvav0RWQ%3D" alt="" loading="lazy"/></p>
<p>这里的关键在于 DexNDM 的<strong>关节级神经动力学模型（ JOINT-WISE NEURAL DYNAMICS MODEL）</strong>。</p>
<p>不同于以往整手建模的方式，DexNDM 将复杂的手–物交互拆解到<strong>关节级</strong>，让每个关节独立预测自身的下一状态，完成整手的运动预测。</p>
<p>这种分解不仅显著提升了数据利用效率，还能增强模型在不同物体、姿态下的泛化能力。</p>
<p>为了学习到具有良好泛化性的动力学模型，团队开发了一套<strong>全自动数据收集策略</strong>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32664d1a145843939ddff1b97b7076b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=nen%2F33Fh3RYqFAUiR5wVqrFiT40%3D" alt="" loading="lazy"/></p>
<p>在任务无关的随机扰动下，机器人能自主生成丰富的接触数据，不用人工重置，也不会频繁 “翻车”。</p>
<p>这样，模型可以在廉价、可扩展的数据上学习到足够丰富的交互动力学。</p>
<p>基于此，研究者进一步训练了一个<strong>残差策略网络</strong>，用于弥合仿真到现实的差距，使仿真中学到的基础策略能够顺利迁移到真实世界。</p>
<p>在策略学习上，DexNDM 采用了 “从专家到通才（expert-to-generalist）” 的训练流程：</p>
<blockquote>
<p>先针对不同长宽比与几何复杂度的物体训练多个专家策略，再将它们融合提炼为一个统一的通用策略，从而实现跨任务、跨形态的稳定操作。</p>
</blockquote>
<p>仿真与真实环境的测试表明，DexNDM 的操作灵活性、鲁棒性与泛化能力都得到了显著提升：</p>
<blockquote>
<p>不仅首次在手掌朝下的姿态下，实现了 10–16cm 长物体沿长轴的空中完整旋转，还能够稳定泛化到更多、更具挑战性的物体类型。</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ad5a6bcdb964227b7a5fe3072aa2dbe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=FNN2InBX7Sali3AzeOXA0cX%2BJ%2BQ%3D" alt="" loading="lazy"/></p>
<p>此外，研究还将这套<strong>通用旋转策略作为底层技能接入遥操作系统</strong>。</p>
<p>操作者只需通过 VR 控制器给出臂端位姿或旋转轴等高层指令，DexNDM 即可自主完成手指层面的精细控制。</p>
<p>这种方式克服了传统遥操作在精细操作中的根本难题——人手与机械手在自由度、传感和动力学上的不匹配。</p>
<p>借助 DexNDM，机器人不仅能 “抓得稳、放得准”，还能完成复杂的、涉及旋转的<strong>手—物—物交互</strong>，实现工具使用与长程装配等对系统鲁棒性要求极高的任务，真正迈向 “能转能用” 的灵巧操作。</p>
<h2 data-id="heading-1">从简单抓取到精细操作</h2>
<p>值得一提的是，DexNDM 解决的是机器人研究中最具挑战性的手内操作中的关键问题——手内旋转（in-hand rotation）。</p>
<p>这一突破之所以意义重大，是因为它直接推动了机器人从简单能力向精细操作能力的跨越。</p>
<p>整体来看，机器人的能力大致可分为<strong>运动能力</strong>与<strong>操作能力</strong>两类。</p>
<p>运动能力，是我们熟悉的 “跑”“跳”“翻”——以及保持全身稳定的 <strong>whole-body control</strong>。</p>
<p>如今，机器人不再需要被绳子吊着防摔，甚至在人为干扰下仍能稳住身形，各种翻跟头、跳舞的 demo 展示也是层出不穷。</p>
<p>而站稳之后，想让机器人真正具备生产力，关键还在于——<strong>操作（manipulation）</strong>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fc7acca63fb42d68c0dbdccc8c1ed8e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=yAVBIoVw3%2FUXmPHd0tq2FZ3AUDE%3D" alt="" loading="lazy"/></p>
<p>所谓操作，就是机器人真正 “动手干活” 的能力，它包括：</p>
<ul>
<li>
<p>抓取：改变物体相对于机器人本体的位置，如拿起 / 放下物体。</p>
</li>
<li>
<p>环境辅助操作：借助外界完成任务，如桌子，平台等。</p>
</li>
<li>
<p>柔性物体操作：处理衣物、绳索、液体等。</p>
</li>
<li>
<p>手内操作：在不借助外部环境或支撑的情况下，仅通过机械手的手指运动和调整抓取姿势来改变物体在手掌中的位置和姿态，如 DexNDM 对应的手内旋转。</p>
</li>
<li>
<p>工具操作：涉及与环境或另一个物体持续、强烈的物理接触，通常用于完成特定的精细任务。</p>
</li>
</ul>
<p>虽然目前大部分的末端执行器都能很好地完成抓取任务，但简单抓取的应用范围十分有限，主要集中在上下料、分拣等场景，远未触及真正的工业级生产力。</p>
<p>因此，灵巧操作必须从 “能抓能放” 迈向“能转能用”，以实现更复杂、更精细的动作。</p>
<p>然而，这恰恰是机器人研究中最难啃的骨头。</p>
<p>机器人先驱 Rodney Brooks 曾说：</p>
<blockquote>
<p>灵巧操作是通用机器人部署中最艰难的前沿。</p>
</blockquote>
<p>原因很简单，灵巧手虽带来了比夹爪更高的自由度，但也带来了成倍的控制难度。</p>
<p>马斯克也曾感叹：</p>
<blockquote>
<p>人类的手极其精密复杂…… 它可以挥棒、穿针、弹琴，也能拆车装车。若要造出真正通用的人形机器人，必须先解决手的问题。</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a033b5ae31c4c969c3fb74c85364d1c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=hSy9CSHh%2Fs%2FSjtow69Vqo0JLf14%3D" alt="" loading="lazy"/></p>
<p>可以说，想实现真正通用的灵巧操作，就必须攻克灵巧手的精细操作。</p>
<p><strong>其中，手内旋转和工具使用能力正成为学界研究的焦点，代表了灵巧操作向更高维度发展的趋势。</strong></p>
<p>前者让机器人能灵活调整抓取姿态，使操作更顺手，后者则让机器人真正能 “干活”，拧螺丝、砸钉子、切割、组装。</p>
<p>但这两项能力，也正是难度的巅峰。它们涉及复杂且快速变化的手–物接触和手–物–物交互，是灵巧操作皇冠上的明珠。</p>
<p>而 DexNDM 的突破，就在于此。它同时攻克了 “旋转” 和“使用”这两大难题：既能实现高精度的手内旋转，也能灵活处理多种工具的操作任务。</p>
<p>更重要的是，只有当机器人能可靠地完成这类操作，语言、视觉等高层智能规划，才能真正落地为具体的动作与执行。</p>
<p>这正是通用机器人与具身智能落地的关键瓶颈。</p>
<p>不过，要做到这一点，并不容易。</p>
<h2 data-id="heading-2">通用的手内旋转策略</h2>
<p>直观地看，在拧螺丝这样的场景中，灵巧手无法像手掌朝上时那样依赖重力来稳定物体。</p>
<p>为了不让螺丝刀滑落，模型必须精确控制更多的自由度，实现对姿态、力和接触的协调控制。</p>
<p>过去的手内操作方法大多只能处理特定物体或固定姿态，依赖昂贵或定制化硬件，难以推广到更通用的场景。</p>
<p>其根源在于灵巧手本身的高自由度（人手有 21 个自由度，加上手腕就有 27 个自由度）与复杂耦合：关节彼此影响，手与物体之间的接触不断变化，建模极其困难。</p>
<p>再加上执行过程中存在自遮挡、传感不完全等问题，模型往往无法准确捕捉这些微妙的动力学细节。</p>
<p>更棘手的是，仿真与现实之间的动力学差距依旧巨大。许多策略在仿真环境下表现完美，一旦进入现实就 “翻车”。而想依靠真实数据修正，又要承担高昂的采集成本和失败风险。</p>
<p>例如，CMU 与 Meta 在《Science Robotics》封面论文 “NeuralFeels with Neural Fields” 中引入视觉 - 触觉融合模型，以弥补纯视觉感知的不足，但依然难以跨越 Sim-to-Real 的鸿沟。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5baa62ad050640f8b03d0c227914bcc6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=RiooOI10e0xudDHtknV0qqRXZfs%3D" alt="" loading="lazy"/></p>
<p>ICRA 2023 的 BACH (Belt-Augmented Compliant Hand) 则通过皮带增强的柔性机械手实现了手腕向下的旋转操作，但这种特殊结构难以迁移，也带来了额外的硬件成本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f9a7805f30749799564ff2fb2140323~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=cU%2FphEU75%2BHw3aPfatGrIWxr2Yg%3D" alt="" loading="lazy"/></p>
<p>类似地，DexCtrl 在旋转轴通用性上取得进展，却仍受限于物体复杂度。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9903ec7b34434e59b9d9ec4f6ce1ccba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=S9%2BHPhUsnAGSzRYql3Pwue5U%2B6o%3D" alt="" loading="lazy"/></p>
<p>而 DexGen 虽能执行拧螺丝任务，却缺乏对目标物体运动的精确控制。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7f5d797066c4f94bde8e5dd60178fbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=tO%2FyC0cqazsuoDfl%2FJrtehuQQzE%3D" alt="" loading="lazy"/></p>
<p>在这些方法中，我们可以窥见，当前的手内操作方法往往局限于特定场景（如固定手腕朝向）、只能处理有限集合的常规物体，或依赖昂贵、定制化硬件。即便在单一维度（如旋转轴）上实现了通用性，仍难以在多维操作中保持稳定表现。</p>
<p>在这样的背景下，DexNDM 实现了实质性飞跃——首次构建了能够跨物体类别、跨姿态任务的通用手内操作策略。</p>
<p>它不仅为遥操作系统的数据生成与策略迁移提供了坚实基础，也为灵巧操作的工业化落地奠定了条件：样本效率更高、泛化性更强、能力可复用，为具身智能研究提供了新的底层基础设施。</p>
<p>同时，遥操应用也可进一步扩展至广泛的任务类型，协助获取各类任务所需的操作数据。</p>
<h2 data-id="heading-3">生产力即产品</h2>
<p>DexNDM 的意义不仅在于一个新的模型，更在于它推动了灵巧操作这一 “皇冠上的明珠” 从学术研究走向了可复用的生产力基础设施。</p>
<p>从最初的搬箱、上下料，到如今能拧螺丝、砸钉子、装配家具、使用工具，灵巧操作正逐步从机械重复劳动者，进化为真正具备操作智慧的 “生产力单元”。</p>
<p>借助这一底层能力，机器人不再局限于演示性的 “抓取放置”，而能在工业装配、家具组装、工具使用等多场景中实现可扩展部署，持续提升实际生产力。</p>
<p>在典型的装配任务中，这一 “能干活的机器人” 的雏形已初现端倪：</p>
<p>第一步，灵巧手使用螺丝刀，将电路板核心部件固定。</p>
<p>它能在手内微调螺丝刀的姿态，使其在最顺手的角度下施力；对准 M2 微小螺丝孔后，精准施压旋入，既不打滑也不损板。</p>
<p>第二步，安装音量旋钮。</p>
<p>五指协同稳握木质旋钮，调整内螺纹与轴心对位后，完成大角度旋转——就像拧紧瓶盖那样流畅。</p>
<p>第三步，安装装饰性部件。</p>
<p>灵巧手先夹持铆钉定位，再旋转调整小锤的握姿，轻敲入位，力量精准、节奏分明。</p>
<p>这三步展示了从手内旋转到多指协调、从静态操作到动态敲击的全链路灵巧控制，也标志着灵巧操作正在从 “抓取” 走向 “使用工具”，从“重复动作” 迈向“任务理解”，成为真正的生产力。</p>
<p>正如银河通用机器人创始人、CTO 王鹤所说：</p>
<blockquote>
<p>如果大模型提倡的是智能即产品，那么具身智能提倡的就是生产力即产品。</p>
</blockquote>
<p>最后，让我们回到开头的问题：灵巧手和夹爪的区别是什么？</p>
<p>——生产力。</p>
<p><em>论文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2510.08556" target="_blank" title="https://arxiv.org/abs/2510.08556" ref="nofollow noopener noreferrer">arxiv.org/abs/2510.08…</a></em></p>
<p><em>项目网站：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmeowuu7.github.io%2FDexNDM%2F" target="_blank" title="https://meowuu7.github.io/DexNDM/" ref="nofollow noopener noreferrer">meowuu7.github.io/DexNDM/</a></em></p>
<p><strong>欢迎在评论区留下你的想法！</strong></p>
<p>— <strong>完</strong> —</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[word文档转html（mammoth ）]]></title>    <link>https://juejin.cn/post/7570912420567285770</link>    <guid>https://juejin.cn/post/7570912420567285770</guid>    <pubDate>2025-11-10T09:33:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570912420567285770" data-draft-id="7570902804450344970" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="word文档转html（mammoth ）"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-10T09:33:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="耀耀切克闹灬"/> <meta itemprop="url" content="https://juejin.cn/user/1781681116679854"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            word文档转html（mammoth ）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1781681116679854/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    耀耀切克闹灬
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:33:56.000Z" title="Mon Nov 10 2025 09:33:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<blockquote>
<p>最近老有需要把协议Word转化为html纯预览展示的需求，为了后面方便摸鱼，用工具包脚本直接转化（手动狗头），主要使用的是 mammoth 。</p>
</blockquote>
<h2 data-id="heading-1">Word 转 HTML 工具</h2>
<p>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmwilliamson%2Fmammoth.js" target="_blank" title="https://github.com/mwilliamson/mammoth.js" ref="nofollow noopener noreferrer">mammoth</a> 将 Word 文档转换为 HTML，特别适用于协议文档的在线预览。</p>
<h3 data-id="heading-2">安装依赖</h3>
<p>bash</p>
<pre><code class="hljs">npm install mammoth
</code></pre>
<h3 data-id="heading-3">完整代码</h3>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> mammoth = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mammoth'</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileConfig</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> inputDir = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'input'</span>);
  <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(inputDir).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.docx'</span>));
  <span class="hljs-keyword">return</span> files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">inputPath</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'input'</span>,f),
      <span class="hljs-attr">outputPath</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>, f.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'.docx'</span>, <span class="hljs-string">'.html'</span>))
    }
  });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">transformParagraph</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">let</span> styleName = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">alignment</span> === <span class="hljs-string">"center"</span>) {
    styleName = <span class="hljs-string">"text-center"</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">alignment</span> === <span class="hljs-string">"right"</span>) {
    styleName = <span class="hljs-string">"text-right"</span>;
  }
  
  <span class="hljs-keyword">return</span> {
      ...element,
      styleName
  };
}

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">styleMap</span>: [
    <span class="hljs-string">"p[style-name='text-center'] =&gt; p.text-center:fresh"</span>,
    <span class="hljs-string">"p[style-name='text-right'] =&gt; p.text-right:fresh"</span>,
     <span class="hljs-string">"u =&gt; span.text-underline:fresh"</span>
  ],
  <span class="hljs-attr">transformDocument</span>: mammoth.<span class="hljs-property">transforms</span>.<span class="hljs-title function_">paragraph</span>(transformParagraph)
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">convertToHtml</span> = (<span class="hljs-params">config</span>) =&gt; {
  <span class="hljs-keyword">const</span> { inputPath, outputPath } = config;
  <span class="hljs-keyword">return</span> mammoth.<span class="hljs-title function_">convertToHtml</span>({ <span class="hljs-attr">path</span>: inputPath }, options).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>){
    <span class="hljs-keyword">const</span> html = result.<span class="hljs-property">value</span>
    <span class="hljs-keyword">const</span> templatePath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'template.html'</span>)
    <span class="hljs-keyword">const</span> tempHtml = fs.<span class="hljs-title function_">readFileSync</span>(templatePath, <span class="hljs-string">'utf8'</span>)
    <span class="hljs-keyword">const</span> insertTag = <span class="hljs-string">'&lt;div id="app"&gt;'</span>
    <span class="hljs-keyword">const</span> insertIndex = tempHtml.<span class="hljs-title function_">lastIndexOf</span>(insertTag) + insertTag.<span class="hljs-property">length</span>
    <span class="hljs-keyword">const</span> resHtml = tempHtml.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, insertIndex) + html + tempHtml.<span class="hljs-title function_">slice</span>(insertIndex)
    fs.<span class="hljs-title function_">writeFileSync</span>(outputPath, resHtml, <span class="hljs-string">'utf8'</span>)
  }).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
  });
}

<span class="hljs-keyword">const</span> allFileConfig = <span class="hljs-title function_">getFileConfig</span>();
<span class="hljs-keyword">const</span> allFileConfigLength = allFileConfig.<span class="hljs-property">length</span>;
<span class="hljs-comment">// 清空 output 目录</span>
<span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>))) {
  fs.<span class="hljs-title function_">rmdirSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>), { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span> });
}
fs.<span class="hljs-title function_">mkdirSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>));

<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`开始转换，共 <span class="hljs-subst">${allFileConfigLength}</span> 个文件`</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">runNext</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (index &gt;= allFileConfigLength) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件转换完成，请查看 output 目录'</span>);
    <span class="hljs-keyword">return</span>;
  }
  
  <span class="hljs-keyword">const</span> config = allFileConfig[index];
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>: <span class="hljs-subst">${path.basename(config.inputPath)}</span>`</span>);
  
  <span class="hljs-title function_">convertToHtml</span>(config).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    index++;
    <span class="hljs-title function_">runNext</span>();
  }).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error processing file <span class="hljs-subst">${path.basename(config.inputPath)}</span>:`</span>, err);
    index++;
    <span class="hljs-title function_">runNext</span>();
  });
}

<span class="hljs-title function_">runNext</span>();




</code></pre>
<h3 data-id="heading-4">目录结构</h3>
<p>text</p>
<pre><code class="hljs language-css" lang="css">word-<span class="hljs-selector-tag">to</span>-<span class="hljs-selector-tag">html</span>/
├── <span class="hljs-selector-tag">input</span>/                 # 存放要转换的 <span class="hljs-selector-class">.docx</span> 文件
│   ├── 协议<span class="hljs-number">1</span><span class="hljs-selector-class">.docx</span>
│   └── 协议<span class="hljs-number">2</span><span class="hljs-selector-class">.docx</span>
├── output/                # 转换后的 <span class="hljs-selector-tag">HTML</span> 文件输出目录
├── template<span class="hljs-selector-class">.html</span>          # <span class="hljs-selector-tag">HTML</span> 模板文件   
├──index<span class="hljs-selector-class">.js</span>
</code></pre>
<h3 data-id="heading-5">在package.json的scripts中添加命令行脚本</h3>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-string">"convert-doc"</span>: <span class="hljs-string">"node ./bin/word-to-html/index.js"</span>,
</code></pre>
<h3 data-id="heading-6">使用方法</h3>
<ol>
<li>将 Word 文档 (.docx) 放入 <code>input</code> 目录</li>
<li>运行脚本：</li>
<li>查看 <code>output</code> 目录获取转换后的 HTML 文件</li>
</ol>
<h3 data-id="heading-7">模板文件示例 (template.html)</h3>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>协议文档预览<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Microsoft YaHei"</span>, sans-serif;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.8</span>;
            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;
        }
        <span class="hljs-selector-id">#app</span> {
            <span class="hljs-attribute">background</span>: white;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">40px</span>;
            <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);
            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
        }
        <span class="hljs-selector-class">.text-center</span> { <span class="hljs-attribute">text-align</span>: center; }
        <span class="hljs-selector-class">.text-right</span> { <span class="hljs-attribute">text-align</span>: right; }
        <span class="hljs-selector-class">.text-underline</span> { <span class="hljs-attribute">text-decoration</span>: underline; }
        <span class="hljs-selector-tag">table</span> {
            <span class="hljs-attribute">border-collapse</span>: collapse;
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">15px</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> {
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
        }
        <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> {
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span>;
            <span class="hljs-attribute">text-align</span>: left;
        }
        <span class="hljs-selector-tag">th</span> {
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f8f9fa</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">注意事项</h3>
<ul>
<li>确保 Word 文档为 .docx 格式</li>
<li>复杂表格样式可能需要额外调整</li>
<li>脚本会自动覆盖 output 目录中的现有文件</li>
<li>建议在转换前备份重要的 Word 文档</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[KuiklyUI的ViewRef设计]]></title>    <link>https://juejin.cn/post/7570902804450934794</link>    <guid>https://juejin.cn/post/7570902804450934794</guid>    <pubDate>2025-11-10T09:55:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804450934794" data-draft-id="7570902804450836490" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="KuiklyUI的ViewRef设计"/> <meta itemprop="keywords" content="GitHub"/> <meta itemprop="datePublished" content="2025-11-10T09:55:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风冷"/> <meta itemprop="url" content="https://juejin.cn/user/3843548379091742"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            KuiklyUI的ViewRef设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3843548379091742/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风冷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:55:33.000Z" title="Mon Nov 10 2025 09:55:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">nativeRef与ViewRef、AbstractBaseView、Pager以及ViewContainer的关系分析</h2>
<p>本文将深入分析KuiklyUI框架中nativeRef与ViewRef、AbstractBaseView、Pager以及ViewContainer与ViewRef之间的关系，帮助您全面理解视图引用系统的设计与实现。</p>
<h3 data-id="heading-1">一、nativeRef的本质与工作机制</h3>
<h4 data-id="heading-2">1.1 nativeRef的定义与生成机制</h4>
<p>nativeRef是KuiklyUI中每个视图实例的唯一标识符，定义在AbstractBaseView类中：</p>
<pre><code class="hljs language-kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt" lang="kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt">abstract class AbstractBaseView&lt;A : Attr, E : Event&gt; : BaseObject(), IViewPublicApi&lt;A, E&gt;, IModuleAccessor, IPagerId {
    val nativeRef: Int = ++nativeRefProducer
    // ...
    companion object {
        var nativeRefProducer = 0
    }
}
</code></pre>
<p>nativeRef通过一个静态计数器<code>nativeRefProducer</code>自增生成，确保每个视图实例拥有全局唯一的标识符。这种设计使得框架可以在整个应用生命周期内精确识别每一个视图。</p>
<h4 data-id="heading-3">1.2 nativeRef在视图系统中的核心作用</h4>
<p>nativeRef在KuiklyUI框架中扮演着多重关键角色：</p>
<ol>
<li><strong>视图身份标识</strong>：作为视图实例的唯一身份标识</li>
<li><strong>视图引用传递</strong>：在父子视图之间传递引用关系</li>
<li><strong>跨层通信桥梁</strong>：连接Kotlin层与原生渲染层</li>
<li><strong>属性与事件绑定</strong>：在创建Attr和Event对象时被注入，用于后续属性更新和事件分发</li>
</ol>
<p>在AbstractBaseView的内部实现中，我们可以看到nativeRef被注入到Attr和Event对象中：</p>
<pre><code class="hljs language-kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt" lang="kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt">private fun internalCreateEvent(): E {
    val event = createEvent()
    event.init(pagerId,nativeRef)  // 将nativeRef注入到Event对象
    return event
}

protected fun internalCreateAttr(): A {
    val attr = createAttr()
    attr.pagerId = pagerId
    attr.nativeRef = nativeRef  // 将nativeRef注入到Attr对象
    attr.flexNode = flexNode
    return attr
}
</code></pre>
<h3 data-id="heading-4">二、ViewRef与nativeRef的关系</h3>
<h4 data-id="heading-5">2.1 ViewRef的定义与实现</h4>
<p>ViewRef是一个轻量级的引用封装类，定义在DeclarativeBaseView.kt中：</p>
<pre><code class="hljs language-kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/DeclarativeBaseView.kt" lang="kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/DeclarativeBaseView.kt">class ViewRef&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;(val pagerId: String, val nativeRef: Int) {
    val view: T?
        get() = PagerManager.getPager(pagerId)
            .getViewWithNativeRef(nativeRef) as? T
}
</code></pre>
<h4 data-id="heading-6">2.2 ViewRef与nativeRef的协作关系</h4>
<p>ViewRef与nativeRef之间存在着紧密的协作关系：</p>
<ol>
<li><strong>组成关系</strong>：ViewRef封装了pagerId和nativeRef两个核心属性</li>
<li><strong>定位机制</strong>：ViewRef通过pagerId和nativeRef组合定位到具体的视图实例</li>
<li><strong>延迟查找</strong>：ViewRef的<code>view</code>属性采用懒加载方式，只有在需要时才通过PagerManager查找视图</li>
<li><strong>类型安全</strong>：ViewRef使用泛型确保返回的视图类型正确</li>
</ol>
<h3 data-id="heading-7">三、ViewRef与AbstractBaseView的关系</h3>
<h4 data-id="heading-8">3.1 ref扩展函数的实现</h4>
<p>在DeclarativeBaseView中，实现了<code>ref</code>扩展函数，作为创建ViewRef的入口：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    ref(ViewRef&lt;T&gt;(pagerId, nativeRef))
}
</code></pre>
<h4 data-id="heading-9">3.2 AbstractBaseView与ViewRef的交互流程</h4>
<p>AbstractBaseView与ViewRef的交互流程如下：</p>
<ol>
<li>AbstractBaseView实例创建时生成唯一的nativeRef</li>
<li>通过ref扩展函数，将当前视图的pagerId和nativeRef传递给ViewRef构造函数</li>
<li>ViewRef持有这些引用信息，但不直接持有视图实例</li>
<li>当需要访问视图时，通过ViewRef的<code>view</code>属性间接获取</li>
</ol>
<p>这种设计实现了视图引用的解耦，使框架能够更灵活地管理视图生命周期和内存。</p>
<h3 data-id="heading-10">四、ViewRef与Pager的协作机制</h3>
<h4 data-id="heading-11">4.1 Pager的视图引用管理</h4>
<p>Pager类实现了IPager接口，负责管理视图引用：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Pager中管理视图引用的关键代码</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> nativeRefViewMap = mutableMapOf&lt;<span class="hljs-built_in">Int</span>, AbstractBaseView&lt;*, *&gt;&gt;()

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">putNativeViewRef</span><span class="hljs-params">(nativeRef: <span class="hljs-type">Int</span>, view: <span class="hljs-type">AbstractBaseView</span>&lt;*, *&gt;)</span></span> {
    nativeRefViewMap[nativeRef] = view
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeNativeViewRef</span><span class="hljs-params">(nativeRef: <span class="hljs-type">Int</span>)</span></span> {
    nativeRefViewMap.remove(nativeRef)
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewWithNativeRef</span><span class="hljs-params">(nativeRef: <span class="hljs-type">Int</span>)</span></span>: AbstractBaseView&lt;*, *&gt;? {
    <span class="hljs-keyword">return</span> nativeRefViewMap[nativeRef]
}
</code></pre>
<h4 data-id="heading-12">4.2 ViewRef与Pager的协作流程</h4>
<p>ViewRef与Pager的协作流程如下：</p>
<ol>
<li>ViewRef持有pagerId和nativeRef信息</li>
<li>当调用ViewRef的<code>view</code>属性时，通过PagerManager获取对应pagerId的Pager实例</li>
<li>调用Pager的<code>getViewWithNativeRef</code>方法，通过nativeRef查找视图实例</li>
<li>将找到的视图实例转换为泛型T类型并返回</li>
</ol>
<p>这种设计使得ViewRef可以安全地在任何地方访问视图，而不需要直接持有视图实例的强引用，有利于内存管理和视图生命周期控制。</p>
<h3 data-id="heading-13">五、ViewContainer与ViewRef的关系</h3>
<h4 data-id="heading-14">5.1 ViewContainer的视图层次管理</h4>
<p>ViewContainer是所有容器视图的基类，负责管理子视图层次结构：</p>
<pre><code class="hljs language-kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt" lang="kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt">abstract class ViewContainer&lt;A : ContainerAttr, E : Event&gt; : DeclarativeBaseView&lt;A, E&gt;() {
    protected val children = fastArrayListOf&lt;DeclarativeBaseView&lt;*, *&gt;&gt;()
    // ...
}
</code></pre>
<h4 data-id="heading-15">5.2 ViewContainer中nativeRef的应用</h4>
<p>在ViewContainer中，nativeRef主要用于以下几个方面：</p>
<ol>
<li><strong>父视图引用传递</strong>：在添加子视图时，设置子视图的parentRef为当前容器的nativeRef</li>
</ol>
<pre><code class="hljs language-kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt" lang="kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt">private fun internalAddChild(child: DeclarativeBaseView&lt;*, *&gt;, index: Int) {
    child.pagerId = pagerId
    child.willMoveToParentComponent()
    if (index &lt; 0) { // append when index -1
        children.add(child)
    } else {
        children.add(index, child)
    }
    child.parentRef = nativeRef  // 设置父视图引用
    child.didMoveToParentView()
}
</code></pre>
<ol start="2">
<li><strong>渲染视图管理</strong>：在创建和移除渲染视图时，使用nativeRef标识视图</li>
</ol>
<pre><code class="hljs language-kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt" lang="kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt">override fun createRenderView() {
    createRenderViewing = true
    super.createRenderView()
    createRenderViewing = false
    var index = 0
    renderChildren().forEach { child -&gt;
        child.createRenderView()
        renderView?.insertSubRenderView(child.nativeRef, index++)  // 使用nativeRef标识子视图
        child.renderViewDidMoveToParentRenderView()
    }
}
</code></pre>
<ol start="3">
<li><strong>视图引用链建立</strong>：通过nativeRef和parentRef建立完整的视图引用链</li>
</ol>
<h4 data-id="heading-16">5.3 ViewContainer中ViewRef的使用场景</h4>
<p>在ViewContainer中，ViewRef主要用于以下场景：</p>
<ol>
<li><strong>子视图引用获取</strong>：通过ViewRef安全地获取子视图引用，进行操作或通信</li>
<li><strong>跨层级视图访问</strong>：在复杂布局中，通过ViewRef实现跨层级的视图访问</li>
<li><strong>视图生命周期管理</strong>：在视图添加、移除等生命周期事件中，通过ViewRef传递引用信息</li>
</ol>
<h3 data-id="heading-17">六、整体架构与数据流</h3>
<h4 data-id="heading-18">6.1 核心组件关系图</h4>
<pre><code class="hljs language-lua" lang="lua">+<span class="hljs-comment">------------------+      +------------------+      +------------------+</span>
|                  |      |                  |      |                  |
|  AbstractBaseView|&lt;<span class="hljs-comment">-----&gt;|    ViewRef       |&lt;-----&gt;|     Pager        |</span>
|                  |      |                  |      |                  |
+<span class="hljs-comment">--------^---------+      +------------------+      +------------------+</span>
         |
         |
+<span class="hljs-comment">--------+---------+      +------------------+</span>
|                  |      |                  |
|  ViewContainer   |&lt;<span class="hljs-comment">-----&gt;|   Declarative   |</span>
|                  |      |     BaseView     |
+<span class="hljs-comment">------------------+      +------------------+</span>
</code></pre>
<h4 data-id="heading-19">6.2 数据流向与交互模式</h4>
<p>在KuiklyUI的视图引用系统中，数据流向和交互模式如下：</p>
<ol>
<li><strong>创建阶段</strong>：视图实例创建时生成nativeRef，Pager注册视图引用</li>
<li><strong>引用封装</strong>：通过ref扩展函数创建ViewRef对象，封装pagerId和nativeRef</li>
<li><strong>引用访问</strong>：通过ViewRef的view属性，间接访问视图实例</li>
<li><strong>生命周期管理</strong>：在视图添加到容器或从容器移除时，更新parentRef和视图引用注册状态</li>
<li><strong>销毁阶段</strong>：视图销毁时，从Pager中移除视图引用</li>
</ol>
<h3 data-id="heading-20">七、设计优势与技术亮点</h3>
<h4 data-id="heading-21">7.1 设计优势</h4>
<ol>
<li><strong>解耦视图引用</strong>：ViewRef通过间接引用机制，实现了视图引用与视图实例的解耦</li>
<li><strong>内存优化</strong>：避免了不必要的强引用，有利于内存管理和垃圾回收</li>
<li><strong>类型安全</strong>：泛型设计确保了类型安全，减少了运行时类型转换错误</li>
<li><strong>灵活的视图访问</strong>：可以在任何地方通过ViewRef安全地访问视图，不受生命周期限制</li>
</ol>
<h4 data-id="heading-22">7.2 技术亮点</h4>
<ol>
<li><strong>唯一标识符生成机制</strong>：通过静态计数器生成全局唯一的nativeRef</li>
<li><strong>延迟查找策略</strong>：ViewRef的view属性采用懒加载方式，只有在需要时才查找视图</li>
<li><strong>引用链管理</strong>：通过nativeRef和parentRef建立完整的视图层次引用链</li>
<li><strong>跨平台兼容性</strong>：设计考虑了跨平台需求，nativeRef作为统一的视图标识符</li>
</ol>
<h3 data-id="heading-23">八、代码优化建议</h3>
<p>基于对ViewRef和nativeRef系统的分析，提出以下优化建议：</p>
<ol>
<li>
<p><strong>引用有效性检查增强</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 在ViewRef的view属性中添加更完善的有效性检查</span>
<span class="hljs-keyword">val</span> view: T?
    <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">val</span> pager = PagerManager.getPager(pagerId)
        <span class="hljs-keyword">if</span> (pager == <span class="hljs-literal">null</span> || !pager.isActive()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }
        <span class="hljs-keyword">val</span> view = pager.getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
        <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span> &amp;&amp; view.isDestroyed()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }
        <span class="hljs-keyword">return</span> view
    }
</code></pre>
</li>
<li>
<p><strong>弱引用优化</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 在Pager中考虑使用WeakReference存储视图引用，避免内存泄漏</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> nativeRefViewMap = mutableMapOf&lt;<span class="hljs-built_in">Int</span>, WeakReference&lt;AbstractBaseView&lt;*, *&gt;&gt;&gt;()
</code></pre>
</li>
<li>
<p><strong>引用缓存机制</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 为频繁访问的ViewRef添加缓存机制</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt;(<span class="hljs-keyword">val</span> pagerId: String, <span class="hljs-keyword">val</span> nativeRef: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cachedView: T? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastCacheTime: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">val</span> view: T?
        <span class="hljs-keyword">get</span>() {
            <span class="hljs-keyword">val</span> currentTime = System.currentTimeMillis()
            <span class="hljs-comment">// 缓存有效期100ms</span>
            <span class="hljs-keyword">if</span> (cachedView != <span class="hljs-literal">null</span> &amp;&amp; currentTime - lastCacheTime &lt; <span class="hljs-number">100</span>) {
                <span class="hljs-keyword">return</span> cachedView
            }
            cachedView = PagerManager.getPager(pagerId)
                .getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
            lastCacheTime = currentTime
            <span class="hljs-keyword">return</span> cachedView
        }
}
</code></pre>
</li>
</ol>
<p>总结来看，nativeRef与ViewRef、AbstractBaseView、Pager以及ViewContainer之间形成了一套完整、高效的视图引用管理体系，为KuiklyUI框架提供了灵活、安全的视图访问机制。通过这种设计，框架能够有效地管理视图生命周期、优化内存使用，并提供一致的跨平台体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AutoHotkey 功能配置与使用指南]]></title>    <link>https://juejin.cn/post/7570904968677851163</link>    <guid>https://juejin.cn/post/7570904968677851163</guid>    <pubDate>2025-11-10T09:12:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570904968677851163" data-draft-id="7570901172526579747" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AutoHotkey 功能配置与使用指南"/> <meta itemprop="keywords" content="Windows"/> <meta itemprop="datePublished" content="2025-11-10T09:12:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="NiShiKiFuNa"/> <meta itemprop="url" content="https://juejin.cn/user/3905924343795950"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AutoHotkey 功能配置与使用指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3905924343795950/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    NiShiKiFuNa
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:12:21.000Z" title="Mon Nov 10 2025 09:12:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文档总结了使用 AutoHotkey 实现多种功能的配置方法，包括屏蔽快捷键、鼠标侧键音量控制、多脚本管理和开机自启动设置。</p>
<h2 data-id="heading-0">1. 使用 AutoHotkey 屏蔽 Ctrl+Esc 快捷键</h2>
<h3 data-id="heading-1">方法一：基础屏蔽脚本</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">; 不展示托盘图标（可选）
#NoTrayIcon
; 屏蔽 Ctrl+Esc 快捷键
^Esc::return
</code></pre>
<h3 data-id="heading-2">方法二：针对特定游戏的屏蔽</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">; 不展示托盘图标（可选）
#NoTrayIcon
; 只在特定游戏窗口中屏蔽 Ctrl+Esc
#IfWinActive ahk_exe 游戏进程名.exe
^Esc::return
#IfWinActive
</code></pre>
<p><strong>注意事项：</strong></p>
<ul>
<li>脚本需要以<strong>管理员身份运行</strong>才能在游戏中生效</li>
<li>使用 <code>#IfWinActive</code> 可以限制热键只在特定程序中生效</li>
<li>如果需要完全退出脚本，可以添加退出热键：<code>^!q::ExitApp</code></li>
</ul>
<h2 data-id="heading-3">2. 使用鼠标侧键调节音量</h2>
<h3 data-id="heading-4">带初始延迟的连续调节脚本</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">#NoTrayIcon

; --- 延迟设置 ---
InitialDelay := 300  ; 首次按下后的延迟时间（毫秒）

; --- 鼠标侧键音量控制 ---
; 侧键1（后退键）：音量减小
XButton1::
    Send {Volume_Down}
    Key1Pressed := true
    SetTimer, RapidVolumeDown, % -InitialDelay
return

XButton1 up::
    Key1Pressed := false
    SetTimer, RapidVolumeDown, Off
return

RapidVolumeDown:
    if Key1Pressed
    {
        Send {Volume_Down}
        SetTimer, RapidVolumeDown, 150
    }
return

; 侧键2（前进键）：音量增加
XButton2::
    Send {Volume_Up}
    Key2Pressed := true
    SetTimer, RapidVolumeUp, % -InitialDelay
return

XButton2 up::
    Key2Pressed := false
    SetTimer, RapidVolumeUp, Off
return

RapidVolumeUp:
    if Key2Pressed
    {
        Send {Volume_Up}
        SetTimer, RapidVolumeUp, 150
    }
return

; --- 退出热键 ---
^+q::ExitApp
</code></pre>
<p><strong>功能特点：</strong></p>
<ul>
<li>单次点击：立即调节一次音量</li>
<li>长按：延迟后开始连续调节（默认延迟300毫秒）</li>
<li>使用系统默认的音量调节方式</li>
</ul>
<p><strong>自定义参数：</strong></p>
<ul>
<li>调整 <code>InitialDelay</code> 值可改变开始连续调节的延迟时间</li>
<li>调整 <code>150</code> 值可改变连续调节的速度</li>
</ul>
<h2 data-id="heading-5">3. 使用一个脚本启动多个其他脚本的方法</h2>
<h3 data-id="heading-6">创建主启动脚本</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">#NoTrayIcon
; 主启动脚本 - 同时运行多个子脚本

; 启动屏蔽 Ctrl+Esc 脚本
Run, C:\脚本路径\屏蔽CtrlEsc.ahk

; 启动鼠标侧键音量控制脚本
Run, C:\脚本路径\鼠标侧键音量.ahk

; 可选：启动其他脚本
; Run, C:\脚本路径\其他功能.ahk

; 可选：主脚本在启动所有子脚本后自动退出
; ExitApp
</code></pre>
<p><strong>优势：</strong></p>
<ul>
<li>集中管理多个脚本</li>
<li>只需在任务计划程序中设置一个自启动任务</li>
<li>方便添加、删除或修改要启动的脚本</li>
</ul>
<p><strong>路径说明：</strong></p>
<ul>
<li>
<p>使用完整路径（如 <code>C:\脚本路径...</code>）最可靠</p>
</li>
<li>
<p>如果脚本在同一目录，可使用 <code>A_ScriptDir</code> 变量：</p>
<pre><code class="hljs language-autohotkey" lang="autohotkey">Run, %A_ScriptDir%\屏蔽CtrlEsc.ahk
</code></pre>
</li>
</ul>
<h2 data-id="heading-7">4. 设置任务计划程序实现开机自启且以管理员身份运行</h2>
<h3 data-id="heading-8">详细设置步骤</h3>
<ol>
<li>
<p><strong>打开任务计划程序</strong></p>
<ul>
<li>按 <code>Win + R</code>，输入 <code>taskschd.msc</code>，回车</li>
</ul>
</li>
<li>
<p><strong>创建新任务</strong></p>
<ul>
<li>点击右侧"创建任务"（不要使用"创建基本任务"）</li>
</ul>
</li>
<li>
<p><strong>常规设置</strong></p>
<ul>
<li>
<p><strong>名称</strong>：输入有意义的任务名称</p>
</li>
<li>
<p><strong>描述</strong>：（可选）添加任务描述</p>
</li>
<li>
<p><strong>安全选项</strong>：</p>
<ul>
<li>选择"只在用户登录时运行"</li>
<li>✅ <strong>勾选"使用最高权限运行"</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>触发器设置</strong></p>
<ul>
<li>点击"新建"，选择"当用户登录时"</li>
<li>建议选择"特定用户"而不是"任何用户"</li>
</ul>
</li>
<li>
<p><strong>操作设置</strong></p>
<ul>
<li>
<p>点击"新建"</p>
</li>
<li>
<p><strong>操作</strong>：选择"启动程序"</p>
</li>
<li>
<p><strong>程序或脚本</strong>：浏览选择 AutoHotkey.exe</p>
<ul>
<li>通常路径：<code>C:\Program Files\AutoHotkey\AutoHotkey.exe</code></li>
</ul>
</li>
<li>
<p><strong>参数</strong>：输入你的脚本完整路径</p>
<ul>
<li>例如：<code>"C:\AHK_Scripts\主启动脚本.ahk"</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>条件设置（可选）</strong></p>
<ul>
<li>在"条件"选项卡中，取消勾选"只有在计算机使用交流电源时才启动此任务"（确保笔记本用电池时也能运行）</li>
</ul>
</li>
</ol>
<h3 data-id="heading-9">重要注意事项</h3>
<ul>
<li><strong>权限设置</strong>：必须在"常规"选项卡中勾选"使用最高权限运行"</li>
<li><strong>触发器选择</strong>：必须选择"当用户登录时"而不是"计算机启动时"</li>
<li><strong>用户选择</strong>：建议选择"特定用户"而不是"任何用户"，以确保托盘图标正常显示</li>
<li><strong>路径处理</strong>：脚本路径中包含空格时，需要用英文双引号包围</li>
</ul>
<h3 data-id="heading-10">验证设置</h3>
<p>设置完成后，可以通过以下方式验证：</p>
<ol>
<li>右键点击任务，选择"运行"测试</li>
<li>检查任务管理器中的 AutoHotkey 进程是否正常运行</li>
<li>测试各项功能是否正常工作</li>
</ol>
<h2 data-id="heading-11">常见问题解决</h2>
<ol>
<li>
<p><strong>游戏中热键不生效</strong></p>
<ul>
<li>确保脚本以管理员身份运行</li>
<li>检查游戏是否在全屏模式下运行</li>
</ul>
</li>
<li>
<p><strong>开机不自启</strong></p>
<ul>
<li>检查任务计划程序中的触发器设置</li>
<li>确认脚本路径正确</li>
</ul>
</li>
<li>
<p><strong>托盘图标不显示</strong></p>
<ul>
<li>检查是否选择了"特定用户"而不是"任何用户"</li>
<li>确认任务属性中选择了"只在用户登录时运行"</li>
</ul>
</li>
</ol>
<p>通过以上配置，你可以实现功能的自动化运行，无需每次手动启动脚本。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python FastAPI 参数传递与响应校验]]></title>    <link>https://juejin.cn/post/7570896170920706111</link>    <guid>https://juejin.cn/post/7570896170920706111</guid>    <pubDate>2025-11-10T09:32:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570896170920706111" data-draft-id="7570598043298578495" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python FastAPI 参数传递与响应校验"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T09:32:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Hacker_Future"/> <meta itemprop="url" content="https://juejin.cn/user/1978776659433063"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python FastAPI 参数传递与响应校验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1978776659433063/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Hacker_Future
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:32:20.000Z" title="Mon Nov 10 2025 09:32:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">FastAPI 进阶教程：参数传递与响应校验</h2>
<p>上一节我们实现了基础的 HelloWorld API，这一节将聚焦实际开发核心需求 —— 参数传递（路径 / 查询 / 请求体）与响应数据校验，结合 Pydantic 模型让接口更规范、更健壮。</p>
<h3 data-id="heading-1">一、核心依赖与前置说明</h3>
<ul>
<li>依赖工具：Pydantic（FastAPI 内置，用于数据校验和模型定义）。</li>
</ul>

<ul>
<li>核心目标：通过类型注解定义参数 / 响应格式，FastAPI 自动完成校验、转换和文档生成。</li>
</ul>

<ul>
<li>适用场景：接口需要接收用户输入（如查询条件、表单数据）或返回结构化结果时。</li>
</ul>
<h3 data-id="heading-2">二、参数传递的 3 种核心方式</h3>
<h4 data-id="heading-3">2.1 路径参数（Path Parameters）</h4>
<p>用于标识资源的唯一标识（如用户 ID、商品编号），直接嵌入 URL 路径中。</p>
<h5 data-id="heading-4">基础用法（无校验）</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
app = FastAPI()
<span class="hljs-comment"># 路径参数 item_id 嵌入 URL，类型注解为 int</span>
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/items/{item_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span></span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"item_id"</span>: item_id, <span class="hljs-string">"message"</span>: <span class="hljs-string">"获取商品成功"</span>}
</code></pre>
<ul>
<li>访问示例：<a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fitems%2F10" target="_blank" title="http://127.0.0.1:8000/items/10" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/items/10</a>，返回 {"item_id":10,"message":"获取商品成功"}。</li>
</ul>

<ul>
<li>自动转换：若访问 items/abc，FastAPI 会返回 422 错误（类型不匹配），无需手动处理。</li>
</ul>
<h5 data-id="heading-5">进阶用法（路径参数校验）</h5>
<p>通过 Path 类添加校验规则（如数值范围、描述）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Path
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>
app = FastAPI()
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/items/{item_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">
    <span class="hljs-comment"># ge=1：大于等于 1，le=100：小于等于 100，description 用于接口文档</span>
    item_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">..., ge=<span class="hljs-number">1</span>, le=<span class="hljs-number">100</span>, description=<span class="hljs-string">"商品 ID，范围 1-100"</span></span>),
    q: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 可选查询参数，下文详解</span>
</span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"item_id"</span>: item_id, <span class="hljs-string">"q"</span>: q}
</code></pre>
<ul>
<li>访问示例：/items/50?q=手机 正常响应，/items/101 会返回 422 校验错误。</li>
</ul>
<h4 data-id="heading-6">2.2 查询参数（Query Parameters）</h4>
<p>用于过滤、分页等非核心参数（如搜索关键词、页码），以 ?key=value 形式附加在 URL 后。</p>
<h5 data-id="heading-7">基础用法（可选参数 + 默认值）</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/users/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">
    page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,  <span class="hljs-comment"># 必选查询参数，默认值 1（不传递时使用默认值）</span>
    limit: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span>,  <span class="hljs-comment"># 每页条数，默认 10</span>
    keyword: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 可选查询参数，默认 None</span>
</span>):
    <span class="hljs-comment"># 模拟分页查询逻辑</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"page"</span>: page,
        <span class="hljs-string">"limit"</span>: limit,
        <span class="hljs-string">"keyword"</span>: keyword,
        <span class="hljs-string">"data"</span>: [{<span class="hljs-string">"user_id"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"张三"</span>}, {<span class="hljs-string">"user_id"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"李四"</span>}]
    }
</code></pre>
<ul>
<li>访问示例：/users/?page=2&amp;limit=20&amp;keyword=张，返回对应分页和筛选结果。</li>
</ul>

<ul>
<li>校验特性：若传递 page=abc，会自动返回类型错误。</li>
</ul>
<h5 data-id="heading-8">进阶用法（查询参数校验）</h5>
<p>通过 Query 类添加校验规则（如字符串长度、正则匹配）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Query
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/users/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">
    page: <span class="hljs-built_in">int</span> = Query(<span class="hljs-params"><span class="hljs-number">1</span>, ge=<span class="hljs-number">1</span>, description=<span class="hljs-string">"页码，最小 1"</span></span>),
    limit: <span class="hljs-built_in">int</span> = Query(<span class="hljs-params"><span class="hljs-number">10</span>, ge=<span class="hljs-number">5</span>, le=<span class="hljs-number">50</span>, description=<span class="hljs-string">"每页条数，5-50 条"</span></span>),
    <span class="hljs-comment"># min_length=2：最小长度 2，max_length=10：最大长度 10</span>
    keyword: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Query(<span class="hljs-params"><span class="hljs-literal">None</span>, min_length=<span class="hljs-number">2</span>, max_length=<span class="hljs-number">10</span></span>)
</span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"page"</span>: page, <span class="hljs-string">"limit"</span>: limit, <span class="hljs-string">"keyword"</span>: keyword, <span class="hljs-string">"data"</span>: []}
</code></pre>
<h4 data-id="heading-9">2.3 请求体（Request Body）</h4>
<p>用于传递复杂数据（如创建用户、提交表单），以 JSON 格式发送（FastAPI 自动解析）。</p>
<p>需通过 Pydantic 模型定义请求体结构。</p>
<h5 data-id="heading-10">步骤 1：定义 Pydantic 模型</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>
app = FastAPI()
<span class="hljs-comment"># 定义请求体模型，继承 BaseModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCreate</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>  <span class="hljs-comment"># 必选字段，字符串类型</span>
    age: <span class="hljs-built_in">int</span> = Field(..., ge=<span class="hljs-number">0</span>, le=<span class="hljs-number">120</span>, description=<span class="hljs-string">"年龄，0-120 岁"</span>)  <span class="hljs-comment"># 带校验的必选字段</span>
    email: <span class="hljs-built_in">str</span> = Field(..., pattern=<span class="hljs-string">r"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+.[a-zA-Z0-9_-]+$"</span>)  <span class="hljs-comment"># 邮箱正则校验</span>
    address: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 可选字段，默认 None</span>
<span class="hljs-comment"># 定义响应体模型（可选，用于规范返回格式）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserResponse</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>
    name: <span class="hljs-built_in">str</span>
    age: <span class="hljs-built_in">int</span>
    email: <span class="hljs-built_in">str</span>
    address: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        orm_mode = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 支持从 ORM 对象（如 SQLAlchemy 模型）转换为 JSON</span>
</code></pre>
<h5 data-id="heading-11">步骤 2：使用模型接收请求体</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">"/users/"</span>, response_model=UserResponse</span>)  </span><span class="hljs-comment"># 指定响应模型，自动校验返回数据</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">user: UserCreate</span>):  <span class="hljs-comment"># user 参数自动解析 JSON 请求体</span>
    <span class="hljs-comment"># 模拟数据库插入，生成用户 ID</span>
    user_id = <span class="hljs-number">1001</span>
    <span class="hljs-comment"># 返回数据会被 UserResponse 校验，确保格式一致</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"id"</span>: user_id,
        <span class="hljs-string">"name"</span>: user.name,
        <span class="hljs-string">"age"</span>: user.age,
        <span class="hljs-string">"email"</span>: user.email,
        <span class="hljs-string">"address"</span>: user.address
    }
</code></pre>
<h5 data-id="heading-12">测试请求体</h5>
<ul>
<li>发送 POST 请求到 <a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fusers%2F" target="_blank" title="http://127.0.0.1:8000/users/" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/users/</a>，请求体 JSON：</li>
</ul>
<pre><code class="hljs language-perl" lang="perl">{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"王五"</span>,
    <span class="hljs-string">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"wangwu@example.com"</span>,
    <span class="hljs-string">"address"</span>: <span class="hljs-string">"北京市海淀区"</span>
}
</code></pre>
<ul>
<li>响应结果：自动校验请求体（如 email 格式错误会返回 422），返回数据严格遵循 UserResponse 结构。</li>
</ul>
<h3 data-id="heading-13">三、响应校验的核心作用</h3>
<ol>
<li>确保返回数据格式统一，避免前端对接混乱。</li>
</ol>

<ol start="2">
<li>自动过滤多余字段（如请求体中的额外参数不会被返回）。</li>
</ol>

<ol start="3">
<li>文档自动同步：/docs 页面会显示请求体和响应体的结构化示例。</li>
</ol>
<h3 data-id="heading-14">四、实战：组合参数示例（路径 + 查询 + 请求体）</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.put(<span class="hljs-params"><span class="hljs-string">"/items/{item_id}"</span>, response_model=UserResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_item</span>(<span class="hljs-params">
    item_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">..., ge=<span class="hljs-number">1</span>, description=<span class="hljs-string">"商品 ID"</span></span>),
    is_active: <span class="hljs-built_in">bool</span> = Query(<span class="hljs-params"><span class="hljs-literal">True</span>, description=<span class="hljs-string">"是否启用商品"</span></span>),
    user: UserCreate  <span class="hljs-comment"># 请求体</span>
</span>):
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"id"</span>: item_id,
        <span class="hljs-string">"name"</span>: user.name,
        <span class="hljs-string">"age"</span>: user.age,
        <span class="hljs-string">"email"</span>: user.email,
        <span class="hljs-string">"address"</span>: user.address
    }
</code></pre>
<ul>
<li>访问示例：PUT 请求 <a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fitems%2F5%3Fis_active%3Dtrue" target="_blank" title="http://127.0.0.1:8000/items/5?is_active=true" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/items/5?is_active=true</a>，携带上述 JSON 请求体。</li>
</ul>

<ul>
<li>校验逻辑：路径参数、查询参数、请求体分别按规则校验，任意环节出错返回 422 错误。</li>
</ul>
<h3 data-id="heading-15">五、常见错误与排查</h3>
<ul>
<li>422 错误：数据校验失败（如类型不匹配、数值超出范围、正则不匹配），查看响应体的 detail 字段可获取具体原因。</li>
</ul>

<ul>
<li>请求体无法解析：未定义 Pydantic 模型，或请求头 Content-Type 不是 application/json。</li>
</ul>

<ul>
<li>可选字段必填：未给 Optional 字段设置默认值（如 keyword: Optional[str] 需改为 keyword: Optional[str] = None）。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从字符串满天飞到优雅枚举：JavaScript 常量管理的几种姿势]]></title>    <link>https://juejin.cn/post/7570598043298611263</link>    <guid>https://juejin.cn/post/7570598043298611263</guid>    <pubDate>2025-11-10T09:43:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570598043298611263" data-draft-id="7570896170920837183" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从字符串满天飞到优雅枚举：JavaScript 常量管理的几种姿势"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T09:43:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从字符串满天飞到优雅枚举：JavaScript 常量管理的几种姿势
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:43:34.000Z" title="Mon Nov 10 2025 09:43:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>重构老项目的时候，看到代码里到处都是这样的判断：</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">status</span> === <span class="hljs-string">'pending'</span>) { }
if (<span class="hljs-attr">status</span> === <span class="hljs-string">'processing'</span>) { }
if (<span class="hljs-attr">orderStatus</span> === <span class="hljs-string">'pending'</span>) { }  // 等等，这个 pending 跟上面那个一样吗？
</code></pre>
<p>字符串满天飞，每次都要小心翼翼地打字，生怕打错一个字母。想用枚举来管理这些常量，但 JavaScript 又没有原生的 <code>enum</code> 关键字。</p>
<p>网上搜了一圈，发现大家的做法五花八门：</p>
<ul>
<li>有人用普通对象：<code>const Status = { PENDING: 'pending' }</code></li>
<li>有人用 <code>Object.freeze()</code>：<code>const Status = Object.freeze({ PENDING: 'pending' })</code></li>
<li>还有人干脆直接用字符串，说"够用就行"</li>
</ul>
<p>那到底哪种方式好？有没有更优雅的写法？</p>
<p>最近看到 Dr. Axel Rauschmayer 的一篇文章，介绍了用 Proxy 实现枚举的技巧。虽然他明确说这是个教学示例，不建议直接用在生产环境，但这个思路确实挺巧妙，能帮我们更好地理解 Proxy 和解构赋值的工作原理。</p>
<h2 data-id="heading-0">为什么 JavaScript 需要枚举？</h2>
<h3 data-id="heading-1">字符串常量的问题</h3>
<p>直接用字符串当常量，问题不少：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">updateOrder</span>(status) {
  if (status === 'shiped') {  <span class="hljs-comment">// 拼错了！应该是 shipped</span>
    <span class="hljs-comment">// ...</span>
  }
}
​
<span class="hljs-built_in">updateOrder</span>('shipped');  <span class="hljs-comment">// 运行时才发现不匹配</span>
</code></pre>
<p>JavaScript 是弱类型语言，拼错字符串编辑器不会报错，只能在运行时才发现问题。而且满屏的字符串字面量，维护起来真的头疼。</p>
<h3 data-id="heading-2">魔法数字更糟糕</h3>
<p>有些老代码喜欢用数字：</p>
<pre><code class="hljs language-scss" lang="scss">if (userLevel === <span class="hljs-number">3</span>) {  <span class="hljs-comment">// 3 是什么意思？</span>
  <span class="hljs-comment">// ...</span>
}
​
if (priority === <span class="hljs-number">3</span>) {  <span class="hljs-comment">// 这个 3 又是什么意思？</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>半年后回头看代码，鬼知道这个 <code>3</code> 代表什么。</p>
<p>问题的根源在于：<strong>JavaScript 缺少一种原生的、类型安全的方式来定义常量集合</strong>。</p>
<h2 data-id="heading-3">常见的枚举实现方式</h2>
<h3 data-id="heading-4">方式 1：普通对象</h3>
<p>最简单的做法：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> OrderStatus = {
  PENDING: <span class="hljs-string">'pending'</span>,
  PROCESSING: <span class="hljs-string">'processing'</span>,
  SHIPPED: <span class="hljs-string">'shipped'</span>,
  DELIVERED: <span class="hljs-string">'delivered'</span>
};
​
<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">if</span> (order.status === OrderStatus.SHIPPED) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>这种方式的问题是，对象属性可以被修改：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">OrderStatus.PENDING</span> = <span class="hljs-string">'xxx'</span><span class="hljs-comment">;  // 能改，但不应该改</span>
<span class="hljs-attr">OrderStatus.CANCELLED</span> = <span class="hljs-string">'cancelled'</span><span class="hljs-comment">;  // 能加新属性</span>
</code></pre>
<h3 data-id="heading-5">方式 2：Object.freeze()</h3>
<p>冻结对象，防止修改：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OrderStatus</span> = Object.<span class="hljs-title function_ invoke__">freeze</span>({
 <span class="hljs-attr"> PENDING</span>: <span class="hljs-string">'pending'</span>,
 <span class="hljs-attr"> PROCESSING</span>: <span class="hljs-string">'processing'</span>,
 <span class="hljs-attr"> SHIPPED</span>: <span class="hljs-string">'shipped'</span>,
 <span class="hljs-attr"> DELIVERED</span>: <span class="hljs-string">'delivered'</span>
});
​
OrderStatus.PENDING = <span class="hljs-string">'xxx'</span>;  <span class="hljs-comment">// 严格模式下报错</span>
</code></pre>
<p>这个方式好一些，但每次都要写 <code>PENDING: 'pending'</code> 这种重复的键值对，有点啰嗦。特别是当枚举值就是字段名的小写形式时，这种重复更明显。</p>
<h3 data-id="heading-6">方式 3：TypeScript 的 enum</h3>
<p>如果用 TypeScript，有两种枚举方式：</p>
<p><strong>数字枚举</strong>（默认）：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span> { 
  foo,    <span class="hljs-comment">// 0</span>
  bar,    <span class="hljs-comment">// 1</span>
  baz     <span class="hljs-comment">// 2</span>
}
​
console.<span class="hljs-built_in">log</span>(MyEnum.foo);  <span class="hljs-comment">// 0</span>
console.<span class="hljs-built_in">log</span>(MyEnum.bar);  <span class="hljs-comment">// 1</span>
</code></pre>
<p>这种方式和很多编程语言（C、Java）的枚举类似，但调试起来不太直观——看到数字 <code>0</code> 你得想一下它代表什么。</p>
<p><strong>字符串枚举</strong>（推荐）：</p>
<pre><code class="hljs language-ini" lang="ini">enum OrderStatus {
  <span class="hljs-attr">PENDING</span> = <span class="hljs-string">'pending'</span>,
  <span class="hljs-attr">PROCESSING</span> = <span class="hljs-string">'processing'</span>,
  <span class="hljs-attr">SHIPPED</span> = <span class="hljs-string">'shipped'</span>,
  <span class="hljs-attr">DELIVERED</span> = <span class="hljs-string">'delivered'</span>
}
​
console.log(OrderStatus.PENDING)<span class="hljs-comment">;  // 'pending' - 一眼就能看懂</span>
</code></pre>
<p>字符串枚举的好处是调试时能直接看到有意义的值，不用去查数字对应什么。但这需要 TypeScript 环境，纯 JavaScript 项目怎么办？</p>
<h2 data-id="heading-7">用 Proxy 实现的巧妙方案</h2>
<p>这里有个挺有意思的技巧，用 Proxy 可以让枚举定义变得更简洁。理解这个技巧需要先了解两个关键点。</p>
<h3 data-id="heading-8">关键点 1：Proxy 拦截器</h3>
<p>核心思路是：创建一个特殊的对象，读取它的任何属性时，都返回属性名本身。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> keyProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey, _receiver</span>) {
    <span class="hljs-keyword">return</span> propKey;
  }
});
​
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keyProxy.<span class="hljs-property">foo</span>);    <span class="hljs-comment">// 'foo'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keyProxy.<span class="hljs-property">bar</span>);    <span class="hljs-comment">// 'bar'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keyProxy.<span class="hljs-property">hello</span>);  <span class="hljs-comment">// 'hello'</span>
</code></pre>
<p>看到了吗？不管你访问什么属性，都能得到属性名的字符串。</p>
<h3 data-id="heading-9">关键点 2：解构赋值的属性简写</h3>
<p>接下来，配合 ES6 的解构赋值：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> { PENDING, PROCESSING, SHIPPED, DELIVERED } = keyProxy;
​
console.<span class="hljs-built_in">log</span>(PENDING);     <span class="hljs-comment">// 'PENDING'</span>
console.<span class="hljs-built_in">log</span>(PROCESSING);  <span class="hljs-comment">// 'PROCESSING'</span>
console.<span class="hljs-built_in">log</span>(SHIPPED);     <span class="hljs-comment">// 'SHIPPED'</span>
</code></pre>
<p>这里利用了解构赋值的<strong>属性简写</strong>（property value shorthand）特性。</p>
<p>写 <code>{ foo }</code> 其实是 <code>{ foo: foo }</code> 的简写。这两种写法是<strong>完全等价的</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 简写形式</span>
<span class="hljs-type">const</span> { foo, bar, baz } = keyProxy;
​
<span class="hljs-comment">// 完整形式（等价）</span>
<span class="hljs-type">const</span> { foo: foo, bar: bar, baz: baz } = keyProxy;
</code></pre>
<p>意思是：</p>
<ul>
<li>从 <code>keyProxy</code> 对象中读取 <code>foo</code> 属性</li>
<li>把读到的值赋给变量 <code>foo</code></li>
</ul>
<p>所以上面的代码实际执行的是：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">PENDING</span> = keyProxy.PENDING<span class="hljs-comment">;      // 'PENDING'</span>
const <span class="hljs-attr">PROCESSING</span> = keyProxy.PROCESSING<span class="hljs-comment">; // 'PROCESSING'</span>
const <span class="hljs-attr">SHIPPED</span> = keyProxy.SHIPPED<span class="hljs-comment">;      // 'SHIPPED'</span>
</code></pre>
<p><strong>两个要素结合</strong>就产生了这个效果：</p>
<ol>
<li>Proxy 让属性访问返回属性名</li>
<li>解构赋值让我们同时定义多个常量</li>
</ol>
<p>一行代码搞定所有枚举值的定义。</p>
<h3 data-id="heading-10">实际使用</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 定义枚举</span>
const { PENDING, PROCESSING, SHIPPED, DELIVERED } = keyProxy;
​
<span class="hljs-comment">// 使用</span>
function <span class="hljs-built_in">updateOrder</span>(status) {
  if (status === SHIPPED) {
    console<span class="hljs-selector-class">.log</span>('订单已发货');
  }
}
​
<span class="hljs-built_in">updateOrder</span>(SHIPPED);
</code></pre>
<p>看起来是不是简洁多了？不用重复写键值对，也不用每次都写 <code>Status.PENDING</code> 这样的前缀。</p>
<h2 data-id="heading-11">进阶：用 Symbol 提高类型安全</h2>
<p>如果想要更强的类型安全性，可以把字符串换成 Symbol。</p>
<p>切换到 Symbol 版本只需要改动一行代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> symbolProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey, _receiver</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(propKey);  <span class="hljs-comment">// 只改这一行</span>
  }
});
​
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">PENDING</span>, <span class="hljs-variable constant_">PROCESSING</span>, <span class="hljs-variable constant_">SHIPPED</span> } = symbolProxy;
​
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">PENDING</span>);  <span class="hljs-comment">// 'symbol'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-variable constant_">PENDING</span>)); <span class="hljs-comment">// 'Symbol(PENDING)'</span>
</code></pre>
<p>其他代码完全不用动，只是把返回值从字符串改成 Symbol。</p>
<h3 data-id="heading-12">Symbol 的好处</h3>
<p><strong>防止误用字符串</strong>：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 用字符串的情况</span>
const { PENDING } = keyProxy;
<span class="hljs-built_in">updateOrder</span>('PENDING');  <span class="hljs-comment">// 能工作，但可能不是你想要的</span>
<span class="hljs-built_in">updateOrder</span>(PENDING);    <span class="hljs-comment">// 也能工作</span>
​
<span class="hljs-comment">// 用 Symbol 的情况</span>
const { PENDING } = symbolProxy;
<span class="hljs-built_in">updateOrder</span>('PENDING');  <span class="hljs-comment">// 不会匹配，因为类型不对</span>
<span class="hljs-built_in">updateOrder</span>(PENDING);    <span class="hljs-comment">// 只有这个才能匹配</span>
</code></pre>
<p>Symbol 是唯一的，即使描述相同，两个 Symbol 也不相等：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'foo'</span>) === <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'foo'</span>)  <span class="hljs-comment">// false</span>
</code></pre>
<p>所以用 Symbol 做枚举值，基本不可能出现误匹配的情况。</p>
<p><strong>更好的调试体验</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">console.<span class="hljs-built_in">log</span>(PENDING);  <span class="hljs-comment">// Symbol(PENDING) - 一眼就能看出是什么</span>
</code></pre>
<h2 data-id="heading-13">这个方案的优缺点</h2>
<h3 data-id="heading-14">优势</h3>
<p><strong>简洁</strong>：</p>
<ul>
<li>不用重复写键值对</li>
<li>一行代码搞定所有常量定义</li>
</ul>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 传统方式</span>
<span class="hljs-type">const</span> Status = {
  PENDING: <span class="hljs-string">'PENDING'</span>,
  PROCESSING: <span class="hljs-string">'PROCESSING'</span>,
  SHIPPED: <span class="hljs-string">'SHIPPED'</span>,
  DELIVERED: <span class="hljs-string">'DELIVERED'</span>
};
​
<span class="hljs-comment">// Proxy 方式</span>
<span class="hljs-type">const</span> { PENDING, PROCESSING, SHIPPED, DELIVERED } = keyProxy;
</code></pre>
<p><strong>灵活</strong>：</p>
<ul>
<li>想要字符串就用字符串版本的 Proxy</li>
<li>想要 Symbol 就用 Symbol 版本的 Proxy</li>
<li>随用随取，不需要预先定义所有常量</li>
</ul>
<h3 data-id="heading-15">缺点</h3>
<p><strong>理解成本</strong>：</p>
<p>这个技巧本质上是个教学示例，主要用来展示 Proxy 和解构赋值的灵活性。对于不熟悉这些特性的同事来说，代码可能不够直观。</p>
<p><strong>没有命名空间</strong>：</p>
<p>传统方式的枚举有明确的命名空间：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">OrderStatus</span> = { PENDING: <span class="hljs-string">'pending'</span> }<span class="hljs-comment">;</span>
const <span class="hljs-attr">UserStatus</span> = { PENDING: <span class="hljs-string">'pending'</span> }<span class="hljs-comment">;</span>
​
// 两个 PENDING 不会混淆
</code></pre>
<p>但 Proxy 方式定义的常量是独立的变量：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> { PENDING: OrderPending } = keyProxy;
<span class="hljs-type">const</span> { PENDING: UserPending } = keyProxy;
​
<span class="hljs-comment">// 需要手动区分变量名</span>
</code></pre>
<p><strong>IDE 支持有限</strong>：</p>
<p>传统对象方式，IDE 能提示你有哪些可用的枚举值：</p>
<pre><code class="hljs language-arduino" lang="arduino">OrderStatus.  <span class="hljs-comment">// IDE 会列出 PENDING, PROCESSING 等</span>
</code></pre>
<p>但 Proxy 方式定义的是普通变量，IDE 不知道你定义了哪些常量。</p>
<h2 data-id="heading-16">实际使用建议</h2>
<p>这个 Proxy 技巧的价值主要在于<strong>学习和理解</strong>，而不是直接应用到生产环境。就像算法题一样，重点是理解思路，而不是把巧妙的解法用在工作代码里。</p>
<h3 data-id="heading-17">适合的场景</h3>
<p><strong>临时常量和快速原型</strong>：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 写测试代码时快速定义一些常量</span>
const { SUCCESS, FAILURE, PENDING } = keyProxy;
​
<span class="hljs-built_in">test</span>('should handle all states', () =&gt; {
  <span class="hljs-built_in">expect</span>(handler(SUCCESS))<span class="hljs-selector-class">.toBe</span>(true);
  <span class="hljs-built_in">expect</span>(handler(FAILURE))<span class="hljs-selector-class">.toBe</span>(false);
  <span class="hljs-built_in">expect</span>(handler(PENDING))<span class="hljs-selector-class">.toBe</span>(null);
});
</code></pre>
<p>在快速开发阶段，不想花时间写繁琐的枚举定义，这个方式很方便。</p>
<h3 data-id="heading-18">生产环境的建议</h3>
<p>对于业务核心的枚举（订单状态、用户角色等），建议还是用传统方式：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 清晰、有命名空间、IDE 友好</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OrderStatus</span> = Object.<span class="hljs-title function_ invoke__">freeze</span>({
 <span class="hljs-attr"> PENDING</span>: <span class="hljs-string">'pending'</span>,
 <span class="hljs-attr"> PROCESSING</span>: <span class="hljs-string">'processing'</span>,
 <span class="hljs-attr"> SHIPPED</span>: <span class="hljs-string">'shipped'</span>,
 <span class="hljs-attr"> DELIVERED</span>: <span class="hljs-string">'delivered'</span>
});
</code></pre>
<p>或者如果项目使用 TypeScript，直接用 <code>enum</code>：</p>
<pre><code class="hljs language-ini" lang="ini">enum OrderStatus {
  <span class="hljs-attr">PENDING</span> = <span class="hljs-string">'pending'</span>,
  <span class="hljs-attr">PROCESSING</span> = <span class="hljs-string">'processing'</span>,
  <span class="hljs-attr">SHIPPED</span> = <span class="hljs-string">'shipped'</span>,
  <span class="hljs-attr">DELIVERED</span> = <span class="hljs-string">'delivered'</span>
}
</code></pre>
<h3 data-id="heading-19">如果真要用，可以封装</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// utils/enum.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> stringEnum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey</span>) {
    <span class="hljs-keyword">return</span> propKey;
  }
});
​
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> symbolEnum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(propKey);
  }
});
​
<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">import</span> { stringEnum } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils/enum'</span>;
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">PENDING</span>, <span class="hljs-variable constant_">PROCESSING</span> } = stringEnum;
</code></pre>
<p>这样至少让代码意图更明确一些。</p>
<h2 data-id="heading-20">写在最后</h2>
<p>这个 Proxy 技巧确实挺巧妙的，理解它的原理也挺有意思。用来学习和理解 JavaScript 的高级特性很有价值。</p>
<p>就像健身房里练单手俯卧撑，不是为了以后干活只用一只手，而是为了提升整体力量。这个技巧也一样：</p>
<ul>
<li>加深对 Proxy 的理解</li>
<li>学会解构赋值的更多玩法</li>
<li>知道"简单特性组合"能产生的效果</li>
</ul>
<p>实际写枚举的时候，老老实实用 <code>Object.freeze()</code> 或者 TypeScript 的 <code>enum</code> 比较好。但如果哪天面试被问到"你能用 Proxy 做点什么有趣的事"，这个例子正好能派上用场。</p>
<p>代码不是越巧妙越好，够清楚、好维护才是王道。</p>
<hr/>
<h2 data-id="heading-21">相关文档</h2>
<ol>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2F2ality.com%2F2018%2F08%2Fenums-via-proxies.html" target="_blank" title="https://2ality.com/2018/08/enums-via-proxies.html" ref="nofollow noopener noreferrer">Enums via proxies (原文)</a></strong> - Dr. Axel Rauschmayer 的原文</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FProxy" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" ref="nofollow noopener noreferrer">Proxy - MDN</a></strong> - Proxy 的详细用法</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSymbol" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" ref="nofollow noopener noreferrer">Symbol - MDN</a></strong> - Symbol 类型说明</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring_assignment" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" ref="nofollow noopener noreferrer">解构赋值 - MDN</a></strong> - 解构赋值的详细说明</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2Ffreeze" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" ref="nofollow noopener noreferrer">Object.freeze() - MDN</a></strong> - 冻结对象的方法</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fenums.html" target="_blank" title="https://www.typescriptlang.org/docs/handbook/enums.html" ref="nofollow noopener noreferrer">TypeScript Enums</a></strong> - TypeScript 的枚举实现</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python FastAPI 数据库集成（SQLAlchemy）+ 接口权限校验]]></title>    <link>https://juejin.cn/post/7570885801477849129</link>    <guid>https://juejin.cn/post/7570885801477849129</guid>    <pubDate>2025-11-10T09:41:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570885801477849129" data-draft-id="7570500819889963051" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python FastAPI 数据库集成（SQLAlchemy）+ 接口权限校验"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T09:41:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Hacker_Future"/> <meta itemprop="url" content="https://juejin.cn/user/1978776659433063"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python FastAPI 数据库集成（SQLAlchemy）+ 接口权限校验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1978776659433063/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Hacker_Future
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:41:36.000Z" title="Mon Nov 10 2025 09:41:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Python FastAPI 教程：数据库集成（SQLAlchemy）+ 接口权限校验</h2>
<p>前面我们掌握了参数传递与响应校验，这一节将聚焦生产级 API 核心需求 —— 数据库持久化（基于 SQLAlchemy ORM）和接口权限控制（基于 OAuth2 + JWT），让 API 具备数据存储、身份认证和权限隔离能力。</p>
<h3 data-id="heading-1">一、前置依赖安装</h3>
<p>需额外安装数据库相关和权限相关依赖：</p>
<pre><code class="hljs language-css" lang="css">pip install sqlalchemy pymysql python-jose<span class="hljs-selector-attr">[cryptography]</span> passlib<span class="hljs-selector-attr">[bcrypt]</span> python-multipart
</code></pre>
<ul>
<li>依赖说明：</li>
</ul>

<ul>
<li>
<ul>
<li>sqlalchemy：Python 主流 ORM 框架，实现数据库操作抽象。</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>pymysql：MySQL 数据库驱动（若用 PostgreSQL 可替换为 psycopg2-binary）。</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>python-jose：生成和验证 JWT 令牌。</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>passlib：密码哈希处理（避免明文存储）。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-2">二、数据库集成（SQLAlchemy）</h3>
<p>以 MySQL 为例，实现数据库连接、模型定义、CRUD 操作封装。</p>
<h4 data-id="heading-3">2.1 项目结构调整</h4>
<p>为便于维护，调整项目结构如下：</p>
<pre><code class="hljs language-bash" lang="bash">fastwebprojects/
├── main.py          <span class="hljs-comment"># 主程序入口（路由、APP 初始化）</span>
├── database.py      <span class="hljs-comment"># 数据库连接配置</span>
├── models.py        <span class="hljs-comment"># SQLAlchemy 数据模型（对应数据库表）</span>
├── schemas.py       <span class="hljs-comment"># Pydantic 模型（请求/响应校验）</span>
└── crud.py          <span class="hljs-comment"># 数据库 CRUD 操作封装</span>
</code></pre>
<h4 data-id="heading-4">2.2 数据库连接配置（<a href="https://link.juejin.cn?target=http%3A%2F%2Fdatabase.py%2F" target="_blank" title="http://database.py/" ref="nofollow noopener noreferrer">database.py</a>）</h4>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
<span class="hljs-comment"># MySQL 连接地址：mysql+pymysql://用户名:密码@主机:端口/数据库名</span>
<span class="hljs-attr">SQLALCHEMY_DATABASE_URL</span> = <span class="hljs-string">"mysql+pymysql://root:123456@localhost:3306/fastapi_db"</span>
<span class="hljs-comment"># 创建数据库引擎</span>
<span class="hljs-attr">engine</span> = create_engine(
    SQLALCHEMY_DATABASE_URL,
    <span class="hljs-attr">pool_pre_ping</span>=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 连接前校验，避免失效连接</span>
)
<span class="hljs-comment"># 创建会话本地类（每次请求对应一个会话，独立隔离）</span>
<span class="hljs-attr">SessionLocal</span> = sessionmaker(autocommit=<span class="hljs-literal">False</span>, autoflush=<span class="hljs-literal">False</span>, bind=engine)
<span class="hljs-comment"># 基础模型类（所有数据模型继承此类）</span>
<span class="hljs-attr">Base</span> = declarative_base()
</code></pre>
<h4 data-id="heading-5">2.3 定义数据模型（<a href="https://link.juejin.cn?target=http%3A%2F%2Fmodels.py%2F" target="_blank" title="http://models.py/" ref="nofollow noopener noreferrer">models.py</a>）</h4>
<p>数据模型对应数据库表，SQLAlchemy 会自动生成表结构（需手动执行迁移）。</p>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import Column, Integer, String, Boolean
from database import Base
<span class="hljs-comment"># 用户表模型</span>
class User(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">"users"</span>  <span class="hljs-comment"># 数据库表名</span>
    <span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 主键 ID，索引</span>
    <span class="hljs-attr">username</span> = Column(String(<span class="hljs-number">50</span>), unique=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, nullable=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 用户名，唯一</span>
    <span class="hljs-attr">email</span> = Column(String(<span class="hljs-number">100</span>), unique=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, nullable=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 邮箱，唯一</span>
    <span class="hljs-attr">hashed_password</span> = Column(String(<span class="hljs-number">100</span>), nullable=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 哈希后的密码</span>
    <span class="hljs-attr">is_active</span> = Column(Boolean, default=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 是否激活</span>
    <span class="hljs-attr">is_admin</span> = Column(Boolean, default=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 是否为管理员（用于权限控制）</span>
</code></pre>
<h4 data-id="heading-6">2.4 初始化数据库表</h4>
<p>在 <a href="https://link.juejin.cn?target=http%3A%2F%2Fmain.py%2F" target="_blank" title="http://main.py/" ref="nofollow noopener noreferrer">main.py</a> 中添加表创建逻辑，启动时自动创建不存在的表：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> database <span class="hljs-keyword">import</span> engine, SessionLocal
<span class="hljs-keyword">import</span> models
<span class="hljs-comment"># 创建所有数据模型对应的数据库表</span>
models.Base.metadata.create_all(bind=engine)
app = FastAPI()
<span class="hljs-comment"># 依赖函数：获取数据库会话（每个请求独立会话）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():
    db = SessionLocal()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span> db  <span class="hljs-comment"># 提供会话给路由函数</span>
    <span class="hljs-keyword">finally</span>:
        db.close()  <span class="hljs-comment"># 请求结束后关闭会话</span>
</code></pre>
<h4 data-id="heading-7">2.5 封装 CRUD 操作（<a href="https://link.juejin.cn?target=http%3A%2F%2Fcrud.py%2F" target="_blank" title="http://crud.py/" ref="nofollow noopener noreferrer">crud.py</a>）</h4>
<p>分离数据库操作与路由逻辑，降低耦合：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session
<span class="hljs-keyword">import</span> models
<span class="hljs-keyword">import</span> schemas
<span class="hljs-keyword">from</span> passlib.context <span class="hljs-keyword">import</span> CryptContext
<span class="hljs-comment"># 密码哈希上下文（使用 bcrypt 算法）</span>
pwd_context = CryptContext(schemes=[<span class="hljs-string">"bcrypt"</span>], deprecated=<span class="hljs-string">"auto"</span>)
<span class="hljs-comment"># 密码哈希处理</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_password_hash</span>(<span class="hljs-params">password: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">return</span> pwd_context.<span class="hljs-built_in">hash</span>(password)
<span class="hljs-comment"># 验证密码</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_password</span>(<span class="hljs-params">plain_password: <span class="hljs-built_in">str</span>, hashed_password: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">return</span> pwd_context.verify(plain_password, hashed_password)
<span class="hljs-comment"># 创建用户</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">db: Session, user: schemas.UserCreate</span>):
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        username=user.username,
        email=user.email,
        hashed_password=hashed_password
    )
    db.add(db_user)  <span class="hljs-comment"># 添加到会话</span>
    db.commit()      <span class="hljs-comment"># 提交事务</span>
    db.refresh(db_user)  <span class="hljs-comment"># 刷新数据（获取自动生成的 ID 等）</span>
    <span class="hljs-keyword">return</span> db_user
<span class="hljs-comment"># 根据用户名查询用户</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_username</span>(<span class="hljs-params">db: Session, username: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">return</span> db.query(models.User).<span class="hljs-built_in">filter</span>(models.User.username == username).first()
</code></pre>
<h4 data-id="heading-8">2.6 定义 Pydantic 模型（<a href="https://link.juejin.cn?target=http%3A%2F%2Fschemas.py%2F" target="_blank" title="http://schemas.py/" ref="nofollow noopener noreferrer">schemas.py</a>）</h4>
<p>区分请求体（创建用户时传入密码）和响应体（返回时隐藏密码）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, EmailStr, Field
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>
<span class="hljs-comment"># 创建用户的请求体模型（需传入密码）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCreate</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    username: <span class="hljs-built_in">str</span> = Field(..., min_length=<span class="hljs-number">3</span>, max_length=<span class="hljs-number">50</span>, description=<span class="hljs-string">"用户名"</span>)
    email: EmailStr = Field(..., description=<span class="hljs-string">"邮箱"</span>)  <span class="hljs-comment"># EmailStr 自动校验邮箱格式</span>
    password: <span class="hljs-built_in">str</span> = Field(..., min_length=<span class="hljs-number">6</span>, description=<span class="hljs-string">"密码，至少 6 位"</span>)
<span class="hljs-comment"># 返回用户的响应体模型（隐藏密码）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserResponse</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>
    username: <span class="hljs-built_in">str</span>
    email: EmailStr
    is_active: <span class="hljs-built_in">bool</span>
    is_admin: <span class="hljs-built_in">bool</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        orm_mode = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 支持从 SQLAlchemy 模型直接转换</span>
</code></pre>
<h3 data-id="heading-9">三、接口权限校验（OAuth2 + JWT）</h3>
<p>实现「用户名密码登录获取令牌」→「携带令牌访问受保护接口」的完整流程。</p>
<h4 data-id="heading-10">3.1 配置 JWT 密钥与过期时间</h4>
<p>在 <a href="https://link.juejin.cn?target=http%3A%2F%2Fmain.py%2F" target="_blank" title="http://main.py/" ref="nofollow noopener noreferrer">main.py</a> 中添加配置（实际项目建议用环境变量存储密钥）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta
<span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> JWTError, jwt
<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, HTTPException, status
<span class="hljs-keyword">from</span> fastapi.security <span class="hljs-keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm
<span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session
<span class="hljs-comment"># JWT 配置</span>
SECRET_KEY = <span class="hljs-string">"your-secret-key-32bytes-long-keep-it-safe"</span>  <span class="hljs-comment"># 密钥（生产环境需随机生成）</span>
ALGORITHM = <span class="hljs-string">"HS256"</span>  <span class="hljs-comment"># 加密算法</span>
ACCESS_TOKEN_EXPIRE_MINUTES = <span class="hljs-number">30</span>  <span class="hljs-comment"># 令牌过期时间（30 分钟）</span>
<span class="hljs-comment"># OAuth2 依赖：从请求头的 Authorization 字段获取令牌（格式：Bearer &lt;token&gt;）</span>
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="hljs-string">"token"</span>)
</code></pre>
<h4 data-id="heading-11">3.2 实现令牌生成与验证逻辑</h4>
<p>在 <a href="https://link.juejin.cn?target=http%3A%2F%2Fmain.py%2F" target="_blank" title="http://main.py/" ref="nofollow noopener noreferrer">main.py</a> 中添加核心函数：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 生成访问令牌</span>
def create_access_token(data: dict):
    <span class="hljs-attr">to_encode</span> = data.copy()
    <span class="hljs-comment"># 设置过期时间</span>
    <span class="hljs-attr">expire</span> = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    <span class="hljs-comment"># 生成 JWT 令牌</span>
    <span class="hljs-attr">encoded_jwt</span> = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
<span class="hljs-comment"># 依赖函数：验证令牌并返回当前用户</span>
def get_current_user(
    db: <span class="hljs-attr">Session</span> = Depends(get_db),
    token: <span class="hljs-attr">str</span> = Depends(oauth2_scheme)
):
    <span class="hljs-comment"># 令牌验证失败异常</span>
    <span class="hljs-attr">credentials_exception</span> = HTTPException(
        <span class="hljs-attr">status_code</span>=status.HTTP_401_UNAUTHORIZED,
        <span class="hljs-attr">detail</span>=<span class="hljs-string">"令牌无效或已过期"</span>,
        <span class="hljs-attr">headers</span>={<span class="hljs-string">"WWW-Authenticate"</span>: <span class="hljs-string">"Bearer"</span>},
    )
    try:
        <span class="hljs-comment"># 解码令牌</span>
        <span class="hljs-attr">payload</span> = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: <span class="hljs-attr">str</span> = payload.get(<span class="hljs-string">"sub"</span>)  <span class="hljs-comment"># 令牌中存储的用户名（sub 为标准字段）</span>
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    <span class="hljs-comment"># 查询用户</span>
    <span class="hljs-attr">user</span> = crud.get_user_by_username(db, username=username)
    if user is None:
        raise credentials_exception
    return user
<span class="hljs-comment"># 依赖函数：验证当前用户是否为管理员（权限细化）</span>
def get_current_admin_user(current_user: <span class="hljs-attr">models.User</span> = Depends(get_current_user)):
    if not current_user.is_admin:
        raise HTTPException(
            <span class="hljs-attr">status_code</span>=status.HTTP_403_FORBIDDEN,
            <span class="hljs-attr">detail</span>=<span class="hljs-string">"无权限访问，仅管理员可操作"</span>
        )
    return current_user
</code></pre>
<h4 data-id="heading-12">3.3 实现登录接口（获取令牌）</h4>
<pre><code class="hljs language-ini" lang="ini">@app.post("/token", <span class="hljs-attr">response_model</span>=dict)
async def login_for_access_token(
    db: <span class="hljs-attr">Session</span> = Depends(get_db),
    form_data: <span class="hljs-attr">OAuth2PasswordRequestForm</span> = Depends()  <span class="hljs-comment"># 接收表单格式的用户名密码</span>
):
    <span class="hljs-comment"># 验证用户名和密码</span>
    <span class="hljs-attr">user</span> = crud.get_user_by_username(db, username=form_data.username)
    if not user or not crud.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            <span class="hljs-attr">status_code</span>=status.HTTP_401_UNAUTHORIZED,
            <span class="hljs-attr">detail</span>=<span class="hljs-string">"用户名或密码错误"</span>,
            <span class="hljs-attr">headers</span>={<span class="hljs-string">"WWW-Authenticate"</span>: <span class="hljs-string">"Bearer"</span>},
        )
    <span class="hljs-comment"># 生成令牌（sub 字段存储用户名）</span>
    <span class="hljs-attr">access_token</span> = create_access_token(data={<span class="hljs-string">"sub"</span>: user.username})
    return {"access_token": access_token, "token_type": "bearer"}
</code></pre>
<h4 data-id="heading-13">3.4 实现受保护接口</h4>
<ul>
<li>普通接口：需登录（携带令牌）即可访问。</li>
</ul>

<ul>
<li>管理员接口：需登录且为管理员身份才能访问。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 普通受保护接口：获取当前登录用户信息</span>
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/users/me/"</span>, response_model=schemas.UserResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_users_me</span>(<span class="hljs-params">current_user: models.User = Depends(<span class="hljs-params">get_current_user</span>)</span>):
    <span class="hljs-keyword">return</span> current_user
<span class="hljs-comment"># 管理员接口：创建用户（仅管理员可操作）</span>
<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">"/users/"</span>, response_model=schemas.UserResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_new_user</span>(<span class="hljs-params">
    user: schemas.UserCreate,
    db: Session = Depends(<span class="hljs-params">get_db</span>),
    current_user: models.User = Depends(<span class="hljs-params">get_current_admin_user</span>)  <span class="hljs-comment"># 管理员权限依赖</span>
</span>):
    <span class="hljs-comment"># 检查用户名是否已存在</span>
    db_user = crud.get_user_by_username(db, username=user.username)
    <span class="hljs-keyword">if</span> db_user:
        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">"用户名已存在"</span>)
    <span class="hljs-keyword">return</span> crud.create_user(db=db, user=user)
</code></pre>
<h3 data-id="heading-14">四、测试流程与验证</h3>
<h4 data-id="heading-15">1. 初始化数据库</h4>
<ol>
<li>确保 MySQL 已启动，创建 fastapi_db 数据库（CREATE DATABASE fastapi_db;）。</li>
</ol>

<ol start="2">
<li>启动 FastAPI 服务（uvicorn main:app --reload），自动创建 users 表。</li>
</ol>
<h4 data-id="heading-16">2. 测试接口（通过 /docs 页面）</h4>
<ul>
<li>第一步：访问 <a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fdocs" target="_blank" title="http://127.0.0.1:8000/docs" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/docs</a>，找到 /token 接口，点击「Try it out」。</li>
</ul>

<ul>
<li>第二步：输入用户名（如 admin）、密码（如 123456），先调用 /users/ 接口（需管理员身份，可手动在数据库将 is_admin 设为 1）创建管理员用户。</li>
</ul>

<ul>
<li>第三步：用管理员用户名密码调用 /token 接口，获取 access_token。</li>
</ul>

<ul>
<li>第四步：调用 /users/me/ 接口，系统会自动携带令牌，返回当前用户信息。</li>
</ul>

<ul>
<li>第五步：非管理员用户调用 /users/ 接口，会返回 403 权限错误。</li>
</ul>
<h3 data-id="heading-17">五、生产级优化建议</h3>
<ol>
<li>密钥与数据库配置：用 python-dotenv 读取环境变量，避免硬编码。</li>
</ol>

<ol start="2">
<li>数据库迁移：使用 alembic 管理表结构变更（避免直接删除重建表）。</li>
</ol>

<ol start="3">
<li>令牌安全：延长过期时间时，可结合刷新令牌机制。</li>
</ol>

<ol start="4">
<li>日志与监控：添加接口访问日志，监控令牌过期、数据库异常等情况。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我们来说一下 Mybatis 的缓存机制]]></title>    <link>https://juejin.cn/post/7570901172526891043</link>    <guid>https://juejin.cn/post/7570901172526891043</guid>    <pubDate>2025-11-10T09:43:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526891043" data-draft-id="7570902473432875008" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我们来说一下 Mybatis 的缓存机制"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-11-10T09:43:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员小假"/> <meta itemprop="url" content="https://juejin.cn/user/2285197690931932"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我们来说一下 Mybatis 的缓存机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2285197690931932/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员小假
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:43:16.000Z" title="Mon Nov 10 2025 09:43:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">核心概览</h3>
<ul>
<li><strong>一级缓存</strong>：默认开启，作用范围在 <strong>同一个 SqlSession</strong> 内。</li>
<li><strong>二级缓存</strong>：需要手动配置开启，作用范围在 <strong>同一个 Mapper 命名空间</strong>（即同一个 Mapper 接口）内，可以被多个 SqlSession 共享。</li>
</ul>
<h3 data-id="heading-1">一级缓存</h3>
<h4 data-id="heading-2">1. 作用域</h4>
<ul>
<li><strong>SqlSession 级别</strong>：当同一个 SqlSession 执行相同的 SQL 查询时，MyBatis 会优先从缓存中获取数据，而不是直接查询数据库。</li>
<li>它是 <strong>默认开启</strong> 的，无法关闭，但可以配置其作用范围（<code>SESSION</code> 或 <code>STATEMENT</code>）。</li>
</ul>
<h4 data-id="heading-3">2. 工作机制</h4>
<ol>
<li>第一次执行查询后，查询结果会被存储到 SqlSession 关联的一级缓存中。</li>
<li>在同一个 SqlSession 中，再次执行 <strong>完全相同的</strong> SQL 查询（包括语句和参数）时，会直接返回缓存中的对象，而不会去数据库查询。</li>
<li>如果 SqlSession 执行了 <strong>增（INSERT）、删（DELETE）、改（UPDATE）</strong> 操作，或者调用了 <code>commit()</code>、<code>close()</code>、<code>rollback()</code> 方法，该 SqlSession 的一级缓存会被清空。这是为了防止读取到脏数据。</li>
</ol>
<h4 data-id="heading-4">3. 示例说明</h4>
<pre><code class="hljs language-ini" lang="ini">// 假设获取的 SqlSession 和 UserMapper
try (SqlSession <span class="hljs-attr">sqlSession</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper</span> = sqlSession.getMapper(UserMapper.class)<span class="hljs-comment">;</span>

    // 第一次查询，会发送 SQL 到数据库
    User <span class="hljs-attr">user1</span> = mapper.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    System.out.println(user1)<span class="hljs-comment">;</span>

    // 第二次查询，SQL 和参数完全相同，直接从一级缓存返回，不查询数据库
    User <span class="hljs-attr">user2</span> = mapper.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    System.out.println(user2)<span class="hljs-comment">;</span>

    // 判断是否为同一个对象（是，因为从缓存中返回的是同一个对象的引用）
    System.out.println(<span class="hljs-attr">user1</span> == user2)<span class="hljs-comment">; // 输出：true</span>

    // 执行一个更新操作
    mapper.updateUser(user1)<span class="hljs-comment">;</span>
    // 此时，一级缓存被清空

    // 第三次查询，因为缓存被清空，会再次发送 SQL 到数据库
    User <span class="hljs-attr">user3</span> = mapper.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    System.out.println(<span class="hljs-attr">user3</span> == user1)<span class="hljs-comment">; // 输出：false (虽然是同一条数据，但已是新对象)</span>
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-5">4. 注意事项</h4>
<ul>
<li><strong>对象相同</strong>：一级缓存返回的是 <strong>同一个对象的引用</strong>，因此在同一个 SqlSession 内，你操作的都是同一个 Java 对象。</li>
<li><strong>分布式环境</strong>：一级缓存无法在多个应用服务器之间共享，因为它绑定在单个请求的 SqlSession 上。</li>
</ul>
<h3 data-id="heading-6">二级缓存</h3>
<h4 data-id="heading-7">1. 作用域</h4>
<ul>
<li><strong>Mapper 级别 / Namespace 级别</strong>：多个 SqlSession 在访问同一个 Mapper 的查询时，可以共享其缓存。</li>
<li>它是 <strong>默认关闭</strong> 的，需要在全局配置中开启，并在具体的 Mapper XML 中显式配置。</li>
</ul>
<h4 data-id="heading-8">2. 开启与配置</h4>
<p><strong>a. 全局配置文件 (</strong> <code>mybatis-config.xml</code> <strong>)</strong> ：<br/>
必须显式设置开启二级缓存（虽然默认是 <code>true</code>，但显式声明是个好习惯）。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 开启全局二级缓存，默认就是 true，但建议写明 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>b. Mapper XML 文件</strong>：<br/>
在需要开启二级缓存的 Mapper.xml 中添加 <code>&lt;cache/&gt;</code> 标签。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span> ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.example.mapper.UserMapper"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 开启本 Mapper 的二级缓存 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">cache</span>
<span class="hljs-attr">eviction</span>=<span class="hljs-string">"FIFO"</span>
<span class="hljs-attr">flushInterval</span>=<span class="hljs-string">"60000"</span>
<span class="hljs-attr">size</span>=<span class="hljs-string">"512"</span>
<span class="hljs-attr">readOnly</span>=<span class="hljs-string">"true"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 其他 SQL 定义 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUserById"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"long"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"User"</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">"true"</span>&gt;</span>
SELECT * FROM user WHERE id = #{id}
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<ul>
<li>
<p><code>&lt;cache/&gt;</code> 标签属性：</p>
<ul>
<li>
<p><code>eviction</code>：缓存回收策略。</p>
<ul>
<li><code>LRU</code>（默认）：最近最少使用。</li>
<li><code>FIFO</code>：先进先出。</li>
<li><code>SOFT</code>：软引用，基于垃圾回收器状态和软引用规则移除。</li>
<li><code>WEAK</code>：弱引用，更积极地移除。</li>
</ul>
</li>
<li>
<p><code>flushInterval</code>：缓存刷新间隔（毫秒），默认不清空。</p>
</li>
<li>
<p><code>size</code>：缓存存放多少元素。</p>
</li>
<li>
<p><code>readOnly</code>：是否为只读。</p>
<ul>
<li><code>true</code>：返回相同的缓存对象实例，性能好，但不允许修改。</li>
<li><code>false</code>（默认）：通过序列化返回缓存对象的拷贝，安全，性能稍差。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 data-id="heading-9">3. 工作机制</h4>
<ol>
<li>当一个 SqlSession 执行查询后，在关闭或提交时，其查询结果会被存入二级缓存。</li>
<li>另一个 SqlSession 执行相同的查询时，会先从二级缓存中查找数据。如果找到，则直接返回，否则再去数据库查询。</li>
<li>任何一个 SqlSession 执行了 <strong>增、删、改</strong> 操作并 <code>commit()</code> 后，会清空 <strong>整个对应 Mapper 的二级缓存</strong>，以保证数据一致性。</li>
</ol>
<h4 data-id="heading-10">4. 示例说明</h4>
<pre><code class="hljs language-ini" lang="ini">// 第一个 SqlSession
try (SqlSession <span class="hljs-attr">sqlSession1</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper1</span> = sqlSession1.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    User <span class="hljs-attr">user1</span> = mapper1.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">; // 查询数据库</span>
    sqlSession1.close()<span class="hljs-comment">; // 关闭时，数据存入二级缓存</span>
}

// 第二个 SqlSession（与第一个不同）
try (SqlSession <span class="hljs-attr">sqlSession2</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper2</span> = sqlSession2.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    // 查询相同的 SQL，直接从二级缓存获取，不查询数据库
    User <span class="hljs-attr">user2</span> = mapper2.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
}

// 第三个 SqlSession，执行了更新
try (SqlSession <span class="hljs-attr">sqlSession3</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper3</span> = sqlSession3.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    User <span class="hljs-attr">user</span> = mapper3.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    user.setName("New Name")<span class="hljs-comment">;</span>
    mapper3.updateUser(user)<span class="hljs-comment">; // 执行更新</span>
    sqlSession3.commit()<span class="hljs-comment">; // 提交时，清空 UserMapper 的二级缓存</span>
}

// 第四个 SqlSession
try (SqlSession <span class="hljs-attr">sqlSession4</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper4</span> = sqlSession4.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    // 因为缓存已被清空，所以会再次查询数据库
    User <span class="hljs-attr">user4</span> = mapper4.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-11">5. 注意事项</h4>
<ul>
<li><strong>实体类序列化</strong>：如果二级缓存的 <code>readOnly="false"</code>，那么对应的实体类必须实现 <code>Serializable</code> 接口。</li>
<li><strong>事务提交</strong>：只有在 SqlSession 执行 <code>commit()</code> 或 <code>close()</code> 时，数据才会从一级缓存转存到二级缓存。</li>
<li><strong>缓存粒度</strong>：二级缓存是 Mapper 级别的，有时会显得比较粗粒度。可以通过 <code>&lt;cache-ref&gt;</code> 让多个 Mapper 共享一个缓存，但不推荐，容易引起数据混乱。</li>
</ul>
<h3 data-id="heading-12">缓存顺序与总结</h3>
<p>当发起一个查询请求时，MyBatis 的缓存查询顺序是：</p>
<ol>
<li><strong>先查二级缓存</strong>：查看当前 Mapper 的二级缓存中是否有数据。</li>
<li><strong>再查一级缓存</strong>：如果二级缓存没有，再查看当前 SqlSession 的一级缓存中是否有数据。</li>
<li><strong>最后查数据库</strong>：如果两级缓存都没有，才发送 SQL 语句到数据库执行查询。</li>
</ol>
<p>查询到的数据会 <strong>先存入一级缓存</strong>，在 SqlSession 关闭或提交时，<strong>再转存到二级缓存</strong>。</p>



































<table><thead><tr><th/><th/><th/></tr></thead><tbody><tr><td>特性</td><td>一级缓存</td><td>二级缓存</td></tr><tr><td><strong>作用域</strong></td><td>SqlSession</td><td>Mapper (Namespace)</td></tr><tr><td><strong>默认状态</strong></td><td>开启</td><td>关闭</td></tr><tr><td><strong>是否共享</strong></td><td>否，Session 独享</td><td>是，跨 Session 共享</td></tr><tr><td><strong>清空时机</strong></td><td>UPDATE/INSERT/DELETE, <code>commit()</code>, <code>close()</code></td><td>同 Mapper 的 UPDATE/INSERT/DELETE + <code>commit()</code></td></tr></tbody></table>
<h3 data-id="heading-13">使用建议</h3>
<ul>
<li><strong>查询多，修改少</strong>的数据适合使用二级缓存，如字典表、配置项。</li>
<li><strong>数据实时性要求高</strong>的场景（如交易、订单）应谨慎使用二级缓存，或者设置较短的刷新间隔。</li>
<li>在分布式环境中，默认的二级缓存（基于内存）是无法共享的，需要集成 Redis、Ehcache 等第三方缓存中间件来替代。</li>
<li>理解缓存机制有助于解决一些“诡异”的问题，比如在同一个事务中，先后查询和更新，但由于一级缓存的存在，后续查询可能看不到其他线程的更新。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理]]></title>    <link>https://juejin.cn/post/7570902473432645632</link>    <guid>https://juejin.cn/post/7570902473432645632</guid>    <pubDate>2025-11-10T09:18:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902473432645632" data-draft-id="7570902473432612864" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理"/> <meta itemprop="keywords" content="Java,Android"/> <meta itemprop="datePublished" content="2025-11-10T09:18:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="弥巷"/> <meta itemprop="url" content="https://juejin.cn/user/1743186606454698"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1743186606454698/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    弥巷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:18:11.000Z" title="Mon Nov 10 2025 09:18:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理</h2>
<p>在Android中，通常会通过缓存策略来优化性能，同时也会减少不必要的流量消耗。比如，用户第一次使用网络加载一张图片后，下次加载这张图片的时候，并不会从网络加载，而是会从内存或者磁盘加载这张图片。</p>
<h3 data-id="heading-1">1.LRU缓存淘汰算法</h3>
<p>由于缓存的大小并不是无限制的，因此在使用缓存时总是要为缓存指定一个最大的容量。如果当缓存容量满了，但是程序还需要向其添加缓存，这就需要删除一些旧的缓存并添加新的缓存，如何定义缓存的新旧就对应着不同的缓存算法。最常用的一种缓存算法是<strong>LRU （Least Recently Used）最近最少使用算法</strong>，它的基本理念是：<strong>当缓存空间不足时，优先淘汰最久未被访问的数据</strong>。常见缓存淘汰策略还有：</p>
<p><strong>1、随机策略：</strong> 使用一个随机数生成器随机地选择要被淘汰的数据块；</p>
<p><strong>2、FIFO 先进先出策略：</strong> 记录各个数据块的访问时间，最早访问的数据最先被淘汰；</p>
<p><strong>3、LRU （Least Recently Used）最近最少策略：</strong> 记录各个数据块的访问 <strong>“时间戳”</strong> ，最近最久未使用的数据最先被淘汰。与前 2 种策略相比，LRU 策略平均缓存命中率更高，这是因为 LRU 策略利用了 “局部性原理”：最近被访问过的数据，将来被访问的几率较大，最近很久未访问的数据，将来访问的几率也较小；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56deddf81e2e4c0c90a1d58db591cfff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=cl43IO1MJdhR%2FEX%2BRRbTdg%2Fd0Ko%3D" alt="1613c53defb9b5d4~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.png" loading="lazy"/></p>
<p><strong>4、LFU （Least Frequently Used）最不经常使用策略：</strong> 与 LRU 相比，LFU 更加注重使用的 <strong>“频率”</strong> 。LFU 会记录每个数据块的访问次数，最少访问次数的数据最先被淘汰。但是有些数据在开始时使用次数很高，以后不再使用，这些数据就会长时间污染缓存。可以定期将计数器右移一位，形成指数衰减。</p>
<p>而在Android中，Lru对应LruCache和DiskLruCache两种缓存类。</p>
<h3 data-id="heading-2">2. LruCache的使用</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">int</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span>);
<span class="hljs-comment">//初始化大小:当前进程的可用内存的1/8</span>
<span class="hljs-type">int</span> <span class="hljs-variable">cacheSize</span> <span class="hljs-operator">=</span> maxMemory / <span class="hljs-number">8</span>;
memorySize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruCache</span>&lt;String, Bitmap&gt;(cacheSize) {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sizeOf</span><span class="hljs-params">(String key, Bitmap value)</span> {
        <span class="hljs-comment">//重写该方法,完成每张要缓存的图片大小的计算</span>
        <span class="hljs-keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="hljs-number">1024</span>;
    }
};

</code></pre>
<p>使用非常简单，只需要提供缓存的总容量大小并重写sizeOf方法即可。总容量大小为当前进程可用内存的1/8，sizeOf方法完成对Bitmap对象大小的计算。</p>
<p>除了创建缓存，还有下面一些常用方法：</p>

































<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>get(K)</td><td>通过K获取缓存</td></tr><tr><td>put(K,V)</td><td>设置K的值为V</td></tr><tr><td>remove(K)</td><td>删除K缓存</td></tr><tr><td>evictAll()</td><td>清除缓存</td></tr><tr><td>resize(int)</td><td>设置最大缓存大小</td></tr><tr><td>snapshot()</td><td>获取缓存内容的镜像</td></tr></tbody></table>
<h3 data-id="heading-3">3.DiskLruCache的使用</h3>
<p>DiskLruCache不是Android SDK的一部分，而是由Jake Wharton在JakeWharton/DiskLruCache提供的一个开源实现。所以使用之前要先引入依赖：</p>
<pre><code class="hljs language-groovy" lang="groovy">implementation 'com.jakewharton:disklrucache:2.0.2'
</code></pre>
<h4 data-id="heading-4">3.1 DiskLruCache的创建</h4>
<p><code>DiskLruCache</code>并不能通过构造方法来创建，它提供了open方法用于创建自身：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> com.jakewharton.disklrucache.DiskLruCache;
<span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskCacheHelper</span> {
    <span class="hljs-keyword">private</span> DiskLruCache diskLruCache;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiskCacheHelper</span><span class="hljs-params">(File cacheDir)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-comment">// 创建缓存目录</span>
        <span class="hljs-keyword">if</span> (!cacheDir.exists()) {
            cacheDir.mkdirs();
        }
        
        <span class="hljs-comment">// 初始化DiskLruCache</span>
        <span class="hljs-comment">// 参数：缓存目录, 版本号, 每个key对应的文件数, 最大缓存大小(字节)</span>
        diskLruCache = DiskLruCache.open(cacheDir, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 10MB</span>
    }
}
</code></pre>
<p>open方法有四个参数，其中第一个参数表示磁盘缓存在文件系统中的存储路径。第二个参数表示应用的版本号，一般设为1即可；第三个参数表示单个节点所对应的数据的个数，一般设为1即可；第四个参数表示缓存的总大小，比如10MB，当缓存大小超出这个设定值后，DiskLruCache会清除一些缓存从而保证总大小不大于这个设定值。</p>
<h4 data-id="heading-5">3.2 DiskLruCache的缓存添加</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveToCache</span><span class="hljs-params">(String key, String data)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 获取编辑器</span>
    DiskLruCache.<span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> diskLruCache.edit(key);
    <span class="hljs-keyword">if</span> (editor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-comment">// 写入数据</span>
    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> editor.newOutputStream(<span class="hljs-number">0</span>);
    outputStream.write(data.getBytes());
    outputStream.close();
    
    <span class="hljs-comment">// 提交保存</span>
    editor.commit();
}
</code></pre>
<p>要添加缓存，首先要通过key获取缓存对象的<code>Editor</code>（编辑对象），对于这个key来说如果当前不存在其他Editor对象。那么edit()就会返回一个新的Editor对象，接着通过这个Editor就可以得到一个文件输出流，有了文件输出流，数据就可以通过这个文件输出流写入到文件系统上。最后要注意的是，单单通过<code>outputStream.write(data.getBytes());</code>，数据其实并没有真正地写入文件系统，还必须通过Editor的commit()来提交写入操作。如果数据下载过程中发生了异常还可以通过Editor的abort()来回退整个操作:</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> editor.newOutputStream(<span class="hljs-number">0</span>)) {
            os.write(data.getBytes());
        }
        editor.commit();
    } <span class="hljs-keyword">catch</span> (IOException e) {
        editor.abort(); <span class="hljs-comment">// 回退</span>
        <span class="hljs-keyword">throw</span> e;
    }
</code></pre>
<p>这样数据就成功写入到文件系统了，接下来数据（比如图片）的获取就不需要网络了。</p>
<h4 data-id="heading-6">3.3 DiskLruCache的缓存查找</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">readFromCache</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 获取快照</span>
    DiskLruCache.<span class="hljs-type">Snapshot</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> diskLruCache.get(key);
    <span class="hljs-keyword">if</span> (snapshot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-comment">// 读取数据</span>
    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> snapshot.getInputStream(<span class="hljs-number">0</span>);
    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream));
    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
    String line;
    
    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) {
        stringBuilder.append(line);
    }
    
    reader.close();
    snapshot.close();
    <span class="hljs-keyword">return</span> stringBuilder.toString();
}
</code></pre>
<p>和缓存的添加类似，查找缓存首先通过DiskLruCache的get方法传入key获取到Snapshot对象，接下里通过Snapshot对象就能得到缓存的文件输入流，拿到文件输入流，就能很轻松的得到原始数据。</p>
<h4 data-id="heading-7">3.4 DiskLruCache的缓存删除</h4>
<p>删除就非常简单了，DiskLruCache提供了remove方法实现缓存的删除操作：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFromCache</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
    diskLruCache.remove(key);
}
</code></pre>
<h3 data-id="heading-8">4. LruCache的源码实现</h3>
<p>LruCahche其实使用了LinkedHashMap双向链表结构，以下是LinkedHashMap的构造方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,
                         <span class="hljs-type">float</span> loadFactor,
                         <span class="hljs-type">boolean</span> accessOrder)</span> {
        <span class="hljs-built_in">super</span>(initialCapacity, loadFactor);
        <span class="hljs-built_in">this</span>.accessOrder = accessOrder;
    }
</code></pre>
<p>布尔变量<code>accessOrder</code>为true时，LinkedHashMap会以访问顺序排列元素，也就是访问了之后就将这个元素放到集合的最后面，否则以插入顺序排列元素。</p>
<p>可以发现，在LiskHashMap中，当<code>accessOrder</code>为true时，最后被访问的元素会被移动到表尾，而LruCache也是从表尾访问数据，在表头删除元素，这正是符合我们预期的，接下来看看LruCache是如何进行缓存的写入、获取和删除的。</p>
<h4 data-id="heading-9">4.1 LruCache的put()方法分析：</h4>
<p>写入缓存是通过LruChche的put方法实现的，源码如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> {
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"key == null || value == null"</span>);
        }
		<span class="hljs-comment">// 这个变量用于保存被替换的旧值（如果有的话）</span>
        V previous;
    	<span class="hljs-comment">// 加锁，确保线程安全 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">// 缓存数量自增</span>
            putCount++;
            <span class="hljs-comment">// 计算缓存总大小，safeSizeOf方法计算当前键值对的大小</span>
            size += safeSizeOf(key, value);
            <span class="hljs-comment">// 通过LinkedHashMap中的put方法将键值对存入map中</span>
            <span class="hljs-comment">// 如果键已存在，map.put会返回被替换的旧值，否则返回null</span>
            previous = map.put(key, value);
            <span class="hljs-comment">// 旧值存在（就是更新键所对应的值）</span>
            <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 从总大小中减去旧值的大小，注意新值大小已经添加</span>
                size -= safeSizeOf(key, previous);
            }
        }

        <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 用于资源回收清理</span>
            entryRemoved(<span class="hljs-literal">false</span>, key, previous, value);
        }
    
		<span class="hljs-comment">// 检查并调整缓存大小，使用Lru算法确保当前缓存总大小不会超出最大容量限制</span>
        trimToSize(maxSize);
    	<span class="hljs-comment">// 返回被替换的旧值（如果存在） </span>
        <span class="hljs-keyword">return</span> previous;
    }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> {
    	<span class="hljs-comment">// 无限循环删除最老缓存直到大小满足要求 </span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-comment">// 用于保存被删除的键值对</span>
            K key;
            V value;
            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
				<span class="hljs-comment">// 参数检查</span>
                <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="hljs-number">0</span>)) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(getClass().getName()
                            + <span class="hljs-string">".sizeOf() is reporting inconsistent results!"</span>);
                }
				<span class="hljs-comment">// 循环终止条件：当前大小小于等于最大容量，不需要删除最老缓存</span>
                <span class="hljs-keyword">if</span> (size &lt;= maxSize) {
                    <span class="hljs-keyword">break</span>;
                }
				
                <span class="hljs-comment">// 核心：eldest()方法返回最近最少使用的缓存，也就是链表的表头元素</span>
                Map.Entry&lt;K, V&gt; toEvict = eldest();
                <span class="hljs-comment">// 异常判断：没有可移除的缓存</span>
                <span class="hljs-keyword">if</span> (toEvict == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">break</span>;
                }
				<span class="hljs-comment">// 最近最少使用的缓存的键值对</span>
                key = toEvict.getKey();
                value = toEvict.getValue();
                <span class="hljs-comment">// 使用LinkedHashMap的remove方法移除该缓存</span>
                map.remove(key);
                <span class="hljs-comment">// 从总大小中减去删除的缓存大小</span>
                size -= safeSizeOf(key, value);
                <span class="hljs-comment">// 移除计数器自增</span>
                evictionCount++;
            }
			
            <span class="hljs-comment">// 资源回收，true表示由于缓存空间不足而被删除，null表示新值</span>
            entryRemoved(<span class="hljs-literal">true</span>, key, value, <span class="hljs-literal">null</span>);
        }
    }
</code></pre>
<p>put方法主要是添加缓存后，然后调用<code>trimToSize</code>方法使用Lru算法来删除最近最少使用的缓存，保证缓存大小。同时两个方法都使用了同步方法块确保线程安全，简要概括来讲就是先插入后检查，以下图示很清楚地展示了put方法的工作流程：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5524aeb01b64351b07b06a810f255a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=dhYZreDzLeQqNTPaA1QCGlASu%2FI%3D" alt="38d656e051a548778c1bd5705ee44ed0~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" loading="lazy"/></p>
<h4 data-id="heading-10">4.2 LruCache的get()方法分析：</h4>
<p>get()方法实现了LruCache的读取缓存操作：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> {
    	<span class="hljs-comment">// 键的非空判断 </span>
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"key == null"</span>);
        }

        V mapValue;
    	<span class="hljs-comment">// 尝试从缓存中获取值 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">//调用LinkedHashMap的get()方法，注意如果该元素存在，且accessOrder为true，这个方法会将该元素移动到表尾</span>
            mapValue = map.get(key);
            <span class="hljs-comment">// 缓存命中：</span>
            <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-literal">null</span>) {
                hitCount++; <span class="hljs-comment">// 命中计数器自增</span>
                <span class="hljs-keyword">return</span> mapValue; <span class="hljs-comment">// 返回找到的值，get()方法结束 </span>
            }
            <span class="hljs-comment">// 缓存没有命中：</span>
            missCount++; <span class="hljs-comment">// 未命中计数器自增</span>
        }
		
    	<span class="hljs-comment">// 缓存未命中处理：创建值 </span>
        <span class="hljs-type">V</span> <span class="hljs-variable">createdValue</span> <span class="hljs-operator">=</span> create(key);
    	<span class="hljs-comment">// creat()方法返回null，创建失败，get()直接返回null </span>
        <span class="hljs-keyword">if</span> (createdValue == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
		
    	<span class="hljs-comment">// 将创建的值存入缓存 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            createCount++; <span class="hljs-comment">// 创建计数器自增</span>
            
            <span class="hljs-comment">// 尝试将创建的值存入map</span>
            <span class="hljs-comment">// 注：在释放锁和重新加锁的间隙，其他线程可能已经存入相同的键，所以这里使用put()方法，可能会返回已经存在的值</span>
            mapValue = map.put(key, createdValue);

            <span class="hljs-comment">// 如果mapValue不为空，说明创建过程中发生了冲突，也就是其他线程在我们创建值的同时也插入了相同的键</span>
            <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// There was a conflict so undo that last put</span>
                <span class="hljs-comment">// 撤销刚才的put操作，就是把其他线程插入的值恢复</span>
                map.put(key, mapValue);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 没有冲突，正常更新缓存大小</span>
                size += safeSizeOf(key, createdValue);
            }
        }

        <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 发生冲突，通知创建的值被丢弃，回调entryRemoved完方法成资源的回收工作</span>
            entryRemoved(<span class="hljs-literal">false</span>, key, createdValue, mapValue);
            <span class="hljs-keyword">return</span> mapValue; <span class="hljs-comment">// 返回其他线程插入的值（就是最终缓存中的值） </span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 没有冲突，正常进行容量检查</span>
            trimToSize(maxSize);
            <span class="hljs-comment">// 返回创建的值</span>
            <span class="hljs-keyword">return</span> createdValue;
        }
    }
</code></pre>
<p>逻辑很清楚，首先通过LinkedHashMap的get方法通过键key获取值，如果存在，并且<code>且accessOrder</code>为true，整个方法会将元素移动到表尾，实现Lru的缓存逻辑。</p>
<p>如果get方法获取不到值，那么就创建键值对通过LinkedHashMap的put方法存入map，和put方法的逻辑类似，不过中间会进行线程安全的判断，保证不会重复插入键。</p>
<p>get方法图示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba74e8e6b9194c1f8c87d364b340010b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=zYuRdFyBYcTrbDVZAllNq48KEOo%3D" alt="5aa6a6141c2f40c3886c7d6204732a97~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" loading="lazy"/></p>
<h4 data-id="heading-11">4.3 LruCache删除缓存方法分析：</h4>
<p>LruCache中删除缓存是通过remove()方法实现的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> {
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"key == null"</span>);
        }
		
    	<span class="hljs-comment">// 保存被移除的值 </span>
        V previous;
    	<span class="hljs-comment">// 确保线程安全地移除操作 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">// 从map中移除缓存</span>
            <span class="hljs-comment">// 如果存在key所对应地值，返回被移除的值</span>
            <span class="hljs-comment">// 不存在就返回null</span>
            previous = map.remove(key);
            <span class="hljs-comment">// 成功移除了缓存</span>
            <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 更新缓存总大小</span>
                size -= safeSizeOf(key, previous);
            }
        }
		
    	<span class="hljs-comment">// 成功移除缓存，回调entryRemoved方法进行资源回收工作</span>
        <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
            entryRemoved(<span class="hljs-literal">false</span>, key, previous, <span class="hljs-literal">null</span>);
        }
		
    	<span class="hljs-comment">// 返回被移除的值，如果键不存在就返回null </span>
        <span class="hljs-keyword">return</span> previous;
    }
</code></pre>
<p>同样非常简单，调用LinkedHashMap的remove方法删除key所对应的值，也是使用了同步方法块来确保线程安全</p>
<p>图示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8018cbb315b94a04ba934f57cc31b2ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=kPQKEqPAB1YpLf%2B8YuTZ18PpuZU%3D" alt="f7c6012cbe3546119f70c48bccded3d3~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" loading="lazy"/></p>
<h3 data-id="heading-12">5. DiskLruCache的源码实现</h3>
<h4 data-id="heading-13">5.1 DiskLruCache的open()方法分析</h4>
<p>DiskLruCache的使用从DiskLruCache的创建开始，也就是从open方法开始，接下来看看open方法的实现：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 打开或创建磁盘LRU缓存实例
 * 这是DiskLruCache的主入口方法，负责缓存的初始化、恢复和重建
 * 
 * <span class="hljs-doctag">@param</span> directory 缓存目录，缓存文件将存储在此目录下
 * <span class="hljs-doctag">@param</span> appVersion 应用版本号，用于版本管理（版本变更时会清空缓存）
 * <span class="hljs-doctag">@param</span> valueCount 每个缓存条目对应的文件数量（通常为1）
 * <span class="hljs-doctag">@param</span> maxSize 缓存的最大容量（字节）
 * <span class="hljs-doctag">@return</span> 初始化好的DiskLruCache实例
 * <span class="hljs-doctag">@throws</span> IOException 如果发生I/O错误
 * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果参数不合法
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskLruCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {
    
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DiskLruCache <span class="hljs-title function_">open</span><span class="hljs-params">(File directory, <span class="hljs-type">int</span> appVersion, <span class="hljs-type">int</span> valueCount, <span class="hljs-type">long</span> maxSize)</span>
          <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">if</span> (maxSize &lt;= <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"maxSize &lt;= 0"</span>);
        }
        <span class="hljs-keyword">if</span> (valueCount &lt;= <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"valueCount &lt;= 0"</span>);
        }
    
        <span class="hljs-type">File</span> <span class="hljs-variable">backupFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(directory, JOURNAL_FILE_BACKUP);
        <span class="hljs-comment">//如果备份文件存在</span>
        <span class="hljs-keyword">if</span> (backupFile.exists()) {
          <span class="hljs-type">File</span> <span class="hljs-variable">journalFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(directory, JOURNAL_FILE);
          <span class="hljs-comment">// 如果journal文件存在，则把备份文件journal.bkp是删了</span>
          <span class="hljs-keyword">if</span> (journalFile.exists()) {
            backupFile.delete();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//如果journal文件不存在，则将备份文件命名为journal</span>
            renameTo(backupFile, journalFile, <span class="hljs-literal">false</span>);
          }
        }
    	<span class="hljs-comment">// 尝试从现有缓存恢复：优先复用已有的缓存数据</span>
        <span class="hljs-type">DiskLruCache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);
        
        <span class="hljs-comment">//判断journal文件是否存在</span>
        <span class="hljs-keyword">if</span> (cache.journalFile.exists()) {
          <span class="hljs-comment">//如果日志文件以及存在</span>
          <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 恢复现有缓存的三步流程：</span>
            <span class="hljs-comment">// 1. readJournal(): 读取日志文件内容到内存</span>
            cache.readJournal();
            <span class="hljs-comment">// 2. processJournal(): 处理日志条目，重建缓存状态</span>
            cache.processJournal();
            <span class="hljs-comment">// 3. 创建追加模式的日志写入器，用于后续操作</span>
            cache.journalWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(cache.journalFile, <span class="hljs-literal">true</span>), Util.US_ASCII));
            <span class="hljs-keyword">return</span> cache;
          } <span class="hljs-keyword">catch</span> (IOException journalIsCorrupt) {
            System.out
                .println(<span class="hljs-string">"DiskLruCache "</span>
                    + directory
                    + <span class="hljs-string">" is corrupt: "</span>
                    + journalIsCorrupt.getMessage()
                    + <span class="hljs-string">", removing"</span>);
            cache.delete();
          }
        }
    
        <span class="hljs-comment">// Create a new empty cache.</span>
        <span class="hljs-comment">//创建新的缓存目录</span>
        directory.mkdirs();
        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);
        <span class="hljs-comment">//调用新的方法建立新的journal文件</span>
        cache.rebuildJournal();
        <span class="hljs-keyword">return</span> cache;
      }
}

</code></pre>
<p>DiskLruCache的构造方法并没有做别的事情，只是简单的将对应成员变量进行初始化，open()方法主要围绕着journal文件的创建与读写而展开的，如下所示：</p>
<ul>
<li>readJournal()：读取journal文件，主要是读取文件头里的信息进行检验，然后调用readJournalLine()逐行去读取，根据读取的内容，执行相应的缓存 添加、移除等操作。</li>
<li>rebuildJournal()：重建journal文件，重建journal文件主要是写入文件头（上面提到的journal文件都有的前面五行的内容）。</li>
<li>rocessJournal()：计算当前缓存容量的大小。</li>
</ul>
<p>至于journal文件，则是一个<strong>日志文件</strong>，主要用于记录缓存的所有操作和状态。这里关于journal文件的创建和读写流程就不展开了，感兴趣的朋友可以看看它的具体原理。接下来主要围绕DiskLruCache的写入，查找以及删除缓存来介绍。</p>
<h4 data-id="heading-14">5.2 DiskLruCache的edit()方法分析：</h4>
<p>DiskLruCache缓存的写入是通过edit()方法来完成的，源码如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> Editor <span class="hljs-title function_">edit</span><span class="hljs-params">(String key, <span class="hljs-type">long</span> expectedSequenceNumber)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 检查DiskLruCache是否已关闭，关闭则抛出异常</span>
    checkNotClosed();
    <span class="hljs-comment">// 验证键的有效性（通常检查是否包含空格等非法字符）</span>
    validateKey(key);
    <span class="hljs-comment">// 从之前的缓存中读取对应的entry</span>
    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> lruEntries.get(key);
    <span class="hljs-comment">// 无法修改</span>
    <span class="hljs-keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="hljs-literal">null</span>
        || entry.sequenceNumber != expectedSequenceNumber)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Snapshot is stale.</span>
    }
    <span class="hljs-comment">// key所对应的缓存不存在，创建新的键值对并存入LinkedHashMap中</span>
    <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) {
      entry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key);
      lruEntries.put(key, entry);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.currentEditor != <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 如果当前缓存正在被其他Editor编辑，拒绝并发编辑</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Another edit is in progress.</span>
    }
	
    <span class="hljs-comment">// 创建新的Editor实例，与缓存相关联</span>
    <span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Editor</span>(entry);
    entry.currentEditor = editor; <span class="hljs-comment">// 当前缓存为编辑状态</span>

    <span class="hljs-comment">// Flush the journal before creating files to prevent file leaks.</span>
    <span class="hljs-comment">// 写入DIRTY记录表示开始编辑操作</span>
    journalWriter.write(DIRTY + <span class="hljs-string">' '</span> + key + <span class="hljs-string">'\n'</span>);
    journalWriter.flush(); <span class="hljs-comment">// 强制刷新到磁盘，确保日志持久化</span>
    <span class="hljs-comment">// 返回Editor实例以供后续编辑使用</span>
    <span class="hljs-keyword">return</span> editor;
  }
</code></pre>
<p>至于DIRTY，DIRTY是DiskLruCache的一种状态标记。向日志文件中写入<strong>DIRTY</strong> ，则表示当前缓存条目正在被编辑但尚未完成。</p>
<p>一般格式为DIRTY + 空格+key，比如：</p>
<pre><code class="hljs language-bash" lang="bash">DIRTY key123  <span class="hljs-comment"># 表示 key123 这个条目正在被修改</span>
</code></pre>
<p>一般来说DIRTY 记录与 CLEAN/REMOVE 记录成对出现，构成一个完整的操作单元：</p>
<p><strong>正常完成</strong>：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">DIRTY key123    ← 表示缓存条目开始编辑
...（文件操作）...
<span class="hljs-built_in">CLEAN</span> key123    ← 表示缓存条目编辑成功完成
</code></pre>
<p><strong>异常终止</strong>：</p>
<pre><code class="hljs language-markdown" lang="markdown">DIRTY key123    ← 表示缓存条目开始编辑
...（程序崩溃）...
<span class="hljs-code">                ← 缺少 CLEAN，表示操作未完成
</span></code></pre>
<p>而lruEntries则是一个LinkedHashMap对象，表示实际的缓存条目表，负责实际的缓存存储。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/225986e2b63c4004a945ec8f93ed2afd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=%2BDYQfA3sNPymrns1ChjwKnHppWg%3D" alt="屏幕截图 2025-11-10 161856.png" loading="lazy"/></p>
<p>edit()方法主要就是构建了一个Editor对象，它主要干了两件事：</p>
<ol>
<li>从集合中找到对应的实例（如果没有创建一个放到集合中），然后创建一个editor，将editor和entry关联起来。</li>
<li>向journal中写入一行操作数据（DITTY 空格 和key拼接的文字），表示这个key当前正处于编辑状态。</li>
</ol>
<p>在前面使用DiskLruCache的例子中，我们调用了Editor的newOutputStream()方法创建了一个OutputStream来写入缓存文件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 获取缓存条目指定索引值文件的输入流
 * 用于读取缓存数据，通常在Snapshot对象中使用
 * 
 * <span class="hljs-doctag">@param</span> index 值文件的索引（从0开始，小于valueCount）
 * <span class="hljs-doctag">@return</span> 文件的输入流，如果文件不存在返回null
 * <span class="hljs-doctag">@throws</span> IOException 如果发生I/O错误
 * <span class="hljs-doctag">@throws</span> IllegalStateException 如果Snapshot已关闭或无效
 */</span>
<span class="hljs-keyword">public</span> InputStream <span class="hljs-title function_">newInputStream</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-keyword">throws</span> IOException {
      <span class="hljs-keyword">synchronized</span> (DiskLruCache.<span class="hljs-built_in">this</span>) {
        <span class="hljs-comment">// 确保当前Editor仍然有效</span>
        <span class="hljs-keyword">if</span> (entry.currentEditor != <span class="hljs-built_in">this</span>) {
          <span class="hljs-comment">// 两种情况：</span>
          <span class="hljs-comment">// 1. Snapshot已被关闭</span>
          <span class="hljs-comment">// 2. 或者条目已被新的Editor占用</span>
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();
        }
          
        <span class="hljs-comment">// 检查条目是否可读：entry.readable为true表示条目处于CLEAN状态</span>
        <span class="hljs-comment">// 如果为false，说明条目可能正在编辑或已被移除</span>
        <span class="hljs-keyword">if</span> (!entry.readable) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">// entry.getCleanFile(index) 获取指定索引的缓存数据文件</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(entry.getCleanFile(index));
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      }
    }
</code></pre>
<p>这个方法的形参index就是我们开始在open()方法里传入的valueCount，这个valueCount表示了一个key对应几个value,也就是说一个key对应几个缓存文件。那么现在传入的这个index就表示 要缓存的文件时对应的第几个value。</p>
<p>有了输出流，我们在接着调用Editor的commit()方法就可以完成缓存文件的写入了：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
      <span class="hljs-keyword">if</span> (hasErrors) {
      	<span class="hljs-comment">// 如果写入缓存出错就把集合中的缓存条目移除掉</span>
        completeEdit(<span class="hljs-built_in">this</span>, <span class="hljs-literal">false</span>);
        remove(entry.key); <span class="hljs-comment">// The previous entry is stale.</span>
      } <span class="hljs-keyword">else</span> {
      	<span class="hljs-comment">// 编辑成功则提交更改</span>
        completeEdit(<span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);
      }
      <span class="hljs-comment">// 标记本次编辑已提交，防止重复提交</span>
      committed = <span class="hljs-literal">true</span>;
    }
</code></pre>
<p>通过completeEdit方法来完成最终的缓存写入，completeEdit方法负责处理编辑的提交或中止。当编辑成功时，它将编辑过程中使用的临时工作文件转换为最终的缓存数据文件，更新缓存大小统计，并在日志中写入 CLEAN 记录；当编辑失败时，则删除临时文件进行操作撤销。
至此，缓存的插入就完成了。</p>
<h4 data-id="heading-15">3.3 读取缓存</h4>
<p>读取缓存是由DiskLruCache的get()方法来完成的，如下所示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskLruCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {
    
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Snapshot <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
        checkNotClosed();
        validateKey(key);
        <span class="hljs-comment">// 获取key对应的entry</span>
        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> lruEntries.get(key);
        <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    
        <span class="hljs-comment">// 如果entry不可读，说明可能在编辑，则返回空。</span>
        <span class="hljs-keyword">if</span> (!entry.readable) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    
        <span class="hljs-comment">// 打开所有缓存文件的输入流，等待被读取。</span>
        InputStream[] ins = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStream</span>[valueCount];
        <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">// 为每个值文件创建输入流</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; valueCount; i++) {
            <span class="hljs-comment">// 获取正式缓存文件（非临时文件）的输入流</span>
            ins[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(entry.getCleanFile(i));
          }
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
          <span class="hljs-comment">// A file must have been deleted manually!</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; valueCount; i++) {
            <span class="hljs-keyword">if</span> (ins[i] != <span class="hljs-literal">null</span>) {
              Util.closeQuietly(ins[i]);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">break</span>;
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    	<span class="hljs-comment">// 增加冗余操作计数</span>
        redundantOpCount++;
        <span class="hljs-comment">// 向journal写入一行READ开头的记录，表示执行了一次读取操作</span>
        journalWriter.append(READ + <span class="hljs-string">' '</span> + key + <span class="hljs-string">'\n'</span>);
        
         
        <span class="hljs-comment">// 如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件</span>
        <span class="hljs-keyword">if</span> (journalRebuildRequired()) {
          executorService.submit(cleanupCallable);
        }
        
        <span class="hljs-comment">// 返回一个缓存文件快照，包含缓存文件大小，输入流等信息。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snapshot</span>(key, entry.sequenceNumber, ins, entry.lengths);
      }
}
</code></pre>
<p>读取操作主要完成了以下几件事情：</p>
<ol>
<li>获取对应的entry。</li>
<li>打开所有缓存文件的输入流，等待被读取。</li>
<li>向journal写入一行READ开头的记录，表示执行了一次读取操作。</li>
<li>如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件。</li>
<li>返回一个缓存文件快照，包含缓存文件大小，输入流等信息。</li>
</ol>
<p>该方法最终返回一个缓存文件快照，包含缓存文件大小，输入流等信息。利用这个快照我们就可以读取缓存文件了。</p>
<h4 data-id="heading-16">3.4 删除缓存</h4>
<p>删除缓存是由DiskLruCache的remove()方法来完成的，如下所示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskLruCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {
    
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
        checkNotClosed();
        validateKey(key);
        <span class="hljs-comment">// 获取对应的entry</span>
        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> lruEntries.get(key);
        <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span> || entry.currentEditor != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    
        <span class="hljs-comment">// 删除对应的缓存文件，并将缓存大小置为0.</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; valueCount; i++) {
          <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> entry.getCleanFile(i);
          <span class="hljs-keyword">if</span> (file.exists() &amp;&amp; !file.delete()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">"failed to delete "</span> + file);
          }
          size -= entry.lengths[i];
          entry.lengths[i] = <span class="hljs-number">0</span>;
        }
    
        redundantOpCount++;
        <span class="hljs-comment">// 向journal文件添加一行REMOVE开头的记录，表示执行了一次删除操作。</span>
        journalWriter.append(REMOVE + <span class="hljs-string">' '</span> + key + <span class="hljs-string">'\n'</span>);
        lruEntries.remove(key);
    
    
        <span class="hljs-comment">// 如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件</span>
        <span class="hljs-keyword">if</span> (journalRebuildRequired()) {
          executorService.submit(cleanupCallable);
        }
    
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }   
}
</code></pre>
<p>删除操作主要做了以下几件事情：</p>
<ol>
<li>获取对应的entry。</li>
<li>删除对应的缓存文件，并将缓存大小置为0.</li>
<li>向journal文件添加一行REMOVE开头的记录，表示执行了一次删除操作。</li>
<li>如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 RAG 到 CAG：AI 正在超越“检索”，学会“融会贯通”！]]></title>    <link>https://juejin.cn/post/7570295366481330212</link>    <guid>https://juejin.cn/post/7570295366481330212</guid>    <pubDate>2025-11-10T08:12:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570295366481330212" data-draft-id="7570598043298152511" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 RAG 到 CAG：AI 正在超越“检索”，学会“融会贯通”！"/> <meta itemprop="keywords" content="LLM,程序员,Agent"/> <meta itemprop="datePublished" content="2025-11-10T08:12:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大模型教程"/> <meta itemprop="url" content="https://juejin.cn/user/1145012233707299"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 RAG 到 CAG：AI 正在超越“检索”，学会“融会贯通”！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1145012233707299/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大模型教程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:12:03.000Z" title="Mon Nov 10 2025 08:12:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fhy.zhipoai.cn%2F" target="_blank" title="https://hy.zhipoai.cn/" ref="nofollow noopener noreferrer">智泊AI</a>。</p>
</blockquote>
<p>大型语言模型 (LLM) 无疑是当今科技领域最耀眼的明星。它们强大的自然语言处理和内容生成能力，正在重塑从搜索到创意工作的几乎所有行业。然而，如同希腊神话中的阿喀琉斯，这些强大的模型也有其“阿喀琉斯之踵”——它们固有的两大缺陷：</p>
<ul>
<li><strong>知识“幻觉” (Hallucination):</strong>  它们有时会自信地编造出错误或不存在的信息。</li>
<li><strong>知识“陈旧” (Outdatedness):</strong>  它们对世界的认知被“冻结”在训练数据截止的那一刻，无法获知任何新发生的事件或信息。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4988cce23dc41e081648de1c5799a0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367123&amp;x-signature=rgMCO29fhbRFRokQ7bTtL1C55lw%3D" alt="" loading="lazy"/></p>
<p>为了解决这些问题， <strong>“增强生成” (Augmented Generation)</strong>  技术应运而生。在这一领域中，<strong>RAG (Retrieval-Augmented Generation)</strong>  已成为行业标配，而 <strong>CAG (Context-Augmented Generation)</strong>  则代表了一个更深入、更智能的演进方向。</p>
<h2 data-id="heading-0">RAG (Retrieval-Augmented Generation)</h2>
<p>RAG（检索增强生成）是目前解决 LLM 缺陷最有效和最主流的架构。其核心思想非常直观：<strong>与其强迫模型“背诵”全世界的知识，不如让它学会“查资料”</strong> 。</p>
<p>RAG 就像是给了 AI 一套最新的参考书（知识库），并允许它在回答问题前进行“开卷考试”。</p>
<p><strong>RAG 的标准工作流程：</strong></p>
<ol>
<li><strong>接收查询：</strong>  用户提出一个问题，例如“2024年诺贝尔物理学奖得主是谁？”</li>
<li><strong>检索 (Retrieve):</strong>  系统首先将查询“编码”成向量，然后在一个庞大的、实时更新的“知识库”（通常是向量数据库，包含了最新新闻、文档、网页等）中搜索最相关的信息片段。</li>
<li><strong>增强 (Augment):</strong>  系统将检索到的相关资料（例如，关于诺奖得主的最新报道）与用户的原始问题“拼接”在一起，形成一个内容丰富的“增强提示词”。</li>
<li><strong>生成 (Generate):</strong>  LLM 最终看到的不是一个它无法回答的“过时”问题，而是一个包含了答案的阅读理解题。它会基于检索到的“事实”材料，生成一个准确、时效性强的答案。</li>
</ol>
<p><strong>RAG 的核心价值在于：</strong></p>
<ul>
<li><strong>高事实性：</strong>  大幅减少幻觉，因为答案是基于检索到的具体文本生成的。</li>
<li><strong>时效性：</strong>  只需更新知识库（这比重新训练模型便宜得多），AI 就能“知道”最新信息。</li>
<li><strong>可解释性：</strong>  可以引用检索到的来源，让答案的“出处”透明可查。</li>
</ul>
<h2 data-id="heading-1">CAG (Context-Augmented Generation)</h2>
<p>RAG 极其强大，但它在本质上仍是一种“即时反应式”的检索。它擅长回答“是什么”类型的事实问题，但在处理需要深度理解、长期记忆或专业领域一致性的复杂对话时，就显得力不从心。</p>
<p>这就是 <strong>CAG（上下文增强生成）</strong>  登场的契机。CAG 不仅仅是“检索”，它追求的是“上下文的深度管理与维护”。如果说 RAG 是“事实检索器”，那么 CAG 的目标是成为“领域专家”。</p>
<p><strong>CAG 的核心区别在于：</strong></p>
<ol>
<li><strong>“领域记忆” (Domain Memory)：</strong>  这是 CAG 的核心。它超越了 RAG 的被动知识库，是一个<strong>主动的、有状态的记忆系统</strong>。这个“记忆”中不仅存储着事实知识，还包括：</li>
</ol>
<ul>
<li><strong>领域规则：</strong>  例如，医疗 AI 需要遵守的诊断逻辑，或金融 AI 必须遵循的合规条款。</li>
<li><strong>对话历史：</strong>  记住用户在三天前讨论过的话题，而不仅仅是上一句话。</li>
<li><strong>用户偏好：</strong>  知道用户的具体需求、风格偏好或个人背景。</li>
</ul>
<ol start="2">
<li><strong>“上下文对齐” (Context Alignment)：</strong>  CAG 不只是简单地“拼接”信息。它在生成答案前，会进行复杂的“对齐”工作，确保即将生成的回复，同时与<strong>外部知识（RAG 做的）、领域记忆、对话历史</strong>保持逻辑一致。</li>
<li><strong>“一致性检查” (Consistency Check)：</strong>  在生成答案后，CAG 会增加一个关键的验证层。它会反向检查答案是否与“领域记忆”中的核心规则或长期目标相矛盾。例如，一个法律 AI 助手在给出建议时，必须确保其建议始终符合它“记忆”中的法律框架。</li>
</ol>
<h2 data-id="heading-2">RAG vs. CAG</h2>
<p>我们可以将这两种架构视为AI智能的两个不同进化阶段：</p>



































<table><thead><tr><th>特性</th><th><strong>RAG (检索增强生成)</strong></th><th><strong>CAG (上下文增强生成)</strong></th></tr></thead><tbody><tr><td><strong>核心焦点</strong></td><td><strong>事实检索 (Fact Retrieval)</strong></td><td><strong>情境管理 (Context Management)</strong></td></tr><tr><td><strong>工作模式</strong></td><td>偏向<strong>无状态 (Stateless)</strong> （每次查询都像一次新的检索）</td><td>强调<strong>有状态 (Stateful)</strong> （维护和调用持久的记忆）</td></tr><tr><td><strong>知识源</strong></td><td>外部知识库（文档、网页等）</td><td>外部知识库 + <strong>领域记忆</strong> （规则、历史、偏好）</td></tr><tr><td><strong>关键动作</strong></td><td>检索 (Retrieve)、排序 (Rank)、融合 (Fuse)</td><td>注入 (Inject)、对齐 (Align)、一致性检查 (Consistency)</td></tr><tr><td><strong>目标角色</strong></td><td><strong>“开卷考试”的考生</strong> （能快速查到正确答案）</td><td><strong>“融会贯通”的专家</strong> （能结合记忆和知识给出一贯的见解）</td></tr></tbody></table>
<p>RAG 解决了 LLM“不知道”和“说错话”的问题，这是 AI 从“玩具”走向“工具”的关键一步。</p>
<p>而 <strong>CAG 则代表了 AI 从“工具”走向“伙伴”和“专家”的雄心</strong>。它追求的不再是“单点正确”，而是“全局一致”和“深度个性化”。</p>
<p>我们必须明白，<strong>CAG 并非要替代 RAG，而是 RAG 的必然演进和扩展</strong>。在先进的 CAG 框架中，RAG 往往会作为其“上下文注入”的一个关键组件，负责从外部世界获取实时事实。</p>
<p>未来的高级 AI 助手，必然是一个 RAG 和 CAG 的混合体：它既能像 RAG 一样博览群书、快速检索，也能像 CAG 一样拥有深刻的记忆和一致的“人格”，真正做到从“知道”走向“理解”。</p>
<h2 data-id="heading-3">学习资源推荐</h2>
<p>如果你想更深入地学习大模型，以下是一些非常有价值的学习资源，这些资源将帮助你从不同角度学习大模型，提升你的实践能力。</p>
<blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fhy.zhipoai.cn%2F" target="_blank" title="https://hy.zhipoai.cn/" ref="nofollow noopener noreferrer">智泊AI</a>。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2025最火的4个国产AI音乐工具全面评测，最后两个完全免费！（建议收藏）]]></title>    <link>https://juejin.cn/post/7570295366481313828</link>    <guid>https://juejin.cn/post/7570295366481313828</guid>    <pubDate>2025-11-10T08:11:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570295366481313828" data-draft-id="7570500819889487915" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2025最火的4个国产AI音乐工具全面评测，最后两个完全免费！（建议收藏）"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2025-11-10T08:11:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员X小鹿"/> <meta itemprop="url" content="https://juejin.cn/user/2928754709505608"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025最火的4个国产AI音乐工具全面评测，最后两个完全免费！（建议收藏）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2928754709505608/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员X小鹿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:11:44.000Z" title="Mon Nov 10 2025 08:11:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是X小鹿。</p>
<p>前几天，一位读者来问，<strong>有哪些 AI 音乐工具推荐，最好国内的</strong>。</p>
<p>我想起来之前正好整理过一篇 AI 音乐工具汇总的文章，可以直接发给他。</p>
<p>但看了下，发现有些已经下架找不到入口了，比如即梦AI、海螺AI，这些之前都是有「AI 音乐」功能的，但现在已经都没有了。</p>
<p>趁着周末，再整理下。</p>
<p><strong>下面分享 4 个目前用的较多的国产</strong> <strong>AI</strong> <strong>音乐生成工具，有电脑端的，也有手机端的，最后两个完全免费！</strong></p>
<p>有需要的可以保存下，早晚用的上～</p>
<h2 data-id="heading-0">一、Tunee</h2>
<p>这个 AI 工具还是之前被网友种草的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/030f5750ddff443dad4aa913e2e51419~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=ZFiKQbBc23Eu2CnKHoaqPx3mC2s%3D" alt="图片" loading="lazy"/></p>
<p><strong>Tunee，国内首个对话式音乐创作 Agent，由「国产 AI 音乐三巨头」之一的天谱乐团队孵化。</strong></p>
<p>简单描述想生成什么音乐，然后 Tunee 就会以对话的形式、一步步和我们沟通更详细的需求，最终创作出想要的音乐。</p>
<p>Tunee 还可以根据我们上传的文件（音频 / 视频 / 图片）来创作，也可以通过联网获取最新的资料来进行需求分析。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1101606b29e414c90ca341a21a613a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=I7%2BIHIEB61RBS7x6z6qlQXNAaVU%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8695003b81e44cc2ae18ea9687f65135~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=QK%2F62lH6IobxtCrhsDUJz1iNRMc%3D" alt="图片" loading="lazy"/></p>
<p>最终的创作结果以画布形式展示：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9199ce8221d40819559a17348f1aefd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=v%2BaTZ3AGXjHY80I9QwfeTdJJskM%3D" alt="图片" loading="lazy"/></p>
<p>下面这首音乐就是用 Tunee 生成的：</p>
<p>（音频不方便上传，试听见<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1x6gCYkWqc-XbWVjSIMPcw" target="_blank" title="https://mp.weixin.qq.com/s/1x6gCYkWqc-XbWVjSIMPcw" ref="nofollow noopener noreferrer">原文</a>）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e9e23e67fbb472ca04ea3217d60a042~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=ebRqsMT1CppjP9gvkQ7dmyBGSxc%3D" alt="截屏2025-11-10 16.07.30.png" loading="lazy"/></p>
<p>Tunee 还可以对生成好的音乐「一键制作 MV」。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf96221cd3874f98bca93756013f5ac5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=pTzJU5xkvNgVhfNNSh57jZzsTk0%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5fa3458be55e415ba365e35e0f291049~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=APh4Y6X%2Bn7aRT1ZnNgyd3iFP0UM%3D" alt="图片" loading="lazy"/></p>
<p>最近看 Tunee 又更新了，接入了 Sora 2 模型，MV 生成效果应该比之前更强了。有兴趣的可以尝试一下。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f636d96a6e744a98943211c571aa34a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=VfMOIYxAMsrEhk6ktkFTTskf2SQ%3D" alt="图片" loading="lazy"/></p>
<p>除了生成音乐、制作 MV，Tunee 还可以编辑歌词、分离音轨（拆分为人声、鼓、贝斯等音轨，便于二次编辑和混音）、智能母带处理等。</p>
<p>更详细的介绍，可以看之前写的这篇文章：</p>
<p><a href="https://juejin.cn/post/7554967090475532303" target="_blank" title="https://juejin.cn/post/7554967090475532303">国产AI又出王炸！拜拜Suno，这个国内首个对话式音乐创作Agent更好用！（附实测体验）</a></p>
<h2 data-id="heading-1">二、Mureka</h2>
<p>今年（2025） 3 月，昆仑万维发布了其 AI 音乐大模型——Mureka O1 和 Mureka V6。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b903d24bea14cc79c4977c7f84fabce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=eALwyZXyarkQLEMXSPmHYSAhuiM%3D" alt="图片" loading="lazy"/></p>
<p>Mureka O1，是全球首个采用 CoT 技术的音乐推理大模型。在推理过程中，加入了思考与自我批判，使得 Mureka 在音乐创作的品质、效率和灵活性等方面大幅提升。</p>
<p><strong>在当时官方公布的主客观测评中，Mureka O1 的多项指标已超越 Suno，实现全球领跑。</strong></p>
<p>随后又发布了 Mureka V7.5 模型，也是目前昆仑万维上线的最新的 AI 音乐大模型。<strong>中文演唱超越海外同类模型，并且支持中英日韩在内的 10 种语言。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bcc7dce55034762951cc69fb2856d5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=yL9rjOPQOsaTKoFej4MguWl47sc%3D" alt="图片" loading="lazy"/></p>
<p>Mureka 的歌曲创作有「简单模式」和「高级模式」。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db87d61d9692487ea3e0323a8cab9c94~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=9IdCRG0eYvpJoZnnUq79JkIAb54%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa5ca6ec6d91459490851c0c0bb7e732~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=jugwa5nixxLC76S03e%2BR2vMa3ZE%3D" alt="图片" loading="lazy"/></p>
<p><strong>简单模式</strong>：只需要输入主题或想法，Mureka 就开始创作了。</p>
<p><strong>高级模式：</strong> 支持自己输入标题和歌词，也可以让 Mureka 根据输入的标题来生成歌词。</p>
<p>而且还可以让 Mureka：</p>
<ul>
<li>参考上传的歌曲来创作相似的</li>
<li>用指定音色来唱</li>
<li>基于歌曲描述（指定曲风、情绪、人声性别、乐器等）来创作</li>
<li>基于哼唱旋律来创作</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3657ade891d343a8b2007b392ee2a0e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=yzLU%2B6KHqCBhZQNjq3YOh9T3HA8%3D" alt="图片" loading="lazy"/></p>
<p>不过这些高级功能，基本都需要开会员了，包括下面的「音频编辑」功能也是。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cce494832014b39bd87a2da8563c749~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=1alrJODC5rzDquApy3n5EOBp9FM%3D" alt="图片" loading="lazy"/></p>
<p>Mureka 的功能很强大，适合专业选手。</p>
<h2 data-id="heading-2">三、海绵音乐</h2>
<p>海绵音乐，是字节跳动旗下的一款 AI 音乐创作平台。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f5c8c77b49104bee9e44200254e8df59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=L1QvUeYUzHk7aiyw76Mmh6fD5Ug%3D" alt="图片" loading="lazy"/></p>
<p><strong>「灵感创作」模式</strong>：简单输入灵感就可以创作；</p>
<p><strong>「自定义写词」模式</strong>：支持填入自己写好的歌词（可以用 AI 润色），可以选择曲风、心情、音色、人声性别等。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c42b80d2368f46089c6dc2abbc4c5baf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=po%2FVeWbe4F0vPrJshtTe4yci4a0%3D" alt="图片" loading="lazy"/></p>
<p>生成好的歌曲，支持「改音色」和 「改歌词」。</p>
<p><strong>改音色</strong>：录制一段自己的声音后，可以用自己音色来唱这首歌。</p>
<p><strong>改歌词</strong>：能在保持旋律不变的情况下修改歌词。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/92916dab634f4538b8c9d29e0cf0fd73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=1B%2FEBpxOJJgMEDwn1KBC%2FOLLI7o%3D" alt="图片" loading="lazy"/></p>
<p>另外在「实验室」里，还有「<strong>AI</strong> <strong>仿写</strong>」的功能，可以参考原曲风，生成相似的歌曲：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd692c98cf104e96a0abc096e5216d9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=IurpzOx4uvs7XTJm08PDvElBaug%3D" alt="图片" loading="lazy"/></p>
<p>但目前只支持从已有的歌曲里选，不支持自己上传歌曲：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/420f12ab10744bedb1917af5f5ad3ada~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=%2FhQ79cevkOiF25S9GkCdsZ%2BYmyE%3D" alt="图片" loading="lazy"/></p>
<p>海绵音乐目前完全免费，同时支持电脑端和手机端（Android / iOS），也支持对生成的音乐再编辑。</p>
<h2 data-id="heading-3">四、豆包</h2>
<p>上面 3 个，都是专门的 AI 音乐工具。</p>
<p>那对于普通人，不需要那么专业的、简单一点的有没有？可以使用豆包。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21ad97b010fb4584a2fdd4210e27edad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=Jo5aO%2BsSIRN%2FbQwlwrT3X7UzCBw%3D" alt="图片" loading="lazy"/></p>
<p>进入豆包（豆包手机端或电脑端都可以），找到「音乐生成」。</p>
<p>只需要输入主题，然后依次选择风格、情绪、音色就可以了（蓝色字体部分）：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d95f588064b4f918bc50bbab689af7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGYWOWwj-m5vw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367103&amp;x-signature=Ur6ceoOwRINpL0FYTVUEhjzbiHk%3D" alt="图片" loading="lazy"/></p>
<p>豆包的 AI 音乐功能「完全免费」，但除了支持自定义歌词外，就没有其他更高级的功能了，不支持对生成的音乐再次编辑等，适合普通玩家。</p>
<h2 data-id="heading-4">五、写在最后</h2>
<p>最后来总结一下吧。</p>
<p>Tunee、Mureka、海绵音乐，是 3 款专门的 AI 音乐工具。</p>
<p>其中 Tunee 和 Mureka 目前功能更多一些，尤其是 Mureka，更适合专业玩家。</p>
<p>Tunee 和 Mureka 是付费工具，但 Tunee 每天都有一些免费额度可以体验。</p>
<p>海绵音乐和豆包都是字节旗下的，目前「完全免费」，而且电脑端、手机端都可以使用。</p>
<p>大家可以根据自己的情况，选择适合的 AI 音乐工具。</p>
<h2 data-id="heading-5">六、链接</h2>
<p>最后附上这些 AI 音乐工具的链接：</p>
<p><strong>Tunee</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.tunee.ai%2Fzh-CN%2F" target="_blank" title="https://www.tunee.ai/zh-CN/" ref="nofollow noopener noreferrer">www.tunee.ai/zh-CN/</a></p>
<p><strong>Mureka</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.mureka.cn%2F" target="_blank" title="https://www.mureka.cn/" ref="nofollow noopener noreferrer">www.mureka.cn/</a></p>
<p><strong>海绵音乐</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.haimian.com%2F" target="_blank" title="https://www.haimian.com/" ref="nofollow noopener noreferrer">www.haimian.com/</a></p>
<p><strong>豆包</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.doubao.com%2F" target="_blank" title="https://www.doubao.com/" ref="nofollow noopener noreferrer">www.doubao.com/</a></p>
<hr/>
<blockquote>
<p>我是<a href="https://juejin.cn/user/2928754709505608/posts" title="https://juejin.cn/user/2928754709505608/posts" target="_blank">程序员X小鹿</a>，前互联网大厂程序员，也是一名 AIGC 爱好者，持续分享更多好用的 AI 工具，欢迎一起交流~</p>
</blockquote>
<p><strong>推荐阅读</strong></p>
<p><a href="https://juejin.cn/post/7454501732203610131" title="https://juejin.cn/post/7454501732203610131" target="_blank">2024年终AI工具汇总：9大AI领域，70+精选AI工具，全都在这了！(建议收藏)</a></p>
<p>更多 AI 工具见<a href="https://juejin.cn/column/7284164153576947724" title="https://juejin.cn/column/7284164153576947724" target="_blank">【AI工具】</a>专栏，持续更新中。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[『OpenGL学习滤镜相机』- Day8: 多重纹理与混合]]></title>    <link>https://juejin.cn/post/7570534000718495807</link>    <guid>https://juejin.cn/post/7570534000718495807</guid>    <pubDate>2025-11-10T08:19:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570534000718495807" data-draft-id="7570534000718479423" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="『OpenGL学习滤镜相机』- Day8: 多重纹理与混合"/> <meta itemprop="keywords" content="Android,OpenGL"/> <meta itemprop="datePublished" content="2025-11-10T08:19:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下位子"/> <meta itemprop="url" content="https://juejin.cn/user/2313028193761389"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            『OpenGL学习滤镜相机』- Day8: 多重纹理与混合
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2313028193761389/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下位子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:19:05.000Z" title="Mon Nov 10 2025 08:19:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><a href="https://juejin.cn/post/7567889397497528383" target="_blank" title="https://juejin.cn/post/7567889397497528383">前言: 『OpenGL学习』 从零打造 Android 滤镜相机</a></p>
<p><a href="https://juejin.cn/post/7569871848793948179" target="_blank" title="https://juejin.cn/post/7569871848793948179">上一篇:『OpenGL学习滤镜相机』- Day7: FBO（帧缓冲对象）</a></p>
<p>Github: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxiaweizi%2FOpenGLTest" target="_blank" title="https://github.com/xiaweizi/OpenGLTest" ref="nofollow noopener noreferrer">OpenGLTest</a></p>
</blockquote>
<h2 data-id="heading-0">📚 今日目标</h2>
<ul>
<li>理解多纹理单元的概念和使用</li>
<li>掌握纹理混合模式（Blend Modes）</li>
<li>学习 Alpha 通道处理和透明度</li>
<li>实现图片水印、纹理叠加等实用效果</li>
</ul>
<p><strong>运行效果：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d0fe85223524f6d85e34d84847cfa31~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiL5L2N5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367544&amp;x-signature=NEY23PHhtHVaLDDj%2FvZ28hR8j1M%3D" alt="Day8.gif" loading="lazy"/></p>
<h2 data-id="heading-1">🎯 学习内容</h2>
<h3 data-id="heading-2">1. 多纹理单元简介</h3>
<p>在 OpenGL ES 中，<strong>纹理单元（Texture Unit）</strong> 允许我们在一次绘制调用中使用多个纹理。</p>
<h4 data-id="heading-3">什么是纹理单元？</h4>
<p>纹理单元是 OpenGL 中的"纹理槽位"，每个槽位可以绑定一个纹理对象。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">GPU</span> <span class="hljs-string">纹理单元</span>
<span class="hljs-string">├──</span> <span class="hljs-string">GL_TEXTURE0</span> <span class="hljs-string">→</span> <span class="hljs-string">纹理</span> <span class="hljs-attr">ID:</span> <span class="hljs-number">123</span><span class="hljs-string">（底图）</span>
<span class="hljs-string">├──</span> <span class="hljs-string">GL_TEXTURE1</span> <span class="hljs-string">→</span> <span class="hljs-string">纹理</span> <span class="hljs-attr">ID:</span> <span class="hljs-number">456</span><span class="hljs-string">（水印）</span>
<span class="hljs-string">├──</span> <span class="hljs-string">GL_TEXTURE2</span> <span class="hljs-string">→</span> <span class="hljs-string">纹理</span> <span class="hljs-attr">ID:</span> <span class="hljs-number">789</span><span class="hljs-string">（遮罩）</span>
<span class="hljs-string">├──</span> <span class="hljs-string">...</span>
<span class="hljs-string">└──</span> <span class="hljs-string">GL_TEXTURE31（OpenGL</span> <span class="hljs-string">ES</span> <span class="hljs-string">至少支持</span> <span class="hljs-number">8</span> <span class="hljs-string">个，通常支持</span> <span class="hljs-number">16</span><span class="hljs-number">-32</span> <span class="hljs-string">个）</span>
</code></pre>
<h4 data-id="heading-4">为什么需要多纹理？</h4>





























<table><thead><tr><th>应用场景</th><th>说明</th></tr></thead><tbody><tr><td><strong>水印效果</strong></td><td>底图 + 水印图</td></tr><tr><td><strong>遮罩效果</strong></td><td>原图 + 遮罩图</td></tr><tr><td><strong>光照贴图</strong></td><td>颜色纹理 + 法线贴图 + 光照贴图</td></tr><tr><td><strong>视频特效</strong></td><td>视频帧 + 滤镜纹理（LUT）</td></tr><tr><td><strong>粒子效果</strong></td><td>粒子纹理 + 渐变纹理</td></tr></tbody></table>
<h3 data-id="heading-5">2. 多纹理的使用流程</h3>
<h4 data-id="heading-6">2.1 激活纹理单元</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 激活纹理单元 0</span>
GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
<span class="hljs-comment">// 绑定第一个纹理</span>
GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture1)

<span class="hljs-comment">// 激活纹理单元 1</span>
GLES20.glActiveTexture(GLES20.GL_TEXTURE1)
<span class="hljs-comment">// 绑定第二个纹理</span>
GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture2)
</code></pre>
<h4 data-id="heading-7">2.2 传递给着色器</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 将纹理单元索引传递给着色器的 sampler2D</span>
GLES20.glUniform1i(texture1Location, <span class="hljs-number">0</span>)  <span class="hljs-comment">// 使用 GL_TEXTURE0</span>
GLES20.glUniform1i(texture2Location, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 使用 GL_TEXTURE1</span>
</code></pre>
<h4 data-id="heading-8">2.3 着色器中采样</h4>
<pre><code class="hljs language-glsl" lang="glsl">precision mediump float;

uniform sampler2D uTexture1;  // 底图
uniform sampler2D uTexture2;  // 水印

varying vec2 vTexCoord;

void main() {
    vec4 color1 = texture2D(uTexture1, vTexCoord);  // 采样底图
    vec4 color2 = texture2D(uTexture2, vTexCoord);  // 采样水印
    
    // 混合两个纹理
    gl_FragColor = mix(color1, color2, color2.a);
}
</code></pre>
<h3 data-id="heading-9">3. 纹理混合模式</h3>
<h4 data-id="heading-10">3.1 常见混合算法</h4>








































<table><thead><tr><th>混合模式</th><th>公式</th><th>效果</th></tr></thead><tbody><tr><td><strong>正常（Normal）</strong></td><td><code>color2</code></td><td>完全覆盖</td></tr><tr><td><strong>Alpha 混合</strong></td><td><code>mix(color1, color2, alpha)</code></td><td>透明叠加</td></tr><tr><td><strong>相加（Add）</strong></td><td><code>color1 + color2</code></td><td>增亮效果</td></tr><tr><td><strong>相乘（Multiply）</strong></td><td><code>color1 * color2</code></td><td>变暗效果</td></tr><tr><td><strong>屏幕（Screen）</strong></td><td><code>1.0 - (1.0 - color1) * (1.0 - color2)</code></td><td>柔光增亮</td></tr><tr><td><strong>叠加（Overlay）</strong></td><td>根据亮度混合相乘和屏幕模式</td><td>保留高光和阴影</td></tr></tbody></table>
<h4 data-id="heading-11">3.2 着色器实现</h4>
<pre><code class="hljs language-glsl" lang="glsl">precision mediump float;

uniform sampler2D uTexture1;  // 底图
uniform sampler2D uTexture2;  // 叠加图
uniform int uBlendMode;       // 混合模式（0-5）
uniform float uAlpha;         // 透明度（0.0 - 1.0）

varying vec2 vTexCoord;

// 正常混合
vec3 blendNormal(vec3 base, vec3 blend) {
    return blend;
}

// 相加混合
vec3 blendAdd(vec3 base, vec3 blend) {
    return min(base + blend, vec3(1.0));
}

// 相乘混合
vec3 blendMultiply(vec3 base, vec3 blend) {
    return base * blend;
}

// 屏幕混合
vec3 blendScreen(vec3 base, vec3 blend) {
    return 1.0 - (1.0 - base) * (1.0 - blend);
}

// 叠加混合
vec3 blendOverlay(vec3 base, vec3 blend) {
    vec3 result;
    result.r = base.r &lt; 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r));
    result.g = base.g &lt; 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g));
    result.b = base.b &lt; 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b));
    return result;
}

// 柔光混合
vec3 blendSoftLight(vec3 base, vec3 blend) {
    vec3 result;
    result.r = blend.r &lt; 0.5 ? (2.0 * base.r * blend.r + base.r * base.r * (1.0 - 2.0 * blend.r)) 
                              : (sqrt(base.r) * (2.0 * blend.r - 1.0) + 2.0 * base.r * (1.0 - blend.r));
    result.g = blend.g &lt; 0.5 ? (2.0 * base.g * blend.g + base.g * base.g * (1.0 - 2.0 * blend.g)) 
                              : (sqrt(base.g) * (2.0 * blend.g - 1.0) + 2.0 * base.g * (1.0 - blend.g));
    result.b = blend.b &lt; 0.5 ? (2.0 * base.b * blend.b + base.b * base.b * (1.0 - 2.0 * blend.b)) 
                              : (sqrt(base.b) * (2.0 * blend.b - 1.0) + 2.0 * base.b * (1.0 - blend.b));
    return result;
}

void main() {
    vec4 base = texture2D(uTexture1, vTexCoord);
    vec4 blend = texture2D(uTexture2, vTexCoord);
    
    vec3 result;
    
    if (uBlendMode == 0) {
        // 正常混合（Alpha 混合）
        result = mix(base.rgb, blend.rgb, blend.a * uAlpha);
    } else if (uBlendMode == 1) {
        // 相加
        result = blendAdd(base.rgb, blend.rgb * uAlpha);
    } else if (uBlendMode == 2) {
        // 相乘
        result = mix(base.rgb, blendMultiply(base.rgb, blend.rgb), uAlpha);
    } else if (uBlendMode == 3) {
        // 屏幕
        result = mix(base.rgb, blendScreen(base.rgb, blend.rgb), uAlpha);
    } else if (uBlendMode == 4) {
        // 叠加
        result = mix(base.rgb, blendOverlay(base.rgb, blend.rgb), uAlpha);
    } else if (uBlendMode == 5) {
        // 柔光
        result = mix(base.rgb, blendSoftLight(base.rgb, blend.rgb), uAlpha);
    } else {
        result = base.rgb;
    }
    
    gl_FragColor = vec4(result, 1.0);
}
</code></pre>
<h3 data-id="heading-12">4. Alpha 通道处理</h3>
<h4 data-id="heading-13">4.1 什么是 Alpha 通道？</h4>
<p><strong>Alpha 通道</strong>表示像素的不透明度：</p>
<ul>
<li><code>alpha = 0.0</code>：完全透明</li>
<li><code>alpha = 0.5</code>：半透明</li>
<li><code>alpha = 1.0</code>：完全不透明</li>
</ul>
<h4 data-id="heading-14">4.2 启用 Alpha 混合</h4>
<p>OpenGL 提供了硬件级别的 Alpha 混合：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 启用混合</span>
GLES20.glEnable(GLES20.GL_BLEND)

<span class="hljs-comment">// 设置混合函数</span>
GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA)
</code></pre>
<p><strong>混合公式</strong>：</p>
<pre><code class="hljs language-css" lang="css">最终颜色 = 源颜色 × 源因子 + 目标颜色 × 目标因子
       = <span class="hljs-attribute">src</span><span class="hljs-selector-class">.rgb</span> × <span class="hljs-attribute">src</span><span class="hljs-selector-class">.a</span> + dst<span class="hljs-selector-class">.rgb</span> × (<span class="hljs-number">1.0</span> - <span class="hljs-attribute">src</span><span class="hljs-selector-class">.a</span>)
</code></pre>
<h4 data-id="heading-15">4.3 常见混合函数</h4>






























<table><thead><tr><th>源因子</th><th>目标因子</th><th>效果</th></tr></thead><tbody><tr><td><code>GL_SRC_ALPHA</code></td><td><code>GL_ONE_MINUS_SRC_ALPHA</code></td><td>标准 Alpha 混合（透明叠加）</td></tr><tr><td><code>GL_ONE</code></td><td><code>GL_ONE</code></td><td>相加混合（增亮）</td></tr><tr><td><code>GL_DST_COLOR</code></td><td><code>GL_ZERO</code></td><td>相乘混合（变暗）</td></tr><tr><td><code>GL_ONE</code></td><td><code>GL_ONE_MINUS_SRC_ALPHA</code></td><td>预乘 Alpha 混合</td></tr></tbody></table>
<h3 data-id="heading-16">5. 实用效果实现</h3>
<h4 data-id="heading-17">5.1 水印效果</h4>
<pre><code class="hljs language-glsl" lang="glsl">// 水印着色器
precision mediump float;

uniform sampler2D uTexture;    // 底图
uniform sampler2D uWatermark;  // 水印
uniform vec2 uWatermarkPos;    // 水印位置（0.0 - 1.0）
uniform vec2 uWatermarkSize;   // 水印大小（0.0 - 1.0）
uniform float uWatermarkAlpha; // 水印透明度

varying vec2 vTexCoord;

void main() {
    vec4 baseColor = texture2D(uTexture, vTexCoord);
    
    // 计算水印区域
    vec2 watermarkCoord = (vTexCoord - uWatermarkPos) / uWatermarkSize;
    
    // 判断是否在水印区域
    if (watermarkCoord.x &gt;= 0.0 &amp;&amp; watermarkCoord.x &lt;= 1.0 &amp;&amp;
        watermarkCoord.y &gt;= 0.0 &amp;&amp; watermarkCoord.y &lt;= 1.0) {
        
        vec4 watermarkColor = texture2D(uWatermark, watermarkCoord);
        
        // Alpha 混合水印
        gl_FragColor = mix(baseColor, watermarkColor, watermarkColor.a * uWatermarkAlpha);
    } else {
        gl_FragColor = baseColor;
    }
}
</code></pre>
<h4 data-id="heading-18">5.2 双重曝光效果</h4>
<pre><code class="hljs language-glsl" lang="glsl">precision mediump float;

uniform sampler2D uTexture1;
uniform sampler2D uTexture2;
uniform float uMixRatio;  // 混合比例

varying vec2 vTexCoord;

void main() {
    vec4 color1 = texture2D(uTexture1, vTexCoord);
    vec4 color2 = texture2D(uTexture2, vTexCoord);
    
    // 屏幕混合模式（双重曝光常用）
    vec3 result = 1.0 - (1.0 - color1.rgb) * (1.0 - color2.rgb * uMixRatio);
    
    gl_FragColor = vec4(result, 1.0);
}
</code></pre>
<h4 data-id="heading-19">5.3 遮罩效果</h4>
<pre><code class="hljs language-glsl" lang="glsl">precision mediump float;

uniform sampler2D uTexture;  // 原图
uniform sampler2D uMask;     // 遮罩（黑白图）

varying vec2 vTexCoord;

void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec4 mask = texture2D(uMask, vTexCoord);
    
    // 使用遮罩的亮度作为 Alpha
    float maskAlpha = dot(mask.rgb, vec3(0.299, 0.587, 0.114));
    
    gl_FragColor = vec4(color.rgb, color.a * maskAlpha);
}
</code></pre>
<h3 data-id="heading-20">6. 性能优化</h3>
<h4 data-id="heading-21">6.1 纹理单元管理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextureManager</span> {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TEXTURE_UNIT_BASE = <span class="hljs-number">0</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TEXTURE_UNIT_BLEND = <span class="hljs-number">1</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TEXTURE_UNIT_WATERMARK = <span class="hljs-number">2</span>
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bindTextures</span><span class="hljs-params">(baseTexture: <span class="hljs-type">Int</span>, blendTexture: <span class="hljs-type">Int</span>, watermarkTexture: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 底图</span>
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + TEXTURE_UNIT_BASE)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, baseTexture)
        
        <span class="hljs-comment">// 混合图</span>
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + TEXTURE_UNIT_BLEND)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, blendTexture)
        
        <span class="hljs-comment">// 水印</span>
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + TEXTURE_UNIT_WATERMARK)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, watermarkTexture)
    }
}
</code></pre>
<h4 data-id="heading-22">6.2 减少纹理切换</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 不好的做法：频繁切换纹理单元</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">renderObjects</span><span class="hljs-params">(objects: <span class="hljs-type">List</span>&lt;<span class="hljs-type">RenderObject</span>&gt;)</span></span> {
    objects.forEach { obj -&gt;
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, obj.texture)
        obj.draw()
    }
}

<span class="hljs-comment">// ✅ 好的做法：批量渲染相同纹理的对象</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">renderObjectsBatched</span><span class="hljs-params">(objects: <span class="hljs-type">List</span>&lt;<span class="hljs-type">RenderObject</span>&gt;)</span></span> {
    <span class="hljs-keyword">val</span> grouped = objects.groupBy { it.texture }
    grouped.forEach { (texture, objs) -&gt;
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture)
        objs.forEach { it.draw() }
    }
}
</code></pre>
<h4 data-id="heading-23">6.3 纹理压缩</h4>
<p>对于水印等辅助纹理，可以使用较低分辨率或压缩格式：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 调整水印尺寸</span>
<span class="hljs-keyword">val</span> watermarkSize = <span class="hljs-number">256</span>  <span class="hljs-comment">// 不需要很高分辨率</span>
<span class="hljs-keyword">val</span> scaledWatermark = Bitmap.createScaledBitmap(
    originalWatermark, 
    watermarkSize, 
    watermarkSize, 
    <span class="hljs-literal">true</span>
)
</code></pre>
<h3 data-id="heading-24">7. 多纹理的限制</h3>
<h4 data-id="heading-25">7.1 查询纹理单元数量</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> maxTextureUnits = IntArray(<span class="hljs-number">1</span>)
GLES20.glGetIntegerv(GLES20.GL_MAX_TEXTURE_IMAGE_UNITS, maxTextureUnits, <span class="hljs-number">0</span>)
Log.d(TAG, <span class="hljs-string">"设备支持的最大纹理单元数: <span class="hljs-subst">${maxTextureUnits[<span class="hljs-number">0</span>]}</span>"</span>)
</code></pre>
<p>OpenGL ES 2.0 规范要求至少支持 8 个纹理单元，大多数设备支持 16-32 个。</p>
<h4 data-id="heading-26">7.2 纹理内存管理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 监控纹理内存使用</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">estimateTextureMemory</span><span class="hljs-params">(width: <span class="hljs-type">Int</span>, height: <span class="hljs-type">Int</span>, format: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">val</span> bytesPerPixel = <span class="hljs-keyword">when</span> (format) {
        GLES20.GL_RGBA -&gt; <span class="hljs-number">4</span>
        GLES20.GL_RGB -&gt; <span class="hljs-number">3</span>
        GLES20.GL_LUMINANCE_ALPHA -&gt; <span class="hljs-number">2</span>
        GLES20.GL_LUMINANCE -&gt; <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">4</span>
    }
    <span class="hljs-keyword">return</span> width * height * bytesPerPixel
}

<span class="hljs-comment">// 示例：1920x1080 RGBA 纹理 = 8.3 MB</span>
<span class="hljs-keyword">val</span> memory = estimateTextureMemory(<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, GLES20.GL_RGBA)
Log.d(TAG, <span class="hljs-string">"纹理内存占用: <span class="hljs-subst">${memory / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>}</span> MB"</span>)
</code></pre>
<h2 data-id="heading-27">💻 代码实践</h2>
<h3 data-id="heading-28">今日任务</h3>
<p>实现一个多纹理混合应用：</p>
<ol>
<li><strong>加载两张图片</strong></li>
<li><strong>实现多种混合模式</strong>：
<ul>
<li>Alpha 混合</li>
<li>相加</li>
<li>相乘</li>
<li>屏幕</li>
<li>叠加</li>
<li>柔光</li>
</ul>
</li>
<li><strong>添加水印功能</strong></li>
<li><strong>提供透明度调节</strong></li>
</ol>
<h3 data-id="heading-29">实现效果</h3>
<ul>
<li>🖼️ 同时加载两张纹理</li>
<li>🎨 6 种混合模式实时切换</li>
<li>💧 透明度 SeekBar 调节</li>
<li>🏷️ 水印位置和透明度控制</li>
</ul>
<h3 data-id="heading-30">核心代码结构</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Day08Renderer</span>(context: Context) : GLSurfaceView.Renderer {

    <span class="hljs-comment">// 多纹理 ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> texture1: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>  <span class="hljs-comment">// 底图</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> texture2: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>  <span class="hljs-comment">// 叠加图</span>

    <span class="hljs-comment">// 混合模式</span>
    <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlendMode</span> {
        ALPHA,      <span class="hljs-comment">// Alpha 混合</span>
        ADD,        <span class="hljs-comment">// 相加</span>
        MULTIPLY,   <span class="hljs-comment">// 相乘</span>
        SCREEN,     <span class="hljs-comment">// 屏幕</span>
        OVERLAY,    <span class="hljs-comment">// 叠加</span>
        SOFT_LIGHT  <span class="hljs-comment">// 柔光</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> currentBlendMode = BlendMode.ALPHA
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> blendAlpha = <span class="hljs-number">0.5f</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDrawFrame</span><span class="hljs-params">(gl: <span class="hljs-type">GL10</span>?)</span></span> {
        <span class="hljs-comment">// 激活纹理单元 0</span>
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture1)
        GLES20.glUniform1i(texture1Location, <span class="hljs-number">0</span>)

        <span class="hljs-comment">// 激活纹理单元 1</span>
        GLES20.glActiveTexture(GLES20.GL_TEXTURE1)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture2)
        GLES20.glUniform1i(texture2Location, <span class="hljs-number">1</span>)

        <span class="hljs-comment">// 设置混合模式</span>
        GLES20.glUniform1i(blendModeLocation, currentBlendMode.ordinal)
        GLES20.glUniform1f(alphaLocation, blendAlpha)

        <span class="hljs-comment">// 绘制</span>
        drawQuad()
    }
}
</code></pre>
<h2 data-id="heading-31">🧪 练习任务</h2>
<h3 data-id="heading-32">基础任务</h3>
<ol>
<li>✅ 实现两个纹理的加载和绑定</li>
<li>✅ 实现至少 3 种混合模式</li>
<li>✅ 添加透明度调节功能</li>
</ol>
<h3 data-id="heading-33">进阶任务</h3>
<ol>
<li>🎨 实现水印功能（可调节位置和大小）</li>
<li>🖼️ 实现遮罩效果</li>
<li>🌈 实现双重曝光效果</li>
<li>📸 添加预设混合效果（复古、电影、梦幻等）</li>
</ol>
<h3 data-id="heading-34">挑战任务</h3>
<ol>
<li>🚀 实现三个纹理的混合（底图 + 叠加图 + 水印）</li>
<li>🎭 实现动态混合（混合比例随时间变化）</li>
<li>🎬 实现分区域混合（不同区域不同混合模式）</li>
<li>💾 保存混合后的图片到相册</li>
</ol>
<h2 data-id="heading-35">📖 知识点总结</h2>
<h3 data-id="heading-36">纹理单元 vs 纹理对象</h3>






























<table><thead><tr><th>特性</th><th>纹理单元</th><th>纹理对象</th></tr></thead><tbody><tr><td><strong>概念</strong></td><td>GPU 的"纹理槽位"</td><td>实际的纹理数据</td></tr><tr><td><strong>数量</strong></td><td>有限（通常 8-32 个）</td><td>可以创建很多</td></tr><tr><td><strong>操作</strong></td><td><code>glActiveTexture()</code></td><td><code>glBindTexture()</code></td></tr><tr><td><strong>类比</strong></td><td>USB 接口</td><td>U 盘</td></tr></tbody></table>
<h3 data-id="heading-37">混合模式对比</h3>








































<table><thead><tr><th>模式</th><th>视觉效果</th><th>常用场景</th></tr></thead><tbody><tr><td><strong>Alpha</strong></td><td>透明叠加</td><td>水印、UI 叠加</td></tr><tr><td><strong>Add</strong></td><td>增亮、发光</td><td>光效、粒子</td></tr><tr><td><strong>Multiply</strong></td><td>变暗、阴影</td><td>阴影、色彩校正</td></tr><tr><td><strong>Screen</strong></td><td>柔和增亮</td><td>柔光、氛围</td></tr><tr><td><strong>Overlay</strong></td><td>对比增强</td><td>照片滤镜</td></tr><tr><td><strong>Soft Light</strong></td><td>柔和混合</td><td>肖像美化</td></tr></tbody></table>
<h3 data-id="heading-38">最佳实践</h3>
<ol>
<li>✅ <strong>复用纹理单元</strong>：不要每帧都重新激活和绑定</li>
<li>✅ <strong>批量渲染</strong>：相同纹理的对象一起渲染</li>
<li>✅ <strong>纹理压缩</strong>：对辅助纹理使用较低分辨率</li>
<li>✅ <strong>及时释放</strong>：不再使用的纹理要删除</li>
<li>✅ <strong>检查限制</strong>：查询设备支持的最大纹理单元数</li>
</ol>
<h2 data-id="heading-39">🐛 常见问题</h2>
<h3 data-id="heading-40">Q1: 纹理显示是黑色的？</h3>
<p><strong>可能原因</strong>：</p>
<ol>
<li>纹理单元索引错误</li>
<li><code>glUniform1i</code> 传递的值不对应激活的纹理单元</li>
</ol>
<p><strong>解决方法</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 纹理单元 0</span>
GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture1)
GLES20.glUniform1i(texture1Location, <span class="hljs-number">0</span>)  <span class="hljs-comment">// 传递 0，不是 GL_TEXTURE0</span>

<span class="hljs-comment">// 纹理单元 1</span>
GLES20.glActiveTexture(GLES20.GL_TEXTURE1)
GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture2)
GLES20.glUniform1i(texture2Location, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 传递 1，不是 GL_TEXTURE1</span>
</code></pre>
<h3 data-id="heading-41">Q2: 混合效果不正确？</h3>
<p>检查是否启用了 OpenGL 混合：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 如果使用硬件混合</span>
GLES20.glEnable(GLES20.GL_BLEND)
GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA)

<span class="hljs-comment">// 如果使用着色器混合</span>
<span class="hljs-comment">// 不需要启用 glBlend，直接在片段着色器中计算即可</span>
</code></pre>
<h3 data-id="heading-42">Q3: 水印位置不对？</h3>
<p>OpenGL 坐标系原点在左下角，而 UI 坐标系在左上角：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// UI 坐标（左上角为原点）</span>
<span class="hljs-keyword">val</span> uiY = <span class="hljs-number">100f</span>

<span class="hljs-comment">// 转换为 OpenGL 坐标（左下角为原点）</span>
<span class="hljs-keyword">val</span> glY = screenHeight - uiY - watermarkHeight
</code></pre>
<h3 data-id="heading-43">Q4: 如何实现圆形水印？</h3>
<p>在着色器中使用距离函数：</p>
<pre><code class="hljs language-glsl" lang="glsl">void main() {
    vec2 center = vec2(0.5, 0.5);
    float dist = distance(watermarkCoord, center);
    
    // 圆形遮罩
    float alpha = smoothstep(0.5, 0.48, dist);
    
    vec4 watermarkColor = texture2D(uWatermark, watermarkCoord);
    watermarkColor.a *= alpha;
    
    gl_FragColor = mix(baseColor, watermarkColor, watermarkColor.a);
}
</code></pre>
<h2 data-id="heading-44">🔗 参考资料</h2>
<h3 data-id="heading-45">官方文档</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.khronos.org%2Fopengl%2Fwiki%2FTexture" target="_blank" title="https://www.khronos.org/opengl/wiki/Texture" ref="nofollow noopener noreferrer">OpenGL ES Texture Units</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.khronos.org%2Fopengl%2Fwiki%2FSampler_(GLSL)" target="_blank" title="https://www.khronos.org/opengl/wiki/Sampler_(GLSL)" ref="nofollow noopener noreferrer">GLSL Sampler Types</a></li>
</ul>
<h3 data-id="heading-46">混合模式参考</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fphotoblogstop.com%2Fphotoshop%2Fphotoshop-blend-modes-explained" target="_blank" title="https://photoblogstop.com/photoshop/photoshop-blend-modes-explained" ref="nofollow noopener noreferrer">Photoshop Blend Modes</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamieowen%2Fglsl-blend" target="_blank" title="https://github.com/jamieowen/glsl-blend" ref="nofollow noopener noreferrer">WebGL Blend Modes</a></li>
</ul>
<h3 data-id="heading-47">推荐阅读</h3>
<ul>
<li>《Real-Time Rendering》- Chapter 5: Visual Appearance</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.nvidia.com%2Fgpugems%2Fgpugems3%2Fpart-iv-image-effects" target="_blank" title="https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects" ref="nofollow noopener noreferrer">GPU Gems - Image Processing</a></li>
</ul>
<h2 data-id="heading-48">📝 今日总结</h2>
<p>今天我们深入学习了多重纹理和混合技术：</p>
<ol>
<li>✅ 理解了纹理单元的概念：GPU 中的"纹理槽位"</li>
<li>✅ 掌握了多纹理的使用流程：激活 → 绑定 → 传递索引</li>
<li>✅ 学习了 6 种常用混合模式：Alpha、Add、Multiply、Screen、Overlay、Soft Light</li>
<li>✅ 实现了实用效果：水印、双重曝光、遮罩</li>
</ol>
<p><strong>关键要点</strong>：</p>
<ul>
<li>纹理单元允许我们在一次绘制中使用多个纹理</li>
<li><code>glActiveTexture()</code> 激活纹理单元，<code>glUniform1i()</code> 传递索引（不是 GL_TEXTURE 常量）</li>
<li>混合模式本质是不同的颜色计算公式</li>
<li>Alpha 通道是实现透明效果的关键</li>
</ul>
<p><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">下一篇</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ModelScope 模型一键上线？FunModel 帮你 5 分钟从零到生产]]></title>    <link>https://juejin.cn/post/7570651893870854196</link>    <guid>https://juejin.cn/post/7570651893870854196</guid>    <pubDate>2025-11-10T08:22:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570651893870854196" data-draft-id="7570866247979335732" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ModelScope 模型一键上线？FunModel 帮你 5 分钟从零到生产"/> <meta itemprop="keywords" content="Serverless"/> <meta itemprop="datePublished" content="2025-11-10T08:22:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ModelScope 模型一键上线？FunModel 帮你 5 分钟从零到生产
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:22:30.000Z" title="Mon Nov 10 2025 08:22:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：百潼</p>
<blockquote>
<p>下一个 AI 爆款应用，或许就从您点击“立即部署”的那一刻开始！</p>
</blockquote>
<h2 data-id="heading-0">前言：AI 浪潮下的模型诉求</h2>
<p>在当今这个全民 AI 的时代，快速入门 AI，赶上时代的浪潮，成为了大家当下最热切的追求和期盼。</p>
<p>于是，模型作为 AI 场景的载体，随着 AI 技术的不断发展，在持续的，如雨后春笋般出现在大家的视野中，可谓是种类繁杂，功能齐全，从不同方面满足大家对 AI 的需求。例如在 AI 聊天场景，就有很多大语言模型（LLM）可供选择；在文本转语音的场景，又有很多不同种类的 TTS 模型。AI 场景多变，人们也在不断探索以模型为载体的更多 AI 的可能。</p>
<p>ModelScope 作为国内 Top 的 AI 模型平台，收录承载了大量的模型，人们可以在 ModelScope 按需选择模型。此时，将模型快速调试应用，发布上线并运维，也成为了很多公司必不可少的探索方向。</p>
<h2 data-id="heading-1">痛点分析：传统模型集成方案已成 AI 革新拦路虎</h2>
<p>ModelScope 给 AI 开发者在模型层面上提供了非常大的便利，然而，真正将模型用起来，让模型具备企业级的生产能力，又是所有企业用户不得不面临的问题。对于很多开发者来说，有着不小的使用门槛。且模型迭代速度太快，如何能实时紧跟模型的热度是很多开发者亟待解决的问题。</p>
<p>试想一下：一个中小型公司希望在自己的平台集成 LLM 模型，却要面对 GPU 资源配置、工程化调试、镜像构建等一系列繁琐步骤，整个过程耗时 1 ～ 2 周！这对于急需快速响应市场的团队来说，简直是“致命伤”。更别提公司的非开发者，如果想要体验模型效果，却因为技术门槛望而却步，错失了宝贵的业务创新机会。</p>
<ul>
<li><strong>高使用门槛阻滞快速接入：</strong> 让模型具备基础工程能力并对外提供服务，需要经历一系列繁琐步骤：获取合适的 GPU 资源、投入大量时间进行开发调试、配置运行镜像、与现有业务系统适配。对于新入职的 AI 工程师而言，这些工作需与公司业务学习并行展开，而较高的技术门槛必然拉长前期准备周期，整个过程可能需要 1 ～ 2 周的时间周期。在紧凑的项目排期压力下，难以实现模型的迅速接入与上线。</li>
<li><strong>运维复杂性威胁服务稳定性：</strong> 模型上线后，突增的流量往往会暴露系统瓶颈。扩容过程链路冗长——需重新配置 GPU 资源、调整运行环境、部署新镜像——耗时巨大，难以应对流量洪峰，最终导致服务宕机。流量消退后，为控制高昂的 GPU 成本又不得不释放资源。如此循环往复，每次流量高峰都重复相同的扩容困境。</li>
<li><strong>迭代效率低下难跟技术潮流：</strong> 鉴于模型迭代速度加快，AI 工程师若欲及时升级至新版本模型，不仅需部署新模型，还需处理旧模型的流量平滑过渡，同时承受现有架构的沉重负担。这种低效的迭代机制，使团队难以实时跟进业界最新的模型方案。</li>
</ul>
<p>究其根本，可以将以上的三个痛点问题提炼为当前 AI 工程师普遍遇到的技术瓶颈：<strong>部署门槛高、环境配置复杂、企业化运维难！</strong></p>
<h2 data-id="heading-2">对新模型集成方案的期望</h2>
<p>行业期待的模型集成方案应该具备：</p>
<ul>
<li><strong>零代码部署：</strong> 告别繁琐的推理代码编写、Dockerfile 配置，只需简单填写配置，模型即刻上线。</li>
<li><strong>一键扩缩容：</strong> 借鉴 Serverless 理念，实现 GPU 资源的弹性伸缩，应对流量波动。</li>
<li><strong>全流程覆盖：</strong> 从开发调试到生产运维，一站式解决，让企业不仅“用得起”，更要“用得好”。</li>
<li><strong>快速迭代能力：</strong> 新模型上线无需重构架构，平滑过渡，紧跟技术潮流。</li>
</ul>
<h2 data-id="heading-3">模型集成新范式——FunModel</h2>
<p>面对以上 AI 开发中遇到的痛点以及开发者们对模型的持续探索和期待，阿里云 FunModel 带来了模型集成的新范式。FunModel 是阿里云云原生的模型服务平台，以阿里云函数计算 FC 为底座，依托天然的 Serverless + GPU 的基本能力，同时在业务层面无缝对接 ModelScope 官方模型平台，实现 0 代码一键部署，并能快速扩缩容。为企业极大程度上减少了部署和运维模型的时间和人力成本，让企业专注于 AI 业务的开发，也让模型企业化触手可及。</p>
<h3 data-id="heading-4">双渠道部署，灵活自由</h3>
<p>阿里云 FunModel 提供了两种部署渠道，兼容多种类模型，给用户提供了部署模型的自由度</p>
<p><strong>1. 无缝对接 ModelScope：</strong> 阿里云 FunModel 承载了 ModelScope 上大量的热门模型，能根据用户需求和热门模型趋势快速上架和迭代新的模型，满足用户需求。同时，也可以输入 ModelScope 上的模型 ID，即可立即部署。在 FunModel 上，还能快速体验 ModelScope 模型效果和了解模型详情，拥有从体验到部署的完整流程，为用户最大程度上带来便捷。</p>
<p><strong>2. 自定义部署：</strong> 阿里云 FunModel 不仅为用户提供模型集成能力，更为有模型开发需求的用户提供了专业的自定义模型部署能力**。用户可以上传自己训练好的工程镜像到 FunModel 平台，指定模型来源或存储路径，填写对应启动参数，就能部署模型到线上，具备企业级服务能力。</p>
<h3 data-id="heading-5">5 分钟极速上线</h3>
<p>阿里云 FunModel 极大程度上简化了模型的部署流程，用户不再需要担心“推理代码不会写”，“部署镜像太慢”，“启动参数填写错误”，“GPU 规格选不对”等问题。FunModel 平台已经提前包装了启动模型需要的所有参数和环境，<strong>只需填写模型名称，5 分钟即可完成企业级服务上线</strong>，<strong>效率提升数十倍</strong>。传统集成方案需要耗时数周，在 FunModel 这里压缩到了一杯咖啡的时间。</p>
<h3 data-id="heading-6">Serverless + GPU 帮助实现扩缩容</h3>
<p>依托阿里云函数计算，FunModel 实现 Serverless+GPU 新范式，提供：</p>
<ul>
<li><strong>定时伸缩 / CRON 表达式伸缩：</strong> 根据业务规律预设扩缩容时间。</li>
<li><strong>水位伸缩：</strong> 基于 CPU/GPU 使用率自动调整资源。</li>
</ul>
<p>两种种策略灵活组合，精准匹配业务流量，极大程度上提高 GPU 利用率，从而节约昂贵的 GPU 费用成本。</p>
<h2 data-id="heading-7">实战指南：快速部署 ModelScope 模型</h2>
<h3 data-id="heading-8">环境准备与权限配置</h3>
<p>在使用 FunModel 平台前，需要完成必要的云资源准备工作：</p>
<p><strong>1. 阿里云账号准备</strong></p>
<p>确保拥有有效的阿里云账号，并完成实名认证。</p>
<p><strong>2. FunModel 控制台访问</strong></p>
<p>访问 FunModel 控制台 <strong>[</strong> <strong>1]</strong> ，这是阿里云 Serverless AI 模型服务的统一入口。</p>
<p><strong>3. RAM 角色授权</strong></p>
<p>根据控制台指引完成 RAM（Resource Access Management）角色授权配置。这个步骤至关重要，它确保 DevPod 能够访问必要的云资源。</p>
<blockquote>
<p><strong>重要提示</strong>：如果您当前使用的是旧版控制台界面，请务必点击右上角的“新版控制台”按钮切换至最新界面，以确保功能完整性。</p>
</blockquote>
<h3 data-id="heading-9">三步极速部署</h3>
<p><strong>步骤一</strong>：登录 FunModel 控制台，进入【模型市场】。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2370d0d1b6344e498d59ad682c31b71~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=dCRJ02iTt7VqjrfEGmjRjZjKE%2Bc%3D" alt="图片" loading="lazy"/></p>
<p><strong>步骤二</strong>：在左侧页签可以选择不同的模型分类，选择模型卡片，可以在右边查看模型详情，并快速体验模型效果。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74c02c7c06fa4157a5fd5bc6d98f4386~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=BourVRrfYyeUkAy7rb5%2FQgylXI4%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a5cacb8eb1248e6834d31a8f8c1621b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=UL38G5J3aeh%2BxPN%2B0pAVeK0BJvQ%3D" alt="图片" loading="lazy"/></p>
<p><strong>步骤三</strong>：点击“立即部署”，填写模型名称（建议包含业务含义，如“ocr-v1”），确认资源配置（系统会根据模型类型智能推荐），点击确认。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/54717568dc484891911c5e0290bb9561~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=%2BKFRNbBMdwLItBaKDvWyZmKLURk%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83ece083a8b94d32b67f4c8889a12927~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=ax2ufmWIqHFqFSTP6dMw5fcdmaQ%3D" alt="图片" loading="lazy"/></p>
<p>等待几分钟即可完成部署。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a12f3c198574f10b42fe7470f1f3291~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=NZB%2Bv1Vq%2BMwPwncqxA93Skwdjug%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f142ebacb7534eef90a8a6699c9619fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=fmYK87uzQh8An%2FCUoLUbM2lUbuU%3D" alt="图片" loading="lazy"/></p>
<blockquote>
<p>如果有更多需求，可以在【更多配置】中自定义配置阿里云存储 Nas，模型执行的超时时间等参数。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/62f6b0d0af55430ba4ea96d097c62e5b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=Xe29oeFzTE7k7FbD4COleCfE2AY%3D" alt="图片" loading="lazy"/></p>
</blockquote>
<h3 data-id="heading-10">高级玩法</h3>
<p><strong>模型在线调试：</strong> 部署完成后，切换到“在线调试”页签，填写对应的 API-Key（如果有），点击发送请求，即可在页面右侧看到模型返回结果，同时支持修改请求参数，并保存到模型概览页的 OpenAPISchema 中。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db4efebd89974494a4836ffabd421050~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=jyZTwFzNi2Q7qB7wWqmz3TfZXiA%3D" alt="图片" loading="lazy"/></p>
<p><strong>API 文档导出：</strong> 一键生成 JSON/YAML 格式的 OpenAPI 文档。支持单独修改 Schema 并保存，让接口定义更精准。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd9a29844d6b403ebb15f5b1cabc523e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=Nu9fBgJOq8By4uYxReTa3iCMWns%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e1f2d397a974f2986bf09afc71cdd75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=%2BpvgO4vbDZPDdGa%2BYyXUSXNXFXU%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-11">输入模型 ID 部署模型</h3>
<blockquote>
<p>自定义模型部署功能允许用户部署自己的模型或使用预训练模型，支持多种部署方式以满足不同的业务需求。 更多有关使用 vLLM、SGLang 和自定义镜像等方式部署模型的详情见自定义部署模型 <strong>[</strong> <strong>2]</strong> 。</p>
</blockquote>
<p>选择【自定义开发】页签，【模型来源】选择【ModelScope 模型 ID】，填入模型 ID，以 iic/nlp_structbert_word-segmentation_chinese-base 为例，点击立即部署。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13055d5c9f1b4fca905dae00704ea167~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=KR9E4Dw%2Bx08UWexfWZHhtDAb3d4%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5f0ecc9607749a89e330c12402d5dc4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=8j6cwS83VqwMivG9nlgXrUZXb0g%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-12">总结</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d69afd6f95e74de6ae7e2985d92e17fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763367749&amp;x-signature=8j6eIpcZUE6WHOufT%2BLU7oWpLY8%3D" alt="图片" loading="lazy"/></p>
<p>FunModel 依托 Serverless + GPU，天然提供了简单，轻量，0 门槛的模型集成方案，给个人开发者良好的玩转模型的体验，也让企业级开发者快速高效的部署、运维和迭代模型。</p>
<p>在阿里云 FunModel 平台，开发者可以做到：</p>
<ul>
<li><strong>模型的快速部署上线：</strong> 从原来的以周为单位的模型接入周期降低到 5 分钟，0 开发，无排期。</li>
<li><strong>一键扩缩容，让运维不再是负担：</strong> 多种扩缩容策略高度适配业务流量，实现“无痛运维”。</li>
</ul>
<p>在 AI 的时代浪潮下，模型作为 AI 的载体必然会不断迭代，开发者对模型部署的需求也会日益增多，FunModel 作为模型集成和部署的新范式，也会朝着“让人人成为开发者”的目标演进下去。</p>
<p><strong>更多内容请参考：</strong></p>
<p>FunModel快速入门</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Ffun-model-docs.devsapp.net%2Fgetting-started%2F" target="_blank" title="http://fun-model-docs.devsapp.net/getting-started/" ref="nofollow noopener noreferrer">fun-model-docs.devsapp.net/getting-sta…</a></p>
<p>FunModel 自定义部署</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Ffun-model-docs.devsapp.net%2Fuser-guide%2Fcustom-model-deployment%2F" target="_blank" title="http://fun-model-docs.devsapp.net/user-guide/custom-model-deployment/" ref="nofollow noopener noreferrer">fun-model-docs.devsapp.net/user-guide/…</a></p>
<p>modelscope魔搭平台</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.modelscope.cn%2F" target="_blank" title="https://www.modelscope.cn/" ref="nofollow noopener noreferrer">www.modelscope.cn/</a></p>
<p><strong>相关链接：</strong></p>
<p>[1] FunModel 控制台</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Ffunctionai.console.aliyun.com%2Fcn-hangzhou%2Ffun-model%2Fmodel-market" target="_blank" title="https://functionai.console.aliyun.com/cn-hangzhou/fun-model/model-market" ref="nofollow noopener noreferrer">functionai.console.aliyun.com/cn-hangzhou…</a></p>
<p>[2] 自定义部署模型</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Ffun-model-docs.devsapp.net%2Fuser-guide%2Fcustom-model-deployment%2F" target="_blank" title="http://fun-model-docs.devsapp.net/user-guide/custom-model-deployment/" ref="nofollow noopener noreferrer">fun-model-docs.devsapp.net/user-guide/…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[uniapp之WebView容器原理详解]]></title>    <link>https://juejin.cn/post/7570866247979728948</link>    <guid>https://juejin.cn/post/7570866247979728948</guid>    <pubDate>2025-11-10T08:30:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570866247979728948" data-draft-id="7570866247979712564" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="uniapp之WebView容器原理详解"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-10T08:30:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端一课"/> <meta itemprop="url" content="https://juejin.cn/user/1169536102963917"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            uniapp之WebView容器原理详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1169536102963917/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端一课
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:30:57.000Z" title="Mon Nov 10 2025 08:30:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style>
<h2 data-id="heading-0">UniApp WebView容器原理详解</h2>
<h3 data-id="heading-1">一、WebView容器概述</h3>
<p>UniApp之所以能够实现跨平台开发，其核心原理是"uniapp 主要是运行在webview容器中的"。这句话揭示了UniApp的底层架构：它本质上是一个基于WebView的混合应用框架。</p>
<h4 data-id="heading-2">1.1 什么是WebView容器</h4>
<p>WebView是一种系统组件，可以嵌入到原生应用中，用于显示网页内容。它本质上是一个迷你浏览器，提供了网页渲染、JavaScript执行环境以及与原生功能的桥接能力。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// WebView的基本结构（概念图）</span>
+---------------------------+
|      原生应用外壳         |
|  +---------------------+  |
|  |                     |  |
|  |    <span class="hljs-title class_">WebView</span>容器      |  |
|  |                     |  |
|  |  +---------------+  |  |
|  |  |   <span class="hljs-variable constant_">HTML</span>/<span class="hljs-variable constant_">CSS</span>/<span class="hljs-variable constant_">JS</span> |  |  |
|  |  +---------------+  |  |
|  |                     |  |
|  +---------------------+  |
|                           |
+---------------------------+
</code></pre>
<h4 data-id="heading-3">1.2 UniApp与WebView的关系</h4>
<p>UniApp利用WebView作为运行环境，将Vue代码编译成可在WebView中运行的HTML/CSS/JavaScript代码，然后通过原生外壳包装成跨平台应用。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// UniApp应用架构（概念图）</span>
+------------------------------------------------------+
|                  <span class="hljs-title class_">UniApp</span>应用                          |
|  +----------------+  +----------------+  +---------+ |
|  |   <span class="hljs-title class_">Android</span>外壳  |  |    iOS外壳     |  | <span class="hljs-variable constant_">H5</span>外壳  | |
|  |                |  |                |  |         | |
|  |  +----------+  |  |  +----------+  |  |  浏览器  | |
|  |  | <span class="hljs-title class_">WebView</span>  |  |  |  | <span class="hljs-title class_">WebView</span>  |  |  |         | |
|  |  +----------+  |  |  +----------+  |  |         | |
|  |       |         |  |       |         |  |         | |
|  |  +----------+  |  |  +----------+  |  |         | |
|  |  | <span class="hljs-title class_">UniApp</span>   |  |  |  | <span class="hljs-title class_">UniApp</span>   |  |  |  <span class="hljs-title class_">UniApp</span> | |
|  |  | 运行时   |  |  |  | 运行时   |  |  |  运行时 | |
|  |  +----------+  |  |  +----------+  |  |         | |
|  +----------------+  +----------------+  +---------+ |
+------------------------------------------------------+
</code></pre>
<h3 data-id="heading-4">二、WebView容器的工作原理</h3>
<h4 data-id="heading-5">2.1 渲染机制</h4>
<p>UniApp在WebView容器中的渲染过程如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// UniApp渲染流程（伪代码）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderUniApp</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 1. Vue模板编译</span>
  <span class="hljs-keyword">const</span> template = <span class="hljs-title function_">compileVueTemplate</span>();
  
  <span class="hljs-comment">// 2. 生成虚拟DOM</span>
  <span class="hljs-keyword">const</span> vdom = <span class="hljs-title function_">createVirtualDOM</span>(template);
  
  <span class="hljs-comment">// 3. 转换为真实DOM</span>
  <span class="hljs-keyword">const</span> dom = <span class="hljs-title function_">createRealDOM</span>(vdom);
  
  <span class="hljs-comment">// 4. WebView渲染DOM</span>
  webView.<span class="hljs-title function_">render</span>(dom);
  
  <span class="hljs-comment">// 5. 应用样式</span>
  <span class="hljs-title function_">applyCSSStyles</span>();
}
</code></pre>
<h4 data-id="heading-6">2.2 JavaScript执行环境</h4>
<p>UniApp的JavaScript代码在WebView的JavaScript引擎中执行，不同平台使用不同的引擎：</p>
<ul>
<li><strong>Android</strong>: 通常使用V8引擎</li>
<li><strong>iOS</strong>: 使用JavaScriptCore</li>
<li><strong>H5</strong>: 使用浏览器的JavaScript引擎</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// UniApp JavaScript执行环境（概念图）</span>
+---------------------------+
|      <span class="hljs-title class_">WebView</span>容器         |
|                           |
|  +---------------------+  |
|  |  <span class="hljs-title class_">JavaScript</span>引擎      |  |
|  |                     |  |
|  |  +-----------------+ |  |
|  |  |   <span class="hljs-title class_">UniApp</span>框架    | |  |
|  |  |                 | |  |
|  |  |  +-------------+ | |  |
|  |  |  |   <span class="hljs-title class_">Vue</span>代码   | | |  |
|  |  |  +-------------+ | |  |
|  |  |                 | |  |
|  |  |  +-------------+ | |  |
|  |  |  |   <span class="hljs-variable constant_">API</span>桥接   | | |  |
|  |  |  +-------------+ | |  |
|  |  +-----------------+ |  |
|  +---------------------+  |
+---------------------------+
</code></pre>
<h4 data-id="heading-7">2.3 原生能力桥接</h4>
<p>UniApp通过桥接机制实现JavaScript与原生功能的交互：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// UniApp原生桥接机制（简化版）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UniBridge</span> {
  <span class="hljs-comment">// 调用原生功能</span>
  <span class="hljs-title function_">callNative</span>(<span class="hljs-params">api, params, callback</span>) {
    <span class="hljs-comment">// 1. 将调用参数序列化</span>
    <span class="hljs-keyword">const</span> message = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">api</span>: api,
      <span class="hljs-attr">params</span>: params,
      <span class="hljs-attr">callbackId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateCallbackId</span>()
    });
    
    <span class="hljs-comment">// 2. 通过WebView接口发送消息到原生</span>
    <span class="hljs-keyword">if</span> (isAndroid) {
      androidInterface.<span class="hljs-title function_">postMessage</span>(message);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isIOS) {
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkit</span>.<span class="hljs-property">messageHandlers</span>.<span class="hljs-property">iosInterface</span>.<span class="hljs-title function_">postMessage</span>(message);
    }
    
    <span class="hljs-comment">// 3. 注册回调函数</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">registerCallback</span>(callbackId, callback);
  }
  
  <span class="hljs-comment">// 接收原生回调</span>
  <span class="hljs-title function_">onNativeCallback</span>(<span class="hljs-params">callbackId, result</span>) {
    <span class="hljs-keyword">const</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCallback</span>(callbackId);
    <span class="hljs-keyword">if</span> (callback) {
      <span class="hljs-title function_">callback</span>(result);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unregisterCallback</span>(callbackId);
    }
  }
}
</code></pre>
<h3 data-id="heading-8">三、WebView容器的优势</h3>
<h4 data-id="heading-9">3.1 跨平台能力</h4>
<p>WebView容器是所有现代移动操作系统都提供的标准组件，这使得UniApp能够实现真正的"一次开发，多端运行"。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 跨平台代码示例</span>
<span class="hljs-comment">// 这段代码可以在Android、iOS和H5环境中运行</span>
uni.<span class="hljs-title function_">showToast</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-string">'提示信息'</span>,
  <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>
});

<span class="hljs-comment">// UniApp编译后的代码（简化版）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">showToast</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-comment">// 根据平台调用不同的实现</span>
  <span class="hljs-keyword">if</span> (platform === <span class="hljs-string">'android'</span>) {
    <span class="hljs-comment">// 通过桥接调用Android原生Toast</span>
    <span class="hljs-title class_">UniBridge</span>.<span class="hljs-title function_">callNative</span>(<span class="hljs-string">'showToast'</span>, options);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (platform === <span class="hljs-string">'ios'</span>) {
    <span class="hljs-comment">// 通过桥接调用iOS原生Toast</span>
    <span class="hljs-title class_">UniBridge</span>.<span class="hljs-title function_">callNative</span>(<span class="hljs-string">'showToast'</span>, options);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// H5环境使用Web实现</span>
    <span class="hljs-keyword">const</span> toast = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
    toast.<span class="hljs-property">textContent</span> = options.<span class="hljs-property">title</span>;
    toast.<span class="hljs-property">className</span> = <span class="hljs-string">'uni-toast'</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(toast);
    
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(toast);
    }, options.<span class="hljs-property">duration</span>);
  }
}
</code></pre>
<h4 data-id="heading-10">3.2 开发效率</h4>
<p>基于WebView的开发模式允许开发者使用Web技术栈，大大提高了开发效率：</p>
<ul>
<li><strong>熟悉的开发语言</strong>: HTML/CSS/JavaScript</li>
<li><strong>丰富的生态系统</strong>: NPM包、前端框架等</li>
<li><strong>热更新能力</strong>: 无需重新安装应用即可更新代码</li>
<li><strong>调试便利</strong>: 可以使用浏览器开发者工具进行调试</li>
</ul>
<h4 data-id="heading-11">3.3 成本优势</h4>
<ul>
<li><strong>人力成本</strong>: 一套代码多端运行，减少开发人员数量</li>
<li><strong>时间成本</strong>: 同时发布到多个平台，缩短开发周期</li>
<li><strong>维护成本</strong>: 统一代码库，降低维护复杂度</li>
</ul>
<h3 data-id="heading-12">四、WebView容器的局限性</h3>
<h4 data-id="heading-13">4.1 性能限制</h4>
<p>WebView容器的性能相比原生应用有一定差距：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 性能对比（概念数据）</span>
<span class="hljs-keyword">const</span> performanceComparison = {
  <span class="hljs-string">'原生应用'</span>: {
    <span class="hljs-string">'启动速度'</span>: <span class="hljs-string">'100%'</span>,
    <span class="hljs-string">'渲染性能'</span>: <span class="hljs-string">'100%'</span>,
    <span class="hljs-string">'内存占用'</span>: <span class="hljs-string">'100%'</span>,
    <span class="hljs-string">'CPU使用'</span>: <span class="hljs-string">'100%'</span>
  },
  <span class="hljs-string">'WebView应用'</span>: {
    <span class="hljs-string">'启动速度'</span>: <span class="hljs-string">'70-80%'</span>,
    <span class="hljs-string">'渲染性能'</span>: <span class="hljs-string">'60-80%'</span>,
    <span class="hljs-string">'内存占用'</span>: <span class="hljs-string">'120-150%'</span>,
    <span class="hljs-string">'CPU使用'</span>: <span class="hljs-string">'110-130%'</span>
  }
};
</code></pre>
<h4 data-id="heading-14">4.2 功能限制</h4>
<p>某些原生功能在WebView中难以实现或性能不佳：</p>
<ul>
<li><strong>复杂动画</strong>: CSS动画和JavaScript动画性能不如原生动画</li>
<li><strong>大量数据处理</strong>: JavaScript处理大数据的能力有限</li>
<li><strong>图形渲染</strong>: 复杂图形和游戏渲染性能不足</li>
<li><strong>后台任务</strong>: WebView在后台时执行能力受限</li>
</ul>
<h4 data-id="heading-15">4.3 平台差异</h4>
<p>尽管WebView是标准组件，但不同平台的实现仍有差异：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 平台差异示例</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handlePlatformDifferences</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// Android WebView特有问题</span>
  <span class="hljs-keyword">if</span> (isAndroid) {
    <span class="hljs-comment">// 处理Android WebView的兼容性问题</span>
    <span class="hljs-title function_">fixAndroidWebViewIssues</span>();
  }
  
  <span class="hljs-comment">// iOS WebView特有问题</span>
  <span class="hljs-keyword">if</span> (isIOS) {
    <span class="hljs-comment">// 处理iOS WebView的兼容性问题</span>
    <span class="hljs-title function_">fixIOSWebViewIssues</span>();
  }
  
  <span class="hljs-comment">// 不同版本的WebView也有差异</span>
  <span class="hljs-title function_">handleWebViewVersionDifferences</span>();
}
</code></pre>
<h3 data-id="heading-16">五、UniApp对WebView容器的优化</h3>
<h4 data-id="heading-17">5.1 渲染优化</h4>
<p>UniApp通过多种方式优化WebView的渲染性能：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 渲染优化策略</span>
<span class="hljs-keyword">const</span> renderingOptimizations = {
  <span class="hljs-comment">// 1. 虚拟列表</span>
  <span class="hljs-attr">virtualList</span>: {
    <span class="hljs-attr">description</span>: <span class="hljs-string">'只渲染可视区域内的元素'</span>,
    <span class="hljs-attr">implementation</span>: <span class="hljs-string">'使用uni-list组件实现虚拟滚动'</span>
  },
  
  <span class="hljs-comment">// 2. 懒加载</span>
  <span class="hljs-attr">lazyLoading</span>: {
    <span class="hljs-attr">description</span>: <span class="hljs-string">'延迟加载非关键资源'</span>,
    <span class="hljs-attr">implementation</span>: <span class="hljs-string">'使用uni.lazyLoad图片懒加载'</span>
  },
  
  <span class="hljs-comment">// 3. 减少重排重绘</span>
  <span class="hljs-attr">reduceReflow</span>: {
    <span class="hljs-attr">description</span>: <span class="hljs-string">'批量更新DOM，减少重排重绘'</span>,
    <span class="hljs-attr">implementation</span>: <span class="hljs-string">'使用setData批量更新数据'</span>
  },
  
  <span class="hljs-comment">// 4. CSS优化</span>
  <span class="hljs-attr">cssOptimization</span>: {
    <span class="hljs-attr">description</span>: <span class="hljs-string">'使用高效的CSS选择器和属性'</span>,
    <span class="hljs-attr">implementation</span>: <span class="hljs-string">'避免复杂选择器，使用transform和opacity'</span>
  }
};
</code></pre>
<h4 data-id="heading-18">5.2 内存管理</h4>
<p>针对WebView内存占用高的问题，UniApp提供了多种优化方案：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 内存管理优化</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">optimizeMemoryUsage</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 1. 及时释放资源</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupResources</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 清理不再使用的对象</span>
    unusedObjects = <span class="hljs-literal">null</span>;
    
    <span class="hljs-comment">// 取消未完成的网络请求</span>
    <span class="hljs-title function_">cancelPendingRequests</span>();
    
    <span class="hljs-comment">// 移除事件监听器</span>
    <span class="hljs-title function_">removeEventListeners</span>();
  }
  
  <span class="hljs-comment">// 2. 图片内存优化</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">optimizeImageMemory</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 使用适当的图片格式和尺寸</span>
    <span class="hljs-title function_">useOptimizedImageFormat</span>();
    
    <span class="hljs-comment">// 及时释放图片资源</span>
    <span class="hljs-title function_">releaseImageResources</span>();
  }
  
  <span class="hljs-comment">// 3. 数据缓存优化</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">optimizeDataCache</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 限制缓存大小</span>
    <span class="hljs-title function_">limitCacheSize</span>();
    
    <span class="hljs-comment">// 使用LRU缓存策略</span>
    <span class="hljs-title function_">implementLRUCache</span>();
  }
}
</code></pre>
<h4 data-id="heading-19">5.3 原生能力增强</h4>
<p>UniApp通过原生插件机制弥补WebView的功能限制：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 原生插件机制（概念图）</span>
+------------------------------------------------------+
|                  <span class="hljs-title class_">UniApp</span>应用                          |
|  +----------------+  +----------------+  +---------+ |
|  |   <span class="hljs-title class_">Android</span>外壳  |  |    iOS外壳     |  | <span class="hljs-variable constant_">H5</span>外壳  | |
|  |                |  |                |  |         | |
|  |  +----------+  |  |  +----------+  |  |  浏览器  | |
|  |  | <span class="hljs-title class_">WebView</span>  |  |  |  | <span class="hljs-title class_">WebView</span>  |  |  |         | |
|  |  +----------+  |  |  +----------+  |  |         | |
|  |       |         |  |       |         |  |         | |
|  |  +----------+  |  |  +----------+  |  |         | |
|  |  | <span class="hljs-title class_">UniApp</span>   |  |  |  | <span class="hljs-title class_">UniApp</span>   |  |  |  <span class="hljs-title class_">UniApp</span> | |
|  |  | 运行时   |  |  |  | 运行时   |  |  |  运行时 | |
|  |  +----+-----+  |  |  +----+-----+  |  |         | |
|  |       |         |  |       |         |  |         | |
|  |  +----v-----+  |  |  +----v-----+  |  |         | |
|  |  | 原生插件  |  |  |  | 原生插件  |  |  |         | |
|  |  +----------+  |  |  +----------+  |  |         | |
|  +----------------+  +----------------+  +---------+ |
+------------------------------------------------------+
</code></pre>
<h3 data-id="heading-20">六、总结</h3>
<p>"uniapp 主要是运行在webview容器中的"这句话揭示了UniApp的核心架构原理。通过WebView容器，UniApp实现了跨平台能力，使开发者能够使用Web技术栈开发移动应用。这种架构既有优势（跨平台、开发效率高、成本低），也有局限性（性能限制、功能限制、平台差异）。</p>
<p>UniApp通过渲染优化、内存管理和原生插件等方式，不断弥补WebView容器的不足，提升应用性能和用户体验。理解WebView容器的工作原理，有助于开发者更好地使用UniApp框架，开发出高质量的跨平台应用。</p>
<p>对于物流元宇宙PDA项目这样的应用，理解WebView容器的原理尤为重要，因为PDA设备通常资源有限，需要特别关注内存占用和性能优化。通过合理使用UniApp提供的优化方案，可以在WebView容器中实现流畅的用户体验，同时保持跨平台的优势。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[DeepSeek印度股票数据源 Java 对接文档]]></title>    <link>https://juejin.cn/post/7570902804450312202</link>    <guid>https://juejin.cn/post/7570902804450312202</guid>    <pubDate>2025-11-10T08:32:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804450312202" data-draft-id="7570579125154922506" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="DeepSeek印度股票数据源 Java 对接文档"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2025-11-10T08:32:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CryptoRzz"/> <meta itemprop="url" content="https://juejin.cn/user/402879809850410"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            DeepSeek印度股票数据源 Java 对接文档
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/402879809850410/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CryptoRzz
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:32:42.000Z" title="Mon Nov 10 2025 08:32:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">📋 文档概述</h2>
<p>本文档详细介绍如何使用 Java 语言对接 StockTV 印度股票数据源，包含完整的代码示例、数据模型、异常处理等。</p>
<h2 data-id="heading-1">🚀 快速开始</h2>
<h3 data-id="heading-2">环境要求</h3>
<ul>
<li>JDK 8+</li>
<li>Maven 3.6+</li>
<li>网络连接（可访问 <code>api.stocktv.top</code>）</li>
</ul>
<h3 data-id="heading-3">项目依赖</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- pom.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- HTTP客户端 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- JSON处理 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.15.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 日志框架 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- Lombok（可选） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
</code></pre>
<h2 data-id="heading-4">🏗️ 核心架构</h2>
<h3 data-id="heading-5">项目结构</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span>/java/com/stocktv/india/
├── config/
│   └── StockTVConfig<span class="hljs-selector-class">.java</span>
├── model/
│   ├── Stock<span class="hljs-selector-class">.java</span>
│   ├── Index<span class="hljs-selector-class">.java</span>
│   ├── KLine<span class="hljs-selector-class">.java</span>
│   └── ApiResponse<span class="hljs-selector-class">.java</span>
├── client/
│   ├── StockTVHttpClient<span class="hljs-selector-class">.java</span>
│   └── StockTVWebSocketClient<span class="hljs-selector-class">.java</span>
├── service/
│   └── IndiaStockService<span class="hljs-selector-class">.java</span>
└── demo/
    └── IndiaStockDemo<span class="hljs-selector-class">.java</span>
</code></pre>
<h2 data-id="heading-6">📦 核心代码实现</h2>
<h3 data-id="heading-7">1. 配置类</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.config;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;
<span class="hljs-keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;
<span class="hljs-keyword">import</span> org.apache.http.impl.client.HttpClients;

<span class="hljs-comment">/**
 * StockTV API 配置类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockTVConfig</span> {
    
    <span class="hljs-comment">// API 基础配置</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BASE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"https://api.stocktv.top"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WS_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"wss://ws-api.stocktv.top/connect"</span>;
    
    <span class="hljs-comment">// 印度市场配置</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INDIA_COUNTRY_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NSE_EXCHANGE_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">46</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BSE_EXCHANGE_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">74</span>;
    
    <span class="hljs-comment">// API Key</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String apiKey;
    
    <span class="hljs-comment">// HTTP 客户端和JSON处理器</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CloseableHttpClient httpClient;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectMapper objectMapper;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockTVConfig</span><span class="hljs-params">(String apiKey)</span> {
        <span class="hljs-built_in">this</span>.apiKey = apiKey;
        <span class="hljs-built_in">this</span>.httpClient = HttpClients.createDefault();
        <span class="hljs-built_in">this</span>.objectMapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();
        <span class="hljs-comment">// 配置ObjectMapper</span>
        <span class="hljs-built_in">this</span>.objectMapper.findAndRegisterModules();
    }
    
    <span class="hljs-comment">// Getter方法</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getApiKey</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> apiKey; }
    <span class="hljs-keyword">public</span> CloseableHttpClient <span class="hljs-title function_">getHttpClient</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> httpClient; }
    <span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title function_">getObjectMapper</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> objectMapper; }
}
</code></pre>
<h3 data-id="heading-8">2. 数据模型类</h3>
<h4 data-id="heading-9">股票数据模型</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.model;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;
<span class="hljs-keyword">import</span> lombok.Data;

<span class="hljs-keyword">import</span> java.math.BigDecimal;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;
<span class="hljs-keyword">import</span> java.time.ZoneId;

<span class="hljs-comment">/**
 * 印度股票数据模型
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> {
    <span class="hljs-meta">@JsonProperty("id")</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-meta">@JsonProperty("symbol")</span>
    <span class="hljs-keyword">private</span> String symbol;
    
    <span class="hljs-meta">@JsonProperty("name")</span>
    <span class="hljs-keyword">private</span> String name;
    
    <span class="hljs-meta">@JsonProperty("last")</span>
    <span class="hljs-keyword">private</span> BigDecimal lastPrice;
    
    <span class="hljs-meta">@JsonProperty("chg")</span>
    <span class="hljs-keyword">private</span> BigDecimal change;
    
    <span class="hljs-meta">@JsonProperty("chgPct")</span>
    <span class="hljs-keyword">private</span> BigDecimal changePercent;
    
    <span class="hljs-meta">@JsonProperty("high")</span>
    <span class="hljs-keyword">private</span> BigDecimal high;
    
    <span class="hljs-meta">@JsonProperty("low")</span>
    <span class="hljs-keyword">private</span> BigDecimal low;
    
    <span class="hljs-meta">@JsonProperty("volume")</span>
    <span class="hljs-keyword">private</span> Long volume;
    
    <span class="hljs-meta">@JsonProperty("open")</span>
    <span class="hljs-keyword">private</span> Boolean isOpen;
    
    <span class="hljs-meta">@JsonProperty("exchangeId")</span>
    <span class="hljs-keyword">private</span> Integer exchangeId;
    
    <span class="hljs-meta">@JsonProperty("countryId")</span>
    <span class="hljs-keyword">private</span> Integer countryId;
    
    <span class="hljs-meta">@JsonProperty("time")</span>
    <span class="hljs-keyword">private</span> Long timestamp;
    
    <span class="hljs-meta">@JsonProperty("fundamentalMarketCap")</span>
    <span class="hljs-keyword">private</span> BigDecimal marketCap;
    
    <span class="hljs-meta">@JsonProperty("fundamentalRevenue")</span>
    <span class="hljs-keyword">private</span> String revenue;
    
    <span class="hljs-comment">// 技术指标</span>
    <span class="hljs-meta">@JsonProperty("technicalDay")</span>
    <span class="hljs-keyword">private</span> String technicalDay;
    
    <span class="hljs-meta">@JsonProperty("technicalHour")</span>
    <span class="hljs-keyword">private</span> String technicalHour;
    
    <span class="hljs-meta">@JsonProperty("technicalWeek")</span>
    <span class="hljs-keyword">private</span> String technicalWeek;
    
    <span class="hljs-meta">@JsonProperty("technicalMonth")</span>
    <span class="hljs-keyword">private</span> String technicalMonth;
    
    <span class="hljs-comment">// 性能指标</span>
    <span class="hljs-meta">@JsonProperty("performanceDay")</span>
    <span class="hljs-keyword">private</span> BigDecimal performanceDay;
    
    <span class="hljs-meta">@JsonProperty("performanceWeek")</span>
    <span class="hljs-keyword">private</span> BigDecimal performanceWeek;
    
    <span class="hljs-meta">@JsonProperty("performanceMonth")</span>
    <span class="hljs-keyword">private</span> BigDecimal performanceMonth;
    
    <span class="hljs-meta">@JsonProperty("performanceYtd")</span>
    <span class="hljs-keyword">private</span> BigDecimal performanceYtd;
    
    <span class="hljs-comment">/**
     * 获取格式化的时间
     */</span>
    <span class="hljs-keyword">public</span> LocalDateTime <span class="hljs-title function_">getFormattedTime</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochSecond(timestamp), ZoneId.systemDefault());
    }
    
    <span class="hljs-comment">/**
     * 获取交易所名称
     */</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getExchangeName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (NSE_EXCHANGE_ID == exchangeId) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"NSE"</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BSE_EXCHANGE_ID == exchangeId) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"BSE"</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Unknown"</span>;
    }
}

<span class="hljs-comment">// 常量接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExchangeConstants</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">NSE_EXCHANGE_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">46</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">BSE_EXCHANGE_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">74</span>;
}
</code></pre>
<h4 data-id="heading-10">K线数据模型</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.model;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;
<span class="hljs-keyword">import</span> lombok.Data;

<span class="hljs-keyword">import</span> java.math.BigDecimal;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;
<span class="hljs-keyword">import</span> java.time.ZoneId;

<span class="hljs-comment">/**
 * K线数据模型
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KLine</span> {
    <span class="hljs-meta">@JsonProperty("time")</span>
    <span class="hljs-keyword">private</span> Long timestamp;
    
    <span class="hljs-meta">@JsonProperty("open")</span>
    <span class="hljs-keyword">private</span> BigDecimal open;
    
    <span class="hljs-meta">@JsonProperty("high")</span>
    <span class="hljs-keyword">private</span> BigDecimal high;
    
    <span class="hljs-meta">@JsonProperty("low")</span>
    <span class="hljs-keyword">private</span> BigDecimal low;
    
    <span class="hljs-meta">@JsonProperty("close")</span>
    <span class="hljs-keyword">private</span> BigDecimal close;
    
    <span class="hljs-meta">@JsonProperty("volume")</span>
    <span class="hljs-keyword">private</span> Long volume;
    
    <span class="hljs-meta">@JsonProperty("vo")</span>
    <span class="hljs-keyword">private</span> BigDecimal turnover;
    
    <span class="hljs-comment">/**
     * 获取格式化的时间
     */</span>
    <span class="hljs-keyword">public</span> LocalDateTime <span class="hljs-title function_">getFormattedTime</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());
    }
    
    <span class="hljs-comment">/**
     * 计算振幅
     */</span>
    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getAmplitude</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (open == <span class="hljs-literal">null</span> || open.compareTo(BigDecimal.ZERO) == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> BigDecimal.ZERO;
        }
        <span class="hljs-keyword">return</span> high.subtract(low).divide(open, <span class="hljs-number">4</span>, BigDecimal.ROUND_HALF_UP);
    }
}
</code></pre>
<h4 data-id="heading-11">指数数据模型</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.model;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;
<span class="hljs-keyword">import</span> lombok.Data;

<span class="hljs-keyword">import</span> java.math.BigDecimal;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;
<span class="hljs-keyword">import</span> java.time.ZoneId;

<span class="hljs-comment">/**
 * 指数数据模型
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> {
    <span class="hljs-meta">@JsonProperty("id")</span>
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-meta">@JsonProperty("name")</span>
    <span class="hljs-keyword">private</span> String name;
    
    <span class="hljs-meta">@JsonProperty("symbol")</span>
    <span class="hljs-keyword">private</span> String symbol;
    
    <span class="hljs-meta">@JsonProperty("last")</span>
    <span class="hljs-keyword">private</span> BigDecimal lastPrice;
    
    <span class="hljs-meta">@JsonProperty("chg")</span>
    <span class="hljs-keyword">private</span> BigDecimal change;
    
    <span class="hljs-meta">@JsonProperty("chgPct")</span>
    <span class="hljs-keyword">private</span> BigDecimal changePercent;
    
    <span class="hljs-meta">@JsonProperty("high")</span>
    <span class="hljs-keyword">private</span> BigDecimal high;
    
    <span class="hljs-meta">@JsonProperty("low")</span>
    <span class="hljs-keyword">private</span> BigDecimal low;
    
    <span class="hljs-meta">@JsonProperty("isOpen")</span>
    <span class="hljs-keyword">private</span> Boolean isOpen;
    
    <span class="hljs-meta">@JsonProperty("time")</span>
    <span class="hljs-keyword">private</span> Long timestamp;
    
    <span class="hljs-meta">@JsonProperty("flag")</span>
    <span class="hljs-keyword">private</span> String countryFlag;
    
    <span class="hljs-comment">/**
     * 获取格式化的时间
     */</span>
    <span class="hljs-keyword">public</span> LocalDateTime <span class="hljs-title function_">getFormattedTime</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochSecond(timestamp), ZoneId.systemDefault());
    }
}
</code></pre>
<h4 data-id="heading-12">API响应包装类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.model;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;
<span class="hljs-keyword">import</span> lombok.Data;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/**
 * API通用响应包装类
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {
    <span class="hljs-meta">@JsonProperty("code")</span>
    <span class="hljs-keyword">private</span> Integer code;
    
    <span class="hljs-meta">@JsonProperty("message")</span>
    <span class="hljs-keyword">private</span> String message;
    
    <span class="hljs-meta">@JsonProperty("data")</span>
    <span class="hljs-keyword">private</span> T data;
    
    <span class="hljs-comment">/**
     * 判断请求是否成功
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSuccess</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> code != <span class="hljs-literal">null</span> &amp;&amp; code == <span class="hljs-number">200</span>;
    }
}

<span class="hljs-comment">/**
 * 股票列表响应包装类
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StockListResponse</span> {
    <span class="hljs-meta">@JsonProperty("records")</span>
    <span class="hljs-keyword">private</span> List&lt;Stock&gt; records;
    
    <span class="hljs-meta">@JsonProperty("total")</span>
    <span class="hljs-keyword">private</span> Integer total;
    
    <span class="hljs-meta">@JsonProperty("current")</span>
    <span class="hljs-keyword">private</span> Integer current;
    
    <span class="hljs-meta">@JsonProperty("pages")</span>
    <span class="hljs-keyword">private</span> Integer pages;
    
    <span class="hljs-meta">@JsonProperty("size")</span>
    <span class="hljs-keyword">private</span> Integer size;
}
</code></pre>
<h3 data-id="heading-13">3. HTTP客户端实现</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.client;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.core.type.TypeReference;
<span class="hljs-keyword">import</span> com.stocktv.india.config.StockTVConfig;
<span class="hljs-keyword">import</span> com.stocktv.india.model.*;
<span class="hljs-keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;
<span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;
<span class="hljs-keyword">import</span> org.apache.http.client.utils.URIBuilder;
<span class="hljs-keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;
<span class="hljs-keyword">import</span> org.apache.http.util.EntityUtils;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.URI;
<span class="hljs-keyword">import</span> java.net.URISyntaxException;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/**
 * StockTV HTTP API客户端
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockTVHttpClient</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StockTVHttpClient.class);
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StockTVConfig config;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CloseableHttpClient httpClient;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockTVHttpClient</span><span class="hljs-params">(StockTVConfig config)</span> {
        <span class="hljs-built_in">this</span>.config = config;
        <span class="hljs-built_in">this</span>.httpClient = config.getHttpClient();
    }
    
    <span class="hljs-comment">/**
     * 获取印度股票列表
     * 
     * <span class="hljs-doctag">@param</span> pageSize 每页数量
     * <span class="hljs-doctag">@param</span> page 页码
     * <span class="hljs-doctag">@return</span> 股票列表
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">getIndiaStocks</span><span class="hljs-params">(Integer pageSize, Integer page)</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException {
        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(config.BASE_URL + <span class="hljs-string">"/stock/stocks"</span>)
                .addParameter(<span class="hljs-string">"countryId"</span>, String.valueOf(StockTVConfig.INDIA_COUNTRY_ID))
                .addParameter(<span class="hljs-string">"pageSize"</span>, String.valueOf(pageSize))
                .addParameter(<span class="hljs-string">"page"</span>, String.valueOf(page))
                .addParameter(<span class="hljs-string">"key"</span>, config.getApiKey())
                .build();
        
        ApiResponse&lt;StockListResponse&gt; response = executeGetRequest(uri, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;ApiResponse&lt;StockListResponse&gt;&gt;() {});
        
        <span class="hljs-keyword">if</span> (response.isSuccess()) {
            logger.info(<span class="hljs-string">"成功获取 {} 条印度股票数据"</span>, response.getData().getRecords().size());
            <span class="hljs-keyword">return</span> response.getData().getRecords();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"API请求失败: "</span> + response.getMessage());
        }
    }
    
    <span class="hljs-comment">/**
     * 查询单个股票
     * 
     * <span class="hljs-doctag">@param</span> pid 股票PID
     * <span class="hljs-doctag">@param</span> symbol 股票代码
     * <span class="hljs-doctag">@param</span> name 股票名称
     * <span class="hljs-doctag">@return</span> 股票列表
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">queryStock</span><span class="hljs-params">(Long pid, String symbol, String name)</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException {
        <span class="hljs-type">URIBuilder</span> <span class="hljs-variable">uriBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(config.BASE_URL + <span class="hljs-string">"/stock/queryStocks"</span>)
                .addParameter(<span class="hljs-string">"key"</span>, config.getApiKey());
        
        <span class="hljs-keyword">if</span> (pid != <span class="hljs-literal">null</span>) {
            uriBuilder.addParameter(<span class="hljs-string">"id"</span>, String.valueOf(pid));
        }
        <span class="hljs-keyword">if</span> (symbol != <span class="hljs-literal">null</span>) {
            uriBuilder.addParameter(<span class="hljs-string">"symbol"</span>, symbol);
        }
        <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span>) {
            uriBuilder.addParameter(<span class="hljs-string">"name"</span>, name);
        }
        
        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> uriBuilder.build();
        
        ApiResponse&lt;List&lt;Stock&gt;&gt; response = executeGetRequest(uri, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;ApiResponse&lt;List&lt;Stock&gt;&gt;&gt;() {});
        
        <span class="hljs-keyword">if</span> (response.isSuccess()) {
            logger.info(<span class="hljs-string">"股票查询成功，返回 {} 条记录"</span>, response.getData().size());
            <span class="hljs-keyword">return</span> response.getData();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"股票查询失败: "</span> + response.getMessage());
        }
    }
    
    <span class="hljs-comment">/**
     * 批量查询多个股票
     * 
     * <span class="hljs-doctag">@param</span> pids 股票PID列表
     * <span class="hljs-doctag">@return</span> 股票列表
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">getStocksByPids</span><span class="hljs-params">(List&lt;Long&gt; pids)</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException {
        <span class="hljs-keyword">if</span> (pids == <span class="hljs-literal">null</span> || pids.isEmpty()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"股票PID列表不能为空"</span>);
        }
        
        <span class="hljs-type">String</span> <span class="hljs-variable">pidsStr</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">","</span>, pids.stream().map(String::valueOf).toArray(String[]::<span class="hljs-keyword">new</span>));
        
        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(config.BASE_URL + <span class="hljs-string">"/stock/stocksByPids"</span>)
                .addParameter(<span class="hljs-string">"key"</span>, config.getApiKey())
                .addParameter(<span class="hljs-string">"pids"</span>, pidsStr)
                .build();
        
        ApiResponse&lt;List&lt;Stock&gt;&gt; response = executeGetRequest(uri, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;ApiResponse&lt;List&lt;Stock&gt;&gt;&gt;() {});
        
        <span class="hljs-keyword">if</span> (response.isSuccess()) {
            logger.info(<span class="hljs-string">"批量查询成功，返回 {} 条记录"</span>, response.getData().size());
            <span class="hljs-keyword">return</span> response.getData();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"批量查询失败: "</span> + response.getMessage());
        }
    }
    
    <span class="hljs-comment">/**
     * 获取印度主要指数
     * 
     * <span class="hljs-doctag">@return</span> 指数列表
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Index&gt; <span class="hljs-title function_">getIndiaIndices</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException {
        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(config.BASE_URL + <span class="hljs-string">"/stock/indices"</span>)
                .addParameter(<span class="hljs-string">"countryId"</span>, String.valueOf(StockTVConfig.INDIA_COUNTRY_ID))
                .addParameter(<span class="hljs-string">"key"</span>, config.getApiKey())
                .build();
        
        ApiResponse&lt;List&lt;Index&gt;&gt; response = executeGetRequest(uri, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;ApiResponse&lt;List&lt;Index&gt;&gt;&gt;() {});
        
        <span class="hljs-keyword">if</span> (response.isSuccess()) {
            logger.info(<span class="hljs-string">"成功获取 {} 个印度指数"</span>, response.getData().size());
            <span class="hljs-keyword">return</span> response.getData();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取指数失败: "</span> + response.getMessage());
        }
    }
    
    <span class="hljs-comment">/**
     * 获取K线数据
     * 
     * <span class="hljs-doctag">@param</span> pid 股票PID
     * <span class="hljs-doctag">@param</span> interval 时间间隔
     * <span class="hljs-doctag">@return</span> K线数据列表
     */</span>
    <span class="hljs-keyword">public</span> List&lt;KLine&gt; <span class="hljs-title function_">getKLineData</span><span class="hljs-params">(Long pid, String interval)</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException {
        <span class="hljs-keyword">if</span> (pid == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"股票PID不能为空"</span>);
        }
        
        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(config.BASE_URL + <span class="hljs-string">"/stock/kline"</span>)
                .addParameter(<span class="hljs-string">"pid"</span>, String.valueOf(pid))
                .addParameter(<span class="hljs-string">"interval"</span>, interval)
                .addParameter(<span class="hljs-string">"key"</span>, config.getApiKey())
                .build();
        
        ApiResponse&lt;List&lt;KLine&gt;&gt; response = executeGetRequest(uri, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;ApiResponse&lt;List&lt;KLine&gt;&gt;&gt;() {});
        
        <span class="hljs-keyword">if</span> (response.isSuccess()) {
            logger.info(<span class="hljs-string">"成功获取股票 {} 的K线数据，共 {} 条"</span>, pid, response.getData().size());
            <span class="hljs-keyword">return</span> response.getData();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取K线数据失败: "</span> + response.getMessage());
        }
    }
    
    <span class="hljs-comment">/**
     * 获取涨跌排行榜
     * 
     * <span class="hljs-doctag">@param</span> type 排行榜类型
     * <span class="hljs-doctag">@return</span> 股票列表
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">getUpDownList</span><span class="hljs-params">(Integer type)</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException {
        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(config.BASE_URL + <span class="hljs-string">"/stock/updownList"</span>)
                .addParameter(<span class="hljs-string">"countryId"</span>, String.valueOf(StockTVConfig.INDIA_COUNTRY_ID))
                .addParameter(<span class="hljs-string">"type"</span>, String.valueOf(type))
                .addParameter(<span class="hljs-string">"key"</span>, config.getApiKey())
                .build();
        
        ApiResponse&lt;List&lt;Stock&gt;&gt; response = executeGetRequest(uri, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;ApiResponse&lt;List&lt;Stock&gt;&gt;&gt;() {});
        
        <span class="hljs-keyword">if</span> (response.isSuccess()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">typeName</span> <span class="hljs-operator">=</span> getRankingTypeName(type);
            logger.info(<span class="hljs-string">"成功获取{}，共 {} 条记录"</span>, typeName, response.getData().size());
            <span class="hljs-keyword">return</span> response.getData();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取排行榜失败: "</span> + response.getMessage());
        }
    }
    
    <span class="hljs-comment">/**
     * 获取IPO新股日历
     * 
     * <span class="hljs-doctag">@param</span> type IPO类型
     * <span class="hljs-doctag">@return</span> IPO列表
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">getIpoList</span><span class="hljs-params">(Integer type)</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException {
        <span class="hljs-type">URIBuilder</span> <span class="hljs-variable">uriBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(config.BASE_URL + <span class="hljs-string">"/stock/getIpo"</span>)
                .addParameter(<span class="hljs-string">"countryId"</span>, String.valueOf(StockTVConfig.INDIA_COUNTRY_ID))
                .addParameter(<span class="hljs-string">"key"</span>, config.getApiKey());
        
        <span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span>) {
            uriBuilder.addParameter(<span class="hljs-string">"type"</span>, String.valueOf(type));
        }
        
        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> uriBuilder.build();
        
        ApiResponse&lt;List&lt;Object&gt;&gt; response = executeGetRequest(uri, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;ApiResponse&lt;List&lt;Object&gt;&gt;&gt;() {});
        
        <span class="hljs-keyword">if</span> (response.isSuccess()) {
            logger.info(<span class="hljs-string">"成功获取IPO数据，共 {} 条"</span>, response.getData().size());
            <span class="hljs-keyword">return</span> response.getData();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取IPO数据失败: "</span> + response.getMessage());
        }
    }
    
    <span class="hljs-comment">/**
     * 通用GET请求执行方法
     */</span>
    <span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">executeGetRequest</span><span class="hljs-params">(URI uri, TypeReference&lt;T&gt; typeReference)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(uri);
        logger.debug(<span class="hljs-string">"执行API请求: {}"</span>, uri);
        
        <span class="hljs-keyword">try</span> (<span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(request)) {
            <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusLine().getStatusCode();
            <span class="hljs-type">String</span> <span class="hljs-variable">responseBody</span> <span class="hljs-operator">=</span> EntityUtils.toString(response.getEntity());
            
            <span class="hljs-keyword">if</span> (statusCode != <span class="hljs-number">200</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">"HTTP请求失败，状态码: "</span> + statusCode);
            }
            
            logger.debug(<span class="hljs-string">"API响应: {}"</span>, responseBody);
            <span class="hljs-keyword">return</span> config.getObjectMapper().readValue(responseBody, typeReference);
        }
    }
    
    <span class="hljs-comment">/**
     * 获取排行榜类型名称
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getRankingTypeName</span><span class="hljs-params">(Integer type)</span> {
        <span class="hljs-keyword">switch</span> (type) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"涨幅榜"</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"跌幅榜"</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"涨停榜"</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"跌停榜"</span>;
            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"排行榜"</span>;
        }
    }
    
    <span class="hljs-comment">/**
     * 关闭HTTP客户端
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">if</span> (httpClient != <span class="hljs-literal">null</span>) {
            httpClient.close();
        }
    }
}
</code></pre>
<h3 data-id="heading-14">4. 服务层封装</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.service;

<span class="hljs-keyword">import</span> com.stocktv.india.client.StockTVHttpClient;
<span class="hljs-keyword">import</span> com.stocktv.india.config.StockTVConfig;
<span class="hljs-keyword">import</span> com.stocktv.india.model.Index;
<span class="hljs-keyword">import</span> com.stocktv.india.model.KLine;
<span class="hljs-keyword">import</span> com.stocktv.india.model.Stock;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.stream.Collectors;

<span class="hljs-comment">/**
 * 印度股票数据服务
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndiaStockService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(IndiaStockService.class);
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StockTVHttpClient httpClient;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StockTVConfig config;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IndiaStockService</span><span class="hljs-params">(String apiKey)</span> {
        <span class="hljs-built_in">this</span>.config = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockTVConfig</span>(apiKey);
        <span class="hljs-built_in">this</span>.httpClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockTVHttpClient</span>(config);
    }
    
    <span class="hljs-comment">/**
     * 获取Nifty 50成分股
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">getNifty50Stocks</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 实际应用中应该根据Nifty 50成分股列表查询</span>
            List&lt;Stock&gt; stocks = httpClient.getIndiaStocks(<span class="hljs-number">50</span>, <span class="hljs-number">1</span>);
            logger.info(<span class="hljs-string">"获取Nifty 50成分股成功，共 {} 只股票"</span>, stocks.size());
            <span class="hljs-keyword">return</span> stocks;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"获取Nifty 50成分股失败"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取Nifty 50成分股失败"</span>, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 获取印度主要指数
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Index&gt; <span class="hljs-title function_">getMajorIndices</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            List&lt;Index&gt; indices = httpClient.getIndiaIndices();
            logger.info(<span class="hljs-string">"获取印度主要指数成功，共 {} 个指数"</span>, indices.size());
            <span class="hljs-keyword">return</span> indices;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"获取印度指数失败"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取印度指数失败"</span>, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 查询特定股票
     */</span>
    <span class="hljs-keyword">public</span> Stock <span class="hljs-title function_">getStockBySymbol</span><span class="hljs-params">(String symbol)</span> {
        <span class="hljs-keyword">try</span> {
            List&lt;Stock&gt; stocks = httpClient.queryStock(<span class="hljs-literal">null</span>, symbol, <span class="hljs-literal">null</span>);
            <span class="hljs-keyword">if</span> (stocks.isEmpty()) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"未找到股票: "</span> + symbol);
            }
            logger.info(<span class="hljs-string">"查询股票 {} 成功"</span>, symbol);
            <span class="hljs-keyword">return</span> stocks.get(<span class="hljs-number">0</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"查询股票失败: "</span> + symbol, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"查询股票失败: "</span> + symbol, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 批量查询股票
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">getStocksBySymbols</span><span class="hljs-params">(List&lt;String&gt; symbols)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 这里需要先将symbol转换为pid，简化处理直接查询</span>
            List&lt;Stock&gt; result = symbols.stream()
                    .map(<span class="hljs-built_in">this</span>::getStockBySymbol)
                    .collect(Collectors.toList());
            logger.info(<span class="hljs-string">"批量查询 {} 只股票成功"</span>, symbols.size());
            <span class="hljs-keyword">return</span> result;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"批量查询股票失败"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"批量查询股票失败"</span>, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 获取股票K线数据
     */</span>
    <span class="hljs-keyword">public</span> List&lt;KLine&gt; <span class="hljs-title function_">getStockKLine</span><span class="hljs-params">(Long pid, String interval)</span> {
        <span class="hljs-keyword">try</span> {
            List&lt;KLine&gt; klines = httpClient.getKLineData(pid, interval);
            logger.info(<span class="hljs-string">"获取股票 {} 的K线数据成功，共 {} 条"</span>, pid, klines.size());
            <span class="hljs-keyword">return</span> klines;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"获取K线数据失败: pid="</span> + pid, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取K线数据失败: pid="</span> + pid, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 获取涨幅榜
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">getGainers</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            List&lt;Stock&gt; gainers = httpClient.getUpDownList(<span class="hljs-number">1</span>);
            logger.info(<span class="hljs-string">"获取涨幅榜成功，共 {} 只股票"</span>, gainers.size());
            <span class="hljs-keyword">return</span> gainers;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"获取涨幅榜失败"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取涨幅榜失败"</span>, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 获取跌幅榜
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Stock&gt; <span class="hljs-title function_">getLosers</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            List&lt;Stock&gt; losers = httpClient.getUpDownList(<span class="hljs-number">2</span>);
            logger.info(<span class="hljs-string">"获取跌幅榜成功，共 {} 只股票"</span>, losers.size());
            <span class="hljs-keyword">return</span> losers;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"获取跌幅榜失败"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取跌幅榜失败"</span>, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 获取IPO数据
     */</span>
    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">getUpcomingIPOs</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            List&lt;Object&gt; ipos = httpClient.getIpoList(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1表示未上市</span>
            logger.info(<span class="hljs-string">"获取IPO数据成功，共 {} 个"</span>, ipos.size());
            <span class="hljs-keyword">return</span> ipos;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"获取IPO数据失败"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取IPO数据失败"</span>, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 关闭服务
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            httpClient.close();
            logger.info(<span class="hljs-string">"IndiaStockService已关闭"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"关闭服务时发生错误"</span>, e);
        }
    }
}
</code></pre>
<h3 data-id="heading-15">5. 使用示例</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.demo;

<span class="hljs-keyword">import</span> com.stocktv.india.model.Index;
<span class="hljs-keyword">import</span> com.stocktv.india.model.KLine;
<span class="hljs-keyword">import</span> com.stocktv.india.model.Stock;
<span class="hljs-keyword">import</span> com.stocktv.india.service.IndiaStockService;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/**
 * 印度股票数据使用示例
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndiaStockDemo</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(IndiaStockDemo.class);
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 替换为您的实际 API Key</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">apiKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">"您的API_KEY"</span>;
        
        <span class="hljs-type">IndiaStockService</span> <span class="hljs-variable">stockService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndiaStockService</span>(apiKey);
        
        <span class="hljs-keyword">try</span> {
            logger.info(<span class="hljs-string">"=== StockTV 印度股票数据演示程序开始 ==="</span>);
            
            <span class="hljs-comment">// 1. 获取印度主要指数</span>
            demonstrateIndices(stockService);
            
            <span class="hljs-comment">// 2. 查询特定股票</span>
            demonstrateStockQuery(stockService);
            
            <span class="hljs-comment">// 3. 获取Nifty 50成分股示例</span>
            demonstrateNifty50(stockService);
            
            <span class="hljs-comment">// 4. 获取K线数据</span>
            demonstrateKLineData(stockService);
            
            <span class="hljs-comment">// 5. 获取排行榜</span>
            demonstrateRankings(stockService);
            
            logger.info(<span class="hljs-string">"=== 演示程序执行完成 ==="</span>);
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"演示程序执行失败"</span>, e);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 关闭服务</span>
            stockService.close();
        }
    }
    
    <span class="hljs-comment">/**
     * 演示指数数据获取
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateIndices</span><span class="hljs-params">(IndiaStockService stockService)</span> {
        logger.info(<span class="hljs-string">"\n1. 印度主要指数"</span>);
        List&lt;Index&gt; indices = stockService.getMajorIndices();
        
        indices.forEach(index -&gt; {
            <span class="hljs-type">String</span> <span class="hljs-variable">trend</span> <span class="hljs-operator">=</span> index.getChange().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"📈"</span> : <span class="hljs-string">"📉"</span>;
            logger.info(<span class="hljs-string">"{} {}: {}{} ({}{}%)"</span>, 
                trend, index.getName(), index.getLastPrice(),
                index.getChange().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"↑"</span> : <span class="hljs-string">"↓"</span>,
                index.getChange().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"+"</span> : <span class="hljs-string">""</span>,
                index.getChangePercent());
        });
    }
    
    <span class="hljs-comment">/**
     * 演示股票查询
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateStockQuery</span><span class="hljs-params">(IndiaStockService stockService)</span> {
        logger.info(<span class="hljs-string">"\n2. 查询特定股票"</span>);
        
        <span class="hljs-comment">// 查询Reliance Industries</span>
        <span class="hljs-type">Stock</span> <span class="hljs-variable">reliance</span> <span class="hljs-operator">=</span> stockService.getStockBySymbol(<span class="hljs-string">"RELIANCE"</span>);
        printStockInfo(reliance, <span class="hljs-string">"Reliance Industries"</span>);
        
        <span class="hljs-comment">// 查询TCS</span>
        <span class="hljs-type">Stock</span> <span class="hljs-variable">tcs</span> <span class="hljs-operator">=</span> stockService.getStockBySymbol(<span class="hljs-string">"TCS"</span>);
        printStockInfo(tcs, <span class="hljs-string">"Tata Consultancy Services"</span>);
    }
    
    <span class="hljs-comment">/**
     * 演示Nifty 50成分股
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateNifty50</span><span class="hljs-params">(IndiaStockService stockService)</span> {
        logger.info(<span class="hljs-string">"\n3. Nifty 50成分股（示例）"</span>);
        List&lt;Stock&gt; niftyStocks = stockService.getNifty50Stocks();
        
        <span class="hljs-comment">// 显示前10只股票</span>
        niftyStocks.stream().limit(<span class="hljs-number">10</span>).forEach(stock -&gt; {
            <span class="hljs-type">String</span> <span class="hljs-variable">trend</span> <span class="hljs-operator">=</span> stock.getChangePercent().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"🟢"</span> : <span class="hljs-string">"🔴"</span>;
            logger.info(<span class="hljs-string">"{} {}: ₹{} ({}{}%) - {}"</span>, 
                trend, stock.getSymbol(), stock.getLastPrice(),
                stock.getChangePercent().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"+"</span> : <span class="hljs-string">""</span>,
                stock.getChangePercent(), stock.getName());
        });
    }
    
    <span class="hljs-comment">/**
     * 演示K线数据获取
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateKLineData</span><span class="hljs-params">(IndiaStockService stockService)</span> {
        logger.info(<span class="hljs-string">"\n4. K线数据示例"</span>);
        
        <span class="hljs-type">Stock</span> <span class="hljs-variable">reliance</span> <span class="hljs-operator">=</span> stockService.getStockBySymbol(<span class="hljs-string">"RELIANCE"</span>);
        <span class="hljs-keyword">if</span> (reliance != <span class="hljs-literal">null</span>) {
            List&lt;KLine&gt; kLines = stockService.getStockKLine(reliance.getId(), <span class="hljs-string">"P1D"</span>);
            
            logger.info(<span class="hljs-string">"Reliance Industries 近期日K线数据:"</span>);
            kLines.stream().limit(<span class="hljs-number">5</span>).forEach(kLine -&gt; {
                logger.info(<span class="hljs-string">"时间: {}, 开: ₹{}, 高: ₹{}, 低: ₹{}, 收: ₹{}, 成交量: {}"</span>, 
                    kLine.getFormattedTime(), kLine.getOpen(), 
                    kLine.getHigh(), kLine.getLow(), kLine.getClose(),
                    kLine.getVolume());
            });
        }
    }
    
    <span class="hljs-comment">/**
     * 演示排行榜功能
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateRankings</span><span class="hljs-params">(IndiaStockService stockService)</span> {
        logger.info(<span class="hljs-string">"\n5. 市场排行榜"</span>);
        
        <span class="hljs-comment">// 获取涨幅榜</span>
        List&lt;Stock&gt; gainers = stockService.getGainers();
        logger.info(<span class="hljs-string">"📈 今日涨幅榜（前5）:"</span>);
        gainers.stream().limit(<span class="hljs-number">5</span>).forEach(stock -&gt; {
            logger.info(<span class="hljs-string">"   {}: ₹{} (+{}%) - {}"</span>, 
                stock.getSymbol(), stock.getLastPrice(), 
                stock.getChangePercent(), stock.getName());
        });
        
        <span class="hljs-comment">// 获取跌幅榜</span>
        List&lt;Stock&gt; losers = stockService.getLosers();
        logger.info(<span class="hljs-string">"📉 今日跌幅榜（前5）:"</span>);
        losers.stream().limit(<span class="hljs-number">5</span>).forEach(stock -&gt; {
            logger.info(<span class="hljs-string">"   {}: ₹{} ({}%) - {}"</span>, 
                stock.getSymbol(), stock.getLastPrice(), 
                stock.getChangePercent(), stock.getName());
        });
    }
    
    <span class="hljs-comment">/**
     * 打印股票信息
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStockInfo</span><span class="hljs-params">(Stock stock, String description)</span> {
        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span>) {
            <span class="hljs-type">String</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> stock.getIsOpen() ? <span class="hljs-string">"🟢 交易中"</span> : <span class="hljs-string">"🔴 已收盘"</span>;
            <span class="hljs-type">String</span> <span class="hljs-variable">trend</span> <span class="hljs-operator">=</span> stock.getChangePercent().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"📈"</span> : <span class="hljs-string">"📉"</span>;
            
            logger.info(<span class="hljs-string">"{} {} - {}"</span>, trend, description, status);
            logger.info(<span class="hljs-string">"   代码: {} | 价格: ₹{}"</span>, stock.getSymbol(), stock.getLastPrice());
            logger.info(<span class="hljs-string">"   涨跌: ₹{} ({}{}%)"</span>, stock.getChange(), 
                stock.getChangePercent().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"+"</span> : <span class="hljs-string">""</span>,
                stock.getChangePercent());
            logger.info(<span class="hljs-string">"   最高: ₹{} | 最低: ₹{} | 成交量: {}"</span>, 
                stock.getHigh(), stock.getLow(), stock.getVolume());
            
            <span class="hljs-keyword">if</span> (stock.getTechnicalDay() != <span class="hljs-literal">null</span>) {
                logger.info(<span class="hljs-string">"   技术指标: {}"</span>, getTechnicalIndicatorName(stock.getTechnicalDay()));
            }
        }
    }
    
    <span class="hljs-comment">/**
     * 获取技术指标中文名称
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getTechnicalIndicatorName</span><span class="hljs-params">(String indicator)</span> {
        <span class="hljs-keyword">switch</span> (indicator) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"strong_buy"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"强烈买入"</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"buy"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"买入"</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"neutral"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"中性"</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"sell"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"卖出"</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"strong_sell"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"强烈卖出"</span>;
            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> indicator;
        }
    }
}
</code></pre>
<h2 data-id="heading-16">🎯 高级功能</h2>
<h3 data-id="heading-17">自定义股票监控器</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.stocktv.india.advanced;

<span class="hljs-keyword">import</span> com.stocktv.india.model.Stock;
<span class="hljs-keyword">import</span> com.stocktv.india.service.IndiaStockService;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**
 * 股票价格监控器
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockPriceMonitor</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StockPriceMonitor.class);
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IndiaStockService stockService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService scheduler;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Stock&gt; lastPrices;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; monitoredSymbols;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockPriceMonitor</span><span class="hljs-params">(String apiKey)</span> {
        <span class="hljs-built_in">this</span>.stockService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndiaStockService</span>(apiKey);
        <span class="hljs-built_in">this</span>.scheduler = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);
        <span class="hljs-built_in">this</span>.lastPrices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-built_in">this</span>.monitoredSymbols = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
    }
    
    <span class="hljs-comment">/**
     * 添加监控股票
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addStock</span><span class="hljs-params">(String symbol)</span> {
        monitoredSymbols.add(symbol);
        logger.info(<span class="hljs-string">"添加监控股票: {}"</span>, symbol);
    }
    
    <span class="hljs-comment">/**
     * 开始监控
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startMonitoring</span><span class="hljs-params">()</span> {
        logger.info(<span class="hljs-string">"开始股票价格监控..."</span>);
        scheduler.scheduleAtFixedRate(<span class="hljs-built_in">this</span>::checkPrices, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);
    }
    
    <span class="hljs-comment">/**
     * 停止监控
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopMonitoring</span><span class="hljs-params">()</span> {
        scheduler.shutdown();
        stockService.close();
        logger.info(<span class="hljs-string">"股票价格监控已停止"</span>);
    }
    
    <span class="hljs-comment">/**
     * 检查价格变化
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPrices</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            List&lt;Stock&gt; currentStocks = stockService.getStocksBySymbols(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(monitoredSymbols));
            
            <span class="hljs-keyword">for</span> (Stock currentStock : currentStocks) {
                <span class="hljs-type">String</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> currentStock.getSymbol();
                <span class="hljs-type">Stock</span> <span class="hljs-variable">lastStock</span> <span class="hljs-operator">=</span> lastPrices.get(symbol);
                
                <span class="hljs-keyword">if</span> (lastStock != <span class="hljs-literal">null</span>) {
                    <span class="hljs-comment">// 检查价格变化</span>
                    <span class="hljs-type">double</span> <span class="hljs-variable">priceChange</span> <span class="hljs-operator">=</span> currentStock.getLastPrice().subtract(lastStock.getLastPrice()).doubleValue();
                    <span class="hljs-type">double</span> <span class="hljs-variable">percentChange</span> <span class="hljs-operator">=</span> currentStock.getChangePercent().doubleValue();
                    
                    <span class="hljs-comment">// 价格预警逻辑</span>
                    <span class="hljs-keyword">if</span> (Math.abs(percentChange) &gt; <span class="hljs-number">2.0</span>) {
                        logger.warn(<span class="hljs-string">"🚨 股票 {} 价格波动超过2%: {}%"</span>, 
                            symbol, percentChange);
                    }
                    
                    <span class="hljs-comment">// 技术指标变化</span>
                    <span class="hljs-keyword">if</span> (!Objects.equals(currentStock.getTechnicalDay(), lastStock.getTechnicalDay())) {
                        logger.info(<span class="hljs-string">"📊 股票 {} 技术指标变化: {} → {}"</span>, 
                            symbol, lastStock.getTechnicalDay(), currentStock.getTechnicalDay());
                    }
                }
                
                <span class="hljs-comment">// 更新最后价格</span>
                lastPrices.put(symbol, currentStock);
            }
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            logger.error(<span class="hljs-string">"价格监控执行失败"</span>, e);
        }
    }
    
    <span class="hljs-comment">/**
     * 获取监控报告
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMonitoringReport</span><span class="hljs-params">()</span> {
        logger.info(<span class="hljs-string">"=== 股票监控报告 ==="</span>);
        lastPrices.values().forEach(stock -&gt; {
            <span class="hljs-type">String</span> <span class="hljs-variable">trend</span> <span class="hljs-operator">=</span> stock.getChangePercent().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"🟢"</span> : <span class="hljs-string">"🔴"</span>;
            logger.info(<span class="hljs-string">"{} {}: ₹{} ({}{}%)"</span>, 
                trend, stock.getSymbol(), stock.getLastPrice(),
                stock.getChangePercent().doubleValue() &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"+"</span> : <span class="hljs-string">""</span>,
                stock.getChangePercent());
        });
    }
}
</code></pre>
<h2 data-id="heading-18">⚠️ 注意事项</h2>
<h3 data-id="heading-19">1. 错误处理最佳实践</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 自定义异常类
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StockTVException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockTVException</span><span class="hljs-params">(String message)</span> {
        <span class="hljs-built_in">super</span>(message);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockTVException</span><span class="hljs-params">(String message, Throwable cause)</span> {
        <span class="hljs-built_in">super</span>(message, cause);
    }
}

<span class="hljs-comment">/**
 * 重试机制
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryableStockService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RETRIES</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RETRY_DELAY_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;
    
    <span class="hljs-keyword">public</span> Stock <span class="hljs-title function_">getStockWithRetry</span><span class="hljs-params">(String symbol)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (retries &lt; MAX_RETRIES) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-type">IndiaStockService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndiaStockService</span>(<span class="hljs-string">"API_KEY"</span>);
                <span class="hljs-keyword">return</span> service.getStockBySymbol(symbol);
            } <span class="hljs-keyword">catch</span> (Exception e) {
                retries++;
                <span class="hljs-keyword">if</span> (retries == MAX_RETRIES) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockTVException</span>(<span class="hljs-string">"获取股票数据失败，已达到最大重试次数"</span>, e);
                }
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(RETRY_DELAY_MS);
                } <span class="hljs-keyword">catch</span> (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockTVException</span>(<span class="hljs-string">"重试过程被中断"</span>, ie);
                }
            }
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockTVException</span>(<span class="hljs-string">"未知错误"</span>);
    }
}
</code></pre>
<h3 data-id="heading-20">2. 性能优化建议</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 数据缓存示例
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StockDataCache</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Stock&gt; stockCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Long, List&lt;KLine&gt;&gt; klineCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">cacheTimeoutMs</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 5分钟缓存</span>
    
    <span class="hljs-keyword">public</span> Stock <span class="hljs-title function_">getCachedStock</span><span class="hljs-params">(String symbol, IndiaStockService service)</span> {
        <span class="hljs-type">Stock</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> stockCache.get(symbol);
        <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span> &amp;&amp; 
            System.currentTimeMillis() - cached.getTimestamp() * <span class="hljs-number">1000</span> &lt; cacheTimeoutMs) {
            <span class="hljs-keyword">return</span> cached;
        }
        
        <span class="hljs-type">Stock</span> <span class="hljs-variable">fresh</span> <span class="hljs-operator">=</span> service.getStockBySymbol(symbol);
        stockCache.put(symbol, fresh);
        <span class="hljs-keyword">return</span> fresh;
    }
}
</code></pre>
<h2 data-id="heading-21">📞 技术支持</h2>
<p>如果在使用过程中遇到问题，可以通过以下方式获取帮助：</p>
<ol>
<li><strong>查看日志</strong>: 启用DEBUG级别日志查看详细请求信息</li>
<li><strong>检查网络</strong>: 确保可以正常访问 <code>api.stocktv.top</code></li>
<li><strong>验证API Key</strong>: 确认API Key有效且具有相应权限</li>
<li><strong>联系支持</strong>: 通过官方渠道获取技术支持</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[浏览器渲染原理深度解析：从HTML/CSS/JS到像素的完整旅程]]></title>    <link>https://juejin.cn/post/7570648023111434278</link>    <guid>https://juejin.cn/post/7570648023111434278</guid>    <pubDate>2025-11-10T07:49:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570648023111434278" data-draft-id="7570646659866116122" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="浏览器渲染原理深度解析：从HTML/CSS/JS到像素的完整旅程"/> <meta itemprop="keywords" content="HTML,CSS"/> <meta itemprop="datePublished" content="2025-11-10T07:49:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Tzarevich"/> <meta itemprop="url" content="https://juejin.cn/user/578786070367529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            浏览器渲染原理深度解析：从HTML/CSS/JS到像素的完整旅程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578786070367529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Tzarevich
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T07:49:30.000Z" title="Mon Nov 10 2025 07:49:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">浏览器渲染原理深度解析：从HTML/CSS/JS到像素的完整旅程</h2>
<h3 data-id="heading-1">引言：数字世界的魔法</h3>
<p>在现代 Web 开发中，HTML、CSS 和 JavaScript 三者共同构成了网页的核心骨架、样式和行为。当我们打开浏览器，输入网址，瞬间就能看到精美的网页界面。这看似简单的过程背后，实则是一场精密的数字魔法。作为一名前端开发者，深入理解浏览器渲染机制不仅是技能提升的必经之路，更是编写高性能Web应用的基础。本文将带您深入探索浏览器如何将HTML、CSS和JavaScript代码转换为我们所见的可视化界面。</p>
<h3 data-id="heading-2">一、渲染流程全景图</h3>
<h4 data-id="heading-3">1. 宏观渲染流水线</h4>
<p>浏览器渲染过程可以概括为一个复杂的多阶段流水线：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">HTML</span>/CSS/JS 输入 → 浏览器(Chrome) → 渲染引擎 → 解析处理 → 生成DOM树/CSSOM树/执行JS → 渲染树 → 布局 → 绘制 → 合成
</code></pre>
<h4 data-id="heading-4">2. 渲染的核心挑战</h4>
<p><strong>流程复杂性</strong>：从字符串解析到像素绘制，涉及多个解析器、多个处理阶段和复杂的计算逻辑。</p>
<p><strong>时间开销</strong>：每个阶段都可能成为性能瓶颈，特别是在移动设备或处理复杂页面时。</p>
<p><strong>性能优化必要性</strong>：理解渲染流程是进行有效性能优化的前提，只有知道时间花在哪里，才能有针对性地优化。</p>
<h3 data-id="heading-5">二、HTML解析与DOM树构建</h3>
<h4 data-id="heading-6">1. HTML 的本质是字符串</h4>
<p>HTML 文件本质上是一段纯文本字符串。浏览器无法直接操作字符串来渲染页面，因此必须将其转换为一种可编程、可遍历的数据结构——<strong>DOM 树</strong>。</p>
<h4 data-id="heading-7">2. 解析过程</h4>
<ul>
<li>浏览器通过 <strong>HTML 解析器（HTML Parser）</strong>  逐字符读取 HTML。</li>
<li>遇到标签（如 <code>&lt;div&gt;</code>）、文本、注释等内容时，会创建对应的 <strong>节点（Node）</strong> 。</li>
<li>节点之间根据嵌套关系形成父子、兄弟等层级结构，最终构成一棵树。</li>
</ul>
<p>例如：</p>
<pre><code class="hljs language-xml" lang="xml">Html
预览
1<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
2  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
3  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
4    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
5    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
6  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
7<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>会被解析为如下 DOM 树结构（简化）：</p>
<pre><code class="hljs language-bash" lang="bash">Text
编辑
1html
2├── <span class="hljs-built_in">head</span>
3│   └── title → <span class="hljs-string">"示例"</span>
4└── body
5    ├── h1 → <span class="hljs-string">"Hello"</span>
6    └── p → <span class="hljs-string">"World"</span>
</code></pre>
<h4 data-id="heading-8">3. DOM树的本质特征</h4>
<p>DOM树具有以下重要特性：</p>
<ul>
<li><strong>层次结构</strong>：反映HTML标签的嵌套关系</li>
<li><strong>节点类型</strong>：元素节点、文本节点、属性节点等</li>
<li><strong>内存表示</strong>：整个DOM树驻留在内存中，可通过JavaScript访问和操作</li>
<li><strong>动态更新</strong>：可以通过JavaScript动态修改DOM结构</li>
</ul>
<h4 data-id="heading-9">4. HTML语义化的深远影响</h4>
<ul>
<li><strong>结构语义化标签</strong>（如 <code>&lt;header&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;section&gt;</code>）不仅帮助开发者组织内容，也便于搜索引擎（SEO）理解页面结构。</li>
<li><strong>功能语义化标签</strong>（如 <code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code>、<code>&lt;code&gt;</code>、<code>&lt;p&gt;</code>）则明确表达了内容的类型和层级。</li>
</ul>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 非语义化写法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"header"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main-content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"footer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 语义化写法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
</code></pre>
<p>语义化标签不仅使代码更易读，更重要的是为浏览器和搜索引擎提供了明确的语义信息。</p>
<h5 data-id="heading-10">SEO优化机制</h5>
<p>搜索引擎通过爬虫程序分析网页内容，语义化标签帮助爬虫：</p>
<ul>
<li>准确识别页面各个部分的作用</li>
<li>理解内容的重要性和相关性</li>
<li>建立内容之间的逻辑关系</li>
</ul>
<h5 data-id="heading-11">渲染性能优化</h5>
<p>通过合理的标签顺序和语义化结构，可以优化渲染性能：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 通过CSS调整视觉顺序而不改变DOM顺序 */</span>
<span class="hljs-selector-tag">main</span> { <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>; }
<span class="hljs-selector-tag">aside</span> { <span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>; }
</code></pre>
<p>这样既保证了重要内容在DOM中优先出现，又实现了期望的视觉布局。</p>
<h3 data-id="heading-12">三、CSS解析与CSSOM树构建</h3>
<h4 data-id="heading-13">1. 从样式表到样式树</h4>
<p>与HTML解析类似，CSS也需要从文本格式转换为计算机易于处理的结构化数据。<strong>CSSOM（CSS Object Model）树</strong>就是这个转换的结果，这是一种包含所有样式规则的对象模型。</p>
<h4 data-id="heading-14">2. 解析规则</h4>
<ul>
<li>浏览器读取 CSS 规则（如 <code>div { color: red; }</code>）。</li>
<li>将选择器与声明分离，构建出“选择器 → 样式属性”的映射。</li>
<li>最终形成一棵树，每个节点代表一个样式规则，并按优先级（层叠、继承、特异性）进行整合。</li>
</ul>
<h4 data-id="heading-15">3. CSSOM与DOM的结合</h4>
<p>单独的 DOM 或 CSSOM 都无法渲染页面，CSSOM树构建完成后，浏览器需要将其与DOM树结合，这个过程包括：</p>
<ul>
<li><strong>选择器匹配</strong>：为每个DOM元素找到所有适用的CSS规则</li>
<li><strong>值计算</strong>：将相对单位转换为绝对像素值</li>
<li><strong>样式继承</strong>：处理可继承属性的传播</li>
<li><strong>层叠处理</strong>：根据优先级和顺序确定最终样式</li>
</ul>
<p>浏览器将两者结合，为每个 DOM 节点附加其最终计算后的样式，生成 <strong>渲染树（Render Tree）</strong></p>
<h3 data-id="heading-16">四、渲染树与布局计算</h3>
<h4 data-id="heading-17">1.渲染树的构建</h4>
<p>渲染树是DOM树和CSSOM树的结合体，但只包含可见内容：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- DOM树中的元素 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display: none;"</span>&gt;</span>隐藏内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"visibility: hidden;"</span>&gt;</span>不可见但占位<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>可见内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>在渲染树中：</p>
<ul>
<li><code>display: none</code> 的元素完全不会出现</li>
<li><code>visibility: hidden</code> 的元素会保留位置但不可见</li>
<li>只有真正可见的元素才会进入渲染树</li>
</ul>
<h4 data-id="heading-18">4.2 布局（重排）过程</h4>
<p>布局阶段计算每个元素在屏幕上的精确位置和尺寸：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
}
</code></pre>
<p><strong>布局计算包括</strong>：</p>
<ul>
<li><strong>盒模型计算</strong>：content + padding + border + margin</li>
<li><strong>位置计算</strong>：相对定位、绝对定位、固定定位</li>
<li><strong>浮动处理</strong>：文本环绕和清除浮动</li>
<li><strong>Flexbox/Grid布局</strong>：现代布局系统的复杂计算</li>
</ul>
<h4 data-id="heading-19">4.3 布局性能优化</h4>
<p>布局是渲染流程中最昂贵的操作之一，优化策略包括：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好：多次触发布局</span>
element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">'100px'</span>;
<span class="hljs-keyword">const</span> height = element.<span class="hljs-property">offsetHeight</span>; <span class="hljs-comment">// 触发布局</span>
element.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = height + <span class="hljs-string">'px'</span>;

<span class="hljs-comment">// 好：批量读写</span>
<span class="hljs-keyword">const</span> height = element.<span class="hljs-property">offsetHeight</span>; <span class="hljs-comment">// 读取</span>
element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">'100px'</span>;       <span class="hljs-comment">// 写入</span>
element.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = height + <span class="hljs-string">'px'</span>; <span class="hljs-comment">// 写入</span>
</code></pre>
<h3 data-id="heading-20">五、JavaScript的执行与交互</h3>
<h4 data-id="heading-21">1. JavaScript引擎与渲染引擎的协作</h4>
<p>JavaScript执行会阻塞DOM解析和渲染：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 同步脚本会阻塞解析</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;p&gt;动态内容&lt;/p&gt;'</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"defer-script.js"</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"async-script.js"</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><strong>关键问题：为什么 JS 会阻塞？</strong></p>
<ul>
<li>因为 JS 可能通过 <code>document.write()</code> 修改 HTML，或通过 <code>appendChild</code> 动态插入新节点。</li>
<li>为保证一致性，浏览器在遇到 <code>&lt;script&gt;</code> 标签时会暂停 HTML 解析，直到脚本下载并执行完毕。</li>
</ul>
<blockquote>
<p>🚫 示例（阻塞）：</p>
</blockquote>
<pre><code class="hljs language-xml" lang="xml">Html
预览
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- 阻塞后续 HTML 解析 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这部分内容会被延迟解析<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><strong>加载策略</strong>：</p>
<ul>
<li><strong>同步脚本</strong>：立即执行，阻塞解析</li>
<li><strong>defer</strong>：异步加载，DOM解析完成后执行</li>
<li><strong>async</strong>：异步加载，加载完成后立即执行</li>
</ul>
<h4 data-id="heading-22">2. 事件循环与渲染调度</h4>
<p>浏览器通过事件循环机制协调JavaScript执行和渲染：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用requestAnimationFrame优化动画</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"/>) {
    element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translateX(<span class="hljs-subst">${position}</span>px)`</span>;
    position += <span class="hljs-number">1</span>;
    <span class="hljs-title function_">requestAnimationFrame</span>(animate);
}
<span class="hljs-title function_">requestAnimationFrame</span>(animate);
</code></pre>
<h3 data-id="heading-23">六、性能优化实战</h3>
<h4 data-id="heading-24">1. 关键渲染路径优化</h4>
<p><strong>优化目标</strong>：缩短首次有意义渲染的时间</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 关键CSS内联 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-comment">/* 首屏关键样式 */</span>
<span class="hljs-selector-class">.header</span>, <span class="hljs-selector-class">.main-content</span> { <span class="hljs-comment">/* ... */</span> }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 非关键CSS异步加载 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"non-critical.css"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"style"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"this.rel='stylesheet'"</span>&gt;</span>
</code></pre>
<h4 data-id="heading-25">2. 减少重排和重绘</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用DocumentFragment批量操作DOM</span>
<span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'li'</span>);
    li.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>;
    fragment.<span class="hljs-title function_">appendChild</span>(li);
}
list.<span class="hljs-title function_">appendChild</span>(fragment);
</code></pre>
<h4 data-id="heading-26">3. 现代CSS布局优化</h4>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 使用Flexbox避免浮动布局的重排问题 */</span>
<span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 使用gap替代margin */</span>
}

<span class="hljs-comment">/* 使用Grid实现复杂布局 */</span>
<span class="hljs-selector-class">.grid-layout</span> {
    <span class="hljs-attribute">display</span>: grid;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">250px</span>, <span class="hljs-number">1</span>fr));
}
</code></pre>
<h3 data-id="heading-27">结语</h3>
<p>浏览器渲染是一个极其复杂但又精妙协调的过程。从HTML字符串到屏幕像素，每一个阶段都体现了计算机科学的深度和浏览器的工程智慧。作为前端开发者，深入理解这一过程不仅能够帮助我们编写更高效的代码，更重要的是能够培养出对Web性能的直觉和对用户体验的深刻理解。</p>
<p>随着Web技术的不断发展，渲染优化仍然是我们需要持续学习和探索的重要领域。只有深入理解底层原理，才能在面对新的技术挑战时游刃有余，创造出真正优秀的Web体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue 3 超强二维码识别：多区域/多尺度扫描 + 高级图像处理]]></title>    <link>https://juejin.cn/post/7570598043298070591</link>    <guid>https://juejin.cn/post/7570598043298070591</guid>    <pubDate>2025-11-10T08:07:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570598043298070591" data-draft-id="7570500819889438763" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue 3 超强二维码识别：多区域/多尺度扫描 + 高级图像处理"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2025-11-10T08:07:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹏北海"/> <meta itemprop="url" content="https://juejin.cn/user/1425415102792237"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue 3 超强二维码识别：多区域/多尺度扫描 + 高级图像处理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1425415102792237/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹏北海
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:07:22.000Z" title="Mon Nov 10 2025 08:07:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue 3 超强二维码识别：多区域/多尺度扫描 + 高级图像处理</h2>
<p>在前端项目里做二维码识别，经常会遇到“背景复杂识别难”“二维码很小识别率低”“识别慢”的痛点。本文给大家介绍一个基于 Vue 3 的二维码识别工具库 —— <code>vue-qrcode-scanner</code>，主打“识别稳、速度快、接入简单”。</p>
<ul>
<li>支持多区域/多尺度扫描，优先命中高概率区域，提升首识别速度</li>
<li>内置多种图像预处理：OTSU、自适应阈值、锐化、对比度拉伸，复杂背景也能顶住</li>
<li>提供 Vue Composable API + 工具函数两套用法</li>
<li>TypeScript 全量类型，开发体验友好</li>
</ul>
<p>开源地址与安装方式见文末，欢迎 Star 与反馈问题。</p>
<h3 data-id="heading-1">✨ 功能亮点</h3>
<ul>
<li><strong>Vue 3 Composable</strong>：使用 Composition API，接入成本低</li>
<li><strong>多区域扫描</strong>：优先常见位置（如右下角）+ 滑动窗口策略</li>
<li><strong>多尺度扫描</strong>：自动在不同缩放级别尝试识别</li>
<li><strong>自动定位</strong>：返回二维码位置坐标，可视化标记更方便</li>
<li><strong>高级图像处理</strong>：OTSU、自适应阈值、锐化、对比度拉伸</li>
<li><strong>零依赖</strong>：除 Vue 以外无额外依赖（二维码识别算法使用 <code>jsQR</code>）</li>
<li><strong>TypeScript 支持</strong>：完整类型定义，二次开发舒适</li>
</ul>
<h3 data-id="heading-2">📦 安装</h3>
<pre><code class="hljs language-bash" lang="bash">npm install vue-qrcode-scanner
<span class="hljs-comment"># 或</span>
yarn add vue-qrcode-scanner
<span class="hljs-comment"># 或</span>
pnpm add vue-qrcode-scanner
</code></pre>
<p>识别二维码需要 <code>jsQR</code> 算法库，请一并安装：</p>
<pre><code class="hljs language-bash" lang="bash">npm install jsqr
</code></pre>
<h3 data-id="heading-3">🚀 快速开始（Composable 用法）</h3>
<p>最简集成方式：直接在组件里调用 <code>useQRCodeScanner</code>。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">"handleFileSelect"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"image/*"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"parseQRCode"</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"isLoading"</span>&gt;</span>
      {{ isLoading ? "解析中..." : "解析二维码" }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 可选：Canvas 用于预览/辅助处理 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"canvas"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display: none"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"resultMessage"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"resultClass"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"resultMessage"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
<span class="hljs-keyword">import</span> { useQRCodeScanner } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-qrcode-scanner/composables"</span>;

<span class="hljs-keyword">const</span> selectedFile = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);

<span class="hljs-keyword">const</span> {
  resultMessage,
  isLoading,
  qrCode,
  canvas,
  resultClass,
  parseQRFromFile,
  clearResult,
} = <span class="hljs-title function_">useQRCodeScanner</span>();

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFileSelect</span> = (<span class="hljs-params">event</span>) =&gt; {
  selectedFile.<span class="hljs-property">value</span> = event.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">parseQRCode</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">if</span> (selectedFile.<span class="hljs-property">value</span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">parseQRFromFile</span>(selectedFile.<span class="hljs-property">value</span>);
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-4">🌐 从 URL 解析</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { useQRCodeScanner } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-qrcode-scanner/composables"</span>;

<span class="hljs-keyword">const</span> { parseQRFromUrl } = <span class="hljs-title function_">useQRCodeScanner</span>();

<span class="hljs-keyword">const</span> code = <span class="hljs-keyword">await</span> <span class="hljs-title function_">parseQRFromUrl</span>(<span class="hljs-string">"https://example.com/qrcode.png"</span>);
<span class="hljs-keyword">if</span> (code) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"二维码内容:"</span>, code.<span class="hljs-property">data</span>);
}
</code></pre>
<h3 data-id="heading-5">🧩 高级用法（直接使用工具函数）</h3>
<p>你也可以跳过 Composable，直接使用底层的图像处理与扫描工具：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { imageProcessors, qrScanner } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-qrcode-scanner"</span>;

<span class="hljs-comment">// 1) 图像预处理（灰度化、OTSU、自适应阈值、锐化、对比度拉伸等）</span>
<span class="hljs-keyword">const</span> imageData = ctx.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
<span class="hljs-keyword">const</span> processed = imageProcessors.<span class="hljs-title function_">preprocessImage</span>(imageData);

<span class="hljs-comment">// 2) 多区域/多尺度扫描</span>
<span class="hljs-keyword">const</span> code = qrScanner.<span class="hljs-title function_">scanRegions</span>(ctx, width, height);
<span class="hljs-keyword">if</span> (code) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"二维码内容:"</span>, code.<span class="hljs-property">data</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"位置:"</span>, code.<span class="hljs-property">location</span>);
}
</code></pre>
<h3 data-id="heading-6">🛠 API 摘要</h3>
<h4 data-id="heading-7">Composable: <code>useQRCodeScanner()</code></h4>
<ul>
<li>响应式状态：<code>resultMessage</code>、<code>isLoading</code>、<code>qrCode</code>、<code>canvas</code>、<code>resultClass</code></li>
<li>方法：
<ul>
<li><code>parseQRFromFile(file: File): Promise&lt;QRCode | null&gt;</code></li>
<li><code>parseQRFromUrl(url: string): Promise&lt;QRCode | null&gt;</code></li>
<li><code>clearResult(): void</code></li>
<li><code>showCanvasPreview(): void</code></li>
<li><code>hideCanvasPreview(): void</code></li>
</ul>
</li>
</ul>
<h4 data-id="heading-8">工具函数: <code>imageProcessors</code></h4>
<ul>
<li><code>grayscale(imageData: ImageData): GrayData</code></li>
<li><code>otsuThreshold(grayData: Uint8ClampedArray): number</code></li>
<li><code>adaptiveThreshold(grayData, width, height, blockSize?, C?): Uint8ClampedArray</code></li>
<li><code>sharpen(grayData, width, height): Uint8ClampedArray</code></li>
<li><code>contrastStretch(grayData, minPercent?, maxPercent?): Uint8ClampedArray</code></li>
<li><code>preprocessImage(imageData: ImageData): ProcessedImage[]</code></li>
</ul>
<h4 data-id="heading-9">工具函数: <code>qrScanner</code></h4>
<ul>
<li><code>tryDecodeQR(imageData: ImageData): QRCode | null</code></li>
<li><code>scanRegions(ctx, imgWidth, imgHeight): QRCode | null</code></li>
<li><code>scanMultiScale(ctx, canvasElement, imgWidth, imgHeight): QRCode | null</code></li>
<li><code>adjustCodeLocation(code, offsetX, offsetY): QRCode</code></li>
<li><code>cropImageRegion(ctx, x, y, width, height): ImageData</code></li>
</ul>
<h4 data-id="heading-10">类型定义（节选）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">QRCode</span> {
  <span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>;
  format?: <span class="hljs-built_in">string</span>;
  location?: <span class="hljs-title class_">QRCodeLocation</span>;
  regionName?: <span class="hljs-built_in">string</span>;
  preprocessMethod?: <span class="hljs-built_in">string</span>;
  scale?: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">QRCodeLocation</span> {
  <span class="hljs-attr">topLeftCorner</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> };
  <span class="hljs-attr">topRightCorner</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> };
  <span class="hljs-attr">bottomLeftCorner</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> };
  <span class="hljs-attr">bottomRightCorner</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> };
}
</code></pre>
<h3 data-id="heading-11">⚠️ 注意事项 &amp; 实战经验</h3>
<ol>
<li><code>jsQR</code> 为解析核心库，请确保已安装并正确引入</li>
<li>浏览器需支持 Canvas API；跨域图片请确保 CORS 允许，否则无法读取像素</li>
<li>大尺寸图片建议先等比压缩到合适尺寸（如最长边不超过 2000px）以提升速度</li>
<li>复杂背景下建议多尝试预处理组合（库内已内置多策略自动尝试）</li>
<li>如果需要在 UI 中高亮二维码位置，可结合返回的 <code>location</code> 四点坐标绘制</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React SSR 技术实现原理]]></title>    <link>https://juejin.cn/post/7570659828811202594</link>    <guid>https://juejin.cn/post/7570659828811202594</guid>    <pubDate>2025-11-10T08:08:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570659828811202594" data-draft-id="7570341520550395919" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React SSR 技术实现原理"/> <meta itemprop="keywords" content="React.js,算法"/> <meta itemprop="datePublished" content="2025-11-10T08:08:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="骑自行车的码农"/> <meta itemprop="url" content="https://juejin.cn/user/4195392103390061"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React SSR 技术实现原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4195392103390061/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    骑自行车的码农
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:08:12.000Z" title="Mon Nov 10 2025 08:08:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>著有《React 源码》《React 用到的一些算法》《javascript地月星》等多个专栏。欢迎关注。</p>
<p>文章不好写，要是有帮助别忘了点赞，收藏～ 你的鼓励是我继续挖干货的的动力🔥。</p>
<p>另外，本文为原创内容，商业转载请联系作者获得授权，非商业转载需注明出处，感谢理解～</p>
</blockquote>
<h2 data-id="heading-0">第一部分</h2>
<p>之前写过一篇<a href="https://juejin.cn/post/7549131152999596067" target="_blank" title="https://juejin.cn/post/7549131152999596067">React SSR 设计原理</a>阅读量不高，感觉写的还可以，所以重新整理和增加了一些内容，再发一遍。末尾的“总结”非常值得看一下，感觉没有人把SSR解读的这么彻底。记得点赞哦～👍。</p>
<h3 data-id="heading-1">SSR搭建 四个角色</h3>
<p>server服务器(server.js) + server ssr返回纯html首页（entry-server.jsx) + client hydrateRoot注水给html，把 Fiber 树挂接到现有 DOM 上(对应client.jsx)，给 DOM 节点加上 React 的事件绑定、内部状态，使 DOM 变“活”。</p>
<p>流程：请求server服务器（server.js)，返回首页内容（entry-server.jsx) ----&gt;  首页下载脚本client.jsx，client.jsx执行hydrateRoot水合，React接管。</p>
<p>所以能看到四个角色:【server.js】【entry-server.jsx】【client.jsx】【App.jsx LazyComp.jsx】。<br/>
其中【App.jsx LazyComp.jsx】这两个属于公共的，服务端和客户端都用到。</p>
<pre><code class="hljs language-sql" lang="sql">my<span class="hljs-operator">-</span>react<span class="hljs-operator">-</span>app
 ├── dist<span class="hljs-operator">/</span>
 │    ├── server<span class="hljs-operator">/</span>
 │    │    └── server.js   ← 这个在 Node 跑，不会发给客户端 打包前是entry<span class="hljs-operator">-</span>server.jsx
 │    └── client<span class="hljs-operator">/</span>
 │         └── client.js         ← 这个才会发给浏览器
 ├── server.js  和上面的server.js不同同一个，node server.js启动的是这个

在提供的例子中还有App.jsx LazyComp.jsx的打包没有在上方体现，简化逻辑，主要就是这<span class="hljs-number">3</span>方。
App  LazyComp在服务的和客户端都被使用属于公共的。
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36b1d503216543e4811900889ba2724b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=AYJBcNjiqbcA55rqwBlbGkpD67w%3D" alt="" loading="lazy"/></p>
<blockquote>
<p>我改了打包目录部分的配置，打包后的目录不一样了，不影响阅读</p>
</blockquote>
<h3 data-id="heading-2">运行两遍React组件</h3>
<p>在服务器端执行一遍React组件，生成html后返回纯html给客户端，完成首次渲染。<br/>
在客户端执行client.js进行水合，再次执行一遍React组件，创建Fiber、挂接到DOM、绑定事件等。</p>
<pre><code class="hljs language-jsx" lang="jsx">entry-server.<span class="hljs-property">jsx</span>
<span class="hljs-keyword">const</span> { pipe } = <span class="hljs-title function_">renderToPipeableStream</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, {...<span class="hljs-title function_">pipe</span>(res)...})

注意这里的&lt;<span class="hljs-title class_">App</span>/&gt;经过打包后是，
<span class="hljs-keyword">const</span> { pipe } = <span class="hljs-title function_">renderToPipeableStream</span>(<span class="hljs-comment">/* @__PURE__ */</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">App</span>, <span class="hljs-literal">null</span>), {...<span class="hljs-title function_">pipe</span>(res)...})
服务端运行<span class="hljs-title class_">React</span>.<span class="hljs-property">createElement</span>得到<span class="hljs-title class_">App</span>的html。

明显已经运行了一遍<span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">App</span>, <span class="hljs-literal">null</span>)，纯<span class="hljs-title class_">App</span>的html。
下面在客户端还会运行一遍。
</code></pre>
<p>返回App的纯html，通过pipe能获取，在option中注入。</p>
<p>客户端会再运行一遍。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"root"</span>), <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);
打包后：
<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"root"</span>), <span class="hljs-comment">/* @__PURE__ */</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">App</span>, <span class="hljs-literal">null</span>));
</code></pre>
<p>这一遍叫水合。没有水合前是纯html的页面。水合后被React接管。<br/>
例如在后面的实践例子中，第8秒在vscode打印一次，第16秒在浏览器打印一次。</p>
<h3 data-id="heading-3">HTML的水合</h3>
<p>水合就是给服务端的返回的HTML的DOM添加internalInstanceKey，能找到它的Fiber。</p>
<p>变量internalInstanceKey，值类似于__reactFiber$chytmrjmd38，__reactFiber$+随机数。<br/>
每个真实DOM都有__reactFiber$...属性，指向真实DOM对应的Fiber Node。<br/>
如果真实DOM没有__reactFiber$...表示这个DOM没有受到React的管理，例如SSR时服务端返回的HTML。<br/>
我简单的把“给DOM添加__reactFiber$..属性”一起归到hydrateRoot()。（实际hydrateRoot没有做这件事。添加属性是触发任意事件的时候做的），有对应的Fiber Node，这个DOM就被React接管了。</p>













<table><thead><tr><th>水合前 只是简单的html 没有__reactFiber$...属性</th><th>水合后 多了__reactFiber$...属性</th></tr></thead><tbody><tr><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44c7884d899d407ea03b98ad53f0c01f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=h2tmXyTC6iZoEVCLT3s7Otim0oY%3D" alt="" loading="lazy"/></td><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4ed097f450f474d80e18002ed04c76b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=LbKLxBy56i%2B1bccgHZxwI7DqFfU%3D" alt="" loading="lazy"/></td></tr></tbody></table>
<h3 data-id="heading-4">注释节点</h3>
<p>SSR生成的HTML带有注释</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- $? --&gt;</span>  有internalInstanceKey、受到管理
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        没有internalInstanceKey、没有受到管理
    Loading...
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- /$ --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- $ --&gt;</span>  有internalInstanceKey、受到管理
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>        没有internalInstanceKey、没有受到管理
    Hello World!
  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- /$ --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>React借助注释节点，快速找到SSR内容。如果没有注释节点，无法分辨SSR内容或者要从整个页面全部节点中一个一个查找。<br/>
React中专门查找注释节点的函数<code>getParentSuspenseInstance</code>:</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!--$--&gt;</span>                    ← Suspense A 开始 (pending)  找到这个节点
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Content A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      注释和内容是兄弟节点
  <span class="hljs-comment">&lt;!--$--&gt;</span>                  ← Suspense B 开始 (pending)
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>嵌套<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-comment">&lt;!--/$--&gt;</span>                 ← Suspense B 结束
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"target"</span>&gt;</span>Target<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  ← targetInstance  从这里开始
<span class="hljs-comment">&lt;!--/$--&gt;</span>                   ← Suspense A 结束
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getParentSuspenseInstance</span>(<span class="hljs-params">targetInstance</span>) {
  <span class="hljs-keyword">var</span> node = targetInstance.<span class="hljs-property">previousSibling</span>; 
  <span class="hljs-keyword">var</span> depth = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (node) {
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
      <span class="hljs-keyword">var</span> data = node.<span class="hljs-property">data</span>;<span class="hljs-comment">//node是`&lt;!--$--&gt;`, `&lt;!--$!--&gt;`, `&lt;!--$?--&gt;`, `&lt;!--/$--&gt;` 。data是`$``$!``$?``/$`。</span>

      <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_START_DATA</span> || <span class="hljs-comment">// $</span>
          data === <span class="hljs-variable constant_">SUSPENSE_FALLBACK_START_DATA</span> ||  <span class="hljs-comment">// $!</span>
          data === <span class="hljs-variable constant_">SUSPENSE_PENDING_START_DATA</span>) { <span class="hljs-comment">// $?</span>
        <span class="hljs-comment">// 遇到 Suspense 开始</span>
        <span class="hljs-keyword">if</span> (depth === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// 找到了最外层未闭合的 Suspense，返回</span>
        } <span class="hljs-keyword">else</span> {
          depth--; <span class="hljs-comment">// 退出一层嵌套</span>
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_END_DATA</span>) { <span class="hljs-comment">// /$</span>
        depth++; <span class="hljs-comment">// 遇到结束，说明我们“进入”了一个更外层的 Suspense 范围</span>
      }
    }

    node = node.<span class="hljs-property">previousSibling</span>; <span class="hljs-comment">//从后往前找</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<p>返回&lt;!-- $ --&gt;等的DOM。</p>
<h2 data-id="heading-5">第二部分</h2>
<h3 data-id="heading-6">SSR核心概念</h3>
<p>用官话来讲：</p>
<ul>
<li>同构（Isomorphic / Universal Rendering）指 React 代码既能运行在服务端（Node.js）又能运行在客户端（浏览器）。其实就是在服务的执行一遍react组件。</li>
<li>注水 （Hydration）浏览器接收到服务端生成的 HTML 后，React <strong>不会重新渲染 DOM</strong>，而是“注水”——把 <strong>Fiber 树挂接到现有 DOM</strong> 上。给 DOM 节点加上 React 的事件绑定、内部状态，使 DOM 变“活”。</li>
<li>脱水 (Dehydration)：在 React 18 里，<strong>Suspense 边界可以被“脱水”</strong> ，即保留 fallback 或 HTML 片段，但不立即 hydrate。等到用户交互或资源到达，再对局部进行 hydration。</li>
</ul>
<p>同构是一个宏观目标： 它的目标是让同一套代码既能在服务器上运行（生成 HTML），又能在客户端上运行（处理交互）。它描述的是一种<strong>架构模式</strong>。<br/>
脱水/注水是一个微观实现： 它是实现同构这个<strong>目标</strong>所必须的<strong>技术手段</strong>。</p>
<p>其实就是服务端执行一遍React组件返回HTML。（服务端渲染）<br/>
HTML上的DOM找不到Fiber。（脱水的）<br/>
把Fiber关联到DOM，DOM能找到自己的Fiber（注水）</p>
<h2 data-id="heading-7">第三部分</h2>
<h3 data-id="heading-8">实践例子</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// src/App.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Suspense</span>, lazy } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyComp</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'服务端和客户端都运行一次LazyComp'</span>);---运行两遍<span class="hljs-title class_">React</span>组件：在vscode控制台打印一次，在浏览器控制台打印一次  第<span class="hljs-number">8</span>秒在vscode打印，第<span class="hljs-number">16</span>秒在浏览器打印

      <span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">import</span>(<span class="hljs-string">'./LazyComp'</span>));
    }, <span class="hljs-number">8000</span>); <span class="hljs-comment">// 模拟 8 秒延迟</span>
  });
});

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">LazyComp</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">//client.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom/client"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./App.jsx"</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">22222</span>);
<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"root"</span>), <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);
</code></pre>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// entry-server.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { renderToPipeableStream } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom/server"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./App.jsx"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">res</span>) {
  <span class="hljs-keyword">const</span> { pipe } = <span class="hljs-title function_">renderToPipeableStream</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, {
    <span class="hljs-title function_">onShellReady</span>(<span class="hljs-params"/>) {
      res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"text/html"</span>);
      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;!DOCTYPE html&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;My React App&lt;/title&gt;
            &lt;meta charset="UTF-8"&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;div id="root"&gt;`</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);
      <span class="hljs-title function_">pipe</span>(res);<span class="hljs-comment">//如果把const {pipe}注释掉，会报错 pipe is not defined;</span>
      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;/div&gt;
          &lt;/body&gt;
          &lt;script type="module" src="/dist/client.js"&gt;&lt;/script&gt;
        &lt;/html&gt;`</span>);
    },
  });
}
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// LazyComp.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">LazyComp</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>✅Hello !<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//server.js  在根目录！</span>
<span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">"express"</span>;
<span class="hljs-keyword">import</span> { createServer <span class="hljs-keyword">as</span> createViteServer } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">"url"</span>;

<span class="hljs-keyword">const</span> __dirname = path.<span class="hljs-title function_">dirname</span>(<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>));

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">start</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

  <span class="hljs-comment">// 1. 创建 Vite dev server (中间件模式)</span>
  <span class="hljs-keyword">const</span> vite = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createViteServer</span>({
    <span class="hljs-attr">server</span>: { <span class="hljs-attr">middlewareMode</span>: <span class="hljs-literal">true</span> },
    <span class="hljs-attr">appType</span>: <span class="hljs-string">"custom"</span>
  });

  app.<span class="hljs-title function_">use</span>(vite.<span class="hljs-property">middlewares</span>);

  <span class="hljs-comment">// 2. SSR 路由</span>
  app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/"</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// const { render } = await vite.ssrLoadModule("/src/entry-server.jsx");</span>
      <span class="hljs-keyword">const</span> { render } = <span class="hljs-keyword">await</span> vite.<span class="hljs-title function_">ssrLoadModule</span>(<span class="hljs-string">"/dist/server.js"</span>);
      <span class="hljs-title function_">render</span>(res);
    } <span class="hljs-keyword">catch</span> (e) {
      vite.<span class="hljs-title function_">ssrFixStacktrace</span>(e);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);
      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">end</span>(e.<span class="hljs-property">message</span>);
    }
  });

  app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"🚀 SSR server running at http://localhost:3000"</span>);
  });
}

<span class="hljs-title function_">start</span>();

</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;
<span class="hljs-comment">// import react from '@vitejs/plugin-react';</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-comment">// plugins: [react()],//导入React</span>
  <span class="hljs-attr">define</span>: {
    <span class="hljs-string">"process.env.NODE_ENV"</span>: <span class="hljs-string">'"development"'</span>,
  },
  <span class="hljs-comment">// minify: false,</span>
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//必须是true,是false打包后entry-server.jsx返回render不返回</span>
    <span class="hljs-comment">// sourcemap: true, // 生成 client.js.map</span>
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">input</span>: {
        <span class="hljs-attr">server</span>: <span class="hljs-string">'src/entry-server.jsx'</span>, 
        <span class="hljs-attr">client</span>: <span class="hljs-string">"src/client.jsx"</span>
      },
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">"[name].js"</span>,
      }
    }
  },
});
</code></pre>
<ul>
<li>如果把const {pipe}注释掉，会报错 pipe is not defined;</li>
<li>pipe的原理是res.write。内部借用TextEncoder.encodeInto()、unit8array最后res.write。<br/>
textEncoder.encodeInto()能把数据写入unit8array。</li>
</ul>
<blockquote>
<p>本例子的补充说明vite的index.html和打包:</p>
<p>为了简化，在我们的例子中虽然存在main.jsx、index.html，但是没有用到index.html，而是在entry-server.jsx手写的html。<br/>
这样的缺点是不能利用vite打包自动注入index.html的内容功能。</p>
</blockquote>
<h3 data-id="heading-9">pipe的原理</h3>
<ul>
<li>completeWriting把loading...和✅Hello发送过去。原理就是res.write。res是express请求的response。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//node_modules/react-dom/cjs/react-dom-server.node.development.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWriting</span>(<span class="hljs-params">destination</span>) {<span class="hljs-comment">//destination就是res</span>
  <span class="hljs-keyword">if</span> (currentView &amp;&amp; writtenBytes &gt; <span class="hljs-number">0</span>) {<span class="hljs-comment">//currentView就是unit8Array</span>
    <span class="hljs-comment">// console.log(destination.write(currentView.subarray(0, 64)));</span>
    <span class="hljs-comment">// console.log(destination.write(currentView.subarray(0, 499)));</span>
    destination.<span class="hljs-title function_">write</span>(currentView.<span class="hljs-title function_">subarray</span>(<span class="hljs-number">0</span>, writtenBytes));
  }
  currentView = <span class="hljs-literal">null</span>;
  writtenBytes = <span class="hljs-number">0</span>;
  destinationHasCapacity = <span class="hljs-literal">true</span>;
}
</code></pre>













<table><thead><tr><th/><th/></tr></thead><tbody><tr><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d6c54c6e56341b8a24d332fabdd8890~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=w%2FenA%2F8KxmajZU07vg1CqU5735o%3D" alt="" loading="lazy"/></td><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f80f09b5b8104c918fddf82a591b69db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=eA1Ymlo96gmoOHYAyiV%2B3MoKQ3Y%3D" alt="" loading="lazy"/></td></tr></tbody></table>
<ul>
<li>send$1把文件发送过去  这似乎是vite干的</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//node_modules/vite/dist/node/chunks/dep-BcnkIxro.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">send$1</span>(<span class="hljs-params">req, res, content, type, options</span>) {
  <span class="hljs-keyword">const</span> {
    etag = <span class="hljs-title function_">getEtag</span>(content, { <span class="hljs-attr">weak</span>: <span class="hljs-literal">true</span> }),
    cacheControl = <span class="hljs-string">"no-cache"</span>,
    headers,
    map
  } = options;
  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">writableEnded</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">headers</span>[<span class="hljs-string">"if-none-match"</span>] === etag) {
    res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">304</span>;
    res.<span class="hljs-title function_">end</span>();
    <span class="hljs-keyword">return</span>;
  }
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Content-Type"</span>, alias[type] || type);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Cache-Control"</span>, cacheControl);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Etag"</span>, etag);
  <span class="hljs-keyword">if</span> (headers) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> headers) {
      res.<span class="hljs-title function_">setHeader</span>(name, headers[name]);
    }
  }
  <span class="hljs-keyword">if</span> (map &amp;&amp; <span class="hljs-string">"version"</span> <span class="hljs-keyword">in</span> map &amp;&amp; map.<span class="hljs-property">mappings</span>) {
    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">"js"</span> || type === <span class="hljs-string">"css"</span>) {
      content = <span class="hljs-title function_">getCodeWithSourcemap</span>(type, content.<span class="hljs-title function_">toString</span>(), map);
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">"js"</span> &amp;&amp; (!map || map.<span class="hljs-property">mappings</span> !== <span class="hljs-string">""</span>)) {
    <span class="hljs-keyword">const</span> code = content.<span class="hljs-title function_">toString</span>();
    <span class="hljs-keyword">if</span> (convertSourceMap.<span class="hljs-property">mapFileCommentRegex</span>.<span class="hljs-title function_">test</span>(code)) {
      debug$3?.(<span class="hljs-string">`Skipped injecting fallback sourcemap for <span class="hljs-subst">${req.url}</span>`</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> urlWithoutTimestamp = <span class="hljs-title function_">removeTimestampQuery</span>(req.<span class="hljs-property">url</span>);
      <span class="hljs-keyword">const</span> ms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicString</span>(code);
      content = <span class="hljs-title function_">getCodeWithSourcemap</span>(
        type,
        code,
        ms.<span class="hljs-title function_">generateMap</span>({
          <span class="hljs-attr">source</span>: path$d.<span class="hljs-title function_">basename</span>(urlWithoutTimestamp),
          <span class="hljs-attr">hires</span>: <span class="hljs-string">"boundary"</span>,
          <span class="hljs-attr">includeContent</span>: <span class="hljs-literal">true</span>
        })
      );
    }
  }
  res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">200</span>;
  res.<span class="hljs-title function_">end</span>(content);
  <span class="hljs-keyword">return</span>;
}
</code></pre>

















<table><thead><tr><th/><th/></tr></thead><tbody><tr><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6e125ed16cc4620ad584d3426933d56~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=EJdYzlDp5l15LhfPSbnYTRMlm94%3D" alt="" loading="lazy"/></td><td>待处理<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9fd898a72be4d8ba12e9244657b5e42~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=0IlHec2JDFo6co%2FHKMxAm6aoLCQ%3D" alt="" loading="lazy"/></td></tr><tr><td>状态码200 <img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bee5add7c834471e95b56679fc3c2a26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=%2FGIkWCzOOqs3ty3S2dgDwYh5HZE%3D" alt="" loading="lazy"/></td><td/></tr></tbody></table>
<h3 data-id="heading-10">插入脚本片段</h3>
<p>SSR多次用到了<code>插入脚本片段</code>的技术，也就是插入&lt;script&gt;，作为整个SSR技术实现的一部分。例如前面的插入client.js，例如前面的状态的注水，还有这里的$RC函数:</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efe38241ccee4c18b8fdb641f0b587db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=gLAG%2BnUAJhJS9vUVL0CXRzjGueo%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//node_modules/react-dom/cjs/react-dom-server.node.development.js</span>
<span class="hljs-keyword">var</span> completeBoundaryFunction = <span class="hljs-string">'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&amp;&amp;8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&amp;&amp;"$?"!==d&amp;&amp;"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&amp;&amp;a._reactRetry()}}'</span>;
<span class="hljs-keyword">var</span> completeBoundaryScript1Full = <span class="hljs-title function_">stringToPrecomputedChunk</span>(completeBoundaryFunction + <span class="hljs-string">';$RC("'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">writeCompletedBoundaryInstruction</span>(<span class="hljs-params">destination, responseState, boundaryID, contentSegmentID</span>) {
  <span class="hljs-title function_">writeChunk</span>(destination, responseState.<span class="hljs-property">startInlineScript</span>);

  <span class="hljs-keyword">if</span> (!responseState.<span class="hljs-property">sentCompleteBoundaryFunction</span>) {
    <span class="hljs-comment">// The first time we write this, we'll need to include the full implementation.</span>
    responseState.<span class="hljs-property">sentCompleteBoundaryFunction</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-title function_">writeChunk</span>(destination, completeBoundaryScript1Full);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Future calls can just reuse the same function.</span>
    <span class="hljs-title function_">writeChunk</span>(destination, completeBoundaryScript1Partial);
  }

  <span class="hljs-keyword">if</span> (boundaryID === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'An ID must have been assigned before we can complete the boundary.'</span>);
  }

  <span class="hljs-keyword">var</span> formattedContentID = <span class="hljs-title function_">stringToChunk</span>(contentSegmentID.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>));
  <span class="hljs-title function_">writeChunk</span>(destination, boundaryID);
  <span class="hljs-title function_">writeChunk</span>(destination, completeBoundaryScript2);
  <span class="hljs-title function_">writeChunk</span>(destination, responseState.<span class="hljs-property">segmentPrefix</span>);
  <span class="hljs-title function_">writeChunk</span>(destination, formattedContentID);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">writeChunkAndReturn</span>(destination, completeBoundaryScript3);
}
</code></pre>
<p>把变量命名成有意义的变量名，取消掉压缩在看一下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">$RC</span>(<span class="hljs-params">a,b</span>){a=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(a);b=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(b);b.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(b);<span class="hljs-keyword">if</span>(a){a=a.<span class="hljs-property">previousSibling</span>;<span class="hljs-keyword">var</span> f=a.<span class="hljs-property">parentNode</span>,c=a.<span class="hljs-property">nextSibling</span>,e=<span class="hljs-number">0</span>;<span class="hljs-keyword">do</span>{<span class="hljs-keyword">if</span>(c&amp;&amp;<span class="hljs-number">8</span>===c.<span class="hljs-property">nodeType</span>){<span class="hljs-keyword">var</span> d=c.<span class="hljs-property">data</span>;<span class="hljs-keyword">if</span>(<span class="hljs-string">"/$"</span>===d)<span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>===e)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">else</span> e--;<span class="hljs-keyword">else</span><span class="hljs-string">"$"</span>!==d&amp;&amp;<span class="hljs-string">"$?"</span>!==d&amp;&amp;<span class="hljs-string">"$!"</span>!==d||e++}d=c.<span class="hljs-property">nextSibling</span>;f.<span class="hljs-title function_">removeChild</span>(c);c=d}<span class="hljs-keyword">while</span>(c);<span class="hljs-keyword">for</span>(;b.<span class="hljs-property">firstChild</span>;)f.<span class="hljs-title function_">insertBefore</span>(b.<span class="hljs-property">firstChild</span>,c);a.<span class="hljs-property">data</span>=<span class="hljs-string">"$"</span>;a.<span class="hljs-property">_reactRetry</span>&amp;&amp;a.<span class="hljs-title function_">_reactRetry</span>()}};$RC(<span class="hljs-string">"B:0"</span>,<span class="hljs-string">"S:0"</span>)
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceSegmentIntoBoundary</span>(<span class="hljs-params">boundaryId, segmentId</span>) {
  <span class="hljs-keyword">const</span> boundaryNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(boundaryId);
  <span class="hljs-keyword">const</span> segmentTemplate = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(segmentId);

  <span class="hljs-comment">// 移除 &lt;template&gt; 包裹</span>
  segmentTemplate.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(segmentTemplate);

  <span class="hljs-keyword">if</span> (boundaryNode) {
    <span class="hljs-keyword">let</span> marker = boundaryNode.<span class="hljs-property">previousSibling</span>; <span class="hljs-comment">// boundary 前的注释节点</span>
    <span class="hljs-keyword">const</span> parent = marker.<span class="hljs-property">parentNode</span>;
    <span class="hljs-keyword">let</span> current = marker.<span class="hljs-property">nextSibling</span>;
    <span class="hljs-keyword">let</span> depth = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 删除 boundary 占位内容 (直到 "/$" 结束标记)</span>
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">if</span> (current &amp;&amp; current.<span class="hljs-property">nodeType</span> === <span class="hljs-number">8</span>) { <span class="hljs-comment">// 注释节点</span>
        <span class="hljs-keyword">const</span> comment = current.<span class="hljs-property">data</span>; <span class="hljs-comment">//data就是注释节点的值&lt;!-- 值 --&gt;</span>
        <span class="hljs-keyword">if</span> (comment === <span class="hljs-string">"/$"</span>) {
          <span class="hljs-keyword">if</span> (depth === <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">else</span> depth--;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (comment === <span class="hljs-string">"$"</span> || comment === <span class="hljs-string">"$?"</span> || comment === <span class="hljs-string">"$!"</span>) {
          depth++;
        }
      }
      <span class="hljs-keyword">const</span> next = current.<span class="hljs-property">nextSibling</span>;
      parent.<span class="hljs-title function_">removeChild</span>(current);
      current = next;
    } <span class="hljs-keyword">while</span> (current);

    <span class="hljs-comment">// 插入 segment 的内容</span>
    <span class="hljs-keyword">while</span> (segmentTemplate.<span class="hljs-property">firstChild</span>) {
      parent.<span class="hljs-title function_">insertBefore</span>(segmentTemplate.<span class="hljs-property">firstChild</span>, current);
    }

    <span class="hljs-comment">// 更新 marker，标记已完成</span>
    marker.<span class="hljs-property">data</span> = <span class="hljs-string">"$"</span>;
    <span class="hljs-keyword">if</span> (marker.<span class="hljs-property">_reactRetry</span>) {
      marker.<span class="hljs-title function_">_reactRetry</span>();
    }
  }
}

<span class="hljs-comment">// 执行：把 S:0 (segment) 替换进 B:0 (boundary)</span>
<span class="hljs-title function_">replaceSegmentIntoBoundary</span>(<span class="hljs-string">"B:0"</span>, <span class="hljs-string">"S:0"</span>);
</code></pre>













<table><thead><tr><th>B:0</th><th>S:0</th></tr></thead><tbody><tr><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9634c7065cec4b1dbf5b0cb086a8b1de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=BmstxN4kcn%2BM1D1%2B%2BoMry2RVjnM%3D" alt="" loading="lazy"/></td><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cd8c37107984ced9f59a5715f28759e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aqR6Ieq6KGM6L2m55qE56CB5Yac:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368185&amp;x-signature=90RR9gwis%2BOTtVqp9Dx4JvppiIw%3D" alt="" loading="lazy"/></td></tr></tbody></table>
<h2 data-id="heading-11">总结</h2>
<p>SSR由四个角色组成，分别是：服务端和客户端公共的文件、HTTP服务器、客户端文件和服务端文件。<br/>
React组件创建了两遍，renderToPipeableStream+公共文件创建一遍，hydrateRoot+公共文件创建第二遍（完全没有用到createRoot）。</p>
<p><strong>水合</strong>不过是把Fiber节点关联到DOM，所谓“关联”就是通过DOM能找到Fiber。</p>
<p>SSR技术的实现设计不过是 <strong>HTML文件 + 插入脚本</strong>。<br/>
第一步，运行HTTP服务器，<strong>renderToPipeableStream + 公共文件</strong>创建纯HTML文件<br/>
第二步，插入水合脚本client.js（客户端文件，里面是hydrateRoot()）<br/>
第三步，插入替换脚本$RC。
HTTP服务器返回这个HTML文件，浏览器显示页面，执行脚本。<br/>
往后，再要其他功能，例如路由的管理、状态的管理，不过也是在HTML上插入新的脚本（不是全部都要插入新脚本）。<br/>
以状态管理为例，在服务端，正常创建了Store：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//服务端</span>
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">"./store"</span>;
<span class="hljs-keyword">const</span> preloadedState = store.<span class="hljs-title function_">getState</span>();
</code></pre>
<p>给HTML文件插入脚本：</p>
<pre><code class="hljs language-html" lang="html">index.html
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>${content}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> <span class="hljs-comment">//插入</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">__PRELOAD_STATE__</span>=${<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(preloadedState)}<span class="hljs-comment">//这样就被添加到了window</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"client.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>客户端就能获取状态：</p>
<pre><code class="hljs language-js" lang="js">client.<span class="hljs-property">js</span>
<span class="hljs-comment">// 创建store时，如果有window?.__PRELOAD_STATE__，就以它为初始state，否则为空对象{}</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStoreInstance</span>(<span class="hljs-variable language_">window</span>?.<span class="hljs-property">__PRELOAD_STATE__</span>);
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【JavaScript基础】Null类型详解]]></title>    <link>https://juejin.cn/post/7570598043298267199</link>    <guid>https://juejin.cn/post/7570598043298267199</guid>    <pubDate>2025-11-10T08:29:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570598043298267199" data-draft-id="7570896170920329279" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【JavaScript基础】Null类型详解"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T08:29:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="爱学习的程序媛"/> <meta itemprop="url" content="https://juejin.cn/user/2999123453938925"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【JavaScript基础】Null类型详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2999123453938925/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    爱学习的程序媛
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:29:23.000Z" title="Mon Nov 10 2025 08:29:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe59468598cd49f892c53e5360af014e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5a2m5Lmg55qE56iL5bqP5aqb:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763368163&amp;x-signature=Byq1ZO6ZJgHPaCRXVcHnmhP9c0U%3D" alt="image.png" loading="lazy"/></p>
<p>在JavaScript中，Null是一个原始数据类型，表示变量被明确赋值为空值或"无值"状态。</p>
<h2 data-id="heading-0">1. Null类型主要场景</h2>
<h3 data-id="heading-1">1）变量初始化</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;
user = { <span class="hljs-attr">name</span>: <span class="hljs-string">'cxh'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> };
</code></pre>
<h3 data-id="heading-2">2）函数返回值</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 函数找不到结果时返回 null</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findUser</span>(<span class="hljs-params">id</span>) {
    <span class="hljs-keyword">const</span> users = [
        { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'cxh001'</span> },
        { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'cxh002'</span> }
    ];
    <span class="hljs-keyword">return</span> users.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">id</span> === id) || <span class="hljs-literal">null</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findUser</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// null</span>

<span class="hljs-comment">// 操作失败时返回 null</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseJSON</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<h3 data-id="heading-3">3）DOM操作</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-comment">// 获取不存在的元素返回 null</span>
    <span class="hljs-keyword">const</span> nonExistentElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'non-existent'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nonExistentElement); <span class="hljs-comment">// null</span>

    <span class="hljs-comment">// 移除元素后设置为 null</span>
    <span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myElement'</span>);
    element?.<span class="hljs-property">parentNode</span>?.<span class="hljs-title function_">removeChild</span>(element);
    element = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 帮助垃圾回收</span>
</code></pre>
<h3 data-id="heading-4">4）对象属性的清理</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">const</span> app = {
        <span class="hljs-attr">cache</span>: {},
        <span class="hljs-attr">config</span>: <span class="hljs-literal">null</span>
    };
    <span class="hljs-comment">// 使用缓存后清理</span>
    app.<span class="hljs-property">cache</span>.<span class="hljs-property">userData</span> = { <span class="hljs-comment">/* 大量数据 */</span> };
    <span class="hljs-comment">// 释放内存</span>
    app.<span class="hljs-property">cache</span>.<span class="hljs-property">userData</span> = <span class="hljs-literal">null</span>;
</code></pre>
<h3 data-id="heading-5">5）函数的可选参数</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params">name, details = <span class="hljs-literal">null</span></span>) {
        <span class="hljs-keyword">return</span> {
            name,
            details
        };
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">createUser</span>(<span class="hljs-string">'cxh'</span>)); <span class="hljs-comment">// {name: 'cxh', details: null}</span>
</code></pre>
<h3 data-id="heading-6">6）API 响应处理</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-comment">// 常见于数据库查询结果</span>
    <span class="hljs-keyword">const</span> apiResponse = {
        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 没有找到数据</span>
        <span class="hljs-attr">message</span>: <span class="hljs-string">'User not found'</span>
    };
    <span class="hljs-comment">// 或者</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserProfile</span>(<span class="hljs-params">userId</span>) {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>);
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response?.<span class="hljs-title function_">json</span>();
        <span class="hljs-keyword">return</span> result?.<span class="hljs-property">data</span> || <span class="hljs-literal">null</span>; <span class="hljs-comment">// 有数据返回数据，没有返回 null</span>
    }
</code></pre>
<h3 data-id="heading-7">7）状态管理</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthService</span> {
        currentUser = <span class="hljs-literal">null</span>;
        token = <span class="hljs-literal">null</span>;

        <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {}

        <span class="hljs-title function_">login</span>(<span class="hljs-params">userData, authToken</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentUser</span> = userData;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span> = authToken;
        }

        <span class="hljs-title function_">logout</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentUser</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span> = <span class="hljs-literal">null</span>;
        }
    }
</code></pre>
<h3 data-id="heading-8">8）配置和选项</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">initializeApp</span>(<span class="hljs-params">config = {}</span>) {
        <span class="hljs-keyword">const</span> defaults = {
            <span class="hljs-attr">apiUrl</span>: <span class="hljs-string">'https://api.example.com'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,
            <span class="hljs-attr">retryCount</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 不重试</span>
            <span class="hljs-attr">logger</span>: <span class="hljs-literal">null</span> <span class="hljs-comment">// 不记录日志</span>
        };
        <span class="hljs-keyword">return</span> { ...defaults, ...config };
    }
</code></pre>
<h3 data-id="heading-9">9）未匹配到正则</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-comment">// RegExp.exec() 方法没有匹配</span>
    <span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/hello (\w+)/</span>;
    <span class="hljs-keyword">const</span> str = <span class="hljs-string">'goodbye world'</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex1.<span class="hljs-title function_">exec</span>(str)); <span class="hljs-comment">// null</span>

    <span class="hljs-comment">// String.match() 没有匹配结果</span>
    <span class="hljs-keyword">const</span> regex2 = <span class="hljs-regexp">/(\d{3})-(\d{3})-(\d{4})/</span>;
    <span class="hljs-keyword">const</span> phone = <span class="hljs-string">'没有电话号码'</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(phone.<span class="hljs-title function_">match</span>(regex2)); <span class="hljs-comment">// null</span>
</code></pre>
<h2 data-id="heading-10">2. 检测Null的方法</h2>
<h3 data-id="heading-11">1）严格相等</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Value is null'</span>); <span class="hljs-comment">// Value is null</span>
    }
</code></pre>
<h3 data-id="heading-12">2）联合检查Null和Undefined</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">let</span> value;
    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Value is null or undefined'</span>); <span class="hljs-comment">// Value is null or undefined</span>
    }
</code></pre>
<h3 data-id="heading-13">3）使用可选链操作符安全访问</h3>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">const</span> userName = user?.<span class="hljs-property">profile</span>?.<span class="hljs-property">name</span> ?? <span class="hljs-string">'default'</span>;
</code></pre>
<h2 data-id="heading-14">3. Undefined和Null的异同</h2>













































<table><thead><tr><th><strong>特性</strong></th><th><strong>Undefined</strong></th><th><strong>Null</strong></th></tr></thead><tbody><tr><td>类型</td><td>独立类型(Undefined)</td><td>独立类型(Null)</td></tr><tr><td>含义</td><td>变量声明但未赋值</td><td>表示一个空对象指针</td></tr><tr><td>默认值</td><td>函数无返回值时的默认返回</td><td>需显式赋值</td></tr><tr><td>相等性</td><td>undefined == null → true</td><td>undefined === null → false</td></tr><tr><td>类型检测</td><td>typeof undefined→ 'undefined'</td><td>typeof null → 'object'</td></tr><tr><td>转换为数字</td><td>Number(undefined) → NaN</td><td>Number(null) → 0</td></tr><tr><td>转换为布尔值</td><td>Boolean(undefined)→ false</td><td>Boolean(null) → false</td></tr></tbody></table>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文讲清鸿蒙网络开发]]></title>    <link>https://juejin.cn/post/7570904968677687323</link>    <guid>https://juejin.cn/post/7570904968677687323</guid>    <pubDate>2025-11-10T08:38:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570904968677687323" data-draft-id="7570902804450361354" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文讲清鸿蒙网络开发"/> <meta itemprop="keywords" content="前端,HarmonyOS,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T08:38:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Android疑难杂症"/> <meta itemprop="url" content="https://juejin.cn/user/1820446983462136"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文讲清鸿蒙网络开发
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1820446983462136/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Android疑难杂症
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:38:19.000Z" title="Mon Nov 10 2025 08:38:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、概述</h2>
<p>通过本指南,您可以掌握HarmonyOS Network Kit的核心功能和最佳实践。Network Kit提供了完整的网络通信解决方案,支持HTTP、WebSocket、Socket等多种协议,满足各类应用的网络需求。合理使用这些能力,可以构建高性能、安全可靠的网络应用。</p>
<h3 data-id="heading-1">核心能力</h3>








































<table><thead><tr><th>功能模块</th><th>主要能力</th><th>应用场景</th></tr></thead><tbody><tr><td>HTTP请求</td><td>GET/POST/PUT/DELETE等方法、流式传输、证书配置</td><td>RESTful API调用、文件上传下载</td></tr><tr><td>WebSocket</td><td>全双工通信、心跳检测、客户端/服务端</td><td>实时聊天、游戏对战、实时数据推送</td></tr><tr><td>TCP Socket</td><td>面向连接的可靠传输、服务端监听</td><td>长连接通信、自定义协议</td></tr><tr><td>UDP Socket</td><td>无连接的快速传输、组播支持</td><td>视频直播、实时语音、局域网发现</td></tr><tr><td>TLS Socket</td><td>加密传输、双向认证、证书锁定</td><td>安全通信、金融支付</td></tr><tr><td>LocalSocket</td><td>进程间通信、无需网络</td><td>同设备进程通信、性能优化</td></tr></tbody></table>
<h2 data-id="heading-2">二、HTTP网络请求</h2>
<h3 data-id="heading-3">2.1 请求流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant App as 应用
    participant HTTP as HttpRequest
    participant Server as 服务器

    App-&gt;&gt;HTTP: createHttp()
    App-&gt;&gt;HTTP: on('headersReceive')
    App-&gt;&gt;HTTP: request(url, options)
    HTTP-&gt;&gt;Server: 发送HTTP请求
    Server--&gt;&gt;HTTP: 返回响应头
    HTTP--&gt;&gt;App: headersReceive回调
    Server--&gt;&gt;HTTP: 返回完整响应
    HTTP--&gt;&gt;App: 响应数据
    App-&gt;&gt;HTTP: destroy()
</code></pre>
<h3 data-id="heading-4">2.2 基础HTTP请求</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { http } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.NetworkKit'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpManager</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">HttpManager</span>;

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {}

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(): <span class="hljs-title class_">HttpManager</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">HttpManager</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-title class_">HttpManager</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpManager</span>();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">HttpManager</span>.<span class="hljs-property">instance</span>;
  }

  <span class="hljs-comment">/**
   * 发送HTTP GET请求
   */</span>
  <span class="hljs-keyword">async</span> get&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, headers?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; {
    <span class="hljs-keyword">const</span> httpRequest = http.<span class="hljs-title function_">createHttp</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> httpRequest.<span class="hljs-title function_">request</span>(url, {
        <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">GET</span>,
        <span class="hljs-attr">header</span>: headers || { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
        <span class="hljs-attr">expectDataType</span>: http.<span class="hljs-property">HttpDataType</span>.<span class="hljs-property">STRING</span>,
        <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">60000</span>,
        <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">60000</span>
      });

      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">responseCode</span> === <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-property">result</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP Error: <span class="hljs-subst">${response.responseCode}</span>`</span>);
      }
    } <span class="hljs-keyword">finally</span> {
      httpRequest.<span class="hljs-title function_">destroy</span>();
    }
  }

  <span class="hljs-comment">/**
   * 发送HTTP POST请求
   */</span>
  <span class="hljs-keyword">async</span> post&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Object</span>, headers?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; {
    <span class="hljs-keyword">const</span> httpRequest = http.<span class="hljs-title function_">createHttp</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> httpRequest.<span class="hljs-title function_">request</span>(url, {
        <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">POST</span>,
        <span class="hljs-attr">header</span>: headers || { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
        <span class="hljs-attr">extraData</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),
        <span class="hljs-attr">expectDataType</span>: http.<span class="hljs-property">HttpDataType</span>.<span class="hljs-property">STRING</span>,
        <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">60000</span>,
        <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">60000</span>
      });

      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">responseCode</span> === <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-property">result</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP Error: <span class="hljs-subst">${response.responseCode}</span>`</span>);
      }
    } <span class="hljs-keyword">finally</span> {
      httpRequest.<span class="hljs-title function_">destroy</span>();
    }
  }

  <span class="hljs-comment">/**
   * 上传文件(multipart/form-data)
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">filePath</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">fileName</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> httpRequest = http.<span class="hljs-title function_">createHttp</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> httpRequest.<span class="hljs-title function_">request</span>(url, {
        <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">POST</span>,
        <span class="hljs-attr">header</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span> },
        <span class="hljs-attr">multiFormDataList</span>: [
          {
            <span class="hljs-attr">name</span>: <span class="hljs-string">'file'</span>,
            <span class="hljs-attr">contentType</span>: <span class="hljs-string">'application/octet-stream'</span>,
            <span class="hljs-attr">filePath</span>: filePath,
            <span class="hljs-attr">remoteFileName</span>: fileName
          }
        ],
        <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">60000</span>,
        <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">300000</span> <span class="hljs-comment">// 上传大文件需要更长超时时间</span>
      });

      <span class="hljs-keyword">return</span> response.<span class="hljs-property">result</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;
    } <span class="hljs-keyword">finally</span> {
      httpRequest.<span class="hljs-title function_">destroy</span>();
    }
  }
}
</code></pre>
<h3 data-id="heading-5">2.3 HTTP流式传输</h3>
<p>适用于大文件下载场景,支持进度监听:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpStreamDownloader</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">httpRequest</span>: http.<span class="hljs-property">HttpRequest</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">receivedData</span>: <span class="hljs-title class_">ArrayBuffer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">/**
   * 下载文件并监听进度
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">downloadFile</span>(
    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">onProgress</span>: <span class="hljs-function">(<span class="hljs-params">received: <span class="hljs-built_in">number</span>, total: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ArrayBuffer</span>&gt; {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span> = http.<span class="hljs-title function_">createHttp</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">receivedData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 订阅数据接收事件</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>!.<span class="hljs-title function_">on</span>(<span class="hljs-string">'dataReceive'</span>, <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">ArrayBuffer</span></span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> newBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">receivedData</span>.<span class="hljs-property">byteLength</span> + data.<span class="hljs-property">byteLength</span>);
        <span class="hljs-keyword">const</span> newView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(newBuffer);
        newView.<span class="hljs-title function_">set</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">receivedData</span>));
        newView.<span class="hljs-title function_">set</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(data), <span class="hljs-variable language_">this</span>.<span class="hljs-property">receivedData</span>.<span class="hljs-property">byteLength</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receivedData</span> = newBuffer;
      });

      <span class="hljs-comment">// 订阅下载进度事件</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>!.<span class="hljs-title function_">on</span>(<span class="hljs-string">'dataReceiveProgress'</span>, <span class="hljs-function">(<span class="hljs-params">progress: http.DataReceiveProgressInfo</span>) =&gt;</span> {
        <span class="hljs-title function_">onProgress</span>(progress.<span class="hljs-property">receiveSize</span>, progress.<span class="hljs-property">totalSize</span>);
      });

      <span class="hljs-comment">// 订阅数据接收完成事件</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>!.<span class="hljs-title function_">on</span>(<span class="hljs-string">'dataEnd'</span>, <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">receivedData</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanup</span>();
      });

      <span class="hljs-comment">// 发起流式请求</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>!.<span class="hljs-title function_">requestInStream</span>(url, {
        <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">GET</span>,
        <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">600000</span> <span class="hljs-comment">// 大文件需要更长超时</span>
      }).<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {
        <span class="hljs-title function_">reject</span>(err);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanup</span>();
      });
    });
  }

  <span class="hljs-comment">/**
   * 取消下载
   */</span>
  <span class="hljs-title function_">cancel</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanup</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">cleanup</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'dataReceive'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'dataReceiveProgress'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'dataEnd'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span>.<span class="hljs-title function_">destroy</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpRequest</span> = <span class="hljs-literal">null</span>;
    }
  }
}
</code></pre>
<h2 data-id="heading-6">三、WebSocket通信</h2>
<h3 data-id="heading-7">3.1 WebSocket架构</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    A[应用层] --&gt; B[WebSocket客户端]
    A --&gt; C[WebSocket服务端-仅智慧屏]
    B --&gt; D[createWebSocket]
    B --&gt; E[connect建立连接]
    B --&gt; F[send发送消息]
    B --&gt; G[close关闭连接]
    C --&gt; H[createWebSocketServer]
    C --&gt; I[start启动服务]
    C --&gt; J[监听客户端连接]
    C --&gt; K[stop停止服务]
</code></pre>
<h3 data-id="heading-8">3.2 WebSocket客户端</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { webSocket } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.NetworkKit'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketClient</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">ws</span>: webSocket.<span class="hljs-property">WebSocket</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">reconnectTimer</span>: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">private</span> reconnectAttempts = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> maxReconnectAttempts = <span class="hljs-number">5</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> url: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span> = webSocket.<span class="hljs-title function_">createWebSocket</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupEventHandlers</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupEventHandlers</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 连接打开事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'open'</span>, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, value: <span class="hljs-built_in">Object</span></span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'WebSocket连接失败:'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err));
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'WebSocket连接成功'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span> = <span class="hljs-number">0</span>;
    });

    <span class="hljs-comment">// 接收消息事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">ArrayBuffer</span></span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'接收消息失败:'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err));
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'收到文本消息:'</span>, value);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleMessage</span>(value);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'收到二进制消息'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleBinaryMessage</span>(value);
      }
    });

    <span class="hljs-comment">// 连接关闭事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, value: webSocket.CloseResult</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`WebSocket关闭 code=<span class="hljs-subst">${value.code}</span> reason=<span class="hljs-subst">${value.reason}</span>`</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attemptReconnect</span>();
    });

    <span class="hljs-comment">// 错误事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'WebSocket错误:'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err));
    });
  }

  <span class="hljs-comment">/**
   * 连接到WebSocket服务器
   */</span>
  <span class="hljs-title function_">connect</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">connect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span>, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, value: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-title function_">reject</span>(err);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">resolve</span>();
        }
      });
    });
  }

  <span class="hljs-comment">/**
   * 发送文本消息
   */</span>
  <span class="hljs-title function_">sendText</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">send</span>(message, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, value: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-title function_">reject</span>(err);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">resolve</span>();
        }
      });
    });
  }

  <span class="hljs-comment">/**
   * 发送二进制消息
   */</span>
  <span class="hljs-title function_">sendBinary</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">send</span>(data, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, value: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-title function_">reject</span>(err);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">resolve</span>();
        }
      });
    });
  }

  <span class="hljs-comment">/**
   * 关闭连接
   */</span>
  <span class="hljs-title function_">close</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimer</span> !== <span class="hljs-literal">null</span>) {
      <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimer</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimer</span> = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">close</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError, value: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-title function_">reject</span>(err);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">resolve</span>();
        }
      });
    });
  }

  <span class="hljs-comment">/**
   * 自动重连
   */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">attemptReconnect</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxReconnectAttempts</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'达到最大重连次数,停止重连'</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> delay = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1000</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span>), <span class="hljs-number">30000</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span>++;

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`<span class="hljs-subst">${delay}</span>ms后尝试第<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.reconnectAttempts}</span>次重连`</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimer</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">connect</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'重连失败:'</span>, err);
      });
    }, delay);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 业务逻辑处理</span>
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">handleBinaryMessage</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 二进制数据处理</span>
  }
}
</code></pre>
<h2 data-id="heading-9">四、Socket通信</h2>
<h3 data-id="heading-10">4.1 TCP Socket客户端</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { socket } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.NetworkKit'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPSocketClient</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">tcp</span>: socket.<span class="hljs-property">TCPSocket</span>;
  <span class="hljs-keyword">private</span> connected = <span class="hljs-literal">false</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span> = socket.<span class="hljs-title function_">constructTCPSocketInstance</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupEventHandlers</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupEventHandlers</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 连接建立事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'TCP连接已建立'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span> = <span class="hljs-literal">true</span>;
    });

    <span class="hljs-comment">// 接收消息事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">value: socket.SocketMessageInfo</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> buffer = value.<span class="hljs-property">message</span>;
      <span class="hljs-keyword">const</span> dataView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);
      <span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dataView.<span class="hljs-property">byteLength</span>; i++) {
        str += <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(dataView.<span class="hljs-title function_">getUint8</span>(i));
      }
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'收到消息:'</span>, str);
    });

    <span class="hljs-comment">// 连接关闭事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'TCP连接已关闭'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span> = <span class="hljs-literal">false</span>;
    });
  }

  <span class="hljs-comment">/**
   * 连接到服务器
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">connect</span>(<span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-comment">// 绑定本地地址(可选,端口由系统分配)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-attr">localAddr</span>: socket.<span class="hljs-property">NetAddress</span> = {
      <span class="hljs-attr">address</span>: <span class="hljs-string">'0.0.0.0'</span>,
      <span class="hljs-attr">port</span>: <span class="hljs-number">0</span>
    };

    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">bind</span>(localAddr, <span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-title function_">reject</span>(err);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">resolve</span>();
        }
      });
    });

    <span class="hljs-comment">// 连接到服务器</span>
    <span class="hljs-keyword">const</span> <span class="hljs-attr">remoteAddr</span>: socket.<span class="hljs-property">NetAddress</span> = {
      <span class="hljs-attr">address</span>: host,
      <span class="hljs-attr">port</span>: port
    };

    <span class="hljs-keyword">const</span> <span class="hljs-attr">connectOptions</span>: socket.<span class="hljs-property">TCPConnectOptions</span> = {
      <span class="hljs-attr">address</span>: remoteAddr,
      <span class="hljs-attr">timeout</span>: <span class="hljs-number">6000</span>
    };

    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">connect</span>(connectOptions);
  }

  <span class="hljs-comment">/**
   * 发送数据
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">send</span>(<span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">connected</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'TCP未连接'</span>);
    }

    <span class="hljs-keyword">const</span> <span class="hljs-attr">sendOptions</span>: socket.<span class="hljs-property">TCPSendOptions</span> = {
      <span class="hljs-attr">data</span>: data
    };

    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">send</span>(sendOptions);
  }

  <span class="hljs-comment">/**
   * 关闭连接
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">close</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">close</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'message'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'connect'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcp</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'close'</span>);
  }
}
</code></pre>
<h3 data-id="heading-11">4.2 TCP Socket服务端</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPSocketServer</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">server</span>: socket.<span class="hljs-property">TCPSocketServer</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">clients</span>: socket.<span class="hljs-property">TCPSocketConnection</span>[] = [];

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">server</span> = socket.<span class="hljs-title function_">constructTCPSocketServerInstance</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupEventHandlers</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupEventHandlers</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 客户端连接事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">server</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">(<span class="hljs-params">client: socket.TCPSocketConnection</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'新客户端连接'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">clients</span>.<span class="hljs-title function_">push</span>(client);

      <span class="hljs-comment">// 监听客户端消息</span>
      client.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">value: socket.SocketMessageInfo</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> buffer = value.<span class="hljs-property">message</span>;
        <span class="hljs-keyword">const</span> dataView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);
        <span class="hljs-keyword">let</span> message = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dataView.<span class="hljs-property">byteLength</span>; i++) {
          message += <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(dataView.<span class="hljs-title function_">getUint8</span>(i));
        }
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'收到客户端消息:'</span>, message);

        <span class="hljs-comment">// 广播给所有客户端</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">broadcast</span>(message, client);
      });

      <span class="hljs-comment">// 客户端关闭事件</span>
      client.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">clients</span>.<span class="hljs-title function_">indexOf</span>(client);
        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">clients</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
        }
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'客户端断开,当前连接数:'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clients</span>.<span class="hljs-property">length</span>);
      });
    });
  }

  <span class="hljs-comment">/**
   * 启动服务器
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">listen</span>(<span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">address</span>: socket.<span class="hljs-property">NetAddress</span> = {
      <span class="hljs-attr">address</span>: <span class="hljs-string">'0.0.0.0'</span>,
      <span class="hljs-attr">port</span>: port
    };

    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">server</span>.<span class="hljs-title function_">listen</span>(address);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`TCP服务器监听端口: <span class="hljs-subst">${port}</span>`</span>);
  }

  <span class="hljs-comment">/**
   * 广播消息给所有客户端
   */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>, sender?: socket.<span class="hljs-property">TCPSocketConnection</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">sendOptions</span>: socket.<span class="hljs-property">TCPSendOptions</span> = {
      <span class="hljs-attr">data</span>: message
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> client <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">clients</span>) {
      <span class="hljs-keyword">if</span> (client !== sender) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">send</span>(sendOptions);
        } <span class="hljs-keyword">catch</span> (err) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'发送失败:'</span>, err);
        }
      }
    }
  }

  <span class="hljs-comment">/**
   * 停止服务器
   */</span>
  <span class="hljs-title function_">stop</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 关闭所有客户端连接</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> client <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">clients</span>) {
      client.<span class="hljs-title function_">close</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">clients</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">server</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'connect'</span>);
  }
}
</code></pre>
<h3 data-id="heading-12">4.3 TLS Socket加密通信</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TLSSocketClient</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">tls</span>: socket.<span class="hljs-property">TLSSocket</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span> = socket.<span class="hljs-title function_">constructTLSSocketInstance</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupEventHandlers</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupEventHandlers</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'TLS连接建立'</span>);
    });

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">value: socket.SocketMessageInfo</span>) =&gt;</span> {
      <span class="hljs-comment">// 处理加密消息</span>
    });

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'TLS连接关闭'</span>);
    });
  }

  <span class="hljs-comment">/**
   * 单向认证连接(仅验证服务器证书)
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">connectOneWay</span>(<span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">caPath</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">localAddr</span>: socket.<span class="hljs-property">NetAddress</span> = {
      <span class="hljs-attr">address</span>: <span class="hljs-string">'0.0.0.0'</span>,
      <span class="hljs-attr">port</span>: <span class="hljs-number">0</span>
    };

    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">bind</span>(localAddr, <span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err);
        <span class="hljs-keyword">else</span> <span class="hljs-title function_">resolve</span>();
      });
    });

    <span class="hljs-keyword">const</span> <span class="hljs-attr">remoteAddr</span>: socket.<span class="hljs-property">NetAddress</span> = {
      <span class="hljs-attr">address</span>: host,
      <span class="hljs-attr">port</span>: port
    };

    <span class="hljs-keyword">const</span> <span class="hljs-attr">secureOptions</span>: socket.<span class="hljs-property">TLSSecureOptions</span> = {
      <span class="hljs-attr">ca</span>: [caPath], <span class="hljs-comment">// CA证书路径</span>
      <span class="hljs-attr">cipherSuite</span>: <span class="hljs-string">'AES256-SHA256'</span>
    };

    <span class="hljs-keyword">const</span> <span class="hljs-attr">connectOptions</span>: socket.<span class="hljs-property">TLSConnectOptions</span> = {
      <span class="hljs-attr">address</span>: remoteAddr,
      <span class="hljs-attr">secureOptions</span>: secureOptions
    };

    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">connect</span>(connectOptions);
  }

  <span class="hljs-comment">/**
   * 双向认证连接(同时验证客户端和服务器证书)
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">connectTwoWay</span>(
    <span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>,
    <span class="hljs-attr">caPath</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">certPath</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">keyPath</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">localAddr</span>: socket.<span class="hljs-property">NetAddress</span> = {
      <span class="hljs-attr">address</span>: <span class="hljs-string">'0.0.0.0'</span>,
      <span class="hljs-attr">port</span>: <span class="hljs-number">0</span>
    };

    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">bind</span>(localAddr, <span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err);
        <span class="hljs-keyword">else</span> <span class="hljs-title function_">resolve</span>();
      });
    });

    <span class="hljs-keyword">const</span> <span class="hljs-attr">remoteAddr</span>: socket.<span class="hljs-property">NetAddress</span> = {
      <span class="hljs-attr">address</span>: host,
      <span class="hljs-attr">port</span>: port
    };

    <span class="hljs-keyword">const</span> <span class="hljs-attr">secureOptions</span>: socket.<span class="hljs-property">TLSSecureOptions</span> = {
      <span class="hljs-attr">ca</span>: [caPath],
      <span class="hljs-attr">cert</span>: certPath, <span class="hljs-comment">// 客户端证书</span>
      <span class="hljs-attr">key</span>: keyPath,   <span class="hljs-comment">// 客户端私钥</span>
      <span class="hljs-attr">password</span>: password, <span class="hljs-comment">// 私钥密码</span>
      <span class="hljs-attr">protocols</span>: [socket.<span class="hljs-property">Protocol</span>.<span class="hljs-property">TLSv12</span>],
      <span class="hljs-attr">cipherSuite</span>: <span class="hljs-string">'AES256-SHA256'</span>
    };

    <span class="hljs-keyword">const</span> <span class="hljs-attr">connectOptions</span>: socket.<span class="hljs-property">TLSConnectOptions</span> = {
      <span class="hljs-attr">address</span>: remoteAddr,
      <span class="hljs-attr">secureOptions</span>: secureOptions
    };

    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">connect</span>(connectOptions);
  }

  <span class="hljs-comment">/**
   * 发送加密数据
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">send</span>(<span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">send</span>(data);
  }

  <span class="hljs-comment">/**
   * 关闭连接
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">close</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">close</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'message'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'connect'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tls</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'close'</span>);
  }
}
</code></pre>
<h2 data-id="heading-13">五、完整示例:网络管理器应用</h2>
<p>创建一个统一的网络管理器,整合所有网络能力:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { http } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.NetworkKit'</span>;
<span class="hljs-keyword">import</span> { webSocket } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.NetworkKit'</span>;
<span class="hljs-keyword">import</span> { socket } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.NetworkKit'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;

<span class="hljs-comment">/**
 * 网络管理器单例
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkManager</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">NetworkManager</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">wsClient</span>: <span class="hljs-title class_">WebSocketClient</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">tcpClient</span>: <span class="hljs-title class_">TCPSocketClient</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {}

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(): <span class="hljs-title class_">NetworkManager</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">NetworkManager</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-title class_">NetworkManager</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkManager</span>();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NetworkManager</span>.<span class="hljs-property">instance</span>;
  }

  <span class="hljs-comment">/**
   * HTTP GET请求
   */</span>
  <span class="hljs-keyword">async</span> httpGet&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; {
    <span class="hljs-keyword">const</span> httpRequest = http.<span class="hljs-title function_">createHttp</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> httpRequest.<span class="hljs-title function_">request</span>(url, {
        <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">GET</span>,
        <span class="hljs-attr">header</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
        <span class="hljs-attr">expectDataType</span>: http.<span class="hljs-property">HttpDataType</span>.<span class="hljs-property">STRING</span>,
        <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">60000</span>,
        <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">60000</span>
      });

      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">responseCode</span> === <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-property">result</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.responseCode}</span>`</span>);
      }
    } <span class="hljs-keyword">finally</span> {
      httpRequest.<span class="hljs-title function_">destroy</span>();
    }
  }

  <span class="hljs-comment">/**
   * HTTP POST请求
   */</span>
  <span class="hljs-keyword">async</span> httpPost&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">data</span>: <span class="hljs-title class_">Object</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; {
    <span class="hljs-keyword">const</span> httpRequest = http.<span class="hljs-title function_">createHttp</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> httpRequest.<span class="hljs-title function_">request</span>(url, {
        <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">POST</span>,
        <span class="hljs-attr">header</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
        <span class="hljs-attr">extraData</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),
        <span class="hljs-attr">expectDataType</span>: http.<span class="hljs-property">HttpDataType</span>.<span class="hljs-property">STRING</span>,
        <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">60000</span>,
        <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">60000</span>
      });

      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">responseCode</span> === <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-property">result</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.responseCode}</span>`</span>);
      }
    } <span class="hljs-keyword">finally</span> {
      httpRequest.<span class="hljs-title function_">destroy</span>();
    }
  }

  <span class="hljs-comment">/**
   * 下载文件并显示进度
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">downloadFile</span>(
    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">onProgress</span>: <span class="hljs-function">(<span class="hljs-params">received: <span class="hljs-built_in">number</span>, total: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ArrayBuffer</span>&gt; {
    <span class="hljs-keyword">const</span> downloader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpStreamDownloader</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> downloader.<span class="hljs-title function_">downloadFile</span>(url, onProgress);
  }

  <span class="hljs-comment">/**
   * 连接WebSocket
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">connectWebSocket</span>(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">WebSocketClient</span>&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span>) {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span>.<span class="hljs-title function_">close</span>();
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketClient</span>(url);
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span>.<span class="hljs-title function_">connect</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span>;
  }

  <span class="hljs-comment">/**
   * 获取WebSocket客户端
   */</span>
  <span class="hljs-title function_">getWebSocketClient</span>(): <span class="hljs-title class_">WebSocketClient</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span>;
  }

  <span class="hljs-comment">/**
   * 连接TCP Socket
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">connectTCPSocket</span>(<span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">TCPSocketClient</span>&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span>) {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span>.<span class="hljs-title function_">close</span>();
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TCPSocketClient</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span>.<span class="hljs-title function_">connect</span>(host, port);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span>;
  }

  <span class="hljs-comment">/**
   * 获取TCP Socket客户端
   */</span>
  <span class="hljs-title function_">getTCPSocketClient</span>(): <span class="hljs-title class_">TCPSocketClient</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span>;
  }

  <span class="hljs-comment">/**
   * 清理所有连接
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">cleanup</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span>) {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span>.<span class="hljs-title function_">close</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsClient</span> = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span>) {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span>.<span class="hljs-title function_">close</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpClient</span> = <span class="hljs-literal">null</span>;
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">NetworkManager</span>;
</code></pre>
<h3 data-id="heading-14">使用示例页面</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">NetworkManager</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./NetworkManager'</span>;

<span class="hljs-meta">@Entry</span>
<span class="hljs-meta">@Component</span>
struct <span class="hljs-title class_">NetworkTestPage</span> {
  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'网络测试'</span>;
  <span class="hljs-meta">@State</span> <span class="hljs-attr">httpResult</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;
  <span class="hljs-meta">@State</span> <span class="hljs-attr">downloadProgress</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'0%'</span>;
  <span class="hljs-meta">@State</span> <span class="hljs-attr">wsStatus</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'未连接'</span>;
  <span class="hljs-meta">@State</span> <span class="hljs-attr">tcpStatus</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'未连接'</span>;

  <span class="hljs-keyword">private</span> networkManager = <span class="hljs-title class_">NetworkManager</span>.<span class="hljs-title function_">getInstance</span>();

  <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Column</span>({ <span class="hljs-attr">space</span>: <span class="hljs-number">20</span> }) {
      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">24</span>)
        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)

      <span class="hljs-comment">// HTTP测试区</span>
      <span class="hljs-title class_">Text</span>(<span class="hljs-string">'HTTP请求测试'</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">18</span>)
        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Medium</span>)

      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'GET请求'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">testHttpGet</span>())

      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'POST请求'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">testHttpPost</span>())

      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'下载文件'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">testDownload</span>())

      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">httpResult</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">14</span>)

      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`下载进度: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.downloadProgress}</span>`</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">14</span>)

      <span class="hljs-title class_">Divider</span>()

      <span class="hljs-comment">// WebSocket测试区</span>
      <span class="hljs-title class_">Text</span>(<span class="hljs-string">'WebSocket测试'</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">18</span>)
        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Medium</span>)

      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`状态: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.wsStatus}</span>`</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">14</span>)

      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'连接WebSocket'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">testWebSocket</span>())

      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'发送WebSocket消息'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendWebSocketMessage</span>())

      <span class="hljs-title class_">Divider</span>()

      <span class="hljs-comment">// TCP Socket测试区</span>
      <span class="hljs-title class_">Text</span>(<span class="hljs-string">'TCP Socket测试'</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">18</span>)
        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Medium</span>)

      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`状态: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tcpStatus}</span>`</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">14</span>)

      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'连接TCP'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">testTCPSocket</span>())

      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'发送TCP消息'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendTCPMessage</span>())
    }
    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)
    .<span class="hljs-title function_">padding</span>(<span class="hljs-number">20</span>)
  }

  <span class="hljs-comment">/**
   * 测试HTTP GET请求
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">testHttpGet</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">httpGet</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpResult</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result);
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpResult</span> = <span class="hljs-string">`请求失败: <span class="hljs-subst">${err}</span>`</span>;
    }
  }

  <span class="hljs-comment">/**
   * 测试HTTP POST请求
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">testHttpPost</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> data = { <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> };
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">httpPost</span>(<span class="hljs-string">'https://api.example.com/submit'</span>, data);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpResult</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result);
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpResult</span> = <span class="hljs-string">`请求失败: <span class="hljs-subst">${err}</span>`</span>;
    }
  }

  <span class="hljs-comment">/**
   * 测试文件下载
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">testDownload</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">downloadFile</span>(
        <span class="hljs-string">'https://example.com/file.zip'</span>,
        <span class="hljs-function">(<span class="hljs-params">received, total</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> percent = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((received / total) * <span class="hljs-number">100</span>);
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadProgress</span> = <span class="hljs-string">`<span class="hljs-subst">${percent}</span>%`</span>;
        }
      );
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpResult</span> = <span class="hljs-string">`下载完成,大小: <span class="hljs-subst">${data.byteLength}</span> 字节`</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">downloadProgress</span> = <span class="hljs-string">'100%'</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpResult</span> = <span class="hljs-string">`下载失败: <span class="hljs-subst">${err}</span>`</span>;
    }
  }

  <span class="hljs-comment">/**
   * 测试WebSocket连接
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">testWebSocket</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">connectWebSocket</span>(<span class="hljs-string">'ws://example.com:8080'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsStatus</span> = <span class="hljs-string">'已连接'</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsStatus</span> = <span class="hljs-string">`连接失败: <span class="hljs-subst">${err}</span>`</span>;
    }
  }

  <span class="hljs-comment">/**
   * 发送WebSocket消息
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">sendWebSocketMessage</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> client = <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">getWebSocketClient</span>();
    <span class="hljs-keyword">if</span> (!client) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsStatus</span> = <span class="hljs-string">'未连接'</span>;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">sendText</span>(<span class="hljs-string">'Hello WebSocket!'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsStatus</span> = <span class="hljs-string">'消息已发送'</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsStatus</span> = <span class="hljs-string">`发送失败: <span class="hljs-subst">${err}</span>`</span>;
    }
  }

  <span class="hljs-comment">/**
   * 测试TCP Socket连接
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">testTCPSocket</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">connectTCPSocket</span>(<span class="hljs-string">'192.168.1.100'</span>, <span class="hljs-number">8888</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpStatus</span> = <span class="hljs-string">'已连接'</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpStatus</span> = <span class="hljs-string">`连接失败: <span class="hljs-subst">${err}</span>`</span>;
    }
  }

  <span class="hljs-comment">/**
   * 发送TCP消息
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">sendTCPMessage</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> client = <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">getTCPSocketClient</span>();
    <span class="hljs-keyword">if</span> (!client) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpStatus</span> = <span class="hljs-string">'未连接'</span>;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">send</span>(<span class="hljs-string">'Hello TCP!'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpStatus</span> = <span class="hljs-string">'消息已发送'</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tcpStatus</span> = <span class="hljs-string">`发送失败: <span class="hljs-subst">${err}</span>`</span>;
    }
  }

  <span class="hljs-title function_">aboutToDisappear</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 页面销毁时清理连接</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">cleanup</span>();
  }
}
</code></pre>
<h2 data-id="heading-15">六、最佳实践</h2>
<h3 data-id="heading-16">6.1 网络请求优化</h3>
<ol>
<li><strong>连接复用</strong>: HTTP/2和HTTP/3支持连接复用,减少握手开销</li>
<li><strong>超时设置</strong>: 根据业务场景合理设置connectTimeout和readTimeout</li>
<li><strong>资源释放</strong>: 及时调用destroy()释放HttpRequest对象</li>
<li><strong>缓存策略</strong>: 合理使用usingCache参数,减少重复请求</li>
</ol>
<h3 data-id="heading-17">6.2 错误处理</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> robustHttpRequest&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">retries</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">lastError</span>: <span class="hljs-title class_">Error</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; retries; i++) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NetworkManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-property">httpGet</span>&lt;T&gt;(url);
      <span class="hljs-keyword">return</span> result;
    } <span class="hljs-keyword">catch</span> (err) {
      lastError = err <span class="hljs-keyword">as</span> <span class="hljs-title class_">Error</span>;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`请求失败,第<span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>次重试:`</span>, err);

      <span class="hljs-comment">// 等待一段时间后重试</span>
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, i)));
    }
  }

  <span class="hljs-keyword">throw</span> lastError || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'请求失败'</span>);
}
</code></pre>
<h3 data-id="heading-18">6.3 证书安全配置</h3>
<p>在<code>src/main/resources/base/profile/network_config.json</code>配置证书锁定:</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"network-security-config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"domain-config"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"domains"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"include-subdomains"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"api.example.com"</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"pin-set"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"expiration"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2025-12-31"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"pin"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
            <span class="hljs-punctuation">{</span>
              <span class="hljs-attr">"digest-algorithm"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sha256"</span><span class="hljs-punctuation">,</span>
              <span class="hljs-attr">"digest"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"base64encodedpinvalue"</span>
            <span class="hljs-punctuation">}</span>
          <span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-19">6.4 性能监控</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkPerformanceMonitor</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">measureRequestTime</span>(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt; {
    <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title class_">NetworkManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">httpGet</span>(url);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求失败:'</span>, err);
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">checkNetworkQuality</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> testUrl = <span class="hljs-string">'https://www.example.com'</span>;
    <span class="hljs-keyword">const</span> responseTime = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">measureRequestTime</span>(testUrl);

    <span class="hljs-keyword">if</span> (responseTime &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'网络异常'</span>;
    <span class="hljs-keyword">if</span> (responseTime &lt; <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'网络优秀'</span>;
    <span class="hljs-keyword">if</span> (responseTime &lt; <span class="hljs-number">300</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'网络良好'</span>;
    <span class="hljs-keyword">if</span> (responseTime &lt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'网络一般'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'网络较差'</span>;
  }
}
</code></pre>
<h2 data-id="heading-20">七、常见问题</h2>
<h3 data-id="heading-21">Q1: 应用退到后台后Socket断开怎么办?</h3>
<p>A: 应用退后台后Socket可能断开,需要在重回前台时检测并重连:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title function_">onPageShow</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 检查连接状态</span>
  <span class="hljs-keyword">const</span> client = <span class="hljs-variable language_">this</span>.<span class="hljs-property">networkManager</span>.<span class="hljs-title function_">getTCPSocketClient</span>();
  <span class="hljs-keyword">if</span> (client &amp;&amp; !client.<span class="hljs-title function_">isConnected</span>()) {
    <span class="hljs-comment">// 重新连接</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reconnectSocket</span>();
  }
}
</code></pre>
<h3 data-id="heading-22">Q2: 如何处理大文件上传?</h3>
<p>A: 使用multipart/form-data格式,设置更长的超时时间:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">uploadLargeFile</span>(<span class="hljs-attr">filePath</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
  <span class="hljs-keyword">const</span> httpRequest = http.<span class="hljs-title function_">createHttp</span>();

  <span class="hljs-keyword">await</span> httpRequest.<span class="hljs-title function_">request</span>(url, {
    <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">POST</span>,
    <span class="hljs-attr">header</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span> },
    <span class="hljs-attr">multiFormDataList</span>: [{
      <span class="hljs-attr">name</span>: <span class="hljs-string">'file'</span>,
      <span class="hljs-attr">contentType</span>: <span class="hljs-string">'application/octet-stream'</span>,
      <span class="hljs-attr">filePath</span>: filePath,
      <span class="hljs-attr">remoteFileName</span>: <span class="hljs-string">'large_file.zip'</span>
    }],
    <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">600000</span>, <span class="hljs-comment">// 10分钟</span>
    <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">60000</span>
  });
}
</code></pre>
<h3 data-id="heading-23">Q3: WebSocket如何实现心跳保活?</h3>
<p>A: HarmonyOS的WebSocket已内置心跳机制,每30秒自动发送Ping帧,60秒无响应会断开连接。开发者无需额外实现。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Math.js封装工具库（解决前端因为浮点数导致计算错误）]]></title>    <link>https://juejin.cn/post/7570896170920476735</link>    <guid>https://juejin.cn/post/7570896170920476735</guid>    <pubDate>2025-11-10T08:43:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570896170920476735" data-draft-id="7435682717955932186" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Math.js封装工具库（解决前端因为浮点数导致计算错误）"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T08:43:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Jack莱杰"/> <meta itemprop="url" content="https://juejin.cn/user/720885038716663"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Math.js封装工具库（解决前端因为浮点数导致计算错误）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/720885038716663/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Jack莱杰
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T08:43:32.000Z" title="Mon Nov 10 2025 08:43:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述</h2>
<p>该工具库是基于 mathjs 封装的一个数学计算工具，主要解决 JavaScript 浮点数运算精度问题，提供精确的加减乘除、取模等运算功能，特别适合财务、金融等需要高精度计算的场景。</p>
<h2 data-id="heading-1">安装与使用</h2>
<h3 data-id="heading-2">安装依赖</h3>
<pre><code class="hljs language-bash" lang="bash">npm install mathjs --save
</code></pre>
<h2 data-id="heading-3">使用</h2>
<p>utils/math.js</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> $math <span class="hljs-keyword">from</span> <span class="hljs-string">"mathjs"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> math = {
  <span class="hljs-title function_">add</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">comp</span>(<span class="hljs-string">"add"</span>, <span class="hljs-variable language_">arguments</span>);
  },
  <span class="hljs-title function_">subtract</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">comp</span>(<span class="hljs-string">"subtract"</span>, <span class="hljs-variable language_">arguments</span>);
  },
  <span class="hljs-title function_">multiply</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">comp</span>(<span class="hljs-string">"multiply"</span>, <span class="hljs-variable language_">arguments</span>);
  },
  <span class="hljs-title function_">divide</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">comp</span>(<span class="hljs-string">"divide"</span>, <span class="hljs-variable language_">arguments</span>);
  },
  <span class="hljs-title function_">mod</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">comp</span>(<span class="hljs-string">"mod"</span>, <span class="hljs-variable language_">arguments</span>);
  },
  <span class="hljs-title function_">divMod</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">const</span> quotient = $math.<span class="hljs-title function_">floor</span>(
      $math.<span class="hljs-title function_">divide</span>($math.<span class="hljs-title function_">bignumber</span>(a), $math.<span class="hljs-title function_">bignumber</span>(b))
    ); <span class="hljs-comment">// 使用 floor 获取整数部分</span>
    <span class="hljs-keyword">const</span> remainder = $math.<span class="hljs-title function_">mod</span>($math.<span class="hljs-title function_">bignumber</span>(a), $math.<span class="hljs-title function_">bignumber</span>(b));
    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">parseFloat</span>(quotient), <span class="hljs-built_in">parseFloat</span>(remainder)];
    <span class="hljs-comment">// return {</span>
    <span class="hljs-comment">//   quotient: parseFloat(quotient),</span>
    <span class="hljs-comment">//   remainder: parseFloat(remainder),</span>
    <span class="hljs-comment">// };</span>
  },
  <span class="hljs-comment">// 处理大数字</span>
  <span class="hljs-title function_">bignumber</span>(<span class="hljs-params">string</span>) {
    <span class="hljs-keyword">return</span> $math.<span class="hljs-title function_">bignumber</span>(string).<span class="hljs-title function_">toNumber</span>();
  },
  <span class="hljs-comment">// 比大小</span>
  <span class="hljs-title function_">compare</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">const</span> numA = $math.<span class="hljs-title function_">bignumber</span>(a);
    <span class="hljs-keyword">const</span> numB = $math.<span class="hljs-title function_">bignumber</span>(b);

    <span class="hljs-keyword">if</span> ($math.<span class="hljs-title function_">equal</span>(numA, numB)) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 相等</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($math.<span class="hljs-title function_">smaller</span>(numA, numB)) {
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// a &lt; b</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// a &gt; b</span>
    }
  },
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">comp</span>(<span class="hljs-params">_func, args</span>) {
  <span class="hljs-keyword">let</span> t = $math.<span class="hljs-title function_">chain</span>($math.<span class="hljs-title function_">bignumber</span>(args[<span class="hljs-number">0</span>]));

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; args.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> arg = args[i] || <span class="hljs-number">0</span>;
    t = t[_func]($math.<span class="hljs-title function_">bignumber</span>(arg));
  }
  <span class="hljs-comment">// 防止超过6位使用科学计数法</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(t.<span class="hljs-title function_">done</span>());
}

<span class="hljs-comment">// 使用场景</span>
<span class="hljs-comment">// import { math } from '@/utils/math.js'</span>
<span class="hljs-comment">// 加法</span>
<span class="hljs-comment">//    const result  = math.add(2, 3)  // 5</span>
<span class="hljs-comment">// 减法</span>
<span class="hljs-comment">//    const result  = math.subtract(3, 2)   // 1</span>
<span class="hljs-comment">// 乘法</span>
<span class="hljs-comment">//     const result  = math.multiply(2, 3) // 6</span>
<span class="hljs-comment">// 除法</span>
<span class="hljs-comment">//       const result = math.divide(4, 2) // 2</span>
<span class="hljs-comment">// 除余</span>
<span class="hljs-comment">// const result = math.mod(10, 3); //1</span>
<span class="hljs-comment">// 除余方法</span>
<span class="hljs-comment">//  math.divMod(10, 3);  // 输出: { quotient: 3, remainder: 1 }</span>
<span class="hljs-comment">// 可以多个</span>
<span class="hljs-comment">//    const result  = math.multiply(3, 2, 2, 2)   // 24</span>
<span class="hljs-comment">// 取决于math.js文件里面的命名，PS：中间是逗号</span>
</code></pre>
<p>demo.vue</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>除法<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number01 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number1 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>乘法<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number02 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number2 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>加法<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number03 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number3 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>减法<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number04 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number4 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>多个计算<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ number5 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { math } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/utils/math.js"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">number1</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number01</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number02</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number2</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number03</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number3</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number04</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number4</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">number5</span>: <span class="hljs-number">0</span>,
    };
  },
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">divide</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">multiply</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">subtract</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">multiplys</span>();
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">divide</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number01</span> = <span class="hljs-number">6.1</span> / <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 60.99999999999999</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number1</span> = math.<span class="hljs-title function_">divide</span>(<span class="hljs-number">6.1</span>, <span class="hljs-number">0.1</span>); <span class="hljs-comment">// 61</span>
    },
    <span class="hljs-title function_">multiply</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number02</span> = <span class="hljs-number">23</span> * <span class="hljs-number">2.4</span>; <span class="hljs-comment">// 55.199999999999996</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number2</span> = math.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">23</span>, <span class="hljs-number">2.4</span>); <span class="hljs-comment">// 55.2</span>
    },
    <span class="hljs-title function_">add</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number03</span> = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>; <span class="hljs-comment">// 0.30000000000000004</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number3</span> = math.<span class="hljs-title function_">add</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>); <span class="hljs-comment">// 0.3</span>
    },
    <span class="hljs-title function_">subtract</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number04</span> = <span class="hljs-number">0.8</span> - <span class="hljs-number">0.7</span>; <span class="hljs-comment">// 0.10000000000000009</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number4</span> = math.<span class="hljs-title function_">subtract</span>(<span class="hljs-number">0.8</span>, <span class="hljs-number">0.7</span>); <span class="hljs-comment">// 0.1</span>
    },
    <span class="hljs-title function_">multiplys</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">number5</span> = math.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 24</span>
    },
  },
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>