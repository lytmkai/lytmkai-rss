<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[构建无障碍组件之Alert Dialog Pattern]]></title>    <link>https://juejin.cn/post/7603911453704028203</link>    <guid>https://juejin.cn/post/7603911453704028203</guid>    <pubDate>2026-02-08T08:43:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603911453704028203" data-draft-id="7603911453704011819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="构建无障碍组件之Alert Dialog Pattern"/> <meta itemprop="keywords" content="前端,HTML,交互设计"/> <meta itemprop="datePublished" content="2026-02-08T08:43:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="anOnion"/> <meta itemprop="url" content="https://juejin.cn/user/553809592722589"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            构建无障碍组件之Alert Dialog Pattern
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/553809592722589/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    anOnion
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T08:43:54.000Z" title="Sun Feb 08 2026 08:43:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Alert Dialog Pattern 详解：构建无障碍中断式对话框</h2>
<p>Alert Dialog 是 Web 无障碍交互的重要组件。本文详解其 WAI-ARIA 实现要点，涵盖角色声明、键盘交互、最佳实践，助你打造中断式对话框，让关键信息触达每位用户。</p>
<h3 data-id="heading-1">一、Alert Dialog 的定义与核心功能</h3>
<p>Alert Dialog（警告对话框）是一种模态对话框，它会中断用户的工作流程以传达重要信息并获取响应。与普通的 Alert 通知不同，Alert Dialog 需要用户明确与之交互后才能继续其他操作。这种设计适用于需要用户立即关注和做出决定的场景。</p>
<p>在实际应用中，Alert Dialog 广泛应用于各种需要用户确认或紧急通知的场景。例如，删除操作前的确认提示、表单提交失败的错误确认、离开页面时的未保存更改提醒等。这些场景都需要用户明确响应才能继续操作，因此 Alert Dialog 成为最佳选择。</p>
<h3 data-id="heading-2">二、Alert Dialog 的特性与注意事项</h3>
<p>Alert Dialog 组件具有几个重要的特性，这些特性决定了它的适用场景和实现方式。首先，Alert Dialog 会获取键盘焦点，确保用户的注意力集中在对话框上。其次，Alert Dialog 通常会阻止用户与页面的其他部分交互，直到用户关闭对话框。这种模态特性确保了用户必须处理重要信息才能继续操作。</p>
<p>Alert Dialog 组件的设计还需要考虑几个关键因素。首先，Alert Dialog 应该始终包含一个明确的关闭方式，如确认按钮或取消按钮。其次，对话框应该有一个清晰的标题，通过 <code>aria-labelledby</code> 或 <code>aria-label</code> 关联。另外，对话框的内容应该通过 <code>aria-describedby</code> 关联，以便屏幕阅读器能够正确读取完整信息。这些属性的正确使用对于无障碍体验至关重要。</p>
<h3 data-id="heading-3">三、WAI-ARIA 角色、状态和属性</h3>
<p>正确使用 WAI-ARIA 属性是构建无障碍 Alert Dialog 组件的技术基础。Alert Dialog 组件的 ARIA 要求包含多个属性的配合使用。</p>
<p><code>role="alertdialog"</code> 是 Alert Dialog 组件的必需属性，它向辅助技术表明这个元素是一个警告对话框。这个属性使浏览器和辅助技术能够将 Alert Dialog 与其他类型的对话框区分开来，从而提供特殊的处理方式，如播放系统提示音。</p>
<p><code>aria-labelledby</code> 或 <code>aria-label</code> 用于标识对话框的标题。如果对话框有可见的标题标签，应该使用 <code>aria-labelledby</code> 引用该标题元素；如果没有可见标题，则使用 <code>aria-label</code> 提供标签。</p>
<p><code>aria-describedby</code> 用于引用包含警告消息的元素。这确保屏幕阅读器能够朗读完整的对话框内容，包括详细的说明和操作提示。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- Alert Dialog 基本结构 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"confirm-dialog"</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？此操作无法撤销。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"actions"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"confirm"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"cancel"</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>
</code></pre>
<p>值得注意的是，Alert Dialog 与普通 Dialog 的主要区别在于 Alert Dialog 用于紧急或重要信息，并且通常包含确认/取消按钮。用户无法忽略 Alert Dialog，必须做出响应才能继续操作。</p>
<h3 data-id="heading-4">四、键盘交互规范</h3>
<p>Alert Dialog 的键盘交互遵循模态对话框的交互模式。用户可以通过多种方式与 Alert Dialog 进行交互。</p>
<ul>
<li><code>Enter</code> 或 <code>Space</code> 用于激活默认按钮，通常是对话框中的主要操作按钮。</li>
<li><code>Tab</code> 键用于在对话框内的焦点元素之间切换，焦点会循环停留 在对话框内部。</li>
<li><code>Escape</code> 键通常用于关闭对话框，相当于点击取消按钮。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ESC 键关闭对话框示例</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'keydown'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">'Escape'</span> &amp;&amp; dialog.<span class="hljs-property">open</span>) {
    dialog.<span class="hljs-title function_">close</span>();
  }
});
</code></pre>
<p>焦点管理是 Alert Dialog 的关键部分。当对话框打开时，焦点应该立即移动到对话框内部或默认按钮上。当对话框关闭时，焦点应该返回到打开对话框的元素。这种焦点管理确保了键盘用户能够保持其工作上下文。</p>
<h3 data-id="heading-5">五、完整示例</h3>
<p>以下是一个完整的 Alert Dialog 实现示例，展示了正确的 HTML 结构、ARIA 属性和焦点管理。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"confirm-dialog"</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？此操作无法撤销。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dialog-actions"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-ghost"</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">"cancel"</span>&gt;</span>
        取消
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-error"</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">"confirm"</span>&gt;</span>
        删除
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"delete-btn"</span>
  <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-error"</span>&gt;</span>
  删除文件
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">const</span> dialog = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'confirm-dialog'</span>);
  <span class="hljs-keyword">const</span> deleteBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'delete-btn'</span>);
  <span class="hljs-keyword">let</span> previousActiveElement;

  deleteBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    previousActiveElement = <span class="hljs-variable language_">document</span>.<span class="hljs-property">activeElement</span>;
    dialog.<span class="hljs-title function_">showModal</span>();
  });

  dialog.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'close'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (dialog.<span class="hljs-property">returnValue</span> === <span class="hljs-string">'confirm'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件已删除'</span>);
    }
    previousActiveElement.<span class="hljs-title function_">focus</span>();
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-6">六、最佳实践</h3>
<h4 data-id="heading-7">6.1 实现方式对比</h4>
<p>Alert Dialog 可以通过两种方式实现：使用 <code>div</code> 配合 ARIA 属性，或使用原生 <code>&lt;dialog&gt;</code> 元素。</p>
<h5 data-id="heading-8">传统方式（div + ARIA）</h5>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-modal</span>=<span class="hljs-string">"true"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>确认<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>这种方式需要开发者手动处理焦点管理、ESC 键关闭、背景锁定等逻辑。</p>
<h5 data-id="heading-9">推荐方式（原生 dialog）</h5>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"confirm"</span>&gt;</span>确认<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"cancel"</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>
</code></pre>
<p>HTML 原生 <code>&lt;dialog&gt;</code> 元素简化了实现，它提供了：</p>
<ul>
<li>自动焦点管理</li>
<li>内置 ESC 键支持</li>
<li>自动模态背景</li>
<li>内置 ARIA 属性</li>
</ul>
<p><code>&lt;dialog&gt;</code> 元素的默认 <code>role</code> 是 <code>dialog</code>，表示普通对话框。对于 Alert Dialog，需要显式设置 <code>role="alertdialog"</code> 来告诉辅助技术这是一个需要紧急处理的对话框，从而获得系统提示音等特殊处理。</p>
<h4 data-id="heading-10">6.2 焦点管理</h4>
<p>正确的焦点管理对于键盘用户和无障碍体验至关重要。打开对话框时，焦点应该移动到对话框内部或默认按钮。关闭对话框时，焦点应该返回到触发对话框的元素。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 焦点管理最佳实践</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">openDialog</span>(<span class="hljs-params">dialog</span>) {
  <span class="hljs-keyword">const</span> previousFocus = <span class="hljs-variable language_">document</span>.<span class="hljs-property">activeElement</span>;
  dialog.<span class="hljs-title function_">showModal</span>();

  <span class="hljs-comment">// 移动焦点到对话框内</span>
  <span class="hljs-keyword">const</span> focusableElements = dialog.<span class="hljs-title function_">querySelectorAll</span>(
    <span class="hljs-string">'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'</span>,
  );
  <span class="hljs-keyword">if</span> (focusableElements.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
    focusableElements[<span class="hljs-number">0</span>].<span class="hljs-title function_">focus</span>();
  }

  <span class="hljs-comment">// 保存关闭时的焦点元素</span>
  dialog.<span class="hljs-property">dataset</span>.<span class="hljs-property">previousFocus</span> = previousFocus;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">closeDialog</span>(<span class="hljs-params">dialog</span>) {
  dialog.<span class="hljs-title function_">close</span>();
  <span class="hljs-keyword">const</span> previousFocus = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(
    <span class="hljs-string">`[data-focus-id="<span class="hljs-subst">${dialog.dataset.focusId}</span>"]`</span>,
  );
  <span class="hljs-keyword">if</span> (previousFocus) {
    previousFocus.<span class="hljs-title function_">focus</span>();
  }
  dialog.<span class="hljs-title function_">remove</span>();
}
</code></pre>
<h4 data-id="heading-11">6.3 避免过度使用</h4>
<p>Alert Dialog 会中断用户的工作流程，因此应该谨慎使用。只有在真正需要用户立即响应的情况下才使用 Alert Dialog。对于非紧急信息，应该考虑使用普通的 Alert 或 Toast 通知。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 不推荐：过度使用 Alert Dialog --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">open</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您的设置已保存。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"this.closest('dialog').close()"</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 推荐：使用普通 Alert --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"alert"</span>&gt;</span>您的设置已保存。<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 data-id="heading-12">6.4 屏幕阅读器兼容性</h4>
<p>确保 <code>&lt;dialog&gt;</code> 对屏幕阅读器用户友好。<code>&lt;dialog&gt;</code> 元素内置了无障碍支持，但仍然建议对 Alert Dialog 设置 <code>role="alertdialog"</code> 来区分紧急对话框。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 屏幕阅读器友好的 dialog --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"session-dialog"</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>重要提醒<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您的会话将在 5 分钟后过期。请尽快保存您的工作。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"actions"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"continue"</span>&gt;</span>继续使用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"exit"</span>&gt;</span>退出<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>
</code></pre>
<h3 data-id="heading-13">七、Alert 与 Alert Dialog 的区别</h3>
<p>理解 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falert%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alert/" ref="nofollow noopener noreferrer">Alert</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falertdialog%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/" ref="nofollow noopener noreferrer">Alert Dialog</a> 的区别对于正确选择通知组件至关重要。虽然两者都是用于传达重要信息，但它们服务于不同的目的和使用场景。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falert%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alert/" ref="nofollow noopener noreferrer">Alert</a> 是一种被动通知组件，它不需要用户进行任何交互操作。Alert 会在不被中断用户工作流程的前提下自动通知用户重要信息。用户可以继续当前的工作，Alert 只是在视觉和听觉上提供通知。这种设计适用于不紧急、不需要用户立即响应的信息，例如操作成功确认、后台处理完成通知等。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falertdialog%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/" ref="nofollow noopener noreferrer">Alert Dialog</a> 则是一种需要用户主动响应的对话框组件。当用户需要做出决定或者提供确认时，应该使用 Alert Dialog。Alert Dialog 会中断用户的工作流程，获取键盘焦点，要求用户必须与之交互才能继续其他操作。这种设计适用于紧急警告、确认删除操作、放弃更改确认等需要用户明确响应的场景。</p>
<p>选择建议：如果信息需要用户立即响应并做出决定，使用 Alert Dialog；如果只是被动通知信息，使用 Alert。</p>
<h3 data-id="heading-14">八、总结</h3>
<p>构建无障碍的对话框组件需要关注元素选择、焦点管理、键盘交互三个层面的细节。从元素选择角度，推荐优先使用原生 <code>&lt;dialog&gt;</code> 元素，它内置了无障碍支持和焦点管理。从焦点管理角度，需要确保打开和关闭时焦点的正确移动。从用户体验角度，应该避免过度使用对话框，只在真正需要用户响应时使用。</p>
<p>WAI-ARIA <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falertdialog%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/" ref="nofollow noopener noreferrer">Alert Dialog Pattern</a> 为我们提供了清晰的指导方针，遵循这些规范能够帮助我们创建更加包容和易用的 Web 应用。每一个正确实现的对话框，都是提升用户体验和确保重要信息有效传达的重要一步。</p>
<p>文章同步于 an-Onion 的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fan-Onion%2Fan-Onion.github.io" target="_blank" title="https://github.com/an-Onion/an-Onion.github.io" ref="nofollow noopener noreferrer">Github</a>。码字不易，欢迎点赞。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JDK 6到25 全版本网盘合集 (Windows + Mac + Linux)]]></title>    <link>https://juejin.cn/post/7603677143214784527</link>    <guid>https://juejin.cn/post/7603677143214784527</guid>    <pubDate>2026-02-08T09:02:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603677143214784527" data-draft-id="7603671627003887656" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JDK 6到25 全版本网盘合集 (Windows + Mac + Linux)"/> <meta itemprop="keywords" content="Java,后端"/> <meta itemprop="datePublished" content="2026-02-08T09:02:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="宋小黑"/> <meta itemprop="url" content="https://juejin.cn/user/897618008110413"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JDK 6到25 全版本网盘合集 (Windows + Mac + Linux)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/897618008110413/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    宋小黑
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T09:02:31.000Z" title="Sun Feb 08 2026 09:02:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">所有版本合集</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96b6be38a95b45aebfdb0cb0aae83bde~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6L5bCP6buR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771146151&amp;x-signature=kLdS8tdlWgU22BBeyqw6pVipNTE%3D" alt="image.png" loading="lazy"/></p>
<p>通过网盘分享的文件：JDK全集</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1KmnYXE8jrs2dnLriuN1Vdw%3Fpwd%3Ditpr" target="_blank" title="https://pan.baidu.com/s/1KmnYXE8jrs2dnLriuN1Vdw?pwd=itpr" ref="nofollow noopener noreferrer">pan.baidu.com/s/1KmnYXE8j…</a></p>
<p>提取码: itpr</p>
<p>如下是各单独版本</p>
<h2 data-id="heading-1">JDK1.6</h2>
<p>通过网盘分享的文件：JDK1.6</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1tWHFnzoaB4fbSl1MYd8qgg%3Fpwd%3Dgr79" target="_blank" title="https://pan.baidu.com/s/1tWHFnzoaB4fbSl1MYd8qgg?pwd=gr79" ref="nofollow noopener noreferrer">pan.baidu.com/s/1tWHFnzoa…</a></p>
<p>提取码: gr79</p>
<h2 data-id="heading-2">JDK1.7</h2>
<p>通过网盘分享的文件：JDK1.7</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1dQIDiPUqnta3yQi55pcm2A%3Fpwd%3Dxhkh" target="_blank" title="https://pan.baidu.com/s/1dQIDiPUqnta3yQi55pcm2A?pwd=xhkh" ref="nofollow noopener noreferrer">pan.baidu.com/s/1dQIDiPUq…</a></p>
<p>提取码: xhkh</p>
<h2 data-id="heading-3">JDK1.8</h2>
<p>通过网盘分享的文件：JDK1.8</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1iCS3Yi1-_kjquJyZk6oDLA%3Fpwd%3Dtg6k" target="_blank" title="https://pan.baidu.com/s/1iCS3Yi1-_kjquJyZk6oDLA?pwd=tg6k" ref="nofollow noopener noreferrer">pan.baidu.com/s/1iCS3Yi1-…</a></p>
<p>提取码: tg6k</p>
<h2 data-id="heading-4">JDK9</h2>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1aBO393S59b5ujVymdF0vTg%3Fpwd%3Dtua1" target="_blank" title="https://pan.baidu.com/s/1aBO393S59b5ujVymdF0vTg?pwd=tua1" ref="nofollow noopener noreferrer">pan.baidu.com/s/1aBO393S5…</a></p>
<p>提取码: tua1</p>
<h2 data-id="heading-5">JDK10</h2>
<p>通过网盘分享的文件：JDK10</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F15OXI6JChAp2Q3IttHDDfmg%3Fpwd%3D6a7t" target="_blank" title="https://pan.baidu.com/s/15OXI6JChAp2Q3IttHDDfmg?pwd=6a7t" ref="nofollow noopener noreferrer">pan.baidu.com/s/15OXI6JCh…</a></p>
<p>提取码: 6a7t</p>
<h2 data-id="heading-6">JDK11</h2>
<p>通过网盘分享的文件：JDK11</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1vddDP0HGF0bOLPLwb-FovA%3Fpwd%3Dwmep" target="_blank" title="https://pan.baidu.com/s/1vddDP0HGF0bOLPLwb-FovA?pwd=wmep" ref="nofollow noopener noreferrer">pan.baidu.com/s/1vddDP0HG…</a></p>
<p>提取码: wmep</p>
<h2 data-id="heading-7">JDK12</h2>
<p>通过网盘分享的文件：JDK12</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F191YElh8MPBH8uoT8zg6tLg%3Fpwd%3Dbmzp" target="_blank" title="https://pan.baidu.com/s/191YElh8MPBH8uoT8zg6tLg?pwd=bmzp" ref="nofollow noopener noreferrer">pan.baidu.com/s/191YElh8M…</a></p>
<p>提取码: bmzp</p>
<h2 data-id="heading-8">JDK13</h2>
<p>通过网盘分享的文件：JDK13</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1O5mJcvDXEFObYg91TUGXFA%3Fpwd%3D7wrs" target="_blank" title="https://pan.baidu.com/s/1O5mJcvDXEFObYg91TUGXFA?pwd=7wrs" ref="nofollow noopener noreferrer">pan.baidu.com/s/1O5mJcvDX…</a></p>
<p>提取码: 7wrs</p>
<h2 data-id="heading-9">JDK14</h2>
<p>通过网盘分享的文件：JDK14</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1Xl5rrDGh80-Fxlo_Ug3wfg%3Fpwd%3Drve7" target="_blank" title="https://pan.baidu.com/s/1Xl5rrDGh80-Fxlo_Ug3wfg?pwd=rve7" ref="nofollow noopener noreferrer">pan.baidu.com/s/1Xl5rrDGh…</a></p>
<p>提取码: rve7</p>
<h2 data-id="heading-10">JDK15</h2>
<p>通过网盘分享的文件：JDK15</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F194EF9-_Rmh9AX0DH2FWM5w%3Fpwd%3Dkuxj" target="_blank" title="https://pan.baidu.com/s/194EF9-_Rmh9AX0DH2FWM5w?pwd=kuxj" ref="nofollow noopener noreferrer">pan.baidu.com/s/194EF9-_R…</a></p>
<p>提取码: kuxj</p>
<h2 data-id="heading-11">JDK16</h2>
<p>通过网盘分享的文件：JDK16</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1iqcpE1FIa6AsVMsGIYn59w%3Fpwd%3D4j7p" target="_blank" title="https://pan.baidu.com/s/1iqcpE1FIa6AsVMsGIYn59w?pwd=4j7p" ref="nofollow noopener noreferrer">pan.baidu.com/s/1iqcpE1FI…</a></p>
<p>提取码: 4j7p</p>
<h2 data-id="heading-12">JDK17</h2>
<p>通过网盘分享的文件：JDK17</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1Bk5lV7DxukOTi9h0muvrjg%3Fpwd%3Dk686" target="_blank" title="https://pan.baidu.com/s/1Bk5lV7DxukOTi9h0muvrjg?pwd=k686" ref="nofollow noopener noreferrer">pan.baidu.com/s/1Bk5lV7Dx…</a></p>
<p>提取码: k686</p>
<h2 data-id="heading-13">JDK18</h2>
<p>通过网盘分享的文件：JDK18</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1PkPOK_ap-vE8pdXCTFns3Q%3Fpwd%3Dfyiv" target="_blank" title="https://pan.baidu.com/s/1PkPOK_ap-vE8pdXCTFns3Q?pwd=fyiv" ref="nofollow noopener noreferrer">pan.baidu.com/s/1PkPOK_ap…</a></p>
<p>提取码: fyiv</p>
<h2 data-id="heading-14">JDK19</h2>
<p>通过网盘分享的文件：JDK19</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1001F7reDD3f4kElZwxhJjQ%3Fpwd%3D5i5s" target="_blank" title="https://pan.baidu.com/s/1001F7reDD3f4kElZwxhJjQ?pwd=5i5s" ref="nofollow noopener noreferrer">pan.baidu.com/s/1001F7reD…</a></p>
<p>提取码: 5i5s</p>
<h2 data-id="heading-15">JDK20</h2>
<p>通过网盘分享的文件：JDK20</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1WAg3fEMGlyMMWUkHla_AIQ%3Fpwd%3Daeft" target="_blank" title="https://pan.baidu.com/s/1WAg3fEMGlyMMWUkHla_AIQ?pwd=aeft" ref="nofollow noopener noreferrer">pan.baidu.com/s/1WAg3fEMG…</a></p>
<p>提取码: aeft</p>
<h2 data-id="heading-16">JDK21</h2>
<p>通过网盘分享的文件：JDK21</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1HS0nV4NgRE5McYlMn87SlA%3Fpwd%3Dkwwr" target="_blank" title="https://pan.baidu.com/s/1HS0nV4NgRE5McYlMn87SlA?pwd=kwwr" ref="nofollow noopener noreferrer">pan.baidu.com/s/1HS0nV4Ng…</a></p>
<p>提取码: kwwr</p>
<h2 data-id="heading-17">JDK22</h2>
<p>通过网盘分享的文件：JDK22</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1S2EqTU8a16Ey6bEBKbS4CA%3Fpwd%3Db2fe" target="_blank" title="https://pan.baidu.com/s/1S2EqTU8a16Ey6bEBKbS4CA?pwd=b2fe" ref="nofollow noopener noreferrer">pan.baidu.com/s/1S2EqTU8a…</a></p>
<p>提取码: b2fe</p>
<h2 data-id="heading-18">JDK23</h2>
<p>通过网盘分享的文件：JDK23</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1H_B4e2RG2hE_tGj3vL_SCQ%3Fpwd%3Dy4bp" target="_blank" title="https://pan.baidu.com/s/1H_B4e2RG2hE_tGj3vL_SCQ?pwd=y4bp" ref="nofollow noopener noreferrer">pan.baidu.com/s/1H_B4e2RG…</a></p>
<p>提取码: y4bp</p>
<h2 data-id="heading-19">JDK24</h2>
<p>通过网盘分享的文件：JDK24</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1vKSW4DDaDG8URWVrWaj2-A%3Fpwd%3D1jy2" target="_blank" title="https://pan.baidu.com/s/1vKSW4DDaDG8URWVrWaj2-A?pwd=1jy2" ref="nofollow noopener noreferrer">pan.baidu.com/s/1vKSW4DDa…</a></p>
<p>提取码: 1jy2</p>
<h2 data-id="heading-20">JDK25</h2>
<p>通过网盘分享的文件：JDK25</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1tuBLLj-6DyPunBZRzTBF9Q%3Fpwd%3Ddc9f" target="_blank" title="https://pan.baidu.com/s/1tuBLLj-6DyPunBZRzTBF9Q?pwd=dc9f" ref="nofollow noopener noreferrer">pan.baidu.com/s/1tuBLLj-6…</a></p>
<p>提取码: dc9f</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring 源码分析 BeanFactoryPostProcessor]]></title>    <link>https://juejin.cn/post/7603771025856528435</link>    <guid>https://juejin.cn/post/7603771025856528435</guid>    <pubDate>2026-02-08T06:21:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856528435" data-draft-id="7599852579067133967" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring 源码分析 BeanFactoryPostProcessor"/> <meta itemprop="keywords" content="Spring,Spring Boot,源码"/> <meta itemprop="datePublished" content="2026-02-08T06:21:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="暮色妖娆丶"/> <meta itemprop="url" content="https://juejin.cn/user/4292946760307655"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring 源码分析 BeanFactoryPostProcessor
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4292946760307655/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    暮色妖娆丶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:21:32.000Z" title="Sun Feb 08 2026 06:21:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>上一篇讲述了 <code>SpringBoot</code> 启动流程和相关源码分析，其中一个重要的刷新方法  <code>AbstractApplicationContext#refresh()</code> 是属于 <code>Spring</code> 的内容，也是 <code>Spring</code> 框架的核心方法，搞懂了这个方法，基本上可以说就完全搞懂了 <code>Spring</code></p>
<p>想了很久不知道对于这样一个复杂的框架，从何开始讲起，那么就按照 <code>AbstractApplicationContext#refresh()</code> 的内部代码顺序来吧，先学习 <code>BeanFactoryPostProcessor</code>。</p>
<p>本篇文章使用的版本是 <code>SpringBoot 3.4.1 、 Spring 6.2.1</code>。</p>
<h2 data-id="heading-1">SpringBoot &amp; Spring 架构图示概览</h2>
<p>这里我以 <code>SpringBoot</code> 源码入口为起点，画了一个相关的流程图，包含了 <code>SpringBoot、Spring 事务、Spring AOP、Spring 事件、BeanFactoryPostProcessor、BeanPostProcessor</code> 等所有 <code>Spring</code> 知识，以及相关模块之间的交互联系，后续也会持续更新此图（因为我自己还没有学完），我试了下作者侧这边更新后，分享的协作链接也会实时变更，希望对大家有帮助</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.processon.com%2Fv%2F696465e679c29354e9e50f69" target="_blank" title="https://www.processon.com/v/696465e679c29354e9e50f69" ref="nofollow noopener noreferrer">SpringBoot &amp; Spring 架构图 持续更新</a> 对于即将需要面试的同学应该会比较有帮助！</p>
<h2 data-id="heading-2">前置知识 IoC 容器</h2>
<p><code>IoC</code> 全称 <code>Inversion of Control</code>，叫做控制反转，它是一种设计原则，其核心思想是将对象创建、依赖管理和生命周期控制的权力从应用程序代码 <strong>反转</strong> 给容器（框架）。</p>
<p>原本我们需要调用某个业务方法，需要自己实例化对象，然后调用该对象某个方法，使用 <code>Spring</code> 之后，我们把该对象交给 <code>Spring</code> 管理，<code>Spring</code> 框架帮我们创建对象，我们只需要拿 <code>Spring</code> 创建好的对象即可。而我们交给 <code>Spring</code> 管理的对象通常就叫做 <code>Bean</code>。</p>
<p><code>IoC</code> 容器就是通常我们常说的 <code>Spring 上下文</code>，<code>ApplicationContext</code> 的实现类，对于 <code>SpringBoot</code> 来说，其扩展的实现类是 <code>AnnotationConfigServletWebServerApplicationContext</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
   <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(SpringAiDemoApplication.class, args);
}
</code></pre>
<p><code>SpringBoot</code> 主类的 <code>run</code> 方法，其返回值就是一个 <code>IoC</code> 容器，<code>ApplicationContext</code> 的子接口</p>
<h2 data-id="heading-3">前置知识 BeanDefinition 和 Bean</h2>
<p>在开始之前，我相信大家都是已经熟悉 <code>Spring</code> 框架的日常用法，我们需要有一个前置知识储备，在 <code>Spring</code> 容器中，<code>Bean</code> 的创建都是由 <code>BeanDefinition</code> 决定的， <code>BeanDefinition</code> 描述了这个 <code>Bean</code> 的所有信息</p>
<ul>
<li><code>Bean</code> 的类型</li>
<li><code>Bean</code> 的名字</li>
<li>单例还是多例</li>
<li>是否延迟加载</li>
<li>是否允许自动装配</li>
<li>等等</li>
</ul>
<p>比如我们使用 <code>@Configuration、@Bean、@Component</code> 注解一个 <code>Bean</code>。刷新方法中，先解析这些注解得到了 <code>BeanDefinition</code> 信息，当所有配置相关的注解被解析完，得到一个</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">256</span>);
</code></pre>
<p>然后 <code>Spring</code> 遍历这个 <code>beanDefinitionNames</code> 去创建 <code>Bean</code>。</p>
<blockquote>
<p>因为 HashMap 是无序的，创建 Bean 需要根据顺序创建，所以需要这个 beanDefinitionNames</p>
</blockquote>
<h2 data-id="heading-4">BeanFactoryPostProcessor 的作用</h2>
<p>学习源码，最有效的方式之一就是看注释，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Factory hook that allows for custom modification of an application context's
 * bean definitions, adapting the bean property values of the context's underlying
 * bean factory.
 * ......
 */</span>
<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> {

    <span class="hljs-comment">/**
     * Modify the application context's internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for overriding or adding
     * properties even to eager-initializing beans.
     * <span class="hljs-doctag">@param</span> beanFactory the bean factory used by the application context
     * <span class="hljs-doctag">@throws</span> org.springframework.beans.BeansException in case of errors
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;

}
</code></pre>
<p>注释说明这个类的作用相当于一个工厂回调函数（通常我们叫它 <code>Bean 工厂后置处理器</code>），可以调整上下文的底层<code>Bean</code> 工厂的 <code>Bean</code> 属性值。也就是在 <code>Bean</code> 创建前，<code>BeanDefinition</code> 已默认加载后，修改某些 <code>BeanDefinition</code> 。因为 <code>Bean</code> 的创建是由 <code>BeanDefinition</code> 决定的，所以修改 <code>BeanDefinition</code>，也就相当于修改即将要创建的 <code>Bean</code></p>
<h2 data-id="heading-5">内置的 BeanFactoryPostProcessor</h2>
<p>在上一篇 <code>SpringBoot</code> 文章中，我们提到在创建 <code>Spring</code> 上下文的时候，<code>AnnotationConfigServletWebServerApplicationContext</code> 的构造方法中，会注册一些内置的 <code>BeanFactoryPostProcessor</code>。源码</p>
<pre><code class="hljs language-java" lang="java">org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()
</code></pre>
<p>内置会注册以下后置处理器</p>
<pre><code class="hljs language-java" lang="java">ConfigurationClassPostProcessor  处理所有配置注解 <span class="hljs-meta">@Componentscan</span>、<span class="hljs-meta">@Import</span>、<span class="hljs-meta">@Bean</span>、<span class="hljs-meta">@Component</span> 等
AutowiredAnnotationBeanPostProcessor  处理 <span class="hljs-meta">@Autowired</span>
CommonAnnotationBeanPostProcessor     处理 <span class="hljs-meta">@PostConstruct</span>、<span class="hljs-meta">@Resource</span> 等
PersistenceAnnotationBeanPostProcessor(如果用了 JPA)
EventListenerMethodProcessor    处理 <span class="hljs-meta">@EventListener</span>
DefaultEventListenerFactory  （不是后置处理器，不知道为什么放在这个方法里）
</code></pre>
<p>这里只有 <code>ConfigurationClassPostProcessor</code> 和 <code>EventListenerMethodProcessor</code> 是工厂后置处理器 <code>BeanFactoryPostProcessor</code>，其他都是 Bean 的后置处理器 <code>BeanPostProcessor</code>，下一篇文章会介绍。在介绍 <code>ConfigurationClassPostProcessor</code> 和 <code>EventListenerMethodProcessor</code> 的作用之前，我们先学习一个 <code>BeanFactoryPostProcessor</code> 的扩展接口 <code>BeanDefinitionRegistryPostProcessor</code>。</p>
<h2 data-id="heading-6">BeanDefinitionRegistryPostProcessor</h2>
<p>还是老规矩，学习一个类之前先看注释</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Extension to the standard {<span class="hljs-doctag">@link</span> BeanFactoryPostProcessor} SPI, allowing for
 * the registration of further bean definitions &lt;i&gt;before&lt;/i&gt; regular
 * BeanFactoryPostProcessor detection kicks in. In particular,
 * BeanDefinitionRegistryPostProcessor may register further bean definitions
 * which in turn define BeanFactoryPostProcessor instances.

 * <span class="hljs-doctag">@see</span> org.springframework.context.annotation.ConfigurationClassPostProcessor
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> {

    <span class="hljs-comment">/**
     * Modify the application context's internal bean definition registry after its
     * standard initialization. All regular bean definitions will have been loaded,
     * but no beans will have been instantiated yet. This allows for adding further
     * bean definitions before the next post-processing phase kicks in.
     * <span class="hljs-doctag">@param</span> registry the bean definition registry used by the application context
     * <span class="hljs-doctag">@throws</span> org.springframework.beans.BeansException in case of errors
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException;
}
</code></pre>
<p>注释说 <code>BeanDefinitionRegistryPostProcessor</code> 是 <code>BeanFactoryPostProcessor</code> 的一个扩展接口。容器刷新过程中 <code>postProcessBeanDefinitionRegistry()</code> 在 <code>postProcessBeanFactory()</code> 之前执行，他们的区别和作用如下</p>
<h3 data-id="heading-7">和 BeanFactoryPostProcessor 的区别对比</h3>
<p>这里用一个表格来对比 <code>BeanDefinitionRegistryPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 的方法</p>



































<table><thead><tr><th>维度</th><th>postProcessBeanDefinitionRegistry</th><th>postProcessBeanFactory</th></tr></thead><tbody><tr><td><strong>执行时机</strong></td><td><strong>更早</strong>，在所有 BeanFactoryPostProcessor 之前</td><td><strong>稍晚</strong>，在所有 postProcessBeanDefinitionRegistry 之后</td></tr><tr><td><strong>参数类型</strong></td><td><code>BeanDefinitionRegistry</code></td><td><code>ConfigurableListableBeanFactory</code></td></tr><tr><td><strong>主要用途</strong></td><td><strong>注册、修改、移除</strong> BeanDefinition</td><td><strong>修改</strong> 已注册的 BeanDefinition，不能注册和移除</td></tr><tr><td><strong>能力范围</strong></td><td><strong>注册新 Bean</strong> 的能力更强</td><td><strong>修改现有 Bean</strong> 的属性</td></tr><tr><td><strong>执行顺序</strong></td><td>第一阶段</td><td>第二阶段</td></tr></tbody></table>
<p>也就是说他们两都是对 <code>BeanDefinition</code> 做操作的，只不过时机不同</p>
<h2 data-id="heading-8">常见的 BeanFactoryPostProcessor</h2>
<p><code>SpringBoot</code> 项目中有一些内置的工厂后置处理器</p>
<ul>
<li><code>ConfigurationClassPostProcessor</code>  解析配置类，获取 <code>BeanDefiniton</code></li>
<li><code>EventListenerMethodProcessor</code>     初始化事件工厂，为了后续创建事件监听器</li>
<li><code>PropertySourcesPlaceholderConfigurer</code> 处理配置类成员变量的值有属性占位符，比如有些 <code>Bean</code> 的某个属性值是 <code>${mybatis-plus.lazy-initialization}</code> 这种表达式，就是通过这个后置处理器来解析赋值</li>
<li><code>MapperScannerConfigurer</code> 如果使用了 <code>mybatis</code> ，扫描 <code>@Mapper</code> 注解的类，添加到 <code>Spring</code> 容器</li>
<li><code>CachingMetadataReaderFactoryPostProcessor</code>  缓存 <code>ResourceLoader</code> 已加载的配置类，不要重复加载</li>
</ul>
<p>下面我们详细介绍其中几个重要的工厂后置处理器的作用。</p>
<h2 data-id="heading-9">BeanFactoryPostProcessor 的执行</h2>
<p>工厂后置处理器的执行方法是通过一个委托类 <code>PostProcessorRegistrationDelegate</code> 实现的</p>
<pre><code class="hljs language-java" lang="java">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
</code></pre>
<p>这个方法非常有意思，作者在这里给出了一大段的注释，告诉读者不要再去 <code>Github</code> 提 <code>issue</code> 了，因为这个方法的代码看起来很乱、有很多重复代码，很多读者提了 <code>issue</code> 表明这个方法需要优化，但是作者一一拒绝，回应说这种实现是必要的，一定要确保工厂后置处理器的执行顺序。有兴趣可以查阅上述方法的源码</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a1cf98563ec41d08e400d64fcb53590~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=ork6UczAeDRGazI37V22JO8O63Y%3D" alt="image.png" loading="lazy"/></p>
<p>这里作者将 <code>BeanDefinitionRegistryPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 分开，并且将它们分别按照顺序排序放到不同列表中依次执行。</p>
<blockquote>
<p>注意，这个阶段还没有创建 <code>Bean</code> ，所以要执行的 <code>BeanFactoryPostProcessor</code> ，都是通过从 <code>BeanFactory</code> 里面的 <code>beanDefinitonNames</code> 集合拿到的，使用 <code>beanFactory.getBeanNamesForType()</code> 方法</p>
</blockquote>
<h2 data-id="heading-10">配置类加载原理 （非常非常重要）ConfigurationClassPostProcessor</h2>
<p>这是一个非常重要的 <code>BeanFactoryPostProcessor</code>，<code>Spring</code> 项目启动加载配置类几乎全都是它实现的，除了我们自己声明的 <code>Service、Controller</code>。 配置类本身也是 <code>Spring Bean</code>。</p>
<p>其实我们查看源码会发现 <code>@Service、@Controller、@Configuration</code> 本身就是一个 <code>@Component</code>。查看 <code>@Component</code> 的注释</p>
<pre><code class="hljs language-vbnet" lang="vbnet">/**
 * Indicates that the annotated <span class="hljs-keyword">class</span> <span class="hljs-built_in">is</span> a &lt;em&gt;component&lt;/em&gt;.
 *
 * &lt;p&gt;Such classes are considered <span class="hljs-keyword">as</span> candidates <span class="hljs-keyword">for</span> <span class="hljs-keyword">auto</span>-detection
 * <span class="hljs-keyword">when</span> <span class="hljs-keyword">using</span> annotation-based configuration <span class="hljs-built_in">and</span> classpath scanning.
 */
</code></pre>
<p>被这个注解标注的类都会被视为一个组件，在被扫描的时候会被认为是一个配置类</p>
<h3 data-id="heading-11">代码解读</h3>
<p><code>ConfigurationClassPostProcessor</code> 是一个 <code>BeanDefinitionRegistryPostProcessor</code> 。我们查看源码方法的调用过程 <code>postProcessBeanDefinitionRegistry → processConfigBeanDefinitions → ConfigurationClassParser#parse → ConfigurationClassParser#processConfigurationClass → ConfigurationClassParser#doProcessConfigurationClass(arg1,arg2) → doProcessConfigurationClass(arg1,arg2,arg3)</code></p>
<p>先看 <code>parse()</code> 方法</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> {
    <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : configCandidates) {
       <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> holder.getBeanDefinition();
       <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition annotatedBeanDef) {
             parse(annotatedBeanDef, holder.getBeanName());
          }
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition abstractBeanDef &amp;&amp; abstractBeanDef.hasBeanClass()) {
             parse(abstractBeanDef.getBeanClass(), holder.getBeanName());
          }
          <span class="hljs-keyword">else</span> {
             parse(bd.getBeanClassName(), holder.getBeanName());
          }
       }
       <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) {
          <span class="hljs-keyword">throw</span> ex;
       }
       <span class="hljs-keyword">catch</span> (Throwable ex) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(
                <span class="hljs-string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="hljs-string">"]"</span>, ex);
       }
    }

    <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.process();
}
</code></pre>
<p>我们传入的入参就是 <code>SpringBoot</code> 主类的 <code>BeanDefinition</code>，这个方法根据 <code>BeanDefinition</code> 实际的类型走不同的重载方法，<code>SpringBoot</code> 项目主类的定义类型是 <code>AnnotatedBeanDefinition</code> 。 接下来我们看 <code>doProcessConfigurationClass(arg1,arg2)</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> {
     <span class="hljs-comment">//......</span>
    <span class="hljs-comment">// 循环处理配置类，返回的 sourceClass 是父类，只要不为空就一直向上找父类循环处理</span>
    <span class="hljs-type">SourceClass</span> <span class="hljs-variable">sourceClass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span> {
       sourceClass = asSourceClass(configClass, filter);
       <span class="hljs-keyword">do</span> {
          sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
       }
       <span class="hljs-keyword">while</span> (sourceClass != <span class="hljs-literal">null</span>);
    }
    <span class="hljs-keyword">catch</span> (IOException ex) {
    <span class="hljs-comment">//...</span>
    }

    <span class="hljs-built_in">this</span>.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>这里有一个循环，解析传入的配置类，返回该配置类的父类，如果该配置类的父类不为空，就一直解析。
接下来内部最直观的解析配置类的方法 <code>doProcessConfigurationClass(arg1,arg2,arg3)</code> 。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title function_">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span> {
    <span class="hljs-keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) {
       <span class="hljs-comment">// 解析内部类。比如一个加了 @Configuration 的配置类，有一个静态内部类也加了 @Configuration</span>
       processMemberClasses(configClass, sourceClass, filter);
    }

    <span class="hljs-comment">// 解析 @PropertySource 注解</span>
    <span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
          sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,
          PropertySources.class, <span class="hljs-literal">true</span>)) {
       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.propertySourceRegistry != <span class="hljs-literal">null</span>) {
          <span class="hljs-built_in">this</span>.propertySourceRegistry.processPropertySource(propertySource);
       }
    }

    <span class="hljs-comment">// 解析 @ComponentScans 注解</span>
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),ComponentScan.class, ComponentScans.class, MergedAnnotation::isDirectlyPresent);

    <span class="hljs-keyword">if</span> (componentScans.isEmpty()) {
       componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);
    }

    <span class="hljs-keyword">if</span> (!componentScans.isEmpty()) {
       List&lt;Condition&gt; registerBeanConditions = collectRegisterBeanConditions(configClass);
       <span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) {
          <span class="hljs-comment">// 解析 @ComponentScan 注解(注意这里直接向 Spring 容器注册了 BeanDefiniton)</span>
          <span class="hljs-comment">//其他注解解析都是先封装成一个 ConfigurationClass 对象，后续统一注册 BeanDefinition</span>
          Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = <span class="hljs-built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
          <span class="hljs-comment">// 检查 @ComponentScan 扫描到的配置类是否还有其他配置注解，例如 @Import，递归解析</span>
          <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) {
             <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bdCand</span> <span class="hljs-operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();
             <span class="hljs-keyword">if</span> (bdCand == <span class="hljs-literal">null</span>) {
                bdCand = holder.getBeanDefinition();
             }
             <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-built_in">this</span>.metadataReaderFactory)) {
                parse(bdCand.getBeanClassName(), holder.getBeanName());
             }
          }
       }
    }

    <span class="hljs-comment">// 解析 @Import 注解（SpringBoot 自动配置类的核心实现）</span>
    processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="hljs-literal">true</span>);

    <span class="hljs-comment">//解析 @ImportResource 注解</span>
    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">importResource</span> <span class="hljs-operator">=</span> AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    <span class="hljs-keyword">if</span> (importResource != <span class="hljs-literal">null</span>) {
       String[] resources = importResource.getStringArray(<span class="hljs-string">"locations"</span>);
       Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="hljs-string">"reader"</span>);
       <span class="hljs-keyword">for</span> (String resource : resources) {
          <span class="hljs-type">String</span> <span class="hljs-variable">resolvedResource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.environment.resolveRequiredPlaceholders(resource);
          configClass.addImportedResource(resolvedResource, readerClass);
       }
    }

    <span class="hljs-comment">// 解析 @Bean 注解</span>
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    <span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) {
       <span class="hljs-keyword">if</span> (methodMetadata.isAnnotated(<span class="hljs-string">"kotlin.jvm.JvmStatic"</span>) &amp;&amp; !methodMetadata.isStatic()) {
          <span class="hljs-keyword">continue</span>;
       }
       configClass.addBeanMethod(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanMethod</span>(methodMetadata, configClass));
    }

    <span class="hljs-comment">// 解析当前类实现的接口里面加了 @Bean 的 default 方法</span>
    processInterfaces(configClass, sourceClass);

    <span class="hljs-comment">// 解析父类</span>
    <span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) {
       <span class="hljs-type">String</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> sourceClass.getMetadata().getSuperClassName();
       <span class="hljs-keyword">if</span> (superclass != <span class="hljs-literal">null</span> &amp;&amp; !superclass.startsWith(<span class="hljs-string">"java"</span>)) {
          <span class="hljs-type">boolean</span> <span class="hljs-variable">superclassKnown</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.knownSuperclasses.containsKey(superclass);
          <span class="hljs-built_in">this</span>.knownSuperclasses.add(superclass, configClass);
          <span class="hljs-keyword">if</span> (!superclassKnown) {
             <span class="hljs-comment">// Superclass found, return its annotation metadata and recurse</span>
             <span class="hljs-keyword">return</span> sourceClass.getSuperClass();
          }
       }
    }
    <span class="hljs-comment">// No superclass -&gt; processing is complete</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<p>我们可以继续阅读 <code>processMemberClasses()、processImports()</code> 等每一个具体解析注解的方法，会发现
这个解析方法的调用是一个递归的过程。先根据一个主配置类，在 <code>SpringBoot</code> 中就是应用启动主类。由于 <code>@SpringBootApplication</code> 内部组合了 <code>@Configuration</code> ，所以它是一个配置类，<code>SpringBoot</code> 会以主类为入口，从它开始扫描，然后由于 <code>SpringBootApplication</code> 内部组合了 <code>@ComponentScan</code> 注解，所以会解析主类所在的包下的所有配置类。然后由于它内部又组合了 <code>SpringBootApplication → @EnableAutoConfiguration → @Import(AutoConfigurationImportSelector.class)</code>，所以会解析 <code>AutoConfigurationImportSelector</code> 获取的所有配置类。这也是 <code>SpringBoot</code> 自动配置的核心实现原理</p>
<h3 data-id="heading-12">SpringBoot 自动配置的核心原理</h3>
<p>在 <code>SpringBoot</code> 文章中我们说过，这个 <code>AutoConfigurationImportSelector</code> 是 <code>SpringBoot</code> 自动配置的核心。从上面的解析方法 <code>doProcessConfigurationClass(arg1,arg2,arg3)</code> 我们知道它会解析 <code>@Import</code> 注解，然后我们看  <code>processImports()</code> 的源码</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">for</span> (SourceClass candidate : importCandidates) {
    <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportSelector.class)) {
       <span class="hljs-comment">// 处理 ImportSelector 的逻辑</span>
       Class&lt;?&gt; candidateClass = candidate.loadClass();
       <span class="hljs-type">ImportSelector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,<span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);
       Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();
       <span class="hljs-keyword">if</span> (selectorFilter != <span class="hljs-literal">null</span>) {
          filter = filter.or(selectorFilter);
       }
       <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DeferredImportSelector deferredImportSelector) {
          <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);
       }
       <span class="hljs-keyword">else</span> {
          String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
          Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, filter);
          processImports(configClass, currentSourceClass, importSourceClasses, filter, <span class="hljs-literal">false</span>);
       }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
       <span class="hljs-comment">// 处理 ImportBeanDefinitionRegistrar 的逻辑</span>
       Class&lt;?&gt; candidateClass = candidate.loadClass();
       <span class="hljs-type">ImportBeanDefinitionRegistrar</span> <span class="hljs-variable">registrar</span> <span class="hljs-operator">=</span>
             ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
                   <span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);
       configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
    }
    <span class="hljs-keyword">else</span> {
       <span class="hljs-comment">// 处理普通配置类的逻辑</span>
       <span class="hljs-built_in">this</span>.importStack.registerImport(
             currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
       processConfigurationClass(candidate.asConfigClass(configClass), filter);
    }
}

</code></pre>
<p>这里对于 <code>@Import</code> 有三种处理逻辑，相当于一个策略模式的体现</p>
<ul>
<li><code>@Import(XxxImportSelector.class)</code> 执行 <code>selectImports</code> 获取导入的配置类</li>
<li><code>@Import(XxxImportBeanDefinitionRegistrar.class)</code> 执行 <code>registerBeanDefinitions</code> 注册 <code>BeanDefinition</code></li>
<li><code>@Import(XxxConfiguration.class)</code> 普通配置类，直接解析</li>
</ul>
<p>对于 <code>@Import</code> 注解中的不同类型值，会进行不同的处理逻辑，但最终都是解析配置类，无非是导入的方式不同，具体我们可以看对应接口的方法说明。</p>
<blockquote>
<p>注意对于 <code>ImportSelector</code> 有两种处理方式，它有一个子接口 <code>DeferredImportSelector</code>，延迟导入器，如果导入的是此类型，那么会执行其内部类 <code>DeferredImportSelector.Group#process</code></p>
</blockquote>
<p>我们查看 <code>AutoConfigurationImportSelector.AutoConfigurationGroup#process()</code> 方法的源码，看它是怎么获取到自动配置类的</p>
<blockquote>
<p>这里有一个点要注意，对于 <code>SpringBoot</code> 的 <code>AutoConfigurationImportSelector</code> 是一个延迟导入器，获取导入的配置类列表不是直接调用 <code>AutoConfigurationImportSelector.selectImports()</code> 而是调用内部类 <code>AutoConfigurationGroup.process()</code> 和 <code>AutoConfigurationGroup.selectImports()</code></p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> {
    <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) {
       <span class="hljs-keyword">return</span> EMPTY_ENTRY;
    }
    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getAttributes(annotationMetadata);
    <span class="hljs-comment">//扫描 imports 文件获取自动配置类列表</span>
    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
    configurations = removeDuplicates(configurations);
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    configurations = getConfigurationClassFilter().filter(configurations);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> {
    <span class="hljs-type">ImportCandidates</span> <span class="hljs-variable">importCandidates</span> <span class="hljs-operator">=</span> ImportCandidates.load(<span class="hljs-built_in">this</span>.autoConfigurationAnnotation,getBeanClassLoader());
    List&lt;String&gt; configurations = importCandidates.getCandidates();
    <span class="hljs-keyword">return</span> configurations;
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImportCandidates <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;?&gt; annotation, ClassLoader classLoader)</span> {
    Assert.notNull(annotation, <span class="hljs-string">"'annotation' must not be null"</span>);
    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> decideClassloader(classLoader);
    <span class="hljs-type">String</span> <span class="hljs-variable">location</span> <span class="hljs-operator">=</span> String.format(LOCATION, annotation.getName());
    Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);
    List&lt;String&gt; importCandidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">while</span> (urls.hasMoreElements()) {
       <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.nextElement();
       importCandidates.addAll(readCandidateConfigurations(url));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImportCandidates</span>(importCandidates);
}
</code></pre>
<p>好了，这里有一个 <code>LOCATION</code> 常量，我们看他的值是写死的</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> LOCATION = <span class="hljs-string">"META-INF/spring/%s.imports"</span>;
</code></pre>
<p>这里传入的注解就是 <code>@AutoConfiguration</code> 的全类名，<code>org.springframework.boot.autoconfigure.AutoConfiguration</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AutoConfigurationImportSelector</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>);
}

AutoConfigurationImportSelector(Class&lt;?&gt; autoConfigurationAnnotation) {
    <span class="hljs-built_in">this</span>.autoConfigurationAnnotation = (autoConfigurationAnnotation != <span class="hljs-literal">null</span>) ? autoConfigurationAnnotation : AutoConfiguration.class;
}
</code></pre>
<p>替换掉 <code>LOCATION</code> 的占位符之后，我们得到完整的路径地址</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">LOCATION</span> = META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
</code></pre>
<p>然后我们再去看 <code>MyBatisPlus、Redis、RabbitMQ</code> 的 <code>starter</code>，我们都会看到这个路径下有这样的文件</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/743446472e194f77a2b07685fdd92278~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=i%2FFo8ac4Z2jWPqbxtx6n97AHm0k%3D" alt="企业微信截图_f001c7fb-e86a-46f5-8db5-500d33a15b4d.png" loading="lazy"/></p>
<p>这下恍然大悟了吧，那现在让你自己定义一个 <code>springboot-starter</code>，还觉得困难吗？</p>
<blockquote>
<p>注意 SpringBoot 3.0 以前读取的是 <code>spring.factories</code> ，之后改成了 <code>imports</code> 文件</p>
</blockquote>
<h3 data-id="heading-13">配置类加载过程流程图</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af334198f2224545bbb4bd88a440f229~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=hAKvfLugez6cJuIsQkPgh7s9spw%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-14">配置类递归解析流程图</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dcb0df7b91fd43148db39daca9f50afa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=tsaF%2Bl2%2FufFSkkmXY8fqX4lVprE%3D" alt="企业微信截图_41c7f5f9-d4c4-4bc1-83c1-76eaac5eb168.png" loading="lazy"/></p>
<p>下面的树形结构可能有助于进一步理解这个流程</p>
<pre><code class="hljs language-ruby" lang="ruby">/**
 * <span class="hljs-title class_">Spring</span> 配置类扫描解析的递归流程
 * 
 * 示例配置结构：
 * └── <span class="hljs-title class_">SpringBootApplication</span> (<span class="hljs-variable">@Configuration</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">0</span>]
  *    ├── <span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">"com.example"</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">1</span>]
 *     │   └── com.example.<span class="hljs-title class_">UserController</span> (<span class="hljs-variable">@Controller</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">2</span>]
 *     │       └── <span class="hljs-variable">@Configuration</span> [<span class="hljs-title class_">Level</span> <span class="hljs-number">3</span>]
 *     └── <span class="hljs-variable">@Bean</span>(appBean)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">1</span>]
 *     ├── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">AutoConfigurationImportSelector</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">1</span>]
 *     │   ├── <span class="hljs-variable">@Configuration</span>
 *     │   ├── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">DataSourceConfig</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">2</span>]
 *     │   │   ├── <span class="hljs-variable">@Configuration</span>
 *     │   │   ├── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">RedisConfig</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">3</span>]
 *     │   │   │   ├── <span class="hljs-variable">@Configuration</span>
 *     │   │   │   └── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">CacheConfig</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">4</span>]
 *     │   │   │       ├── <span class="hljs-variable">@Configuration</span>
 *     │   │   │       └── <span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">"com.cache"</span>)
 *     │   │   └── <span class="hljs-variable">@Bean</span>(dataSource)
 *     │   └── <span class="hljs-variable">@Bean</span>(service)
 *<span class="hljs-regexp">/
</span></code></pre>
<p>只要当前正在扫描处理的配置类里面还有其他配置注解，就一直递归扫描解析，直到解析完毕为止。</p>
<h3 data-id="heading-15">特殊的 @ComponentScan</h3>
<p>仔细观察源码会发现 <code>@ComponentScan</code> 注解的扫描过程中，使用 <code>ComponentScanAnnotationParser</code> 解析之后直接向 <code>Spring</code> 容器注册了 <code>BeanDefinition</code> 。而其他注解的扫描，例如 <code>@Configuration、@Bean、@Import</code> 都是将需要处理的配置类信息存储到 <code>ConfigurationClassParser</code> 的成员变量中。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//@ComponentScan 解析器</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ComponentScanAnnotationParser componentScanParser;
<span class="hljs-comment">//配置类集合</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();

<span class="hljs-comment">//延迟导入器处理器</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DeferredImportSelectorHandler</span> <span class="hljs-variable">deferredImportSelectorHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeferredImportSelectorHandler</span>();
</code></pre>
<p>此时还没有注册它们的 <code>BeanDefinition</code></p>
<h3 data-id="heading-16">分类构建 BeanDefinition</h3>
<p>上一段我们说了，前面的步骤解析完之后，只是把每一个配置类信息存储起来，抽象成一个 <code>Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses</code>，此时还没有向 <code>Spring</code> 容器中注册成 <code>BeanDefiniton</code>。我们可以查看源码，这个类里面有一些成员变量</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurationClass</span> {
    <span class="hljs-comment">//bean 名称</span>
    <span class="hljs-keyword">private</span> String beanName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;ConfigurationClass&gt; importedBy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">1</span>);

    <span class="hljs-comment">//@Bean 方法集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;BeanMethod&gt; beanMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();
    <span class="hljs-comment">//@ImportResource 集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanDefinitionReader</span>&gt;&gt; importedResources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-comment">//ImportBeanDefinitionRegistrar 集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; importBeanDefinitionRegistrars =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
}
</code></pre>
<p>当所有配置类解析完成之后，得到一个全量集合 <code>Map&lt;ConfigurationClass, ConfigurationClass&gt;</code> ，然后在
<code>ConfigurationClassPostProcessor#processConfigBeanDefinitions()</code> 中调用 <code>ConfigurationClassBeanDefinitionReader.loadBeanDefinitions()</code> 这一步执行完毕后，整个应用所有的配置都构建 <code>BeanDefinition</code> 加载完毕</p>
<h2 data-id="heading-17">EventListenerMethodProcessor</h2>
<p>它是一个解析事件监听的后置处理器</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> {
    <span class="hljs-built_in">this</span>.beanFactory = beanFactory;
    <span class="hljs-built_in">this</span>.originalEvaluationContext.setBeanResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryResolver</span>(<span class="hljs-built_in">this</span>.beanFactory));

    Map&lt;String, EventListenerFactory&gt; beans = beanFactory.getBeansOfType(EventListenerFactory.class, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
    List&lt;EventListenerFactory&gt; factories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(beans.values());
    AnnotationAwareOrderComparator.sort(factories);
    <span class="hljs-built_in">this</span>.eventListenerFactories = factories;
}
</code></pre>
<p>我们可以看到这个后置处理方法中，主要是对 <code>eventListenerFactories</code> 赋值，然后后续等所有单例 <code>Bean</code> 实例化完成后，会调用它的生命周期方法 <code>EventListenerMethodProcessor#afterSingletonsInstantiated()</code>，会用这个工厂创建事件监听器，添加到 <code>ApplicationContext</code> 中，<code>Spring 事件机制</code> 就是把所有事件监听器添加到 <code>ApplicationContext</code> 的 <code>applicationListeners</code> 字段中，调用 <code>ApplicationEventPublisher#publishEvent(ApplicationEvent)</code> 的时候从这里找到符合的监听器批量执行，相当于广播一个消息。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multicastEvent</span><span class="hljs-params">(ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> {
    <span class="hljs-type">ResolvableType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> (eventType != <span class="hljs-literal">null</span> ? eventType : ResolvableType.forInstance(event));
    <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getTaskExecutor();
    <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
       <span class="hljs-keyword">if</span> (executor != <span class="hljs-literal">null</span> &amp;&amp; listener.supportsAsyncExecution()) {
          <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">//异步事件</span>
             executor.execute(() -&gt; invokeListener(listener, event));
          }
          <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) {
             <span class="hljs-comment">// Probably on shutdown -&gt; invoke listener locally instead</span>
             invokeListener(listener, event);
          }
       }
       <span class="hljs-keyword">else</span> {
          invokeListener(listener, event);
       }
    }
}
</code></pre>
<h2 data-id="heading-18">MapperScannerConfigurer</h2>
<p>如果我们使用 <code>Mybatis</code> 框架的话，就会有这个工厂后置处理器</p>
<h3 data-id="heading-19">注册来源</h3>
<p>上面我们知道 <code>SpringBoot</code> 启动后会先执行 <code>ConfigurationClassPostProcessor</code> 加载自动配置类，于是加载到了 <code>MybatisPlusAutoConfiguration</code>，它有一个静态内部类</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration(proxyBeanMethods = <span class="hljs-literal">false</span>)
<span class="hljs-meta">@Import(AutoConfiguredMapperScannerRegistrar.class)</span>
<span class="hljs-meta">@ConditionalOnMissingBean({MapperFactoryBean.class, MapperScannerConfigurer.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> {
        logger.debug(<span class="hljs-string">"Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."</span>);
    }
}
</code></pre>
<p>这里 <code>@Import</code> 导入了 <code>AutoConfiguredMapperScannerRegistrar</code> 类，再查看<code>AutoConfiguredMapperScannerRegistrar#registerBeanDefinitions</code> 注册方法中注册了 <code>MapperScannerConfigurer</code> 的 <code>BeanDefiniton</code> 。</p>
<h3 data-id="heading-20">作用</h3>
<p>我们查看 <code>MapperScannerConfigurer#postProcessBeanDefinitionRegistry</code>，源码很简单</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.processPropertyPlaceHolders) {
   <span class="hljs-comment">//解析属性值中的占位符</span>
    processPropertyPlaceHolders();
  }
  
  <span class="hljs-comment">//实例化 `ClassPathBeanDefinitionScanner` 的实现类扫描类路径下的 @Mapper 注解</span>
  <span class="hljs-type">ClassPathMapperScanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathMapperScanner</span>(registry);
  scanner.setAddToConfig(<span class="hljs-built_in">this</span>.addToConfig);
  scanner.setAnnotationClass(<span class="hljs-built_in">this</span>.annotationClass);
  scanner.setMarkerInterface(<span class="hljs-built_in">this</span>.markerInterface);
  scanner.setSqlSessionFactory(<span class="hljs-built_in">this</span>.sqlSessionFactory);
  scanner.setSqlSessionTemplate(<span class="hljs-built_in">this</span>.sqlSessionTemplate);
  scanner.setSqlSessionFactoryBeanName(<span class="hljs-built_in">this</span>.sqlSessionFactoryBeanName);
  scanner.setSqlSessionTemplateBeanName(<span class="hljs-built_in">this</span>.sqlSessionTemplateBeanName);
  scanner.setResourceLoader(<span class="hljs-built_in">this</span>.applicationContext);
  scanner.setBeanNameGenerator(<span class="hljs-built_in">this</span>.nameGenerator);
  scanner.setMapperFactoryBeanClass(<span class="hljs-built_in">this</span>.mapperFactoryBeanClass);
  <span class="hljs-keyword">if</span> (StringUtils.hasText(lazyInitialization)) {
    scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
  }
  <span class="hljs-keyword">if</span> (StringUtils.hasText(defaultScope)) {
    scanner.setDefaultScope(defaultScope);
  }
  scanner.registerFilters();
  scanner.scan(
      StringUtils.tokenizeToStringArray(<span class="hljs-built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
}
</code></pre>
<p>就是把类路径下的 <code>@Mapper</code> 注解的类扫描出来注册为 <code>BeanDefiniton</code> 。</p>
<h3 data-id="heading-21">自我扩展</h3>
<p>参考 <code>MapperScannerConfigurer</code> 假设我们后续需要自己制作一个组件，读取 <code>@Xxx</code> 标注的类注册为 <code>BeanDefiniton</code> 交给 <code>Spring</code> ，是不是就很简单了~</p>
<h2 data-id="heading-22">CachingMetadataReaderFactoryPostProcessor</h2>
<p>这个类是 <code>SpringBoot</code> 提供的一个重要的缓存元信息的工厂后置处理器，它是通过 <code>ApplicationContextInitializer</code> 添加到 <code>ApplicationContext</code> 中的</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedMetadataReaderFactoryContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt;, Ordered, BeanRegistrationExcludeFilter {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BEAN_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">"org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory"</span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> {
       <span class="hljs-keyword">if</span> (AotDetector.useGeneratedArtifacts()) {
          <span class="hljs-keyword">return</span>;
       }
       <span class="hljs-type">BeanFactoryPostProcessor</span> <span class="hljs-variable">postProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingMetadataReaderFactoryPostProcessor</span>(applicationContext);
       applicationContext.addBeanFactoryPostProcessor(postProcessor);
    }
}
</code></pre>
<p>我们可以查看 <code>CachingMetadataReaderFactoryPostProcessor#postProcessBeanDefinitionRegistry</code> 后置处理方法源码，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException {
    register(registry);
    configureConfigurationClassPostProcessor(registry);
}
</code></pre>
<p>先注册了一个 <code>SharedMetadataReaderFactoryBean</code> 的 <code>BeanDefiniton</code> ，实际上最后就是向容器中注入 <code>ConcurrentReferenceCachingMetadataReaderFactory</code>，然后第二行代码很关键，给 <code>ConfigurationClassPostProcessor</code> 这个工厂后置处理器的属性 <code>metadataReaderFactory</code> 赋值为刚刚创建的 <code>ConcurrentReferenceCachingMetadataReaderFactory</code></p>
<p>我们再去看原生的 <code>ConfigurationClassPostProcessor.metadataReaderFactory</code> 默认值</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-type">MetadataReaderFactory</span> <span class="hljs-variable">metadataReaderFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingMetadataReaderFactory</span>();
</code></pre>
<p>在判断一个类是不是配置类的时候会用到它，默认的实现是每次都会用资源加载器读取一遍这个类，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> MetadataReader <span class="hljs-title function_">getMetadataReader</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-keyword">try</span> {
       <span class="hljs-type">String</span> <span class="hljs-variable">resourcePath</span> <span class="hljs-operator">=</span> ResourceLoader.CLASSPATH_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;
       <span class="hljs-comment">//重新读取文件</span>
       <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resourceLoader.getResource(resourcePath);
       <span class="hljs-keyword">return</span> getMetadataReader(resource);
    }
}
</code></pre>
<p>而 <code>ConcurrentReferenceCachingMetadataReaderFactory</code> 的实现是，第一次读取之后放入缓存，后续每次获取会先从缓存中查询</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> MetadataReader <span class="hljs-title function_">getMetadataReader</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">//读取缓存</span>
    <span class="hljs-type">MetadataReader</span> <span class="hljs-variable">metadataReader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.classNameCache.get(className);
    <span class="hljs-keyword">if</span> (metadataReader == <span class="hljs-literal">null</span>) {
       metadataReader = <span class="hljs-built_in">super</span>.getMetadataReader(className);
       <span class="hljs-built_in">this</span>.classNameCache.put(className, metadataReader);
    }
    <span class="hljs-keyword">return</span> metadataReader;
}
</code></pre>
<p>它的作用就是提高程序性能，避免重复读取类的元数据信息</p>
<h2 data-id="heading-23">BeanFactoryPostProcessor 与 BeanPostProcessor 对比</h2>
<p>这两个名字很像，这里列出它们的区别，下一篇文章会详细介绍 <code>BeanPostProcessor</code></p>


















































<table><thead><tr><th align="left">对比维度</th><th align="left">BeanFactoryPostProcessor</th><th align="left">BeanPostProcessor</th></tr></thead><tbody><tr><td align="left"><strong>处理时机</strong></td><td align="left">Bean 定义加载之后，Bean 实例化之前</td><td align="left">Bean 实例化之后，初始化回调前后</td></tr><tr><td align="left"><strong>作用对象</strong></td><td align="left">Bean 的定义元数据（BeanDefinition）</td><td align="left">Bean 实例对象</td></tr><tr><td align="left"><strong>主要功能</strong></td><td align="left">修改、注册或移除 BeanDefinition</td><td align="left">修改或包装 Bean 实例</td></tr><tr><td align="left"><strong>执行阶段</strong></td><td align="left"><code>postProcessBeanFactory()</code></td><td align="left"><code>postProcessBeforeInitialization()</code><br/><code>postProcessAfterInitialization()</code></td></tr><tr><td align="left"><strong>触发次数</strong></td><td align="left">每个容器<strong>仅执行一次</strong></td><td align="left">对<strong>每个 Bean 实例</strong>都会执行</td></tr><tr><td align="left"><strong>Spring 核心阶段</strong></td><td align="left">BeanFactory 准备阶段</td><td align="left">Bean 生命周期阶段</td></tr><tr><td align="left"><strong>典型应用场景</strong></td><td align="left">1. 修改 Bean 的属性值（占位符解析）<br/>2. 动态注册 BeanDefinition<br/>3. 根据条件移除 Bean</td><td align="left">1. 代理增强（AOP）<br/>2. 属性注入后的处理<br/>3. 自定义初始化逻辑</td></tr><tr><td align="left"><strong>实现示例</strong></td><td align="left"><code>PropertySourcesPlaceholderConfigurer</code><br/><code>ConfigurationClassPostProcessor</code></td><td align="left"><code>AutowiredAnnotationBeanPostProcessor</code><br/><code>CommonAnnotationBeanPostProcessor</code></td></tr></tbody></table>
<h2 data-id="heading-24">结语</h2>
<p>篇幅原因，这里无法列出所有的工厂后置处理器的具体作用和实现，不过 <code>SpringBoot</code> 启动过程中，<code>Spring</code> 容器刷新过程中调用的 <code>BeanFactoryPostProcessor</code> 相对于 <code>BeanPostProcessor</code> 要少的多，但是两者都很重要，有兴趣可以逐一查看源码。</p>
<h3 data-id="heading-25">如果这篇文章对你有帮助，记得点赞加关注！你的支持就是我继续创作的动力！</h3></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Web 安全与反编译源码下的权限设计：构筑前后端一致的防护体系]]></title>    <link>https://juejin.cn/post/7603651855236857865</link>    <guid>https://juejin.cn/post/7603651855236857865</guid>    <pubDate>2026-02-08T06:32:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651855236857865" data-draft-id="7603674653153771529" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Web 安全与反编译源码下的权限设计：构筑前后端一致的防护体系"/> <meta itemprop="keywords" content="前端,安全"/> <meta itemprop="datePublished" content="2026-02-08T06:32:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LeonGao"/> <meta itemprop="url" content="https://juejin.cn/user/3976252950591149"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Web 安全与反编译源码下的权限设计：构筑前后端一致的防护体系
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3976252950591149/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LeonGao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:32:33.000Z" title="Sun Feb 08 2026 06:32:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">引言</h2>
<p>在 Web 应用的安全体系中，<strong>权限控制</strong> 是最核心的防线之一。无论是企业后台、数据门户还是 SaaS 平台，一旦权限设计出现漏洞，就可能导致数据泄漏、越权操作甚至后门利用。</p>
<p>然而，许多开发者只在前端配置权限逻辑，忽略了 <strong>反编译与前端源码暴露的安全风险</strong>。通过 F12 调试、打包反编译或网络抓包等手段，攻击者可以轻易绕过前端判断直接访问后端接口。</p>
<blockquote>
<p><strong>问题：</strong> 如何在「源码可见」「反编译可行」的环境下，设计一套真正安全且可扩展的权限体系？</p>
</blockquote>
<p>本文将从 <strong>Web 安全视角</strong> 分析权限设计的底层风险，讲解 <strong>从前端到后端的统一权限防护策略</strong>，并通过示例代码展示如何有效抵御反编译带来的安全威胁。</p>
<hr/>
<h2 data-id="heading-1">一、问题定义与背景</h2>
<h3 data-id="heading-2">1. 前端可逆向的现实</h3>
<p>现代 Web 前端（如 React、Vue、Angular）使用 <strong>打包编译</strong> 与 <strong>代码混淆</strong> 技术，但本质上仍是 <strong>运行在用户端的可执行脚本</strong>。攻击者可通过：</p>
<ul>
<li>浏览器开发者工具查看源码（即使混淆）；</li>
<li>抓包工具（如 Burp、Postman）直接模拟请求；</li>
<li>反编译 WebAssembly / 前端加密逻辑；</li>
<li>修改本地存储信息（token、role、flag）。</li>
</ul>
<p>这意味着 <strong>任何前端层的权限校验都是不可信的</strong>。</p>
<h3 data-id="heading-3">2. 常见错误示例</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ❌ 前端中错误的“权限控制”</span>
if (userRole === 'admin') {
  <span class="hljs-built_in">showAdminPanel</span>();
} else {
  <span class="hljs-built_in">hideAdminPanel</span>();
}
</code></pre>
<p>攻击者只需在浏览器控制台输入：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">userRole</span> = <span class="hljs-string">'admin'</span><span class="hljs-comment">; showAdminPanel();</span>
</code></pre>
<p>即可伪装为管理员。</p>
<hr/>
<h2 data-id="heading-4">二、解决方案与技术设计</h2>
<h3 data-id="heading-5">🔒 权限控制的本质：可信判定必须在服务端</h3>
<p>安全设计原则：</p>
<blockquote>
<p><strong>任何安全相关的判断都应在服务端完成，前端仅作展示或引导。</strong></p>
</blockquote>
<h3 data-id="heading-6">1. 后端统一鉴权与授权</h3>
<p>后端需要构建一套集中式的 <strong>鉴权（Authentication）</strong> 与 <strong>授权（Authorization）</strong> 模型：</p>
<ul>
<li><strong>鉴权：</strong> 当前请求是谁？（JWT / Session / OAuth2）</li>
<li><strong>授权：</strong> 当前用户能做什么？（RBAC / ABAC / PBAC）</li>
</ul>
<p><strong>示例：基于 RBAC 的 Spring Boot 后端实现</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// RoleBasedAccess.java（自定义注解）</span>
<span class="hljs-variable">@Target</span>(ElementType.METHOD)
<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)
public <span class="hljs-variable">@interface</span> RoleBasedAccess {
    <span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">value</span>();
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// SecurityInterceptor.java</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">"Authorization"</span>);
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> TokenUtils.verify(token);
        <span class="hljs-type">RoleBasedAccess</span> <span class="hljs-variable">access</span> <span class="hljs-operator">=</span> ((HandlerMethod) handler).getMethodAnnotation(RoleBasedAccess.class);
        <span class="hljs-keyword">if</span> (access != <span class="hljs-literal">null</span> &amp;&amp; !user.hasAnyRole(access.value())) {
            res.setStatus(HttpServletResponse.SC_FORBIDDEN);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 控制器示例</span>
<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/admin/list"</span>)
<span class="hljs-variable">@RoleBasedAccess</span>({<span class="hljs-string">"ADMIN"</span>})
public ResponseEntity&lt;?&gt; <span class="hljs-built_in">listAdmins</span>() {
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResponseEntity</span><span class="hljs-selector-class">.ok</span>(adminService.<span class="hljs-built_in">findAll</span>());
}
</code></pre>
<blockquote>
<p>✅ 即使攻击者篡改前端变量或修改 UI，仍无法访问未经授权的接口。</p>
</blockquote>
<hr/>
<h3 data-id="heading-7">2. 前端仅作“权限可视化”，非“权限控制”</h3>
<p>前端可以按服务器返回的权限标识动态渲染按钮、菜单，但<strong>不能</strong>依赖这些字段做业务安全判断。</p>
<p><strong>前端示例（Vue + Axios）</strong></p>
<pre><code class="hljs language-ini" lang="ini">// app.js
axios.interceptors.request.use(<span class="hljs-attr">config</span> =&gt; {
  const <span class="hljs-attr">token</span> = localStorage.getItem(<span class="hljs-string">'token'</span>)<span class="hljs-comment">;</span>
  <span class="hljs-attr">config.headers.Authorization</span> = token<span class="hljs-comment">;</span>
  return config<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

// 动态菜单渲染
const <span class="hljs-attr">user</span> = getUserInfo()<span class="hljs-comment">; // 后端返回的角色信息</span>
const <span class="hljs-attr">routes</span> = allRoutes.filter(route =&gt; user.roles.includes(route.meta.role))<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>菜单与按钮的展示只影响“视觉体验”；</li>
<li>实际的访问结果由后端决定（即使前端按钮被伪造也无效）。</li>
</ul>
<hr/>
<h3 data-id="heading-8">3. 防反编译与数据暴露的加固措施</h3>



































<table><thead><tr><th>威胁类型</th><th>防护策略</th><th>技术点</th></tr></thead><tbody><tr><td>源码反编译</td><td>构建时混淆与 Tree Shaking</td><td>Webpack <code>terser</code> / <code>esbuild</code></td></tr><tr><td>关键逻辑逆向</td><td>将核心算法迁移至后端或 WebAssembly</td><td>例如签名、密钥生成</td></tr><tr><td>API 被直接调用</td><td>使用 Token + HMAC 签名 + 限流</td><td>JWT + Redis + Nginx</td></tr><tr><td>调试注入</td><td>CSP（Content Security Policy）限制 JS 执行环境</td><td>HTTP 安全头</td></tr><tr><td>数据泄漏</td><td>后端白名单过滤、敏感字段脱敏</td><td>DTO 防止 DB 字段透传</td></tr></tbody></table>
<p>例如，通过 <strong>请求签名机制（HMAC）</strong> 阻止伪造请求：</p>
<pre><code class="hljs language-ini" lang="ini">// 前端发起请求前生成签名（所有参数 + 时间戳）
import crypto from "crypto"<span class="hljs-comment">;</span>

const <span class="hljs-attr">secret</span> = <span class="hljs-string">"server-shared-key"</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">timestamp</span> = Date.now().toString()<span class="hljs-comment">;</span>
const <span class="hljs-attr">sign</span> = crypto.createHmac(<span class="hljs-string">'sha256'</span>, secret)
                   .update(userId + timestamp)
                   .digest('hex')<span class="hljs-comment">;</span>

axios.post('/api/secure', { data, timestamp, sign })<span class="hljs-comment">;</span>
</code></pre>
<p>后端验证签名合法性：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Flask 示例</span>
<span class="hljs-keyword">import</span> hmac, hashlib

<span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_sign</span>(<span class="hljs-params">userId, ts, sign</span>):
    secret = <span class="hljs-string">"server-shared-key"</span>
    expected = hmac.new(secret.encode(), <span class="hljs-string">f"<span class="hljs-subst">{userId}</span><span class="hljs-subst">{ts}</span>"</span>.encode(), hashlib.sha256).hexdigest()
    <span class="hljs-keyword">return</span> hmac.compare_digest(expected, sign)
</code></pre>
<hr/>
<h2 data-id="heading-9">三、优缺点分析与实践建议</h2>





























<table><thead><tr><th>模型</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>前端权限（展示级）</td><td>响应快、易实现</td><td>简单易被绕过</td><td>UI控制、低安全页面</td></tr><tr><td>后端权限（验证级）</td><td>安全可靠、可审计</td><td>开发略复杂</td><td>所有敏感接口必须</td></tr><tr><td>混合策略</td><td>安全+体验平衡</td><td>需前后端版本统一</td><td>企业后台中大型系统</td></tr></tbody></table>
<p><strong>实践建议：</strong></p>
<ol>
<li><strong>前端负责体验</strong>，但不要承担安全职责；</li>
<li><strong>后端负责权限核心</strong>，所有请求均二次校验；</li>
<li>对<strong>静态资源与接口</strong>同时限流、校验、审计；</li>
<li>每个权限点应<strong>有日志可追溯、有策略可管理</strong>。</li>
</ol>
<hr/>
<h2 data-id="heading-10">四、结论</h2>
<p>在反编译与源码暴露成为常态的 Web 环境中，<strong>前端安全只是幻觉，后端的权限才是真相</strong>。</p>
<p>高质量的权限设计，不是让前端更“聪明”，而是让后端更“可信”；不是靠混淆隐藏逻辑，而是靠架构建立信任边界。</p>
<p>未来，随着 <strong>零信任架构（Zero Trust）</strong> 与 <strong>前后端一体化加密通信</strong> 的普及，<br/>
权限设计将更智能、更去中心化，基于 <strong>身份、上下文与行为检测</strong> 的动态授权机制将逐渐取代传统 RBAC。</p>
<hr/>
<h2 data-id="heading-11">五、参考资料</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fowasp.org%2FTop10%2FA01_2021-Broken_Access_Control%2F" target="_blank" title="https://owasp.org/Top10/A01_2021-Broken_Access_Control/" ref="nofollow noopener noreferrer">OWASP Top 10 2021 – A01: Broken Access Control</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fspring.io%2Fprojects%2Fspring-security" target="_blank" title="https://spring.io/projects/spring-security" ref="nofollow noopener noreferrer">Spring Security 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" ref="nofollow noopener noreferrer">MDN – Content Security Policy (CSP) 指南</a></li>
<li>[JWT.io – JSON Web Token 官方标准]</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcheatsheetseries.owasp.org%2Fcheatsheets%2FAuthorization_Cheat_Sheet.html" target="_blank" title="https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html" ref="nofollow noopener noreferrer">OWASP – Authorization Cheat Sheet</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Unsafe魔法类深度解析：Java底层操作的终极指南]]></title>    <link>https://juejin.cn/post/7603688142004699145</link>    <guid>https://juejin.cn/post/7603688142004699145</guid>    <pubDate>2026-02-08T06:33:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142004699145" data-draft-id="7603721514203283465" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Unsafe魔法类深度解析：Java底层操作的终极指南"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:33:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="神奇小汤圆"/> <meta itemprop="url" content="https://juejin.cn/user/1151943919285431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Unsafe魔法类深度解析：Java底层操作的终极指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1151943919285431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    神奇小汤圆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:33:22.000Z" title="Sun Feb 08 2026 06:33:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">介绍</h2>
<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p>
<p>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
<p>先来看下这张图，对UnSafe类总体功能：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202404251040445.jpg" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404251040445.jpg" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af56ce01300f4528b2404ef5e07612fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=FbCKApmBIzjz3cacmsUy8EKKseY%3D" alt="" loading="lazy"/></a></p>
<p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。</p>
<h2 data-id="heading-1">内存操作</h2>
<h3 data-id="heading-2">介绍</h3>
<p>如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//分配新的本地空间</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">allocateMemory</span><span class="hljs-params">(<span class="hljs-type">long</span> bytes)</span>;
<span class="hljs-comment">//重新调整内存空间的大小</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">reallocateMemory</span><span class="hljs-params">(<span class="hljs-type">long</span> address, <span class="hljs-type">long</span> bytes)</span>;
<span class="hljs-comment">//将内存设置为指定值</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> bytes, <span class="hljs-type">byte</span> value)</span>;
<span class="hljs-comment">//内存拷贝</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyMemory</span><span class="hljs-params">(Object srcBase, <span class="hljs-type">long</span> srcOffset,Object destBase, <span class="hljs-type">long</span> destOffset,<span class="hljs-type">long</span> bytes)</span>;
<span class="hljs-comment">//清除内存</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">freeMemory</span><span class="hljs-params">(<span class="hljs-type">long</span> address)</span>;
</code></pre>
<p>使用下面的代码进行测试：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memoryTest</span>()</span> {
    <span class="hljs-built_in">int</span> size = <span class="hljs-number">4</span>;
    <span class="hljs-built_in">long</span> addr = <span class="hljs-keyword">unsafe</span>.allocateMemory(size);
    <span class="hljs-built_in">long</span> addr3 = <span class="hljs-keyword">unsafe</span>.reallocateMemory(addr, size * <span class="hljs-number">2</span>);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"addr: "</span>+addr);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"addr3: "</span>+addr3);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">unsafe</span>.setMemory(<span class="hljs-literal">null</span>,addr ,size,(<span class="hljs-built_in">byte</span>)<span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {
            <span class="hljs-keyword">unsafe</span>.copyMemory(<span class="hljs-literal">null</span>,addr,<span class="hljs-literal">null</span>,addr3+size*i,<span class="hljs-number">4</span>);
        }
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">unsafe</span>.getInt(addr));
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">unsafe</span>.getLong(addr3));
    }<span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">unsafe</span>.freeMemory(addr);
        <span class="hljs-keyword">unsafe</span>.freeMemory(addr3);
    }
}
</code></pre>
<p>先看结果输出：</p>
<p>plain</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">addr: 2433733895744</span>
<span class="hljs-section">addr3: 2433733894944</span>
16843009
72340172838076673
</code></pre>
<p>分析一下运行结果，首先使用<code>allocateMemory</code>方法申请 4 字节长度的内存空间，调用<code>setMemory</code>方法向每个字节写入内容为<code>byte</code>类型的 1，当使用 Unsafe 调用<code>getInt</code>方法时，因为一个<code>int</code>型变量占 4 个字节，会一次性读取 4 个字节，组成一个<code>int</code>的值，对应的十进制结果为 16843009。</p>
<p>你可以通过下图理解这个过程：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130396.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130396.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60e61edb820240908dfef29cdca85ae7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=McQsQTlSzXk3eVY8DvAFFeWA0zo%3D" alt="" loading="lazy"/></a></p>
<p>在代码中调用<code>reallocateMemory</code>方法重新分配了一块 8 字节长度的内存空间，通过比较<code>addr</code>和<code>addr3</code>可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用<code>copyMemory</code>方法进行了两次内存的拷贝，每次拷贝内存地址<code>addr</code>开始的 4 个字节，分别拷贝到以<code>addr3</code>和<code>addr3+4</code>开始的内存空间上：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130404.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130404.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf0021cd157244e8bc4857c7ee307703~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=cIfVZVovO11KHNXFn8iyfbYKmbU%3D" alt="" loading="lazy"/></a></p>
<p>拷贝完成后，使用<code>getLong</code>方法一次性读取 8 个字节，得到<code>long</code>类型的值为 72340172838076673。</p>
<p>需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p>
<p><strong>为什么要使用堆外内存？</strong></p>
<ul>
<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>
<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<h3 data-id="heading-3">典型应用</h3>
<p><code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。</p>
<p>下图为 <code>DirectByteBuffer</code> 构造函数，创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放。</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">DirectByteBuffer(int cap) {                   // package-private

    super(-1, 0, cap, cap)<span class="hljs-comment">;</span>
    boolean <span class="hljs-attr">pa</span> = VM.isDirectMemoryPageAligned()<span class="hljs-comment">;</span>
    int <span class="hljs-attr">ps</span> = Bits.pageSize()<span class="hljs-comment">;</span>
    long <span class="hljs-attr">size</span> = Math.max(<span class="hljs-number">1</span>L, (long)cap + (pa ? ps : <span class="hljs-number">0</span>))<span class="hljs-comment">;</span>
    Bits.reserveMemory(size, cap)<span class="hljs-comment">;</span>

    long <span class="hljs-attr">base</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    try {
        // 分配内存并返回基地址
        <span class="hljs-attr">base</span> = unsafe.allocateMemory(size)<span class="hljs-comment">;</span>
    } catch (OutOfMemoryError x) {
        Bits.unreserveMemory(size, cap)<span class="hljs-comment">;</span>
        throw x<span class="hljs-comment">;</span>
    }
    // 内存初始化
    unsafe.setMemory(base, size, (byte) 0)<span class="hljs-comment">;</span>
    if (pa &amp;&amp; (base % ps != 0)) {
        // Round up to page boundary
        <span class="hljs-attr">address</span> = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
    } else {
        <span class="hljs-attr">address</span> = base<span class="hljs-comment">;</span>
    }
    // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放
    <span class="hljs-attr">cleaner</span> = Cleaner.create(this, new Deallocator(base, size, cap))<span class="hljs-comment">;</span>
    <span class="hljs-attr">att</span> = null<span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-4">内存屏障</h2>
<h3 data-id="heading-5">介绍</h3>
<p>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p>
<p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>
<p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">void</span> <span class="hljs-title">loadFence</span>()</span>;
<span class="hljs-comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">void</span> <span class="hljs-title">storeFence</span>()</span>;
<span class="hljs-comment">//内存屏障，禁止load、store操作重排序</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">void</span> <span class="hljs-title">fullFence</span>()</span>;
</code></pre>
<p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p>
<p>看到这估计很多小伙伴们会想到<code>volatile</code>关键字了，如果在字段上添加了<code>volatile</code>关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改<code>flag</code>标志位，注意这里的<code>flag</code>是没有被<code>volatile</code>修饰的：</p>
<p>java</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Getter</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>{
    <span class="hljs-comment">/**volatile**/</span> <span class="hljs-built_in">boolean</span> flag=<span class="hljs-literal">false</span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) {
            e.<span class="hljs-title function_">printStackTrace</span>();
        }
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"subThread change flag to:"</span> + flag);
        flag = <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>在主线程的<code>while</code>循环中，加入内存屏障，测试是否能够感知到<code>flag</code>的修改变化：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>{
    ChangeThread changeThread = <span class="hljs-keyword">new</span> ChangeThread();
    <span class="hljs-keyword">new</span> Thread(changeThread).start();
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        boolean flag = changeThread.isFlag();
        <span class="hljs-keyword">unsafe</span>.loadFence(); <span class="hljs-comment">//加入读内存屏障</span>
        <span class="hljs-keyword">if</span> (flag){
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"detected flag changed"</span>);
            <span class="hljs-keyword">break</span>;
        }
    }
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"main thread end"</span>);
}
</code></pre>
<p>运行结果：</p>
<p>plain</p>
<pre><code class="hljs language-arduino" lang="arduino">subThread change flag to:<span class="hljs-literal">false</span>
detected flag changed
main thread end
</code></pre>
<p>而如果删掉上面代码中的<code>loadFence</code>方法，那么主线程将无法感知到<code>flag</code>发生的变化，会一直在<code>while</code>中循环。可以用图来表示上面的过程：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fp0-xtjj-private.juejin.cn%2Ftos-cn-i-73owjymdk6%2Ff320a294eacd4789a072b1f71e541406~tplv-73owjymdk6-jj-mark-v1%3A0%3A0%3A0%3A0%3A5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG%3Aq75.awebp%3Fpolicy%3DeyJ2bSI6MywidWlkIjoiMTE1MTk0MzkxOTI4NTQzMSJ9%26rk3s%3De9ecf3d6%26x-orig-authkey%3Df32326d3454f2ac7e96d3d06cdbb035152127018%26x-orig-expires%3D1770618790%26x-orig-sign%3DdYNDmbPY7ht9OLvDS82flYbnOis%253D" target="_blank" title="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/f320a294eacd4789a072b1f71e541406~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMTE1MTk0MzkxOTI4NTQzMSJ9&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1770618790&amp;x-orig-sign=dYNDmbPY7ht9OLvDS82flYbnOis%3D" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fba0241f9bb84ff29959034d18ae368e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=nxiCNFJoxs6yyGp8MgE%2FB66dFiA%3D" alt="" loading="lazy"/></a></p>
<p>了解 Java 内存模型（<code>JMM</code>）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>
<h3 data-id="heading-6">典型应用</h3>
<p>在 Java 8 中引入了一种锁的新机制——<code>StampedLock</code>，它可以看成是读写锁的一个改进版本。<code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p>
<p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p>
<p>java</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">validate</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span> </span>{
   U.<span class="hljs-built_in">loadFence</span>();
   <span class="hljs-keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);
}
</code></pre>
<h2 data-id="heading-7">对象操作</h2>
<h3 data-id="heading-8">介绍</h3>
<p><strong>例子</strong></p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp">import sun.misc.Unsafe;
import java.lang.reflect.Field;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws Exception</span>{
        Unsafe <span class="hljs-keyword">unsafe</span> = reflectGetUnsafe();
        assert <span class="hljs-keyword">unsafe</span> != <span class="hljs-literal">null</span>;
        <span class="hljs-built_in">long</span> offset = <span class="hljs-keyword">unsafe</span>.objectFieldOffset(Main.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"value"</span>));
        Main main = <span class="hljs-keyword">new</span> Main();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"value before putInt: "</span> + main.<span class="hljs-keyword">value</span>);
        <span class="hljs-keyword">unsafe</span>.putInt(main, offset, <span class="hljs-number">42</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"value after putInt: "</span> + main.<span class="hljs-keyword">value</span>);
  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"value after putInt: "</span> + <span class="hljs-keyword">unsafe</span>.getInt(main, offset));
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span>()</span> {
        <span class="hljs-keyword">try</span> {
            Field field = Unsafe.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"theUnsafe"</span>);
            field.setAccessible(<span class="hljs-literal">true</span>);
            <span class="hljs-keyword">return</span> (Unsafe) field.<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }

}
</code></pre>
<p>输出结果：</p>
<p>plain</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">value before putInt:</span> <span class="hljs-number">0</span>
<span class="hljs-attr">value after putInt:</span> <span class="hljs-number">42</span>
<span class="hljs-attr">value after putInt:</span> <span class="hljs-number">42</span>
</code></pre>
<p><strong>对象属性</strong></p>
<p>对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的<code>putInt</code>、<code>getInt</code>方法外，Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）。下面是<code>Object</code>的读写方法：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//在对象的指定偏移地址获取一个对象引用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset)</span>;
<span class="hljs-comment">//在对象指定偏移地址写入一个对象引用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object x)</span>;
</code></pre>
<p>除了对象属性的普通读写外，<code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。<code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，以<code>int</code>类型为例：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//在对象的指定偏移地址处读取一个int值，支持volatile load语义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIntVolatile</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset)</span>;
<span class="hljs-comment">//在对象指定偏移地址处写入一个int，支持volatile store语义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntVolatile</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> x)</span>;
</code></pre>
<p>相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p>
<p>有序写入的方法有以下三个：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putOrderedObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object x)</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putOrderedInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> x)</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putOrderedLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> x)</span>;
</code></pre>
<p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：</p>
<ul>
<li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li>
<li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li>
</ul>
<p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类型，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型，如下图所示：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130467.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130467.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ffdc3b0cb1944029747a07cca8f7381~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=pAvU2CZVAAqKxOeTX9A%2FCZ5aJB8%3D" alt="" loading="lazy"/></a></p>
<p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p>
<p>综上所述，在上面的三类写入方法中，在写入效率方面，按照<code>put</code>、<code>putOrder</code>、<code>putVolatile</code>的顺序效率逐渐降低。</p>
<p><strong>对象实例化</strong></p>
<p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp">@Data
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> b;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span>()</span>{
        <span class="hljs-keyword">this</span>.b =<span class="hljs-number">1</span>;
    }
}
</code></pre>
<p>分别基于构造函数、反射以及 <code>Unsafe</code> 方法的不同方式创建对象进行比较：</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">public void objTest() throws Exception{
    A <span class="hljs-attr">a1</span>=new A()<span class="hljs-comment">;</span>
    System.out.println(a1.getB())<span class="hljs-comment">;</span>
    A <span class="hljs-attr">a2</span> = A.class.newInstance()<span class="hljs-comment">;</span>
    System.out.println(a2.getB())<span class="hljs-comment">;</span>
    A <span class="hljs-attr">a3</span>= (A) unsafe.allocateInstance(A.class)<span class="hljs-comment">;</span>
    System.out.println(a3.getB())<span class="hljs-comment">;</span>
}
</code></pre>
<p>打印结果分别为 1、1、0，说明通过<code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但<code>allocateInstance</code>方法仍然有效。</p>
<h3 data-id="heading-9">典型应用</h3>
<ul>
<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>
<li><strong>非常规的实例化方式</strong>：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>
</ul>
<h2 data-id="heading-10">数组操作</h2>
<h3 data-id="heading-11">介绍</h3>
<p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//返回数组中第一个元素的偏移地址</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayBaseOffset</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span>;
<span class="hljs-comment">//返回数组中一个元素占用的大小</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayIndexScale</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span>;
</code></pre>
<h3 data-id="heading-12">典型应用</h3>
<p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code>、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130522.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130522.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e11d8699d0e348dab3f81b341301441c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=wEVeqZomJ856PftogdC%2FATMiFJw%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-13">CAS 操作</h2>
<h3 data-id="heading-14">介绍</h3>
<p>这部分主要为 CAS 相关操作的方法。</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
  *  CAS
  * <span class="hljs-doctag">@param</span> o         包含要修改field的对象
  * <span class="hljs-doctag">@param</span> offset    对象中某field的偏移量
  * <span class="hljs-doctag">@param</span> expected  期望值
  * <span class="hljs-doctag">@param</span> update    更新值
  * <span class="hljs-doctag">@return</span>          true | false
  */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,  Object expected, Object update)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> expected,<span class="hljs-type">int</span> update)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> expected, <span class="hljs-type">long</span> update)</span>;
</code></pre>
<p><strong>什么是 CAS?</strong>  CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p>
<h3 data-id="heading-15">典型应用</h3>
<p>在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍<code>synchronized</code>和<code>AQS</code>的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,<span class="hljs-type">int</span> expected,<span class="hljs-type">int</span> x)</span>;
</code></pre>
<p>参数中<code>o</code>为需要更新的对象，<code>offset</code>是对象<code>o</code>中整形字段的偏移量，如果这个字段的值与<code>expected</code>相同，则将字段的值设为<code>x</code>这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用<code>compareAndSwapInt</code>的例子：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> a;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>{
    CasTest casTest=<span class="hljs-keyword">new</span> CasTest();
    <span class="hljs-keyword">new</span> Thread(()-&gt;{
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) {
            casTest.increment(i);
            System.<span class="hljs-keyword">out</span>.print(casTest.a+<span class="hljs-string">" "</span>);
        }
    }).start();
    <span class="hljs-keyword">new</span> Thread(()-&gt;{
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span> ; i &lt;<span class="hljs-number">10</span> ; i++) {
            casTest.increment(i);
            System.<span class="hljs-keyword">out</span>.print(casTest.a+<span class="hljs-string">" "</span>);
        }
    }).start();
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>){
        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">long</span> fieldOffset = <span class="hljs-keyword">unsafe</span>.objectFieldOffset(CasTest.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"a"</span>));
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">unsafe</span>.compareAndSwapInt(<span class="hljs-keyword">this</span>,fieldOffset,x<span class="hljs-number">-1</span>,x))
                <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">catch</span> (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>运行代码会依次输出：</p>
<p>plain</p>
<pre><code class="hljs">1 2 3 4 5 6 7 8 9
</code></pre>
<p>在上面的例子中，使用两个线程去修改<code>int</code>型属性<code>a</code>的值，并且只有在<code>a</code>的值等于传入的参数<code>x</code>减一时，才会将<code>a</code>的值变为<code>x</code>，也就是实现对<code>a</code>的加一的操作。流程如下所示：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130526.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130526.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab7b1c68423246038926ec5227e9cd9b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=TUIiFd06QpGQRv2GUC%2FZGTUgK1M%3D" alt="" loading="lazy"/></a></p>
<p>需要注意的是，在调用<code>compareAndSwapInt</code>方法后，会直接返回<code>true</code>或<code>false</code>的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在<code>AtomicInteger</code>类的设计中，也是采用了将<code>compareAndSwapInt</code>的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。</p>
<h2 data-id="heading-16">线程调度</h2>
<h3 data-id="heading-17">介绍</h3>
<p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//取消阻塞线程</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Object thread)</span>;
<span class="hljs-comment">//阻塞线程</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAbsolute, <span class="hljs-type">long</span> time)</span>;
<span class="hljs-comment">//获得对象锁（可重入锁）</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorEnter</span><span class="hljs-params">(Object o)</span>;
<span class="hljs-comment">//释放对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorExit</span><span class="hljs-params">(Object o)</span>;
<span class="hljs-comment">//尝试获取对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMonitorEnter</span><span class="hljs-params">(Object o)</span>;
</code></pre>
<p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常。</p>
<p>此外，<code>Unsafe</code> 源码中<code>monitor</code>相关的三个方法已经被标记为<code>deprecated</code>，不建议被使用：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//获得对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorEnter</span><span class="hljs-params">(Object var1)</span>;
<span class="hljs-comment">//释放对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorExit</span><span class="hljs-params">(Object var1)</span>;
<span class="hljs-comment">//尝试获得对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMonitorEnter</span><span class="hljs-params">(Object var1)</span>;
</code></pre>
<p><code>monitorEnter</code>方法用于获得对象锁，<code>monitorExit</code>用于释放对象锁，如果对一个没有被<code>monitorEnter</code>加锁的对象执行此方法，会抛出<code>IllegalMonitorStateException</code>异常。<code>tryMonitorEnter</code>方法尝试获取对象锁，如果成功则返回<code>true</code>，反之返回<code>false</code>。</p>
<h3 data-id="heading-18">典型应用</h3>
<p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code>、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code>、<code>unpark</code> 方式实现的。</p>
<p>java</p>
<pre><code class="hljs language-scss" lang="scss">public static void <span class="hljs-built_in">park</span>(Object blocker) {
    Thread t = Thread<span class="hljs-selector-class">.currentThread</span>();
    <span class="hljs-built_in">setBlocker</span>(t, blocker);
    UNSAFE<span class="hljs-selector-class">.park</span>(false, <span class="hljs-number">0</span>L);
    <span class="hljs-built_in">setBlocker</span>(t, null);
}
public static void <span class="hljs-built_in">unpark</span>(Thread thread) {
    if (thread != null)
        UNSAFE<span class="hljs-selector-class">.unpark</span>(thread);
}
</code></pre>
<p><code>LockSupport</code> 的<code>park</code>方法调用了 <code>Unsafe</code> 的<code>park</code>方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用<code>unpark</code>方法唤醒当前线程。下面的例子对 <code>Unsafe</code> 的这两个方法进行测试：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> {
    Thread mainThread = Thread.currentThread();
    <span class="hljs-keyword">new</span> Thread(()-&gt;{
        <span class="hljs-keyword">try</span> {
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"subThread try to unpark mainThread"</span>);
            <span class="hljs-keyword">unsafe</span>.unpark(mainThread);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();

    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"park main mainThread"</span>);
    <span class="hljs-keyword">unsafe</span>.park(<span class="hljs-literal">false</span>,<span class="hljs-number">0L</span>);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"unpark mainThread success"</span>);
}
</code></pre>
<p>程序输出为：</p>
<p>plain</p>
<pre><code class="hljs language-css" lang="css">park <span class="hljs-selector-tag">main</span> mainThread
subThread try <span class="hljs-selector-tag">to</span> unpark mainThread
unpark mainThread success
</code></pre>
<p>程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用<code>park</code>方法阻塞自己，子线程在睡眠 5 秒后，调用<code>unpark</code>方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130484.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130484.png" ref="nofollow noopener noreferrer"><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130484.png" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-19">Class 操作</h2>
<h3 data-id="heading-20">介绍</h3>
<p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p>
<p><strong>静态属性读取相关的方法</strong></p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//获取静态属性的偏移量</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">staticFieldOffset</span><span class="hljs-params">(Field f)</span>;
<span class="hljs-comment">//获取静态属性的对象指针</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">staticFieldBase</span><span class="hljs-params">(Field f)</span>;
<span class="hljs-comment">//判断类是否需要初始化（用于获取类的静态属性前进行检测）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldBeInitialized</span><span class="hljs-params">(Class&lt;?&gt; c)</span>;
</code></pre>
<p>创建一个包含静态属性的类，进行测试：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp">@Data
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String name=<span class="hljs-string">"Hydra"</span>;
    <span class="hljs-built_in">int</span> age;
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticTest</span>() throws Exception</span> {
    User user=<span class="hljs-keyword">new</span> User();
    <span class="hljs-comment">// 也可以用下面的语句触发类初始化</span>
    <span class="hljs-comment">// 1.</span>
    <span class="hljs-comment">// unsafe.ensureClassInitialized(User.class);</span>
    <span class="hljs-comment">// 2.</span>
    <span class="hljs-comment">// System.out.println(User.name);</span>
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">unsafe</span>.shouldBeInitialized(User.<span class="hljs-keyword">class</span>));
    Field sexField = User.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"name"</span>);
    <span class="hljs-built_in">long</span> fieldOffset = <span class="hljs-keyword">unsafe</span>.staticFieldOffset(sexField);
    Object fieldBase = <span class="hljs-keyword">unsafe</span>.staticFieldBase(sexField);
    Object <span class="hljs-built_in">object</span> = <span class="hljs-keyword">unsafe</span>.getObject(fieldBase, fieldOffset);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">object</span>);
}
</code></pre>
<p>运行结果：</p>
<p>plain</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-literal">false</span>
Hydra
</code></pre>
<p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code>。</p>
<p>在上面的代码中首先创建一个<code>User</code>对象，这是因为如果一个类没有被初始化，那么它的静态属性也不会被初始化，最后获取的字段属性将是<code>null</code>。所以在获取静态属性前，需要调用<code>shouldBeInitialized</code>方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为：</p>
<p>plain</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-literal">true</span>
<span class="hljs-literal">null</span>
</code></pre>
<p><strong>使用<code>defineClass</code>方法允许程序在运行时动态地创建一个类</strong></p>
<p>java</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> native Class&lt;?&gt; <span class="hljs-title">defineClass</span><span class="hljs-params">(<span class="hljs-type">String</span> name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len, ClassLoader loader,ProtectionDomain protectionDomain)</span></span>;
</code></pre>
<p>在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（<code>ClassLoader</code>）和保护域（<code>ProtectionDomain</code>）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能：</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">private static void defineTest() {
    String <span class="hljs-attr">fileName</span>=<span class="hljs-string">"F:\workspace\unsafe-test\target\classes\com\cn\model\User.class"</span><span class="hljs-comment">;</span>
    File <span class="hljs-attr">file</span> = new File(fileName)<span class="hljs-comment">;</span>
    try(FileInputStream <span class="hljs-attr">fis</span> = new FileInputStream(file)) {
        byte<span class="hljs-section">[]</span> <span class="hljs-attr">content</span>=new byte[(int)file.length()]<span class="hljs-comment">;</span>
        fis.read(content)<span class="hljs-comment">;</span>
        Class <span class="hljs-attr">clazz</span> = unsafe.defineClass(null, content, <span class="hljs-number">0</span>, content.length, null, null)<span class="hljs-comment">;</span>
        Object <span class="hljs-attr">o</span> = clazz.newInstance()<span class="hljs-comment">;</span>
        Object <span class="hljs-attr">age</span> = clazz.getMethod(<span class="hljs-string">"getAge"</span>).invoke(o, null)<span class="hljs-comment">;</span>
        System.out.println(age)<span class="hljs-comment">;</span>
    } catch (Exception e) {
        e.printStackTrace()<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>在上面的代码中，首先读取了一个<code>class</code>文件并通过文件流将它转化为字节数组，之后使用<code>defineClass</code>方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Foss.javaguide.cn%2Fgithub%2Fjavaguide%2Fjava%2Fbasis%2Funsafe%2Fimage-20220717145000710.png" target="_blank" title="https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717145000710.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/943b180e413f45d38624174ed73a4ebc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=hsOaP0KsEp%2FGFeTEkmNIllfaG34%3D" alt="" loading="lazy"/></a></p>
<p>除了<code>defineClass</code>方法外，Unsafe 还提供了一个<code>defineAnonymousClass</code>方法：</p>
<p>java</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">Class</span>&lt;?&gt; defineAnonymousClass(<span class="hljs-keyword">Class</span>&lt;?&gt; hostClass, <span class="hljs-type">byte</span>[] data, <span class="hljs-type">Object</span>[] cpPatches);
</code></pre>
<p>使用该方法可以用来动态的创建一个匿名类，在<code>Lambda</code>表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（<code>Hidden classes</code>）一条中，指出将在未来的版本中弃用 <code>Unsafe</code> 的<code>defineAnonymousClass</code>方法。</p>
<h3 data-id="heading-21">典型应用</h3>
<p>Lambda 表达式实现需要依赖 <code>Unsafe</code> 的 <code>defineAnonymousClass</code> 方法定义实现相应的函数式接口的匿名类。</p>
<h2 data-id="heading-22">系统信息</h2>
<h3 data-id="heading-23">介绍</h3>
<p>这部分包含两个获取系统相关信息的方法。</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-built_in">int</span> <span class="hljs-title">addressSize</span>()</span>;
<span class="hljs-comment">//内存页的大小，此值为2的幂次方。</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-built_in">int</span> <span class="hljs-title">pageSize</span>()</span>;
</code></pre>
<h3 data-id="heading-24">典型应用</h3>
<p>这两个方法的应用场景比较少，在<code>java.nio.Bits</code>类中，在使用<code>pageCount</code>计算所需的内存页的数量时，调用了<code>pageSize</code>方法获取内存页的大小。另外，在使用<code>copySwapMemory</code>方法拷贝内存时，调用了<code>addressSize</code>方法，检测 32 位系统的情况。</p>
<h2 data-id="heading-25">Unsafe底层</h2>
<p>再看看Unsafe的compareAndSwap 方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper("Unsafe_CompareAndSwapInt")<span class="hljs-comment">;</span>
  oop <span class="hljs-attr">p</span> = JNIHandles::resolve(obj)<span class="hljs-comment">;</span>
  jint* <span class="hljs-attr">addr</span> = (jint *) index_oop_from_field_<span class="hljs-literal">off</span>set_long(p, <span class="hljs-literal">off</span>set)<span class="hljs-comment">;</span>
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e<span class="hljs-comment">;</span>
UNSAFE_END
</code></pre>
<p>可以看到它通过 Atomic::cmpxchg 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。</p>
<p>如果是Linux的x86，Atomic::cmpxchg方法的实现如下：</p>
<p>java</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">inline</span> jint <span class="hljs-title">Atomic::cmpxchg</span> <span class="hljs-params">(jint exchange_value, <span class="hljs-keyword">volatile</span> jint* dest, jint compare_value)</span> </span>{
  <span class="hljs-type">int</span> mp = os::<span class="hljs-built_in">is_MP</span>();
  <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">"cmpxchgl %1,(%3)"</span>
                    : <span class="hljs-string">"=a"</span> (exchange_value)
                    : <span class="hljs-string">"r"</span> (exchange_value), <span class="hljs-string">"a"</span> (compare_value), <span class="hljs-string">"r"</span> (dest), <span class="hljs-string">"r"</span> (mp)
                    : <span class="hljs-string">"cc"</span>, <span class="hljs-string">"memory"</span>)</span></span>;
  <span class="hljs-keyword">return</span> exchange_value;
}
</code></pre>
<p>而windows的x86的实现如下：</p>
<p>java</p>
<pre><code class="hljs language-scss" lang="scss">inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
    int mp = os::<span class="hljs-built_in">isMP</span>(); <span class="hljs-comment">//判断是否是多处理器</span>
    _asm {
        mov edx, dest
        mov ecx, exchange_value
        mov eax, compare_value
        <span class="hljs-built_in">LOCK_IF_MP</span>(mp)
        cmpxchg dword ptr <span class="hljs-selector-attr">[edx]</span>, ecx
    }
}

<span class="hljs-comment">// Adding a lock prefix to an instruction on MP machine</span>
<span class="hljs-comment">// VC++ doesn't like the lock prefix to be on a single line</span>
<span class="hljs-comment">// so we can't insert a label after the lock prefix.</span>
<span class="hljs-comment">// By emitting a lock prefix, we can define a label after it.</span>
<span class="hljs-selector-id">#define</span> <span class="hljs-built_in">LOCK_IF_MP</span>(mp) __asm cmp mp, <span class="hljs-number">0</span>  \
                       __asm je L0      \
                       __asm _emit <span class="hljs-number">0</span>xF0 \
                       __asm L0:
</code></pre>
<p>如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p>
<blockquote>
<p>cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Web 安全与反编译源码下的权限设计：构建前后端一体的信任防线]]></title>    <link>https://juejin.cn/post/7603771025856561203</link>    <guid>https://juejin.cn/post/7603771025856561203</guid>    <pubDate>2026-02-08T06:35:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856561203" data-draft-id="7603674653153787913" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Web 安全与反编译源码下的权限设计：构建前后端一体的信任防线"/> <meta itemprop="keywords" content="前端,安全,编译原理"/> <meta itemprop="datePublished" content="2026-02-08T06:35:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LeonGao"/> <meta itemprop="url" content="https://juejin.cn/user/3976252950591149"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Web 安全与反编译源码下的权限设计：构建前后端一体的信任防线
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3976252950591149/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LeonGao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:35:50.000Z" title="Sun Feb 08 2026 06:35:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">引言</h2>
<p>在现代 Web 应用中，<strong>安全与权限设计</strong> 是架构中最容易被忽视、却最容易出问题的部分。<br/>
随着前端应用的复杂度不断提高（Vue、React、Flutter Web 等），越来越多逻辑被放在客户端执行；<br/>
与此同时，打包后的前端代码可被轻易“反编译”、“逆向分析”或直接在浏览器中篡改。</p>
<p>于是，开发者常面临一个棘手问题：</p>
<blockquote>
<p>「当用户可以直接查看、修改、甚至注入前端逻辑时，我们该如何保障权限体系的安全性？」</p>
</blockquote>
<p>本文将系统分析 <strong>反编译环境下权限设计的风险与防护机制</strong>，通过架构分层思路，<br/>
构建一个前后端统一、安全可控的权限防护体系，并提供实践代码与工程建议。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f136ab89966405c858f127a85d954e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGVvbkdhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137350&amp;x-signature=OrhcZhqf%2F91h7ZTzDxqsJqWUCL4%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1">一、问题定义与背景</h2>
<h3 data-id="heading-2">1. 前端反编译：安全的假象</h3>
<p>前端编译产物（HTML、JS、CSS）最终都需运行在用户端。<br/>
即使使用了 Webpack、Vite、Uglify 进行混淆打包，攻击者仍可通过如下方式分析源码：</p>
<ul>
<li>打开 <strong>浏览器开发者工具</strong> 查看逻辑；</li>
<li>使用 <strong>反混淆工具</strong> 还原函数与模块；</li>
<li>直接 <strong>修改全局变量绕过条件判断</strong>；</li>
<li>使用 <strong>抓包工具（如 Burp、Postman）</strong> 模拟接口调用。</li>
</ul>
<p>这意味着：<br/>
前端的权限判断、令牌验证或角色限制——如果<strong>不由后端复核</strong>，<br/>
都可以被通过篡改脚本的方式绕过。</p>
<h3 data-id="heading-3">2. 案例：被篡改的前端权限</h3>
<p>错误示例（前端判断管理员身份）：</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">user.role</span> === <span class="hljs-string">'admin'</span>) {
  showAdminPanel()<span class="hljs-comment">;</span>
}
</code></pre>
<p>攻击者在浏览器控制台直接执行：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">user.role</span> = <span class="hljs-string">'admin'</span><span class="hljs-comment">;</span>
showAdminPanel()<span class="hljs-comment">;</span>
</code></pre>
<p>即可解锁「管理员面板」。<br/>
但如果后端接口没有二次验证，那么真正的危险在于：<strong>他能调用后台管理 API 删除数据。</strong></p>
<hr/>
<h2 data-id="heading-4">二、安全权限设计的核心原则</h2>
<ol>
<li>
<p><strong>前端展示，后端决策</strong></p>
<ul>
<li>前端只能控制 UI 是否显示某个按钮，不应决定「是否允许执行动作」。</li>
<li>所有与安全相关的逻辑（增删改、数据查询）必须由后端验证。</li>
</ul>
</li>
<li>
<p><strong>服务端必须验证权限 + 签名</strong></p>
<ul>
<li>后端是「唯一可信环境」，应验证请求来源、签名、角色、Token。</li>
</ul>
</li>
<li>
<p><strong>权限是「被动判定」，不是「主动记忆」</strong></p>
<ul>
<li>不依赖前端本地状态（如 localStorage）；</li>
<li>每次请求都在后端重新验证身份。</li>
</ul>
</li>
</ol>
<hr/>
<h2 data-id="heading-5">三、安全权限防护的分层架构</h2>
<p>为了实现安全的分布式权限体系，我们可以将系统划分为六层：</p>








































<table><thead><tr><th>层级</th><th>描述</th><th>核心防护策略</th></tr></thead><tbody><tr><td><strong>① 前端展示层</strong></td><td>Vue / React 应用</td><td>仅展示功能，不存储逻辑；限制 Token 暴露</td></tr><tr><td><strong>② 接入与网关层</strong></td><td>Nginx / Kong / API Gateway</td><td>限流、防爬；验证 Token 签名；请求日志</td></tr><tr><td><strong>③ 鉴权服务层</strong></td><td>OAuth2 / SSO Server</td><td>登录态验证；角色与租户判断；颁发 JWT</td></tr><tr><td><strong>④ 资源服务层</strong></td><td>各业务模块服务</td><td>核心逻辑校验：RBAC / ABAC 权限匹配</td></tr><tr><td><strong>⑤ 数据与审计层</strong></td><td>Database、Redis、ELK</td><td>脱敏、最小访问策略、操作留痕</td></tr><tr><td><strong>⑥ 安全监控层</strong></td><td>SIEM、Prometheus</td><td>风控检测、告警策略、异常分析</td></tr></tbody></table>
<h3 data-id="heading-6">架构图</h3>
<p>下图展示了完整防护分层结构（数据流由上至下）：</p>
<pre><code class="hljs language-css" lang="css">┌──────────────────────────────────────┐
│          安全监控层（SIEM/风控）     │
│  • 登录异常检测  • 攻击告警分析     │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          数据与审计层               │
│  • 数据最小权限访问                │
│  • 审计日志与安全追踪              │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          资源服务层（业务逻辑）      │
│  • 接口级权限控制（<span class="hljs-keyword">@RoleBasedAccess</span>）│
│  • 防越权、操作审计                │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          鉴权服务层（SSO）           │
│  • Token验证、角色发放              │
│  • 动态授权、租户隔离               │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          接入网关层（API Gateway）   │
│  • 限流、防爬、防刷                │
│  • HMAC签名验证                    │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          前端展示层（非信任区）      │
│  • 仅展示UI、读取Token提醒用户登录   │
│  • 禁止业务逻辑在本地执行           │
└──────────────────────────────────────┘
</code></pre>
<hr/>
<h2 data-id="heading-7">四、技术实现</h2>
<h3 data-id="heading-8">1. 后端角色权限注解示例</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 自定义注解</span>
<span class="hljs-variable">@Target</span>(ElementType.METHOD)
<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)
public <span class="hljs-variable">@interface</span> RoleCheck {
    <span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">value</span>();
}
</code></pre>

<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 拦截器实现</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">"Authorization"</span>);
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> TokenService.verify(token);
        <span class="hljs-type">RoleCheck</span> <span class="hljs-variable">check</span> <span class="hljs-operator">=</span> ((HandlerMethod) handler).getMethodAnnotation(RoleCheck.class);
        <span class="hljs-keyword">if</span> (check != <span class="hljs-literal">null</span> &amp;&amp; !user.hasAnyRole(check.value())) {
            res.setStatus(HttpServletResponse.SC_FORBIDDEN);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<blockquote>
<p>🔐 即便攻击者模拟请求或反编译前端，也无法绕过后端角色认证。</p>
</blockquote>
<hr/>
<h3 data-id="heading-9">2. 前端：基于权限的显示控制（非逻辑控制）</h3>
<pre><code class="hljs language-ini" lang="ini">// 假设后端返回的角色为 <span class="hljs-section">['user']</span>
const <span class="hljs-attr">userRoles</span> = [<span class="hljs-string">'user'</span>]<span class="hljs-comment">;</span>

const <span class="hljs-attr">routes</span> = [
  { name: <span class="hljs-string">'Dashboard'</span>, meta: { role: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>] } },
  { name: <span class="hljs-string">'SystemConfig'</span>, meta: { role: [<span class="hljs-string">'admin'</span>] } }
]<span class="hljs-comment">;</span>

// 仅前端渲染控制
const <span class="hljs-attr">visibleRoutes</span> = routes.filter(route =&gt;
  route.meta.role.some(<span class="hljs-attr">role</span> =&gt; userRoles.includes(role))
)<span class="hljs-comment">;</span>
</code></pre>
<blockquote>
<p>仅影响 UI 展示，不影响接口可访问性。</p>
</blockquote>
<hr/>
<h3 data-id="heading-10">3. 防反编译与攻击加固</h3>



































<table><thead><tr><th>攻击方式</th><th>防护措施</th><th>实践工具</th></tr></thead><tbody><tr><td>打包JS被逆向</td><td>混淆与代码压缩</td><td><code>terser</code>, <code>webpack-obfuscator</code></td></tr><tr><td>Token篡改</td><td>服务签名验证、短时效JWT</td><td>Redis / JWT RFC7519</td></tr><tr><td>模拟接口</td><td>请求签名（HMAC / Nonce）</td><td>Nginx + Auth Filter</td></tr><tr><td>调试注入</td><td>Content-Security-Policy (CSP)</td><td>HTTP 安全策略头</td></tr><tr><td>重放攻击</td><td>时间戳 + 随机Nonce验证</td><td>Redis缓存校验</td></tr></tbody></table>
<p><strong>签名验证示例（Node.js HMAC）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> crypto <span class="hljs-keyword">from</span> <span class="hljs-string">'crypto'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">signRequest</span>(<span class="hljs-params">payload, secret, timestamp</span>) {
  <span class="hljs-keyword">const</span> base = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload) + timestamp;
  <span class="hljs-keyword">return</span> crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">'sha256'</span>, secret).<span class="hljs-title function_">update</span>(base).<span class="hljs-title function_">digest</span>(<span class="hljs-string">'hex'</span>);
}
</code></pre>
<hr/>
<h2 data-id="heading-11">五、设计优缺点分析</h2>





























<table><thead><tr><th>模型</th><th>优点</th><th>缺点</th><th>适合场景</th></tr></thead><tbody><tr><td><strong>前端判断权限</strong></td><td>简单、体验好</td><td>易被绕过、不安全</td><td>仅用于 UI 控制</td></tr><tr><td><strong>后端校验权限</strong></td><td>安全、集中管理</td><td>开销稍高、响应滞后</td><td>核心业务接口</td></tr><tr><td><strong>分层架构权限体系</strong></td><td>安全与效率平衡</td><td>架构复杂、需治理</td><td>企业级中大型系统</td></tr></tbody></table>
<blockquote>
<p>✅ 推荐混合架构：前端保障体验，后端保障安全。</p>
</blockquote>
<hr/>
<h2 data-id="heading-12">六、结论</h2>
<p>在 Web 反编译几乎无法避免的时代，<strong>安全是策略，不是幻觉</strong>。</p>
<p>权限控制要从「信任前端」转变为「前后端协同」。<br/>
只要保持以下三点，你的权限体系就能在复杂的安全形势下立于不败之地：</p>
<ol>
<li><strong>一切授权最终落地后端；</strong></li>
<li><strong>所有敏感逻辑皆可审计；</strong></li>
<li><strong>前后端之间的信任关系可验证、可撤销。</strong></li>
</ol>
<p>未来，伴随 <strong>零信任架构（Zero Trust）</strong> 与 <strong>动态策略授权（Policy-based Access Control, PBAC）</strong> 的兴起，<br/>
权限安全将更加智能与分布化。安全从此不是附加，而将成为业务本身的一部分。</p>
<hr/>
<h2 data-id="heading-13">七、参考资料</h2>
<ol>
<li>[OWASP Top 10 2021: Broken Access Control]</li>
<li>[Spring Security Reference Documentation]</li>
<li>[MDN Web Docs: Content Security Policy (CSP)]</li>
<li>[RFC 7519 – JSON Web Token (JWT)]</li>
<li>[Zero Trust Architecture – NIST SP 800-207]</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java 后端定时任务怎么选：@Scheduled、Quartz 还是 XXL-Job？]]></title>    <link>https://juejin.cn/post/7603721514203316233</link>    <guid>https://juejin.cn/post/7603721514203316233</guid>    <pubDate>2026-02-08T06:51:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603721514203316233" data-draft-id="7603687444052099110" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java 后端定时任务怎么选：@Scheduled、Quartz 还是 XXL-Job？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:51:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java编程爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/819554264300154"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java 后端定时任务怎么选：@Scheduled、Quartz 还是 XXL-Job？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/819554264300154/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java编程爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:51:17.000Z" title="Sun Feb 08 2026 06:51:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>做后端总绕不开“定时任务”：对账、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%2595%25B0%25E6%258D%25AE%25E6%25B8%2585%25E7%2590%2586%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86&amp;zhida_source=entity" ref="nofollow noopener noreferrer">数据清理</a>、发券、补偿、同步……</p>
<p>但一到<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25BE%25AE%25E6%259C%258D%25E5%258A%25A1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">微服务</a>/多实例部署，很多同学就开始踩坑：<strong>同一任务在每台机器都跑一遍（重复执行）</strong> 、某台机器挂了任务就断了（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%258D%2595%25E7%2582%25B9%25E6%2595%2585%25E9%259A%259C%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C&amp;zhida_source=entity" ref="nofollow noopener noreferrer">单点故障</a>）、任务太久把<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25B0%2583%25E5%25BA%25A6%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">调度线程</a>卡死（后面全堵）……</p>
<hr/>
<h2 data-id="heading-0">“单机闹钟”还是“<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E8%25B0%2583%25E5%25BA%25A6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">分布式调度</a>”？</h2>
<ul>
<li>
<p>• <strong>单机定时任务</strong>：应用只部署 1 台（或明确只允许 1 台跑任务）。<br/>
✅ 这类任务追求“简单、快、少依赖”。</p>
</li>
<li>
<p>• <strong>分布式/<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E9%259B%2586%25E7%25BE%25A4%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E9%9B%86%E7%BE%A4&amp;zhida_source=entity" ref="nofollow noopener noreferrer">集群</a>定时任务</strong>：应用部署 N 台、会扩缩容、会<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%2595%2585%25E9%259A%259C%25E8%25BD%25AC%25E7%25A7%25BB%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB&amp;zhida_source=entity" ref="nofollow noopener noreferrer">故障转移</a>。<br/>
✅ 这类任务追求“只执行一次、可观测、可运维”。</p>
</li>
</ul>
<p><strong>在集群里，单机方案默认=每台都执行</strong>，不做控制就会重复跑。</p>
<hr/>
<h2 data-id="heading-1">三个方案</h2>
<h3 data-id="heading-2">1）<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%2540Scheduled%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%40Scheduled&amp;zhida_source=entity" ref="nofollow noopener noreferrer">@Scheduled</a>：Spring 自带的轻量方案（单机优先）</h3>
<p>就是给方法加个注解：cron / fixedRate / fixedDelay，立刻能跑。<br/>
优点：零额外<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25B8%25AD%25E9%2597%25B4%25E4%25BB%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E4%B8%AD%E9%97%B4%E4%BB%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">中间件</a>、和 Spring 生态贴合。</p>
<p>短板：<strong>天生不管集群</strong>（多实例就多份闹钟）、基本没<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%258F%25AF%25E8%25A7%2586%25E5%258C%2596%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%8F%AF%E8%A7%86%E5%8C%96&amp;zhida_source=entity" ref="nofollow noopener noreferrer">可视化</a>、想改规则通常要走发布流程。</p>
<blockquote>
<p>提醒：同一个方法可以声明多个 @Scheduled，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25A7%25A6%25E5%258F%2591%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%A7%A6%E5%8F%91%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">触发器</a>彼此独立，甚至可能并发/连续触发。</p>
</blockquote>
<hr/>
<h3 data-id="heading-3">2）<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DQuartz%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Quartz&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Quartz</a>：老牌、灵活、可集群（但“偏框架”）</h3>
<p>Quartz 的核心是 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DScheduler%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Scheduler&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Scheduler</a>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25B0%2583%25E5%25BA%25A6%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%B0%83%E5%BA%A6%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">调度器</a>）+ Job（任务）+ <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DTrigger%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Trigger&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Trigger</a>（触发器）</strong> ，能力非常全。<br/>
它也支持集群，但需要 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DJDBC%2BJobStore%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=JDBC+JobStore&amp;zhida_source=entity" ref="nofollow noopener noreferrer">JDBC JobStore</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2585%25B1%25E4%25BA%25AB%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93&amp;zhida_source=entity" ref="nofollow noopener noreferrer">共享数据库</a> + 锁</strong> 来保证同一触发点只跑一次：多个节点抢到锁的那个节点执行。</p>
<p>优点：能力强、模型成熟、可<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%25B7%25B1%25E5%25BA%25A6%25E5%25AE%259A%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">深度定制</a>。<br/>
短板：原生不带管理后台，<strong>集群配置/运维成本更高</strong>。</p>
<hr/>
<h3 data-id="heading-4">3）XXL-Job：开箱即用的分布式调度平台（偏“产品”）</h3>
<p>XXL-Job 更像“带后台的调度系统”：</p>
<ul>
<li>
<p>• Web 页面直接 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DCRUD%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=CRUD&amp;zhida_source=entity" ref="nofollow noopener noreferrer">CRUD</a> 任务，修改后<strong>即时生效</strong></p>
</li>
<li>
<p>• <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25B0%2583%25E5%25BA%25A6%25E4%25B8%25AD%25E5%25BF%2583%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83&amp;zhida_source=entity" ref="nofollow noopener noreferrer">调度中心</a>、执行器都支持集群 HA</p>
</li>
<li>
<p>• 支持分片广播、故障转移、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%259C%25A8%25E7%25BA%25BF%25E6%2597%25A5%25E5%25BF%2597%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%9C%A8%E7%BA%BF%E6%97%A5%E5%BF%97&amp;zhida_source=entity" ref="nofollow noopener noreferrer">在线日志</a>等</p>
</li>
<li>
<p>• 通过 DB 锁保证“一次调度只触发一次执行”</p>
</li>
</ul>
<p>优点：上手快、可视化强、分布式能力齐。<br/>
局限：任务模型/运行方式相对固定，<strong>超深度定制</strong>可能要读源码或二开。</p>
<hr/>
<h2 data-id="heading-5">核心<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BB%25B4%25E5%25BA%25A6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BB%B4%E5%BA%A6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">维度</a>对比（快速看懂版）</h2>









































<table><thead><tr><th>维度</th><th>@Scheduled</th><th>Quartz</th><th>XXL-Job</th></tr></thead><tbody><tr><td>依赖/引入成本</td><td>最低（Spring 内置）</td><td>中（引入框架 + 持久化/集群要配 DB）</td><td>中（调度中心 + 执行器）</td></tr><tr><td>可视化/运维</td><td>基本没有</td><td>原生没有（通常要自建）</td><td>自带 Web 管理后台</td></tr><tr><td>集群下“只跑一次”</td><td>不支持（需你自己加锁/选主）</td><td>支持（JDBC 集群 + DB 锁）</td><td>原生支持（DB 锁一致性）</td></tr><tr><td>动态修改规则</td><td>通常要发布/重启</td><td>支持 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DAPI%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=API&amp;zhida_source=entity" ref="nofollow noopener noreferrer">API</a> 动态改 Trigger</td><td>页面改完即时生效</td></tr><tr><td>适合场景</td><td>单机、小任务、快速实现</td><td>老系统/强定制/复杂触发需求</td><td>分布式、想省运维、团队人手不多</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">常见“坑点”与避坑建议</h2>
<h3 data-id="heading-7">A. @Scheduled 的坑（最容易被忽略）</h3>
<ol>
<li>
<p>1. <strong>默认调度线程少，任务会互相堵</strong><br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DSpring%2BBoot%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Spring+Boot&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Spring Boot</a> 默认的调度器（ThreadPoolTaskScheduler）<strong>默认只有 1 个线程</strong>，一个任务跑久了，后面的定时任务可能排队等。<br/>
✅ 建议：显式配置 scheduling <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程池</a>大小（至少让“慢任务”不拖死全局）。</p>
</li>
<li>
<p>2. <strong>fixedRate vs fixedDelay 用错，节奏就乱了</strong></p>
</li>
</ol>
<ul>
<li>
<p>• fixedRate：按“固定频率”触发（更像每隔 X 秒就开始一次）</p>
</li>
<li>
<p>• fixedDelay：按“上一次结束后再等 X 秒”<br/>
✅ 建议：想“准点”用 fixedRate/cron；想“串行且留间隔”用 fixedDelay。</p>
</li>
</ul>
<ol>
<li>3. <strong>集群重复执行</strong><br/>
多实例部署时，每台都会触发。<br/>
✅ 建议（择一）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2594%2581%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;zhida_source=entity" ref="nofollow noopener noreferrer">分布式锁</a>、Leader 选举、或把任务迁移到分布式调度平台。</li>
</ol>
<hr/>
<h3 data-id="heading-8">B. Quartz 的坑（集中在集群与稳定性）</h3>
<ol>
<li>
<p>1. <strong>集群必须用 JDBC JobStore + 共享 DB</strong><br/>
Quartz 的集群依赖共享数据库与<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E9%2594%2581%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E9%94%81%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">锁机制</a>；而且节点越多，锁竞争越明显，文档也提醒扩到很多节点性能会下降。<br/>
✅ 建议：Quartz 集群别盲目加节点，先评估调度密度与 DB 承载。</p>
</li>
<li>
<p>2. <strong>时间不同步会出大事</strong><br/>
官方明确提醒：集群机器时钟必须同步到“秒级”。<br/>
✅ 建议：NTP/chrony 做好<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%2597%25B6%25E9%2597%25B4%25E5%2590%258C%25E6%25AD%25A5%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5&amp;zhida_source=entity" ref="nofollow noopener noreferrer">时间同步</a>，别拿“差几秒没事”赌系统稳定。</p>
</li>
<li>
<p>3. <strong>Misfire（错过触发）没理解，任务可能“补跑/不跑”</strong><br/>
Quartz 文档解释：当持久化 Trigger 因为调度器关闭或线程不足等原因错过触发时间，就会发生 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3Dmisfire%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=misfire&amp;zhida_source=entity" ref="nofollow noopener noreferrer">misfire</a>，并按 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3Dmisfire%2B%25E7%25AD%2596%25E7%2595%25A5%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=misfire+%E7%AD%96%E7%95%A5&amp;zhida_source=entity" ref="nofollow noopener noreferrer">misfire 策略</a>处理。<br/>
✅ 建议：对关键任务明确配置 misfire 策略，别完全依赖默认“smart policy”。</p>
</li>
</ol>
<hr/>
<h3 data-id="heading-9">C. XXL-Job 的坑（集中在“平台化落地”）</h3>
<ol>
<li>
<p>1. <strong>调度中心/执行器尽量版本一致</strong><br/>
这是大量团队的真实经验：版本不一致时容易出现协议/字段不匹配等“玄学问题”。<br/>
✅ 建议：统一版本发布，至少保持同一大版本。</p>
</li>
<li>
<p>2. <strong>分片/路由策略选错，容易负载不均</strong><br/>
XXL-Job 支持“<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D2%26q%3D%25E5%2588%2586%25E7%2589%2587%25E5%25B9%25BF%25E6%2592%25AD%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=2&amp;q=%E5%88%86%E7%89%87%E5%B9%BF%E6%92%AD&amp;zhida_source=entity" ref="nofollow noopener noreferrer">分片广播</a>”“故障转移”等路由能力<br/>
✅ 建议：</p>
</li>
</ol>
<ul>
<li>
<p>• 大批量处理：优先分片广播 + 设计好分片参数</p>
</li>
<li>
<p>• 强可用：用故障转移，但要关注健康检查与超时</p>
</li>
</ul>
<ol>
<li>3. <strong>日志与数据留存</strong><br/>
它支持在线 Rolling 日志查看<br/>
✅ 建议：配好日志保留/归档策略，别让“<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25BB%25BB%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E4%BB%BB%E5%8A%A1%E6%97%A5%E5%BF%97&amp;zhida_source=entity" ref="nofollow noopener noreferrer">任务日志</a>”变成数据库/磁盘隐形炸弹。</li>
</ol>
<hr/>
<h2 data-id="heading-10">3 条“通用铁律”</h2>
<ol>
<li>
<p>1. <strong>任务幂等性</strong>：同一任务跑两次，也不能把钱扣两次/发两次券。</p>
</li>
<li>
<p>2. <strong>超时 + 告警</strong>：慢任务要能被发现、被终止或降级。</p>
</li>
<li>
<p>3. <strong>时间同步</strong>：尤其是集群调度，机器时间不准会让问题变得非常难排查。</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[线程池用完不Shutdown，CPU和内存都快哭了]]></title>    <link>https://juejin.cn/post/7603771025856593971</link>    <guid>https://juejin.cn/post/7603771025856593971</guid>    <pubDate>2026-02-08T06:52:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856593971" data-draft-id="7603687444052115494" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="线程池用完不Shutdown，CPU和内存都快哭了"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:52:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java编程爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/819554264300154"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            线程池用完不Shutdown，CPU和内存都快哭了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/819554264300154/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java编程爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:52:28.000Z" title="Sun Feb 08 2026 06:52:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>前言</strong></h2>
<p>大家平常使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DSpringBoot%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=SpringBoot&amp;zhida_source=entity" ref="nofollow noopener noreferrer">SpringBoot</a>进行Web项目开发，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程池</a>会被配置成为全局可复用的工具，生命周期随服务启动开始，到服务停止即结束。这种“<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0%25E6%2589%2598%25E7%25AE%25A1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%98%E7%AE%A1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程池托管</a></strong>”模式，让多少兄弟产生美丽的错觉 ：“原来线程池会自己管理自己啊！”</p>
<p>但是，当需求经理对你露出神秘的微笑：“这个批量导出需求，今晚就要...”。你不得不撸起袖子，写下了罪恶的代码创建临时线程池，这时兄弟们，如果对线程池使用不当，很容易给服务埋下隐患 。</p>
<h2 data-id="heading-1"><strong>1 问题初现</strong></h2>
<h3 data-id="heading-2"><strong>1.1 示例代码</strong></h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/806758f53acb433f8ab961a2b8bb0b9b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=OtgSIADCBnLAOodNWffoPlxGgcg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3"><strong>1.2 问题描述</strong></h3>
<p><strong>面试官：</strong> 不考虑任务内部的复杂度，这个线程池的使用会有问题吗？</p>
<p><strong>菜鸟：</strong> 方法执行完弹栈后，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25B1%2580%25E9%2583%25A8%25E5%258F%2598%25E9%2587%258F%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&amp;zhida_source=entity" ref="nofollow noopener noreferrer">局部变量</a>，都会被GC回收，谁写的代码，稳得很啊！</p>
<p><strong>老鸟：</strong> （一口咖啡喷屏幕上）老弟，你线程池用完不用shutdown呀？</p>
<p>===========</p>
<p><strong>再问：反正任务执行完，内存都会被GC回收，非得Shutdown一下不多余吗？</strong></p>
<p><strong>菜鸟：</strong> ......</p>
<p><strong>老鸟：</strong> （邪魅一笑）倒也不是必须Shutdown，但是不建议犯险尝试，请看VCR演示（代码演示）</p>
<h2 data-id="heading-4"><strong>2 走进科学实验现场（验证)</strong></h2>
<blockquote>
<p><strong>说明</strong>：本文讨论的线程池对象及相关源码，都围绕常用的java.util.concurrent.ThreadPoolExecutor类展开，下文不再额外说明</p>
</blockquote>
<h3 data-id="heading-5"><strong>2.2 装备说明（代码）</strong></h3>
<p>⚠️ <strong>警 告</strong> ：紧接着将出现大量源码解析，可能引起轻微不适。</p>
<blockquote>
<p><strong>说明</strong>：以下代码都是在一个类中，queue、phantomRef这两个对象是作为全局对象，专门捕捉那个"肉身已死但阴魂不散"的线程池对象。</p>
</blockquote>
<p><strong>2.2.1 幽灵探测仪（判断线程池对象是否被回收)</strong></p>
<p>因为验证的代码是在一个成熟的SpringBoot项目中跑的，线程池对象太多了，从内存分析工具上监测这单个线程池对象是否被GC回收不够直观，这里借助<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%2599%259A%25E5%25BC%2595%25E7%2594%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%99%9A%E5%BC%95%E7%94%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">虚引用</a>来判断线程池对象是否被回收。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f97518c695f425baa555668a97daca8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=gnj34fOpOeQMhG8KSl92zgN09I4%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.2 实验1：core 0，max 100 任务完成后，不进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30f051d9361745848f80f80d62757217~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=dMDy%2BfzFkIAe7dHFz5K6NlfVsqw%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.3 实验2：core 0，max 100 任务完成后，进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e649d955b88c4675a8c8bd8cf6664a22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=R7YMvsK7ewcdISdDfl53zgmR7tk%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.4 实验3：core 100，max 100 任务完成后，不进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cffac05c8a2412db8144327b6a211fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=5OTUMfaWOiIyOUzxsybVHiIq3R8%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.5 实验4：core 100，max 100 任务完成后，进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d47b3a408210415d99446b513115148c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=OUlvqmV4Jf4HhebQKmGhDkbgUWw%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.6 任务执行代码示例</strong></p>
<p><strong>解释说明：</strong></p>
<p>任务数量是110，主要是为了保证有足够多的任务让线程池所有线程能够打满；任务里面要sleep 500ms，也是同样的道理</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1925b9232ba541f5bd7893a55ef6c6cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=bkyaOViCgHvth0dlCtgBz5wKAes%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6"><strong>2.3 实验执行结果</strong></h3>
<p><strong>2.3.1 实验执行步骤</strong></p>
<p>项目启动后，依次执行上述4个实验。需要注意的是时间间隔要保证前一个实验的任务全部执行完，最好再留一些空挡，这样监控更清晰</p>
<p>每个实验执行完后，分别执行一次2.2.1 判断线程池对象是否回收</p>
<p><strong>2.3.2 结果分析</strong></p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DJVM%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=JVM&amp;zhida_source=entity" ref="nofollow noopener noreferrer">JVM</a>初始状态</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9e895c3c92b4940aa3974e72e78c8bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=zVLitQZhDfgE0%2B4Ca67RSMYTxAs%3D" alt="" loading="lazy"/></p>
<p>1. <strong>实验1执行监控</strong></p>
<p>core 0，max 100 任务完成后，不进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3e22d687ea14a07a6290204a10f79b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=59xOR3kyDR2654pQfDP8pIBVato%3D" alt="" loading="lazy"/></p>
<p>2. <strong>实验2执行监控</strong></p>
<p>core 0，max 100 任务完成后，进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ab80c0e84b849c1a2e1f638bf5774cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=sHtcQ7AxzY7XE2bjpBrcBhkQyck%3D" alt="" loading="lazy"/></p>
<p>3. <strong>实验3执行监控</strong></p>
<p>core 100，max 100 任务完成后，不进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a077c5114484eaabb501e0c6b643d2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=mjclYoEvREyRAYkg0AP%2FVSnETCc%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e04985847703446488554e0594f42b7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=UpPpi%2FGiXxv2Z%2B1vQGs%2BYKEcYPo%3D" alt="" loading="lazy"/></p>
<p>4. <strong>实验4执行监控</strong></p>
<p>core 100，max 100 任务完成后，进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1efdeab66fd74b0ca1a5bcfa439c1618~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=T1Kv%2F6vTF2BppYHQ6u%2FMnBfrsDg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7"><strong>3 原因解剖室</strong></h2>
<p><strong>接下来都是对实验3的异常现象进行的分析</strong></p>
<h3 data-id="heading-8"><strong>3.1 shutdown的五步拆解法</strong></h3>
<p>首先看下ThreadPoolExecutor#shutdown方法</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a785cda4800b48069a7dd793a0780e74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=z0AhwGEexSUCqel2IYFOlS%2BQmrk%3D" alt="" loading="lazy"/></p>
<p>截图中，可以看到shutdown方法里面，主要做了5个动作：</p>
<ol>
<li>
<p>根据方法名称可以看出是一个检查动作，这里不用细看</p>
</li>
<li>
<p>把线程池状态置为SHUTDOWN状态<strong>重要</strong></p>
</li>
<li>
<p>根据方法名称可以看出是将线程池中的空闲线程进行中断 <strong>重要</strong></p>
</li>
<li>
<p>根据注释来看，是给特定场景对象使用，这里不用细看</p>
</li>
<li>
<p>尝试终止线程池（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25B8%25AD%25E6%2596%25AD%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">中断线程</a>、关闭线程池）</p>
</li>
</ol>
<p>每一步的细节处理，这里就不带大家看了，有兴趣可以点开源码一步步研究下。<strong>总结下来就是，线程池执行shutdown方法后：</strong></p>
<ol>
<li>线程池对象置为SHUTDOWN状态——<strong>挂上“暂停营业”牌子</strong></li>
<li>将线程池中空闲线程置为中断状态，最终从线程池中剔除(会被GC回收)——<strong>给闲逛的线程发《<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25A7%25A3%25E8%2581%2598%25E9%2580%259A%25E7%259F%25A5%25E4%25B9%25A6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%A7%A3%E8%81%98%E9%80%9A%E7%9F%A5%E4%B9%A6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">解聘通知书</a>》</strong></li>
<li>线程池中的线程对象会置为中断状态，最终terminated</li>
</ol>
<h3 data-id="heading-9"><strong>3.2 为什么线程池不进行shutdown，在方法弹栈后不会立即被GC回收？</strong></h3>
<p>首先我们梳理一下当前执行实验的线程方法栈、线程池、线程池中的线程之间的引用关系图如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d695e9bf18f541aca26f75fb664d4160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=IdG%2Fic3WXaYgjLk8rLjURYdfolo%3D" alt="" loading="lazy"/></p>
<p>实验3中，当主方法执行完弹栈后，短时间内，线程池中的线程对象仍处于<strong>空闲/活跃状态</strong>。但是线程池对象已经不被主线程对象中的方法栈持有，也就是<strong>图中关系1断开</strong>，按照JVM的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%259E%2583%25E5%259C%25BE%25E5%259B%259E%25E6%2594%25B6%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">垃圾回收机制</a>，这时，ThreadPoolExecutor对象已经不被GCRoot引用，是要被GC回收的，但是从2.3.2中的实验3执行监控来看，ThreadPoolExecutor对象并没有被GC回收。</p>
<p><strong>疑问：难道还有什么对象持有这个线程池对象的引用？</strong></p>
<p>首先，由于JVM的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25BF%2590%25E8%25A1%258C%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">运行机制</a>，每一个java线程都关联一个<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DOS%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=OS%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">OS线程</a>，线程对象在terminated之前(线程任务执行完之前)，都不会被GC回收。</p>
<p>上面的引用关系实际上应该是下面这样的，线程池中的每个线程对象都有自己的执行方法栈对象</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9bbb8eab3f5493e96cc2f66c55d7ebf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=8bi1EYjEZoIm%2BLLwF8fa10bKzzc%3D" alt="" loading="lazy"/></p>
<p>根据2.3.2中的几个执行结果监控，就能看出，线程池对象的回收与线程池中的工作线程是否被全部回收是有关系的，所以先预测线程池中的线程对象是持有线程池对象的引用的，然后基于这个预测，去源码中找理论支撑。</p>
<p><strong>预测存在黄色箭头依赖关系，如下图：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34a8a758153d48679cf97849ab26af8f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=t804CVJMgGvj1PZTAyFSr5TV7FY%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10"><strong>3.3 线程对象为何会持有线程池对象的引用？</strong></h3>
<p>其实，上面的引用关系图中，所有的正向依赖关系我们不难理解。需要验证的是反向的依赖关系r 2.x和r 3.x，这些反向的依赖关系都是什么时候建立的？可以从下面几个问题入手去排查：</p>
<ol>
<li>线程池(ThreadPoolExecutor)类结构中是否有相关对象的属性字段？</li>
<li>线程池对象中<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DWorker%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=Worker&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Worker</a>集合中Worker对象创建时机？</li>
<li>Worker对象创建时是如何建立相应的依赖关系的？</li>
</ol>
<p>从线程池提交任务开始，从源码中可以看到worker类结构中本身定义有Thread变量属性，在Worker对象创建时，就为Thread属性显式赋值：</p>
<p><strong>Worker类定义如下：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99b021a6362a4febb662dd802655d71e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=EsbpifZlzr9gdBOhfy4OuZHl5XM%3D" alt="" loading="lazy"/></p>
<p><strong>Worker对象创建时机如下：</strong></p>
<p>从CompletableFuture工具任务执行方法中一步步进入源码，可以看到如下关系</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ac031ed60b9495a8d87bfdc92f2c5d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=PFF77Y7Yy8iC6NPQLPBcw8aLXE4%3D" alt="" loading="lazy"/></p>
<p>上面两段源码截图中，验证了<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25BE%259D%25E8%25B5%2596%25E5%2585%25B3%25E7%25B3%25BB%25E5%259B%25BE%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE&amp;zhida_source=entity" ref="nofollow noopener noreferrer">依赖关系图</a>中<strong>2.x，3.x</strong>与<strong>r 3.x</strong>的依赖关系，还剩下<strong>r 2.x</strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D8%26q%3D%25E4%25BE%259D%25E8%25B5%2596%25E5%2585%25B3%25E7%25B3%25BB%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=8&amp;q=%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB&amp;zhida_source=entity" ref="nofollow noopener noreferrer">依赖关系</a>没有得到验证。</p>
<p>首先，从Worker类结构上，没有找到Worker类中有定义对ThreadPoolExecutor类的显式引用，并且从2.3.2的实验执行结果图中可以看到，即使多次触发GC，依旧没有将ThreadPoolExecutor对象回收掉，所以，<strong>Worker-&gt;ThreadPoolExecutor肯定是一种<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25BC%25BA%25E5%25BC%2595%25E7%2594%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BC%BA%E5%BC%95%E7%94%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">强引用</a></strong>(4种引用关系：强引用、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25BD%25AF%25E5%25BC%2595%25E7%2594%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%BD%AF%E5%BC%95%E7%94%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">软引用</a>、弱引用、虚引用)。</p>
<p>那么，哪些行为会让对象之间建立强引用关系呢？我们先问下AI助手，让它罗列出会建立引用关系的代码行为。总结归纳如下：</p>
<ol>
<li>对象中的属性字段显式赋值引用</li>
<li>数组、集合对象中添加其他对象的引用</li>
<li>子类通过面向对象的继承多态特性引用父类中的属性字段</li>
<li>还有一种平常关注较少的，相对隐式的引用关系——内部<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25B1%25BB%25E5%25AF%25B9%25E8%25B1%25A1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E7%B1%BB%E5%AF%B9%E8%B1%A1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">类对象</a>引用外部类对象</li>
</ol>
<p>从Worker的类结构来看，是没有显示的对ThreadPoolExecutor的属性引用的，也没有相关的数据、集合，<strong>所以1,2不成立</strong>。Worker对象与ThreadPoolExecutor也没有直接或者间接的继承/实现关系，<strong>所以3也不成立。</strong></p>
<p>最后再看Worker类定义，确实是在ThreadPoolExecutor类的内部(内部类对象持有外部类对象的验证很简单，不在这里赘述)。这样Worker-&gt;ThreadPoolExecutor的引用关系就能说得通了。至此，<strong>引用依赖关系图中预测的r 2.x和r 3.x关系都成立了。</strong></p>
<h3 data-id="heading-11"><strong>3.4 原因逻辑梳理</strong></h3>
<p>再次把依赖关系图贴出来，一起再梳理一下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a9850d8c7974bec9dee423b57870d4b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=sbm8cYeSHSVSpfkNYIvETGToQgM%3D" alt="" loading="lazy"/></p>
<ol>
<li>当前方法main-Thread执行完，main-Thread的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D4%26q%3D%25E6%2596%25B9%25E6%25B3%2595%25E6%25A0%2588%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=4&amp;q=%E6%96%B9%E6%B3%95%E6%A0%88&amp;zhida_source=entity" ref="nofollow noopener noreferrer">方法栈</a>都弹栈</li>
<li>依赖关系<strong>1</strong>断开，线程池不再被活跃线程引用，不会再有任务进来</li>
<li>当线程池任务都完成，此时线程池中的线程都处于休眠(wait)状态，等待任务队列中任务进来</li>
<li>由于线程池中的线程都处于存活状态，不会被回收</li>
<li>存在<strong>线程池线程_n</strong> <strong>-&gt; worker_n -&gt; 线程池</strong>的逆向引用关系</li>
<li>所以导致实验3中的现象——线程池和线程池中线程无法被GC回收</li>
</ol>
<h2 data-id="heading-12"><strong>4 线程池未shutdown的影响</strong></h2>
<p>这里再把实验3会导致系统的出现的问题总结一下。通过2.3.2中的实验3监控图以及源码，我们可以看到，线程池使用完，未及时进行shutdown，就最差的情况来说，会导致的问题：</p>
<ol>
<li>
<p>线程池对象无法被GC回收——<strong>内存泄露</strong></p>
</li>
<li>
<p>线程对象无法被GC回收——<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2586%2585%25E5%25AD%2598%25E6%25B3%2584%25E6%25BC%258F%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&amp;zhida_source=entity" ref="nofollow noopener noreferrer">内存泄漏</a></strong></p>
</li>
<li>
<p>从线程获取任务的源码来看，即使任务队列中是空的，只要线程池状态仍处于<strong>Running</strong>，线程会定时从wait状态苏醒，重新获取任务——<strong>占用CPU执行分片</strong></p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/295892aeb97a4c2fa7e3e8cf42023cc2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=K1Nt2f65n29D%2F73Nk7ea5MFKDEI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-13"><strong>血泪教训总结</strong></h2>
<ol>
<li><strong>线程池用完一定要养成shutdown的习惯：</strong> 因为有的没关好，真的会漏水(内存泄露)</li>
<li><strong>线程池创建线程命名，一定要有业务相关标识：</strong> 建议采用“业务场景+线程计数”法："<strong>订单导出-xx"、"邮件发送-xx"</strong> ，出问题时秒锁嫌疑人："就是订单导出线程在摸鱼！"</li>
<li><strong>内部类使用要谨慎：</strong> 谈恋爱可以，玩失踪不行，别让人家（GC）找不到你！</li>
</ol>
<h2 data-id="heading-14"><strong>文末彩蛋</strong></h2>
<p>以后，你在代码里看到随手创建的线程池，最终没有.shutdown()，请像看到有人上厕所不冲水一样，大喊：“同！学！你！线程池！忘！关！了！”</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[去到比北方更北的地方—2025年终总结]]></title>    <link>https://juejin.cn/post/7603769956975231017</link>    <guid>https://juejin.cn/post/7603769956975231017</guid>    <pubDate>2026-02-08T06:56:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603769956975231017" data-draft-id="7591389489411555369" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="去到比北方更北的地方—2025年终总结"/> <meta itemprop="keywords" content="前端,AI编程,年终总结"/> <meta itemprop="datePublished" content="2026-02-08T06:56:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="海石"/> <meta itemprop="url" content="https://juejin.cn/user/3747593580715102"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            去到比北方更北的地方—2025年终总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3747593580715102/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    海石
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:56:33.000Z" title="Sun Feb 08 2026 06:56:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p><em>想写年终总结的心情，是在看到车窗外的雪之后，突然有的。</em></p>
<p>2025年的最后一天，我们坐上了从北京朝阳开往延吉西的高铁。</p>
<p>车厢内的暖气开得很足，我靠在椅背上，觉得码字是打发这6小时车程再好不过的事。</p>
<p>古典主义认为灵感是神的旨意，于是我便开始等待，等待着神对我下达祂的旨意。</p>
<p>没等多久我就发现了比码字还要好的事情，那就是睡觉。</p>
<p>于是这一篇在离开北京时就想写的文章，最终还是在我回北京之后，才被写出来。</p>
<hr/>
<h2 data-id="heading-0">时代的关键词</h2>
<blockquote>
<p>如果让大家用一个词语形容2025年，大家会选择什么词语呢？</p>
</blockquote>
<p>我选的词语是“AI”</p>
<p>从chatGPT一鸣惊人的“AI元年”来算，这波浪潮已经汹涌了3年。</p>
<p>大家都说要拥抱变化，拥抱变化 。</p>
<p>个人感觉变化已经不够形容了</p>
<p>这是 <strong>冲击</strong></p>
<p>以<code>Cursor</code>为首的AI IDE工具正在冲击我们这个职业</p>
<p>技术社区的博客里涌现出越来越多的名词，LLM、Agent、MCP、CSR、Rules、Skills、AGUI、A2UI、A2A等等</p>
<p>集团在年初邀请梁宁做了一次分享，我当时没来得及去线下，后来用几个午休的时间，断断续续看完了录播回放</p>
<p>在视频播放完毕，进度条已经重置的时候，脑海里还是存在着她频频提到的6个字</p>
<p><em>“时代的关键词”</em></p>
<ul>
<li>
<p>蒸汽时代的关键词是效率不对称</p>
</li>
<li>
<p>互联网时代的关键词是信息不对称</p>
</li>
<li>
<p>AI时代的关键词是经验不对称</p>
</li>
</ul>
<p>从梁宁的视角看互联网时代，对我来说是很新奇的体验：</p>
<p>“互联网解决的是什么问题，解决的就是信息不对称这个问题</p>
<p>所以我们有时候也会用‘信息时代’来称呼‘互联网时代’</p>
<p>那么什么是‘信息’？</p>
<p>我们在网上看到的图片也好，视频也好，文字也好，认为自己看到了一个商品也好、人物也好。</p>
<p>我们在互联网上看到的一切，都是信息。</p>
<p>再书面化一些，引用《信息系统项目管理师教程》这本书里对于信息的定义</p>
<blockquote>
<p>信息是物质、能量及其属性的标示的集合</p>
</blockquote>
<p>谈到互联网时代，谈到互联网，肯定绕不开BAT，</p>
<p>为什么BAT会产生、会崛起？</p>
<p>先说B，百度是搜索引擎，他天然收割了web上的所有信息</p>
<p>互联网解决的是信息不对称的问题，搜索引擎又天然站在了这种生态位的顶端，他能拿到全量的信息，作为收割者</p>
<p>因此这也是为什么最初B是BAT之首的原因。</p>
<p>再说T，腾讯的核心信息是什么？是人，</p>
<blockquote>
<p>“人是一切社会关系的总和” —马克思</p>
</blockquote>
<p>在互联网如何用信息表达一个人？</p>
<p>id和关系链</p>
<p>没人能撼动他的核心，碰他的人</p>
<p>而且他跳脱在了百度的收割之外</p>
<p>因为他是客户端</p>
<p>最后来说说A，阿里</p>
<p>为什么百度也收割不了阿里？</p>
<p>最早的时候淘宝主动屏蔽百度的搜索，淘宝通过构建自己的商品信息生态，他自己打造的信息当然是他自己内部收割，因此百度收割不了他的信息</p>
<p>人的信息、交易的信息、其他的信息（比如携程）构成了信息的全部</p>
<p>现在则是每个企业都在构建自己的信息生态，携程是酒旅，京东是供应链</p>
<p>而到了移动互联网时代，</p>
<p>小红书、抖音又有自己的信息生态”</p>
<p>那么AI时代的经验不对称又该从何说起？</p>
<p>如何区分“知识”和“经验”？</p>
<p>我很好奇梁宁又会怎么看待现在的时代，在《真需求》这本书写完后，外边的世界发生了天翻地覆的变化…</p>
<h2 data-id="heading-1">与其感慨路难行，不如马上出发</h2>
<p>打完这个标题，我抬头看了一眼电脑旁的饮料，写文字的时候需要喝点小甜水，这是我两年前养成的习惯</p>
<p>后来我发现很多作家也有这样的习惯，王小波需要一直喝茶、吸烟，来让自己保持一个亢奋的状态，用于写作</p>
<ul>
<li>
<p>2024年，我写了将近20万字，输出了34篇技术博客，掘金的热榜挤进去过几次，还“混“上过第一，至于喝掉了的饮料数...大概也能在余杭区拔得头筹吧😄</p>
</li>
<li>
<p>2025年，我只在掘金发了3篇文章，正文加起来估计1万字左右</p>
</li>
</ul>
<p>同比<strong>下降2000%</strong>，我还想不想在掘金混了？</p>
<p>非也非也，倒不是我也感慨路难行了所以不去行了，而是转战场了，主要的技术沉淀与分享都在公司内部社区。</p>
<p>本来这一章节是想顺着这个标题做一些技术写作的心得分享，但是随着OpenClaw的出现，我对技术写作产生了完全不同于以往的想法</p>
<ul>
<li>
<p>就像OpenClaw出现之后，程序员应该去写让大模型更方便阅读和理解的cli层面的东西一样。</p>
</li>
<li>
<p>以后所谓的技术博客，是不是也就是写成让大模型更能读懂、最佳读懂代码的提示词而已</p>
</li>
</ul>
<p>形态上的变化</p>
<p>比如我写一篇源码分析，代码层面的查看基本就是靠大模型通过csr去全面解读，然后我再基于个人经验和理解完成汇总，顺便补上知识点的官方文档出处，确保不会误人子弟、减少大模型的幻觉</p>
<p>但是其实很多时候也没必要花力气打开博客论坛去看别人的这种文章</p>
<p>作为开发者我期望我能在AI IDE里完成一切，我希望它在代码解读时是站在高质量技术博主的视角上的。</p>
<p>很多时候同一个知识点，不同水平的人看到的门道是不一样的。</p>
<p>说个八股文，js的闭包是千人千面，各种说法都有，</p>
<p>背后的根因我想就是每个人的理解有深有浅。</p>
<p>大家用了这么久的技术论坛，应该看过不少技术大佬、技术团队的文章</p>
<p>有些技术大佬看问题的角度特别刁钻、特别深入，看完往往会让人拍大腿，原来还能这么理解吗？</p>
<p>有些技术团队看问题直抓本质，解决方案一出就是最佳实践</p>
<p>如果大模型能够具备和这些技术大佬、技术团队一样对问题/现象/知识点 的思考与解读能力</p>
<p>我们是否还有必要访问技术论坛、关注这些技术大佬、技术团队呢？</p>
<p>或许，在未来，技术博客只有帮助作者本人沉淀知识、掌握知识这一个作用了？</p>
<p>（费曼学习法：教授他人，对学习的吸收率是90%）</p>
<h2 data-id="heading-2">“前端已死”</h2>
<ul>
<li>
<p>Claude模型更新了，甩开别的一大截，前端已死</p>
</li>
<li>
<p>GPT 5更新了，CodeMax模式，甩开别的一大截，前端已死</p>
</li>
<li>
<p>Gemini更新了，甩开别的一大截，前端已死</p>
</li>
</ul>
<p>前端又双叒叕死了😭</p>
<p>Vibe Coding确实给我们这个行业带来了巨大的影响</p>
<p>skills出来前，依托mcp和rules，再加上规约编程，大模型就能写出很不错的、符合研发规范的代码了</p>
<p>再加上一些d2c的工具，从0到1的需求开发，效率确实得到了显著的提升</p>
<p>但是目前的模式对于增量开发（基于工程现有功能完成需求迭代）的提效其实没那么显著</p>
<p>再者，对于程序员来说，写代码需要的时间很多时候并不是大头，更多时间被花在了prd评审，上下游对齐，协作沟通，开会等非编码性质的事上</p>
<p>我们可能不应该再继续想着提升5个流程节点中某个节点的几个子节点的效率</p>
<p>（比如研发节点中的设计稿还原、code reciew这些子节点）</p>
<p>而是能不能把5个流程节点直接砍成3个，这种层面的提效</p>
<p>Vibe Coding什么时候可以不仅仅是Coding？</p>
<h2 data-id="heading-3">去到比北方更北的地方</h2>
<p>前端不仅仅只是前端</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Boot 4 升级指南：告别RestTemplate，拥抱现代HTTP客户端]]></title>    <link>https://juejin.cn/post/7603651855236808713</link>    <guid>https://juejin.cn/post/7603651855236808713</guid>    <pubDate>2026-02-08T06:12:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651855236808713" data-draft-id="7603687444052033574" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Boot 4 升级指南：告别RestTemplate，拥抱现代HTTP客户端"/> <meta itemprop="keywords" content="后端,Spring Boot"/> <meta itemprop="datePublished" content="2026-02-08T06:12:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Boot 4 升级指南：告别RestTemplate，拥抱现代HTTP客户端
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:12:38.000Z" title="Sun Feb 08 2026 06:12:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Spring Boot 4 升级指南：告别RestTemplate，拥抱现代[HTTP客户端]</h2>
<h3 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>引言</h3>
<p>随着Spring Boot 4.0的发布，我们正式告别了一个时代——RestTemplate这个伴随Java开发者十余年的[HTTP客户端工具]正式进入弃用阶段。在Spring Boot 4.0中，Spring官方强烈建议迁移到更现代、更强大的HTTP客户端解决方案。</p>
<p>本文将详细介绍在Spring Boot 4.0环境中如何替换RestTemplate，以及推荐的新一代HTTP客户端解决方案。</p>
<h3 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>背景：为什么RestTemplate不再推荐？</h3>
<h4 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1. 技术演进</h4>
<ul>
<li><strong>Spring Framework 5+</strong> ：从Spring Framework 5开始，RestTemplate已被标记为弃用</li>
<li><strong>响应式编程趋势</strong>：现代应用需要异步非阻塞的HTTP调用能力</li>
<li><strong>性能优化</strong>：新的HTTP客户端提供更好的性能和资源利用率</li>
</ul>
<h4 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2. Spring Boot 4.0的变化</h4>
<p>Spring Boot 4.0对HTTP客户端进行了重大调整：</p>
<ul>
<li>RestTemplate进入完全弃用状态</li>
<li>推荐使用WebClient（响应式）或RestClient（同步）</li>
<li>移除了对传统HTTP客户端的内置支持</li>
</ul>
<h3 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>推荐的替代方案</h3>
<h4 data-id="heading-6"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>方案一：WebClient（推荐用于异步场景）</h4>
<p>WebClient是Spring WebFlux项目的一部分，提供响应式、非阻塞的HTTP客户端功能。</p>
<h5 data-id="heading-7"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>依赖配置</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- Maven配置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
12345
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// Gradle配置</span>
implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-webflux'</span>

AI写代码gradle
<span class="hljs-number">12</span>
</code></pre>
<h5 data-id="heading-8"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>基本使用示例</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> org.springframework.web.reactive.function.client.WebClient;
<span class="hljs-keyword">import</span> reactor.core.publisher.Mono;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;
    
    <span class="hljs-keyword">public</span> HttpClientService() {
        <span class="hljs-keyword">this</span>.webClient = WebClient.builder()
                .baseUrl(<span class="hljs-string">"https://api.example.com"</span>)
                .defaultHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)
                .build();
    }
    
    <span class="hljs-comment">// GET请求</span>
    <span class="hljs-keyword">public</span> Mono&lt;String&gt; getData(String id) {
        <span class="hljs-keyword">return</span> webClient
                .<span class="hljs-keyword">get</span>()
                .uri(<span class="hljs-string">"/data/{id}"</span>, id)
                .retrieve()
                .bodyToMono(String.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// POST请求</span>
    <span class="hljs-keyword">public</span> Mono&lt;User&gt; createUser(User user) {
        <span class="hljs-keyword">return</span> webClient
                .post()
                .uri(<span class="hljs-string">"/users"</span>)
                .bodyValue(user)
                .retrieve()
                .bodyToMono(User.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// 响应式链式调用</span>
    <span class="hljs-keyword">public</span> Mono&lt;Result&gt; complexWorkflow(String id) {
        <span class="hljs-keyword">return</span> webClient
                .<span class="hljs-keyword">get</span>()
                .uri(<span class="hljs-string">"/data/{id}"</span>, id)
                .retrieve()
                .bodyToMono(Data.<span class="hljs-keyword">class</span>)
                .flatMap(<span class="hljs-keyword">data</span> -&gt; webClient
                        .post()
                        .uri(<span class="hljs-string">"/process"</span>)
                        .bodyValue(<span class="hljs-keyword">data</span>)
                        .retrieve()
                        .bodyToMono(Result.<span class="hljs-keyword">class</span>));
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</span>
</code></pre>
<h5 data-id="heading-9"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>WebClient的优势</h5>
<ol>
<li><strong>异步非阻塞</strong>：支持响应式编程模式</li>
<li><strong>背压支持</strong>：内置背压处理机制</li>
<li><strong>流式处理</strong>：支持服务器端推送和流式数据</li>
<li><strong>函数式API</strong>：提供链式调用的函数式API</li>
<li><strong>更好的错误处理</strong>：支持错误恢复和重试机制</li>
</ol>
<h4 data-id="heading-10"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>方案二：RestClient（推荐用于同步场景）</h4>
<p>Spring 6.1引入的RestClient提供了现代化的同步HTTP客户端API。</p>
<h5 data-id="heading-11"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>依赖配置</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- Maven配置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
12345
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// Gradle配置</span>
implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span>

AI写代码gradle
<span class="hljs-number">12</span>
</code></pre>
<h5 data-id="heading-12"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>基本使用示例</h5>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">import</span> org.springframework.web.client.RestClient;
<span class="hljs-keyword">import</span> org.springframework.core.ParameterizedTypeReference;

@Service
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncHttpClientService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SyncHttpClientService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.restClient = RestClient.<span class="hljs-built_in">builder</span>()
                .<span class="hljs-built_in">baseUrl</span>(<span class="hljs-string">"https://api.example.com"</span>)
                .<span class="hljs-built_in">defaultHeader</span>(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)
                .<span class="hljs-built_in">build</span>();
    }
    
    <span class="hljs-comment">// GET请求</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-type">String</span> id)</span> </span>{
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-built_in">get</span>()
                .<span class="hljs-built_in">uri</span>(<span class="hljs-string">"/users/{id}"</span>, id)
                .<span class="hljs-built_in">retrieve</span>()
                .<span class="hljs-built_in">body</span>(User.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// POST请求</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">createUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-built_in">post</span>()
                .<span class="hljs-built_in">uri</span>(<span class="hljs-string">"/users"</span>)
                .<span class="hljs-built_in">body</span>(user)
                .<span class="hljs-built_in">retrieve</span>()
                .<span class="hljs-built_in">body</span>(User.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// 复杂查询参数</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">searchUsers</span><span class="hljs-params">(<span class="hljs-type">String</span> name, <span class="hljs-type">int</span> page, <span class="hljs-type">int</span> size)</span> </span>{
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-built_in">get</span>()
                .<span class="hljs-built_in">uri</span>(uriBuilder -&gt; uriBuilder
                        .<span class="hljs-built_in">path</span>(<span class="hljs-string">"/users/search"</span>)
                        .<span class="hljs-built_in">queryParam</span>(<span class="hljs-string">"name"</span>, name)
                        .<span class="hljs-built_in">queryParam</span>(<span class="hljs-string">"page"</span>, page)
                        .<span class="hljs-built_in">queryParam</span>(<span class="hljs-string">"size"</span>, size)
                        .<span class="hljs-built_in">build</span>())
                .<span class="hljs-built_in">retrieve</span>()
                .<span class="hljs-built_in">body</span>(<span class="hljs-keyword">new</span> ParameterizedTypeReference&lt;List&lt;User&gt;&gt;() {});
    }
    
    <span class="hljs-comment">// 错误处理</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserWithErrorHandling</span><span class="hljs-params">(<span class="hljs-type">String</span> id)</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> restClient
                    .<span class="hljs-built_in">get</span>()
                    .<span class="hljs-built_in">uri</span>(<span class="hljs-string">"/users/{id}"</span>, id)
                    .<span class="hljs-built_in">retrieve</span>()
                    .<span class="hljs-built_in">body</span>(User.<span class="hljs-keyword">class</span>);
        } <span class="hljs-built_in">catch</span> (RestClientException e) {
            <span class="hljs-comment">// 处理错误</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserServiceException</span>(<span class="hljs-string">"Failed to fetch user"</span>, e);
        }
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162</span>
</code></pre>
<h3 data-id="heading-13"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>迁移策略</h3>
<h4 data-id="heading-14"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>阶段一：评估现有代码</h4>
<ol>
<li><strong>识别RestTemplate使用点</strong></li>
</ol>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 搜索项目中所有RestTemplate的使用</span>
<span class="hljs-keyword">grep</span> -r <span class="hljs-string">"RestTemplate"</span> src/

AI写代码bash
<span class="hljs-number">12</span>
</code></pre>
<ol start="2">
<li>
<p><strong>分类使用场景</strong></p>
<ul>
<li>同步调用 → RestClient</li>
<li>异步调用 → WebClient</li>
<li>批处理 → RestClient</li>
<li>流式处理 → WebClient</li>
</ul>
</li>
</ol>
<h4 data-id="heading-15"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>阶段二：渐进式迁移</h4>
<h5 data-id="heading-16"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>步骤1：添加新依赖</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 根据需要添加 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
12345
</code></pre>
<h5 data-id="heading-17"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>步骤2：创建适配器</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Primary</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">RestClient</span> <span class="hljs-title function_">restClient</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">RestClient</span>.<span class="hljs-title function_">builder</span>()
                .<span class="hljs-title function_">baseUrl</span>(<span class="hljs-string">"https://api.example.com"</span>)
                .<span class="hljs-title function_">build</span>();
    }
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">WebClient</span> <span class="hljs-title function_">webClient</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">WebClient</span>.<span class="hljs-title function_">builder</span>()
                .<span class="hljs-title function_">baseUrl</span>(<span class="hljs-string">"https://api.example.com"</span>)
                .<span class="hljs-title function_">build</span>();
    }
}

<span class="hljs-variable constant_">AI</span>写代码java
运行
<span class="hljs-number">123456789101112131415161718</span>
</code></pre>
<h5 data-id="heading-18"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>步骤3：逐个替换</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 旧代码</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestTemplate restTemplate = new RestTemplate();
    
    <span class="hljs-keyword">public</span> User getUser(String id) {
        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"/users/{id}"</span>, User.<span class="hljs-keyword">class</span>, id);
    }
}

<span class="hljs-comment">// 新代码</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    
    <span class="hljs-keyword">public</span> UserService(RestClient restClient) {
        <span class="hljs-keyword">this</span>.restClient = restClient;
    }
    
    <span class="hljs-keyword">public</span> User getUser(String id) {
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-keyword">get</span>()
                .uri(<span class="hljs-string">"/users/{id}"</span>, id)
                .retrieve()
                .body(User.<span class="hljs-keyword">class</span>);
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627</span>
</code></pre>
<h3 data-id="heading-19"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>高级特性对比</h3>





















































<table><thead><tr><th>特性</th><th>RestTemplate</th><th>RestClient</th><th>WebClient</th></tr></thead><tbody><tr><td>同步调用</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>异步调用</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>响应式支持</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>连接池</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>拦截器支持</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>错误处理</td><td>基础</td><td>改进</td><td>高级</td></tr><tr><td>性能</td><td>基础</td><td>良好</td><td>优秀</td></tr></tbody></table>
<h3 data-id="heading-20"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>最佳实践</h3>
<h4 data-id="heading-21"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1. 选择合适的客户端</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 同步场景使用RestClient</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    
    <span class="hljs-keyword">public</span> SyncService(RestClient restClient) {
        <span class="hljs-keyword">this</span>.restClient = restClient;
    }
}

<span class="hljs-comment">// 异步场景使用WebClient</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;
    
    <span class="hljs-keyword">public</span> AsyncService(WebClient webClient) {
        <span class="hljs-keyword">this</span>.webClient = webClient;
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819</span>
</code></pre>
<h4 data-id="heading-22"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2. 配置优化</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Configuration</span>
public class HttpClientConfig {
    
    <span class="hljs-keyword">@Bean</span>
    public RestClient optimizedRestClient() {
        return RestClient<span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.requestFactory</span>(HttpComponentsClientHttpRequestFactory.class)
                <span class="hljs-selector-class">.baseUrl</span>("https://api.example.com")
                <span class="hljs-selector-class">.defaultHeader</span>("User-Agent", "MyApp/<span class="hljs-number">1.0</span>")
                <span class="hljs-selector-class">.defaultHeader</span>("Accept", "application/json")
                <span class="hljs-selector-class">.build</span>();
    }
    
    <span class="hljs-keyword">@Bean</span>
    public WebClient optimizedWebClient() {
        HttpClient httpClient = HttpClient<span class="hljs-selector-class">.create</span>()
                <span class="hljs-selector-class">.responseTimeout</span>(Duration.ofSeconds(<span class="hljs-number">10</span>))
                <span class="hljs-selector-class">.option</span>(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);
        
        return WebClient<span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.clientConnector</span>(new ReactorClientHttpConnector(httpClient))
                <span class="hljs-selector-class">.baseUrl</span>("https://api.example.com")
                <span class="hljs-selector-class">.filter</span>(logRequest())
                <span class="hljs-selector-class">.filter</span>(logResponse())
                <span class="hljs-selector-class">.build</span>();
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627</span>
</code></pre>
<h4 data-id="heading-23"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3. 错误处理</h4>
<pre><code class="hljs language-vbscript" lang="vbscript">// RestClient错误处理
<span class="hljs-keyword">public</span> User getUserSafely(String id) {
    return restClient
            .<span class="hljs-keyword">get</span>()
            .uri(<span class="hljs-string">"/users/{id}"</span>, id)
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError, 
                     <span class="hljs-built_in">response</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ServerException(<span class="hljs-string">"Server error"</span>)))
            .onStatus(HttpStatus::is4xxClientError,
                     <span class="hljs-built_in">response</span> -&gt; <span class="hljs-built_in">response</span>.bodyToMono(ErrorResponse.<span class="hljs-keyword">class</span>)
                         .flatMap(<span class="hljs-keyword">error</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ClientException(<span class="hljs-keyword">error</span>))))
            .body(User.<span class="hljs-keyword">class</span>);
}

// WebClient错误处理
<span class="hljs-keyword">public</span> Mono&lt;User&gt; getUserReactive(String id) {
    return webClient
            .<span class="hljs-keyword">get</span>()
            .uri(<span class="hljs-string">"/users/{id}"</span>, id)
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError,
                     <span class="hljs-built_in">response</span> -&gt; <span class="hljs-built_in">response</span>.bodyToMono(ErrorResponse.<span class="hljs-keyword">class</span>)
                         .flatMap(<span class="hljs-keyword">error</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ServerException(<span class="hljs-keyword">error</span>))))
            .onStatus(HttpStatus::is4xxClientError,
                     <span class="hljs-built_in">response</span> -&gt; <span class="hljs-built_in">response</span>.bodyToMono(ErrorResponse.<span class="hljs-keyword">class</span>)
                         .flatMap(<span class="hljs-keyword">error</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ClientException(<span class="hljs-keyword">error</span>))))
            .bodyToMono(User.<span class="hljs-keyword">class</span>)
            .retryWhen(retrySpec())
            .onErrorResume(Exception.<span class="hljs-keyword">class</span>, 
                          <span class="hljs-keyword">error</span> -&gt; Mono.just(getDefaultUser()));
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031</span>
</code></pre>
<h3 data-id="heading-24"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>测试策略</h3>
<h4 data-id="heading-25"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>单元测试</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@ExtendWith</span>(MockitoExtension.class)
class UserServiceTest {
    
    <span class="hljs-keyword">@Mock</span>
    private RestClient restClient;
    
    <span class="hljs-keyword">@InjectMocks</span>
    private UserService userService;
    
    <span class="hljs-keyword">@Test</span>
    void shouldGetUserById() {
        <span class="hljs-comment">// Given</span>
        String userId = "<span class="hljs-number">123</span>";
        User expectedUser = new <span class="hljs-built_in">User</span>(userId, "John Doe");
        
        RestClient<span class="hljs-selector-class">.RequestHeadersUriSpec</span> requestSpec = Mockito<span class="hljs-selector-class">.mock</span>(RestClient.RequestHeadersUriSpec.class);
        RestClient<span class="hljs-selector-class">.ResponseSpec</span> responseSpec = Mockito<span class="hljs-selector-class">.mock</span>(RestClient.ResponseSpec.class);
        
        <span class="hljs-built_in">when</span>(restClient.get())<span class="hljs-selector-class">.thenReturn</span>(requestSpec);
        <span class="hljs-built_in">when</span>(requestSpec.uri("/users/{id}", userId))<span class="hljs-selector-class">.thenReturn</span>(requestSpec);
        <span class="hljs-built_in">when</span>(requestSpec.retrieve())<span class="hljs-selector-class">.thenReturn</span>(responseSpec);
        <span class="hljs-built_in">when</span>(responseSpec.body(User.class))<span class="hljs-selector-class">.thenReturn</span>(expectedUser);
        
        <span class="hljs-comment">// When</span>
        User actualUser = userService<span class="hljs-selector-class">.getUser</span>(userId);
        
        <span class="hljs-comment">// Then</span>
        <span class="hljs-built_in">assertEquals</span>(expectedUser, actualUser);
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627282930</span>
</code></pre>
<h4 data-id="heading-26"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>集成测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientIntegrationTest</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> TestRestTemplate testRestTemplate;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldCommunicateWithExternalService</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 使用真实的HTTP调用测试</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUser(<span class="hljs-string">"123"</span>);
        assertNotNull(user);
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516</span>
</code></pre>
<h3 data-id="heading-27"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>性能考虑</h3>
<h4 data-id="heading-28"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1. 连接池配置</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Configuration</span>
public class ConnectionPoolConfig {
    
    <span class="hljs-keyword">@Bean</span>
    public RestClient customRestClient() {
        SimpleClientHttpRequestFactory factory = new <span class="hljs-built_in">SimpleClientHttpRequestFactory</span>();
        factory<span class="hljs-selector-class">.setConnectTimeout</span>(<span class="hljs-number">5000</span>);
        factory<span class="hljs-selector-class">.setReadTimeout</span>(<span class="hljs-number">30000</span>);
        
        return RestClient<span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.requestFactory</span>(factory)
                <span class="hljs-selector-class">.baseUrl</span>("https://api.example.com")
                <span class="hljs-selector-class">.build</span>();
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415</span>
</code></pre>
<h4 data-id="heading-29"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2. WebClient连接池</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Bean</span>
public WebClient webClientWithPool() {
    HttpClient httpClient = HttpClient<span class="hljs-selector-class">.create</span>()
            <span class="hljs-selector-class">.option</span>(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>)
            <span class="hljs-selector-class">.responseTimeout</span>(Duration.ofSeconds(<span class="hljs-number">30</span>))
            <span class="hljs-selector-class">.doOnConnected</span>(conn -&gt; 
                conn.addHandlerLast(new ReadTimeoutHandler(<span class="hljs-number">30</span>))
                    <span class="hljs-selector-class">.addHandlerLast</span>(new WriteTimeoutHandler(<span class="hljs-number">30</span>)));
    
    ConnectionProvider provider = ConnectionProvider<span class="hljs-selector-class">.builder</span>("custom")
            <span class="hljs-selector-class">.maxConnections</span>(<span class="hljs-number">50</span>)
            <span class="hljs-selector-class">.maxIdleTime</span>(Duration.ofSeconds(<span class="hljs-number">20</span>))
            <span class="hljs-selector-class">.build</span>();
    
    return WebClient<span class="hljs-selector-class">.builder</span>()
            <span class="hljs-selector-class">.clientConnector</span>(new ReactorClientHttpConnector(provider, httpClient))
            <span class="hljs-selector-class">.build</span>();
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718</span>
</code></pre>
<h3 data-id="heading-30"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>常见问题与解决方案</h3>
<h4 data-id="heading-31"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>Q1: 如何处理大量并发请求？</h4>
<p><strong>A</strong>: 对于高并发场景，推荐使用WebClient，因为它支持响应式编程和非阻塞I/O。</p>
<h4 data-id="heading-32"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>Q2: 迁移成本太大，能否渐进式迁移？</h4>
<p><strong>A</strong>: 可以通过适配器模式逐步迁移，先在一个模块中试点，再推广到整个应用。</p>
<h4 data-id="heading-33"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>Q3: 如何保持向后兼容性？</h4>
<p><strong>A</strong>: 可以创建包装类，隐藏具体的HTTP客户端实现，便于后续更换。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientFacade</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;
    
    <span class="hljs-keyword">public</span> HttpClientFacade(RestClient restClient, WebClient webClient) {
        <span class="hljs-keyword">this</span>.restClient = restClient;
        <span class="hljs-keyword">this</span>.webClient = webClient;
    }
    
    <span class="hljs-comment">// 统一的同步接口</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; T callSync(String url, Class&lt;T&gt; responseType) {
        <span class="hljs-keyword">return</span> restClient.<span class="hljs-keyword">get</span>().uri(url).retrieve().body(responseType);
    }
    
    <span class="hljs-comment">// 统一的异步接口</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; Mono&lt;T&gt; callAsync(String url, Class&lt;T&gt; responseType) {
        <span class="hljs-keyword">return</span> webClient.<span class="hljs-keyword">get</span>().uri(url).retrieve().bodyToMono(responseType);
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021</span>
</code></pre>
<h3 data-id="heading-34"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>总结</h3>
<p>Spring Boot 4.0标志着HTTP客户端技术的重大进步。虽然RestTemplate的告别可能带来短期的迁移成本，但从长远来看：</p>
<ol>
<li><strong>性能提升</strong>：新的HTTP客户端提供更好的性能和资源利用率</li>
<li><strong>开发效率</strong>：函数式API和链式调用使代码更简洁</li>
<li><strong>未来兼容</strong>：拥抱响应式编程和现代Java生态</li>
</ol>
<p>建议开发团队：</p>
<ul>
<li>评估现有RestTemplate使用情况</li>
<li>制定渐进式迁移计划</li>
<li>培训团队掌握新的HTTP客户端API</li>
<li>在新项目中直接使用推荐的替代方案</li>
</ul>
<p>随着Spring生态系统的不断发展，掌握这些现代化的HTTP客户端技术将成为Java开发者的必备技能。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[双库协同，各取所长：.NET Core 中 PostgreSQL 与 SQLite 的优雅融合实战]]></title>    <link>https://juejin.cn/post/7603771025856479283</link>    <guid>https://juejin.cn/post/7603771025856479283</guid>    <pubDate>2026-02-08T06:12:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856479283" data-draft-id="7603651855236792329" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="双库协同，各取所长：.NET Core 中 PostgreSQL 与 SQLite 的优雅融合实战"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:12:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大黄评测"/> <meta itemprop="url" content="https://juejin.cn/user/714024404135696"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            双库协同，各取所长：.NET Core 中 PostgreSQL 与 SQLite 的优雅融合实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/714024404135696/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大黄评测
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:12:53.000Z" title="Sun Feb 08 2026 06:12:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代应用开发中，单一数据库架构往往难以满足所有场景需求。例如，你可能希望：</p>
<ul>
<li><strong>主业务数据</strong>存入功能强大、支持高并发的 <strong>PostgreSQL</strong>；</li>
<li><strong>本地缓存、边缘计算或嵌入式日志</strong>使用轻量、零配置的 <strong>SQLite</strong>。</li>
</ul>
<p>这种“混合持久化”（Polyglot Persistence）策略正变得越来越普遍。而 .NET Core 凭借其强大的依赖注入（DI）体系和 Entity Framework Core（EF Core）的多上下文支持，为双数据库架构提供了优雅的实现路径。</p>
<p>本文将手把手带你构建一个同时使用 <strong>PostgreSQL（主库）</strong> 和 <strong>SQLite（辅助库）</strong> 的 .NET Core 应用，并分享生产级的最佳实践。</p>
<hr/>
<h3 data-id="heading-0">一、为什么选择 PostgreSQL + SQLite？</h3>






























<table><thead><tr><th>场景</th><th>PostgreSQL</th><th>SQLite</th></tr></thead><tbody><tr><td><strong>数据规模</strong></td><td>TB 级，多用户并发</td><td>GB 级，单机/边缘</td></tr><tr><td><strong>部署复杂度</strong></td><td>需独立服务</td><td>零配置，文件即数据库</td></tr><tr><td><strong>事务与一致性</strong></td><td>完整 ACID，支持分布式事务</td><td>单文件 ACID，不支持并发写</td></tr><tr><td><strong>典型用途</strong></td><td>用户账户、订单、核心业务</td><td>本地缓存、设备日志、临时任务队列</td></tr></tbody></table>
<blockquote>
<p>✅ 组合优势：<br/>
主业务强一致 + 边缘数据轻量化 = 架构弹性与性能兼顾</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">二、项目结构设计</h3>
<p>我们将创建两个独立的 <code>DbContext</code>，分别对应不同数据库：</p>
<pre><code class="hljs language-arduino" lang="arduino">MyApp/
├── Data/
│   ├── MainDbContext.cs        <span class="hljs-comment">// PostgreSQL</span>
│   └── LocalDbContext.cs       <span class="hljs-comment">// SQLite</span>
├── Models/
│   ├── User.cs                 <span class="hljs-comment">// 存于 PostgreSQL</span>
│   └── DeviceLog.cs            <span class="hljs-comment">// 存于 SQLite</span>
├── Services/
│   ├── UserService.cs
│   └── LogService.cs
└── Program.cs
</code></pre>
<hr/>
<h3 data-id="heading-2">三、Step-by-Step 实现</h3>
<h4 data-id="heading-3">1. 安装必要 NuGet 包</h4>
<pre><code class="hljs language-csharp" lang="csharp">dotnet <span class="hljs-keyword">add</span> package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet <span class="hljs-keyword">add</span> package Microsoft.EntityFrameworkCore.Sqlite
</code></pre>
<blockquote>
<p>注意：不要混用同一个 DbContext 注册多个提供程序！</p>
</blockquote>
<h4 data-id="heading-4">2. 定义模型（Models）</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// Models/User.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>!;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Email { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>!;
}

<span class="hljs-comment">// Models/DeviceLog.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DeviceLog</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> DateTime Timestamp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>!;
}
</code></pre>
<h4 data-id="heading-5">3. 创建两个 DbContext</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// Data/MainDbContext.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainDbContext</span> : DbContext
{
    <span class="hljs-keyword">public</span> DbSet&lt;User&gt; Users { get; set; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainDbContext</span><span class="hljs-params">(DbContextOptions&lt;MainDbContext&gt; options)</span> : base(options) {</span> }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-type">void</span> <span class="hljs-title">OnModelCreating</span><span class="hljs-params">(ModelBuilder modelBuilder)</span>
    </span>{
        modelBuilder.<span class="hljs-built_in">Entity</span>&lt;User&gt;().<span class="hljs-built_in">ToTable</span>(<span class="hljs-string">"users"</span>);
    }
}

<span class="hljs-comment">// Data/LocalDbContext.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalDbContext</span> : DbContext
{
    <span class="hljs-keyword">public</span> DbSet&lt;DeviceLog&gt; DeviceLogs { get; set; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LocalDbContext</span><span class="hljs-params">(DbContextOptions&lt;LocalDbContext&gt; options)</span> : base(options) {</span> }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-type">void</span> <span class="hljs-title">OnConfiguring</span><span class="hljs-params">(DbContextOptionsBuilder optionsBuilder)</span>
    </span>{
        <span class="hljs-comment">// 可选：若未通过 DI 注入连接字符串</span>
        <span class="hljs-comment">// optionsBuilder.UseSqlite("Data Source=device_logs.db");</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-type">void</span> <span class="hljs-title">OnModelCreating</span><span class="hljs-params">(ModelBuilder modelBuilder)</span>
    </span>{
        modelBuilder.<span class="hljs-built_in">Entity</span>&lt;DeviceLog&gt;().<span class="hljs-built_in">ToTable</span>(<span class="hljs-string">"device_logs"</span>);
    }
}
</code></pre>
<h4 data-id="heading-6">4. 在 Program.cs 中注册双上下文</h4>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">builder</span> = WebApplication.CreateBuilder(args)<span class="hljs-comment">;</span>

// 注册 PostgreSQL 上下文
builder.Services.AddDbContext&lt;MainDbContext&gt;(<span class="hljs-attr">options</span> =&gt;
    options.UseNpgsql(builder.Configuration.GetConnectionString("Postgres")))<span class="hljs-comment">;</span>

// 注册 SQLite 上下文
builder.Services.AddDbContext&lt;LocalDbContext&gt;(<span class="hljs-attr">options</span> =&gt;
    options.UseSqlite(builder.Configuration.GetConnectionString("Sqlite")))<span class="hljs-comment">;</span>

// 自动创建数据库（仅开发环境建议）
using var <span class="hljs-attr">scope</span> = builder.Services.BuildServiceProvider().CreateScope()<span class="hljs-comment">;</span>
scope.ServiceProvider.GetRequiredService&lt;MainDbContext&gt;().Database.EnsureCreated()<span class="hljs-comment">;</span>
scope.ServiceProvider.GetRequiredService&lt;LocalDbContext&gt;().Database.EnsureCreated()<span class="hljs-comment">;</span>
</code></pre>
<p><code>appsettings.json</code> 配置：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ConnectionStrings"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"Postgres"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Host=localhost;Database=myapp;Username=postgres;Password=secret"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"Sqlite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Data Source=device_logs.db"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-7">5. 编写服务层，按需注入</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// Services/UserService.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MainDbContext _db;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">MainDbContext db</span>)</span> =&gt; _db = db;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;User&gt; <span class="hljs-title">CreateUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> email</span>)</span>
    {
        <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User { Name = name, Email = email };
        _db.Users.Add(user);
        <span class="hljs-keyword">await</span> _db.SaveChangesAsync();
        <span class="hljs-keyword">return</span> user;
    }
}

<span class="hljs-comment">// Services/LogService.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LogService</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> LocalDbContext _localDb;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogService</span>(<span class="hljs-params">LocalDbContext localDb</span>)</span> =&gt; _localDb = localDb;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">LogMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span>
    {
        _localDb.DeviceLogs.Add(<span class="hljs-keyword">new</span> DeviceLog
        {
            Timestamp = DateTime.UtcNow,
            Message = msg
        });
        <span class="hljs-keyword">await</span> _localDb.SaveChangesAsync();
    }
}
</code></pre>
<p>控制器中使用：</p>
<pre><code class="hljs language-dart" lang="dart">app.MapPost(<span class="hljs-string">"/user"</span>, <span class="hljs-keyword">async</span> (UserService userService, HttpRequest req) =&gt;
{
    <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">await</span> userService.CreateUser(<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"alice@example.com"</span>);
    <span class="hljs-keyword">return</span> Results.Ok(user);
});

app.MapPost(<span class="hljs-string">"/log"</span>, <span class="hljs-keyword">async</span> (LogService logService, [FromBody] string msg) =&gt;
{
    <span class="hljs-keyword">await</span> logService.LogMessage(msg);
    <span class="hljs-keyword">return</span> Results.Ok();
});
</code></pre>
<hr/>
<h3 data-id="heading-8">四、最佳实践与避坑指南</h3>
<h4 data-id="heading-9">✅ 1. <strong>严格分离关注点</strong></h4>
<ul>
<li>不要在同一个业务方法中同时操作两个 DbContext（除非必要）；</li>
<li>若需跨库事务，考虑最终一致性（如通过消息队列补偿）。</li>
</ul>
<h4 data-id="heading-10">✅ 2. <strong>连接字符串安全</strong></h4>
<ul>
<li>PostgreSQL 密码勿硬编码，使用 Secret Manager 或 Azure Key Vault；</li>
<li>SQLite 路径建议使用 <code>Path.Combine(Directory.GetCurrentDirectory(), "data", "logs.db")</code> 确保可移植性。</li>
</ul>
<h4 data-id="heading-11">✅ 3. <strong>迁移（Migrations）管理</strong></h4>
<ul>
<li>
<p>为每个 DbContext 单独启用迁移：</p>
<pre><code class="hljs language-csharp" lang="csharp">dotnet ef migrations <span class="hljs-keyword">add</span> InitialMain -c MainDbContext -o Migrations/Postgres
dotnet ef migrations <span class="hljs-keyword">add</span> InitialLocal -c LocalDbContext -o Migrations/Sqlite
</code></pre>
</li>
<li>
<p>生产环境建议手动审核 SQL 脚本。</p>
</li>
</ul>
<h4 data-id="heading-12">✅ 4. <strong>性能与资源</strong></h4>
<ul>
<li>SQLite 默认不支持高并发写入，避免在 Web API 热点路径频繁写日志；</li>
<li>可搭配 <code>Microsoft.Data.Sqlite</code> 的 WAL 模式提升并发读性能。</li>
</ul>
<hr/>
<h3 data-id="heading-13">五、适用场景推荐</h3>
<ul>
<li>📱 <strong>IoT 边缘设备 + 云中心</strong>：设备用 SQLite 记录本地状态，定期同步到云端 PostgreSQL；</li>
<li>🖥️ <strong>桌面应用</strong>：配置、缓存用 SQLite，用户数据同步到 PostgreSQL；</li>
<li>🧪 <strong>测试隔离</strong>：集成测试时用 SQLite 替代 PostgreSQL，加速执行。</li>
</ul>
<hr/>
<h3 data-id="heading-14">结语</h3>
<p>在 .NET Core 中融合 PostgreSQL 与 SQLite，并非“炫技”，而是对<strong>场景适配性</strong>的理性选择。通过清晰的架构分层、独立的 DbContext 设计和合理的服务注入，我们既能享受 PostgreSQL 的企业级能力，又能利用 SQLite 的极致轻量。</p>
<p>双库协同，不是妥协，而是智慧——让每一份数据，都落在最适合它的土壤上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【JAVA 进阶】Spring AOP核心原理：JDK与CGLib动态代理实战解析]]></title>    <link>https://juejin.cn/post/7603674653153755145</link>    <guid>https://juejin.cn/post/7603674653153755145</guid>    <pubDate>2026-02-08T06:25:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153755145" data-draft-id="7603651855236841481" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【JAVA 进阶】Spring AOP核心原理：JDK与CGLib动态代理实战解析"/> <meta itemprop="keywords" content="后端,Spring"/> <meta itemprop="datePublished" content="2026-02-08T06:25:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【JAVA 进阶】Spring AOP核心原理：JDK与CGLib动态代理实战解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:25:23.000Z" title="Sun Feb 08 2026 06:25:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读26分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在[Spring框架]的核心特性中，AOP（面向切面编程）无疑是与IOC（控制反转）并驾齐驱的灵魂技术。它通过"横切"的方式，将日志记录、事务管理、权限控制等分散在业务逻辑中的通用功能抽取出来，形成独立的切面，实现了"业务功能"与"通用功能"的解耦，极大提升了代码的复用性和可维护性。而支撑Spring AOP实现的核心技术，正是动态代理——其中JDK动态代理与CGLib动态代理更是重中之重。本文将从AOP的基础概念出发，层层深入剖析这两种动态代理的实现原理、代码细节及适用场景，最终梳理Spring AOP的整体执行逻辑，为开发者提供一份全面且实用的技术指南。</p>
<h2 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第一章 夯实基础：走进Spring AOP的世界</h2>
<h3 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.1 为什么需要AOP？—— 从代码痛点说起</h3>
<p>在传统的OOP（面向对象编程）开发中，我们习惯于将功能封装在类和对象中，通过继承和多态实现代码复用。但在实际业务场景中，会存在一些"跨界"的通用功能，例如：</p>
<ul>
<li>接口调用前后的日志记录，需要在每个接口实现中重复编写日志输出代码；</li>
<li>数据库操作的事务管理，需在增删改方法前后手动开启、提交或回滚事务；</li>
<li>接口访问的权限校验，要在每个业务方法开头判断用户权限是否合法。</li>
</ul>
<p>这些代码与核心业务逻辑无关，却分散在各个业务类中，导致代码冗余、维护成本高——修改日志格式需要改动所有日志相关代码，调整事务隔离级别则要遍历所有事务方法。AOP的出现正是为了解决这一问题，它将这些通用功能抽象为"切面"，在不修改业务代码的前提下，通过"织入"机制将切面与业务逻辑结合，实现通用功能的统一管理。</p>
<h3 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2 AOP核心概念：读懂切面的"语言体系"</h3>
<p>要理解Spring AOP的实现原理，首先需要掌握其核心概念，这些概念共同构成了AOP的"语言体系"，也是后续理解动态代理的基础：</p>
<h4 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.1 切面（Aspect）</h4>
<p>切面是AOP的核心载体，它封装了需要横切到业务逻辑中的通用功能，例如"日志切面"、“事务切面”。在Spring中，切面通常是一个带有@Aspect注解的类，其中包含了通知和切入点的定义。</p>
<h4 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.2 通知（Advice）</h4>
<p>通知定义了切面的具体执行逻辑和执行时机，即"在什么时候做什么事"。Spring支持5种类型的通知：</p>
<ul>
<li>前置通知（Before）：在目标方法执行前执行；</li>
<li>后置通知（After）：在目标方法执行后执行，无论方法是否抛出异常；</li>
<li>返回通知（AfterReturning）：在目标方法正常返回后执行；</li>
<li>异常通知（AfterThrowing）：在目标方法抛出异常后执行；</li>
<li>环绕通知（Around）：包裹目标方法，可在方法执行前后自定义逻辑，甚至控制方法是否执行。</li>
</ul>
<h4 data-id="heading-6"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.3 切入点（Pointcut）</h4>
<p>切入点定义了切面的"作用范围"，即"对哪些方法生效"。它通过切入点表达式（如execution表达式）指定目标方法，例如"所有com.example.service包下以find开头的public方法"。切入点是连接切面与目标对象的桥梁，只有匹配切入点的方法才会被织入通知逻辑。</p>
<h4 data-id="heading-7"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.4 目标对象（Target）</h4>
<p>目标对象即被切面织入的业务对象，也就是包含核心业务逻辑的对象，例如UserService、OrderService等。</p>
<h4 data-id="heading-8"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.5 代理对象（Proxy）</h4>
<p>代理对象是Spring AOP实现的关键——Spring不会直接修改目标对象的代码，而是通过动态代理技术为目标对象创建一个代理对象。当客户端调用目标方法时，实际上是调用代理对象的方法，代理对象会在合适的时机执行切面的通知逻辑，再调用目标对象的原始方法。</p>
<h4 data-id="heading-9"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.6 织入（Weaving）</h4>
<p>织入是将切面的通知逻辑融入到目标对象业务方法中的过程。根据织入时机的不同，可分为编译期织入（如AspectJ）、类加载期织入和运行期织入——Spring AOP采用的是运行期织入，通过动态代理在程序运行时动态生成代理对象，完成通知与目标方法的结合。</p>
<h3 data-id="heading-10"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.3 Spring AOP的核心逻辑：代理对象的"桥梁作用"</h3>
<p>Spring AOP的核心逻辑可概括为"代理介导"：客户端请求目标对象时，Spring的IOC容器返回的不是目标对象本身，而是其代理对象；客户端调用代理对象的方法时，代理对象先执行切面的通知逻辑（如日志记录、权限校验），再调用目标对象的原始方法；方法执行完成后，代理对象还会执行后续的通知逻辑（如事务提交、返回值处理）。整个过程中，客户端无需感知代理对象的存在，目标对象的业务代码也无需修改，从而实现了通用功能与业务逻辑的解耦。</p>
<h2 data-id="heading-11"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第二章 深度解析：JDK动态代理的实现原理</h2>
<p>JDK动态代理是Spring AOP默认使用的代理方式，它基于Java的反射机制实现，核心依赖java.lang.reflect包下的Proxy类和InvocationHandler接口。需要注意的是，JDK动态代理有一个重要限制：<strong>只能为实现了接口的目标对象创建代理对象</strong>，这是由其底层实现机制决定的。</p>
<h3 data-id="heading-12"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.1 JDK动态代理核心组件</h3>
<p>要理解JDK动态代理，首先需要掌握其两个核心组件的作用，它们共同支撑起代理对象的创建和逻辑执行：</p>
<h4 data-id="heading-13"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.1.1 InvocationHandler接口</h4>
<p>InvocationHandler是一个函数式接口，仅包含一个invoke方法，它是代理对象的"逻辑处理器"——当客户端调用代理对象的方法时，最终都会委托给该接口的invoke方法执行。其定义如下：</p>
<pre><code class="hljs language-typescript" lang="typescript">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> {
    <span class="hljs-comment">/**
     * 代理对象方法调用的核心处理方法
     * <span class="hljs-doctag">@param</span> proxy 代理对象本身
     * <span class="hljs-doctag">@param</span> method 被调用的目标方法
     * <span class="hljs-doctag">@param</span> args 目标方法的参数数组
     * <span class="hljs-doctag">@return</span> 目标方法的返回值
     * <span class="hljs-doctag">@throws</span> Throwable 目标方法可能抛出的异常
     */</span>
    <span class="hljs-title class_">Object</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">Object</span> proxy, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>[] args) throws <span class="hljs-title class_">Throwable</span>;
}

<span class="hljs-variable constant_">AI</span>写代码java
运行
<span class="hljs-number">123456789101112</span>
</code></pre>
<p>invoke方法的三个参数含义明确：proxy是动态生成的代理对象；method是客户端调用的目标方法实例，通过它可以反射调用目标对象的方法；args是客户端传递给目标方法的参数。开发者需要在invoke方法中实现"通知逻辑+目标方法调用"的组合逻辑。</p>
<h4 data-id="heading-14"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.1.2 Proxy类</h4>
<p>Proxy类是JDK动态代理的"代理工厂"，它提供了静态方法newProxyInstance用于创建代理对象。该方法是JDK动态代理的入口，其定义如下：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,
                                     Class&lt;?&gt;[] interfaces,
                                     InvocationHandler h)</span>
    <span class="hljs-keyword">throws</span> IllegalArgumentException

AI写代码java
运行
<span class="hljs-number">12345</span>
</code></pre>
<p>三个参数的作用至关重要，直接决定了代理对象的生成：</p>
<ul>
<li>loader：类加载器，用于加载代理对象的字节码，通常使用目标对象的类加载器；</li>
<li>interfaces：目标对象实现的所有接口数组，JDK动态代理会让代理对象实现这些接口，从而保证代理对象与目标对象的接口一致性；</li>
<li>h：InvocationHandler实例，代理对象的方法调用会委托给该实例的invoke方法。</li>
</ul>
<h3 data-id="heading-15"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2 JDK动态代理实战：手写一个日志代理</h3>
<p>理论结合实践是理解技术的最佳方式，下面我们通过一个"日志切面"的案例，手写JDK动态代理的完整实现，直观感受其工作流程。</p>
<h4 data-id="heading-16"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.1 步骤1：定义目标接口与目标对象</h4>
<p>由于JDK动态代理依赖接口，首先定义一个业务接口UserService，包含用户查询和新增两个方法，再创建其实现类UserServiceImpl作为目标对象：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">
<span class="hljs-comment">// 目标接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-comment">// 查询用户</span>
    User findUserById(<span class="hljs-built_in">Long</span> id);
    <span class="hljs-comment">// 新增用户</span>
    void addUser(User user);
}

<span class="hljs-comment">// 目标对象（业务实现类）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">UserService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> User findUserById(<span class="hljs-built_in">Long</span> id) {
        <span class="hljs-comment">// 模拟数据库查询</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库查询：根据ID="</span> + id + <span class="hljs-string">"查询用户"</span>);
        <span class="hljs-keyword">return</span> new User(id, <span class="hljs-string">"张三"</span>, <span class="hljs-number">25</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> void addUser(User user) {
        <span class="hljs-comment">// 模拟数据库新增</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库新增：添加用户"</span> + user.getName());
    }
}

<span class="hljs-comment">// 实体类User</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;

    <span class="hljs-comment">// 构造方法、getter、setter省略</span>
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627282930313233</span>
</code></pre>
<h4 data-id="heading-17"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.2 步骤2：实现InvocationHandler接口——定义切面逻辑</h4>
<p>创建LogInvocationHandler类实现InvocationHandler接口，在invoke方法中实现"前置日志+目标方法调用+后置日志"的逻辑，这就是我们的"日志切面"：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> {
    <span class="hljs-comment">// 目标对象（被代理的业务对象）</span>
    <span class="hljs-keyword">private</span> Object target;

    <span class="hljs-comment">// 构造方法注入目标对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogInvocationHandler</span><span class="hljs-params">(Object target)</span> {
        <span class="hljs-built_in">this</span>.target = target;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 1. 前置通知：日志记录（方法调用时间、方法名）</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();
        System.out.println(<span class="hljs-string">"【日志前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);

        <span class="hljs-comment">// 2. 调用目标对象的原始方法</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            result = method.invoke(target, args);
            <span class="hljs-comment">// 3. 返回通知：记录方法返回值</span>
            System.out.println(<span class="hljs-string">"【日志返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result.toString()));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 4. 异常通知：记录方法异常信息</span>
            System.out.println(<span class="hljs-string">"【日志异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// 抛出异常，不影响业务逻辑</span>
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 5. 后置通知：记录方法调用结束</span>
            System.out.println(<span class="hljs-string">"【日志后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束\n"</span>);
        }

        <span class="hljs-keyword">return</span> result;
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738</span>
</code></pre>
<h4 data-id="heading-18"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.3 步骤3：使用Proxy创建代理对象并测试</h4>
<p>创建测试类，通过Proxy.newProxyInstance方法生成代理对象，然后调用代理对象的方法，观察日志切面是否生效：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkProxyTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 1. 创建目标对象</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();

        <span class="hljs-comment">// 2. 创建InvocationHandler实例（传入目标对象）</span>
        <span class="hljs-type">LogInvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInvocationHandler</span>(target);

        <span class="hljs-comment">// 3. 生成代理对象：参数分别为目标类加载器、目标接口数组、InvocationHandler</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                invocationHandler
        );

        <span class="hljs-comment">// 4. 调用代理对象的方法</span>
        proxy.findUserById(<span class="hljs-number">1L</span>);
        proxy.addUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2L</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-number">30</span>));
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223</span>
</code></pre>
<h4 data-id="heading-19"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.4 测试结果与分析</h4>
<p>运行测试类，输出结果如下：</p>
<pre><code class="hljs language-ini" lang="ini">
【日志前置通知】2025-12-05T15:30:00 调用方法：findUserById
执行数据库查询：根据<span class="hljs-attr">ID</span>=<span class="hljs-number">1</span>查询用户
【日志返回通知】方法findUserById返回值：User(<span class="hljs-attr">id</span>=<span class="hljs-number">1</span>, name=张三, age=<span class="hljs-number">25</span>)
【日志后置通知】方法findUserById调用结束

【日志前置通知】2025-12-05T15:30:00 调用方法：addUser
执行数据库新增：添加用户李四
【日志返回通知】方法addUser返回值：无
【日志后置通知】方法addUser调用结束

AI写代码text
12345678910
</code></pre>
<p>从结果可以看出，代理对象成功将日志通知逻辑与业务方法结合：调用findUserById和addUser方法时，均先执行前置日志，再执行核心业务逻辑，最后执行返回通知和后置通知。这正是JDK动态代理的核心作用——通过代理对象介导，实现切面逻辑与业务逻辑的解耦。</p>
<h3 data-id="heading-20"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.3 JDK动态代理底层机制：代理类是如何生成的？</h3>
<p>很多开发者会好奇：Proxy.newProxyInstance方法调用后，代理对象的字节码是如何生成的？其实，JDK动态代理的底层是通过"动态生成字节码文件"并加载到JVM中实现的，具体流程如下：</p>
<ol>
<li><strong>生成代理类的字节码</strong>：Proxy类根据传入的interfaces参数，动态生成一个实现了这些接口的代理类字节码，该类继承自java.lang.reflect.Proxy类（这也是JDK动态代理不能代理类的原因——Java单继承机制）；</li>
<li><strong>为代理类生成方法</strong>：代理类会为每个接口方法生成对应的实现方法，这些方法的逻辑非常简单——直接调用InvocationHandler的invoke方法；</li>
<li><strong>加载代理类字节码</strong>：通过传入的类加载器（loader参数）将生成的代理类字节码加载到JVM中，生成Class对象；</li>
<li><strong>创建代理对象实例</strong>：通过反射调用代理类的构造方法（该构造方法接收InvocationHandler参数），创建代理对象并返回。</li>
</ol>
<p>我们可以通过设置系统属性，将JDK动态生成的代理类字节码保存到本地，以便直观查看。在测试类的main方法开头添加如下代码：</p>
<pre><code class="hljs language-arduino" lang="arduino">
<span class="hljs-comment">// 保存JDK动态生成的代理类字节码到本地</span>
System.<span class="hljs-built_in">getProperties</span>().<span class="hljs-built_in">put</span>(<span class="hljs-string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="hljs-string">"true"</span>);

AI写代码java
运行
<span class="hljs-number">123</span>
</code></pre>
<p>运行后，会在项目根目录下生成com/sun/proxy/$Proxy0.class文件，反编译后可以看到代理类的核心结构（简化后）：</p>
<pre><code class="hljs language-scala" lang="scala">
public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">$Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-title">implements</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-comment">// 静态代码块：获取目标接口的方法实例</span>
    static {
        <span class="hljs-keyword">try</span> {
            m1 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"equals"</span>, <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Object"</span>));
            m2 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"toString"</span>);
            m3 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"com.example.service.UserService"</span>).getMethod(<span class="hljs-string">"findUserById"</span>, <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Long"</span>));
            m4 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"com.example.service.UserService"</span>).getMethod(<span class="hljs-string">"addUser"</span>, <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"com.example.entity.User"</span>));
            <span class="hljs-comment">// ...省略其他方法</span>
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">NoSuchMethodException</span> e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NoSuchMethodError</span>(e.getMessage());
        }
    }

    <span class="hljs-comment">// 构造方法：接收InvocationHandler参数并传给父类Proxy</span>
    public $<span class="hljs-type">Proxy0</span>(<span class="hljs-type">InvocationHandler</span> var1) <span class="hljs-keyword">throws</span>  {
        <span class="hljs-keyword">super</span>(var1);
    }

    <span class="hljs-comment">// 实现UserService的findUserById方法</span>
    public <span class="hljs-keyword">final</span> <span class="hljs-type">User</span> findUserById(<span class="hljs-type">Long</span> var1) <span class="hljs-keyword">throws</span>  {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 调用InvocationHandler的invoke方法</span>
            <span class="hljs-keyword">return</span> (<span class="hljs-type">User</span>)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[]{var1});
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">RuntimeException</span> | <span class="hljs-type">Error</span> var3) {
            <span class="hljs-keyword">throw</span> var3;
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">Throwable</span> var4) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UndeclaredThrowableException</span>(var4);
        }
    }

    <span class="hljs-comment">// 实现UserService的addUser方法</span>
    public <span class="hljs-keyword">final</span> void addUser(<span class="hljs-type">User</span> var1) <span class="hljs-keyword">throws</span>  {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 调用InvocationHandler的invoke方法</span>
            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m4, <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[]{var1});
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">RuntimeException</span> | <span class="hljs-type">Error</span> var3) {
            <span class="hljs-keyword">throw</span> var3;
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">Throwable</span> var4) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UndeclaredThrowableException</span>(var4);
        }
    }
}

<span class="hljs-type">AI</span>写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span>
</code></pre>
<p>反编译后的代码清晰地展示了代理类的结构：它继承自Proxy类，实现了UserService接口，每个接口方法的实现都委托给了InvocationHandler的invoke方法。这也就解释了为什么调用代理对象的方法会触发invoke方法的执行——代理类的方法逻辑就是如此设计的。</p>
<h2 data-id="heading-21"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第三章 另辟蹊径：CGLib动态代理的实现原理</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01d95c8e5f27489d8ca89547f47d62b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136723&amp;x-signature=JpGLTnGUz7AmkaAoiaQ1yIxJz0Q%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>上一章我们提到，JDK动态代理只能为实现了接口的目标对象创建代理，这在实际开发中存在局限性——如果某个业务类没有实现任何接口（如遗留系统中的类），JDK动态代理就无法满足需求。此时，CGLib动态代理便成为了Spring AOP的补充方案。CGLib（Code Generation Library）是一个基于ASM字节码操作框架的代码生成类库，它通过"继承目标类"的方式创建代理对象，无需目标类实现接口。</p>
<h3 data-id="heading-22"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.1 CGLib动态代理核心原理：基于继承的代理</h3>
<p>CGLib动态代理的核心思想是"继承目标类，重写目标方法"：</p>
<ol>
<li>CGLib通过ASM框架动态生成目标类的子类，该子类就是代理类；</li>
<li>代理类重写目标类中的非final方法，在重写的方法中实现"通知逻辑+目标方法调用"；</li>
<li>客户端调用代理对象的方法时，实际上是调用代理类重写后的方法，从而触发通知逻辑和目标方法的执行。</li>
</ol>
<p>需要注意的是，CGLib无法代理final类和final方法——因为final类不能被继承，final方法不能被重写，这是CGLib的核心限制。</p>
<h3 data-id="heading-23"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.2 CGLib动态代理核心组件</h3>
<p>CGLib动态代理的核心组件主要有两个：MethodInterceptor接口和Enhancer类，它们的作用与JDK动态代理的InvocationHandler和Proxy类类似。</p>
<h4 data-id="heading-24"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.2.1 MethodInterceptor接口</h4>
<p>MethodInterceptor是CGLib的"方法拦截器"，类似于JDK动态代理的InvocationHandler，它定义了代理对象方法调用的核心处理逻辑。该接口仅包含一个intercept方法：</p>
<pre><code class="hljs language-typescript" lang="typescript">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callback</span> {
    <span class="hljs-comment">/**
     * 代理对象方法调用的核心处理方法
     * <span class="hljs-doctag">@param</span> obj 代理对象
     * <span class="hljs-doctag">@param</span> method 被调用的目标方法
     * <span class="hljs-doctag">@param</span> args 目标方法的参数数组
     * <span class="hljs-doctag">@param</span> proxy MethodProxy对象，用于调用目标方法（比反射更高效）
     * <span class="hljs-doctag">@return</span> 目标方法的返回值
     * <span class="hljs-doctag">@throws</span> Throwable 目标方法可能抛出的异常
     */</span>
    <span class="hljs-title class_">Object</span> <span class="hljs-title function_">intercept</span>(<span class="hljs-title class_">Object</span> obj, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>[] args, <span class="hljs-title class_">MethodProxy</span> proxy) throws <span class="hljs-title class_">Throwable</span>;
}

<span class="hljs-variable constant_">AI</span>写代码java
运行
<span class="hljs-number">12345678910111213</span>
</code></pre>
<p>与invoke方法相比，intercept方法多了一个MethodProxy参数，它是CGLib提供的用于调用目标方法的工具类，其效率比通过反射调用Method对象更高——因为MethodProxy会生成目标方法的快速调用代码，避免了反射的性能开销。</p>
<h4 data-id="heading-25"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.2.2 Enhancer类</h4>
<p>Enhancer是CGLib的"代理生成器"，类似于JDK动态代理的Proxy类，它负责动态生成目标类的子类（代理类）并创建代理对象。Enhancer的核心方法包括setSuperclass（设置目标类，即代理类的父类）、setCallback（设置方法拦截器）、create（生成并返回代理对象）。</p>
<h3 data-id="heading-26"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3 CGLib动态代理实战：为无接口类创建日志代理</h3>
<p>下面我们以一个<strong>无接口的业务类</strong>为例，实现CGLib动态代理的日志切面，对比与JDK动态代理的差异。</p>
<h4 data-id="heading-27"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.1 步骤1：引入CGLib依赖</h4>
<p>Spring Boot项目中已默认引入CGLib依赖（通过spring-core间接依赖），非Spring项目需手动引入：</p>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
123456
</code></pre>
<h4 data-id="heading-28"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.2 步骤2：定义无接口的目标对象</h4>
<p>创建一个未实现任何接口的业务类OrderService，作为CGLib的代理目标：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">
<span class="hljs-comment">// 无接口的目标对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-comment">// 订单查询方法</span>
    <span class="hljs-keyword">public</span> Order findOrderById(<span class="hljs-built_in">Long</span> id) {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库查询：根据ID="</span> + id + <span class="hljs-string">"查询订单"</span>);
        <span class="hljs-keyword">return</span> new Order(id, <span class="hljs-string">"20251205001"</span>, <span class="hljs-number">199.9</span>);
    }

    <span class="hljs-comment">// 订单创建方法</span>
    <span class="hljs-keyword">public</span> void createOrder(Order order) {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库新增：创建订单"</span> + order.getOrderNo());
        <span class="hljs-comment">// 模拟异常场景</span>
        <span class="hljs-comment">// if (order.getAmount() &lt; 0) {</span>
        <span class="hljs-comment">//     throw new IllegalArgumentException("订单金额不能为负数");</span>
        <span class="hljs-comment">// }</span>
    }
}

<span class="hljs-comment">// 实体类Order</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;
    <span class="hljs-keyword">private</span> String orderNo;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Double</span> amount;

    <span class="hljs-comment">// 构造方法、getter、setter省略</span>
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627</span>
</code></pre>
<h4 data-id="heading-29"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.3 步骤3：实现MethodInterceptor接口——定义日志拦截逻辑</h4>
<p>创建LogMethodInterceptor类实现MethodInterceptor接口，在intercept方法中实现日志通知逻辑：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 1. 前置通知：日志记录</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();
        System.out.println(<span class="hljs-string">"【CGLib日志前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);

        <span class="hljs-comment">// 2. 调用目标对象的原始方法（通过MethodProxy调用，效率更高）</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            result = proxy.invokeSuper(obj, args); <span class="hljs-comment">// 注意：此处是invokeSuper，调用父类（目标类）的方法</span>
            <span class="hljs-comment">// 3. 返回通知</span>
            System.out.println(<span class="hljs-string">"【CGLib日志返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result.toString()));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 4. 异常通知</span>
            System.out.println(<span class="hljs-string">"【CGLib日志异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e;
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 5. 后置通知</span>
            System.out.println(<span class="hljs-string">"【CGLib日志后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束\n"</span>);
        }

        <span class="hljs-keyword">return</span> result;
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031</span>
</code></pre>
<p>需要特别注意的是，调用目标方法时使用的是MethodProxy的invokeSuper方法，而非invoke方法：</p>
<ul>
<li>invokeSuper(obj, args)：调用代理对象的父类（即目标类）的对应方法，这是CGLib调用目标方法的正确方式；</li>
<li>invoke(obj, args)：会再次触发intercept方法，导致无限循环，开发中需避免。</li>
</ul>
<h4 data-id="heading-30"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.4 步骤4：使用Enhancer创建代理对象并测试</h4>
<p>创建测试类，通过Enhancer生成代理对象并调用方法：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 1. 创建目标对象</span>
        <span class="hljs-type">OrderService</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderService</span>();

        <span class="hljs-comment">// 2. 创建方法拦截器实例</span>
        <span class="hljs-type">LogMethodInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogMethodInterceptor</span>();

        <span class="hljs-comment">// 3. 创建Enhancer对象（代理生成器）</span>
        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();
        <span class="hljs-comment">// 设置目标类为父类（代理类继承自目标类）</span>
        enhancer.setSuperclass(OrderService.class);
        <span class="hljs-comment">// 设置方法拦截器（代理类的方法调用会委托给该拦截器）</span>
        enhancer.setCallback(interceptor);

        <span class="hljs-comment">// 4. 生成代理对象（通过create方法）</span>
        <span class="hljs-type">OrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (OrderService) enhancer.create();

        <span class="hljs-comment">// 5. 调用代理对象的方法</span>
        proxy.findOrderById(<span class="hljs-number">1L</span>);
        proxy.createOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-number">2L</span>, <span class="hljs-string">"20251205002"</span>, <span class="hljs-number">299.9</span>));

        <span class="hljs-comment">// 测试异常场景（解开OrderService中createOrder的异常注释）</span>
        <span class="hljs-comment">// proxy.createOrder(new Order(3L, "20251205003", -50.0));</span>
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829</span>
</code></pre>
<h4 data-id="heading-31"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.5 测试结果与分析</h4>
<p>运行测试类，输出结果如下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">
【<span class="hljs-built_in">CGLib</span>日志前置通知】<span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-05</span>T16:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 调用方法：findOrderById
执行数据库查询：根据ID=<span class="hljs-number">1</span>查询订单
【<span class="hljs-built_in">CGLib</span>日志返回通知】方法findOrderById返回值：Order(<span class="hljs-type">id</span>=<span class="hljs-number">1</span>, orderNo=<span class="hljs-number">20251205001</span>, amount=<span class="hljs-number">199.9</span>)
【<span class="hljs-built_in">CGLib</span>日志后置通知】方法findOrderById调用结束

【<span class="hljs-built_in">CGLib</span>日志前置通知】<span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-05</span>T16:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 调用方法：createOrder
执行数据库新增：创建订单<span class="hljs-number">20251205002</span>
【<span class="hljs-built_in">CGLib</span>日志返回通知】方法createOrder返回值：无
【<span class="hljs-built_in">CGLib</span>日志后置通知】方法createOrder调用结束

AI写代码text
<span class="hljs-number">12345678910</span>
</code></pre>
<p>结果表明，CGLib成功为无接口的OrderService创建了代理对象，日志通知逻辑与业务逻辑完美结合。若解开OrderService中createOrder方法的异常注释，调用时会触发异常通知，输出如下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">
【<span class="hljs-built_in">CGLib</span>日志前置通知】<span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-05</span>T16:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 调用方法：createOrder
执行数据库新增：创建订单<span class="hljs-number">20251205003</span>
【<span class="hljs-built_in">CGLib</span>日志异常通知】方法createOrder抛出异常：订单金额不能为负数
【<span class="hljs-built_in">CGLib</span>日志后置通知】方法createOrder调用结束

Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.IllegalArgumentException: 订单金额不能为负数
    ...省略堆栈信息

AI写代码text
<span class="hljs-number">12345678</span>
</code></pre>
<p>这说明CGLib的异常处理逻辑同样生效，与JDK动态代理的通知类型覆盖能力一致。</p>
<h3 data-id="heading-32"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.4 CGLib动态代理底层机制：代理类的生成过程</h3>
<p>与JDK动态代理类似，CGLib也是通过动态生成字节码文件来创建代理类的，但其生成逻辑基于ASM框架，直接操作字节码，过程更为复杂，核心流程如下：</p>
<ol>
<li><strong>确定代理类的父类</strong>：Enhancer根据setSuperclass方法传入的目标类，确定代理类的父类；</li>
<li><strong>生成代理类字节码</strong>：通过ASM框架生成代理类的字节码，代理类继承自目标类，并重写目标类的非final方法；</li>
<li><strong>注入拦截逻辑</strong>：在代理类重写的方法中，注入方法拦截逻辑——调用MethodInterceptor的intercept方法；</li>
<li><strong>生成MethodProxy</strong>：为每个重写的方法生成对应的MethodProxy对象，用于高效调用目标方法；</li>
<li><strong>创建代理对象</strong>：通过Enhancer的create方法，将生成的代理类字节码加载到JVM中，创建代理对象并返回。</li>
</ol>
<p>我们可以通过设置系统属性，将CGLib生成的代理类字节码保存到本地。在测试类main方法开头添加如下代码：</p>
<pre><code class="hljs language-arduino" lang="arduino">
<span class="hljs-comment">// 保存CGLib生成的代理类字节码到本地</span>
System.<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">"cglib.debugLocation"</span>, <span class="hljs-string">"D:/cglib_proxy"</span>);
System.<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">"cglib.generateSpringCglibProxyClass"</span>, <span class="hljs-string">"true"</span>);

AI写代码java
运行
<span class="hljs-number">1234</span>
</code></pre>
<p>运行后，会在D:/cglib_proxy目录下生成多个class文件，其中OrderServiceE n h a n c e r B y C G L I B EnhancerByCGLIBEnhancerByCGLIBxxxx.class就是代理类，反编译后可看到其核心结构（简化后）：</p>
<pre><code class="hljs language-swift" lang="swift">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService$$EnhancerByCGLIB$$1234</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">OrderService</span> <span class="hljs-title class_">implements</span> <span class="hljs-title class_">Factory</span> {
    <span class="hljs-comment">// MethodProxy对象，用于调用目标方法</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MethodProxy</span> <span class="hljs-type">CGLIB_findOrderById_0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MethodProxy</span> <span class="hljs-type">CGLIB_createOrder_1</span>;

    <span class="hljs-comment">// 静态代码块：初始化MethodProxy</span>
    <span class="hljs-keyword">static</span> {
        <span class="hljs-type">CGLIB_findOrderById_0</span> <span class="hljs-operator">=</span> <span class="hljs-type">MethodProxy</span>.create(
            <span class="hljs-type">OrderService</span>.class, 
            <span class="hljs-type">OrderService</span>$<span class="hljs-variable">$EnhancerByCGLIB</span>$<span class="hljs-variable">$1234</span>.class, 
            <span class="hljs-string">"(Ljava/lang/Long;)Lcom/example/entity/Order;"</span>, 
            <span class="hljs-string">"findOrderById"</span>, 
            <span class="hljs-string">"CGLIB$findOrderById$0"</span>
        );
        <span class="hljs-comment">// ...初始化其他MethodProxy</span>
    }

    <span class="hljs-comment">// 重写findOrderById方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">Order</span> findOrderById(<span class="hljs-type">Long</span> var1) {
        <span class="hljs-type">MethodInterceptor</span> var10000 <span class="hljs-operator">=</span> this.<span class="hljs-type">CGLIB</span><span class="hljs-variable">$CALLBACK_0</span>;
        <span class="hljs-keyword">if</span> (var10000 <span class="hljs-operator">==</span> null) {
            <span class="hljs-type">CGLIB</span><span class="hljs-variable">$BIND_CALLBACKS</span>(this);
            var10000 <span class="hljs-operator">=</span> this.<span class="hljs-type">CGLIB</span><span class="hljs-variable">$CALLBACK_0</span>;
        }

        <span class="hljs-comment">// 调用MethodInterceptor的intercept方法</span>
        <span class="hljs-keyword">return</span> var10000 <span class="hljs-operator">!=</span> null <span class="hljs-operator">?</span> (<span class="hljs-type">Order</span>)var10000.intercept(
            this, 
            <span class="hljs-type">CGLIB</span><span class="hljs-variable">$findOrderById</span><span class="hljs-variable">$0</span><span class="hljs-variable">$Method</span>, 
            new <span class="hljs-type">Object</span>[]{var1}, 
            <span class="hljs-type">CGLIB_findOrderById_0</span>
        ) : <span class="hljs-keyword">super</span>.findOrderById(var1);
    }

    <span class="hljs-comment">// 目标方法的快速调用方法（由MethodProxy调用）</span>
    <span class="hljs-keyword">final</span> <span class="hljs-type">Order</span> <span class="hljs-type">CGLIB</span><span class="hljs-variable">$findOrderById</span><span class="hljs-variable">$0</span>(<span class="hljs-type">Long</span> var1) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.findOrderById(var1);
    }

    <span class="hljs-comment">// ...其他重写方法和辅助方法</span>
}

<span class="hljs-type">AI写代码java</span>
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031323334353637383940414243</span>
</code></pre>
<p>反编译后的代码显示，代理类OrderServiceE n h a n c e r B y C G L I B EnhancerByCGLIBEnhancerByCGLIB1234继承自OrderService，重写了findOrderById方法，方法内部调用了MethodInterceptor的intercept方法，这与我们之前的分析完全一致。</p>
<h2 data-id="heading-33"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第四章 对比与抉择：JDK与CGLib动态代理的核心差异</h2>
<p>JDK动态代理与CGLib动态代理是Spring AOP的两大核心支撑，它们在实现原理、适用场景、性能等方面存在显著差异，了解这些差异是开发者在实际开发中做出正确选择的关键。</p>
<h3 data-id="heading-34"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4.1 核心差异对比</h3>
<p>下表从多个维度对比了JDK动态代理与CGLib动态代理的核心差异：</p>








































<table><thead><tr><th>对比维度</th><th>JDK动态代理</th><th>CGLib动态代理</th></tr></thead><tbody><tr><td>实现原理</td><td>基于Java反射机制，代理类实现目标接口，继承自Proxy类</td><td>基于ASM字节码框架，代理类继承目标类，重写非final方法</td></tr><tr><td>目标对象要求</td><td>必须实现至少一个接口</td><td>无接口要求，但不能是final类，目标方法不能是final方法</td></tr><tr><td>代理类结构</td><td>代理类 = 实现目标接口 + 继承Proxy类</td><td>代理类 = 继承目标类 + 实现Factory接口</td></tr><tr><td>方法调用方式</td><td>通过反射调用目标方法，性能相对较低</td><td>通过MethodProxy调用目标方法，避免反射，性能更高</td></tr><tr><td>依赖</td><td>依赖Java原生API，无需额外引入依赖</td><td>依赖CGLib和ASM框架，Spring已默认集成</td></tr><tr><td>适用场景</td><td>目标对象实现接口的场景（Spring AOP默认首选）</td><td>目标对象无接口的场景，或对性能要求较高的场景</td></tr></tbody></table>
<h3 data-id="heading-35"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4.2 性能对比：谁更高效？</h3>
<p>关于JDK动态代理与CGLib动态代理的性能，长期存在争议。实际上，两者的性能差异与JDK版本密切相关：</p>
<ul>
<li><strong>JDK 8及之前版本</strong>：CGLib的性能优于JDK动态代理。因为JDK动态代理通过反射调用目标方法，而CGLib通过MethodProxy直接调用目标方法，避免了反射的性能开销；</li>
<li><strong>JDK 9及之后版本</strong>：JDK对反射机制进行了优化，JDK动态代理的性能大幅提升，与CGLib的性能差距缩小，甚至在某些场景下超过CGLib。</li>
</ul>
<p>为了直观对比两者的性能，我们设计一个简单的性能测试：分别通过JDK和CGLib代理，调用目标方法100万次，统计总耗时。测试代码如下（以JDK代理为例，CGLib类似）：</p>
<pre><code class="hljs language-ini" lang="ini">
public class ProxyPerformanceTest {
    public static void main(String<span class="hljs-section">[]</span> args) {
        // 测试次数
        int <span class="hljs-attr">count</span> = <span class="hljs-number">1000000</span><span class="hljs-comment">;</span>

        // JDK动态代理性能测试
        UserService <span class="hljs-attr">jdkTarget</span> = new UserServiceImpl()<span class="hljs-comment">;</span>
        UserService <span class="hljs-attr">jdkProxy</span> = (UserService) Proxy.newProxyInstance(
            jdkTarget.getClass().getClassLoader(),
            jdkTarget.getClass().getInterfaces(),
            new LogInvocationHandler(jdkTarget)
        )<span class="hljs-comment">;</span>
        long <span class="hljs-attr">jdkStart</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++) {</span>
            jdkProxy.findUserById(1L)<span class="hljs-comment">;</span>
        }
        long <span class="hljs-attr">jdkEnd</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        System.out.println("JDK动态代理100万次调用耗时：" + (jdkEnd - jdkStart) + "ms")<span class="hljs-comment">;</span>

        // CGLib动态代理性能测试
        OrderService <span class="hljs-attr">cglibTarget</span> = new OrderService()<span class="hljs-comment">;</span>
        Enhancer <span class="hljs-attr">enhancer</span> = new Enhancer()<span class="hljs-comment">;</span>
        enhancer.setSuperclass(OrderService.class)<span class="hljs-comment">;</span>
        enhancer.setCallback(new LogMethodInterceptor())<span class="hljs-comment">;</span>
        OrderService <span class="hljs-attr">cglibProxy</span> = (OrderService) enhancer.create()<span class="hljs-comment">;</span>
        long <span class="hljs-attr">cglibStart</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++) {</span>
            cglibProxy.findOrderById(1L)<span class="hljs-comment">;</span>
        }
        long <span class="hljs-attr">cglibEnd</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        System.out.println("CGLib动态代理100万次调用耗时：" + (cglibEnd - cglibStart) + "ms")<span class="hljs-comment">;</span>
    }
}

AI写代码java
运行
12345678910111213141516171819202122232425262728293031323334
</code></pre>
<p>在JDK 8环境下的测试结果（仅供参考）：</p>
<pre><code class="hljs language-arduino" lang="arduino">
JDK动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">120</span>ms
CGLib动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">80</span>ms

AI写代码text
<span class="hljs-number">123</span>
</code></pre>
<p>在JDK 11环境下的测试结果（仅供参考）：</p>
<pre><code class="hljs language-arduino" lang="arduino">
JDK动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">75</span>ms
CGLib动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">82</span>ms

AI写代码text
<span class="hljs-number">123</span>
</code></pre>
<p>从测试结果可以看出，JDK版本对两者的性能影响很大。在实际开发中，无需过度纠结于性能差异——除非是高频调用的核心接口，否则两者的性能差距对系统整体影响微乎其微。选择代理方式的核心依据应是目标对象是否实现接口。</p>
<h3 data-id="heading-36"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4.3 Spring AOP的代理选择策略</h3>
<p>Spring AOP作为成熟的框架，并没有强制要求使用某一种代理方式，而是根据目标对象的类型自动选择合适的代理方式，其核心选择策略如下：</p>
<ol>
<li><strong>优先使用JDK动态代理</strong>：如果目标对象实现了至少一个接口，Spring AOP默认使用JDK动态代理，生成的代理对象是目标接口的实现类；</li>
<li><strong>自动切换为CGLib</strong>：如果目标对象没有实现任何接口，Spring AOP会自动切换为CGLib动态代理，生成的代理对象是目标类的子类；</li>
<li><strong>强制使用CGLib</strong>：开发者可以通过配置强制Spring AOP使用CGLib代理，即使目标对象实现了接口。在Spring Boot 2.x中，可通过如下配置实现：<br/>
<code>spring: aop: proxy-target-class: true # true表示强制使用CGLib代理，false表示优先使用JDK代理</code></li>
</ol>
<p>需要注意的是，Spring Boot 2.x版本中，proxy-target-class的默认值为true——这意味着即使目标对象实现了接口，Spring AOP也会默认使用CGLib代理。这一变化的原因是Spring团队认为，CGLib代理在易用性（无接口要求）和性能（JDK 8及以下版本）上更具优势，同时避免了JDK代理只能代理接口的限制。</p>
<h2 data-id="heading-37"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第五章 Spring AOP的整体执行流程：从切面定义到方法调用</h2>
<p>前面我们分别剖析了JDK和CGLib动态代理的实现原理，而Spring AOP的整体执行流程是将这两种代理技术与切面定义、切入点匹配等逻辑结合起来的完整链路。理解这一流程，能帮助我们从宏观上把握Spring AOP的工作机制。</p>
<h3 data-id="heading-38"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.1 Spring AOP核心执行流程</h3>
<p>Spring AOP的核心执行流程可分为"初始化阶段"和"运行阶段"两个部分，每个阶段包含多个关键步骤：</p>
<h4 data-id="heading-39"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.1.1 初始化阶段：解析切面并准备代理</h4>
<p>初始化阶段发生在Spring容器启动时，核心任务是解析切面定义、生成切入点，并为目标对象准备代理逻辑。具体步骤如下：</p>
<ol>
<li><strong>扫描切面类</strong>：Spring容器启动时，通过@ComponentScan注解扫描带有@Aspect注解的切面类，将其注册为Spring Bean；</li>
<li><strong>解析切入点表达式</strong>：Spring解析切面类中@Pointcut注解定义的切入点表达式，将其转换为Pointcut对象，用于后续匹配目标方法；</li>
<li><strong>解析通知</strong>：解析切面类中带有@Before、@After等注解的通知方法，将其与对应的切入点关联，形成Advisor对象（Advisor = 切入点 + 通知）；</li>
<li><strong>识别目标对象</strong>：Spring容器扫描业务类（如带有@Service注解的类），识别需要被代理的目标对象；</li>
<li><strong>匹配Advisor</strong>：根据目标对象的方法，匹配与之对应的Advisor（即判断目标方法是否符合切入点表达式）；</li>
<li><strong>创建代理工厂</strong>：为匹配到Advisor的目标对象创建ProxyFactory（代理工厂），ProxyFactory封装了目标对象、Advisor等信息，负责生成代理对象。</li>
</ol>
<h4 data-id="heading-40"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.1.2 运行阶段：代理对象介导的方法调用</h4>
<p>运行阶段发生在客户端调用目标对象方法时，核心任务是通过代理对象执行通知逻辑和目标方法。具体步骤如下：</p>
<ol>
<li><strong>获取代理对象</strong>：客户端从Spring容器中获取目标对象时，容器返回的不是目标对象本身，而是由ProxyFactory生成的代理对象（JDK或CGLib代理）；</li>
<li><strong>触发代理方法</strong>：客户端调用代理对象的方法，代理对象的方法逻辑被触发（JDK代理调用InvocationHandler.invoke，CGLib代理调用MethodInterceptor.intercept）；</li>
<li><strong>获取匹配的通知链</strong>：代理对象根据当前调用的方法，从ProxyFactory中获取与之匹配的Advisor链，将其转换为通知链（MethodInterceptor链）；</li>
<li><strong>执行通知链</strong>：按照通知的类型和顺序，依次执行通知链中的通知逻辑。例如，先执行@Before通知，再执行目标方法，最后执行@After通知；</li>
<li><strong>调用目标方法</strong>：通知链执行到最后，通过反射或MethodProxy调用目标对象的原始方法；</li>
<li><strong>返回结果</strong>：将目标方法的返回值通过代理对象返回给客户端，完成整个调用流程。</li>
</ol>
<h3 data-id="heading-41"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.2 结合Spring注解的完整案例</h3>
<p>为了让大家更直观地理解Spring AOP的整体执行流程，下面我们通过一个完整的Spring Boot案例，展示从切面定义到方法调用的全过程。</p>
<h4 data-id="heading-42"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.2.1 步骤1：创建Spring Boot项目并引入依赖</h4>
<p>创建Spring Boot项目，引入spring-boot-starter-web和spring-boot-starter-aop依赖：</p>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

AI写代码xml
1234567891011
</code></pre>
<h4 data-id="heading-43"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.2.2 步骤2：定义切面类</h4>
<p>创建LogAspect切面类，定义切入点和五种类型的通知：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;
<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-comment">// 切面类：日志切面</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> {
    <span class="hljs-comment">// 切入点：匹配com.example.service包下所有类的所有方法</span>
    <span class="hljs-meta">@Pointcut("execution(* com.example.service.*.*(..))")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePointcut</span><span class="hljs-params">()</span> {}

    <span class="hljs-comment">// 前置通知</span>
    <span class="hljs-meta">@Before("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);
    }

    <span class="hljs-comment">// 后置通知</span>
    <span class="hljs-meta">@After("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束"</span>);
    }

    <span class="hljs-comment">// 返回通知</span>
    <span class="hljs-meta">@AfterReturning(value = "servicePointcut()", returning = "result")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result));
    }

    <span class="hljs-comment">// 异常通知</span>
    <span class="hljs-meta">@AfterThrowing(value = "servicePointcut()", throwing = "ex")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowingAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Exception ex)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + ex.getMessage());
    }

    <span class="hljs-comment">// 环绕通知</span>
    <span class="hljs-meta">@Around("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundAdvice</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-前】"</span> + LocalDateTime.now() + <span class="hljs-string">" 准备调用方法："</span> + methodName);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行目标方法</span>
            result = joinPoint.proceed();
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-后】方法"</span> + methodName + <span class="hljs-string">"执行完成"</span>);
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-异常】方法"</span> + methodName + <span class="hljs-string">"执行异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e;
        }
        <span class="hljs-keyword">return</span> result;
    }
}

AI写代码Plain
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859</span>
</code></pre>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;
<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-comment">// 切面类：日志切面</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> {
    <span class="hljs-comment">// 切入点：匹配com.example.service包下所有类的所有方法</span>
    <span class="hljs-meta">@Pointcut("execution(* com.example.service.*.*(..))")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePointcut</span><span class="hljs-params">()</span> {}

    <span class="hljs-comment">// 前置通知</span>
    <span class="hljs-meta">@Before("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);
    }

    <span class="hljs-comment">// 后置通知</span>
    <span class="hljs-meta">@After("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束"</span>);
    }

    <span class="hljs-comment">// 返回通知</span>
    <span class="hljs-meta">@AfterReturning(value = "servicePointcut()", returning = "result")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result));
    }

    <span class="hljs-comment">// 异常通知</span>
    <span class="hljs-meta">@AfterThrowing(value = "servicePointcut()", throwing = "ex")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowingAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Exception ex)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + ex.getMessage());
    }

    <span class="hljs-comment">// 环绕通知</span>
    <span class="hljs-meta">@Around("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundAdvice</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-前】"</span> + LocalDateTime.now() + <span class="hljs-string">" 准备调用方法："</span> + methodName);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行目标方法</span>
            result = joinPoint.proceed();
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-后】方法"</span> + methodName + <span class="hljs-string">"执行完成"</span>);
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-异常】方法"</span> + methodName + <span class="hljs-string">"执行异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e;
        }
        <span class="hljs-keyword">return</span> result;
    }
}


AI写代码Plain
<span class="hljs-number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960</span>
</code></pre>
<h2 data-id="heading-44"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第六章 总结：Spring AOP的核心启示与实践指南</h2>
<p>本文通过从基础概念到底层实现、从理论解析到实战案例的层层递进，全面剖析了Spring AOP的核心原理与实践应用。从AOP解决的代码痛点出发，我们深入理解了其“横切编程”的本质，掌握了切面、通知、切入点等核心概念，并重点拆解了支撑Spring AOP的两大动态代理技术——JDK与CGLib动态代理，最终梳理了Spring AOP的完整执行链路。这些内容不仅揭示了技术的底层逻辑，更能为实际开发提供清晰的指引。</p>
<h3 data-id="heading-45"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.1 核心知识体系梳理</h3>
<p>Spring AOP的知识体系可归纳为“一个核心目标、两大技术支撑、三个核心环节”：</p>
<ul>
<li><strong>一个核心目标</strong>：通过“业务逻辑”与“通用功能”的解耦，提升代码复用性与可维护性。AOP将日志、事务、权限等横切逻辑抽象为切面，避免了代码冗余，使开发者能聚焦核心业务开发。</li>
<li><strong>两大技术支撑</strong>：JDK动态代理与CGLib动态代理构成了Spring AOP的技术基石。两者基于不同的实现原理（接口实现vs类继承），形成互补：JDK代理依赖接口，无需额外依赖，在JDK 9+版本性能优异；CGLib代理通过继承实现，无接口限制，在JDK 8及以下版本性能更具优势。</li>
<li><strong>三个核心环节</strong>：Spring AOP的工作流程可概括为“切面解析与准备”“代理对象生成”“方法调用与通知执行”。初始化阶段，Spring容器完成切面扫描、切入点解析与Advisor组装；运行阶段，代理对象作为中介，按顺序执行通知逻辑与目标方法，实现横切功能的织入。</li>
</ul>
<h3 data-id="heading-46"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2 关键实践决策指南</h3>
<p>基于前文的技术对比与原理分析，在实际开发中使用Spring AOP时，可遵循以下决策原则：</p>
<h4 data-id="heading-47"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2.1 代理方式选择</h4>
<p>Spring AOP的代理选择已实现自动化，但开发者需明确其逻辑并根据场景调整：</p>
<ul>
<li>默认场景：Spring Boot 2.x及以上版本默认启用<code>proxy-target-class: true</code>，优先使用CGLib代理，覆盖接口与无接口两种场景，降低使用成本；</li>
<li>接口优先场景：若项目采用“面向接口编程”规范，且使用JDK 9+版本，可配置为JDK代理，利用其原生支持与优化后的性能；</li>
<li>特殊限制场景：若目标类为final类或包含final方法，CGLib无法代理，需确保目标类实现接口以使用JDK代理。</li>
</ul>
<h4 data-id="heading-48"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2.2 切面设计与使用</h4>
<p>切面设计的合理性直接影响系统的可维护性，需注意以下几点：</p>
<ul>
<li>单一职责：一个切面聚焦一类横切功能（如日志切面仅处理日志记录，事务切面仅管理事务），避免切面逻辑臃肿；</li>
<li>切入点精准：通过execution表达式精准匹配目标方法，避免“过度代理”。例如，仅对service层的业务方法织入事务切面，而非所有层的方法；</li>
<li>通知类型适配：根据需求选择合适的通知类型——环绕通知功能最全面，可控制方法执行与异常处理；前置/后置通知适用于简单的日志记录；返回/异常通知则针对性处理方法结果与异常场景。</li>
</ul>
<h4 data-id="heading-49"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2.3 性能优化建议</h4>
<p>虽然Spring AOP的性能开销通常可忽略，但在高频调用场景下仍需优化：</p>
<ul>
<li>减少代理对象创建：Spring容器会缓存代理对象，避免频繁创建；</li>
<li>优化切入点表达式：避免使用过于宽泛的表达式（如<code>execution(* *(..))</code>），减少方法匹配的性能消耗；</li>
<li>控制通知逻辑复杂度：通知代码应简洁高效，避免在通知中执行耗时操作（如复杂IO、数据库查询），必要时通过异步处理优化。</li>
</ul>
<h3 data-id="heading-50"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.3 技术本质与未来启示</h3>
<p>从技术本质来看，Spring AOP是“动态代理”与“依赖注入”的结合产物——动态代理实现了方法增强的技术能力，依赖注入则实现了切面与目标对象的解耦与管理。这种“技术组合”的思路，为解决复杂问题提供了典范。</p>
<p>随着Spring框架的发展，AOP的实现也在不断优化，但核心思想始终未变。对于开发者而言，掌握底层原理远比单纯使用API更重要：理解动态代理的字节码生成逻辑，能快速定位代理相关的异常；明晰通知的执行顺序，可避免切面逻辑冲突；掌握切入点表达式的语法，能精准控制切面作用范围。这些能力不仅适用于Spring AOP，更能迁移到其他需要“方法增强”的场景（如RPC框架的调用增强、分布式追踪的链路埋点等）。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[三极管推挽输出电路分析]]></title>    <link>https://juejin.cn/post/7603721514203332617</link>    <guid>https://juejin.cn/post/7603721514203332617</guid>    <pubDate>2026-02-08T06:52:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603721514203332617" data-draft-id="7603687444052082726" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="三极管推挽输出电路分析"/> <meta itemprop="keywords" content="嵌入式,后端"/> <meta itemprop="datePublished" content="2026-02-08T06:52:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员良许"/> <meta itemprop="url" content="https://juejin.cn/user/3913917128246942"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            三极管推挽输出电路分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3913917128246942/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员良许
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:52:43.000Z" title="Sun Feb 08 2026 06:52:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">三极管推挽输出电路分析</h2>
<p>大家好，我是良许。</p>
<p>在嵌入式系统开发中，我们经常需要驱动各种负载，比如 LED、继电器、电机等。</p>
<p>这时候，单纯依靠 MCU 的 IO 口往往无法提供足够的驱动能力。</p>
<p>推挽输出电路作为一种经典的功率放大电路，在实际项目中应用非常广泛。</p>
<p>今天我们就来深入分析一下三极管推挽输出电路的工作原理和实际应用。</p>
<h3 data-id="heading-1">1. 推挽电路的基本概念</h3>
<h4 data-id="heading-2">1.1 什么是推挽电路</h4>
<p>推挽电路是一种由两个三极管组成的互补输出电路。</p>
<p>这两个三极管一个负责"推"，即向负载提供电流；另一个负责"挽"，即从负载吸收电流。</p>
<p>这种结构使得电路能够在正负两个方向上都提供强大的驱动能力。</p>
<p>与普通的单管放大电路相比，推挽电路最大的优势在于输出阻抗低、驱动能力强、效率高。</p>
<p>在我之前做汽车电子项目时，就经常使用推挽电路来驱动车载继电器和指示灯，效果非常好。</p>
<h4 data-id="heading-3">1.2 推挽电路的分类</h4>
<p>推挽电路主要分为两种类型：</p>
<p><strong>互补型推挽电路</strong>：使用 NPN 和 PNP 两种不同类型的三极管，这是最常见的推挽电路形式。</p>
<p>当输入高电平时，NPN 管导通，PNP 管截止；当输入低电平时，PNP 管导通，NPN 管截止。</p>
<p><strong>同类型推挽电路</strong>：使用两个相同类型的三极管，通过变压器或其他方式实现互补工作。</p>
<p>这种电路在音频功放中比较常见。</p>
<h3 data-id="heading-4">2. 互补型推挽电路的工作原理</h3>
<h4 data-id="heading-5">2.1 电路结构分析</h4>
<p>互补型推挽电路的典型结构如下：输入信号同时送到 NPN 管和 PNP 管的基极，NPN 管的发射极和 PNP 管的发射极连接在一起作为输出端，NPN 管的集电极接正电源，PNP 管的集电极接地。</p>
<p>让我给大家画个简单的原理图来说明。</p>
<p>假设我们使用 STM32 的 GPIO 口来控制一个推挽电路驱动 LED：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// STM32 HAL库配置GPIO为推挽输出</span>
void <span class="hljs-built_in">MX_GPIO_Init</span>(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {<span class="hljs-number">0</span>};
    
    <span class="hljs-comment">// 使能GPIOA时钟</span>
    <span class="hljs-built_in">__HAL_RCC_GPIOA_CLK_ENABLE</span>();
    
    <span class="hljs-comment">// 配置PA5为推挽输出</span>
    GPIO_InitStruct<span class="hljs-selector-class">.Pin</span> = GPIO_PIN_5;
    GPIO_InitStruct<span class="hljs-selector-class">.Mode</span> = GPIO_MODE_OUTPUT_PP;  <span class="hljs-comment">// 推挽输出模式</span>
    GPIO_InitStruct<span class="hljs-selector-class">.Pull</span> = GPIO_NOPULL;
    GPIO_InitStruct<span class="hljs-selector-class">.Speed</span> = GPIO_SPEED_FREQ_LOW;
    <span class="hljs-built_in">HAL_GPIO_Init</span>(GPIOA, &amp;GPIO_InitStruct);
}
​
<span class="hljs-comment">// 控制输出</span>
void <span class="hljs-built_in">LED_Control</span>(uint8_t state)
{
    <span class="hljs-built_in">if</span>(state) {
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);   <span class="hljs-comment">// 输出高电平</span>
    } else {
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); <span class="hljs-comment">// 输出低电平</span>
    }
}
</code></pre>
<h4 data-id="heading-6">2.2 工作过程详解</h4>
<p>当输入信号为高电平时，NPN 管的基极电压升高，基极-发射极之间形成正向偏置，NPN 管导通。</p>
<p>此时，电流从正电源经过 NPN 管的集电极-发射极流向负载，负载两端获得接近电源电压的高电平。</p>
<p>同时，PNP 管的基极相对于发射极为正电压，基极-发射极之间反向偏置，PNP 管截止。</p>
<p>当输入信号为低电平时，情况正好相反。</p>
<p>NPN 管的基极电压降低，基极-发射极之间电压不足以使其导通，NPN 管截止。</p>
<p>而 PNP 管的基极相对于发射极变为负电压，基极-发射极之间正向偏置，PNP 管导通。</p>
<p>此时，电流从负载经过 PNP 管的发射极-集电极流向地，负载两端获得接近地电位的低电平。</p>
<p>这种工作方式的巧妙之处在于，无论输出高电平还是低电平，都有一个三极管处于导通状态，提供低阻抗的电流通路。</p>
<p>这就是推挽电路驱动能力强的根本原因。</p>
<h4 data-id="heading-7">2.3 关键参数计算</h4>
<p>在设计推挽电路时，我们需要计算几个关键参数。</p>
<p>首先是基极限流电阻的选择。</p>
<p>假设我们使用的三极管放大倍数 <em>β</em>=100，负载电流 <em>IL</em>=100<em>mA</em>，那么基极电流需要：</p>
<p><em>IB</em>=<em>IB/β=100</em>mA/100=1<em>m</em>A</p>
<p>如果输入电压为 5V，三极管基极-发射极压降 VBE = 0.7V，则基极限流电阻为：</p>
<p>RB = (VIN - VBE)/IB= (5V - 0.7V)/1mA= 4.3<em>k</em>Ω</p>
<p>实际应用中，我们通常选择标准阻值 4.7<em>k</em>Ω 或 3.9<em>k</em>Ω</p>
<h3 data-id="heading-8">3. 实际应用电路设计</h3>
<h4 data-id="heading-9">3.1 LED 驱动电路</h4>
<p>在嵌入式项目中，我们经常需要驱动大功率 LED。</p>
<p>下面是一个使用推挽电路驱动 LED 的完整示例：</p>
<pre><code class="hljs language-ini" lang="ini">// 硬件连接：
// STM32 PA5 -&gt; R1(4.7k) -&gt; Q1(NPN)基极
// STM32 PA5 -&gt; R2(4.7k) -&gt; Q2(PNP)基极
// Q1集电极 -&gt; VCC(12V)
// Q2集电极 -&gt; GND
// Q1发射极 = Q2发射极 -&gt; LED正极
// LED负极 -&gt; R3(限流电阻) -&gt; GND
​
<span class="hljs-comment">#define LED_PIN GPIO_PIN_5</span>
<span class="hljs-comment">#define LED_PORT GPIOA</span>
​
// 初始化LED驱动
void LED_Driver_Init(void)
{
    GPIO_InitTypeDef <span class="hljs-attr">GPIO_InitStruct</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    __HAL_RCC_GPIOA_CLK_ENABLE()<span class="hljs-comment">;</span>
    
    <span class="hljs-attr">GPIO_InitStruct.Pin</span> = LED_PIN<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Mode</span> = GPIO_MODE_OUTPUT_PP<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Pull</span> = GPIO_NOPULL<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Speed</span> = GPIO_SPEED_FREQ_MEDIUM<span class="hljs-comment">;</span>
    HAL_GPIO_Init(LED_PORT, &amp;GPIO_InitStruct)<span class="hljs-comment">;</span>
    
    // 初始状态设为低电平
    HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
}
​
// PWM调光控制
void LED_PWM_Control(uint8_t brightness)
{
    // brightness: 0-100，表示亮度百分比
    uint16_t <span class="hljs-attr">period</span> = <span class="hljs-number">1000</span><span class="hljs-comment">;  // PWM周期，单位us</span>
    uint16_t <span class="hljs-attr">pulse_width</span> = (period * brightness) / <span class="hljs-number">100</span><span class="hljs-comment">;</span>
    
    for(uint16_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; period; i++) {</span>
        if(i &lt; pulse_width) {
            HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET)<span class="hljs-comment">;</span>
        } else {
            HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
        }
        // 延时1us（实际项目中应使用硬件PWM）
        delay_us(1)<span class="hljs-comment">;</span>
    }
}
​
// 使用硬件PWM的更优方案
void LED_Hardware_PWM_Init(void)
{
    TIM_HandleTypeDef htim2<span class="hljs-comment">;</span>
    TIM_OC_InitTypeDef <span class="hljs-attr">sConfigOC</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    // 配置定时器2
    <span class="hljs-attr">htim2.Instance</span> = TIM2<span class="hljs-comment">;</span>
    <span class="hljs-attr">htim2.Init.Prescaler</span> = <span class="hljs-number">72</span>-<span class="hljs-number">1</span><span class="hljs-comment">;  // 假设系统时钟72MHz</span>
    <span class="hljs-attr">htim2.Init.CounterMode</span> = TIM_COUNTERMODE_UP<span class="hljs-comment">;</span>
    <span class="hljs-attr">htim2.Init.Period</span> = <span class="hljs-number">1000</span>-<span class="hljs-number">1</span><span class="hljs-comment">;   // PWM频率1kHz</span>
    <span class="hljs-attr">htim2.Init.ClockDivision</span> = TIM_CLOCKDIVISION_DIV1<span class="hljs-comment">;</span>
    HAL_TIM_PWM_Init(&amp;htim2)<span class="hljs-comment">;</span>
    
    // 配置PWM通道
    <span class="hljs-attr">sConfigOC.OCMode</span> = TIM_OCMODE_PWM1<span class="hljs-comment">;</span>
    <span class="hljs-attr">sConfigOC.Pulse</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    <span class="hljs-attr">sConfigOC.OCPolarity</span> = TIM_OCPOLARITY_HIGH<span class="hljs-comment">;</span>
    <span class="hljs-attr">sConfigOC.OCFastMode</span> = TIM_OCFAST_DISABLE<span class="hljs-comment">;</span>
    HAL_TIM_PWM_ConfigChannel(&amp;htim2, &amp;sConfigOC, TIM_CHANNEL_1)<span class="hljs-comment">;</span>
    
    // 启动PWM
    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1)<span class="hljs-comment">;</span>
}
​
void LED_Set_Brightness(uint8_t brightness)
{
    // 设置占空比
    __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, brightness * 10)<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-10">3.2 继电器驱动电路</h4>
<p>在工业控制和汽车电子中，继电器是常用的开关器件。</p>
<p>推挽电路可以提供足够的驱动电流来可靠地控制继电器。</p>
<p>下面是一个继电器驱动的实现：</p>
<pre><code class="hljs language-ini" lang="ini">// 继电器驱动电路
// 硬件连接：
// STM32 PB0 -&gt; 推挽驱动电路 -&gt; 继电器线圈
// 继电器线圈并联续流二极管
​
<span class="hljs-comment">#define RELAY_PIN GPIO_PIN_0</span>
<span class="hljs-comment">#define RELAY_PORT GPIOB</span>
​
typedef struct {
    GPIO_TypeDef* port<span class="hljs-comment">;</span>
    uint16_t pin<span class="hljs-comment">;</span>
    uint8_t state<span class="hljs-comment">;</span>
    uint32_t last_toggle_time<span class="hljs-comment">;</span>
} Relay_TypeDef<span class="hljs-comment">;</span>
​
Relay_TypeDef <span class="hljs-attr">relay1</span> = {
    .<span class="hljs-attr">port</span> = RELAY_PORT,
    .<span class="hljs-attr">pin</span> = RELAY_PIN,
    .<span class="hljs-attr">state</span> = <span class="hljs-number">0</span>,
    .<span class="hljs-attr">last_toggle_time</span> = <span class="hljs-number">0</span>
}<span class="hljs-comment">;</span>
​
// 初始化继电器
void Relay_Init(Relay_TypeDef* relay)
{
    GPIO_InitTypeDef <span class="hljs-attr">GPIO_InitStruct</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    // 使能时钟
    if(relay-&gt;<span class="hljs-attr">port</span> == GPIOB) {
        __HAL_RCC_GPIOB_CLK_ENABLE()<span class="hljs-comment">;</span>
    }
    
    <span class="hljs-attr">GPIO_InitStruct.Pin</span> = relay-&gt;pin<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Mode</span> = GPIO_MODE_OUTPUT_PP<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Pull</span> = GPIO_NOPULL<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Speed</span> = GPIO_SPEED_FREQ_LOW<span class="hljs-comment">;</span>
    HAL_GPIO_Init(relay-&gt;port, &amp;GPIO_InitStruct)<span class="hljs-comment">;</span>
    
    // 初始状态关闭
    HAL_GPIO_WritePin(relay-&gt;port, relay-&gt;pin, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
    relay-&gt;<span class="hljs-attr">state</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
}
​
// 继电器控制（带防抖动）
void Relay_Control(Relay_TypeDef* relay, uint8_t state)
{
    uint32_t <span class="hljs-attr">current_time</span> = HAL_GetTick()<span class="hljs-comment">;</span>
    
    // 防止频繁切换，至少间隔100ms
    if(current_time - relay-&gt;last_toggle_time &lt; 100) {
        return<span class="hljs-comment">;</span>
    }
    
    if(state &amp;&amp; !relay-&gt;state) {
        // 打开继电器
        HAL_GPIO_WritePin(relay-&gt;port, relay-&gt;pin, GPIO_PIN_SET)<span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">state</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">last_toggle_time</span> = current_time<span class="hljs-comment">;</span>
    } else if(!state &amp;&amp; relay-&gt;state) {
        // 关闭继电器
        HAL_GPIO_WritePin(relay-&gt;port, relay-&gt;pin, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">state</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">last_toggle_time</span> = current_time<span class="hljs-comment">;</span>
    }
}
​
// 继电器状态读取
uint8_t Relay_Get_State(Relay_TypeDef* relay)
{
    return relay-&gt;state<span class="hljs-comment">;</span>
}
​
// 继电器翻转
void Relay_Toggle(Relay_TypeDef* relay)
{
    Relay_Control(relay, !relay-&gt;state)<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-11">3.3 电机驱动电路</h4>
<p>推挽电路也常用于小功率直流电机的驱动。</p>
<p>通过 PWM 控制可以实现电机调速：</p>
<pre><code class="hljs language-ini" lang="ini">// 电机驱动
<span class="hljs-comment">#define MOTOR_PIN GPIO_PIN_6</span>
<span class="hljs-comment">#define MOTOR_PORT GPIOA</span>
<span class="hljs-comment">#define MOTOR_TIMER TIM3</span>
<span class="hljs-comment">#define MOTOR_CHANNEL TIM_CHANNEL_1</span>
​
typedef struct {
    TIM_HandleTypeDef* htim<span class="hljs-comment">;</span>
    uint32_t channel<span class="hljs-comment">;</span>
    uint8_t speed<span class="hljs-comment">;      // 0-100</span>
    uint8_t direction<span class="hljs-comment">;  // 0:正转, 1:反转</span>
} Motor_TypeDef<span class="hljs-comment">;</span>
​
Motor_TypeDef motor1<span class="hljs-comment">;</span>
​
// 电机初始化
void Motor_Init(Motor_TypeDef* motor, TIM_HandleTypeDef* htim, uint32_t channel)
{
    motor-&gt;<span class="hljs-attr">htim</span> = htim<span class="hljs-comment">;</span>
    motor-&gt;<span class="hljs-attr">channel</span> = channel<span class="hljs-comment">;</span>
    motor-&gt;<span class="hljs-attr">speed</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    motor-&gt;<span class="hljs-attr">direction</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    
    // 启动PWM
    HAL_TIM_PWM_Start(motor-&gt;htim, motor-&gt;channel)<span class="hljs-comment">;</span>
}
​
// 设置电机速度
void Motor_Set_Speed(Motor_TypeDef* motor, uint8_t speed)
{
    if(speed &gt; 100) <span class="hljs-attr">speed</span> = <span class="hljs-number">100</span><span class="hljs-comment">;</span>
    
    motor-&gt;<span class="hljs-attr">speed</span> = speed<span class="hljs-comment">;</span>
    
    // 计算PWM占空比
    uint32_t <span class="hljs-attr">pulse</span> = (motor-&gt;htim-&gt;Init.Period * speed) / <span class="hljs-number">100</span><span class="hljs-comment">;</span>
    __HAL_TIM_SET_COMPARE(motor-&gt;htim, motor-&gt;channel, pulse)<span class="hljs-comment">;</span>
}
​
// 设置电机方向
void Motor_Set_Direction(Motor_TypeDef* motor, uint8_t direction)
{
    motor-&gt;<span class="hljs-attr">direction</span> = direction<span class="hljs-comment">;</span>
    // 这里需要配合H桥电路来实现方向控制
}
​
// 电机启动
void Motor_Start(Motor_TypeDef* motor, uint8_t speed, uint8_t direction)
{
    Motor_Set_Direction(motor, direction)<span class="hljs-comment">;</span>
    Motor_Set_Speed(motor, speed)<span class="hljs-comment">;</span>
}
​
// 电机停止
void Motor_Stop(Motor_TypeDef* motor)
{
    Motor_Set_Speed(motor, 0)<span class="hljs-comment">;</span>
}
​
// 电机加速
void Motor_Accelerate(Motor_TypeDef* motor, uint8_t target_speed, uint16_t time_ms)
{
    uint8_t <span class="hljs-attr">current_speed</span> = motor-&gt;speed<span class="hljs-comment">;</span>
    uint16_t <span class="hljs-attr">steps</span> = time_ms / <span class="hljs-number">10</span><span class="hljs-comment">;  // 每10ms调整一次</span>
    int16_t <span class="hljs-attr">speed_increment</span> = (target_speed - current_speed) / steps<span class="hljs-comment">;</span>
    
    for(uint16_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; steps; i++) {</span>
        current_speed += speed_increment<span class="hljs-comment">;</span>
        Motor_Set_Speed(motor, current_speed)<span class="hljs-comment">;</span>
        HAL_Delay(10)<span class="hljs-comment">;</span>
    }
    
    Motor_Set_Speed(motor, target_speed)<span class="hljs-comment">;</span>
}
</code></pre>
<h3 data-id="heading-12">4. 推挽电路的优化设计</h3>
<h4 data-id="heading-13">4.1 交越失真的消除</h4>
<p>在互补推挽电路中，存在一个常见问题叫做交越失真。</p>
<p>当输入信号在零点附近时，两个三极管都处于临界导通状态，输出会出现非线性失真。</p>
<p>解决方法是在两个三极管的基极之间加入偏置电路，使它们始终处于微导通状态。</p>
<p>我们可以使用两个二极管串联来提供偏置电压：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 在实际电路中，我们需要在基极电路中加入偏置</span>
<span class="hljs-comment">// 这里通过软件方式模拟偏置效果</span>
​
<span class="hljs-selector-id">#define</span> BIAS_VOLTAGE <span class="hljs-number">0.6</span>  <span class="hljs-comment">// 偏置电压，单位V</span>
​
<span class="hljs-comment">// 带偏置的输出控制</span>
void <span class="hljs-built_in">Biased_Output_Control</span>(uint8_t level)
{
    <span class="hljs-comment">// 在实际硬件电路中实现偏置</span>
    <span class="hljs-comment">// 这里仅作示意</span>
    <span class="hljs-built_in">if</span>(level &gt; <span class="hljs-number">128</span>) {
        <span class="hljs-comment">// 输出高电平，考虑偏置</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
    } else {
        <span class="hljs-comment">// 输出低电平，考虑偏置</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    }
}
</code></pre>
<h4 data-id="heading-14">4.2 过流保护设计</h4>
<p>在驱动大功率负载时，过流保护是必不可少的。</p>
<p>我们可以在电路中串联一个小阻值的采样电阻，通过 ADC 采集电压来监测电流：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 过流保护</span>
<span class="hljs-selector-id">#define</span> CURRENT_SENSE_PIN GPIO_PIN_0
<span class="hljs-selector-id">#define</span> CURRENT_SENSE_PORT GPIOA
<span class="hljs-selector-id">#define</span> MAX_CURRENT_MA <span class="hljs-number">500</span>  <span class="hljs-comment">// 最大电流500mA</span>
<span class="hljs-selector-id">#define</span> SENSE_RESISTOR <span class="hljs-number">0.1</span>  <span class="hljs-comment">// 采样电阻0.1欧姆</span>
​
typedef struct {
    ADC_HandleTypeDef* hadc;
    uint32_t channel;
    uint16_t max_current;
    uint8_t protection_enabled;
} Current_Protection_TypeDef;
​
Current_Protection_TypeDef current_protection;
​
<span class="hljs-comment">// 初始化过流保护</span>
void <span class="hljs-built_in">Current_Protection_Init</span>(Current_Protection_TypeDef* cp, ADC_HandleTypeDef* hadc, uint32_t channel)
{
    cp-&gt;hadc = hadc;
    cp-&gt;channel = channel;
    cp-&gt;max_current = MAX_CURRENT_MA;
    cp-&gt;protection_enabled = <span class="hljs-number">1</span>;
}
​
<span class="hljs-comment">// 读取电流值</span>
uint16_t <span class="hljs-built_in">Read_Current</span>(Current_Protection_TypeDef* cp)
{
    uint32_t adc_value;
    <span class="hljs-attribute">float</span> voltage, current;
    
    <span class="hljs-comment">// 启动ADC转换</span>
    <span class="hljs-built_in">HAL_ADC_Start</span>(cp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_PollForConversion</span>(cp-&gt;hadc, <span class="hljs-number">100</span>);
    adc_value = <span class="hljs-built_in">HAL_ADC_GetValue</span>(cp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_Stop</span>(cp-&gt;hadc);
    
    <span class="hljs-comment">// 计算电压和电流</span>
    <span class="hljs-comment">// 假设ADC参考电压3.3V，12位分辨率</span>
    voltage = (adc_value * <span class="hljs-number">3.3</span>) / <span class="hljs-number">4096.0</span>;
    current = voltage / SENSE_RESISTOR;  <span class="hljs-comment">// 单位：A</span>
    
    return (uint16_t)(current * <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 转换为mA</span>
}
​
<span class="hljs-comment">// 过流检测</span>
uint8_t <span class="hljs-built_in">Check_Overcurrent</span>(Current_Protection_TypeDef* cp)
{
    <span class="hljs-built_in">if</span>(!cp-&gt;protection_enabled) return <span class="hljs-number">0</span>;
    
    uint16_t current = <span class="hljs-built_in">Read_Current</span>(cp);
    
    <span class="hljs-built_in">if</span>(current &gt; cp-&gt;max_current) {
        <span class="hljs-comment">// 检测到过流</span>
        return <span class="hljs-number">1</span>;
    }
    
    return <span class="hljs-number">0</span>;
}
​
<span class="hljs-comment">// 带过流保护的负载控制</span>
void <span class="hljs-built_in">Protected_Load_Control</span>(uint8_t state)
{
    <span class="hljs-built_in">if</span>(state) {
        <span class="hljs-comment">// 打开负载</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
        
        <span class="hljs-comment">// 延时一小段时间后检测电流</span>
        <span class="hljs-built_in">HAL_Delay</span>(<span class="hljs-number">10</span>);
        
        <span class="hljs-built_in">if</span>(Check_Overcurrent(&amp;current_protection)) {
            <span class="hljs-comment">// 检测到过流，立即关闭输出</span>
            <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
            <span class="hljs-comment">// 记录错误日志或触发报警</span>
            <span class="hljs-built_in">Error_Handler</span>();
        }
    } else {
        <span class="hljs-comment">// 关闭负载</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    }
}
</code></pre>
<h4 data-id="heading-15">4.3 热保护设计</h4>
<p>大功率推挽电路工作时会产生热量，需要进行温度监测和保护：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 温度保护</span>
<span class="hljs-selector-id">#define</span> TEMP_SENSOR_PIN GPIO_PIN_1
<span class="hljs-selector-id">#define</span> MAX_TEMPERATURE <span class="hljs-number">85</span>  <span class="hljs-comment">// 最大温度85°C</span>
​
typedef struct {
    ADC_HandleTypeDef* hadc;
    uint32_t channel;
    int16_t max_temp;
    int16_t current_temp;
    uint8_t protection_enabled;
} Thermal_Protection_TypeDef;
​
Thermal_Protection_TypeDef thermal_protection;
​
<span class="hljs-comment">// 读取温度</span>
int16_t <span class="hljs-built_in">Read_Temperature</span>(Thermal_Protection_TypeDef* tp)
{
    uint32_t adc_value;
    <span class="hljs-attribute">float</span> voltage, temperature;
    
    <span class="hljs-built_in">HAL_ADC_Start</span>(tp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_PollForConversion</span>(tp-&gt;hadc, <span class="hljs-number">100</span>);
    adc_value = <span class="hljs-built_in">HAL_ADC_GetValue</span>(tp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_Stop</span>(tp-&gt;hadc);
    
    <span class="hljs-comment">// 假设使用NTC热敏电阻，这里需要根据实际传感器特性计算</span>
    voltage = (adc_value * <span class="hljs-number">3.3</span>) / <span class="hljs-number">4096.0</span>;
    
    <span class="hljs-comment">// 简化的温度计算公式（实际应使用查表法或B值公式）</span>
    temperature = (voltage - <span class="hljs-number">0.5</span>) * <span class="hljs-number">100</span>;
    
    tp-&gt;current_temp = (int16_t)temperature;
    return tp-&gt;current_temp;
}
​
<span class="hljs-comment">// 温度保护检测</span>
uint8_t <span class="hljs-built_in">Check_Overtemperature</span>(Thermal_Protection_TypeDef* tp)
{
    <span class="hljs-built_in">if</span>(!tp-&gt;protection_enabled) return <span class="hljs-number">0</span>;
    
    int16_t temp = <span class="hljs-built_in">Read_Temperature</span>(tp);
    
    <span class="hljs-built_in">if</span>(temp &gt; tp-&gt;max_temp) {
        return <span class="hljs-number">1</span>;
    }
    
    return <span class="hljs-number">0</span>;
}
​
<span class="hljs-comment">// 综合保护的负载控制</span>
void <span class="hljs-built_in">Safe_Load_Control</span>(uint8_t state)
{
    <span class="hljs-built_in">if</span>(state) {
        <span class="hljs-comment">// 先检查温度</span>
        <span class="hljs-built_in">if</span>(Check_Overtemperature(&amp;thermal_protection)) {
            <span class="hljs-comment">// 温度过高，拒绝开启</span>
            return;
        }
        
        <span class="hljs-comment">// 打开负载</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
        
        <span class="hljs-comment">// 检查电流</span>
        <span class="hljs-built_in">HAL_Delay</span>(<span class="hljs-number">10</span>);
        <span class="hljs-built_in">if</span>(Check_Overcurrent(&amp;current_protection)) {
            <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
            return;
        }
    } else {
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    }
}
</code></pre>
<h3 data-id="heading-16">5. 常见问题与解决方案</h3>
<h4 data-id="heading-17">5.1 输出波形振荡</h4>
<p>在实际应用中，推挽电路的输出有时会出现振荡现象。</p>
<p>这通常是由于负载电容和电路寄生电感形成了 LC 振荡回路。</p>
<p>解决方法是在输出端并联一个小电容（通常 0.1<em>μF</em> 到 1<em>μF</em>）进行滤波，或者串联一个小电阻进行阻尼。</p>
<h4 data-id="heading-18">5.2 上电瞬间的冲击电流</h4>
<p>当推挽电路驱动容性负载时，上电瞬间会产生很大的冲击电流。</p>
<p>我们可以通过软启动的方式来解决：</p>
<pre><code class="hljs language-ini" lang="ini">// 软启动函数
void Soft_Start_Output(uint16_t ramp_time_ms)
{
    uint16_t <span class="hljs-attr">steps</span> = ramp_time_ms / <span class="hljs-number">10</span><span class="hljs-comment">;</span>
    uint16_t <span class="hljs-attr">pwm_period</span> = <span class="hljs-number">1000</span><span class="hljs-comment">;  // PWM周期</span>
    
    for(uint16_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt;= steps; i++) {</span>
        uint16_t <span class="hljs-attr">duty</span> = (pwm_period * i) / steps<span class="hljs-comment">;</span>
        
        // 设置PWM占空比
        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, duty)<span class="hljs-comment">;</span>
        HAL_Delay(10)<span class="hljs-comment">;</span>
    }
    
    // 最终切换到直流输出
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET)<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-19">5.3 EMI 问题</h4>
<p>推挽电路的快速开关会产生电磁干扰。</p>
<p>在 PCB 设计时，需要注意以下几点：驱动信号走线要短，远离敏感电路；在电源引脚附近放置去耦电容；使用地平面来降低回路面积；必要时可以串联小电阻来降低开关速度。</p>
<h3 data-id="heading-20">6. 总结</h3>
<p>推挽输出电路是嵌入式系统中非常实用的驱动电路。</p>
<p>它具有驱动能力强、效率高、输出阻抗低等优点，广泛应用于 LED 驱动、继电器控制、电机驱动等场合。</p>
<p>在实际设计中，我们需要根据负载特性选择合适的三极管，计算好基极限流电阻，并考虑过流保护、热保护等安全措施。</p>
<p>通过本文的分析和代码示例，相信大家对推挽电路有了更深入的理解。</p>
<p>在实际项目中，建议先在面包板上搭建电路进行测试，确认参数无误后再进行 PCB 设计。</p>
<p>同时，要注意电路的散热设计，必要时加装散热片。</p>
<p>只有把理论和实践结合起来，才能设计出可靠稳定的推挽驱动电路。</p>
<p><strong>更多编程学习资源</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fc_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/c_course_handout_2025.html" ref="nofollow noopener noreferrer">C 语言零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fstm32%2Fstm32_course_handout_2024.html" target="_blank" title="https://www.lxlinux.net/e/stm32/stm32_course_handout_2024.html" ref="nofollow noopener noreferrer">STM32 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Ffreertos%2Ffreertos_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/freertos/freertos_course_handout_2025.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fcpp_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/cpp_course_handout_2025.html" ref="nofollow noopener noreferrer">C++ 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2F51-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/51-learning-path.html" ref="nofollow noopener noreferrer">51 单片机零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fad-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/ad-learning-path.html" ref="nofollow noopener noreferrer">AD 画板零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fc-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/c-learning-path.html" ref="nofollow noopener noreferrer">C 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fcpp-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/cpp-learning-path.html" ref="nofollow noopener noreferrer">C++ 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fesp32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/esp32-learning-path.html" ref="nofollow noopener noreferrer">ESP32 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Ffreertos-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/freertos-learning-path.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-devop-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-devop-learning-path.html" ref="nofollow noopener noreferrer">Linux 应用开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-lower-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-lower-learning-path.html" ref="nofollow noopener noreferrer">Linux 底层开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flvgl-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/lvgl-learning-path.html" ref="nofollow noopener noreferrer">LVGL 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fqt-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/qt-learning-path.html" ref="nofollow noopener noreferrer">QT 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fstm32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/stm32-learning-path.html" ref="nofollow noopener noreferrer">STM32 零基础入门学习路线</a></li>
</ul>
<pre><code class="hljs"/></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端HTML转PDF的两种主流方案深度解析]]></title>    <link>https://juejin.cn/post/7603673564908896291</link>    <guid>https://juejin.cn/post/7603673564908896291</guid>    <pubDate>2026-02-08T06:33:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603673564908896291" data-draft-id="7603671627003756584" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端HTML转PDF的两种主流方案深度解析"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-08T06:33:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹿心肺语"/> <meta itemprop="url" content="https://juejin.cn/user/3030678257798120"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端HTML转PDF的两种主流方案深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3030678257798120/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹿心肺语
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:33:52.000Z" title="Sun Feb 08 2026 06:33:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在现代Web开发中，将网页内容导出为PDF格式的需求越来越普遍。无论是生成电子发票、导出数据报表、制作可打印的文档，还是为用户提供离线阅读的材料，HTML到PDF的转换都是前端开发者必须掌握的技能。本文将深入剖析两种主流的前端PDF生成方案，从原理、实现到最佳实践，帮助你根据实际场景选择最合适的技术路线。</p>
<hr/>
<h2 data-id="heading-1">方案一：浏览器原生打印API</h2>
<h3 data-id="heading-2">核心原理</h3>
<p>浏览器原生打印方案利用了<code>window.print()</code>这一内置API。通过动态创建一个新的浏览器窗口，将需要打印的HTML内容写入该窗口，然后触发浏览器的打印对话框，让用户可以选择"另存为PDF"。这种方法的本质是依赖浏览器自身的渲染引擎和打印能力。</p>
<h3 data-id="heading-3">完整实现代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 使用浏览器原生API生成PDF
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">title</span> - 打印页面的标题
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">style</span> - 需要打印的CSS样式
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">content</span> - 需要打印的HTML内容
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">printToPDF</span>(<span class="hljs-params">title, style, content</span>) {
    <span class="hljs-comment">// 构建完整的HTML文档结构</span>
    <span class="hljs-keyword">const</span> html = <span class="hljs-string">`
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;title&gt;<span class="hljs-subst">${title}</span>&lt;/title&gt;
            &lt;style&gt;
                /* 基础重置样式 */
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
                
                /* 打印优化样式 */
                @media print {
                    body {
                        -webkit-print-color-adjust: exact;
                        print-color-adjust: exact;
                    }
                    
                    /* 避免表格被截断 */
                    table {
                        page-break-inside: avoid;
                    }
                    
                    /* 避免图片被截断 */
                    img {
                        page-break-inside: avoid;
                        max-width: 100%;
                    }
                }
                
                <span class="hljs-subst">${style}</span>
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
            <span class="hljs-subst">${content}</span>
        &lt;/body&gt;
        &lt;/html&gt;
    `</span>;
    
    <span class="hljs-comment">// 创建新窗口</span>
    <span class="hljs-keyword">const</span> printWindow = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">''</span>, <span class="hljs-string">'_blank'</span>);
    
    <span class="hljs-keyword">if</span> (!printWindow) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'弹窗被浏览器拦截，请检查弹窗设置'</span>);
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 写入HTML内容</span>
    printWindow.<span class="hljs-property">document</span>.<span class="hljs-title function_">write</span>(html);
    printWindow.<span class="hljs-property">document</span>.<span class="hljs-title function_">close</span>();
    
    <span class="hljs-comment">// 等待资源加载完成后触发打印</span>
    printWindow.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            printWindow.<span class="hljs-title function_">print</span>();
            <span class="hljs-comment">// 打印完成后可选择关闭窗口</span>
            <span class="hljs-comment">// printWindow.close();</span>
        }, <span class="hljs-number">500</span>);
    };
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> title = <span class="hljs-string">'月度销售报表'</span>;
<span class="hljs-keyword">const</span> style = <span class="hljs-string">`
    .report-header { text-align: center; margin-bottom: 20px; }
    .report-table { width: 100%; border-collapse: collapse; }
    .report-table th, .report-table td { border: 1px solid #ddd; padding: 8px; }
`</span>;
<span class="hljs-keyword">const</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'report-container'</span>).<span class="hljs-property">innerHTML</span>;

<span class="hljs-title function_">printToPDF</span>(title, style, content);
</code></pre>
<h3 data-id="heading-4">关键配置说明</h3>

























<table><thead><tr><th>配置项</th><th>说明</th><th>建议值</th></tr></thead><tbody><tr><td><code>-webkit-print-color-adjust</code></td><td>确保打印时保留背景色和颜色</td><td><code>exact</code></td></tr><tr><td><code>page-break-inside: avoid</code></td><td>防止元素在分页处被截断</td><td>应用于表格、图片</td></tr><tr><td><code>page-break-before/after</code></td><td>控制强制分页位置</td><td>根据内容结构设置</td></tr></tbody></table>
<h3 data-id="heading-5">方案一优缺点分析</h3>
<p><strong>优点：</strong></p>
<ul>
<li><strong>零依赖</strong>：无需引入任何第三方库，减少项目体积</li>
<li><strong>浏览器兼容性好</strong>：所有现代浏览器都支持</li>
<li><strong>用户可控</strong>：用户可以在打印对话框中选择纸张大小、方向、边距等</li>
<li><strong>样式灵活</strong>：可以使用<code>@media print</code>媒体查询专门优化打印样式</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>交互依赖</strong>：必须弹出打印对话框，无法静默生成PDF</li>
<li><strong>样式一致性差</strong>：不同浏览器的打印效果可能存在差异</li>
<li><strong>无法自动下载</strong>：需要用户手动选择"另存为PDF"</li>
<li><strong>分页控制有限</strong>：复杂的分页逻辑难以精确控制</li>
</ul>
<hr/>
<h2 data-id="heading-6">方案二：html2pdf.js库方案</h2>
<h3 data-id="heading-7">核心原理</h3>
<p>html2pdf.js是一个基于<code>html2canvas</code>和<code>jsPDF</code>的封装库。其工作流程分为三步：</p>
<ol>
<li><strong>DOM转Canvas</strong>：使用html2canvas将HTML元素渲染为Canvas图像</li>
<li><strong>Canvas转图像</strong>：将Canvas转换为JPEG/PNG图像数据</li>
<li><strong>图像转PDF</strong>：使用jsPDF将图像数据插入PDF文档</li>
</ol>
<h3 data-id="heading-8">完整实现代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> html2pdf <span class="hljs-keyword">from</span> <span class="hljs-string">'html2pdf.js'</span>;

<span class="hljs-comment">/**
 * 使用html2pdf.js生成PDF
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">HTMLElement</span>} <span class="hljs-variable">element</span> - 需要转换的DOM元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">options</span> - 配置选项
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise</span>} - 返回Promise对象
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePDF</span>(<span class="hljs-params">element, options = {}</span>) {
    <span class="hljs-comment">// 默认配置</span>
    <span class="hljs-keyword">const</span> defaultOptions = {
        <span class="hljs-comment">// PDF基础设置</span>
        <span class="hljs-attr">margin</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],           <span class="hljs-comment">// 上右下左边距（单位：mm）</span>
        <span class="hljs-attr">filename</span>: <span class="hljs-string">'document.pdf'</span>,            <span class="hljs-comment">// 默认文件名</span>
        
        <span class="hljs-comment">// 图像质量设置</span>
        <span class="hljs-attr">image</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'jpeg'</span>,                    <span class="hljs-comment">// 图像格式：jpeg/png</span>
            <span class="hljs-attr">quality</span>: <span class="hljs-number">0.98</span>                    <span class="hljs-comment">// 图像质量：0-1</span>
        },
        
        <span class="hljs-comment">// html2canvas配置</span>
        <span class="hljs-attr">html2canvas</span>: {
            <span class="hljs-attr">scale</span>: <span class="hljs-number">2</span>,                        <span class="hljs-comment">// 缩放倍数，影响清晰度</span>
            <span class="hljs-attr">useCORS</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 允许加载跨域图片</span>
            <span class="hljs-attr">allowTaint</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 允许污染画布（用于跨域图片）</span>
            <span class="hljs-attr">logging</span>: <span class="hljs-literal">false</span>,                  <span class="hljs-comment">// 关闭日志输出</span>
            <span class="hljs-attr">letterRendering</span>: <span class="hljs-literal">true</span>,           <span class="hljs-comment">// 改善文字渲染</span>
            <span class="hljs-attr">dpi</span>: <span class="hljs-number">192</span>                         <span class="hljs-comment">// 图像DPI</span>
        },
        
        <span class="hljs-comment">// jsPDF配置</span>
        <span class="hljs-attr">jsPDF</span>: {
            <span class="hljs-attr">unit</span>: <span class="hljs-string">'mm'</span>,                      <span class="hljs-comment">// 单位：mm/pt/px/in</span>
            <span class="hljs-attr">format</span>: <span class="hljs-string">'a4'</span>,                    <span class="hljs-comment">// 页面格式：a4/letter/legal等</span>
            <span class="hljs-attr">orientation</span>: <span class="hljs-string">'portrait'</span>          <span class="hljs-comment">// 方向：portrait(纵向)/landscape(横向)</span>
        },
        
        <span class="hljs-comment">// 分页控制</span>
        <span class="hljs-attr">pagebreak</span>: {
            <span class="hljs-attr">mode</span>: [<span class="hljs-string">'avoid-all'</span>, <span class="hljs-string">'css'</span>, <span class="hljs-string">'legacy'</span>],
            <span class="hljs-attr">before</span>: <span class="hljs-string">'.page-break-before'</span>,    <span class="hljs-comment">// 在这些元素前强制分页</span>
            <span class="hljs-attr">after</span>: <span class="hljs-string">'.page-break-after'</span>,      <span class="hljs-comment">// 在这些元素后强制分页</span>
            <span class="hljs-attr">avoid</span>: <span class="hljs-string">'img, table, .no-break'</span>   <span class="hljs-comment">// 避免这些元素被分页截断</span>
        }
    };
    
    <span class="hljs-comment">// 合并配置</span>
    <span class="hljs-keyword">const</span> mergedOptions = <span class="hljs-title function_">deepMerge</span>(defaultOptions, options);
    
    <span class="hljs-comment">// 执行转换</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">html2pdf</span>()
        .<span class="hljs-title function_">set</span>(mergedOptions)
        .<span class="hljs-title function_">from</span>(element)
        .<span class="hljs-title function_">save</span>();
}

<span class="hljs-comment">/**
 * 获取PDF的Base64数据（用于上传或预览）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">HTMLElement</span>} <span class="hljs-variable">element</span> - 需要转换的DOM元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">options</span> - 配置选项
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;string&gt;</span>} - 返回Base64编码的PDF数据
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPDFBase64</span>(<span class="hljs-params">element, options = {}</span>) {
    <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">await</span> <span class="hljs-title function_">html2pdf</span>()
        .<span class="hljs-title function_">set</span>(options)
        .<span class="hljs-title function_">from</span>(element)
        .<span class="hljs-title function_">outputPdf</span>(<span class="hljs-string">'datauristring'</span>);
    
    <span class="hljs-keyword">return</span> pdf;
}

<span class="hljs-comment">/**
 * 获取PDF的Blob对象（用于自定义下载逻辑）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">HTMLElement</span>} <span class="hljs-variable">element</span> - 需要转换的DOM元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">options</span> - 配置选项
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;Blob&gt;</span>} - 返回PDF的Blob对象
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPDFBlob</span>(<span class="hljs-params">element, options = {}</span>) {
    <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">await</span> <span class="hljs-title function_">html2pdf</span>()
        .<span class="hljs-title function_">set</span>(options)
        .<span class="hljs-title function_">from</span>(element)
        .<span class="hljs-title function_">outputPdf</span>(<span class="hljs-string">'blob'</span>);
    
    <span class="hljs-keyword">return</span> pdf;
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'invoice-container'</span>);

<span class="hljs-comment">// 基础使用 - 直接下载</span>
<span class="hljs-title function_">generatePDF</span>(element, {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'发票-2024001.pdf'</span>,
    <span class="hljs-attr">margin</span>: [<span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>]
});

<span class="hljs-comment">// 高级使用 - 获取数据后上传</span>
<span class="hljs-title function_">getPDFBase64</span>(element, {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'report.pdf'</span>,
    <span class="hljs-attr">html2canvas</span>: { <span class="hljs-attr">scale</span>: <span class="hljs-number">3</span> },  <span class="hljs-comment">// 更高清晰度</span>
    <span class="hljs-attr">jsPDF</span>: { <span class="hljs-attr">orientation</span>: <span class="hljs-string">'landscape'</span> }  <span class="hljs-comment">// 横向布局</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">base64Data</span> =&gt;</span> {
    <span class="hljs-comment">// 上传到服务器</span>
    <span class="hljs-title function_">uploadToServer</span>(base64Data);
});
</code></pre>
<h3 data-id="heading-9">配置项深度解析</h3>
<h4 data-id="heading-10">1. 清晰度优化</h4>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-attr">html2canvas</span>: {
        <span class="hljs-attr">scale</span>: <span class="hljs-number">3</span>,           <span class="hljs-comment">// 推荐值：2-4，值越大越清晰但性能越差</span>
        <span class="hljs-attr">dpi</span>: <span class="hljs-number">300</span>,           <span class="hljs-comment">// 打印级清晰度</span>
        <span class="hljs-attr">letterRendering</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 改善小字体渲染</span>
    }
}
</code></pre>
<h4 data-id="heading-11">2. 分页控制策略</h4>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* CSS方式控制分页 */</span>
<span class="hljs-selector-class">.page-break-before</span> {
    <span class="hljs-attribute">page-break-before</span>: always;
}

<span class="hljs-selector-class">.page-break-after</span> {
    <span class="hljs-attribute">page-break-after</span>: always;
}

<span class="hljs-selector-class">.no-break</span> {
    <span class="hljs-attribute">page-break-inside</span>: avoid;
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-attr">pagebreak</span>: {
        <span class="hljs-attr">mode</span>: [<span class="hljs-string">'avoid-all'</span>, <span class="hljs-string">'css'</span>, <span class="hljs-string">'legacy'</span>],
        <span class="hljs-comment">// avoid-all: 尽可能避免元素被截断</span>
        <span class="hljs-comment">// css: 尊重CSS的page-break属性</span>
        <span class="hljs-comment">// legacy: 使用旧版分页算法</span>
    }
}
</code></pre>
<h4 data-id="heading-12">3. 跨域图片处理</h4>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-attr">html2canvas</span>: {
        <span class="hljs-attr">useCORS</span>: <span class="hljs-literal">true</span>,       <span class="hljs-comment">// 尝试使用CORS加载跨域图片</span>
        <span class="hljs-attr">allowTaint</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 允许污染画布（如果CORS失败）</span>
        <span class="hljs-attr">proxy</span>: <span class="hljs-string">'/api/proxy'</span>  <span class="hljs-comment">// 图片代理服务地址</span>
    }
}
</code></pre>
<h3 data-id="heading-13">方案二优缺点分析</h3>
<p><strong>优点：</strong></p>
<ul>
<li><strong>静默生成</strong>：无需用户交互，可自动下载或上传</li>
<li><strong>效果一致</strong>：不受浏览器打印设置影响，输出稳定</li>
<li><strong>程序化控制</strong>：可通过代码精确控制生成过程</li>
<li><strong>支持异步</strong>：可集成到自动化流程中</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>体积较大</strong>：需要引入第三方库（约200KB+）</li>
<li><strong>性能开销</strong>：大页面转换可能较慢，会阻塞主线程</li>
<li><strong>文字可选性</strong>：生成的PDF中文字是图像，无法选择复制</li>
<li><strong>复杂样式限制</strong>：某些CSS特性（如flexbox、grid）可能渲染不准确</li>
</ul>
<hr/>
<h2 data-id="heading-14">方案对比与选型指南</h2>























































<table><thead><tr><th>对比维度</th><th>浏览器原生打印</th><th>html2pdf.js</th></tr></thead><tbody><tr><td><strong>依赖体积</strong></td><td>0KB</td><td>~200KB+</td></tr><tr><td><strong>用户交互</strong></td><td>需要</td><td>不需要</td></tr><tr><td><strong>生成速度</strong></td><td>快</td><td>较慢（取决于内容大小）</td></tr><tr><td><strong>输出一致性</strong></td><td>浏览器依赖</td><td>高度一致</td></tr><tr><td><strong>文字可选性</strong></td><td>支持</td><td>不支持（文字为图像）</td></tr><tr><td><strong>分页控制</strong></td><td>有限</td><td>灵活</td></tr><tr><td><strong>跨域图片</strong></td><td>支持</td><td>需特殊配置</td></tr><tr><td><strong>自动化集成</strong></td><td>困难</td><td>容易</td></tr><tr><td><strong>浏览器兼容性</strong></td><td>优秀</td><td>良好</td></tr></tbody></table>
<h3 data-id="heading-15">选型建议</h3>
<p><strong>选择浏览器原生打印的场景：</strong></p>
<ul>
<li>需要用户自定义打印设置（纸张、边距等）</li>
<li>对PDF文件大小敏感</li>
<li>需要生成的PDF中文字可选择、可复制</li>
<li>项目对第三方依赖有严格限制</li>
</ul>
<p><strong>选择html2pdf.js的场景：</strong></p>
<ul>
<li>需要静默生成PDF，不打扰用户</li>
<li>需要自动上传PDF到服务器</li>
<li>对输出效果的一致性要求高</li>
<li>需要集成到自动化工作流中</li>
</ul>
<hr/>
<h2 data-id="heading-16">最佳实践与常见问题</h2>
<h3 data-id="heading-17">1. 打印样式优化</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 打印专用样式表 */</span>
<span class="hljs-keyword">@media</span> print {
    <span class="hljs-comment">/* 隐藏不需要打印的元素 */</span>
    <span class="hljs-selector-class">.no-print</span>,
    <span class="hljs-selector-class">.navbar</span>,
    <span class="hljs-selector-class">.sidebar</span>,
    <span class="hljs-selector-class">.actions</span> {
        <span class="hljs-attribute">display</span>: none <span class="hljs-meta">!important</span>;
    }
    
    <span class="hljs-comment">/* 确保背景色打印 */</span>
    * {
        -webkit-print-<span class="hljs-attribute">color</span>-adjust: exact <span class="hljs-meta">!important</span>;
        print-<span class="hljs-attribute">color</span>-adjust: exact <span class="hljs-meta">!important</span>;
    }
    
    <span class="hljs-comment">/* 链接显示URL */</span>
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span><span class="hljs-selector-pseudo">:after</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-string">" ("</span> <span class="hljs-built_in">attr</span>(href) <span class="hljs-string">")"</span>;
    }
    
    <span class="hljs-comment">/* 表格优化 */</span>
    <span class="hljs-selector-tag">table</span> {
        <span class="hljs-attribute">page-break-inside</span>: avoid;
        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12pt</span>;
    }
    
    <span class="hljs-comment">/* 分页控制 */</span>
    <span class="hljs-selector-class">.page-break</span> {
        <span class="hljs-attribute">page-break-after</span>: always;
    }
}
</code></pre>
<h3 data-id="heading-18">2. 大页面性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 分块处理大页面</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateLargePDF</span>(<span class="hljs-params">container</span>) {
    <span class="hljs-keyword">const</span> pages = container.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.page'</span>);
    <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">new</span> <span class="hljs-title function_">jsPDF</span>(<span class="hljs-string">'p'</span>, <span class="hljs-string">'mm'</span>, <span class="hljs-string">'a4'</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pages.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-comment">// 使用requestIdleCallback避免阻塞UI</span>
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
            <span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">await</span> <span class="hljs-title function_">html2canvas</span>(pages[i], { <span class="hljs-attr">scale</span>: <span class="hljs-number">2</span> });
                <span class="hljs-keyword">const</span> imgData = canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">'image/jpeg'</span>, <span class="hljs-number">0.95</span>);
                
                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) pdf.<span class="hljs-title function_">addPage</span>();
                pdf.<span class="hljs-title function_">addImage</span>(imgData, <span class="hljs-string">'JPEG'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">210</span>, <span class="hljs-number">297</span>);
                
                <span class="hljs-title function_">resolve</span>();
            });
        });
    }
    
    pdf.<span class="hljs-title function_">save</span>(<span class="hljs-string">'large-document.pdf'</span>);
}
</code></pre>
<h3 data-id="heading-19">3. 常见问题解决方案</h3>
<p><strong>Q: 生成的PDF中文字模糊？</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 提高scale值和DPI</span>
<span class="hljs-attr">html2canvas</span>: {
    <span class="hljs-attr">scale</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">dpi</span>: <span class="hljs-number">300</span>,
    <span class="hljs-attr">letterRendering</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<p><strong>Q: 跨域图片无法显示？</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 方案1：配置CORS</span>
<span class="hljs-attr">html2canvas</span>: {
    <span class="hljs-attr">useCORS</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">allowTaint</span>: <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// 方案2：使用图片代理</span>
<span class="hljs-attr">html2canvas</span>: {
    <span class="hljs-attr">proxy</span>: <span class="hljs-string">'https://your-domain.com/image-proxy'</span>
}

<span class="hljs-comment">// 方案3：将图片转为Base64</span>
<span class="hljs-keyword">const</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'img'</span>);
<span class="hljs-title function_">fetch</span>(img.<span class="hljs-property">src</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">blob</span>())
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">blob</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();
        reader.<span class="hljs-property">onloadend</span> = <span class="hljs-function">() =&gt;</span> {
            img.<span class="hljs-property">src</span> = reader.<span class="hljs-property">result</span>;
        };
        reader.<span class="hljs-title function_">readAsDataURL</span>(blob);
    });
</code></pre>
<p><strong>Q: 表格被分页截断？</strong></p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 为表格容器添加保护 */</span>
<span class="hljs-selector-class">.table-wrapper</span> {
    <span class="hljs-attribute">page-break-inside</span>: avoid;
}

<span class="hljs-comment">/* 或使用html2pdf的分页配置 */</span>
pagebreak: {
    avoid: <span class="hljs-string">'table, tr'</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-20">总结</h2>
<p>前端HTML转PDF的两种主流方案各有优劣：</p>
<ul>
<li><strong>浏览器原生打印</strong>适合需要用户参与、对文件大小敏感、需要文字可选的场景</li>
<li><strong>html2pdf.js</strong>适合需要自动化、对输出一致性要求高的场景</li>
</ul>
<p>在实际项目中，可以根据具体需求选择单一方案或组合使用。例如，可以提供"打印"按钮使用原生方案，同时提供"下载PDF"按钮使用html2pdf.js方案，让用户自主选择。</p>
<p>随着Web技术的发展，新的方案如Chrome的Headless打印、Puppeteer等服务端方案也在兴起。但对于纯前端场景，本文介绍的两种方案仍然是最实用、最成熟的选择。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CSS盒模型实战：用代码透视 `border-box`与 `content-box`的天壤之别]]></title>    <link>https://juejin.cn/post/7603643385816842292</link>    <guid>https://juejin.cn/post/7603643385816842292</guid>    <pubDate>2026-02-08T06:57:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816842292" data-draft-id="7603643385816825908" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CSS盒模型实战：用代码透视 `border-box`与 `content-box`的天壤之别"/> <meta itemprop="keywords" content="CSS"/> <meta itemprop="datePublished" content="2026-02-08T06:57:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lee川"/> <meta itemprop="url" content="https://juejin.cn/user/2402874087453658"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CSS盒模型实战：用代码透视 `border-box`与 `content-box`的天壤之别
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2402874087453658/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lee川
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:57:33.000Z" title="Sun Feb 08 2026 06:57:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0"><strong>CSS盒模型实战：用代码透视 <code>border-box</code>与 <code>content-box</code>的天壤之别</strong></h3>
<p>理解CSS盒模型是前端布局的必修课，而 <code>box-sizing</code>属性则是掌控盒模型计算规则的钥匙。本文将通过您文档中生动的代码示例，直观展示其核心区别。</p>
<h4 data-id="heading-1"><strong>场景一：标准盒模型的“扩张”困扰（<code>content-box</code>）</strong></h4>
<p>在默认的 <code>content-box</code>模型下，您为元素设置的 <code>width</code>和 <code>height</code>仅作用于其<strong>内容区域</strong>。让我们看一个例子：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.content-box</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-comment">/* 仅指内容的宽度 */</span>
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;      <span class="hljs-comment">/* 仅指内容的高度 */</span>
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;      <span class="hljs-comment">/* 内边距 */</span>
            <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black; <span class="hljs-comment">/* 边框 */</span>
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;       <span class="hljs-comment">/* 外边距 */</span>
            <span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 这是默认值，也可不写 */</span>
            <span class="hljs-attribute">background-color</span>: lightgreen;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box content-box"</span>&gt;</span>Box with content-box<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>关键代码分析</strong>：</p>
<ul>
<li><code>width: 200px; height: 100px;</code>：这里定义的仅仅是绿色内容区域的尺寸。</li>
<li>添加的 <code>padding</code>和 <code>border</code>会<strong>向外扩张</strong>盒子的总尺寸。</li>
</ul>
<p><strong>计算结果</strong>：</p>
<ul>
<li>盒子的<strong>总宽度</strong>​ = <code>200(width) + 20 * 2(padding) + 5 * 2(border) = 250px</code></li>
<li>盒子的<strong>总高度</strong>​ = <code>100(height) + 20 * 2(padding) + 5 * 2(border) = 150px</code></li>
</ul>
<p>此时，盒子在页面上的实际占位是 250px * 150px，远大于你直觉上认为的 200px * 100px。这在多列布局时极易导致意外换行或溢出。</p>
<h4 data-id="heading-2"><strong>场景二：怪异盒模型的“收缩”智慧（<code>border-box</code>）</strong></h4>
<p>为了解决上述问题，<code>border-box</code>模型采用了更直观的计算方式：你设定的 <code>width</code>和 <code>height</code>直接定义了这个盒子的<strong>总边框盒尺寸</strong>。对比示例：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.border-box</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-comment">/* 指整个盒子的总宽度！ */</span>
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;      <span class="hljs-comment">/* 指整个盒子的总高度！ */</span>
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 核心：切换为 border-box */</span>
            <span class="hljs-attribute">background-color</span>: lightblue;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box border-box"</span>&gt;</span>Box with border-box<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>关键代码分析</strong>：</p>
<ul>
<li>同样的 <code>width: 200px; height: 100px;</code>声明，但因为 <code>box-sizing: border-box;</code>的存在，这里的 200px 和 100px 被解释为<strong>包含内容、内边距和边框的总尺寸</strong>。</li>
<li>添加的 <code>padding</code>和 <code>border</code>会<strong>向内挤压</strong>内容区域的空间。</li>
</ul>
<p><strong>计算结果</strong>：</p>
<ul>
<li>盒子的<strong>总宽度</strong>​ = <code>200px</code>（由 <code>width</code>直接定义）</li>
<li>盒子的<strong>总高度</strong>​ = <code>100px</code>（由 <code>height</code>直接定义）</li>
<li>内容区域的<strong>实际宽度</strong>​ = <code>200 - 20 * 2 - 5 * 2 = 150px</code></li>
<li>内容区域的<strong>实际高度</strong>​ = <code>100 - 20 * 2 - 5 * 2 = 50px</code></li>
</ul>
<p>无论你如何调整 <code>padding</code>和 <code>border</code>，这个浅蓝色盒子的<strong>外轮廓</strong>都严格保持为你设定的 200px * 100px，这使得精确控制布局变得轻而易举。</p>
<h4 data-id="heading-3"><strong>实战应用：为什么 <code>border-box</code>是布局神器</strong></h4>
<p>让我们看一个经典应用场景——创建两个等宽并列的盒子：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">1200px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
        }
        <span class="hljs-selector-class">.box</span> {
            <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 使用 border-box 模型 */</span>
            <span class="hljs-attribute">width</span>: <span class="hljs-number">580px</span>; <span class="hljs-comment">/* 总宽580px */</span>
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 左右外边距各10px */</span>
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>; <span class="hljs-comment">/* 边框 */</span>
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <span class="hljs-comment">/* 内边距 */</span>
            <span class="hljs-attribute">display</span>: inline-block;
            <span class="hljs-attribute">background-color</span>: green;
        }
        <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) {
            <span class="hljs-attribute">background-color</span>: yellow;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>核心优势解析</strong>：</p>
<ol>
<li>
<p><strong>尺寸可预测</strong>：每个 <code>.box</code>的总宽度是明确的 580px，无论其 <code>border</code>和 <code>padding</code>如何变化。</p>
</li>
<li>
<p><strong>布局计算简单</strong>：</p>
<ul>
<li>单个盒子占位：<code>580px(width) + 10 * 2(margin) = 600px</code></li>
<li>两个盒子总占位：<code>600px + 600px = 1200px</code></li>
<li>容器宽度为 1200px，完美容纳。</li>
</ul>
</li>
</ol>
<p><strong>如果此处使用 <code>content-box</code>，会发生什么？</strong></p>
<p>每个盒子的实际总宽度会变成：<code>580(width) + 5 * 2(padding) + 1 * 2(border) = 592px</code>，再加上左右 <code>margin</code>各10px，单个盒子就占用了 <code>612px</code>，两个盒子就需要 <code>1224px</code>，会立即撑破 <code>1200px</code>的容器，导致第二个盒子掉到下一行。<code>border-box</code>彻底避免了这种烦人的计算。</p>
<h4 data-id="heading-4"><strong>总结与最佳实践</strong></h4>
<p>通过以上代码的对比演示，可以清晰地看到：</p>
<ul>
<li>**<code>content-box</code>**​ 是“加法模型”（<code>实际尺寸 = 设定尺寸 + padding + border</code>），易导致布局失控。</li>
<li>**<code>border-box</code>**​ 是“减法模型”（<code>内容尺寸 = 设定尺寸 - padding - border</code>），让元素的占位尺寸完全可预测。</li>
</ul>
<p>因此，在现代前端开发中，一个公认的最佳实践是在CSS起始位置就全局应用 <code>border-box</code>模型：</p>
<pre><code class="hljs language-css" lang="css">*,
*<span class="hljs-selector-pseudo">::before</span>,
*<span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">box-sizing</span>: border-box;
}
</code></pre>
<p>这条简单的规则，能让你在后续的整个开发过程中，彻底告别因 <code>padding</code>和 <code>border</code>导致的布局尺寸计算烦恼，将更多精力投入到创意和逻辑的实现中。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Flux方法总结]]></title>    <link>https://juejin.cn/post/7603643385816547380</link>    <guid>https://juejin.cn/post/7603643385816547380</guid>    <pubDate>2026-02-08T03:51:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816547380" data-draft-id="7603673564908683299" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Flux方法总结"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T03:51:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Luke君60797"/> <meta itemprop="url" content="https://juejin.cn/user/3632442148656990"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Flux方法总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3632442148656990/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Luke君60797
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:51:18.000Z" title="Sun Feb 08 2026 03:51:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>Flux</code> 的方法非常多（几百个），但你不需要全部记住。我们可以把它们按照“功能”分成几类，就像厨房里不同的工具：</p>
<h3 data-id="heading-0">1. 制造水源（创建操作符）</h3>
<p>用来定义流量的来源。</p>
<ul>
<li><strong><code>just(T... data)</code></strong> ：最直接的，把现成的数据塞进去。</li>
<li><strong><code>fromIterable(Iterable)</code></strong> ：把 <code>List</code> 或 <code>Set</code> 变成 <code>Flux</code>。</li>
<li><strong><code>range(int start, int count)</code></strong> ：生成一个整数序列（如 1 到 100）。</li>
<li><strong><code>interval(Duration)</code></strong> ：<strong>定时器</strong>。每隔一段时间发一个数字（0, 1, 2...），常用于心跳检测。</li>
<li><strong><code>empty()</code></strong> ：直接发送完成信号，水管里啥也没有。</li>
<li><strong><code>error(Throwable)</code></strong> ：直接发送错误信号，水管一通就爆。</li>
</ul>
<hr/>
<h3 data-id="heading-1">2. 加工转换（转化操作符）</h3>
<p>最常用的部分，用来改变流里的数据。</p>
<ul>
<li>
<p><strong><code>map(Function)</code></strong> ：<strong>1对1转换</strong>。把 A 变成 B（如：把“洗洁精”字符串变成 <code>Soap</code> 对象）。</p>
</li>
<li>
<p><strong><code>flatMap(Function)</code></strong> ：<strong>1对N转换（异步）</strong> 。把一个元素变成一个新的 <code>Flux</code>。</p>
<blockquote>
<p><em>比喻：<code>map</code> 是把菜切碎；<code>flatMap</code> 是把一个订单拆成多个物流单，并异步去查每一个物流。</em></p>
</blockquote>
</li>
<li>
<p><strong><code>buffer(int n)</code></strong> ：<strong>打包</strong>。把零散的水滴收集满 <code>n</code> 个，凑成一个 <code>List</code> 再往下流。</p>
</li>
<li>
<p><strong><code>collectList()</code></strong> ：把水管里所有的水都接住，最后装进一个 <code>Mono&lt;List&lt;T&gt;&gt;</code>。</p>
</li>
</ul>
<hr/>
<h3 data-id="heading-2">3. 过滤与挑选（过滤操作符）</h3>
<p>决定哪些东西能流过去。</p>
<ul>
<li><strong><code>filter(Predicate)</code></strong> ：符合条件的才让过。</li>
<li><strong><code>distinct()</code></strong> ：<strong>去重</strong>。流过的东西如果重复，只放行第一个。</li>
<li><strong><code>take(long n)</code></strong> ：<strong>只取前 n 个</strong>。拿完就关水龙头。</li>
<li><strong><code>skip(long n)</code></strong> ：跳过前 n 个，从后面开始接。</li>
</ul>
<hr/>
<h3 data-id="heading-3">4. 组合流（组合操作符）</h3>
<p>把多根水管拼在一起。</p>
<ul>
<li>
<p><strong><code>mergeWith(Publisher)</code></strong> ：<strong>合并</strong>。两根管子汇成一根，谁有水谁先流（交错输出）。</p>
</li>
<li>
<p><strong><code>zipWith(Publisher)</code></strong> ：<strong>配对</strong>。左边流出一滴，右边流出一滴，凑成一对（Tuple）再往下走。</p>
<blockquote>
<p><em>比喻：<code>merge</code> 是合流，<code>zip</code> 是相亲，必须两边都有人才成对。</em></p>
</blockquote>
</li>
<li>
<p><strong><code>concatWith(Publisher)</code></strong> ：<strong>首尾相接</strong>。等第一根管子流完了，才开始流第二根。</p>
</li>
</ul>
<hr/>
<h3 data-id="heading-4">5. 副作用与生命周期（监听操作符）</h3>
<p>只观察，不干预。</p>
<ul>
<li><strong><code>doOnNext(Consumer)</code></strong> ：数据流过时看一眼（打日志）。</li>
<li><strong><code>doOnError(Consumer)</code></strong> ：出故障时看一眼。</li>
<li><strong><code>doOnComplete(Runnable)</code></strong> ：流完时看一眼。</li>
<li><strong><code>doFinally(Consumer)</code></strong> ：管它成功还是失败，最后都要执行（类似 <code>finally</code> 块）。</li>
</ul>
<hr/>
<h3 data-id="heading-5">6. 错误处理（容错操作符）</h3>
<p>水管爆了之后的救场方案。</p>
<ul>
<li><strong><code>onErrorReturn(T)</code></strong> ：出错了？别报警，直接返回一个默认值。</li>
<li><strong><code>onErrorResume(Function)</code></strong> ：出错了？切到备用水管（另一个 <code>Flux</code>）。</li>
<li><strong><code>retry(long n)</code></strong> ：出错了？再试 <code>n</code> 次。</li>
</ul>
<hr/>
<h3 data-id="heading-6">总结</h3>
<ul>
<li>如果你要<strong>改变</strong>数据：找 <code>map</code>/<code>flatMap</code>。</li>
<li>如果你要<strong>减少</strong>数据：找 <code>filter</code>/<code>take</code>。</li>
<li>如果你要<strong>合并</strong>数据：找 <code>zip</code>/<code>merge</code>。</li>
<li>如果你要<strong>观察</strong>数据：找 <code>doOn...</code> 系列。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[高版本 MySQL 驱动的 DNS 陷阱]]></title>    <link>https://juejin.cn/post/7603674653153525769</link>    <guid>https://juejin.cn/post/7603674653153525769</guid>    <pubDate>2026-02-08T04:24:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153525769" data-draft-id="7603674653153476617" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="高版本 MySQL 驱动的 DNS 陷阱"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T04:24:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="define9527"/> <meta itemprop="url" content="https://juejin.cn/user/414960194946937"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            高版本 MySQL 驱动的 DNS 陷阱
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/414960194946937/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    define9527
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:24:35.000Z" title="Sun Feb 08 2026 04:24:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>项目使用 OceanBase 数据库，并通过 ShardingSphere JDBC 实现分表。由于 ShardingSphere 当前不支持 <code>jdbc:oceanbase:</code> 协议，我们在代码中将连接串替换为 <code>jdbc:mysql</code> 并引入 MySQL 驱动</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.oceanbase<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>oceanbase-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shardingsphere-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 问题根源 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>数据源配置如下（关键部分）</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.oceanbase.jdbc.Driver</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:oceanbase:loadbalance://IP:PORT/test?...</span>
    <span class="hljs-attr">druid:</span>
      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">8</span>
      <span class="hljs-attr">max-active:</span> <span class="hljs-number">30</span>
      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">8</span>
</code></pre>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingDataSourceConfiguration</span> {

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${spring.datasource.url}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> url;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${spring.datasource.username}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> username;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${spring.datasource.password}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> password;

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">DataSource</span>&gt; <span class="hljs-title function_">createDataSourceMap</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">DataSource</span>&gt; dataSourceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-title class_">DruidDataSource</span> dataSource1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();
        dataSource1.<span class="hljs-title function_">setDriverClassName</span>(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);
        url = url.<span class="hljs-title function_">replace</span>(<span class="hljs-string">"jdbc:oceanbase"</span>, <span class="hljs-string">"jdbc:mysql"</span>);
        dataSource1.<span class="hljs-title function_">setUrl</span>(url);
        dataSource1.<span class="hljs-title function_">setUsername</span>(username);
        dataSource1.<span class="hljs-title function_">setPassword</span>(password);
        dataSource1.<span class="hljs-title function_">setInitialSize</span>(<span class="hljs-number">8</span>);
        dataSource1.<span class="hljs-title function_">setMaxActive</span>(<span class="hljs-number">30</span>);
        dataSource1.<span class="hljs-title function_">setMinIdle</span>(<span class="hljs-number">8</span>);
        dataSourceMap.<span class="hljs-title function_">put</span>(<span class="hljs-string">"ds_0"</span>, dataSource1);
        <span class="hljs-keyword">return</span> dataSourceMap;
    }

    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"shardingDataSource"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DataSource</span> <span class="hljs-title function_">dataSource</span>() throws <span class="hljs-title class_">SQLException</span> {
        <span class="hljs-title class_">Properties</span> props = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        props.<span class="hljs-title function_">put</span>(<span class="hljs-string">"sql-show"</span>, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ShardingSphereDataSourceFactory</span>.<span class="hljs-title function_">createDataSource</span>(
            <span class="hljs-title function_">createDataSourceMap</span>(),
            <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(<span class="hljs-title function_">createShardingRuleConfiguration</span>()),
            props
        );
    }
}
</code></pre>
<p>同时，项目中还有一个未经过 ShardingSphere 的原生 OceanBase 数据源</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfiguration</span> {

    <span class="hljs-meta">@Bean(name = <span class="hljs-string">"logAnalysisDataSource"</span>)</span>
    <span class="hljs-keyword">public</span> DataSource logAnalysisDataSource() {
        <span class="hljs-comment">// com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder</span>
        <span class="hljs-comment">// 使用 spring.datasource 配置来创建数据库连接池</span>
        DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
        druidDataSource.setSocketTimeout(<span class="hljs-number">180000</span>);
        druidDataSource.setConnectTimeout(<span class="hljs-number">180000</span>);
        <span class="hljs-keyword">return</span> druidDataSource;
    }
}
</code></pre>
<h2 data-id="heading-1">问题现象</h2>
<p>启动项目时，发现 <code>@Bean("shardingDataSource")</code> 所对应的 DruidDataSource 初始化时间特别长，但 <code>@Bean(name = "logAnalysisDataSource")</code> 所对应的 DruidDataSource 初始化却很快</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[2026-02-07 17:47:32.417]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[80]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Starting...]</span>
<span class="hljs-selector-attr">[2026-02-07 17:47:32.739]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[82]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Start completed.]</span>

<span class="hljs-selector-attr">[2026-02-07 17:50:22.107]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-1} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 17:50:34.454]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-2} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 17:50:35.840]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.xxx.WebApplication]</span> <span class="hljs-selector-attr">[61]</span> - <span class="hljs-selector-attr">[Started WebApplication in 188.327 seconds (JVM running for 189.054)]</span>
</code></pre>
<blockquote>
<p>日志中的 HikariDataSource 是 ShardingSphere JDBC 用于操作元数据的内部连接池，其初始化完成至 DruidDataSource#init 执行前的耗时可忽略不计</p>
</blockquote>
<p>启动日志中，<code>{dataSource-1}</code> 对应 <code>@Bean("shardingDataSource")</code>，<code>{dataSource-2}</code> 对应 <code>@Bean(name = "logAnalysisDataSource")</code></p>
<p>从日志可以看出，<code>@Bean("shardingDataSource")</code> 这个 DruidDataSource 对象的初始化时间为 2 分 50 秒，而 <code>@Bean(name = "logAnalysisDataSource")</code> 这个 DruidDataSource 对象的初始化时间为 12 秒，而两者唯一的区别在于底层 JDBC 驱动</p>
<blockquote>
<p>备注：因项目开发环境位于内网，且数据库部署于不同地域，网络延迟较高，数据库连接池初始化耗时 12 秒属正常范围</p>
</blockquote>
<p>跟踪 Druid 源码发现，耗时主要集中在 <code>createPhysicalConnection()</code> 方法执行过程中，该方法负责建立底层物理数据库连接</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidDataSource</span> <span class="hljs-title">extends</span> <span class="hljs-title">DruidAbstractDataSource</span> <span class="hljs-title">implements</span> <span class="hljs-title">DruidDataSourceMBean</span>, <span class="hljs-type">ManagedDataSource</span>, <span class="hljs-type">Referenceable</span>, <span class="hljs-type">Closeable</span>, <span class="hljs-type">Cloneable</span>, <span class="hljs-type">ConnectionPoolDataSource</span>, <span class="hljs-type">MBeanRegistration</span> {

    <span class="hljs-keyword">public</span> void <span class="hljs-keyword">init</span>() throws SQLException {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (createScheduler != <span class="hljs-literal">null</span> &amp;&amp; asyncInit) {
                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; initialSize; ++i) {
                    submitCreateTask(<span class="hljs-literal">true</span>);
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!asyncInit) {
                <span class="hljs-comment">// init connections</span>
                <span class="hljs-keyword">while</span> (poolingCount &lt; initialSize) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 慢在这里</span>
                        PhysicalConnectionInfo pyConnectInfo = createPhysicalConnection();
                        DruidConnectionHolder holder = new DruidConnectionHolder(<span class="hljs-keyword">this</span>, pyConnectInfo);
                        connections[poolingCount++] = holder;
                    } <span class="hljs-keyword">catch</span> (SQLException ex) {

                    }
                }
            }
        } <span class="hljs-keyword">finally</span> {
            inited = <span class="hljs-literal">true</span>;
            lock.unlock();
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">init</span> &amp;&amp; LOG.isInfoEnabled()) {
                String msg = <span class="hljs-string">"{dataSource-"</span> + <span class="hljs-keyword">this</span>.getID();
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.name.isEmpty()) {
                    msg += <span class="hljs-string">","</span>;
                    msg += <span class="hljs-keyword">this</span>.name;
                }
                msg += <span class="hljs-string">"} inited"</span>;
                <span class="hljs-comment">// 打印日志</span>
                LOG.info(msg);
            }
        }
    }
}
</code></pre>
<p>继续跟踪源码，最终定位到问题源于 MySQL 驱动在创建连接时调用 <code>InetSocketAddress.getHostName()</code> 进行反向 DNS 解析，耗时显著，导致连接初始化缓慢</p>
<p>完整的链路：<code>DruidAbstractDataSource#createPhysicalConnection</code> =&gt; ... =&gt; <code>com.mysql.cj.jdbc.ConnectionImpl#getInstance(HostInfo hostInfo)</code> =&gt; <code>ConnectionImpl</code> 构造方法</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.mysql.cj.jdbc;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">JdbcConnection</span>, <span class="hljs-type">SessionEventListener</span>, <span class="hljs-type">Serializable</span> {
    <span class="hljs-keyword">public</span> ConnectionImpl(HostInfo hostInfo) throws SQLException {
        <span class="hljs-keyword">try</span> {
            SocketAddress socketAddress = <span class="hljs-keyword">this</span>.session.getRemoteSocketAddress();
            <span class="hljs-keyword">if</span> (InetSocketAddress.<span class="hljs-keyword">class</span>.isInstance(socketAddress)) {
                InetSocketAddress inetSocketAddress = (InetSocketAddress) socketAddress;
                <span class="hljs-comment">// 关键</span>
                <span class="hljs-keyword">this</span>.connectionSpan.setAttribute(
                    TelemetryAttribute.NETWORK_PEER_ADDRESS,
                    <span class="hljs-comment">// 获取 hostname 字段值</span>
                    inetSocketAddress.getHostName()
                );
            }
        }
    }
}
</code></pre>

<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> java.net;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InetSocketAddress</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SocketAddress</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> InetSocketAddressHolder holder;

    <span class="hljs-comment">// Private implementation class pointed to by all public methods.</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InetSocketAddressHolder</span> {
        <span class="hljs-comment">// The hostname of the Socket Address</span>
        <span class="hljs-keyword">private</span> String hostname;
        <span class="hljs-comment">// The IP address of the Socket Address</span>
        <span class="hljs-keyword">private</span> InetAddress addr;
        <span class="hljs-comment">// The port number of the Socket Address</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;

        <span class="hljs-keyword">private</span> <span class="hljs-title function_">InetSocketAddressHolder</span><span class="hljs-params">(String hostname, InetAddress addr, <span class="hljs-type">int</span> port)</span> {
            <span class="hljs-built_in">this</span>.hostname = hostname;
            <span class="hljs-built_in">this</span>.addr = addr;
            <span class="hljs-built_in">this</span>.port = port;
        }

        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPort</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> port;
        }

        <span class="hljs-keyword">private</span> InetAddress <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> addr;
        }

        <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getHostName</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">if</span> (hostname != <span class="hljs-literal">null</span>)
                <span class="hljs-keyword">return</span> hostname;
            <span class="hljs-keyword">if</span> (addr != <span class="hljs-literal">null</span>)
                <span class="hljs-comment">// ⚠️ 触发反向 DNS 解析！内网无 DNS 服务 → 阻塞超时</span>
                <span class="hljs-keyword">return</span> addr.getHostName();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }

    <span class="hljs-comment">/**
     * Gets the {<span class="hljs-doctag">@code</span> hostname}.
     * Note: This method may trigger a name service reverse lookup if the
     * address was created with a literal IP address.
     *
     * <span class="hljs-doctag">@return</span>  the hostname part of the address.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getHostName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> holder.getHostName();
    }
}
</code></pre>
<p>在网上搜了下，有如下的文章片段</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 解决 Linux 上 Java 获取 hostname 很慢的问题</span>

在 Linux 环境中运行 Java 应用时，有时会遇到 <span class="hljs-code">`InetAddress.getLocalHost().getHostName()`</span> 方法执行缓慢的问题，严重影响应用启动速度

<span class="hljs-section">## 问题原因</span>
Java 在调用 <span class="hljs-code">`getHostName()`</span> 时，会尝试对本机 IP 地址进行<span class="hljs-strong">**反向 DNS 解析（PTR 查询）**</span>，以获取主机名，若 DNS 服务器不可达、无 PTR 记录或网络延迟高，该操作将长时间阻塞

<span class="hljs-section">## 常见场景</span>
<span class="hljs-bullet">-</span> Docker / K8S 容器中未配置 DNS
<span class="hljs-bullet">-</span> 内部网络无反向解析支持
<span class="hljs-bullet">-</span> 使用纯 IP 地址连接数据库（如 MySQL）
</code></pre>
<p>真相大白！我的项目开发环境位于公司内网，完全无法访问外网，更无外部 DNS 服务支持，以下为尝试 ping 外网的输出结果</p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-variable">$ </span>ping www.baidu.com
<span class="hljs-title class_">Ping</span> 请求找不到主机 www.baidu.com。请检查该名称，然后重试。
</code></pre>
<p>那怎么解释 <code>@Bean(name = "logAnalysisDataSource")</code> 这个 DruidDataSource 对象的初始化时间仅 12 秒呢？这是因为它使用的是 <code>jdbc:oceanbase</code> 协议与 <code>oceanbase-client</code> 驱动，这个驱动在连接建立过程中不会调用 <code>InetSocketAddress.getHostName()</code> 方法（没看源码，仅为猜测，但八九不离十）</p>
<p>如何解决这个问题呢？有如下两种方法（网上说添加几个 JVM 参数就能解决，实测无效）</p>
<blockquote>
<p>上述问题在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_33919114%2Farticle%2Fdetails%2F143167989" target="_blank" title="https://blog.csdn.net/qq_33919114/article/details/143167989" ref="nofollow noopener noreferrer">SpringBoot 3 Druid 启动慢排查，SpringBoot 启动慢、服务偶发接口慢查询，MySQL Connector-j 9.0.0 版本问题，getHostName() 请求慢</a> 这篇文章中也提到了</p>
</blockquote>
<h2 data-id="heading-2">解决办法一：修改 hosts 文件</h2>
<ul>
<li>修改 hosts 文件，添加域名映射</li>
</ul>

<pre><code class="hljs language-makefile" lang="makefile">10.xxx.xxx.146 www.<span class="hljs-keyword">define</span>.com
</code></pre>
<ul>
<li>从启动日志可以看出，问题完美解决</li>
</ul>

<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[2026-02-07 18:44:04.258]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[80]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Starting...]</span>
<span class="hljs-selector-attr">[2026-02-07 18:44:04.582]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[82]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Start completed.]</span>

<span class="hljs-selector-attr">[2026-02-07 18:44:09.426]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-1} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:44:22.180]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-2} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:44:23.552]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.xxx.WebApplication]</span> <span class="hljs-selector-attr">[61]</span> - <span class="hljs-selector-attr">[Started WebApplication in 24.191 seconds (JVM running for 24.92)]</span>
</code></pre>
<ul>
<li>原理：因 <code>InetAddress.getHostName()</code> 在本地 hosts 有映射时会<strong>跳过网络 DNS 查询</strong>，从而避免阻塞</li>
</ul>
<h2 data-id="heading-3">解决办法二：降低 MySQL 驱动版本</h2>
<ul>
<li>降低至 8.0.33 版本，实测有效</li>
</ul>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<ul>
<li>从启动日志可以看出，问题完美解决</li>
</ul>

<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[2026-02-07 18:51:19.582]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[80]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Starting...]</span>
<span class="hljs-selector-attr">[2026-02-07 18:51:19.899]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[82]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Start completed.]</span>

<span class="hljs-selector-attr">[2026-02-07 18:51:24.718]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-1} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:51:37.035]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-2} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:51:38.433]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.xxx.WebApplication]</span> <span class="hljs-selector-attr">[61]</span> - <span class="hljs-selector-attr">[Started WebApplication in 23.6 seconds (JVM running for 24.33)]</span>
</code></pre>
<ul>
<li>翻看 8.0.33 中 ConnectionImpl 的源码，不会调用 <code>InetSocketAddress.getHostName()</code> 方法</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/385985b131054048b8d265fcc2b1d816~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGVmaW5lOTUyNw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771129772&amp;x-signature=sm9g23yDAn6PgmNqT8O42SFGnis%3D" alt="1770436368060.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 Vue.js 渲染机制：从声明式到虚拟 DOM 的完整实现]]></title>    <link>https://juejin.cn/post/7603644943351726086</link>    <guid>https://juejin.cn/post/7603644943351726086</guid>    <pubDate>2026-02-08T04:36:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603644943351726086" data-draft-id="7603781883973271571" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 Vue.js 渲染机制：从声明式到虚拟 DOM 的完整实现"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2026-02-08T04:36:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="EchoEcho"/> <meta itemprop="url" content="https://juejin.cn/user/2920774267837208"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 Vue.js 渲染机制：从声明式到虚拟 DOM 的完整实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2920774267837208/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    EchoEcho
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:36:23.000Z" title="Sun Feb 08 2026 04:36:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">相关概念：</h2>
<h3 data-id="heading-1">命令式 VS 声明式</h3>
<p>从范式上来看，视图层框架通常分为：</p>
<ul>
<li><strong>命令式框架</strong>
<ul>
<li>更加<strong>关注过程</strong>，代码本身描述的是“做事的过程”，符合逻辑直觉</li>
<li>
<pre><code class="hljs language-dart" lang="dart">  <span class="hljs-comment">// 自然语言描述能够与代码产生一一对应的关系</span>
  <span class="hljs-comment">// 示例：</span>
  <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">'#app'</span>) <span class="hljs-comment">// 获取div</span>
  div.innerText = <span class="hljs-string">'hello world'</span><span class="hljs-comment">// 设置文本内容</span>
  div.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; { alert(<span class="hljs-string">'ok'</span>) }) <span class="hljs-comment">// 绑定点击事件</span>
</code></pre>
</li>
</ul>
</li>
<li><strong>声明式框架</strong>
<ul>
<li>更加<strong>关注结果</strong>，主要是提升代码的可维护性</li>
<li>
<pre><code class="hljs language-less" lang="less">  <span class="hljs-comment">// 用户提供一个“预期的结果”，中间的过程由vue.js实现</span>
  <span class="hljs-comment">// 示例</span>
  &lt;<span class="hljs-selector-tag">div</span> @<span class="hljs-selector-tag">click</span>="()  =&gt; <span class="hljs-selector-tag">alert</span>(<span class="hljs-string">'ok'</span>)"&gt;<span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">world</span>&lt;/<span class="hljs-selector-tag">div</span>&gt;
</code></pre>
</li>
<li>更新时性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</li>
</ul>
</li>
</ul>
<p>因为声明式框架在更新时比命令式框架多了“<strong>找出差异</strong>”的过程，所以声明式代码的性能不会优于命令式代码的性能。而对比命令式代码，声明式代码又具有更强的可维护性，更加的直观。所以框架要做的就是：<strong>在保持可维护性的同时让性能损失最小化</strong>。</p>
<p>在开发过程中，原生<code>JS</code>操作DOM，虚拟DOM和<code>innerHTML</code>三者操作页面的性能都与创建页面、更新页面，页面大小、变更部分的大小有关系，选择哪种更新策略，需要结合心智负担、可维护性等因素综合考虑。</p>
<p><strong>性能对比</strong></p>

































<table><thead><tr><th>更新策略</th><th>心智负担</th><th>可维护性</th><th>性能</th><th>适用场景</th></tr></thead><tbody><tr><td>原生<code>JS</code></td><td>高</td><td>低</td><td>最高</td><td>简单页面</td></tr><tr><td>虚拟DOM</td><td>中</td><td>高</td><td>中</td><td>复杂应用</td></tr><tr><td><code>innerHTML</code></td><td>低</td><td>中</td><td>低</td><td>静态内容</td></tr></tbody></table>
<h3 data-id="heading-2">运行时 VS 编译时</h3>
<blockquote>
<p>以上文中声明式框架示例代码为例，简单描述<code>vue.js</code>的渲染过程：</p>
<p>1、通过<strong>编译器【compile】</strong> 解析模版字符串识别到需要创建一个DOM元素，设置内容为<code>hello world</code>，并为其绑定一个点击事件，完成后输出一个虚拟DOM【即一个描述真实DOM的<code>js</code>对象】</p>
<p>2、通过<strong>渲染函数【render】</strong> 将虚拟DOM渲染成真实的DOM树挂载到指定元素上，完成渲染</p>
</blockquote>
<p>当设计一个框架的时候，有三种选择</p>
<ul>
<li>纯运行时
<ul>
<li>上面提到的如果<strong>只用渲染函数</strong>，由用户直接提供虚拟DOM作为入参，就是所谓的<strong>纯运行时框架</strong></li>
<li>没有编译过程，也就无法添加相关的优化手段，比如tree-shaking</li>
</ul>
</li>
<li>运行时 + 编译时
<ul>
<li>代码运行时由编译器将语义化代码编译成目标数据并作为渲染函数的入参，这种操作就是 <strong>运行时编译框架</strong>。它既支持运行时【即用户直接提供数据对象】，又支持编译时【即将用户语义化代码编译为目标数据】</li>
<li>由于代码运行时才开始编译会产生一定的性能开销，因此可以在构建时就执行编译操作，以提升性能。【在 Vue 3.5.22 中，运行时编译通过 <code>@vue/compiler-dom</code> 实现，构建时编译通过 <code>@vitejs/plugin-vue</code> 实现】</li>
</ul>
</li>
<li>纯编译时
<ul>
<li>如果省略上面的渲染函数，直接将用户代码通过编译器完成真实DOM的渲染，就是一个纯编译时框架。即不支持任何运行时内容。</li>
<li>由于不需要任何运行时，而是直接将代码编译成可执行的<code>js</code>代码，因为性能可能会更好，但是有损灵活性。</li>
</ul>
</li>
</ul>
<p><code>Vue.js</code>就是内部封装了命令式代码从而实现的面向用户的声明式框架；是运行时+编译时架构，目的在于保持灵活性的基础上尽可能的优化性能</p>
<p>其中组件的实现依赖于<strong>渲染器</strong>，组件中模板的编译依赖于<strong>编译器</strong>。<strong>虚拟DOM</strong>作为媒介在整个渲染过程中作为组件真实DOM的载体协助实现内容渲染和更新。</p>
<h3 data-id="heading-3">虚拟DOM【<code>vnode</code>】</h3>
<p>虚拟DOM 是一个用来描述真实DOM的<code>js</code>对象。</p>
<p>使用虚拟DOM的好处是可以将不同类型的标签、属性及子节点抽象成一个对象，这样描述<code>UI</code>可以更加灵活。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 上文中的代码可以用以下形式表示</span>
<span class="hljs-keyword">const</span> vnode= {
    <span class="hljs-comment">// 标签名称</span>
    <span class="hljs-attr">tag</span>: <span class="hljs-string">'div'</span>,
    <span class="hljs-comment">// 标签属性</span>
    <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span><span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
    },
    <span class="hljs-comment">// 子节点</span>
    <span class="hljs-attr">children</span>: <span class="hljs-string">'hello world'</span>
}
</code></pre>
<blockquote>
<p><code>vue</code>中的<code>h</code>函数就是一个辅助创建虚拟DOM的工具函数</p>
</blockquote>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>) }, <span class="hljs-string">'hello world'</span>)
    }
}

<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">tag</span>: <span class="hljs-string">'div'</span>,
            <span class="hljs-attr">props</span>: {
                <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
            },
            <span class="hljs-attr">children</span>: <span class="hljs-string">'hello world'</span>
        }
    }
}

<span class="hljs-comment">// 等价于</span>
&lt;div <span class="hljs-meta">@click</span>=<span class="hljs-string">"() =&gt; alert('ok')"</span>&gt;hello world&lt;/div&gt;
</code></pre>
<p>虚拟DOM的性能优势：</p>
<ul>
<li>批量更新：可以将多次DOM操作合并为一次</li>
<li>跨平台：同一套代码可以渲染到不同平台</li>
<li>优化策略：通过<code>diff</code>算法最小化DOM操作</li>
</ul>
<h3 data-id="heading-4">组件</h3>
<p>组件就是一组DOM元素的封装，它可以是一个返回虚拟DOM的函数，也可以是一个对象。组件的返回值也是虚拟DOM，它代表组件要渲染的内容。</p>
<h3 data-id="heading-5">编译器【compile】</h3>
<p>编译器的作用是将组件模板【<code>&lt;template&gt;</code>】编译为渲染函数并添加到<code>&lt;script&gt;</code>标签块的组件对象上</p>
<pre><code class="hljs language-xml" lang="xml">// demo.vue
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
&lt;div@click="handler"&gt;
        hello world
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
exportdefault {
        <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) { }
        <span class="hljs-attr">methods</span>: {
            <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span><span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
        }
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>组件编译后结果：</p>
<pre><code class="hljs language-javascript" lang="javascript">exportdefault {
    <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {},
    <span class="hljs-attr">methods</span>: {
        <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span><span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
    },
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">_createElementVNode</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">onClick</span>: handler }, <span class="hljs-string">'hello world'</span>, -<span class="hljs-number">1</span><span class="hljs-comment">/* HOISTED */</span>)
    }
}
</code></pre>
<p>无论是使用模板还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的。然后再将渲染函数返回的虚拟DOM作为渲染器的入参，进行真实DOM的渲染</p>
<p><code>Vue3</code>的编译优化：</p>
<ul>
<li>静态提升：将静态内容提升到渲染函数外部</li>
<li>补丁标记：为动态内容添加标记，优化<code>diff</code>过程【通过在虚拟DOM中添加标记实现】</li>
<li><code>tree-shaking</code>：移除未使用代码</li>
</ul>
<h3 data-id="heading-6">渲染器【renderer】</h3>
<p>渲染器的作用就是递归遍历虚拟DOM对象，并调用原生<code>DOM API</code>来完成真实DOM的创建。</p>
<p>渲染器的精髓在于后续的更新，它会通过<code>Diff</code>算法寻找并且只更新变化内容。</p>
<p>大致实现思路如下：</p>
<ul>
<li>如果不是内容变更：</li>
<li>
<ul>
<li>根据<code>vnode.tag</code>创建对应DOM元素</li>
<li>遍历<code>vnode.props</code>对象，如果<code>key</code>以<code>on</code>字符开头，说明它是一个事件，调用<code>addEventListener</code>绑定事件处理函数；否则作为属性添加到DOM元素上</li>
<li>处理<code>children</code>，如果是字符串，就创建文本节点；如果是数组就递归调用<code>render</code>继续渲染，最后把创建的元素挂载到新创建的元素内</li>
</ul>
</li>
</ul>

<ul>
<li>否则先找出<code>vnode</code>对象的变更点，并且只更新变更的内容</li>
</ul>
<h3 data-id="heading-7">组件渲染过程详解：</h3>
<h5 data-id="heading-8"><code>vite</code>、<code>@vitejs/plugin-vue</code>和<code>vue-core</code>的关系</h5>
<ul>
<li>
<p><code>vite</code>中使用了<code>@vitejs/plugin-vue</code>来处理<code>vue</code>组件</p>
</li>
<li>
<p><code>@vitejs/plugin-vue</code>中集成了<code>vue-core</code>中的<code>compiler-sfc</code>用于解析编译<code>Vue</code>组件</p>
</li>
<li>
<p><code>compiler-sfc</code>中调用了<code>compiler-core</code>中的基础逻辑进行组件的编译和渲染</p>
</li>
</ul>
<p>当我们新建并启动<code>vue</code>项目后，内容是如何渲染的，又是如何实时更新的？</p>
<h4 data-id="heading-9">创建并启动一个<code>Vue</code>应用 </h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 创建新项目</span>
npm create vue@latest
<span class="hljs-comment">// 进入项目后安装依赖</span>
npm install
<span class="hljs-comment">// 启动，实际执行的是vite命令</span>
npm run dev
</code></pre>
<h4 data-id="heading-10">当项目运行<code>npm run dev</code>命令时执行内容如下：</h4>
<h4 data-id="heading-11">编译阶段：</h4>
<h5 data-id="heading-12">启动一个<code>vite</code>开发服务器，浏览器会通过这个服务器来访问此项目的网页和代码</h5>
<p><code>vite</code>是一个通用的构建工具，<code>vite</code>本身并不直接处理<code>.vue</code>文件，而是通过插件系统来处理各种类型文件，其中<code>@vitejs/plugin-vue</code>就是用来处理<code>vue</code>单文件组件的</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2284b50fb4e44ecf82dc5f4f566f79d8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=AavXU%2B6fWQqANaT9e4c2mzqjgv8%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-13">构建时阶段</h4>
<p><code>Vite</code>接收到组件请求，会执行插件【<code>@vitejs/plugin-vue</code>】的<code>load</code>钩子函数，再执行<code>Transform</code>钩子函数</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cf498d2125e4627a484df191975b452~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=e9M3QhwkXxxJqjhJldPe1Yh7keQ%3D" alt="图片" loading="lazy"/></p>
<p>在上图钩子函数执行过程中触发了<code>compiler-sfc</code>相关方法的执行</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/09df4edbc402409e937d769740850d74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=RUiB%2B7mQIj5jXah01ftQpboNZGE%3D" alt="图片" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ea11c3f85d34604b44722b154aca173~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=8KxgD1chNHz7Q%2FBEFdHKTzN54Ss%3D" alt="图片" loading="lazy"/></p>
<h5 data-id="heading-14">监听组件变化</h5>
<p><code>@Vitejs/plugin-vue</code>插件的核心入口文件【<code>packages/plugin-vue/src/index.ts</code>】中定义了<code>Vite</code>插件的所有钩子函数，其中<code>handleHotUpdate</code>钩子是<code>Vite</code>提供的热更新处理函数，当<code>Vue</code>文件发生变化时，<code>Vite</code>会自动调用这个钩子，此时插件会检查变化的文件是否为<code>Vue</code>组件，如果是则调用专门的<code>handleHotUpdate函数</code>【<code>packages/plugin-vue/src/handleHotUpdate.ts</code>】</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c129e02641f14c62ad5dbc3c1a888d4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=MUFBcSJ%2FoHSh66u64Jt1zUsFrZg%3D" alt="图片" loading="lazy"/></p>
<p>最终将返回</p>
<pre><code class="hljs language-c" lang="c">SFCTemplateCompileResults ： {
    code: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 渲染函数代码</span>
    ast?: RootNode, <span class="hljs-comment">// 抽象语法树</span>
    preamble?: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 预处理代码</span>
    source: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 输入源</span>
    tips: <span class="hljs-built_in">string</span>[], <span class="hljs-comment">// 提示</span>
    errors: (<span class="hljs-built_in">string</span> | CompilerError)[], <span class="hljs-comment">// 错误</span>
    <span class="hljs-built_in">map</span>?: RawSourceMap, <span class="hljs-comment">// 源映射</span>
}
</code></pre>
<p>这个阶段会将<code>.vue</code>文件转换为<code>js</code>代码，生成的是渲染函数的字符串</p>
<h4 data-id="heading-15">运行时阶段</h4>
<p>当浏览器加载并执行这些<code>js</code>代码时，就会发生真正的渲染过程</p>
<pre><code class="hljs language-scss" lang="scss">应用启动 -&gt; <span class="hljs-built_in">createApp</span>() -&gt; app<span class="hljs-selector-class">.mount</span>() -&gt; <span class="hljs-built_in">render</span>() -&gt; <span class="hljs-built_in">patch</span>() -&gt; <span class="hljs-built_in">mountElement</span>() -&gt; 真实DOM
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59b801a153e24563ae174e29b29b870e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=I5TwTb1ZBF42SwbAYwPJX7dWxiA%3D" alt="图片" loading="lazy"/></p>
<p>到此就完成了<code>vue</code>中基本的渲染过程。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[主管:”人家 Node 框架都用 Nest.js 了 , 你怎么还在用 Express ?“]]></title>    <link>https://juejin.cn/post/7603688142004617225</link>    <guid>https://juejin.cn/post/7603688142004617225</guid>    <pubDate>2026-02-08T04:43:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142004617225" data-draft-id="7603651855236595721" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="主管:”人家 Node 框架都用 Nest.js 了 , 你怎么还在用 Express ?“"/> <meta itemprop="keywords" content="前端,后端,面试"/> <meta itemprop="datePublished" content="2026-02-08T04:43:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="千寻girling"/> <meta itemprop="url" content="https://juejin.cn/user/2276467567770442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            主管:”人家 Node 框架都用 Nest.js 了 , 你怎么还在用 Express ?“
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2276467567770442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    千寻girling
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:43:22.000Z" title="Sun Feb 08 2026 04:43:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{margin-bottom:5px;font-size:30px;font-weight:500}.markdown-body h1:before{content:"#";margin-right:10px;color:#1976d2}.markdown-body h2{font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out}.markdown-body h2:hover{border-color:#1976d2}.markdown-body h3{font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0}.markdown-body h4{font-size:20px;font-weight:500}.markdown-body h5{font-size:16px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter{text-transform:capitalize}.markdown-body em{text-emphasis:dot;text-emphasis-position:under}.markdown-body img{display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important}.markdown-body hr{position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center}.markdown-body code{font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:0 4px}.markdown-body pre&gt;code{font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent}.markdown-body a:after{content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat}.markdown-body a:hover{border-color:#027fff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after{display:none!important}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6}.markdown-body table img{box-shadow:none!important}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body del{color:rgba(0,0,0,.6)}.markdown-body blockquote{position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out}.markdown-body blockquote:hover{border-color:#1976d2}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6}.markdown-body blockquote:before{content:"“";top:4px;left:6px}.markdown-body blockquote:after{content:"”";right:8px;bottom:-8px}.markdown-body blockquote&gt;p,.markdown-body blockquote blockquote{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body details{outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary:hover::-webkit-details-marker{color:#1976d2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>我反驳主管道 : “我自己做项目做着玩 ! 你管我用哪一个 !”</p>
</blockquote>
<blockquote>
<p>回家之后 , 我开始好奇那么多 Node 框架 , 到底有什么区别啊?</p>
</blockquote>
<blockquote>
<p>Node.js Web 框架各式各样 , 下面简单的介绍一下这些 Node.js Web 框架 !</p>
</blockquote>
<h3 data-id="heading-0">一、分类</h3>
<p>Node.js Web 框架主要分 3 类：</p>



































<table><thead><tr><th>分类</th><th>核心特点</th><th>代表框架</th><th>适用场景</th></tr></thead><tbody><tr><td>极简核心框架</td><td>仅封装 HTTP 基础能力，无冗余功能</td><td><strong>Express、Koa</strong></td><td>中小型 API、自定义业务系统</td></tr><tr><td>全栈 / 企业级框架</td><td>内置路由、ORM、验证、鉴权等全套能力</td><td><strong>NestJS、AdonisJS</strong></td><td>大型企业应用、团队协作项目</td></tr><tr><td>高性能框架</td><td>基于异步 I/O/ 编译优化，极致性能</td><td><strong>Fastify、Hapi</strong></td><td>高并发 API、微服务</td></tr><tr><td>特殊场景框架</td><td>针对特定场景优化（如 SSR、低代码）</td><td><strong>Next.js、Nuxt.js（Node 端）、Sails.js</strong></td><td>前端 SSR、低代码平台</td></tr></tbody></table>
<h3 data-id="heading-1">二、主流框架详细介绍</h3>
<blockquote>
<p>⚠️ : 排名不分先后顺序</p>
</blockquote>
<h4 data-id="heading-2">1. Express（最经典的极简框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：Node.js Web 框架的 “鼻祖”，极简、灵活，无内置冗余功能，生态最丰富。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>中间件机制（线性中间件，<code>req -&gt; 中间件1 -&gt; 中间件2 -&gt; res</code>）；</li>
<li>简洁的路由系统；</li>
<li>无内置 ORM / 验证，需手动集成第三方库（如 <code>mongoose</code>、<code>express-validator</code>）。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

<span class="hljs-comment">// 中间件</span>
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());

<span class="hljs-comment">// 路由</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/user'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> });
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Express 启动在 3000 端口'</span>));
</code></pre>
</li>
<li>
<p><strong>优点</strong>：生态极全（几乎所有 Node 库都兼容）、学习成本低、灵活度高；</p>
</li>
<li>
<p><strong>缺点</strong>：回调嵌套（易出现 “回调地狱”）、无内置类型支持（TS 需手动配置）、无统一规范（团队协作易混乱）；</p>
</li>
<li>
<p><strong>适用场景</strong>：中小型 API 服务、快速原型开发、个人项目。</p>
</li>
</ul>
<h4 data-id="heading-3">2. Koa（Express 团队升级版）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：Express 原团队开发，解决 Express 回调地狱问题，基于 <code>async/await</code> 重构。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>洋葱模型中间件（中间件可双向执行，如 “请求进来执行 -&gt; 响应出去再执行”）；</li>
<li>原生支持 <code>async/await</code>，无回调地狱；</li>
<li>比 Express 更精简（甚至没有内置路由，需装 <code>koa-router</code>）。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">Koa</span> = require(<span class="hljs-string">'koa'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">koaRouter</span> = require(<span class="hljs-string">'koa-router'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">koaBody</span> = require(<span class="hljs-string">'koa-body'</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">app</span> = new Koa()<span class="hljs-comment">;</span>
const <span class="hljs-attr">router</span> = new koaRouter()<span class="hljs-comment">;</span>

// 洋葱模型中间件
app.use(async (ctx, next) =&gt; {
  console.log('请求开始')<span class="hljs-comment">;</span>
  await next()<span class="hljs-comment">; // 执行下一个中间件</span>
  console.log('请求结束')<span class="hljs-comment">; // 响应时执行</span>
})<span class="hljs-comment">;</span>

app.use(koaBody())<span class="hljs-comment">;</span>
router.get('/api/user', async (ctx) =&gt; {
  <span class="hljs-attr">ctx.body</span> = { name: <span class="hljs-string">'张三'</span>, age: <span class="hljs-number">20</span> }<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

app.use(router.routes())<span class="hljs-comment">;</span>
app.listen(3000, () =&gt; console.log('Koa 启动在 3000 端口'))<span class="hljs-comment">;</span>
</code></pre>
</li>
<li>
<p><strong>优点</strong>：异步体验好、洋葱模型灵活（适合日志 / 鉴权 / 异常捕获）、轻量；</p>
</li>
<li>
<p><strong>缺点</strong>：生态比 Express 略少、需手动集成更多第三方库；</p>
</li>
<li>
<p><strong>适用场景</strong>：中小型 API 服务、需要灵活中间件的场景、嫌弃 Express 回调的项目。</p>
</li>
</ul>
<h4 data-id="heading-4">3. NestJS（企业级 TypeScript 框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：对标 Spring Boot，基于 TypeScript，强调模块化、依赖注入，适合大型团队协作。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>强制 TypeScript 开发，类型安全；</li>
<li>模块化架构（Module + Controller + Service）；</li>
<li>内置依赖注入、拦截器、管道、守卫（鉴权）、过滤器；</li>
<li>兼容 Express/Koa，可无缝集成第三方库；</li>
<li>支持微服务、GraphQL、WebSocket。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// user.controller.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.service'</span>;

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'api/user'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> userService: UserService</span>) {}

  <span class="hljs-meta">@Get</span>()
  <span class="hljs-title function_">getUser</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">getUser</span>();
  }
}

<span class="hljs-comment">// user.service.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-title function_">getUser</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> };
  }
}
</code></pre>
</li>
<li>
<p><strong>优点</strong>：规范统一、类型安全、适合大型项目 / 团队、生态完善（官方封装了大量企业级能力）；</p>
</li>
<li>
<p><strong>缺点</strong>：学习成本高、入门门槛高、小型项目用着 “重”；</p>
</li>
<li>
<p><strong>适用场景</strong>：大型企业应用、微服务、团队协作项目、需要强类型的项目。</p>
</li>
</ul>
<h4 data-id="heading-5">4. Fastify（高性能极简框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：极致性能，比 Express 快 2-3 倍，专为高并发 API 设计。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>基于 JSON Schema 验证请求参数，性能优于传统验证库；</li>
<li>内置日志、压缩、路由缓存，无需额外配置；</li>
<li>兼容 Express 中间件；</li>
<li>支持 TypeScript。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fastify</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fastify'</span>)({ logger: <span class="hljs-literal">true</span> });

<span class="hljs-comment">// 路由 + 参数验证</span>
fastify.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">'/api/user'</span>, {
  <span class="hljs-attr">schema</span>: {
    <span class="hljs-attr">querystring</span>: {
      <span class="hljs-attr">age</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'number'</span> }
    }
  }
}, <span class="hljs-title function_ invoke__">async</span> (request, reply) =&gt; {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: request.query.age || <span class="hljs-number">20</span> };
});

fastify.<span class="hljs-title function_ invoke__">listen</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> }, (err) =&gt; {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">'Fastify 启动在 3000 端口'</span>);
});
</code></pre>
</li>
<li>
<p><strong>优点</strong>：性能极高、内置功能丰富（无需装大量中间件）、轻量；</p>
</li>
<li>
<p><strong>缺点</strong>：生态比 Express 小、部分特性（如 Schema 验证）有学习成本；</p>
</li>
<li>
<p><strong>适用场景</strong>：高并发 API、微服务、对性能要求高的项目。</p>
</li>
</ul>
<h4 data-id="heading-6">5. Hapi（稳定的企业级框架）</h4>
<blockquote>
<p>“还记得当初在 <strong>沃尔玛</strong> 买了虾 , 自己回家自己做 <strong>鸡油炒河虾仁</strong> , 艾玛 , 老香了!!! ”</p>
</blockquote>
<ul>
<li>
<p><strong>核心定位</strong>：由 Walmart ( 沃尔玛  ) 开发，强调配置优于编码，适合稳定的企业级服务。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>内置路由、验证、缓存、日志，无需第三方库；</li>
<li>插件化架构，扩展能力强；</li>
<li>稳定性极高（适合金融 / 电商等核心系统）。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：稳定、内置功能全、安全性高；</p>
</li>
<li>
<p><strong>缺点</strong>：学习成本高、灵活性低、性能不如 Fastify；</p>
</li>
<li>
<p><strong>适用场景</strong>：金融 / 电商等核心系统、对稳定性要求极高的项目。</p>
</li>
</ul>
<h4 data-id="heading-7">6. Next.js（前端 SSR/SSG 框架，Node 端核心）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：React 生态的全栈框架，Node 端负责服务端渲染（SSR）、静态生成（SSG）。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>服务端渲染（提升 SEO、首屏加载速度）；</li>
<li>自动路由（基于文件系统）；</li>
<li>内置 API 路由（无需额外搭后端）；</li>
<li>支持静态生成、增量静态再生。</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：React 前端项目、需要 SEO 的网站（如博客、电商）、全栈 React 应用。</p>
</li>
</ul>
<h4 data-id="heading-8">7. Sails.js（低代码 / 快速开发框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：对标 Ruby on Rails，内置 ORM、蓝图 API、实时通信，适合快速开发全栈应用。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>自动生成 CRUD API（蓝图路由）；</li>
<li>内置 Waterline ORM（支持多数据库）；</li>
<li>支持 WebSocket 实时通信；</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：开发速度极快、低代码；</p>
</li>
<li>
<p><strong>缺点</strong>：灵活性低、定制化成本高；</p>
</li>
<li>
<p><strong>适用场景</strong>：快速原型开发、低代码平台、小型全栈应用。</p>
</li>
</ul>
<h4 data-id="heading-9">8. AdonisJS（Node.js 版的 Laravel，全栈企业级框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：对标 PHP 界的 Laravel，是 Node.js 生态中 “开箱即用” 的全栈框架，内置全套企业级能力，强调 “约定优于配置”。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>内置 ORM（Lucid ORM）：支持 MySQL、PostgreSQL 等，无需手动集成第三方 ORM；</li>
<li>内置身份验证（用户注册 / 登录 / 权限）、表单验证、CSRF 保护；</li>
<li>支持 MVC 架构、路由分组、中间件、任务调度；</li>
<li>原生支持 TypeScript，类型安全；</li>
<li>内置模板引擎（Edge），也支持前后端分离；</li>
</ul>
</li>
<li>
<p><strong>示例代码（核心路由 + ORM）</strong> ：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// start/routes.ts</span>
<span class="hljs-keyword">import</span> Route from <span class="hljs-string">'@ioc:Adonis/Core/Route'</span>
<span class="hljs-keyword">import</span> User from <span class="hljs-string">'App/Models/User'</span>

<span class="hljs-comment">// 路由 + 数据库查询</span>
Route.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/api/user'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> User.find(<span class="hljs-number">1</span>) <span class="hljs-comment">// Lucid ORM 查用户</span>
  <span class="hljs-keyword">return</span> { name: user?.name, age: user?.age }
})

<span class="hljs-comment">// 表单验证</span>
Route.post(<span class="hljs-string">'/api/user'</span>, <span class="hljs-keyword">async</span> ({ request }) =&gt; {
  <span class="hljs-keyword">const</span> data = request.validate({
    schema: {
      name: schema.string(),
      age: schema.number()
    }
  })
  <span class="hljs-keyword">await</span> User.create(data) <span class="hljs-comment">// 新增用户</span>
  <span class="hljs-keyword">return</span> { success: <span class="hljs-keyword">true</span> }
})
</code></pre>
</li>
<li>
<p><strong>优点</strong>：开箱即用（无需装大量依赖）、Laravel 开发者易上手、规范统一、内置安全特性；</p>
</li>
<li>
<p><strong>缺点</strong>：生态比 Express/NestJS 小、灵活性略低、国内使用较少（中文文档有限）；</p>
</li>
<li>
<p><strong>适用场景</strong>：全栈 Node.js 应用、Laravel 转 Node 开发的团队、中小型企业应用、需要快速搭建带数据库的业务系统。</p>
</li>
</ul>
<h4 data-id="heading-10">9. Nuxt.js（Vue 生态全栈框架，Node 端负责 SSR/SSG）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：Vue 生态的官方全栈框架，基于 Vue + Node.js 实现服务端渲染（SSR）、静态站点生成（SSG），解决 Vue 单页应用 SEO 差的问题。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>自动路由（基于 <code>pages</code> 目录，无需手动配置路由）；</li>
<li>服务端渲染（SSR）、静态生成（SSG）、增量静态再生（ISR）；</li>
<li>内置 API 路由（<code>server/api</code> 目录，无需额外搭后端服务）；</li>
<li>支持 Vue3 + TypeScript、自动代码分割、缓存优化；</li>
<li>集成 Pinia（状态管理）、Nuxt Modules（生态插件）；</li>
</ul>
</li>
<li>
<p><strong>示例代码（核心用法）</strong> ：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- pages/api/user.vue (页面路由) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ user.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 服务端获取数据（SSR）</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: user } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'user'</span>, <span class="hljs-function">() =&gt;</span> 
  $fetch(<span class="hljs-string">'/api/user'</span>) <span class="hljs-comment">// 调用内置 API 路由</span>
)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

// server/api/user.ts (内置 API 路由)
export default defineEventHandler(() =&gt; {
  return { name: '张三', age: 20 }
})
</code></pre>
</li>
<li>
<p><strong>优点</strong>：Vue 开发者无缝上手、解决 SEO 问题、全栈一体化（前端 + Node 端）、生态完善；</p>
</li>
<li>
<p><strong>缺点</strong>：仅适配 Vue 技术栈、Node 端逻辑定制化能力有限、大型项目需深入理解其生命周期；</p>
</li>
<li>
<p><strong>适用场景</strong>：Vue 全栈应用、需要 SEO 的网站（博客 / 电商 / 官网）、静态站点生成、中小型 Vue 项目。</p>
</li>
</ul>
<h4 data-id="heading-11">10. Egg.js（阿里开源，企业级 Node.js 框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：阿里开源的企业级框架，基于 Express/Koa 封装，强调 “约定优于配置”，适合中大型团队协作。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>基于 Koa2（洋葱模型），兼容 Koa/Express 中间件；</li>
<li>内置多进程模型（Master + Worker），自动利用多核 CPU；</li>
<li>插件化架构（如 egg-mysql、egg-redis），生态丰富（阿里官方维护）；</li>
<li>支持 TypeScript、单元测试、日志、监控；</li>
<li>规范的目录结构（controller/service/middleware/config），团队协作友好；</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-comment">// app/controller/user.js</span>
const { <span class="hljs-type">Controller</span> } = require('egg');

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{
  async index() {
    const { ctx } = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 调用 service 层</span>
    const user = await ctx.service.user.getUser();
    ctx.body = user;
  }
}

module.exports = <span class="hljs-type">UserController</span>;

<span class="hljs-comment">// app/service/user.js</span>
const { <span class="hljs-type">Service</span> } = require('egg');

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>{
  async getUser() {
    <span class="hljs-comment">// 用 egg-mysql 查数据库</span>
    <span class="hljs-keyword">return</span> await <span class="hljs-keyword">this</span>.app.mysql.get('user', { id: <span class="hljs-number">1</span> });
  }
}

module.exports = <span class="hljs-type">UserService</span>;
</code></pre>
</li>
<li>
<p><strong>优点</strong>：阿里背书、规范统一、多进程性能优、国内生态完善（中文文档 / 社区）、适合团队协作；</p>
</li>
<li>
<p><strong>缺点</strong>：灵活性低于 Express/Koa、学习成本中等、小型项目用着 “重”；</p>
</li>
<li>
<p><strong>适用场景</strong>：中大型企业应用、阿里系技术栈项目、国内团队协作项目、需要多进程优化的 Node 服务。</p>
</li>
</ul>
<h3 data-id="heading-12">三、 对比</h3>



















































































































<table><thead><tr><th>框架</th><th>学习成本</th><th>性能</th><th>生态</th><th>类型支持</th><th>适用规模</th><th>核心优势</th><th>技术栈 / 定位</th></tr></thead><tbody><tr><td>Express</td><td>低</td><td>中等</td><td>极丰富</td><td>需手动配</td><td>小 / 中</td><td>灵活、生态全、入门快</td><td>极简核心框架</td></tr><tr><td>Koa</td><td>中</td><td>中等</td><td>丰富</td><td>需手动配</td><td>小 / 中</td><td>洋葱模型、async/await</td><td>极简核心框架（Express 升级版）</td></tr><tr><td>NestJS</td><td>高</td><td>中等</td><td>丰富</td><td>原生 TS</td><td>中 / 大</td><td>规范、企业级、团队协作</td><td>企业级 TS 框架</td></tr><tr><td>Fastify</td><td>中</td><td>极高</td><td>中等</td><td>原生 TS</td><td>小 / 中 / 大</td><td>极致性能、内置功能全</td><td>高性能极简框架</td></tr><tr><td>Hapi</td><td>高</td><td>中高</td><td>中等</td><td>需手动配</td><td>中 / 大</td><td>稳定、安全、企业级</td><td>企业级配置优先框架</td></tr><tr><td>Next.js</td><td>中</td><td>中等</td><td>极丰富</td><td>原生 TS</td><td>小 / 中 / 大</td><td>React SSR、全栈一体化</td><td>React 全栈框架</td></tr><tr><td>Sails.js</td><td>低</td><td>中等</td><td>中等</td><td>需手动配</td><td>小</td><td>低代码、开发速度快</td><td>低代码全栈框架</td></tr><tr><td>AdonisJS</td><td>中</td><td>中等</td><td>中等</td><td>原生 TS</td><td>小 / 中</td><td>Laravel 风格、开箱即用</td><td>全栈企业级框架（Node 版 Laravel）</td></tr><tr><td>Nuxt.js</td><td>中</td><td>中等</td><td>极丰富</td><td>原生 TS</td><td>小 / 中 / 大</td><td>Vue SSR、全栈一体化、SEO 优</td><td>Vue 全栈框架</td></tr><tr><td>Egg.js</td><td>中</td><td>中高</td><td>丰富</td><td>需手动配</td><td>中 / 大</td><td>阿里背书、多进程、国内生态好</td><td>企业级框架（基于 Koa）</td></tr></tbody></table>
<h3 data-id="heading-13">四、选型建议</h3>
<ol>
<li><strong>个人 / 小型项目、快速开发</strong>：选 Express（生态全）或 Koa（异步体验好）；</li>
<li><strong>高并发 API、微服务</strong>：选 Fastify（性能第一）；</li>
<li><strong>大型企业应用、团队协作</strong>：选 NestJS（TS + 规范）或 Hapi（稳定）；</li>
<li><strong>React 全栈、需要 SEO</strong>：选 Next.js；</li>
<li><strong>低代码、快速原型</strong>：选 Sails.js。</li>
</ol>
<h3 data-id="heading-14">总结</h3>
<ol>
<li><strong>核心维度</strong>：选型优先看「项目规模 + 团队技术栈 + 性能要求」，小型项目别用重框架（如 NestJS），大型项目别用太灵活的框架（如 Express）；</li>
<li><strong>生态优先级</strong>：如果需要集成大量第三方库，Express / Koa / Next.js 是首选；</li>
<li><strong>性能优先级</strong>：高并发场景直接选 Fastify；</li>
<li><strong>团队协作</strong>：大型团队优先 NestJS（强规范），避免 Express 因灵活导致的代码混乱。</li>
</ol>
<blockquote>
<p>okokok , 这个文章到这里就结束了 , 我们有缘再会 😁😁😁 !!!</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nginx 路径映射深度解析：从本地开发到生产交付的底层哲学]]></title>    <link>https://juejin.cn/post/7603699739223293967</link>    <guid>https://juejin.cn/post/7603699739223293967</guid>    <pubDate>2026-02-08T05:01:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603699739223293967" data-draft-id="7603673564908732451" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nginx 路径映射深度解析：从本地开发到生产交付的底层哲学"/> <meta itemprop="keywords" content="前端,后端,架构"/> <meta itemprop="datePublished" content="2026-02-08T05:01:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="文艺理科生Owen"/> <meta itemprop="url" content="https://juejin.cn/user/3817963023244503"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nginx 路径映射深度解析：从本地开发到生产交付的底层哲学
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3817963023244503/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    文艺理科生Owen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T05:01:07.000Z" title="Sun Feb 08 2026 05:01:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Nginx 静态资源映射：从原理到生产环境的最佳实践</h2>
<blockquote>
<p><strong>摘要</strong>：在现代前后端分离架构中，Nginx 不仅是高性能的静态资源服务器，更是不可或缺的反向代理枢纽。然而，由于对资源映射（root/alias）及请求转发（proxy_pass）逻辑的理解偏差，往往会导致从 Windows 开发环境迁移至 Linux 生产环境时出现 404 或转发异常。本文将从 HTTP 协议视角出发，深度剖析“路径映射三剑客”的底层逻辑，并提供一套可落地的工程化配置规范与避坑指南。</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">1. 业务场景与工程痛点</h3>
<p>在实际的工程链路中，我们经常遇到这样的场景：
前端同学在 Windows 本地使用 Nginx 调试 SPA（单页应用）或静态站点，一切运行正常。但当 CI/CD 流水线将代码部署到 Linux 生产服务器后，访问特定资源（如图片、次级路由）却频频出现 404 错误。</p>
<p>这并非玄学，而是由于对 <strong>Nginx 路径解析机制</strong> 及 <strong>操作系统文件系统差异</strong> 理解不足导致的。要解决这个问题，我们需要先建立正确的路径映射心智模型。</p>
<h3 data-id="heading-2">2. 核心模型解析：URL 与文件系统的映射</h3>
<p>Nginx 的核心职责之一，就是将抽象的 <strong>HTTP URI</strong> 映射到具体的 <strong>服务器文件系统路径</strong>。</p>
<h4 data-id="heading-3">2.1 URI 的语义差异</h4>
<p>在配置之前，必须明确 URL 尾部斜杠的协议语义：</p>
<ul>
<li><strong><code>/images</code></strong>：客户端请求名为 <code>images</code> 的<strong>资源实体</strong>（可能是文件，也可能是目录）。</li>
<li><strong><code>/images/</code></strong>：客户端明确请求名为 <code>images</code> 的<strong>目录容器</strong>。</li>
</ul>
<p><strong>工程细节</strong>：
当用户访问 <code>/images</code>（不带斜杠）且服务器上存在同名目录时，Nginx 默认会返回 <strong>301 Moved Permanently</strong>，自动重定向到 <code>/images/</code>。这是为了确保相对路径资源（如 <code>./logo.png</code>）能基于正确的 Base URL 加载。</p>
<hr/>
<h3 data-id="heading-4">3. 资源映射三剑客：Root、Alias 与 Proxy_Pass</h3>
<p><code>root</code>、<code>alias</code> 与 <code>proxy_pass</code> 是 Nginx 流量分发的核心指令。前两者解决的是如何将 URI 映射到 <strong>本地文件系统</strong>，而后者解决的是如何将请求转发到 <strong>网络服务接口</strong>。</p>
<h4 data-id="heading-5">3.1 Root：追加逻辑 (Append)</h4>
<p><code>root</code> 指令采用<strong>追加</strong>策略。它将请求的 URI 完整拼接到 <code>root</code> 指定的路径之后。</p>
<ul>
<li><strong>计算公式</strong>：<code>最终物理路径 = root路径 + 完整URI</code></li>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /static/ {
    root /var/www/app;
}
</code></pre>
</li>
<li><strong>解析过程</strong>：请求 <code>GET /static/css/style.css</code> -&gt; 物理路径：<code>/var/www/app/static/css/style.css</code></li>
</ul>
<h4 data-id="heading-6">3.2 Alias：替换逻辑 (Replace)</h4>
<p><code>alias</code> 指令采用<strong>替换</strong>策略。它用 <code>alias</code> 指定的路径替换掉 <code>location</code> 匹配到的部分。</p>
<ul>
<li><strong>计算公式</strong>：<code>最终物理路径 = alias路径 + (完整URI - location匹配部分)</code></li>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /static/ {
    alias /var/www/app/public/;
}
</code></pre>
</li>
<li><strong>解析过程</strong>：请求 <code>GET /static/css/style.css</code> -&gt; 匹配 <code>/static/</code> -&gt; 剩余 <code>css/style.css</code> -&gt; 最终访问：<code>/var/www/app/public/css/style.css</code></li>
</ul>
<h4 data-id="heading-7">3.3 Proxy_Pass：请求转发逻辑 (Forward)</h4>
<p>与处理本地文件的指令不同，<code>proxy_pass</code> 处理的是网络协议栈的转发。其路径处理逻辑遵循相似的“追加”与“替换”哲学，由目标 URL 结尾是否有 <strong><code>/</code></strong> 决定。</p>
<h5 data-id="heading-8"><strong>场景 A：不带斜杠（透明转发，对应 Root 逻辑）</strong></h5>
<p>当 <code>proxy_pass</code> 的目标 URL 不带路径（即没有结尾的 <code>/</code>）时，Nginx 会将原始请求的 URI 完整地传递给后端服务。</p>
<ul>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /api/ {
    proxy_pass http://127.0.0.1:3000; 
}
</code></pre>
</li>
<li><strong>路径解析</strong>：请求 <code>GET /api/user</code> -&gt; 转发到 <code>http://127.0.0.1:3000/api/user</code>。</li>
<li><strong>工程特征</strong>：<code>location</code> 匹配路径被完整保留。适用于后端服务本身就包含 <code>/api</code> 前缀的场景。</li>
</ul>
<h5 data-id="heading-9"><strong>场景 B：带斜杠（路径重写，对应 Alias 逻辑）</strong></h5>
<p>当 <code>proxy_pass</code> 的目标 URL 包含路径（即使只有一个结尾的 <code>/</code>）时，Nginx 会将 URI 中匹配 <code>location</code> 的部分替换为该路径。</p>
<ul>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /api/ {
    proxy_pass http://127.0.0.1:3000/; 
}
</code></pre>
</li>
<li><strong>路径解析</strong>：请求 <code>GET /api/user</code> -&gt; 转发到 <code>http://127.0.0.1:3000/user</code>。</li>
<li><strong>工程特征</strong>：<code>location</code> 匹配路径被“剥离”。适用于后端服务是纯净接口，仅通过 Nginx 统一前缀入口的场景。</li>
</ul>
<h4 data-id="heading-10">3.4 资源映射三剑客对比表</h4>
<p>假设统一配置 <code>location /api/</code>，观察不同指令下的映射结果：</p>













































<table><thead><tr><th align="left">指令</th><th align="left">映射目标</th><th align="left">URI 处理方式</th><th align="left">示例配置</th><th align="left">实际请求 -&gt; 结果映射</th><th align="left">典型场景</th></tr></thead><tbody><tr><td align="left"><strong>Root</strong></td><td align="left">本地磁盘</td><td align="left"><strong>追加</strong> (Append)</td><td align="left"><code>root /data;</code></td><td align="left"><code>/api/user</code> -&gt; <code>/data/api/user</code></td><td align="left">静态站点默认部署</td></tr><tr><td align="left"><strong>Alias</strong></td><td align="left">本地磁盘</td><td align="left"><strong>替换</strong> (Replace)</td><td align="left"><code>alias /data/v1/;</code></td><td align="left"><code>/api/user</code> -&gt; <code>/data/v1/user</code></td><td align="left">虚拟路径、资源别名</td></tr><tr><td align="left"><strong>Proxy_Pass (无/)</strong></td><td align="left">远程服务</td><td align="left"><strong>透明转发</strong></td><td align="left"><code>proxy_pass http://node:3000;</code></td><td align="left"><code>/api/user</code> -&gt; <code>node:3000/api/user</code></td><td align="left">后端服务自带前缀</td></tr><tr><td align="left"><strong>Proxy_Pass (带/)</strong></td><td align="left">远程服务</td><td align="left"><strong>路径重写</strong></td><td align="left"><code>proxy_pass http://node:3000/;</code></td><td align="left"><code>/api/user</code> -&gt; <code>node:3000/user</code></td><td align="left">统一入口，后端无前缀</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-11">4. 工程化落地：跨平台环境差异处理</h3>
<p>在团队协作中，统一开发环境（Windows/Mac）与生产环境（Linux）的配置规范至关重要。</p>
<h4 data-id="heading-12">4.1 Windows 开发环境的陷阱</h4>
<p>Windows 文件系统有“盘符”概念，且对路径分隔符不敏感。</p>
<ul>
<li><strong>绝对路径问题</strong>：
在 Windows 下配置 <code>root /html;</code>，Nginx 会将其解析为当前盘符的根目录（如 <code>D:\html</code>），而非 Nginx 安装目录。</li>
<li><strong>最佳实践</strong>：
<strong>使用相对路径</strong>。
<pre><code class="hljs language-nginx" lang="nginx"># 推荐：相对于 Nginx 安装目录 (prefix)
location / {
    root html; 
    index index.html;
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-13">4.2 Linux 生产环境的规范</h4>
<p>Linux 环境强调权限控制与路径的确定性。</p>
<ul>
<li>
<p><strong>绝对路径强制</strong>：
生产配置必须使用绝对路径，避免因启动方式不同导致的工作目录漂移。</p>
<pre><code class="hljs language-nginx" lang="nginx">root /usr/share/nginx/html;
</code></pre>
</li>
<li>
<p><strong>权限隔离 (Permission)</strong>：
常见的 403 Forbidden 错误通常并非配置错误，而是权限问题。</p>
<ul>
<li><strong>要求</strong>：Nginx 运行用户（通常是 <code>nginx</code> 或 <code>www-data</code>）必须拥有从根目录到目标文件全路径的 <strong>x (执行/搜索)</strong> 权限，以及目标文件的 <strong>r (读取)</strong> 权限。</li>
<li><strong>排查命令</strong>：
<pre><code class="hljs language-bash" lang="bash">namei -om /var/www/project/static/image.png
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Alias 的斜杠对称性</strong>：
这是一个容易被忽视的 Bug 源。在 Linux 下使用 <code>alias</code> 时，如果 <code>location</code> 只有尾部斜杠，建议 <code>alias</code> 也加上尾部斜杠，保持对称，避免路径拼接错位。</p>
<pre><code class="hljs language-nginx" lang="nginx"># Good
location /img/ {
    alias /var/www/images/;
}
</code></pre>
</li>
</ul>
<h3 data-id="heading-14">5. 调试与排错指南</h3>
<p>当出现 404 或 403 时，不要盲目猜测，请遵循以下排查路径：</p>
<ol>
<li>
<p><strong>Check Error Log</strong>：
这是最直接的证据。Nginx 的 <code>error.log</code> 会明确打印出它试图访问的完整物理路径。</p>
<pre><code class="hljs language-text" lang="text">open() "/var/www/app/static/css/style.css" failed (2: No such file or directory)
</code></pre>
<p>对比日志中的路径与你预期的路径，通常能立刻发现 <code>root</code> 或 <code>alias</code> 的误用。</p>
</li>
<li>
<p><strong>验证文件存在性</strong>：
直接复制日志中的路径，在服务器上执行 <code>ls -l &lt;path&gt;</code>，确认文件是否存在以及权限是否正确。</p>
</li>
</ol>
<hr/>
<p><strong>总结</strong>：
Nginx 的路径映射与转发逻辑虽然细碎，但其背后遵循着高度一致的“追加”与“替换”哲学。掌握 <code>root</code>、<code>alias</code> 与 <code>proxy_pass</code> 的底层差异，不仅能解决 404/403 等表象问题，更能帮助开发者构建出优雅、可维护的配置体系。在工程实践中，建议通过<strong>规范化路径命名</strong>（如统一使用 <code>/api/</code> 前缀）与<strong>环境感知配置</strong>（如 Linux 绝对路径强制化）来降低运维复杂度，确保从本地开发到生产交付的丝滑顺畅。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【ThreeJS实战】从86MB到4MB：复杂模型加载优化黑魔法]]></title>    <link>https://juejin.cn/post/7603771025856397363</link>    <guid>https://juejin.cn/post/7603771025856397363</guid>    <pubDate>2026-02-08T05:34:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856397363" data-draft-id="7603771025855922227" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【ThreeJS实战】从86MB到4MB：复杂模型加载优化黑魔法"/> <meta itemprop="keywords" content="three.js,性能优化"/> <meta itemprop="datePublished" content="2026-02-08T05:34:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="叶智辽"/> <meta itemprop="url" content="https://juejin.cn/user/3320999244205294"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【ThreeJS实战】从86MB到4MB：复杂模型加载优化黑魔法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3320999244205294/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    叶智辽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T05:34:15.000Z" title="Sun Feb 08 2026 05:34:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><em>前言：正当我沉浸在将draw call从52000优化到1的喜悦中无法自拔时，产品经理这时候又杀过来了："客户说模型加载要30秒，还没进去就关页面了，你优化一下？"我打开Network面板一看，卧槽，86MB的GLB文件！这谁顶得住啊...</em></p>
<p>如果你也遇到过这种情况：精心打磨的3D场景，本地运行丝滑流畅，一上线用户骂娘——"破网站卡死了"、"怎么还在转圈"、"手机直接闪退"。别急着怪用户网速慢，先看看你的模型是不是<strong>太胖了</strong>。</p>
<p>我这有个复杂模型，几何体+贴图一共<strong>86MB</strong>，在4G网络下加载需要<strong>30秒</strong>（Chrome模拟Slow 4G(3mb/s)一直加载...)。今天咱们不讲Blender操作模型（之前用Blender是因为没招，现在有更狠的），直接用<strong>命令行黑魔法</strong>把它压到<strong>4MB!!</strong>，加载时间从30秒干到<strong>1.5秒</strong>。</p>
<p>以下是优化前的绝望现场整整加载了30多秒...</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/674e9f906cc746b3b8f29b017e4603a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=tsoCT58MD8cav1uSQnyd2NcJc%2Bc%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-0">一、优化思路</h3>
<p>既然知道了加载为什么那么慢的原因，那我们就可以开始想想该怎么优化了</p>
<p>我目前的思路就是用<code>gltf-transform</code>
先把模型体积压下来，要不然渲染的时候再流畅，客户等到第二十秒的时候关闭浏览器，也没有意义了。。</p>
<h3 data-id="heading-1">二、DRACOLoader</h3>
<p>ThreeJS DRACOLoader直接无缝解压缩被压缩的模型</p>
<h4 data-id="heading-2">安装压缩模型工具（不用Blender，命令行搞定）</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装gltf-transform（一行命令搞定Draco压缩+WebP+KTX2）</span>
npm install -g @gltf-transform/cli
</code></pre>
<p>至于我为什么选择gltf-transform而不是gltf-pipeline，以下是它们的对比：</p>



































<table><thead><tr><th>特性</th><th>gltf-pipeline</th><th>gltf-transform</th></tr></thead><tbody><tr><td><strong>Draco压缩</strong></td><td>✅ 支持</td><td>✅ 支持（更快）</td></tr><tr><td><strong>WebP纹理</strong></td><td>❌ 不支持</td><td>✅ 支持（关键！）</td></tr><tr><td><strong>KTX2/Basis</strong></td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td><strong>安装体积</strong></td><td>大（依赖多）</td><td>小（WASM核心）</td></tr><tr><td><strong>推荐度</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table>
<h2 data-id="heading-3">压缩你的GLB（80MB → 4MB）</h2>
<pre><code class="hljs language-bash" lang="bash">gltf-transform optimize input.glb output.glb \
  --compress draco \
  --texture-compress webp \
  --texture-size 2048
</code></pre>
<p>以下是我压缩之后的体积：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7625fd53c564acb8f71b83e39f2cd5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=Qt6vRnu5GJeXcNUoNO%2By5kpmOEM%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到，模型的体积得到了巨大的缩减，从原来的86mb到现在的4mb左右！</p>
<p><strong>参数说明</strong>：</p>













































<table><thead><tr><th>参数</th><th>说明</th><th>建议值</th></tr></thead><tbody><tr><td><code>--texture-compress webp</code></td><td>贴图转WebP格式</td><td><strong>必加</strong>，体积减半</td></tr><tr><td><code>--texture-compress ktx2</code></td><td>贴图转KTX2（GPU直读）</td><td>如果目标设备支持，比WebP更好</td></tr><tr><td><code>--texture-size 2048</code></td><td>限制最大贴图尺寸</td><td><strong>必加</strong>，4096→2048省4倍显存</td></tr><tr><td><code>--compress draco</code></td><td>启用Draco几何压缩</td><td><strong>必加</strong>，默认就是sequential模式</td></tr><tr><td><code>--compress-method sequential</code></td><td>Draco编码模式</td><td>sequential（默认，小体积）或 edgeloop（快解码）</td></tr><tr><td><code>--compress-level 10</code></td><td>Draco压缩级别</td><td>0-10，10压最狠但解压慢，建议7-10</td></tr><tr><td><code>--flatten</code></td><td>打平节点层级</td><td>如果模型层级太深，加这个减少DrawCall（但会丢失动画）</td></tr></tbody></table>
<p>以下是优化之后的加载时间，就问你快不快！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c128c4ba2d14860b8623cf34327cf21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=Gj1p3h7rSzkEUOr8ceIYI4kXA2s%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-4">Three.js加载代码（关键！）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 优化后的 GLB 加载步骤（Draco / gltf-transform）
 *
 * 依赖：Three.js、GLTFLoader、DRACOLoader
 * 解码器：把 three 的 examples/jsm/libs/draco/gltf/ 放到站点 /draco/ 下，或使用 CDN 路径
 */</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">GLTFLoader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'three/examples/jsm/loaders/GLTFLoader'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DRACOLoader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'three/examples/jsm/loaders/DRACOLoader'</span>;

<span class="hljs-comment">// ————— 步骤 1：创建 Draco 解码器并指定路径 —————</span>
<span class="hljs-keyword">const</span> dracoLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DRACOLoader</span>();
dracoLoader.<span class="hljs-title function_">setDecoderPath</span>(<span class="hljs-string">'/draco/'</span>);
<span class="hljs-comment">// 或用 CDN（与项目 three 版本一致）：'https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/libs/draco/gltf/'</span>

<span class="hljs-comment">// ————— 步骤 2：把 DRACOLoader 挂到 GLTFLoader 上 —————</span>
<span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>();
loader.<span class="hljs-title function_">setDRACOLoader</span>(dracoLoader);

<span class="hljs-comment">// ————— 步骤 3：正常 load，普通 GLB 与 Draco 压缩的 GLB 都能加载 —————</span>
loader.<span class="hljs-title function_">load</span>(
  <span class="hljs-string">'https://your-cdn.com/model-optimized.glb'</span>,
  <span class="hljs-function">(<span class="hljs-params">gltf</span>) =&gt;</span> {
    scene.<span class="hljs-title function_">add</span>(gltf.<span class="hljs-property">scene</span>);
  },
  <span class="hljs-literal">undefined</span>,
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err),
);

<span class="hljs-comment">// Promise 写法（可选）：</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadOptimizedGLB</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    loader.<span class="hljs-title function_">load</span>(url, resolve, <span class="hljs-literal">undefined</span>, reject);
  });
}
<span class="hljs-comment">// 使用方式：const gltf = await loadOptimizedGLB(url);</span>

</code></pre>
<p><strong>注意</strong>：<code>setDecoderPath</code> 指向的是 Draco 的 WASM 解码文件，需要从 Three.js 的 <code>examples/jsm/libs/draco/</code> 目录复制到你的 public 文件夹，或者用 CDN（上面示例用的是从threejs复制的本地解码文件）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f6056ed4edd8424e9f576076746a6227~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=LfB00kEcCV01BCgkwfo%2BfL0j%2B2E%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0bcc195429b6461dad0a0b37005c7a60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=Pm6unUZnhNJrWVyGpRLGgHL%2B5u4%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-5">避坑指南</h3>
<ol>
<li><strong>别重复压缩</strong>：Draco是有损压缩，压一次损失一点精度，<strong>别压两遍</strong>！先备份原文件。</li>
<li><strong>WebP兼容性</strong>：虽然现代浏览器都支持WebP，但如果你要兼容IE11（虽然不应该），只能用PNG/JPG。</li>
<li><strong>KTX2谨慎用</strong>：KTX2（Basis Universal）压缩率最高，但需要 GPU 支持，老旧手机可能解码失败，建议 WebP 更稳妥。</li>
<li><strong>量化精度</strong>：如果你发现压缩后的模型出现<strong>裂缝</strong>（顶点没对齐），把 <code>--quantization-position</code> 从 10 调到 14。</li>
</ol>
<p><strong>还有一件事</strong>：Draco是<strong>有损压缩</strong>，但视觉上几乎看不出差别（工业模型顶点精度够高），解压是在Web Worker里进行的，不会卡主线程。</p>
<h3 data-id="heading-6">三、又到了喜闻乐见的前后对比（刺激！）</h3>




















<table><thead><tr><th>指标</th><th>原始模型</th><th>Draco压缩</th></tr></thead><tbody><tr><td><strong>文件体积</strong></td><td>86MB</td><td>4MB</td></tr><tr><td><strong>4G加载时间</strong></td><td>30秒</td><td>1.5秒</td></tr></tbody></table>
<p>可以看到加载时间跨度很大，从30秒到1.5秒，足足提升了20倍，客户本来都要睡着了，但现在客户眨了一下眼睛，就发现眼前屏幕里的世界都不一样了~</p>
<h3 data-id="heading-7">总结</h3>
<p>优化路径：<strong>86MB（原始）→ 4MB（Draco+WebP）→ 1.5秒加载完成</strong></p>
<p><strong>核心认知</strong>：</p>
<ul>
<li><strong>gltf-transform</strong>：一站式解决几何体+贴图压缩，不用Blender，一行命令搞定</li>
<li><strong>Draco</strong>：解决"下载慢"（几何体从18MB压到2MB）</li>
<li><strong>WebP</strong>：解决"贴图肥"（68MB压到2MB，兼容性最好）</li>
</ul>
<p><strong>没用到的手段（进阶可选）</strong>：</p>
<ul>
<li><strong>KTX2</strong>：比WebP体积更小且GPU直读，但需要设备支持，老旧手机可能解码失败</li>
<li><strong>分块加载</strong>：如果4MB还是大，可以拆成"外壳1MB+细节3MB"，首屏秒开</li>
</ul>
<p><strong>不用Blender，全程命令行+代码搞定</strong>，这才是工程师的浪漫。</p>
<p>下篇预告：【ThreeJS实战】GPU还是100%？LOD策略：让远处模型自动"减肥"</p>
<p><strong>互动</strong>：你用<code>gltf-transform</code>压了多少倍？我<strong>20倍</strong>算不算狠？评论区报出你的<strong>原始体积vs优化后体积</strong>，看看谁是真正的"压王"😏</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 React 手搓一个 3D 翻页书籍组件，呼吸海浪式翻页，交互体验带感！]]></title>    <link>https://juejin.cn/post/7603771025856430131</link>    <guid>https://juejin.cn/post/7603771025856430131</guid>    <pubDate>2026-02-08T05:46:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856430131" data-draft-id="7603674653153099785" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 React 手搓一个 3D 翻页书籍组件，呼吸海浪式翻页，交互体验带感！"/> <meta itemprop="keywords" content="前端,GitHub,架构"/> <meta itemprop="datePublished" content="2026-02-08T05:46:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端市界"/> <meta itemprop="url" content="https://juejin.cn/user/289926798641176"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 React 手搓一个 3D 翻页书籍组件，呼吸海浪式翻页，交互体验带感！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/289926798641176/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端市界
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T05:46:14.000Z" title="Sun Feb 08 2026 05:46:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">用 React 手搓一个 3D 翻页书籍组件，页角还能卷起来！从零到踩坑全记录</h2>
<blockquote>
<p>前端开发中，你是否也想过把枯燥的内容展示做得像翻书一样？本文记录了我从零开发一个 <strong>3D 交互式书籍组件</strong> 的完整过程——包括 CSS 3D 翻页、拖拽手势、页角海浪卷起效果，以及中间踩过的坑和最终的解决方案。</p>
</blockquote>
<h3 data-id="heading-1">一、为什么要做这个组件？</h3>
<p>在做一个 AI 知识库产品时，产品经理提了一个需求：</p>
<blockquote>
<p>「能不能把教程做成一本可以翻页的书？用户点击或拖拽就能翻页，体验要像真书。」</p>
</blockquote>
<p>市面上的轮播图、Tab 切换都太「平」了，我希望做一个<strong>有纵深感的 3D 翻书交互</strong>。翻遍了 npm，要么功能太简陋，要么依赖 Canvas 体积太大，最终决定——<strong>自己写一个</strong>。</p>
<p>目标很明确：</p>
<ul>
<li>🎨 CSS 3D 实现真实翻页效果，不用 Canvas</li>
<li>✋ 支持拖拽翻页、点击翻页、键盘翻页</li>
<li>🌊 鼠标悬停页角时有「海浪卷起」的视觉提示</li>
<li>📱 移动端触摸支持</li>
<li>🧱 纯 React 组件，零外部翻书依赖</li>
</ul>
<h3 data-id="heading-2">二、架构设计：一本书的 DOM 结构</h3>
<p>先想清楚一本书的物理结构：</p>
<pre><code class="hljs language-css" lang="css">┌─────────────────────────────────┐
│           Container             │  ← <span class="hljs-attribute">perspective</span>: <span class="hljs-number">2000px</span> 提供 <span class="hljs-number">3</span>D 视角
│  ┌───────────────────────────┐  │
│  │       BookWrapper         │  │  ← 打开时 <span class="hljs-built_in">translateX</span>(<span class="hljs-number">50%</span>) 居中
│  │  ┌─────────────────────┐  │  │
│  │  │      Cover          │  │  │  ← <span class="hljs-built_in">rotateY</span>(-<span class="hljs-number">180deg</span>) 翻开
│  │  │  ┌ front ┐┌ back ─┐ │  │  │
│  │  │  │封面图片││内封页  │ │  │  │
│  │  │  └───────┘└───────┘ │  │  │
│  │  ├─────────────────────┤  │  │
│  │  │      Pages          │  │  │  ← 所有页面叠在一起
│  │  │  ┌ Page <span class="hljs-number">1</span> ────────┐ │  │  │
│  │  │  │ front │ back   │ │  │  │  ← 每页双面
│  │  │  └────────────────┘ │  │  │
│  │  │  ┌ Page <span class="hljs-number">2</span> ────────┐ │  │  │
│  │  │  │ front │ back   │ │  │  │
│  │  │  └────────────────┘ │  │  │
│  │  │  ┌ BackCover ─────┐ │  │  │
│  │  │  │   The End      │ │  │  │
│  │  │  └────────────────┘ │  │  │
│  │  └─────────────────────┘  │  │
│  └───────────────────────────┘  │
│        Navigation Bar           │
└─────────────────────────────────┘
</code></pre>
<p>核心思路：</p>
<ul>
<li>每一页都是绝对定位叠在一起，<code>transform-origin: left center</code>，翻页就是绕左边缘旋转 -180°</li>
<li>用 <code>backface-visibility: hidden</code> + 前后两个 div 模拟正反面</li>
<li>通过 <code>zIndex</code> 控制翻过的页和未翻的页的层叠关系</li>
</ul>
<h3 data-id="heading-3">三、核心实现</h3>
<h4 data-id="heading-4">3.1 CSS 3D 翻页</h4>
<p>关键 CSS：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">2000px</span>;  <span class="hljs-comment">// 3D 视角距离</span>
}

<span class="hljs-selector-class">.page</span> {
  <span class="hljs-attribute">position</span>: absolute;
  inset: 0;
  <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;
  <span class="hljs-attribute">transform-origin</span>: left;  <span class="hljs-comment">// 绕左边轴翻转</span>
}

<span class="hljs-selector-class">.pageFront</span>, <span class="hljs-selector-class">.pageBack</span> {
  <span class="hljs-attribute">backface-visibility</span>: hidden;  <span class="hljs-comment">// 只显示朝向用户的面</span>
}

<span class="hljs-selector-class">.pageBack</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0.5px</span>);  <span class="hljs-comment">// 背面翻转 180°</span>
}
</code></pre>
<p>用 Framer Motion 的 <code>variants</code> 控制翻转动画：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> variants = {
  <span class="hljs-attr">flipped</span>: {
    <span class="hljs-attr">rotateY</span>: -<span class="hljs-number">180</span>,
    <span class="hljs-attr">zIndex</span>: isBuriedLeft ? index + <span class="hljs-number">1</span> : pages.<span class="hljs-property">length</span> + <span class="hljs-number">10</span>,
    <span class="hljs-attr">transition</span>: {
      <span class="hljs-attr">rotateY</span>: { <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">ease</span>: [<span class="hljs-number">0.645</span>, <span class="hljs-number">0.045</span>, <span class="hljs-number">0.355</span>, <span class="hljs-number">1</span>] },
      <span class="hljs-attr">zIndex</span>: { <span class="hljs-attr">delay</span>: <span class="hljs-number">0.6</span> },
    },
  },
  <span class="hljs-attr">unflipped</span>: {
    <span class="hljs-attr">rotateY</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">zIndex</span>: pages.<span class="hljs-property">length</span> - index,
    <span class="hljs-attr">transition</span>: {
      <span class="hljs-attr">rotateY</span>: { <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">ease</span>: [<span class="hljs-number">0.645</span>, <span class="hljs-number">0.045</span>, <span class="hljs-number">0.355</span>, <span class="hljs-number">1</span>] },
      <span class="hljs-attr">zIndex</span>: { <span class="hljs-attr">delay</span>: <span class="hljs-number">0.6</span> },
    },
  },
}
</code></pre>
<p>这里的贝塞尔曲线 <code>[0.645, 0.045, 0.355, 1]</code> 是精心调的，模拟纸张翻页时先快后慢的物理感。</p>
<h4 data-id="heading-5">3.2 拖拽翻页</h4>
<p>参考电子书阅读器的拖拽逻辑：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// mousedown → 记录起点</span>
<span class="hljs-comment">// mousemove → 计算偏移，用 rAF 优化性能</span>
<span class="hljs-comment">// mouseup → 偏移超过阈值(80px)则触发翻页</span>

<span class="hljs-keyword">const</span> handleMouseMove = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e: MouseEvent</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!isDragging) <span class="hljs-keyword">return</span>
  currentDragXRef.<span class="hljs-property">current</span> = e.<span class="hljs-property">clientX</span>
  <span class="hljs-keyword">if</span> (rafIdRef.<span class="hljs-property">current</span>) <span class="hljs-title function_">cancelAnimationFrame</span>(rafIdRef.<span class="hljs-property">current</span>)
  rafIdRef.<span class="hljs-property">current</span> = <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setDragOffset</span>(currentDragXRef.<span class="hljs-property">current</span> - dragStartXRef.<span class="hljs-property">current</span>)
  })
}, [isDragging])
</code></pre>
<p>拖拽过程中，当前页面会有一个「弓起」效果：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> curlAngle = isActiveDragPage
  ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(dragOffset) * <span class="hljs-number">0.25</span>, <span class="hljs-number">45</span>) * (dragOffset &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>)
  : <span class="hljs-number">0</span>
<span class="hljs-keyword">const</span> curlZ = isActiveDragPage
  ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(dragOffset) * <span class="hljs-number">0.15</span>, <span class="hljs-number">30</span>)
  : <span class="hljs-number">0</span>
</code></pre>
<p>根据拖拽偏移量，页面最多弓起 45°，同时沿 Z 轴抬升 30px，配合 <code>box-shadow</code> 产生投影，效果非常逼真。</p>
<h4 data-id="heading-6">3.3 页角海浪卷起效果 🌊</h4>
<p>这是整个组件最有趣的交互细节：鼠标悬停在页角时，纸张会像海浪一样卷起来，提示用户「这里可以翻页」。</p>
<p><strong>实现原理</strong>：在页面的右下角/左下角放置 80×80 的热区，hover 时用 <code>border-radius: 100%</code> + 渐变背景模拟卷角，配合 CSS <code>@keyframes</code> 实现呼吸式波浪动画。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-class">.cornerZone</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
}

<span class="hljs-selector-class">.curlEffect</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: width <span class="hljs-number">0.35s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.34</span>, <span class="hljs-number">1.56</span>, <span class="hljs-number">0.64</span>, <span class="hljs-number">1</span>),
              height <span class="hljs-number">0.35s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.34</span>, <span class="hljs-number">1.56</span>, <span class="hljs-number">0.64</span>, <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// hover 时展开卷角</span>
<span class="hljs-selector-class">.cornerActive</span> <span class="hljs-selector-class">.curlEffect</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">55px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">55px</span>;
}
</code></pre>
<p>卷角的渐变模拟了纸张翻起时的明暗变化：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-class">.cornerBottomRight</span> <span class="hljs-selector-class">.curlEffect</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(
    <span class="hljs-number">225deg</span>,
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">253</span>, <span class="hljs-number">251</span>, <span class="hljs-number">247</span>, <span class="hljs-number">0.95</span>) <span class="hljs-number">0%</span>,    <span class="hljs-comment">// 翻起的纸面（亮）      </span>
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">253</span>, <span class="hljs-number">251</span>, <span class="hljs-number">247</span>, <span class="hljs-number">0.9</span>) <span class="hljs-number">35%</span>,
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">230</span>, <span class="hljs-number">225</span>, <span class="hljs-number">215</span>, <span class="hljs-number">0.85</span>) <span class="hljs-number">50%</span>,   <span class="hljs-comment">// 折痕处（暗）</span>
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">200</span>, <span class="hljs-number">195</span>, <span class="hljs-number">185</span>, <span class="hljs-number">0.4</span>) <span class="hljs-number">70%</span>,
    transparent <span class="hljs-number">100%</span>                  <span class="hljs-comment">// 渐隐到背景</span>
  );
  <span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">100%</span>;      <span class="hljs-comment">// 关键！圆弧形卷角</span>
}
</code></pre>
<p>海浪动画通过 <code>@keyframes</code> 让卷角大小在 50px - 70px 之间波动：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-keyword">@keyframes</span> curlWaveRight {
  <span class="hljs-number">0%</span>   { <span class="hljs-attribute">width</span>: <span class="hljs-number">55px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">55px</span>; }
  <span class="hljs-number">30%</span>  { <span class="hljs-attribute">width</span>: <span class="hljs-number">70px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">70px</span>; }  <span class="hljs-comment">// 浪涌</span>
  <span class="hljs-number">60%</span>  { <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>; }  <span class="hljs-comment">// 回落</span>
  <span class="hljs-number">100%</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">55px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">55px</span>; }  <span class="hljs-comment">// 归位</span>
}
</code></pre>
<p>弹性过渡的贝塞尔曲线 <code>cubic-bezier(0.34, 1.56, 0.64, 1)</code> 让展开有一个「弹一下」的效果，像纸张被风吹起。</p>
<h3 data-id="heading-7">四、踩坑实录：那些让我抓狂的 Bug</h3>
<h4 data-id="heading-8">坑 1：页角点击不触发翻页</h4>
<p><strong>现象</strong>：鼠标在页角卷起后点击，但页面没有翻动。</p>
<p><strong>原因</strong>：<code>mousedown</code> 事件冒泡到了父容器 <code>.pages</code>，触发了拖拽逻辑（<code>isDragging = true</code>）。由于 React 的条件渲染逻辑写了 <code>!isDragging</code>，页角区域立刻被卸载，<code>onClick</code> 根本来不及触发。</p>
<p><strong>解决</strong>：在页角热区上阻止 <code>mousedown</code> 冒泡：</p>
<pre><code class="hljs language-tsx" lang="tsx">&lt;div
  className={styles.<span class="hljs-property">cornerZone</span>}
  onMouseDown={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.<span class="hljs-title function_">stopPropagation</span>()}  <span class="hljs-comment">// 关键！</span>
  onTouchStart={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.<span class="hljs-title function_">stopPropagation</span>()}
  onClick={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.<span class="hljs-title function_">stopPropagation</span>()
    <span class="hljs-title function_">setCornerHover</span>(<span class="hljs-string">'none'</span>)
    <span class="hljs-title function_">nextPage</span>(e)
  }}
&gt;
</code></pre>
<h4 data-id="heading-9">坑 2：翻到下一页时左侧短暂闪烁</h4>
<p><strong>现象</strong>：翻页时左侧会短暂显示封面内容，然后才变成当前页的背面。</p>
<p><strong>第一次尝试（失败）</strong>：用 Framer Motion 的 <code>opacity</code> 动画延迟隐藏已翻过的页面。设置了 <code>delay: 0.65s</code>，等翻转动画完成后再隐藏。</p>
<p><strong>结果</strong>：时序不可靠。<code>opacity</code> 依赖 Framer Motion 的 variant 重算，<code>isBuriedLeft</code> 变化时 variant 值立刻更新，无论 delay 多少都可能出现竞态。</p>
<p><strong>最终方案</strong>：彻底放弃 <code>opacity</code> 动画，改用 CSS <code>visibility</code> 隐藏深层页面：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 只隐藏 "深层" 掩埋的页面（index &lt; currentPageIndex - 1）</span>
<span class="hljs-comment">// 保留紧邻的前一页可见，确保左侧始终有背面内容</span>
<span class="hljs-keyword">const</span> isDeeplyBuried = isFlipped &amp;&amp; index &lt; currentPageIndex - <span class="hljs-number">1</span>

&lt;motion.<span class="hljs-property">div</span> style={{
  <span class="hljs-attr">visibility</span>: isDeeplyBuried ? <span class="hljs-string">'hidden'</span> : <span class="hljs-string">'visible'</span>,
}}&gt;
</code></pre>
<p><code>visibility: hidden</code> 是<strong>即时的、无动画的、确定性的</strong>——完美解决闪烁问题。</p>
<h4 data-id="heading-10">坑 3：翻回上一页时又闪了</h4>
<p><strong>现象</strong>：修好了向后翻页，但翻回上一页时又出现闪烁。</p>
<p><strong>原因</strong>：<code>unflipped</code> variant 的 <code>zIndex</code> transition 的 <code>delay</code> 设为了 <code>0</code>，导致页面还在翻转动画过程中，zIndex 就提前降低了，被其他页面遮挡。</p>
<p><strong>解决</strong>：双向翻页的 <code>zIndex</code> 都延迟到动画结束后再更新：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-attr">unflipped</span>: {
  <span class="hljs-attr">rotateY</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">zIndex</span>: pages.<span class="hljs-property">length</span> - index,
  <span class="hljs-attr">transition</span>: {
    <span class="hljs-attr">rotateY</span>: { <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">ease</span>: [<span class="hljs-number">0.645</span>, <span class="hljs-number">0.045</span>, <span class="hljs-number">0.355</span>, <span class="hljs-number">1</span>] },
    <span class="hljs-attr">zIndex</span>: { <span class="hljs-attr">delay</span>: <span class="hljs-number">0.6</span> },  <span class="hljs-comment">// 和翻页动画时长一致！</span>
  },
},
</code></pre>
<h4 data-id="heading-11">坑 4：最后一页拖不动但光标还是「抓手」</h4>
<p><strong>现象</strong>：翻到最后一页（The End），虽然结束页已经阻止了事件冒泡，但在页面空白区域鼠标仍然显示 <code>grab</code> 光标。</p>
<p><strong>解决</strong>：检测最后一页状态，同时禁用拖拽逻辑和光标样式：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> isLastPage = currentPageIndex &gt;= pages.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>

<span class="hljs-comment">// 禁用 mousedown</span>
<span class="hljs-keyword">const</span> handleMouseDown = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!isOpen || isLastPage) <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 最后一页不触发拖拽</span>
  <span class="hljs-comment">// ...</span>
}, [isOpen, isLastPage])

<span class="hljs-comment">// 光标</span>
<span class="hljs-attr">cursor</span>: isOpen
  ? (isLastPage ? <span class="hljs-string">'default'</span> : isDragging ? <span class="hljs-string">'grabbing'</span> : <span class="hljs-string">'grab'</span>)
  : <span class="hljs-string">'default'</span>
</code></pre>
<h3 data-id="heading-12">五、最终效果</h3>
<p>组件支持的交互方式一览：</p>

































<table><thead><tr><th>交互方式</th><th>说明</th></tr></thead><tbody><tr><td>🖱️ 拖拽翻页</td><td>按住页面左右拖拽，超过 80px 阈值松手翻页</td></tr><tr><td>🌊 页角点击</td><td>悬停右下角/左下角出现卷起效果，点击翻页</td></tr><tr><td>🔘 导航栏</td><td>底部导航栏前后翻页按钮</td></tr><tr><td>⌨️ 键盘</td><td>← → 翻页 / Escape 关闭 / Home End 跳转</td></tr><tr><td>📱 触摸</td><td>移动端触摸滑动翻页</td></tr><tr><td>📕 封面</td><td>点击或向左拖拽打开书籍</td></tr></tbody></table>
<p>使用方式非常简单：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">InteractiveBook</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@stateless/InteractiveBook'</span>

&lt;<span class="hljs-title class_">InteractiveBook</span>
  coverImage=<span class="hljs-string">"/cover.jpg"</span>
  bookTitle=<span class="hljs-string">"AI Agent 完全指南"</span>
  bookAuthor=<span class="hljs-string">"AI 专家"</span>
  pages={[
    {
      <span class="hljs-attr">pageNumber</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'第一章'</span>,
      <span class="hljs-attr">content</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>正面内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
      <span class="hljs-attr">backContent</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>背面内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
    },
    <span class="hljs-comment">// ...</span>
  ]}
  onPageChange={<span class="hljs-function">(<span class="hljs-params">index</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前页:'</span>, index)}
  enableKeyboard
/&gt;
</code></pre>
<h3 data-id="heading-13">六、技术栈总结</h3>

































<table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>React + TypeScript</td><td>组件逻辑</td></tr><tr><td>Framer Motion</td><td>翻页动画、封面动画、导航栏动画</td></tr><tr><td>CSS 3D Transform</td><td><code>perspective</code>、<code>rotateY</code>、<code>preserve-3d</code>、<code>backface-visibility</code></td></tr><tr><td>CSS Modules (Less)</td><td>样式隔离</td></tr><tr><td>requestAnimationFrame</td><td>拖拽性能优化</td></tr><tr><td>lucide-react</td><td>图标</td></tr></tbody></table>
<h3 data-id="heading-14">七、写在最后</h3>
<p>一个看似简单的翻书组件，涉及了 <strong>CSS 3D 变换、事件冒泡机制、Framer Motion variant 生命周期、zIndex 时序控制</strong> 等多个知识点。最大的教训是：</p>
<blockquote>
<p><strong>不要用动画属性（opacity/transform）去做「显示/隐藏」这种二元状态控制。</strong> 用 <code>visibility</code> 或条件渲染——确定性比优雅更重要。</p>
</blockquote>
<p>完整代码已开源，欢迎 Star ⭐</p>
<hr/>
<p>GitHub: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwkylin%2Fpro-react-admin" target="_blank" title="https://github.com/wkylin/pro-react-admin" ref="nofollow noopener noreferrer">Pro React Admin</a></p>
<p>预览地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwkylin.github.io%2Fpro-react-admin%2Fstorybook%2F%3Fpath%3D%2Fdocs%2Fstateless-interactivebook--docs" target="_blank" title="https://wkylin.github.io/pro-react-admin/storybook/?path=/docs/stateless-interactivebook--docs" ref="nofollow noopener noreferrer">Interactive Book</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b38133acbdf4cbdba0dad49c1ca2b75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5biC55WM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771134374&amp;x-signature=8vi1B84z7aKyHbJ8eF2sJ94Y3%2Fo%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51fa994a011548d5bab542b32cf4c44d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5biC55WM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771134374&amp;x-signature=jBlMH%2FU9vdjSpkIqb5fewPRH3Lg%3D" alt="image.png" loading="lazy"/></p>
<p><strong>如果这篇文章对你有帮助，别忘了点个赞 👍 收藏一下 📌</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[APP原生与H5互调Bridge技术原理及基础使用]]></title>    <link>https://juejin.cn/post/7603674653153427465</link>    <guid>https://juejin.cn/post/7603674653153427465</guid>    <pubDate>2026-02-08T03:57:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153427465" data-draft-id="7603688142004469769" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="APP原生与H5互调Bridge技术原理及基础使用"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-08T03:57:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="黄诂多"/> <meta itemprop="url" content="https://juejin.cn/user/510642324769053"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            APP原生与H5互调Bridge技术原理及基础使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/510642324769053/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    黄诂多
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:57:08.000Z" title="Sun Feb 08 2026 03:57:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">API使用</h2>
<h4 data-id="heading-1">js调用原生插件功能</h4>
<p>调用命名为'11'的插件里的一个定时器api：jsCallTimer</p>
<p>带回调结果带参数的调用方式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable constant_">YN</span>.<span class="hljs-title function_">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>,<span class="hljs-string">'我是传到原生端的参数'</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
      <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>){
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress1"</span>).<span class="hljs-property">innerText</span> = value
      }<span class="hljs-keyword">else</span>{
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress2"</span>).<span class="hljs-property">innerText</span> = value
      }
    },<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
      <span class="hljs-title function_">alert</span>(error)
    })
</code></pre>
<p>不带回调结果带参数的调用方式：</p>
<pre><code class="hljs language-arduino" lang="arduino">YN.<span class="hljs-built_in">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>,<span class="hljs-string">'我是传到原生端的参数'</span>)
</code></pre>
<p>不带回调结果不带参数的调用方式：</p>
<pre><code class="hljs language-arduino" lang="arduino">YN.<span class="hljs-built_in">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>)
</code></pre>
<h4 data-id="heading-2">原生调用js插件功能</h4>
<p>调用命名为'asynObj'的插件里的一个定时器api：startTimer</p>
<p>带回调结果带参数的调用方式：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">[dwebview callHandler:<span class="hljs-string">@"asynObj"</span> action:<span class="hljs-string">@"startTimer"</span> arguments:<span class="hljs-string">@"我是传到js端的参数"</span> completionHandler:^(CallbackStatus status, <span class="hljs-type">id</span>  _Nonnull value, <span class="hljs-built_in">NSString</span> * _Nonnull callId, <span class="hljs-type">BOOL</span> complete) {
        [sender setTitle:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"%@-%@"</span>,value,callId] forState:<span class="hljs-number">0</span>];
    }];
</code></pre>
<p>不带回调结果的调用方式：</p>
<pre><code class="hljs language-csharp" lang="csharp">[<span class="hljs-meta">dwebview callHandler:@<span class="hljs-string">"asynObj"</span> action:@<span class="hljs-string">"startTimer"</span> arguments:@<span class="hljs-string">"我是传到js端的参数"</span> completionHandler:nil</span>];
</code></pre>
<h2 data-id="heading-3">一些全局约定</h2>
<ul>
<li>
<p>js调原生和原生调js的参数传递必须是json字符串格式。</p>
</li>
<li>
<p>api调用,底层逻辑必须使用命名空间方式即：namespace.apixxx的形式。</p>
</li>
<li>
<p>还有很多规范和约定，后续补充。</p>
</li>
</ul>
<h2 data-id="heading-4">js call native</h2>
<h4 data-id="heading-5">关键技术点</h4>
<p>原生Android端向浏览器注入供js调用的对象‘_anbridge’，对象里实现‘call()’方法，并且方法需要加上@JavascriptInterface注解，代码示例：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">WebSettings</span> <span class="hljs-variable">webSettings</span> <span class="hljs-operator">=</span> wv.getSettings();
webSettings.setJavaScriptEnabled(<span class="hljs-literal">true</span>);
wv.addJavascriptInterface(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsApp</span>(),<span class="hljs-string">"_anbridge"</span>);
<span class="hljs-keyword">class</span> <span class="hljs-title class_">JsApp</span>{
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsApp</span><span class="hljs-params">()</span>{}
  <span class="hljs-meta">@JavascriptInterface</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">(Object obj)</span>{

  }
}
</code></pre>
<p>原生iOS端</p>
<p>向浏览器配置对象里注入‘window._ynwk=true;’这段js代码，并且设置注入时机为开始加载时即：injectionTime=WKUserScriptInjectionTimeAtDocumentStart,代码实现：</p>
<pre><code class="hljs language-ini" lang="ini">///初始化注入js标记
    WKUserScript *<span class="hljs-attr">script</span> = [[WKUserScript alloc] initWithSource:@<span class="hljs-string">"window._ynwk=true;"</span>
                                                  injectionTime:WKUserScriptInjectionTimeAtDocumentStart
                                               forMainFrameOnly:<span class="hljs-literal">YES</span>]<span class="hljs-comment">;</span>
    <span class="hljs-section">[configuration.userContentController addUserScript:script]</span><span class="hljs-comment">;</span>
</code></pre>
<p>实现js端换起原生通信的关键是实现wk的h5输入框拦截回调方法- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler<br/>
当js端执行代码‘prompt()’时原生端就会自动调起该方法</p>
<p>在上面实现的基础上，js端判断window._anbridge为true则为与Android通信，执行代码：_anbridge.call(api, arg)，如果判断window._ynwk为true则为与iOS端通信，执行代码：prompt('_ynbridge=' + api, arg)，js端代码实现：</p>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">natiValue</span> = <span class="hljs-string">''</span><span class="hljs-comment">;</span>
if (window._anbridge)
   <span class="hljs-attr">natiValue</span> = _anbridge.call(api, arg)<span class="hljs-comment">;//调用android对象的call()</span>
else if (window._ynwk)
   <span class="hljs-attr">natiValue</span> = prompt(<span class="hljs-string">'_ynbridge='</span> + api, arg)<span class="hljs-comment">;</span>
</code></pre>
<p>原生端、js端提供的api都要通过命名空间的方式管理，如：api_1在‘namespace1’这个命名空间下的类里面，则js端调用api_1书写形式为‘namespace1.api_1’。</p>
<p>原生端和js端提供的功能都以插件的方式提供，插件（除基础插件）都继承自一个基础插件类，插件结果回调都是走异步回传值方式，同步方式也可以但暂没实现。</p>
<h4 data-id="heading-6">iOS端逻辑步骤</h4>
<p>基础插件对象是处理js通讯和插件扩展的必要条件，wk浏览器初始化好后将基础插件类注册进插件集合，然后读取配置文件里可用的其他插件，将每个插件类注册进插件集合，代码实现：</p>
<pre><code class="hljs language-objectivec" lang="objectivec"><span class="hljs-comment">//注册基础插件</span>
    [<span class="hljs-keyword">self</span> addJavascriptObject:<span class="hljs-keyword">self</span>.ynPlugin namespace:baseNameSpace];
    <span class="hljs-comment">//注册已有插件</span>
    <span class="hljs-built_in">NSString</span>* plistPath = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@"applyPlugPlist"</span> ofType:<span class="hljs-string">@"plist"</span>];
    <span class="hljs-built_in">NSArray</span> *modules = [<span class="hljs-built_in">NSArray</span> arrayWithContentsOfFile:plistPath];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSDictionary</span> *obj <span class="hljs-keyword">in</span> modules) {
        Class <span class="hljs-keyword">class</span> = <span class="hljs-built_in">NSClassFromString</span>(obj[<span class="hljs-string">@"plug"</span>]);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> != <span class="hljs-literal">nil</span> &amp;&amp; ![<span class="hljs-keyword">class</span> isKindOfClass:[<span class="hljs-built_in">NSNull</span> <span class="hljs-keyword">class</span>]]) {
            [<span class="hljs-keyword">self</span> addJavascriptObject:[[<span class="hljs-keyword">class</span> alloc] init] namespace:obj[<span class="hljs-string">@"namespace"</span>]];
        }
    }
</code></pre>
<ol>
<li>
<p>js端的第一个信号来自wk的h5输入框拦截回调方法，参数prompt里携带js端要调用的api名字，参数值为字符串：_ynbridge=namespace1.api_1，_ynbridge=为YNBridge框架调用的标记，如果不是以这个标记开头则不做任何处理，只弹出正常的系统弹框。</p>
</li>
<li>
<p>通过api名，去插件集合里找有没有注册对应的插件对象，如果没有找到或找到了但插件下没有对应api则将错误结果返回js端</p>
</li>
<li>
<p>js调起的api，参数由defaultText携带。defaultText是json字符串，需要转换为json对象来解析出数据，参数值示例：{"data":null,"callId":"callId0"} data:真实参数值。 callId:api调用事件id或叫回传值队列id，当次api调用js需要回传值时此参数不为空，如果为空则表示当次api调用js端不需要结果回调</p>
</li>
<li>
<p>-(BOOL)exec:(YNJsCallInfo*)arg 此方法是插件接收数据的入口，这是个工厂方法子类必须实现，解析和组装好js过来的api和参数后用反射的方式执行对应插件的exec:方法，该方法同步方式返回个bool值，表示调用成功或失败，如果失败则将失败结果返回给js，代码实现：</p>
</li>
</ol>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">BOOL</span>(*action)(id,SEL,id) = (BOOL(*)(id,SEL,id))objc_msgSend;
    BOOL ret=<span class="hljs-built_in">action</span>(JavascriptInterfaceObject,sel,info);
    if (ret) {
        return YES;
    }
    return <span class="hljs-selector-attr">[self nativeCallBackWithCode:ret ? OK : ERROR value:ret ? @<span class="hljs-string">"OK"</span> : error complete:YES callId:info.callId]</span>;
</code></pre>
<ol>
<li>
<p>exec:方法的形参是YNJsCallInfo对象，该对象携带的参数：<br/>
action:api名，或叫动作标识字符串，各业务通过该字段判断该执行什么功能，如果插件内没有处理该api则返回调用失败的错误值false反之返回true。<br/>
callId:api调用事件id或叫回传值队列id，当给js回传值时需要带上该值返回去。<br/>
data:js给过来的参数值。<br/>
callBack:block变量，结果回调入口，回传值时需要指定四个参数status、value、callId、complete，参数用处后面讲解。</p>
</li>
<li>
<p>功能实现完成后需要调用YNJsCallInfo对象的callBack回调方法，方法参数：<br/>
status:结果状态值，此值为一个枚举类型，OK表示成功ERROR表示失败。<br/>
value:结果值，该值最后在调用js回传值api时会转换为json字符串格式。<br/>
callId:api调用事件id或叫回传值队列id。<br/>
complete:bool值，当次api任务是否全部执行完毕，处理需要保活服务的长连接状态，false执行完毕，true服务需要继续保持。</p>
</li>
<li>
<p>api调用完毕，需要给js回传值时，调用wk的- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id, NSError * _Nullable error))completionHandler方法 执行这段js代码：window.nativeCallBack('%@',%ld,%@,%d)，nativeCallBack()是js端接收原生端回传值的方法，接收四个参数，即为YNJsCallInfo对象的callBack回调参数。</p>
</li>
<li>
<p>原生功能通过插件的形式实现，要新增一个插件只需要： 第一步新建一个继承'YNPlugin'基础插件类的对象，然后在对象里实现方法-(BOOL)exec:(YNJsCallInfo*)arg； 第二步在YNBridgePlugPlist.plist文件里添加以下形式的代码</p>
</li>
</ol>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>namespace<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>命名空间<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>plug<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>nativeCallBack
        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>插件类名<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
</code></pre>
<p>然后将命名空间名和相应的api名告诉js端即可</p>
<h4 data-id="heading-7">js端</h4>
<p>调起一个原生插件时，执行YN对象里面的callNative: function (service,action,actionArgs,successCallback,failCallback)方法，方法参数：<br/>
service:原生api对应的命名空间名。<br/>
action:api名。<br/>
actionArgs:需要给原生端的参数。<br/>
successCallback:成功的回调。<br/>
failCallback:失败的回调。 比如我要调起原生端11命名空间下的jsCallTimer这个api，让原生端执行一个定时器功能，代码实现：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable constant_">YN</span>.<span class="hljs-title function_">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
      <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>){
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress1"</span>).<span class="hljs-property">innerText</span> = value
      }<span class="hljs-keyword">else</span>{
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress2"</span>).<span class="hljs-property">innerText</span> = value
      }
    },<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
      <span class="hljs-title function_">alert</span>(error)
    })
</code></pre>
<ol>
<li>
<p>执行YN.call()方法，实现调起原生和结果回调队列的维护，如果注入过安卓js对象‘window._anbridge’则执行_anbridge.call(api, arg)调起安卓端，如果注入过‘window._ynwk’值为true则执行prompt('_ynbridge=' + api, arg)调起iOS端，如果需要有回传值，则arg对象将给callId字段赋一个唯一值，并且在window.nativeCallBackIds缓存集合里新增callId值，值即为回调函数。</p>
</li>
<li>
<p>所有插件调用的前提基础是js端和原生端都已正常初始化，并且通讯已建立，即deviceReady已为ture，deviceReady的询问会在js入口函数里执行，即通过YN.call()方法，执行一个原生YNBase.init的api，如果结果返回为OK则为deviceReady成功</p>
</li>
<li>
<p>原生端插件执行结果回调通过‘nativeCallBack = function (callId,status,args,complete)’方法接收值，方法内部通过callId在window.nativeCallBackIds对象里找到回调方法然后执行，将args值由json字符串转json对象后传入，判断complete字段，为true则执行：delete window.nativeCallBackIds[callId]代码，将该服务回调移除队列。</p>
</li>
</ol>
<h2 data-id="heading-8">native call js</h2>
<h4 data-id="heading-9">js端</h4>
<ol>
<li>实现思路和设计方式同js call native，即只是其一个反向过程，实现基础依然是需要实现和注册基础插件类，各子插件继承基础插件，结果回调都是通过异步回传值，所以细节不做重复阐述。</li>
<li>在入口函数执行基础插件和各插件对象的注册，注册完成后可以调用原生YNBase.jsinit这个api告诉原生端，代码实现：</li>
</ol>
<pre><code class="hljs language-arduino" lang="arduino">YN.<span class="hljs-built_in">register</span>(<span class="hljs-string">'asynObj'</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">YNPlugin</span>());
   YN.<span class="hljs-built_in">register</span>(<span class="hljs-string">'YNPlugin1'</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">YNPlugin1</span>());
  <span class="hljs-comment">//告诉原生js初始化了，调原生初始化api（在js初始化前原生就要求执行的js方法可在jsinit方法里开始执行了）</span>
  <span class="hljs-keyword">if</span> (deviceReady){
    YN.<span class="hljs-built_in">call</span>(<span class="hljs-string">'YNBase.jsinit'</span>);
  }
</code></pre>
<p>register()方法内部实现同原生注册插件的形式，将插件和对应的命名空间添加进window.nativeNamespaceInterfaces集合。</p>
<ol start="3">
<li>
<p>接收原生端第一个信号由nativeCallJs = function(callId,service,action,actionArgs)方法接收，参数：<br/>
callId:api调用事件id或叫回传值队列id。<br/>
service:js api对应的命名空间名。<br/>
action:api名。<br/>
actionArgs:原生端的参数。 方法内部实现同原生插件调用，也是找到插件并执行插件方法exec(action,args,responseCallback)。</p>
</li>
<li>
<p>插件回传值结果和api调用结果通过调用原生的YNBase.returnValue这个api实现，即执行YN.call('YNBase.returnValue', value); value是参数对象，包含data、callId、complete、status四个字段，含义和用途同原生回调那里。</p>
</li>
</ol>
<h4 data-id="heading-10">iOS端</h4>
<ol>
<li>
<p>调起一个js端的插件功能，执行wk对象的方法-(void)callHandler:(NSString*)server action:(NSString *)action arguments:(id)args completionHandler:(JSCallback)completionHandler;该方法逻辑同js call native时调用的YN.call()方法，通过维护一个callid服务队列来处理结果回传。</p>
</li>
<li>
<p>组装好参数后浏览器执行window.nativeCallJs('%@','%@','%@',%@)这个js代码即可调起js，代码示例：</p>
</li>
</ol>
<pre><code class="hljs language-objectivec" lang="objectivec">[<span class="hljs-keyword">self</span> evaluateJavaScript:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"window.nativeCallJs('%@','%@','%@',%@)"</span>,info.callId,info.service,info.action,[JSBUtil objToJsonString:info.args]]];
</code></pre>
<p>接收插件结果回传值在基础插件里监听returnValue这个api的执行，逻辑处理同js端nativeCallBack()方法。也是如果complete字段值为true时将该服务对象从队列里移除</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[command和shell模块到底区别在哪？]]></title>    <link>https://juejin.cn/post/7603651011979427882</link>    <guid>https://juejin.cn/post/7603651011979427882</guid>    <pubDate>2026-02-08T04:27:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651011979427882" data-draft-id="7603769956974936105" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="command和shell模块到底区别在哪？"/> <meta itemprop="keywords" content="Linux,Ansible,云计算"/> <meta itemprop="datePublished" content="2026-02-08T04:27:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Sheffield"/> <meta itemprop="url" content="https://juejin.cn/user/362164852109770"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            command和shell模块到底区别在哪？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/362164852109770/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Sheffield
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:27:58.000Z" title="Sun Feb 08 2026 04:27:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>刚学Ansible的新手，肯定都懵过：command和shell模块，不都是远程执行命令吗？为啥有时候用command报错，换shell就好使？</p>
<p>核心就1句大白话：<strong>执行命令时，要不要找“中间人”（shell解释器）帮忙</strong>。不用记复杂概念，今天用最简单的话+实操例子，讲清两者区别，新手看完就知道该用哪个。</p>
<h2 data-id="heading-0">一、先搞懂：两者执行方式不一样</h2>
<p>不用管底层原理，记住两个类比，瞬间明白：</p>
<h3 data-id="heading-1">1. command模块：直接“喊”程序干活，不找中间人</h3>
<p>用command执行命令，会直接调用目标机器上的程序，不经过任何“翻译”（shell解释器，比如bash）。</p>
<p>例子：用command执行ls /home，Ansible直接找到系统里的ls程序，让它查/home目录，一步到位。</p>
<p>特点：快、简单，但笨——不支持任何“高级操作”（比如管道、重定向）。</p>
<h3 data-id="heading-2">2. shell模块：先找中间人，再让中间人“喊”程序干活</h3>
<p>用shell执行命令，会先启动目标机器的默认“中间人”（默认是/bin/sh），再让这个中间人去调用程序、执行命令。</p>
<p>还是执行ls /home，用shell的话，流程是：Ansible启动中间人→中间人喊ls程序→执行命令。</p>
<p>特点：灵活、能干——支持所有高级操作，但比command慢一点，还有点安全风险。</p>
<h2 data-id="heading-3">二、核心区别：一张表看清</h2>
<p>不用死记，遇到分不清的情况，对照这张表找答案，一目了然：</p>








































<table><thead><tr><th>对比维度</th><th>command模块</th><th>shell模块</th></tr></thead><tbody><tr><td>要不要中间人（shell）</td><td>不要，直接调用程序</td><td>要，默认用/bin/sh</td></tr><tr><td>支持管道(|)</td><td>不支持（新手记死）</td><td>支持</td></tr><tr><td>支持重定向（&gt;、&gt;&gt;）</td><td>不支持（新手记死）</td><td>支持</td></tr><tr><td>支持环境变量（$HOME等）</td><td>不支持（直接输出$HOME）</td><td>支持（能输出真实路径）</td></tr><tr><td>安全性</td><td>高（不容易出问题）</td><td>较低（有安全风险）</td></tr><tr><td>Ansible默认用哪个</td><td>是（不指定模块就用它）</td><td>否（要手动指定-m shell）</td></tr></tbody></table>
<h2 data-id="heading-4">三、实战示例：新手最常遇到的3种情况</h2>
<p>光看表不够，结合例子练1次，以后再也不踩坑！</p>
<h3 data-id="heading-5">场景1：简单命令（比如重启服务）——优先用command</h3>
<p>像重启nginx、查看文件，这种简单操作，两者都能用，但优先选command（快、安全）。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 推荐：用command重启nginx</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span> <span class="hljs-string">with</span> <span class="hljs-string">command</span>
  <span class="hljs-attr">command:</span> <span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span>

<span class="hljs-comment"># 能用但没必要：用shell重启nginx</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span> <span class="hljs-string">with</span> <span class="hljs-string">shell</span>
  <span class="hljs-attr">shell:</span> <span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span>
</code></pre>
<h3 data-id="heading-6">场景2：用管道、重定向——只能用shell</h3>
<p>新手最容易踩坑的地方！只要命令里有|、&gt;、&gt;&gt;，用command必报错，换shell就好。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 错误：command不能用管道</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">查看java进程（报错）</span>
  <span class="hljs-attr">command:</span> <span class="hljs-string">ps</span> <span class="hljs-string">aux</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">java</span>

<span class="hljs-comment"># 正确：用shell执行管道命令</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">查看java进程（正常）</span>
  <span class="hljs-attr">shell:</span> <span class="hljs-string">ps</span> <span class="hljs-string">aux</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">java</span>

<span class="hljs-comment"># 正确：用shell重定向写入文件</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">写内容到文件</span>
  <span class="hljs-attr">shell:</span> <span class="hljs-string">echo</span> <span class="hljs-string">"Sheffield"</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">/tmp/test.txt</span>
</code></pre>
<h3 data-id="heading-7">场景3：用环境变量（比如$HOME）——只能用shell</h3>
<p>想调用<code>$HOME、$PATH</code>这种环境变量，command不识别，必须用shell。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 正确：用shell查看家目录</span>
- name: 查看家目录
  shell: <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span> <span class="hljs-comment"># 会输出/root（管理员用户）</span>

<span class="hljs-comment"># 错误：command查看家目录（只会输出$HOME）</span>
- name: 查看家目录（报错效果）
  <span class="hljs-built_in">command</span>: <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span>
</code></pre>
<h2 data-id="heading-8">四、安全提醒</h2>
<p>shell虽然好用，但如果命令里有用户输入、变量，容易被恶意攻击（比如删文件）。</p>
<p>简单说：能不用shell就不用，必须用的时候，别随便放用户输入的内容。</p>
<h2 data-id="heading-9">五、新手速记：3句话搞定所有场景</h2>
<ol>
<li>简单命令（不涉及|、&gt;、$）：优先用command（默认、安全、快）；</li>
<li>用到管道、重定向、环境变量：只能用shell；</li>
<li>命令里有用户输入、变量：优先用command，避免风险。</li>
</ol>
<h2 data-id="heading-10">常见误区（避坑！）</h2>
<ol>
<li>
<p>误区：shell比command强，所有场景都用shell</p>
<p>——错！非必要不用，费资源还不安全；</p>
</li>
<li>
<p>误区：两者用法不一样</p>
<p>——错！常用参数（比如切换目录），用法完全相同；</p>
</li>
<li>
<p>误区：command用不了的，shell也用不了</p>
<p>——错！只要有shell解释器，shell都能搞定。</p>
</li>
</ol>
<p>其实新手不用想太复杂，记住“简单用command，复杂用shell”，就能应对99%的场景。练两次实操，很快就能分清～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[浅析二叉树、B树、B+树和MySQL索引底层原理]]></title>    <link>https://juejin.cn/post/7603651855236743177</link>    <guid>https://juejin.cn/post/7603651855236743177</guid>    <pubDate>2026-02-08T06:02:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651855236743177" data-draft-id="7603674653153689609" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="浅析二叉树、B树、B+树和MySQL索引底层原理 "/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:02:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="神奇小汤圆"/> <meta itemprop="url" content="https://juejin.cn/user/1151943919285431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            浅析二叉树、B树、B+树和MySQL索引底层原理 
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1151943919285431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    神奇小汤圆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:02:48.000Z" title="Sun Feb 08 2026 06:02:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>数据库是后端工程师绕不开的核心技术，而索引则是核心中的核心。在日常工作中，我们每天都在和索引打交道，索引问题也是高级工程师面试中，面试官最喜欢考察的地方。</p>
<p>  很多开发者在面试中谈及索引时，往往只能给出一些零散、机械的记忆性答案，比如“B+树查询快”、“索引能提速”。这样的回答在面试官心中留下的深刻印象就是此候选人学习知识浅尝辄止，不够深入，不够努力。真正体现一个工程师技术深度的，是对索引背后设计原理的系统性理解，以及在复杂场景下进行选型和优化的能力。</p>
<p>  在 MySQL 中，通常所说的索引，如果没有特别声明，默认都是指 B+ 树数据结构的索引。在介绍各种树的数据结构和MySQL索引之前，先介绍本文多次使用的几个基本概念：</p>
<p><strong>节点</strong>：包含一个数据元素及若干指向子树的指针等。<br/>
<strong>根节点</strong>：是树的起始节点，它没有父节点，就像是大树的根基，其它节点都从根节点衍生出来。<br/>
<strong>叶子节点</strong>：也叫终端节点，是没有子节点的节点，它们位于树的最底层，就像树枝的末梢。<br/>
‌<strong>内部节点</strong>（internal Node）‌：至少有一个子节点的节点，包括根节点和所有非叶子节点。<br/>
<strong>兄弟节点</strong>： 具有相同父节点的节点。<br/>
<strong>节点的度</strong>：该节点拥有的子节点个数。例如二叉树中节点的度最大为 2，即每个节点最多有两个子节点。<br/>
<strong>树的度</strong>：整棵树中所有节点的最大度数。<br/>
<strong>层级</strong>：从根节点开始，树的每一层都是一个层级。<br/>
<strong>高度</strong>（height）：当前节点到最远叶子节点的最长路径上的节点数。<br/>
<strong>平衡因子</strong>（Balance Factor）：简称BF，每个节点的左右子树的高度之差。<br/>
<strong>数据页</strong>：树上每个节点在计算机中叫做数据页，是 InnoDB 存储引擎与磁盘交互的最小单位，默认大小为 16KB。<br/>
<strong>阶数</strong>：一个节点最多可以有多少个子节点（即节点的最大度数），一般用小写字母m表示阶数。用⌈m/2⌉表示对m/2向上取整数。例如，三阶 B+ 树 → 每个节点最多 3 个子节点 → 最大度 = 3。</p>
<p>  在数据库中我们将B+树作为索引结构，可以加快查询速度，此时树中的key一般是表的主键。例如，MySQL InnoDB 的记录，就是按照主键由小到大排序后，存在 B+ 树的叶子节点里。树中每个节点存储了关键字（key）、关键字对应的数据（data）以及指向孩子节点的指针。我们将一个key及其对应的data称为一条 <strong>记录</strong>。但为了方便描述，除非特别说明，后续文中就用“关键字”来代指（key, value）键值对。下面就是MySQL中索引的数据结构：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1425079df27a4ec6961449e319c95016~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=tDSMLNqTd%2FyFEdPl1CSvqd6ZH1w%3D" alt="image" loading="lazy"/><br/>
图1 索引的数据结构。备注：磁盘块4有笔误，应该删除10。</p>
<p>  不同的树结构适用于不同的应用场景，选择合适的树结构可以显著提高程序的性能和效率。在分析为什么MySQL InnoDB存储引擎的索引选择使用B+树之前，我相信很多攻城狮对数据结构中的树还是有些许模糊的，因此就让我们一同踏上这趟由浅入深探讨二叉查找树、AVL树、红黑树、B树和B*树的奇妙之旅，一步步引出B+树以及为什么MySQL InnoDB数据库索引选择使用B+树！领略B+树在数据库索引中应用的神奇魅力。希望通过本文，你能构建起一个体系化的树和索引知识框架，让你在未来的面试和工作中游刃有余。</p>
<h3 data-id="heading-0">二叉查找树</h3>
<p>  二叉查找树(Binary Search Tree, BST)也称为有序二叉树（Ordered Binary Tree）、排序二叉树（sorted binary tree）或者二叉搜索树，是一棵满足以下三个性质的二叉树：</p>
<ol>
<li>有序性：任意非空左子树所有节点的值均小于该节点的值；非空右子树所有节点的值均大于于该节点的值；</li>
<li>递归性：任意节点的子树都是二叉查找树；</li>
<li>每个节点存储一条记录，且没有键值相等的节点。</li>
</ol>
<p>  从递归定义的角度来看，二叉查找树可以被定义为：要么是一棵空树，要么是由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；而左子树和右子树又同样都是二叉查找树。这种递归定义方式简洁而准确地描述了二叉查找树的结构特点。它作为基础的树形结构，<strong>每个节点最多有两个子节点</strong>，其递归性和有序性为我们理解更复杂的树结构奠定了基础。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c3fe3ef4df44f3891671296a5f6f280~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=2WNazK3yj09jeAg7U3I%2BfBWNA7E%3D" alt="image" loading="lazy"/><br/>
图2 二叉搜索树</p>
<p>  如果我们需要查找id=31的记录，利用我们创建的BST，基于二分查找算法实现的查找流程如下：</p>
<ol>
<li>将根节点作为当前节点，把31与当前节点的键值33比较，31小于33，接下来我们把当前节点的左子节点作为当前节点。</li>
<li>继续把31和当前节点的键值28比较，发现31大于28，把当前节点的右子节点作为当前节点。</li>
<li>把31和当前节点的键值31对比，发现二者相等，满足条件，遍历结束。</li>
</ol>
<p>  所以，我们利用BST只需要3次即可找到目标数据。</p>
<p>  二叉树的查找、插入和删除操作的时间复杂度在平均情况下为 O(logn) ，但在最坏情况下，当二叉树退化为链表时，时间复杂度会变为 O(n) 。这是因为在最坏情况下，所有节点都在一条链上，查找、插入和删除都需要遍历整个链表。如下图所示退化的二叉查找树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2cdd2f92a86b41e39d80d6337863cad4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=UzRdZ3knfyovWg%2BZOtpNmTRnBxI%3D" alt="image" loading="lazy"/></p>
<p>  二叉树完全不平衡时，查找的时间复杂度就和链表一致了：O(n)。导致这个现象的原因其实是BST变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。为了解决这个问题，我们需要保证二叉查找树一直保持平衡，从而引出了一个新的定义——平衡二叉树AVL。</p>
<h3 data-id="heading-1">AVL树/红黑树</h3>
<p>  平衡二叉树（Balanced Binary Tree）是一种特殊的、平衡的二叉搜索树，通过严格控制每个节点的平衡因子来保持树的平衡。常见的平衡二叉树有AVL树和红黑树等，在满足BST特性的基础上，具有如下特性：</p>
<ol>
<li>平衡因子限制‌：要求平衡因子的绝对值不能超过1。</li>
<li>递归性质‌：左右两个子树本身也都是平衡二叉树。</li>
</ol>
<p>  不管是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转树上的节点来保持平衡，使得树的高度始终保持在 O(logn)的范围内。而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入或者删除次数比较少，但查找多的情况。</p>
<p>🤔 为什么要平衡？</p>
<p>  保持效率：平衡的二叉搜索树可以确保不管是执行插入还是删除操作都能在O(logn)时间内完成，这对于需要高效处理数据的系统来说至关重要。</p>
<p>  避免最坏情况：没有平衡机制的数据结构在最坏情况下可能会退化成链表，导致效率大大降低。平衡机制通过旋转操作<br/>
完成，而旋转操作非常耗时，由此我们可以知道AVL树适合用于插入或者删除次数比较少，但查找多的情况。本文不介绍具体的旋转操作。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/938839846591468ca7f81485a5c664ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=AKUbnuhg%2F7qN0PNfKup1U%2FG8WeQ%3D" alt="image" loading="lazy"/></p>
<p>  平衡二叉树通过约束节点的子树高度差，确保树的高度保持对数级，相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p>
<p>  红黑树（Red-Black Tree）因节点是红色和黑色两种颜色之一而命名，它本身是一棵二叉查找树，在其基础上做了如下约束：</p>
<ul>
<li>根节点是黑色节点</li>
<li>所有叶子节点（NIL节点）都是黑色的</li>
<li>节点的颜色要么是黑色要么是红色</li>
<li>无连续红色节点：红色节点的子节点为黑色节点（即相邻的两个节点不可能同时为红色）</li>
<li>任意节点的左子树和右子树高度（只统计黑色节点）相同</li>
<li>旋转操作：当插入或删除导致树不平衡时，通过旋转操作来恢复平衡。</li>
</ul>
<p>  这些规则看起来是否有点复杂？其实它们的核心目的只有一个：控制整棵树的高度，防止退化成链表。</p>
<p>  下图是一个标准的红黑树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1d06f02ab84420fa341474d8011b03c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=l%2FG6MXeZLG1koYAovjrS7DrFxfo%3D" alt="image" loading="lazy"/></p>
<p>  黑色完美平衡：“任意节点的左子树和右子树高度（只统计黑色节点）相同 &amp; 红色节点的子节点是黑色节点”。这就保证了红黑树的“平衡性”。由于这种平衡，其查询的复杂度自然也是O(log n)的。</p>
<p>红黑树与AVL树的区别：</p>






























<table><thead><tr><th>特性</th><th>AVL 树</th><th>红黑树</th></tr></thead><tbody><tr><td>平衡性</td><td>非常严格，平衡因子最多为1</td><td>近似平衡，只要求从根到叶子的最长路径不超过最短路径的两倍</td></tr><tr><td>插入性能</td><td>多次旋转，效率较低</td><td>快（最多两次旋转）</td></tr><tr><td>删除性能</td><td>多次旋转，效率更低，代价更高</td><td>较快（最多三次旋转）</td></tr><tr><td>查找性能</td><td>更快</td><td>稍慢（但仍为 O(log n)）</td></tr></tbody></table>
<p>  相较于 AVL 树，它是一种弱平衡二叉树，不需要像 AVL 树那样严格要求平衡，这也导致它的查询效率并没有 AVL 树那么高，但相对的，它带来的好处是对于调整失衡，红黑树的旋转次数更少，所以频繁的插入或删除操作，红黑树更有优势。</p>
<p>  AVL 是“强迫症患者”，每次插入删除都可能引发多次旋转，代价太高；而红黑树是“实用主义者”，它不要求完全平衡，只要能保证查找效率不崩就行。红黑树是在“速度”、“稳定性”和“实现成本”之间找到的一个折中王者！</p>
<p>  红黑树更常用于需要高频插入和删除的场景，例如：java 8 HashMap和ConcurrentHashMap中链表转红黑树；epoll在内核中的实现，用红黑树管理事件块（文件描述符）；Java的TreeMap和TreeSet实现；linux进程CFS调度器（Completely Fair Scheduler）用红黑树管理进程控制块 ；nginx中，用红黑树管理timer。AVL树更适合读多写少的场景，因为它的查找性能更接近完美的平衡树。</p>
<h3 data-id="heading-2">B树(B-tree)</h3>
<p>  当数据量太大，无法全部装入内存时，就必须存放在磁盘上。磁盘I/O（读写）速度远远逊色于内存访问。B树和B+树就是为了减少磁盘I/O次数而设计的多路平衡搜索树，它们被广泛用于数据库和文件系统的索引。下面介绍B树。</p>
<p>  B树（Balance Tree）也称B-树，是一棵平衡多路查找树，<strong>节点的子节点个数可能超过两个</strong>，用来存储排序后的数据。我们描述一棵B树时需要指定它的阶数m，当m=2时，就是我们常见的二叉搜索树。B树是一种自平衡的树状数据结构，能够让数据的查找、插入及删除动作都在对数时间内完成，常常用在存储系统上，如数据库或文件系统。</p>
<p>  一棵m阶的B树，或为空树，或为满足下列特性的m叉树：</p>
<ol>
<li>每个节点最多有m（m&gt;=2）棵子树，除非根节点为叶子节点，否则，至少有两棵子树。例如，对于一个4阶B树，每个节点最多有4个孩子，最少有2个孩子；</li>
<li>每个节点存放至少 <strong>⌈m/2⌉-1</strong> 个关键字，至多 <strong>m-1</strong> 个关键字；</li>
<li>关键字个数比孩子节点个数小1。即如果一个节点有k个关键字，那么它就有k + 1个孩子。如下图所示为一棵3阶B树的结构示意图，根节点有2个关键字和3个指针，它有3个孩子，这些孩子分别对应关键字划分的3个区间：</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91865d6b93bc483a98957fb0e22feb43~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=Vr1Eq6Cx%2BOMo6vcD1P2dnT5H%2FEU%3D" alt="image" loading="lazy"/></p>
<ol start="2">
<li>若根节点不是叶子节点，则至少包含两棵子树（特殊情况：没有孩子的根节点，即根节点为叶子节点，整棵树只有一个根节点）；</li>
<li>除根节点和叶子节点外，其它每个节点至少有 <strong>⌈m/2⌉</strong> 棵子树；</li>
<li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它；</li>
<li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。这保证了B树的平衡性，使得查找操作的时间复杂度为O(logn)。</li>
</ol>
<p>  下图即是一棵 m=3 的B树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e41b73427d8b47ebb6a039f3b6c8f06c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=YJMBBJzKBXHMAR2ikjE1qOXkts8%3D" alt="image" loading="lazy"/></p>
<p>  在实际应用中B树的阶数都非常大，通常大于100，所以即使存储大量的数据，B树的高度仍然比较小。每个节点中存储了关键字（key）和关键字对应的数据（data）以及孩子节点的指针。B树和平衡二叉树的不同之处：B树属于多叉树，父节点的子节点个数不止两个。注意: 有文章把B树和B-tree理解成了两种不同类别的树，其实二者是同一种树。B树有如下数据特征：</p>
<ol>
<li>数据存储在整棵树中；</li>
<li>任何一个关键字出现且只出现在一个节点中；</li>
<li>搜索有可能在非叶子节点结束，故查询性能不稳定；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动平衡树的高度和数据页。</li>
</ol>
<p>  B-树的查询方式如下：从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子节点。</p>
<h3 data-id="heading-3">B+树（B+ Tree）</h3>
<p>  B+树是在B树的基础上又一次改进的多路平衡搜索树，其主要在两个方面进行了提升，一方面是查询的稳定性，让查询速度更加稳定，其速度完全接近于二分查找；另外一方面是在数据排序方面更友好，更充分的利用节点的空间。B+树包含两种类型的节点：内部节点（也称索引节点）和叶子节点。根节点本身即可以是内部节点，也可以是叶子节点。B+树的规则与B树基本类似，但是又在B树的基础上做了以下几点改进：</p>
<ul>
<li>父节点存有指向右子树第一个元素的索引。</li>
<li>内部节点不存储数据，只存储索引，用于路由，叶子节点存完整行数据（主键索引）或 (索引列 + 主键)（二级索引）。这是B+树与B树的最大差异。</li>
<li>内部节点的子树指针与关键字个数相同。</li>
<li>内部节点的关键字都按照从小到大的顺序排列，对于内部节点中的一个关键字，左子树中的所有关键字都小于它，右子树中的关键字都大于等于它。</li>
<li>所有叶子节点都存储指向下一个相邻叶子节点的指针，形成一个单向链表。</li>
</ul>
<p>  下图是一棵m=3的B+树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27aaed6dd99840d98bca40692deb7fd5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=WinfQPeM4GOFHcisfAwOaVZqoF4%3D" alt="image" loading="lazy"/></p>
<p>MySQL中的B+树是上述B+树的又一次进化：MySQL基于普通B+Tree，在叶子节点添加了一个指向上一个相邻叶子节点的指针，并且首尾叶子节点也是相连的，也就是构造了一个如图1所示的双链表。下文再提及B+树时，指带有双向链表的MySQL B+树。</p>
<p>  B+树相对于B树有一些自己的巨大优势，可以归结为下面几点：</p>

























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>更稳定的查询效率</td><td>数据仅存储在叶子节点，任何查找都必须走到叶子节点，路径长度相同，性能稳定。</td></tr><tr><td>更高的空间利用率</td><td>内部节点不存数据，存储的关键字更多，树更矮，读取数据时I/O次数更少。</td></tr><tr><td>强大的范围查询</td><td>叶子节点通过指向前后叶子节点的指针形成了一个有序双向链表，故可以高效地进行范围查询和反向排序，而B树需要进行复杂的中序遍历。</td></tr><tr><td>更适合磁盘预读</td><td>磁盘按数据页读写。B+树的节点通常设计为恰好一数据页大小，一次I/O能加载更多键，进一步减少I/O。</td></tr></tbody></table>
<p>  B+树的插入操作很简单，只需要记住一个技巧即可：当节点元素数量大于m-1的时候，就按中间元素分裂成左右两部分，中间元素的关键字分裂到父节点当做索引存储，但是，本身中间元素还是分裂到右子树中。</p>
<blockquote>
<p><strong>面试题</strong>：B+树为什么比B树更适合作为操作系统的文件索引和数据库索引？</p>
</blockquote>
<p>  简答如下：<br/>
<strong>B+树的磁盘读写代价更低</strong>。它的内部节点没有存储记录，因此内部节点相对B树占用的存储空间更小。如果把所有同一内部节点的关键字放在同一块磁盘中，盘块所能容纳的关键字数量也就越多，一次性读入内存中的需要查找的关键字也就越多，相对I/O读写次数降低。</p>
<p>  <strong>B+树的查询效率更加稳定</strong>。由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>  <strong>B+树支持范围查询</strong>。B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围查询，而B树不支持范围查找。</p>
<blockquote>
<p>面试题：为什么 InnoDB 选择 B+ 树作为索引结构？</p>
</blockquote>
<p>  相对于二叉树，B+ 树的层级更少，搜索效率更高。相对 Hash 索引，B+ 树支持范围查找以及排序操作。对于 B- 树，无论是叶子节点还是非叶子节点都会保存数据，这样会导致一页中存储的键值减少，指针跟着减少；要同样保存大量数据，只能增加树的高度，导致性能降低。B+ 树中间节点没有卫星数据（索引元素所指向的数据记录），只有索引。这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，B+ 树更加 “矮胖”，I/O 操作更少。因为卫星数据的不同，导致查询过程也不同；B- 树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而 B+ 树每次必须查找到叶子结点，性能稳定。</p>
<h3 data-id="heading-4">B*树（B star Tree）</h3>
<p>  B<em>树是普通B+树的变形，在普通B+树除根节点外的内部节点增加指向兄弟节点的指针，将节点的最低利用率从普通B+树的1/2提升到2/3。下图是一棵m=3的B</em>树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fed75f90c5c46acb10d8d338176e70c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=lAUbVGEnXpbRU9tng0FiLqEk5tg%3D" alt="image" loading="lazy"/></p>
<p>  在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树分裂次数变得更少。</p>
<p>  B+树的分裂：当一个节点满时，分配一个新的节点，并将原节点中1/2的数据复制到新节点，最后在父节点中增加新节点的指针；B+树的分裂只影响原节点和父节点，而不会影响兄弟节点，所以它不需要指向兄弟节点的指针。</p>
<p>  B<em>树的分裂：当一个节点满时，如果它的下一个兄弟节点未满，那么将一部分数据移到兄弟节点中，再在原节点插入关键字，最后修改父节点中兄弟节点的关键字（因为兄弟节点的关键字范围改变了）；如果兄弟也满了，则在原节点与兄弟节点之间增加新节点，并各贡献三分之一的数据到新节点，最后在父节点增加新节点的指针。所以，B</em>树分配新节点的概率比B+树要低，空间使用率更高。</p>
<h3 data-id="heading-5">树的总结</h3>
<p>1、相同思想和策略</p>
<p>  从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分查找和数据平衡策略来提升查找数据的速度。</p>
<p>2、不同的方式对树的不断优化</p>
<p>  为了保证树的节点均匀分布，所以在二叉树的基础上加上了平衡算法，就有了平衡二叉树。</p>
<p>  为了减少树的高度，所以B树一个节点下面可以添加N个子节点，然后每个节点的大小默认限制在16KB，只需要通过一次IO就能读取到节点上的所有数据，通过增加节点存储的数据减少了树的高度，而并没有让IO次数变多。</p>
<p>  B+树在B树的基础上，对查询的稳定性和排序策略进行了优化，因为B+树所有的数据都保存到叶子节点，并且所有叶子节点本身是有序排列的。</p>
<p>  B*树为了减少树在构建过程中节点的分裂或者合并次数，所以在每个非根节点的内部节点上都保存了兄弟节点的指针，在节点需要进行分裂或者合并时，优先从兄弟节点挪数据，从而减少构建过程中节点分裂或者合并的次数，提升了树的构建性能，将节点的最低利用率从1/2提高到2/3。</p>
<h3 data-id="heading-6">实际应用中的索引优化</h3>
<p>  了解 B树 和 B+树的基本原理后，在实际应用中如何合理使用索引呢？首先，要选择合适的索引列。对于经常用作查询条件和排序的列，应该建立索引。其次，要注意索引的维护。频繁更新的列会导致索引重建，因此要权衡索引的利弊。最后，要根据查询需求选择合适的索引类型。对于需要频繁进行范围查询的列，B+ 树索引是更好的选择。</p>
<p>  在实际应用中，还可以通过复合索引、覆盖索引等高级技术进一步优化查询性能。</p>
<h3 data-id="heading-7">聚集索引和辅助索引</h3>
<p>  MySQL InnoDB存储引擎数据库中的B+Tree索引可以分为聚集索引（clustered index，也叫主键索引、聚簇索引）和辅助索引（secondary index，也叫非聚集索引）。</p>
<p>  聚集索引也叫主键索引，叶子节点中的data存储的是该主键对应的整行数据，通常B+Tree的高度为3，也就是有三层节点，MySQL会把B+Tree第一层也就是根节点放在内存中，我们根据主键索引查数据，只需要两次磁盘I\O（第二层1次，第三层1次）即可。</p>
<p>非聚集索引也叫辅助索引，叶子节点中存储的是该索引所在记录的主键值，所以非聚集索引的寻址过程分两种情况：</p>
<p>(1) 非聚集索引已经索引覆盖了，那么只需要遍历这非聚集索引这一个B+Tree即可，按照上面的分析，需要两次磁盘IO即可（mysql会把根节点放到内存中）。</p>
<p>(2) 非聚集索引不能索引覆盖，那么需要回表。先需要在非聚集索引这个B+Tree上两次IO找到主键，然后拿着主键去聚集索引的B+Tree上找对应的完整数据记录。相比第一种情况IO次数要多，所以我们通常喜欢索引覆盖。这个过程会增加额外的 IO 消耗和网络传输时间，降低查询性能。</p>
<p>下图表示非聚集索引不能索引覆盖的情况：右侧的辅助索引先拿到主键值5，然后去左侧的主键索引中寻址，最后可以得到整行记录的内容。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/700732be249847d893da968764a1b1dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=XPXfhzhzM8GBVCqnQU3LpYYdG80%3D" alt="image" loading="lazy"/></p>
<h3 data-id="heading-8">面试实战指南</h3>
<p>  掌握了以上各种树的知识，你已经能应对80%的索引问题。但想在面试中真正征服面试官，还需要准备一些更具深度和广度的话题。这里再考察索引问题的时候，有经验的面试官很可能对以下三个问题深挖，你可以准确回答了吗？</p>
<ul>
<li>B+树与B树、红黑树等其它树的对比</li>
<li>MySQL索引会失效吗</li>
<li>MySQL InnoDB表中含有NULL值的列建索引有作用吗</li>
<li>MySQL InnoDB高度为3的B+Tree可以存储多少条数据</li>
</ul>
<p>答案即将揭晓，敬请关注小编。</p>
<h3 data-id="heading-9">结束语</h3>
<p>  本文介绍了二叉树、AVL树、红黑树、B树和B+树五种树的数据结构，介绍了如何一步步降低树的高度，提升增删改查效率，最后介绍了MySQL InnoDB索引及其相关高频、高阶面试题。</p>
<p>  请暂放工作喧嚣，享受汗水换来的闲暇，惬意阅读。聆听内心，感受自由，静享丰盈时光。愿这份宁静和这篇博文，滋养你前行。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Batch实战]]></title>    <link>https://juejin.cn/post/7603575763786874906</link>    <guid>https://juejin.cn/post/7603575763786874906</guid>    <pubDate>2026-02-06T23:44:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603575763786874906" data-draft-id="7603352117640134665" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Batch实战"/> <meta itemprop="keywords" content="Java,Spring"/> <meta itemprop="datePublished" content="2026-02-06T23:44:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Batch实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-06T23:44:29.000Z" title="Fri Feb 06 2026 23:44:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Spring Batch实战</h2>
<h3 data-id="heading-1">前言</h3>
<p>在企业级应用中，批量数据处理是一个非常常见的需求。比如月底的工资代发、银行对账、数据报表生成等。当数据量达到几十万甚至上百万时，如何高效、可靠地处理这些数据，就成了一个技术挑战。</p>
<p>本文将以"50万笔工资代发"为实际场景，详细介绍如何使用Spring Batch框架来处理大规模批量数据，并重点讲解当处理失败时，如何实现<strong>部分回滚机制</strong>，确保已成功处理的数据不会因为少量失败记录而全部回滚。</p>
<hr/>
<h3 data-id="heading-2">一、什么是Spring Batch？</h3>
<h4 data-id="heading-3">1.1 Spring Batch简介</h4>
<p>Spring Batch是一个轻量级的、全面的批处理框架，由Spring团队开发，旨在帮助企业开发健壮的批处理应用程序。它于2008年首次发布，经过十多年的发展，已经成为Java批处理领域的事实标准。</p>
<p>Spring Batch的核心设计理念包括：</p>
<ul>
<li><strong>Chunk-oriented Processing（块级处理）</strong>：将大量数据分批处理，避免内存溢出</li>
<li><strong>事务管理</strong>：每个Chunk作为一个独立的事务，支持部分回滚</li>
<li><strong>容错机制</strong>：支持跳过（Skip）、重试（Retry）等容错策略</li>
<li><strong>作业调度</strong>：支持定时任务、手动触发等多种调度方式</li>
<li><strong>监控与统计</strong>：提供完整的执行记录和统计信息</li>
</ul>
<h4 data-id="heading-4">1.2 核心概念详解</h4>
<h5 data-id="heading-5">Job（作业）</h5>
<p>Job是批处理的核心概念，代表一个完整的批处理任务。一个Job可以包含多个Step，按顺序或并行执行。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Job <span class="hljs-title function_">salaryPaymentJob</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> jobBuilderFactory.get(<span class="hljs-string">"salaryPaymentJob"</span>)
        .start(step1())
        .next(step2())
        .build();
}
</code></pre>
<h5 data-id="heading-6">Step（步骤）</h5>
<p>Step是Job的基本执行单元，每个Step包含：</p>
<ul>
<li><strong>ItemReader</strong>：读取数据</li>
<li><strong>ItemProcessor</strong>：处理数据（可选）</li>
<li><strong>ItemWriter</strong>：写入数据</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Step <span class="hljs-title function_">salaryPaymentStep</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> stepBuilderFactory.get(<span class="hljs-string">"salaryPaymentStep"</span>)
        .&lt;SalaryPayment, SalaryPayment&gt;chunk(<span class="hljs-number">1000</span>)
        .reader(reader())
        .processor(processor())
        .writer(writer())
        .build();
}
</code></pre>
<h5 data-id="heading-7">Chunk（数据块）</h5>
<p>Chunk是Spring Batch处理数据的基本单位。每次从Reader读取指定数量的记录，处理后一起提交到数据库：</p>
<pre><code class="hljs">读取1000条 → 处理1000条 → 写入1000条 → 提交事务
</code></pre>
<h4 data-id="heading-8">1.3 应用场景</h4>
<p>Spring Batch适用于以下典型场景：</p>






























<table><thead><tr><th>场景</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>数据迁移</td><td>跨系统数据同步</td><td>从旧系统迁移数据到新系统</td></tr><tr><td>数据转换</td><td>ETL过程</td><td>从数据库读取、转换、写入数据仓库</td></tr><tr><td>批量处理</td><td>定期批量操作</td><td>月底工资代发、银行对账</td></tr><tr><td>报表生成</td><td>定期生成报表</td><td>每日交易汇总报表</td></tr></tbody></table>
<h4 data-id="heading-9">1.4 与其他框架对比</h4>









































<table><thead><tr><th>特性</th><th>Spring Batch</th><th>Quartz</th><th>Scheduled Executor</th></tr></thead><tbody><tr><td>批量处理</td><td>✅ 专用</td><td>需要</td><td>需要</td></tr><tr><td>事务管理</td><td>✅ 内置</td><td>无</td><td>无</td></tr><tr><td>容错机制</td><td>✅ 完善的Skip/Retry</td><td>无</td><td>无</td></tr><tr><td>监控统计</td><td>✅ 数据库持久化</td><td>基础</td><td>无</td></tr><tr><td>并行处理</td><td>✅ 多种模式</td><td>无</td><td>基础</td></tr></tbody></table>
<p><strong>为什么需要部分回滚？</strong></p>
<p>想象一下：你需要处理50万笔工资代发，如果第49万笔记录因为银行卡号错误而失败，在没有部分回滚机制的情况下，前面489,999笔已成功处理的数据会全部回滚！这对于业务来说是不可接受的。</p>
<hr/>
<h3 data-id="heading-10">二、系统架构设计</h3>
<p>为了实现50万笔工资代发的高效处理，我们设计了如下的系统架构：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bcd00eb304e3405bba04e396f8f17e3a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=6U7zJ6OTXz6gkHUmSzFWbDGsk6w%3D" alt="" loading="lazy"/></p>
<p>上图展示了Spring Batch工资代发系统的分层架构：</p>
<ul>
<li><strong>Web层</strong>：提供监控面板，支持Job启动/停止、实时状态监控和统计信息查询</li>
<li><strong>Batch控制层</strong>：REST API接口，包含JobLauncher和JobRepository</li>
<li><strong>Spring Batch核心层</strong>：Job→Step→Chunk的处理流程，包含Reader、Processor、Writer三大组件</li>
<li><strong>数据存储层</strong>：MySQL数据库、CSV文件和Job执行日志</li>
</ul>
<h4 data-id="heading-11">2.1 核心组件说明</h4>



































<table><thead><tr><th>组件</th><th>职责</th><th>实现类</th></tr></thead><tbody><tr><td>Job</td><td>整个批处理任务</td><td>SalaryPaymentJob</td></tr><tr><td>Step</td><td>任务中的一个步骤</td><td>SalaryPaymentStep</td></tr><tr><td>ItemReader</td><td>数据读取器</td><td>FlatFileItemReader（读取CSV）</td></tr><tr><td>ItemProcessor</td><td>数据处理器</td><td>SalaryPaymentProcessor（数据验证）</td></tr><tr><td>ItemWriter</td><td>数据写入器</td><td>JdbcBatchItemWriter（批量写入数据库）</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-12">三、部分回滚机制原理</h3>
<h4 data-id="heading-13">3.1 Chunk-Oriented Processing</h4>
<p>Spring Batch采用**Chunk-Oriented Processing（块级处理）**模式，这是实现部分回滚的核心机制：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d084688d1ebe463c9652b1ba0d53c668~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=UuFoHlDwgOOpU%2FXE5sMRjhtTvc8%3D" alt="" loading="lazy"/></p>
<p>上图展示了Batch处理的核心流程：Reader读取数据 → Processor处理验证 → Writer批量写入，形成完整的处理管道。</p>
<p>对于50万笔数据的处理，Chunk机制的工作方式如下：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-number">50</span>万笔数据
    │
    ├─► Chunk <span class="hljs-number">1</span> (<span class="hljs-number">1</span>-<span class="hljs-number">1000</span>笔)   ──► 独立事务 ──► 成功提交
    ├─► Chunk <span class="hljs-number">2</span> (<span class="hljs-number">1001</span>-<span class="hljs-number">2000</span>笔) ──► 独立事务 ──► 成功提交
    ├─► Chunk <span class="hljs-number">3</span> (<span class="hljs-number">2001</span>-<span class="hljs-number">3000</span>笔) ──► 独立事务 ──► 第<span class="hljs-number">2500</span>笔失败 → 重试<span class="hljs-number">3</span>次 → 跳过 → 其余<span class="hljs-number">999</span>笔提交
    ├─► Chunk <span class="hljs-number">4</span> (<span class="hljs-number">3001</span>-<span class="hljs-number">4000</span>笔) ──► 独立事务 ──► 成功提交
    ...
    └─► Chunk <span class="hljs-number">500</span> (<span class="hljs-number">499001</span>-<span class="hljs-number">500000</span>笔) ──► 独立事务 ──► 成功提交

最终结果：<span class="hljs-number">499</span>,<span class="hljs-number">999</span>笔成功，<span class="hljs-number">1</span>笔被跳过
</code></pre>
<p><strong>关键配置：</strong></p>
<ul>
<li><strong>chunkSize</strong>: 1000（每1000笔提交一次）</li>
<li><strong>skipLimit</strong>: 100（最多跳过100笔失败记录）</li>
<li><strong>retryLimit</strong>: 3（每笔失败重试3次）</li>
</ul>
<h4 data-id="heading-14">3.2 事务边界与部分回滚</h4>
<p>每个Chunk是独立的事务单元，这是实现部分回滚的关键：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3cadc7def044954ab96efb3b4f174c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=tDesgDqGrq9SQu7Kbxsq%2FXq2ljQ%3D" alt="" loading="lazy"/></p>
<p>上图清晰地展示了事务边界和部分回滚的工作机制：</p>
<p><strong>事务规则：</strong></p>
<ul>
<li>Chunk内任意记录失败 → 整个Chunk回滚</li>
<li>重试成功 → 继续处理</li>
<li>重试失败且可跳过 → 跳过该记录，继续处理Chunk内剩余记录</li>
<li>跳过次数超限 → 整个Job失败</li>
</ul>
<p><strong>实际案例：</strong>
假设Chunk 3中有1000笔数据，第500笔验证失败：</p>
<ol>
<li>Spring Batch回滚整个Chunk 3</li>
<li>重新读取Chunk 3的1000笔数据</li>
<li>处理到第500笔时，捕获异常</li>
<li>重试3次后仍然失败</li>
<li>检查是否可跳过（IllegalArgumentException在跳过列表中）</li>
<li>跳过第500笔，继续处理501-1000笔</li>
<li>最终Chunk 3成功提交999笔，1笔被跳过</li>
</ol>
<h4 data-id="heading-15">3.3 容错策略配置</h4>
<pre><code class="hljs language-java" lang="java">.faultTolerant()                    <span class="hljs-comment">// 启用容错</span>
    .skipLimit(<span class="hljs-number">100</span>)                 <span class="hljs-comment">// 最多跳过100条</span>
    .skip(IllegalArgumentException.class)    <span class="hljs-comment">// 跳过数据验证异常</span>
    .skip(NullPointerException.class)        <span class="hljs-comment">// 跳过空指针异常</span>
    .retryLimit(<span class="hljs-number">3</span>)                  <span class="hljs-comment">// 失败重试3次</span>
    .retry(Exception.class)         <span class="hljs-comment">// 重试所有异常</span>
</code></pre>
<hr/>
<h3 data-id="heading-16">四、50万笔工资代发数据处理流程</h3>
<p>在理解了部分回滚机制后，我们来看完整的工资代发数据处理流程：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8b9318892e8425abf7d289b608db5bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=SIsXxsWk3rb%2BjcCk4aE465G5rXg%3D" alt="" loading="lazy"/></p>
<p>上图展示了从CSV文件读取到数据库写入的完整数据流，包含以下关键步骤：</p>
<ol>
<li><strong>数据读取</strong>：FlatFileItemReader读取CSV文件，每行映射为SalaryPayment对象</li>
<li><strong>数据验证</strong>：SalaryPaymentProcessor进行数据校验
<ul>
<li>员工ID非空验证</li>
<li>金额范围验证（0.01-100万）</li>
<li>银行卡号格式验证（16-19位数字）</li>
</ul>
</li>
<li><strong>状态更新</strong>：设置状态为PROCESSING，生成唯一交易ID</li>
<li><strong>批量写入</strong>：JdbcBatchItemWriter批量写入数据库</li>
<li><strong>异常处理</strong>：验证失败的记录被跳过，记录到失败列表</li>
</ol>
<hr/>
<h3 data-id="heading-17">五、核心代码实现</h3>
<h4 data-id="heading-18">5.1 Job配置</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryPaymentJobConfig</span> {

    <span class="hljs-meta">@Value("${batch.chunk.size:1000}")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> chunkSize;  <span class="hljs-comment">// 每次处理的记录数</span>

    <span class="hljs-meta">@Value("${batch.skip.limit:100}")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> skipLimit;  <span class="hljs-comment">// 跳过限制</span>

    <span class="hljs-meta">@Value("${batch.retry.limit:3}")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> retryLimit; <span class="hljs-comment">// 重试次数</span>

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Step <span class="hljs-title function_">salaryPaymentStep</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> stepBuilderFactory
            .get(<span class="hljs-string">"salaryPaymentStep"</span>)
            .&lt;SalaryPayment, SalaryPayment&gt;chunk(chunkSize)
            .reader(salaryPaymentReader())
            .processor(salaryPaymentProcessor())
            .writer(salaryPaymentWriter())
            .faultTolerant()  <span class="hljs-comment">// 启用容错</span>
            .skipLimit(skipLimit)
            .skip(IllegalArgumentException.class)
            .skip(NullPointerException.class)
            .retryLimit(retryLimit)
            .retry(Exception.class)
            .listener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SalaryItemReadListener</span>())
            .listener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SalaryItemWriteListener</span>())
            .build();
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Job <span class="hljs-title function_">salaryPaymentJob</span><span class="hljs-params">(Step step, SalaryJobExecutionListener listener)</span> {
        <span class="hljs-keyword">return</span> jobBuilderFactory.get(<span class="hljs-string">"salaryPaymentJob"</span>)
            .incrementer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunIdIncrementer</span>())
            .listener(listener)
            .start(step)
            .build();
    }
}
</code></pre>
<h4 data-id="heading-19">5.2 数据读取器</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> FlatFileItemReader&lt;SalaryPayment&gt; <span class="hljs-title function_">salaryPaymentReader</span><span class="hljs-params">()</span> {
    FlatFileItemReader&lt;SalaryPayment&gt; reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlatFileItemReader</span>&lt;&gt;();
    reader.setName(<span class="hljs-string">"salaryPaymentReader"</span>);
    reader.setResource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">"input/salary-payments.csv"</span>));
    reader.setLinesToSkip(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 跳过CSV标题行</span>

    <span class="hljs-comment">// 设置列映射</span>
    <span class="hljs-type">DelimitedLineTokenizer</span> <span class="hljs-variable">tokenizer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelimitedLineTokenizer</span>();
    tokenizer.setNames(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{
        <span class="hljs-string">"employeeId"</span>, <span class="hljs-string">"employeeName"</span>, <span class="hljs-string">"accountNumber"</span>,
        <span class="hljs-string">"accountName"</span>, <span class="hljs-string">"bankName"</span>, <span class="hljs-string">"amount"</span>, <span class="hljs-string">"currency"</span>,
        <span class="hljs-string">"paymentDate"</span>, <span class="hljs-string">"remark"</span>
    });

    <span class="hljs-comment">// 设置字段映射</span>
    BeanWrapperFieldSetMapper&lt;SalaryPayment&gt; mapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanWrapperFieldSetMapper</span>&lt;&gt;();
    mapper.setTargetType(SalaryPayment.class);

    DefaultLineMapper&lt;SalaryPayment&gt; lineMapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultLineMapper</span>&lt;&gt;();
    lineMapper.setLineTokenizer(tokenizer);
    lineMapper.setFieldSetMapper(mapper);
    reader.setLineMapper(lineMapper);

    <span class="hljs-keyword">return</span> reader;
}
</code></pre>
<h4 data-id="heading-20">5.3 数据处理器（验证逻辑）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryPaymentProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ItemProcessor</span>&lt;SalaryPayment, SalaryPayment&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">MIN_AMOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"0.01"</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">MAX_AMOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1000000"</span>);

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> SalaryPayment <span class="hljs-title function_">process</span><span class="hljs-params">(SalaryPayment item)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 1. 数据验证</span>
        <span class="hljs-keyword">if</span> (item.getEmployeeId() == <span class="hljs-literal">null</span> || item.getEmployeeId().trim().isEmpty()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"员工ID不能为空"</span>);
        }

        <span class="hljs-comment">// 2. 金额验证</span>
        <span class="hljs-keyword">if</span> (item.getAmount() == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"发放金额不能为空"</span>);
        }
        <span class="hljs-keyword">if</span> (item.getAmount().compareTo(MIN_AMOUNT) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"发放金额不能小于0.01元"</span>);
        }
        <span class="hljs-keyword">if</span> (item.getAmount().compareTo(MAX_AMOUNT) &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"发放金额不能大于100万元"</span>);
        }

        <span class="hljs-comment">// 3. 银行卡号验证</span>
        <span class="hljs-keyword">if</span> (item.getAccountNumber() == <span class="hljs-literal">null</span> ||
            item.getAccountNumber().length() &lt; <span class="hljs-number">16</span> ||
            item.getAccountNumber().length() &gt; <span class="hljs-number">19</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"银行账号长度必须在16-19位之间"</span>);
        }

        <span class="hljs-comment">// 4. 设置处理状态</span>
        item.setStatus(<span class="hljs-string">"PROCESSING"</span>);
        item.setTransactionId(<span class="hljs-string">"SAL"</span> + System.currentTimeMillis() + item.getEmployeeId());

        <span class="hljs-keyword">return</span> item;
    }
}
</code></pre>
<h4 data-id="heading-21">5.4 数据写入器</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryPaymentWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ItemWriter</span>&lt;SalaryPayment&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JdbcBatchItemWriter&lt;SalaryPayment&gt; delegate;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SalaryPaymentWriter</span><span class="hljs-params">(DataSource dataSource)</span> {
        <span class="hljs-built_in">this</span>.delegate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcBatchItemWriter</span>&lt;&gt;();
        <span class="hljs-built_in">this</span>.delegate.setDataSource(dataSource);
        <span class="hljs-built_in">this</span>.delegate.setSql(
            <span class="hljs-string">"INSERT INTO salary_payment "</span> +
            <span class="hljs-string">"(employee_id, employee_name, account_number, account_name, "</span> +
            <span class="hljs-string">"bank_name, amount, currency, payment_date, remark, "</span> +
            <span class="hljs-string">"status, transaction_id, create_time, update_time) "</span> +
            <span class="hljs-string">"VALUES (:employeeId, :employeeName, :accountNumber, :accountName, "</span> +
            <span class="hljs-string">":bankName, :amount, :currency, :paymentDate, :remark, "</span> +
            <span class="hljs-string">":status, :transactionId, :createTime, :updateTime)"</span>);
        <span class="hljs-built_in">this</span>.delegate.setItemSqlParameterSourceProvider(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyItemSqlParameterSourceProvider</span>&lt;&gt;()
        );
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;? extends SalaryPayment&gt; items)</span> <span class="hljs-keyword">throws</span> Exception {
        delegate.write(items);
    }
}
</code></pre>
<h4 data-id="heading-22">5.5 自定义SkipPolicy</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PartialRollbackHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SkipPolicy</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SKIP_LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSkip</span><span class="hljs-params">(Throwable throwable, <span class="hljs-type">int</span> skipCount)</span> {
        <span class="hljs-comment">// 超过跳过限制</span>
        <span class="hljs-keyword">if</span> (skipCount &gt;= SKIP_LIMIT) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// 文件不存在，不能跳过</span>
        <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> FileNotFoundException) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// 数据格式错误，可以跳过</span>
        <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> FlatFileParseException) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-comment">// 数据验证失败，可以跳过</span>
        <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> IllegalArgumentException ||
            throwable <span class="hljs-keyword">instanceof</span> NullPointerException) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-23">六、监控与调度架构</h3>
<p>除了数据处理，Spring Batch还提供了完善的监控和调度能力：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75d4b1910c2744e1ae48875ce1ce6e31~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=6ByRneA25pJ%2BsYmXWs9B49dsOdQ%3D" alt="" loading="lazy"/></p>
<p>上图展示了完整的监控与调度架构：</p>
<p><strong>调度层</strong>：支持三种调度方式</p>
<ul>
<li>Quartz调度器：支持分布式调度，适合集群环境</li>
<li>Spring Task调度：简单的定时任务，轻量级选择</li>
<li>Cron表达式：灵活的时间配置</li>
</ul>
<p><strong>执行层</strong>：核心执行组件</p>
<ul>
<li>JobLauncher：启动作业，创建执行上下文</li>
<li>JobOperator：操作作业，支持停止/重启/重试</li>
<li>StepExecution：步骤执行，采用Chunk处理模式</li>
<li>ThreadPoolExecutor：线程池，实现并发处理</li>
</ul>
<p><strong>监控层</strong>：监控与统计</p>
<ul>
<li>JobRepository：存储元数据（BATCH_JOB_INSTANCE、BATCH_JOB_EXECUTION、BATCH_STEP_EXECUTION）</li>
<li>JobExplorer：查询作业状态、获取执行历史</li>
<li>Metrics：处理记录数、执行时间、失败率统计</li>
</ul>
<p><strong>数据层</strong>：数据存储</p>
<ul>
<li>MySQL 8.0：存储元数据表、业务数据表、日志记录</li>
<li>Redis缓存：执行状态缓存、计数器、分布式锁</li>
</ul>
<hr/>
<h3 data-id="heading-24">七、数据库设计</h3>
<h4 data-id="heading-25">7.1 工资代发表</h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> salary_payment (
    id <span class="hljs-type">BIGINT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,
    employee_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'员工ID'</span>,
    employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'员工姓名'</span>,
    account_number <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'银行账号'</span>,
    account_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'账户名称'</span>,
    bank_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'开户行'</span>,
    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'发放金额'</span>,
    currency <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'CNY'</span> COMMENT <span class="hljs-string">'币种'</span>,
    payment_date DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'发放日期'</span>,
    remark <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">500</span>) COMMENT <span class="hljs-string">'备注'</span>,
    status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'PENDING'</span> COMMENT <span class="hljs-string">'状态'</span>,
    transaction_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">'交易ID'</span>,
    error_message <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">1000</span>) COMMENT <span class="hljs-string">'错误信息'</span>,
    create_time DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
    update_time DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
    INDEX idx_employee_id (employee_id),
    INDEX idx_status (status)
) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;
</code></pre>
<h4 data-id="heading-26">7.2 Spring Batch元表</h4>
<p>Spring Batch框架会自动创建以下元表来存储Job执行信息：</p>
<ul>
<li><code>batch_job_instance</code> - Job实例表</li>
<li><code>batch_job_execution</code> - Job执行表</li>
<li><code>batch_job_execution_params</code> - Job参数表</li>
<li><code>batch_step_execution</code> - Step执行表</li>
<li><code>batch_step_execution_context</code> - Step上下文表</li>
</ul>
<hr/>
<h3 data-id="heading-27">八、REST API设计</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/api/batch")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchJobController</span> {

    <span class="hljs-comment">// 启动Job</span>
    <span class="hljs-meta">@PostMapping("/start")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">startJob</span><span class="hljs-params">(
        <span class="hljs-meta">@RequestParam</span> String inputFile
    )</span> {
        <span class="hljs-type">JobParameters</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JobParametersBuilder</span>()
            .addLong(<span class="hljs-string">"startTime"</span>, System.currentTimeMillis())
            .addString(<span class="hljs-string">"inputFile"</span>, inputFile)
            .toJobParameters();
        <span class="hljs-type">JobExecution</span> <span class="hljs-variable">execution</span> <span class="hljs-operator">=</span> jobLauncher.run(salaryPaymentJob, params);
        <span class="hljs-keyword">return</span> ResponseEntity.ok(result);
    }

    <span class="hljs-comment">// 获取Job状态</span>
    <span class="hljs-meta">@GetMapping("/status/{jobExecutionId}")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getJobStatus</span><span class="hljs-params">(
        <span class="hljs-meta">@PathVariable</span> Long jobExecutionId
    )</span> {
        <span class="hljs-type">JobExecution</span> <span class="hljs-variable">execution</span> <span class="hljs-operator">=</span> jobRepository.getJobExecution(jobExecutionId);
        <span class="hljs-comment">// 返回执行详情</span>
    }

    <span class="hljs-comment">// 停止Job</span>
    <span class="hljs-meta">@PostMapping("/stop/{jobExecutionId}")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">stopJob</span><span class="hljs-params">(
        <span class="hljs-meta">@PathVariable</span> Long jobExecutionId
    )</span> {
        <span class="hljs-type">JobExecution</span> <span class="hljs-variable">execution</span> <span class="hljs-operator">=</span> jobRepository.getJobExecution(jobExecutionId);
        execution.stop();
        <span class="hljs-keyword">return</span> ResponseEntity.ok(result);
    }

    <span class="hljs-comment">// 获取统计信息</span>
    <span class="hljs-meta">@GetMapping("/statistics")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getStatistics</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 返回总数、成功数、失败数等统计</span>
    }

    <span class="hljs-comment">// 健康检查</span>
    <span class="hljs-meta">@GetMapping("/health")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">health</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 返回系统健康状态</span>
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-28">九、性能优化与并行处理</h3>
<p>当数据量达到50万甚至更多时，单线程处理可能成为瓶颈。Spring Batch提供了多种并行处理方式。</p>
<h4 data-id="heading-29">9.1 多线程并发处理</h4>
<p>Spring Batch支持多线程并发处理，大幅提升处理效率：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/316e23bab05d4fe596fe18021513b6c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=0BkUFvIWBtjJgwbQoXjOKq2s7MQ%3D" alt="" loading="lazy"/></p>
<p>上图展示了多线程并发处理的工作原理：</p>
<p><strong>核心机制：</strong></p>
<ul>
<li><strong>主线程</strong>：创建线程池，分配任务</li>
<li><strong>工作线程</strong>：并发执行多个Step或Chunk</li>
<li><strong>线程安全</strong>：JobRepository保证线程安全的状态管理</li>
<li><strong>负载均衡</strong>：任务均匀分配到各个线程</li>
</ul>
<p><strong>配置示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">taskExecutor</span><span class="hljs-params">()</span> {
    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();
    executor.setCorePoolSize(<span class="hljs-number">5</span>);
    executor.setMaxPoolSize(<span class="hljs-number">10</span>);
    executor.setQueueCapacity(<span class="hljs-number">100</span>);
    executor.setThreadNamePrefix(<span class="hljs-string">"salary-batch-"</span>);
    executor.initialize();
    <span class="hljs-keyword">return</span> executor;
}

<span class="hljs-comment">// 在Step中使用</span>
.step(stepName)
.chunk(chunkSize)
.taskExecutor(taskExecutor())
.throttleLimit(<span class="hljs-number">10</span>)  <span class="hljs-comment">// 限制并发数</span>
.build();
</code></pre>
<h4 data-id="heading-30">9.2 分区处理（Partitioning）</h4>
<p>对于超大数据集，可以使用分区处理实现更高程度的并行：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f2a8815f01144f197a00ba5ad2c0802~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=9I%2BjxPUBFL%2B5Vi3qT9oI4Xub9sM%3D" alt="" loading="lazy"/></p>
<p>上图展示了分区处理的架构：</p>
<p><strong>核心组件：</strong></p>
<ul>
<li><strong>Master Step</strong>：负责创建和管理分区</li>
<li><strong>Slave Step</strong>：每个分区独立执行</li>
<li><strong>Partitioner</strong>：将数据分成多个分区</li>
<li><strong>TaskExecutor</strong>：线程池执行分区任务</li>
</ul>
<p><strong>配置示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Step <span class="hljs-title function_">masterStep</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> stepBuilderFactory.get(<span class="hljs-string">"masterStep"</span>)
        .partitioner(slaveStep().getName(), rangePartitioner(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))
        .step(slaveStep())
        .gridSize(<span class="hljs-number">10</span>)  <span class="hljs-comment">// 分成10个分区</span>
        .taskExecutor(taskExecutor())
        .build();
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Partitioner <span class="hljs-title function_">rangePartitioner</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Partitioner</span>() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Map&lt;String, ExecutionContext&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> gridSize)</span> {
            Map&lt;String, ExecutionContext&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
            <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> (max - min) / gridSize;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gridSize; i++) {
                <span class="hljs-type">ExecutionContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>();
                context.putInt(<span class="hljs-string">"minValue"</span>, min + i * range);
                context.putInt(<span class="hljs-string">"maxValue"</span>, min + (i + <span class="hljs-number">1</span>) * range - <span class="hljs-number">1</span>);
                result.put(<span class="hljs-string">"partition"</span> + i, context);
            }
            <span class="hljs-keyword">return</span> result;
        }
    };
}
</code></pre>
<h4 data-id="heading-31">9.3 调优参数</h4>






























<table><thead><tr><th>参数</th><th>推荐值</th><th>说明</th></tr></thead><tbody><tr><td>chunkSize</td><td>1000-5000</td><td>根据记录大小调整，越大吞吐量越高但内存占用也越大</td></tr><tr><td>skipLimit</td><td>100-500</td><td>根据数据质量设置</td></tr><tr><td>retryLimit</td><td>3-5</td><td>过多会浪费时间，过少可能误判暂时性故障</td></tr><tr><td>线程池大小</td><td>CPU核心数*2</td><td>用于多线程处理</td></tr></tbody></table>
<h4 data-id="heading-32">9.4 批量写入优化</h4>
<p>使用JDBC批量操作代替单条插入：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 单条插入（慢）</span>
<span class="hljs-keyword">for</span> (SalaryPayment p : payments) {
    jdbcTemplate.update(sql, p.getId(), p.getName(), ...);
}

<span class="hljs-comment">// 批量插入（快）</span>
jdbcTemplate.batchUpdate(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchPreparedStatementSetter</span>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValues</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// 设置参数</span>
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBatchSize</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> payments.size();
    }
});
</code></pre>
<h4 data-id="heading-33">9.5 索引优化</h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 为常用查询字段添加索引</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_employee_id <span class="hljs-keyword">ON</span> salary_payment(employee_id);
<span class="hljs-keyword">CREATE</span> INDEX idx_status <span class="hljs-keyword">ON</span> salary_payment(status);
<span class="hljs-keyword">CREATE</span> INDEX idx_create_time <span class="hljs-keyword">ON</span> salary_payment(create_time);

<span class="hljs-comment">-- 复合索引</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_status_employee <span class="hljs-keyword">ON</span> salary_payment(status, employee_id);
</code></pre>
<hr/>
<h3 data-id="heading-34">十、实际应用场景</h3>
<h4 data-id="heading-35">场景1：月底工资代发</h4>
<p>某公司月底需要为50,000名员工发放工资，使用Spring Batch：</p>
<ul>
<li>设置chunkSize=1000，分成50个Chunk处理</li>
<li>假设第23个Chunk中第23,456号员工银行卡号错误</li>
<li>系统重试3次后跳过该记录</li>
<li>最终结果：49,999笔成功，1笔记录到失败列表供后续处理</li>
</ul>
<h4 data-id="heading-36">场景2：银行对账文件处理</h4>
<p>银行提供100万笔交易对账文件：</p>
<ul>
<li>设置chunkSize=5000，提高处理效率</li>
<li>使用多线程并发处理（Partitioning）</li>
<li>完成后生成对账差异报告</li>
</ul>
<h4 data-id="heading-37">场景3：数据报表生成</h4>
<p>每天凌晨生成T+1交易报表：</p>
<ul>
<li>使用Spring Task定时调度</li>
<li>读取当日交易数据</li>
<li>生成Excel报表并发送邮件</li>
</ul>
<hr/>
<h3 data-id="heading-38">十一、常见问题与解决方案</h3>
<h4 data-id="heading-39">Q1: Job执行一半挂了怎么办？</h4>
<p>Spring Batch支持Job重启。通过JobRepository记录的执行状态，可以从上次失败的位置继续执行：</p>
<pre><code class="hljs language-java" lang="java">.job(salaryPaymentJob)
    .allowStartIfComplete(<span class="hljs-literal">false</span>)  <span class="hljs-comment">// 已完成的Job不重新执行</span>
    .restartable(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// 允许重启</span>
</code></pre>
<h4 data-id="heading-40">Q2: 如何实现并行处理？</h4>
<p>使用Partitioning方式实现多线程并行处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Step <span class="hljs-title function_">masterStep</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> stepBuilderFactory.get(<span class="hljs-string">"masterStep"</span>)
        .partitioner(slaveStep().getName(), partitioner())
        .step(slaveStep())
        .gridSize(<span class="hljs-number">10</span>)  <span class="hljs-comment">// 分成10个分区并行处理</span>
        .taskExecutor(taskExecutor())
        .build();
}
</code></pre>
<h4 data-id="heading-41">Q3: 处理失败的数据如何重试？</h4>
<p>可以通过以下方式重试：</p>
<ol>
<li>查询status='FAILED'的记录</li>
<li>修正错误数据</li>
<li>将status改回'PENDING'</li>
<li>重新执行Job</li>
</ol>
<hr/>
<h3 data-id="heading-42">十二、总结</h3>
<p>Spring Batch作为成熟的批处理框架，提供了完整的解决方案来处理大规模批量数据。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>银行对账、清算</li>
<li>工资代发、批量转账</li>
<li>报表生成、数据导出</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>合理设置chunkSize，平衡内存和性能</li>
<li>配置合适的Skip和Retry策略</li>
<li>做好失败记录的重处理机制</li>
<li>定期清理Job执行历史数据</li>
</ul>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[虚拟列表：从定高到动态高度的 Vue 3 & React 满分实现]]></title>    <link>https://juejin.cn/post/7603591775392251931</link>    <guid>https://juejin.cn/post/7603591775392251931</guid>    <pubDate>2026-02-07T03:49:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603591775392251931" data-draft-id="7603359026711969802" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="虚拟列表：从定高到动态高度的 Vue 3 &amp; React 满分实现"/> <meta itemprop="keywords" content="前端,Vue.js,React.js"/> <meta itemprop="datePublished" content="2026-02-07T03:49:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            虚拟列表：从定高到动态高度的 Vue 3 &amp; React 满分实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T03:49:36.000Z" title="Sat Feb 07 2026 03:49:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在处理海量数据渲染（如万级甚至十万级列表）时，直接操作 DOM 会导致严重的页面卡顿甚至崩溃。<strong>虚拟列表（Virtual List）</strong> 作为前端性能优化的“核武器”，通过“只渲染可视区”的策略，能将渲染性能提升数个量级。本文将带你从零实现一个支持<strong>动态高度</strong>的通用虚拟列表。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0aeb589869424d08be07ff8183e5af9e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=83d1HWo%2Fzcfl0pbpVr8sTUG%2Bd4g%3D" alt="定高虚拟列表滚动.gif" loading="lazy"/></p>
<h2 data-id="heading-1">一、 核心原理解析</h2>
<p>虚拟列表本质上是一个“障眼法”，其结构通常分为三层：</p>
<ol>
<li><strong>外层容器（Container）</strong> ：固定高度，设置 <code>overflow: auto</code>，负责监听滚动事件。</li>
<li><strong>占位背景（Placeholder）</strong> ：高度等于“总数据量 × 列表项高度”，用于撑开滚动条，模拟真实滚动的视觉效果。</li>
<li><strong>渲染内容区（Content Area）</strong> ：绝对定位，根据滚动距离动态计算起始索引，并通过 <code>translateY</code> 偏移到当前可视区域。</li>
</ol>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35758c5b480e4fd4ae543f60afd26730~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=gm9VzHaAFCGyUyiSagfZbbWktEk%3D" alt="image.png" width="60%" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-2">二、 定高虚拟列表</h2>
<h3 data-id="heading-3">1. 设计思路</h3>
<ul>
<li><strong>可视项数计算</strong>：<code>Math.ceil(容器高度 / 固定高度) ± 缓冲区 (BUFFER)</code>。</li>
<li><strong>起始索引</strong>：<code>Math.floor(滚动距离 / 固定高度)</code>。</li>
<li><strong>偏移量</strong>：<code>起始索引 * 固定高度</code>。</li>
</ul>
<h3 data-id="heading-4">2. Vue 3 + TailwindCSS实现</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div
    class="min-h-screen bg-gradient-to-br from-indigo-600 to-purple-600 py-10 px-5"
  &gt;
    &lt;div class="bg-white mt-20 h-[calc(100vh-200px)] rounded-xl"&gt;
      &lt;!-- 滚动容器 --&gt;
      &lt;div
        ref="virtualListRef"
        class="h-full overflow-auto relative"
        @scroll="handleScroll"
      &gt;
        &lt;!-- 占位容器：用于撑开滚动条，高度 = 总数据量 * 每项高度 --&gt;
        &lt;div :style="{ height: `${totalHeight}px` }"&gt;&lt;/div&gt;

        &lt;!-- 可视区域列表：通过 transform 定位到滚动位置 --&gt;
        &lt;div
          class="absolute top-0 left-0 right-0"
          :style="{ transform: `translateY(${offsetY}px)` }"
        &gt;
          &lt;div
            v-for="item in visibleList"
            :key="item.id"
            class="py-2 px-4 border-b border-gray-200"
            :class="{
              'bg-pink-200 h-[100px]': item.id % 2 !== 0,
              'bg-green-200 h-[100px]': item.id % 2 === 0,
            }"
          &gt;
            {{ item.name }}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div
      class="fixed top-2 left-24 -translate-x-1/2 px-8 py-3 bg-white text-indigo-600 rounded-full text-base font-semibold cursor-pointer shadow-lg transition-all duration-300 hover:-translate-x-1/2 hover:-translate-y-0.5 hover:shadow-2xl"
      @click="goBack"
    &gt;
      ← 返回首页
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';

const router = useRouter();

const ITEM_HEIGHT = 100; // 列表项固定高度（与样式中的 h-[100px] 一致）
const BUFFER = 5; // 缓冲区数量，避免滚动时出现空白

const virtualListRef = ref&lt;HTMLDivElement | null&gt;(null);

const ListData = ref&lt;any[]&gt;([]); // 完整列表数据
const scrollTop = ref(0); // 滚动容器的滚动距离

// 总列表高度（撑开滚动条用）
const totalHeight = computed(() =&gt; ListData.value.length * ITEM_HEIGHT);

// 可视区域高度（滚动容器的高度）
const viewportHeight = computed(() =&gt; {
  return virtualListRef.value?.clientHeight || 0;
});

// 可视区域可显示的列表项数量（向上取整 + 缓冲区）
const visibleCount = computed(() =&gt; {
  return Math.ceil(viewportHeight.value / ITEM_HEIGHT) + BUFFER;
});

// 当前显示的起始索引
const startIndex = computed(() =&gt; {
  // 滚动距离 / 每项高度 = 跳过的项数（向下取整）
  const index = Math.floor(scrollTop.value / ITEM_HEIGHT);
  // 防止索引为负数
  return Math.max(0, index);
});

// 当前显示的结束索引
const endIndex = computed(() =&gt; {
  const end = startIndex.value + visibleCount.value;
  // 防止超出总数据长度
  return Math.min(end, ListData.value.length);
});

// 可视区域需要渲染的列表数据
const visibleList = computed(() =&gt; {
  return ListData.value.slice(startIndex.value, endIndex.value);
});

// 可视区域的偏移量（让列表项定位到正确位置）
const offsetY = computed(() =&gt; {
  return startIndex.value * ITEM_HEIGHT;
});

// 处理滚动事件
const handleScroll = () =&gt; {
  if (virtualListRef.value) {
    scrollTop.value = virtualListRef.value.scrollTop;
  }
};

// 返回首页
const goBack = () =&gt; {
  router.push('/home');
};

// 初始化
onMounted(() =&gt; {
  // 生成模拟数据
  ListData.value = Array.from({ length: 1000 }, (_, index) =&gt; ({
    id: index,
    name: `Item ${index}`,
  }));
});
&lt;/script&gt;

</code></pre>
<h3 data-id="heading-5">3. 实现效果图</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0aeb589869424d08be07ff8183e5af9e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=83d1HWo%2Fzcfl0pbpVr8sTUG%2Bd4g%3D" alt="定高虚拟列表滚动.gif" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">三、 进阶：不定高（动态高度）虚拟列表</h2>
<p>在实际业务（如社交动态、聊天记录）中，每个 Item 的高度往往是不固定的。</p>
<h3 data-id="heading-7">1. 核心改进思路</h3>
<ul>
<li><strong>高度映射表（Map）</strong> ：记录每一个 Item 渲染后的真实高度。</li>
<li><strong>累计高度数组（Cumulative Heights）</strong> ：存储每一项相对于顶部的偏移位置。</li>
<li><strong>ResizeObserver</strong>：利用该 API 监听子组件高度变化，实时更新映射表，解决图片加载或文本折行导致的位移。</li>
</ul>
<h3 data-id="heading-8">2. Vue 3 + tailwindCSS 实现（子组件抽离）</h3>
<p><strong>子组件</strong>： 负责上报真实高度：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div
    ref="itemRef"
    class="py-2 px-4 border-b border-gray-200"
    :class="{
      'bg-pink-200': item.id % 2 !== 0,
      'bg-green-200': item.id % 2 === 0,
    }"
    :style="{ height: item.id % 2 === 0 ? '150px' : '100px' }"
  &gt;
    {{ item.name }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted, onUpdated, onUnmounted, watch, nextTick } from 'vue';

// 定义props：接收父组件传递的item数据
const props = defineProps&lt;{
  item: {
    id: number;
    name: string;
  };
}&gt;();

// 定义emit：向父组件传递高度更新事件
const emit = defineEmits&lt;{
  (e: 'update-height', id: number, height: number): void;
}&gt;();

const itemRef = ref&lt;HTMLDivElement | null&gt;(null);
let resizeObserver: ResizeObserver | null = null;

// 计算并发送当前组件的高度
const sendItemHeight = () =&gt; {
  if (!itemRef.value) return;
  const realHeight = itemRef.value.offsetHeight;
  emit('update-height', props.item.id, realHeight);
};

// 监听组件挂载：首次发送高度 + 监听高度变化
onMounted(() =&gt; {
  // 首次渲染完成后发送高度
  nextTick(() =&gt; {
    sendItemHeight();
  });

  // 监听元素高度变化（适配动态内容导致的高度变化）
  if (window.ResizeObserver) {
    resizeObserver = new ResizeObserver(() =&gt; {
      sendItemHeight();
    });
    if (itemRef.value) {
      resizeObserver.observe(itemRef.value);
    }
  }
});

// 组件更新后重新发送高度（比如内容变化）
onUpdated(() =&gt; {
  nextTick(() =&gt; {
    sendItemHeight();
  });
});

// 组件卸载：清理监听
onUnmounted(() =&gt; {
  if (resizeObserver) {
    resizeObserver.disconnect();
    resizeObserver = null;
  }
});

// 监听item变化：如果item替换，重新计算高度
watch(
  () =&gt; props.item.id,
  () =&gt; {
    nextTick(() =&gt; {
      sendItemHeight();
    });
  }
);
&lt;/script&gt;

</code></pre>
<p><strong>父组件</strong>：核心逻辑</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div
    class="min-h-screen bg-gradient-to-br from-indigo-600 to-purple-600 py-10 px-5"
  &gt;
    &lt;div class="bg-white mt-20 h-[calc(100vh-200px)] rounded-xl"&gt;
      &lt;!-- 滚动容器 --&gt;
      &lt;div
        ref="virtualListRef"
        class="h-full overflow-auto relative"
        @scroll="handleScroll"
      &gt;
        &lt;!-- 占位容器：撑开滚动条 --&gt;
        &lt;div :style="{ height: `${totalHeight}px` }"&gt;&lt;/div&gt;

        &lt;!-- 可视区域列表 --&gt;
        &lt;div
          class="absolute top-0 left-0 right-0"
          :style="{ transform: `translateY(${offsetY}px)` }"
        &gt;
          &lt;!-- 渲染子组件，监听高度更新事件 --&gt;
          &lt;VirtualListItem
            v-for="item in visibleList"
            :key="item.id"
            :item="item"
            @update-height="handleItemHeightUpdate"
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div
      class="fixed top-2 left-24 -translate-x-1/2 px-8 py-3 bg-white text-indigo-600 rounded-full text-base font-semibold cursor-pointer shadow-lg transition-all duration-300 hover:-translate-x-1/2 hover:-translate-y-0.5 hover:shadow-2xl"
      @click="goBack"
    &gt;
      ← 返回首页
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted, computed, onUnmounted, nextTick } from 'vue';
import { useRouter } from 'vue-router';
import VirtualListItem from './listItem.vue'; // 引入子组件

const router = useRouter();

const MIN_ITEM_HEIGHT = 100; // 子项预设的最小高度
const BUFFER = 5; //上下缓冲区数目
const virtualListRef = ref&lt;HTMLDivElement | null&gt;(null); // 滚动容器引用

const ListData = ref&lt;any[]&gt;([]); // 完整列表数据
const scrollTop = ref(0); // 滚动距离
const itemHeights = ref&lt;Map&lt;number, number&gt;&gt;(new Map()); // 子组件高度映射表
const cumulativeHeights = ref&lt;number[]&gt;([0]); // 累计高度数组
const scrollTimer = ref&lt;number | null&gt;(null); // 滚动节流定时器
const isUpdatingCumulative = ref(false); // 累计高度更新防抖

// 初始化位置数据
const initPositionData = () =&gt; {
  // 初始化高度映射表（默认最小高度）
  const heightMap = new Map&lt;number, number&gt;();
  ListData.value.forEach((item) =&gt; {
    heightMap.set(item.id, MIN_ITEM_HEIGHT);
  });
  // 初始化累计高度
  updateCumulativeHeights();
};

// 更新累计高度（核心）
const updateCumulativeHeights = () =&gt; {
  if (isUpdatingCumulative.value) return;
  isUpdatingCumulative.value = true;

  const itemCount = ListData.value.length;
  const cumulative = [0];
  let sum = 0;

  for (let i = 0; i &lt; itemCount; i++) {
    const itemId = ListData.value[i].id;
    sum += itemHeights.value.get(itemId) || MIN_ITEM_HEIGHT;
    cumulative.push(sum);
  }

  cumulativeHeights.value = cumulative;
  isUpdatingCumulative.value = false;
};

// 处理子组件的高度更新事件
const handleItemHeightUpdate = (id: number, height: number) =&gt; {
  // 高度未变化则跳过
  if (itemHeights.value.get(id) === height) return;

  // 更新高度映射表
  itemHeights.value.set(id, height);

  // 异步更新累计高度（避免同步更新导致的性能问题）
  nextTick(() =&gt; {
    updateCumulativeHeights();
  });
};

// 总高度，根据统计高度数组最后一个值计算得出
const totalHeight = computed(() =&gt; {
  return cumulativeHeights.value[cumulativeHeights.value.length - 1] || 0;
});

// 列表可视区域高度
const viewportHeight = computed(() =&gt; {
  return virtualListRef.value?.clientHeight || MIN_ITEM_HEIGHT * 5;
});

// 计算起始索引
const startIndex = computed(() =&gt; {
  const totalItemCount = ListData.value.length;
  if (totalItemCount === 0) return 0;
  if (scrollTop.value &lt;= 0) return 0;

  let baseStartIndex = 0;
  // 反向遍历找起始索引
  for (let i = cumulativeHeights.value.length - 1; i &gt;= 0; i--) {
    if (cumulativeHeights.value[i] &lt;= scrollTop.value) {
      baseStartIndex = i;
      break;
    }
  }
  const finalIndex = Math.max(0, baseStartIndex - BUFFER); // 确保不小于0
  return Math.min(finalIndex, totalItemCount - 1);
});

// 计算结束索引
const endIndex = computed(() =&gt; {
  const totalItemCount = ListData.value.length;
  const viewportHeightVal = viewportHeight.value;
  if (totalItemCount === 0) return 0;

  const targetScrollBottom = scrollTop.value + viewportHeightVal; // 目标滚动到底部位置
  let baseEndIndex = totalItemCount - 1;
  for (let i = 0; i &lt; cumulativeHeights.value.length; i++) {
    if (cumulativeHeights.value[i] &gt; targetScrollBottom) {
      baseEndIndex = i - 1;
      break;
    }
  }
  const finalEndIndex = Math.min(baseEndIndex + BUFFER, totalItemCount - 1); // 确保不大于总项数-1
  return finalEndIndex;
});

// 可见列表
const visibleList = computed(() =&gt; {
  const start = startIndex.value;
  const end = endIndex.value;
  return start &lt;= end ? ListData.value.slice(start, end + 1) : [];
});

const offsetY = computed(() =&gt; {
  return cumulativeHeights.value[startIndex.value] || 0;
});

// 滚动节流处理
const handleScroll = () =&gt; {
  if (!virtualListRef.value) return;

  if (scrollTimer.value) clearTimeout(scrollTimer.value);
  scrollTimer.value = window.setTimeout(() =&gt; {
    scrollTop.value = virtualListRef.value!.scrollTop;
  }, 20);
};

const handleResize = () =&gt; {
  if (virtualListRef.value) {
    scrollTop.value = virtualListRef.value.scrollTop;
  }
};

const goBack = () =&gt; {
  router.push('/home');
};

// 生命周期
onMounted(() =&gt; {
  // 生成模拟数据
  ListData.value = Array.from({ length: 1000 }, (_, index) =&gt; ({
    id: index,
    name: `Item ${index}`,
  }));
  initPositionData();
  window.addEventListener('resize', handleResize); // 监听窗口大小变化
});

onUnmounted(() =&gt; {
  window.removeEventListener('resize', handleResize);
  if (scrollTimer.value) clearTimeout(scrollTimer.value);
  isUpdatingCumulative.value = false;
  itemHeights.value.clear();
});
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-9">3. React + tailwindCSS 实现（子组件抽离）</h3>
<p><strong>子组件：</strong></p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useEffect, useRef, useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">VirtualListItemProps</span> {
  <span class="hljs-attr">item</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  };
  <span class="hljs-attr">onUpdateHeight</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, height: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 替代 Vue 的 emit</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">VirtualListItem</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">VirtualListItemProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">{
  item,
  onUpdateHeight,
}</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> itemRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-comment">// 存储 ResizeObserver 实例（避免重复创建）</span>
  <span class="hljs-keyword">const</span> resizeObserverRef = useRef&lt;<span class="hljs-title class_">ResizeObserver</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// 计算并上报高度</span>
  <span class="hljs-keyword">const</span> sendItemHeight = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!itemRef.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">const</span> realHeight = itemRef.<span class="hljs-property">current</span>.<span class="hljs-property">offsetHeight</span>;
    <span class="hljs-title function_">onUpdateHeight</span>(item.<span class="hljs-property">id</span>, realHeight);
  }, [item.<span class="hljs-property">id</span>, onUpdateHeight]);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">sendItemHeight</span>();
    }, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// 初始化 ResizeObserver 监听高度变化</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">ResizeObserver</span>) {
      resizeObserverRef.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">sendItemHeight</span>();
      });
      <span class="hljs-keyword">if</span> (itemRef.<span class="hljs-property">current</span>) {
        resizeObserverRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">observe</span>(itemRef.<span class="hljs-property">current</span>);
      }
    }

    <span class="hljs-comment">// 清理定时器（对应 Vue 的 onUnmounted 部分）</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearTimeout</span>(timer);
      <span class="hljs-keyword">if</span> (resizeObserverRef.<span class="hljs-property">current</span>) {
        resizeObserverRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">disconnect</span>();
        resizeObserverRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      }
    };
  }, [sendItemHeight]); <span class="hljs-comment">// 仅首次挂载执行</span>

  <span class="hljs-comment">//监听 item 变化重新计算高度</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">sendItemHeight</span>();
    }, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer);
  }, [item.<span class="hljs-property">id</span>, sendItemHeight]); <span class="hljs-comment">// item.id 变化时执行</span>

  <span class="hljs-keyword">const</span> itemClass = <span class="hljs-string">`py-2 px-4 border-b border-gray-200 <span class="hljs-subst">${
    item.id % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> ? <span class="hljs-string">'bg-pink-200'</span> : <span class="hljs-string">'bg-green-200'</span>
  }</span>`</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-attr">itemStyle</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">CSSProperties</span> = {
    <span class="hljs-attr">height</span>: item.<span class="hljs-property">id</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">'150px'</span> : <span class="hljs-string">'100px'</span>,
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{itemRef}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{itemClass}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{itemStyle}</span>&gt;</span>
      {item.name}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">VirtualListItem</span>;


</code></pre>
<p><strong>父组件：</strong></p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, {
  useEffect,
  useRef,
  useState,
  useCallback,
  useMemo,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">VirtualListItem</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./listItem'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">VirtualList</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 最小项高度</span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BUFFER</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 缓冲区项数</span>

  <span class="hljs-keyword">const</span> virtualListRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 虚拟列表容器引用</span>

  <span class="hljs-keyword">const</span> [listData, setListData] = useState&lt;<span class="hljs-title class_">Array</span>&lt;{ <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }&gt;&gt;(
    []
  ); <span class="hljs-comment">// 列表数据</span>
  <span class="hljs-keyword">const</span> [scrollTop, setScrollTop] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 滚动位置</span>
  <span class="hljs-keyword">const</span> [itemHeights, setItemHeights] = useState&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;&gt;(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  ); <span class="hljs-comment">// 高度映射表（Map 结构）</span>
  <span class="hljs-keyword">const</span> [cumulativeHeights, setCumulativeHeights] = useState&lt;<span class="hljs-built_in">number</span>[]&gt;([<span class="hljs-number">0</span>]); <span class="hljs-comment">// 累计高度数组</span>
  <span class="hljs-keyword">const</span> scrollTimerRef = useRef&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 滚动节流定时器</span>

  <span class="hljs-comment">// 初始化模拟数据</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">initData</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> mockData = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000</span> }, <span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> ({
      <span class="hljs-attr">id</span>: index,
      <span class="hljs-attr">name</span>: <span class="hljs-string">`Item <span class="hljs-subst">${index}</span>`</span>,
    }));
    <span class="hljs-title function_">setListData</span>(mockData);
    <span class="hljs-comment">// 初始化高度映射表（默认最小高度）</span>
    <span class="hljs-keyword">const</span> initHeightMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;();
    mockData.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
      initHeightMap.<span class="hljs-title function_">set</span>(item.<span class="hljs-property">id</span>, <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span>);
    });
    <span class="hljs-title function_">setItemHeights</span>(initHeightMap);
    <span class="hljs-comment">// 初始化累计高度</span>
    <span class="hljs-title function_">updateCumulativeHeights</span>(initHeightMap, mockData);
  };

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">initData</span>();
    <span class="hljs-comment">// 监听窗口大小变化</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResize</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">if</span> (virtualListRef.<span class="hljs-property">current</span>) {
        <span class="hljs-title function_">setScrollTop</span>(virtualListRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollTop</span>);
      }
    };
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, handleResize);

    <span class="hljs-comment">// 清理监听</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'resize'</span>, handleResize);
      <span class="hljs-keyword">if</span> (scrollTimerRef.<span class="hljs-property">current</span>) {
        <span class="hljs-built_in">clearTimeout</span>(scrollTimerRef.<span class="hljs-property">current</span>);
      }
      itemHeights.<span class="hljs-title function_">clear</span>(); <span class="hljs-comment">// 清空 Map 释放内存</span>
    };
  }, []);

  <span class="hljs-comment">// 更新累计高度（核心函数）</span>
  <span class="hljs-keyword">const</span> updateCumulativeHeights = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">heightMap: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;, data: <span class="hljs-keyword">typeof</span> listData</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> cumulative = [<span class="hljs-number">0</span>];
      <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">const</span> itemId = data[i].<span class="hljs-property">id</span>;
        sum += heightMap.<span class="hljs-title function_">get</span>(itemId) || <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span>;
        cumulative.<span class="hljs-title function_">push</span>(sum);
      }
      <span class="hljs-title function_">setCumulativeHeights</span>(cumulative);
    },
    [<span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span>]
  );

  <span class="hljs-comment">// 处理子组件的高度更新事件（对应 Vue 的 handleItemHeightUpdate）</span>
  <span class="hljs-keyword">const</span> handleItemHeightUpdate = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, height: <span class="hljs-built_in">number</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 高度未变化则跳过</span>
      <span class="hljs-keyword">if</span> (itemHeights.<span class="hljs-title function_">get</span>(id) === height) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// 更新高度映射表</span>
      <span class="hljs-keyword">const</span> newHeightMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(itemHeights);
      newHeightMap.<span class="hljs-title function_">set</span>(id, height);
      <span class="hljs-title function_">setItemHeights</span>(newHeightMap);

      <span class="hljs-comment">// 异步更新累计高度</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">updateCumulativeHeights</span>(newHeightMap, listData);
      }, <span class="hljs-number">0</span>);
    },
    [itemHeights, listData, updateCumulativeHeights]
  );

  <span class="hljs-comment">// 滚动节流处理</span>
  <span class="hljs-keyword">const</span> handleScroll = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!virtualListRef.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 节流：20ms 内只更新一次 scrollTop</span>
    <span class="hljs-keyword">if</span> (scrollTimerRef.<span class="hljs-property">current</span>) {
      <span class="hljs-built_in">clearTimeout</span>(scrollTimerRef.<span class="hljs-property">current</span>);
    }
    scrollTimerRef.<span class="hljs-property">current</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setScrollTop</span>(virtualListRef.<span class="hljs-property">current</span>!.<span class="hljs-property">scrollTop</span>);
    }, <span class="hljs-number">20</span>);
  }, []);

  <span class="hljs-comment">// 可视区域高度</span>
  <span class="hljs-keyword">const</span> viewportHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> virtualListRef.<span class="hljs-property">current</span>?.<span class="hljs-property">clientHeight</span> || <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span> * <span class="hljs-number">5</span>;
  }, []);

  <span class="hljs-comment">//  总列表高度</span>
  <span class="hljs-keyword">const</span> totalHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> cumulativeHeights[cumulativeHeights.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] || <span class="hljs-number">0</span>;
  }, [cumulativeHeights]);

  <span class="hljs-comment">// 起始索引</span>
  <span class="hljs-keyword">const</span> startIndex = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> totalItemCount = listData.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">if</span> (totalItemCount === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (scrollTop &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 反向遍历找起始索引</span>
    <span class="hljs-keyword">let</span> baseStartIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = cumulativeHeights.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
      <span class="hljs-keyword">if</span> (cumulativeHeights[i] &lt;= scrollTop) {
        baseStartIndex = i;
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">const</span> finalIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, baseStartIndex - <span class="hljs-variable constant_">BUFFER</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(finalIndex, totalItemCount - <span class="hljs-number">1</span>);
  }, [
    scrollTop,
    viewportHeight,
    totalHeight,
    cumulativeHeights,
    listData.<span class="hljs-property">length</span>,
  ]);

  <span class="hljs-comment">// 结束索引</span>
  <span class="hljs-keyword">const</span> endIndex = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> totalItemCount = listData.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">if</span> (totalItemCount === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> targetScrollBottom = scrollTop + viewportHeight;
    <span class="hljs-keyword">let</span> baseEndIndex = totalItemCount - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cumulativeHeights.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (cumulativeHeights[i] &gt; targetScrollBottom) {
        baseEndIndex = i - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">let</span> finalEndIndex = baseEndIndex + <span class="hljs-variable constant_">BUFFER</span>;
    finalEndIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(finalEndIndex, totalItemCount - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> finalEndIndex;
  }, [scrollTop, viewportHeight, cumulativeHeights, listData.<span class="hljs-property">length</span>]);

  <span class="hljs-comment">// 可视区列表</span>
  <span class="hljs-keyword">const</span> visibleList = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> startIndex &lt;= endIndex
      ? listData.<span class="hljs-title function_">slice</span>(startIndex, endIndex + <span class="hljs-number">1</span>)
      : [];
  }, [startIndex, endIndex, listData]);

  <span class="hljs-comment">// 偏移量</span>
  <span class="hljs-keyword">const</span> offsetY = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> cumulativeHeights[startIndex] || <span class="hljs-number">0</span>;
  }, [startIndex, cumulativeHeights]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"h-full bg-gradient-to-br from-indigo-600 to-purple-600 py-10 px-5"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-white mt-10 h-[calc(100vh-200px)] rounded-xl"</span>&gt;</span>
        {/* 滚动容器 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
          <span class="hljs-attr">ref</span>=<span class="hljs-string">{virtualListRef}</span>
          <span class="hljs-attr">className</span>=<span class="hljs-string">"h-full overflow-auto relative"</span>
          <span class="hljs-attr">onScroll</span>=<span class="hljs-string">{handleScroll}</span>
        &gt;</span>
          {/* 占位容器：撑开滚动条 */}
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">height:</span> `${<span class="hljs-attr">totalHeight</span>}<span class="hljs-attr">px</span>` }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

          {/* 可视区域列表：transform 偏移 */}
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">"absolute top-0 left-0 right-0"</span>
            <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">transform:</span> `<span class="hljs-attr">translateY</span>(${<span class="hljs-attr">offsetY</span>}<span class="hljs-attr">px</span>)` }}
          &gt;</span>
            {visibleList.map((item) =&gt; (
              <span class="hljs-tag">&lt;<span class="hljs-name">VirtualListItem</span>
                <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>
                <span class="hljs-attr">item</span>=<span class="hljs-string">{item}</span>
                <span class="hljs-attr">onUpdateHeight</span>=<span class="hljs-string">{handleItemHeightUpdate}</span>
              /&gt;</span>
            ))}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">VirtualList</span>;

</code></pre>
<h3 data-id="heading-10">4. 实现效果图</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f94fc95662c463caed332ed77b1d3c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=SGyg1H2pDISwd9X9leROtXl7YlA%3D" alt="动高虚拟列表滚动.gif" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-11">四、 总结与避坑指南</h2>
<h3 data-id="heading-12">1. 为什么需要缓冲区（BUFFER）？</h3>
<p>如果只渲染可见部分，用户快速滚动时，异步渲染可能会导致瞬间的“白屏”。设置上下缓冲区可以预加载部分 DOM，让滑动更顺滑。</p>
<h3 data-id="heading-13">2. 性能进一步优化</h3>
<ul>
<li><strong>滚动节流（Throttle）</strong> ：虽然滚动监听很快，但在 <code>handleScroll</code> 中加入 <code>requestAnimationFrame</code> 或 20ms 的节流，能有效减轻主线程压力。</li>
<li><strong>Key 的选择</strong>：在虚拟列表中，<code>key</code> 必须是唯一的 <code>id</code>，绝对不能使用 <code>index</code>，否则在滚动重用 DOM 时会出现状态错乱。</li>
</ul>
<h3 data-id="heading-14">3. 注意事项</h3>
<ul>
<li><strong>定高</strong>：逻辑简单，性能极高。</li>
<li><strong>不定高</strong>：依赖 <code>ResizeObserver</code>，需注意频繁重排对性能的影响，建议对 <code>updateCumulativeHeights</code> 做异步批处理。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[脚本伪装：让 Python 与 Node.js 像原生 Shell 命令一样运行]]></title>    <link>https://juejin.cn/post/7603591775391973403</link>    <guid>https://juejin.cn/post/7603591775391973403</guid>    <pubDate>2026-02-07T01:59:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603591775391973403" data-draft-id="7603584155785379890" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="脚本伪装：让 Python 与 Node.js 像原生 Shell 命令一样运行"/> <meta itemprop="keywords" content="JavaScript,Python,运维"/> <meta itemprop="datePublished" content="2026-02-07T01:59:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="火车叼位"/> <meta itemprop="url" content="https://juejin.cn/user/1345457960792808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            脚本伪装：让 Python 与 Node.js 像原生 Shell 命令一样运行
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1345457960792808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    火车叼位
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T01:59:16.000Z" title="Sat Feb 07 2026 01:59:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    18
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在开发自动化工具或命令行小玩具时，频繁输入 <code>python myscript.py</code> 或 <code>node index.js</code> 难免显得笨拙。为了让这些脚本看起来更像系统原生的二进制工具，我们需要对其进行“伪装”。</p>
<p>本文将带你攻克 Linux 和 Windows 两大平台，实现脚本的直接调用。</p>
<h2 data-id="heading-0">一、 Linux 环境：利用 Shebang 实现优雅调用</h2>
<p>在类 Unix 系统（Linux, macOS, BSD）中，内核支持一种名为 <strong>Shebang</strong> 的机制。通过在文件头部指定解释器路径，系统会自动调用相应的环境来运行代码。</p>
<h4 data-id="heading-1">1. 核心步骤：Shebang + 可执行权限</h4>
<p>要在 Linux 上实现“伪装”，你需要完成以下两个动作：</p>
<p><strong>第一步：在脚本首行添加 Shebang</strong>
推荐使用 <code>/usr/bin/env</code> 方式，它会自动从用户的 <code>PATH</code> 环境变量中寻找解释器，具有极强的可移植性。</p>
<ul>
<li><strong>Python 示例：</strong></li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#!/usr/bin/env python3</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Python 正在运行，参数为: <span class="hljs-subst">{sys.argv[<span class="hljs-number">1</span>:]}</span>"</span>)

</code></pre>
<ul>
<li><strong>Node.js 示例：</strong></li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-meta">#!/usr/bin/env node</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Node.js 脚本已启动，当前工作目录:"</span>, process.<span class="hljs-title function_">cwd</span>());

</code></pre>
<p><strong>第二步：赋予执行权限</strong>
在终端运行 <code>chmod +x</code> 命令，告诉文件系统该文件可以被执行：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">chmod</span> +x my_script.py

</code></pre>
<p>此时，你就可以通过 <code>./my_script.py</code> 直接运行它了。</p>
<h4 data-id="heading-2">2. 进阶：去除后缀并全局化</h4>
<p>如果你想在任何路径下通过输入 <code>mytool</code>（而不是 <code>./mytool.py</code>）来运行脚本：</p>
<ol>
<li><strong>重命名并去掉后缀</strong>：<code>mv my_script.py mytool</code></li>
<li><strong>移入 PATH 路径</strong>：</li>
</ol>
<pre><code class="hljs language-bash" lang="bash">sudo <span class="hljs-built_in">mv</span> mytool /usr/local/bin/

</code></pre>
<p><em>注：<code>/usr/local/bin</code> 通常默认在系统 PATH 中，这样你只需输入 <code>mytool</code> 即可直接触发。</em></p>
<hr/>
<h2 data-id="heading-3">二、 Windows 环境：从批处理到环境关联</h2>
<p>Windows 并不原生支持 Shebang 机制（除非在 WSL 内部运行）。它主要依靠<strong>文件扩展名关联</strong>。</p>
<h4 data-id="heading-4">1. 方案 A：使用 .bat 包装器（推荐）</h4>
<p>这是最稳妥的方法。通过创建一个简单的批处理文件，将接收到的所有参数（用 <code>%*</code> 表示）转发给脚本解释器。</p>
<ul>
<li><strong>创建 <code>mytool.bat</code>：</strong></li>
</ul>
<pre><code class="hljs language-batch" lang="batch">@echo off
python "C:\scripts\my_script.py" %*

</code></pre>
<p><em>注：<code>@echo off</code> 用于隐藏命令本身的执行行，<code>%*</code> 确保你传递给 <code>.bat</code> 的参数能原封不动地传给 Python。</em></p>
<h4 data-id="heading-5">2. 方案 B：利用文件关联</h4>
<p>如果你安装 Python 时勾选了 <strong>"Add Python to PATH"</strong>，Windows 会自动将 <code>.py</code> 文件关联到 <code>python.exe</code>。</p>
<ul>
<li>在命令行直接输入 <code>script.py</code> 即可运行。</li>
<li><strong>注意</strong>：<code>.js</code> 文件在 Windows 上默认关联的是老旧的 <code>WScript</code> (Windows Script Host)，这会导致运行 Node.js 脚本时报错。你需要手动修改 <code>.js</code> 的打开方式为 <code>node.exe</code>。</li>
</ul>
<h4 data-id="heading-6">3. 方案 C：PowerShell 别名（Alias）</h4>
<p>如果你是 PowerShell 用户，可以在配置文件中定义函数来实现：</p>
<pre><code class="hljs language-powershell" lang="powershell"># 在 $PROFILE 文件中添加
function Run-MyTool { python "C:\path\to\script.py" $args }
Set-Alias -Name mytool -Value Run-MyTool

</code></pre>
<hr/>
<h2 data-id="heading-7">三、 跨平台对比总结</h2>






























<table><thead><tr><th>特性</th><th>Linux / macOS</th><th>Windows</th></tr></thead><tbody><tr><td><strong>底层机制</strong></td><td>Shebang (<code>#!</code>)</td><td>文件后缀名关联</td></tr><tr><td><strong>推荐做法</strong></td><td><code>chmod +x</code> + <code>/usr/bin/env</code></td><td><code>.bat</code> 或 <code>.cmd</code> 包装</td></tr><tr><td><strong>全局调用</strong></td><td>放入 <code>/usr/local/bin</code></td><td>将脚本所在文件夹加入环境变量 <code>Path</code></td></tr><tr><td><strong>参数传递</strong></td><td>原生支持</td><td>需在批处理中使用 <code>%*</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-8">四、 结论与行动建议</h2>
<p>将脚本转化为工具不仅是为了“好看”，更是为了提升自动化流转的效率。</p>
<h4 data-id="heading-9">核心行动建议：</h4>
<ol>
<li>**优先使用 <code>/usr/bin/env**</code>：无论开发什么脚本，首行养成写 Shebang 的习惯，这能显著降低 Linux 用户的使用门槛。</li>
<li><strong>封装为工具包</strong>：如果你的脚本较多，建议将其统一放在一个目录下（如 <code>~/bin</code> 或 <code>C:\tools</code>），并将该目录添加到系统的 <code>PATH</code> 环境变量中。</li>
<li><strong>处理跨平台差异</strong>：对于需要跨平台分发的工具，可以考虑使用 <code>poetry</code> (Python) 或 <code>npm bin</code> (Node.js) 提供的 Entry Points 功能，它们会自动为你生成适配各平台的启动器。</li>
</ol>
<hr/>
<p><strong>参考来源：</strong></p>
<ul>
<li>Linux Manual Pages: <a href="https://link.juejin.cn?target=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman2%2Fexecve.2.html" target="_blank" title="https://man7.org/linux/man-pages/man2/execve.2.html" ref="nofollow noopener noreferrer">execve(2) - Shebang mechanism</a></li>
<li>Python Documentation: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2F3%2Fusing%2Fwindows.html" target="_blank" title="https://docs.python.org/3/using/windows.html" ref="nofollow noopener noreferrer">Using Python on Windows</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[也许你不需要创建.venv, 此规范使python脚本自备依赖]]></title>    <link>https://juejin.cn/post/7603591775391891483</link>    <guid>https://juejin.cn/post/7603591775391891483</guid>    <pubDate>2026-02-07T01:41:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603591775391891483" data-draft-id="7603591775391858715" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="也许你不需要创建.venv, 此规范使python脚本自备依赖"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-07T01:41:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="火车叼位"/> <meta itemprop="url" content="https://juejin.cn/user/1345457960792808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            也许你不需要创建.venv, 此规范使python脚本自备依赖
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1345457960792808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    火车叼位
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T01:41:50.000Z" title="Sat Feb 07 2026 01:41:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Python 开发中，我们经常陷入一种“环境通胀”：为了运行一个不到 50 行的简单脚本（比如抓个接口数据、写个 Streamlit 演示），却不得不经历 <code>python -m venv .venv</code>、激活环境、<code>pip install</code> 等一系列繁琐动作。</p>
<p>如果你手头有十个这样的脚本，你的磁盘就会被几十个重复的 <code>.venv</code> 文件夹占满。<strong>Astral 推出的 <code>uv</code> 工具正在终结这种低效。</strong> 配合 <strong>PEP 723 (Inline script metadata)</strong> 规范，我们可以真正实现“单文件即项目”的优雅体验。</p>
<hr/>
<h2 data-id="heading-0">1. 核心纠偏：uv init 还是 uv venv？</h2>
<p>很多初学者在刚接触 <code>uv</code> 时会感到困惑。其实，针对不同的颗粒度，<code>uv</code> 提供了三条清晰的路径：</p>

























<table><thead><tr><th>命令</th><th>适用场景</th><th>产物</th></tr></thead><tbody><tr><td><strong><code>uv init</code></strong></td><td><strong>正规军</strong>：需要长期维护、多人协作的复杂应用。</td><td><code>pyproject.toml</code>, <code>.python-version</code></td></tr><tr><td><strong><code>uv venv</code></strong></td><td><strong>传统派</strong>：只是想快点创建环境，继续用传统的 <code>pip</code> 习惯。</td><td><code>.venv</code> 文件夹</td></tr><tr><td><strong><code>uv run</code></strong></td><td><strong>特种兵</strong>：单脚本运行，<strong>不产生任何本地依赖文件夹</strong>。</td><td>临时缓存环境（自动管理）</td></tr></tbody></table>
<blockquote>
<p>[!TIP]
对于简单的工具脚本，<strong>忘掉前两个命令</strong>。你只需要 <code>uv run</code>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-1">2. 现代方案：PEP 723 脚本元数据</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fpeps.python.org%2Fpep-0723%2F" target="_blank" title="https://peps.python.org/pep-0723/" ref="nofollow noopener noreferrer">PEP 723</a> 是 Python 社区的一个里程碑。它允许我们将依赖信息直接以“代码注释”的形式嵌入到脚本头部。这意味着你的脚本具备了<strong>自描述性</strong>——它是自给自足的。</p>
<h3 data-id="heading-2">规范示例</h3>
<p>当你运行一个包含以下代码块的脚本时：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># /// script</span>
<span class="hljs-comment"># dependencies = [</span>
<span class="hljs-comment">#   "httpx",</span>
<span class="hljs-comment">#   "streamlit",</span>
<span class="hljs-comment"># ]</span>
<span class="hljs-comment"># ///</span>

<span class="hljs-keyword">import</span> httpx
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st

st.title(<span class="hljs-string">"Token 刷新工具"</span>)
<span class="hljs-comment"># 脚本逻辑...</span>

</code></pre>
<h3 data-id="heading-3">为什么这种方式更优秀？</h3>
<ol>
<li><strong>环境全自动化</strong>：运行 <code>uv run script.py</code> 时，<code>uv</code> 会瞬时在后台创建临时环境。如果依赖没变，下次运行会直接秒开。</li>
<li><strong>零污染</strong>：它不会在你的脚本目录下留下 <code>.venv</code> 文件夹，全局环境永远保持洁净。</li>
<li><strong>极简分发</strong>：把脚本发给同事时，不用再附带 <code>requirements.txt</code>。对方只要装了 <code>uv</code>，直接运行即可。</li>
</ol>
<hr/>
<h2 data-id="heading-4">3. 实战技巧：如何快速配置</h2>
<p>不想手动打那堆 <code># ///</code> 注释？<code>uv</code> 早就帮你想好了自动化方案。</p>
<p>如果你已经写好了一个脚本 <code>refresh_token.py</code>，只需在终端输入：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 为脚本一键添加依赖声明</span>
uv add --script refresh_token.py <span class="hljs-string">"streamlit"</span> <span class="hljs-string">"httpx"</span>

</code></pre>
<p>这会自动在文件头插入符合 PEP 723 规范的元数据。之后，你只需一行命令即可启动：</p>
<pre><code class="hljs language-bash" lang="bash">uv run refresh_token.py

</code></pre>
<hr/>
<h2 data-id="heading-5">4. 进阶特性：精细化控制</h2>
<p>除了基础的依赖管理，你还可以在脚本头部玩出更多花样：</p>
<ul>
<li><strong>版本约束</strong>：<code>"requests&gt;=2.31.0"</code>，确保脚本不会因为库升级而崩掉。</li>
<li><strong>指定 Python 版本</strong>：<code># requires-python = "&gt;=3.12"</code>，自动调用合适的解释器。</li>
<li><strong>工具链配置</strong>：通过 <code>[tool.uv]</code> 块自定义镜像源，解决国内下载慢的问题。</li>
</ul>
<hr/>
<h2 data-id="heading-6">结论与行动建议</h2>
<p>Python 脚本的开发模式正在从“手动建档”转向“声明式运行”。</p>
<ul>
<li><strong>立即可做</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.astral.sh%2Fuv%2Fgetting-started%2Finstallation%2F" target="_blank" title="https://docs.astral.sh/uv/getting-started/installation/" ref="nofollow noopener noreferrer">安装 uv</a>，并尝试用 <code>uv run --with &lt;库名&gt; &lt;脚本&gt;</code> 运行一个临时脚本。</li>
<li><strong>长期实践</strong>：对于所有的工具类脚本，统一使用 <code>uv add --script</code> 写入元数据，把每一个脚本都打造成一个<strong>自给自足的“单兵作战单元”</strong>。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[关于行业 AI Agent 评测的 9 个方面]]></title>    <link>https://juejin.cn/post/7603643385816514612</link>    <guid>https://juejin.cn/post/7603643385816514612</guid>    <pubDate>2026-02-08T03:04:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816514612" data-draft-id="7603643385816498228" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="关于行业 AI Agent 评测的 9 个方面"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-02-08T03:04:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="潘锦"/> <meta itemprop="url" content="https://juejin.cn/user/730549110707431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            关于行业 AI Agent 评测的 9 个方面
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/730549110707431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    潘锦
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:04:48.000Z" title="Sun Feb 08 2026 03:04:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>做 AI Agent，跑起来很容易，简单点函数调用+几个最好的大模型，复杂一点，整合或「学习」一些开源的多 Agent 项目，也能跑起来。</p>
<p>但是如何真正要做到一个行业中去，把一个行业 Agent 做好就没那么容易了，特别是让这个 Agent 能稳定的迭代，稳定的跑对了，也就难了。</p>
<p>在这些迭代过程中，我们会不停的换模型、改提示词、加工具、加缓存、改路由、做多智能体……</p>
<p>这样我们就会收获如下的一堆问题：</p>
<ul>
<li>线上用户说「变笨了」，却没证据；</li>
<li>反馈说生成效果不行，却不知道该如何描述其所说的效果；</li>
<li>修一个 bug，引入三个新 bug；</li>
<li>团队讨论靠口感，最后靠拍板；</li>
<li>研发不敢升级模型，因为测试周期太长；</li>
<li>业务要结果，技术要可控，双方都焦虑。</li>
</ul>
<p>面对这些问题，我们聊聊如何对行业 Agent 做评测。</p>
<h2 data-id="heading-0">0. 说在前面</h2>
<p>我们评测的是「系统」，不是「模型」</p>
<p>很多团队说在做评测，实际上只是在测「模型回复像不像」。对 Agent 来说不够，因为 Agent 的能力来自两部分：</p>
<ul>
<li>模型</li>
<li>工程：提示词、工具编排、状态管理、记忆、重试策略、检索、权限、路由、超时、并发、回退等</li>
</ul>
<p>所以评测对象应该是：模型 + 工程 的整体行为。</p>
<h2 data-id="heading-1">1. 标准</h2>
<p>团队里面一定要有领域专家，没有领域专家的测评只能算自娱自乐。</p>
<p>Agent 的「好」不是抽象的。没有领域专家，评测标准会变成两类坏结果：</p>
<ul>
<li>写得很漂亮，但不对应业务结果（比如客服很礼貌，但票据没关单）</li>
<li>标准含糊，评分不可重复（今天判通过，明天同样输出判不通过）</li>
</ul>
<p>「领域专家」不一定是外部大咖，很多时候就是我们身边的同事：</p>
<ul>
<li>客服主管（知道什么叫“解决”）</li>
<li>财务/风控（知道哪些动作不能做）</li>
<li>资深运营（知道用户会怎么钻空子）</li>
<li>负责交付的实施/售后（知道线上真实约束）</li>
<li>售前负责人（知道用户要的是什么）</li>
</ul>
<p>要求只有一个：两位领域专家独立评审同一个任务，应该能得到一致的 pass/fail。做不到就说明任务或标准还不够清晰。</p>
<h2 data-id="heading-2">2. 数据集</h2>
<p>输入与输出要成对，从 20 条 good case 和 bad case 开始吧。</p>
<p>很多团队拖着不做评测，理由是「没有足够的数据」。</p>
<h2 data-id="heading-3">2.1 数据集怎么来</h2>
<ol>
<li>线上事故 / 客诉 / 工单：最值钱，但也是压力最大的</li>
<li>发布前人工回归里会反复点的那些检查项</li>
<li>运营同学最常复述的“用户就爱这么问”</li>
<li>灰度期间的失败轨迹（尤其是工具调用失败、超时、权限不足、状态不一致）</li>
</ol>
<h2 data-id="heading-4">2.2 一个测试任务里应该包含什么</h2>
<ul>
<li>输入（用户消息 + 初始状态 + 可用工具 + 环境约束）</li>
<li>明确的成功条件</li>
<li>参考解（可能是图、视频和文本）</li>
</ul>
<p>当遇到测试不通过或者通过率很低时，一般不是模型不行，可能是设计的测试任务有问题。</p>
<h2 data-id="heading-5">2.3 数据集要有正反两派</h2>
<p>测试人都知道的，做测试更多的是测异常。在做数据集时，这个逻辑一样的成立。</p>
<ul>
<li>该搜 vs 不该搜</li>
<li>该下单 vs 不该下单</li>
<li>该升级人工 vs 应该继续处理</li>
<li>该改文件 vs 不该动文件</li>
<li>该生成图 vs 应该拒绝（合规/版权/不当内容）</li>
</ul>
<h2 data-id="heading-6">3. 系统</h2>
<p>让过程系统化，小系统也是系统</p>
<p>评测不系统化，最后一定会回到「手工点点点 + 群里吵架」。一个可用的评测系统，最少包括：</p>
<h2 data-id="heading-7">3.1 评测运行系统</h2>
<ul>
<li>并发跑任务</li>
<li>每个环境隔离（干净的文件系统、数据库、缓存、账户）</li>
<li>固定随机种子/版本（尽量可复现）</li>
<li>记录完整过程</li>
<li>输出结构化结果</li>
</ul>
<p>请注意：共享状态会污染结果。</p>
<p>这个系统可以大，也可以小，甚至小到只是一个 python 脚本。</p>
<h2 data-id="heading-8">3.2 评测资产管理</h2>
<ul>
<li>任务版本化（任务也要像代码一样走 PR）</li>
<li>rubric/断言版本化</li>
<li>基线版本固定可回放</li>
<li>失败样本池：每次线上新失败，能快速进入评测集</li>
<li>评测数据集管理</li>
<li>评测结果管理，特别是图片类 Agent，所有的结果图都需要保存，并且能随时查阅，给到领域专家来审查。</li>
</ul>
<h2 data-id="heading-9">3.3 结果可读性</h2>
<p>最终的结果重要，但这个结果不仅仅是分数，还必须能「点开看」：</p>
<ul>
<li>失败的结果</li>
<li>判定理由</li>
<li>最终的证据（输入的 prompt，图片结果，过程中的数据库/文件/页面状态等等）</li>
</ul>
<h2 data-id="heading-10">4. 成本</h2>
<p>和过往的测试工作不同，AI 的评测需要更多些的考虑成本，特别是多模态或视频，生图类 Agent。</p>
<p>这里的基本逻辑是：每个 AI 算力资源都是有限的，也是贵的。</p>
<p>如果在一个死循环中写了调用外部视频生成的接口逻辑，那等待的就是账号里面的钱被用光，如果有加了使用限制，大概率就是达到限制。</p>
<p>以第三方大模型账号为例，有几个小点：</p>
<ol>
<li>测试账号要和生产账号隔离，防止异常突出导致资源受限，在每个平台请求并发数，或者分钟请求数，或者 token 速度都是有限的，不同环境的资源需要隔离开来。</li>
<li>账号需要做好限制，防止账号的钱被用完；</li>
<li>安全考虑，定期更换。</li>
</ol>
<h2 data-id="heading-11">5. 传统测试方式</h2>
<p>静态分析、工具验证、记录分析这些传统的测试方法别丢了。</p>
<h2 data-id="heading-12">5.1 静态分析</h2>
<p>适合：</p>
<ul>
<li>代码类：lint、type check、安全扫描（ruff/mypy/bandit 这类）</li>
<li>配置类：schema 校验</li>
<li>文本结构：JSON schema、正则、字段完整性 优势：快、便宜、可复现、可 debug。</li>
</ul>
<h2 data-id="heading-13">5.2 工具验证</h2>
<p>Agent 出问题很常见的一类是：工具用错、参数错、顺序不合理、该用不用。</p>
<p>你可以验证：</p>
<ul>
<li>是否调用了某工具</li>
<li>参数是否在范围（例如退款金额 &lt;=100）</li>
<li>是否访问了不该访问的资源</li>
</ul>
<p>但要注意：不要把“必须按某条路径走”写死。太死会惩罚合理的创造性解法。更推荐「看产出」，必要时只加一些底线约束（比如必须做身份验证）。</p>
<h2 data-id="heading-14">5.3 记录分析</h2>
<p>不一定评价“对错”，而是监控质量与成本：</p>
<ul>
<li>turn 数、toolcall 数、tokens</li>
<li>延迟：TTFT、总耗时、吞吐</li>
<li>重试次数、错误码分布</li>
</ul>
<h2 data-id="heading-15">6. 新的基于大模型的测试</h2>
<p>该用用，但要用得克制</p>
<p>对于评测，我们通过可以分为三类：代码型、模型型、人工。实际落地里，模型型的价值主要在两件事：</p>
<ol>
<li>开放式输出：没有唯一正确答案（客服话术、研究总结、写作、规划）</li>
<li>细粒度质量维度：礼貌、同理心、覆盖度、论证质量、是否胡编</li>
</ol>
<p>常用方式：</p>
<ul>
<li>打分（按维度给分）</li>
<li>自然语言断言（是否满足某条要求）</li>
<li>A/B 谁更好</li>
<li>对照参考答案</li>
<li>多裁判投票/取中位数</li>
</ul>
<p>但需要注意：</p>
<ul>
<li>非确定性：同样输入可能不同评分</li>
<li>更贵：相当于每条任务再跑一遍模型</li>
<li>需要校准：必须和人评对齐，否则就是“模型自嗨”</li>
</ul>
<p>一个实用的建议：给 LLM 评测一个「退路」，例如信息不足就输出 Unknown，避免它为了「必须回答」而脑补。</p>
<p>另外：把评分标准结构化，并拆维度单独评，不要一次判所有维度，噪声会很大，因为随着上下文更长，大模型的注意力会出现一些问题。</p>
<h2 data-id="heading-16">7. 人工评分</h2>
<p>领域专家门禁：效果不好就不能上，灰度可选</p>
<p>人工评分并不是用来「天天打分」的，人工的职责更多是：</p>
<ul>
<li>定义标准（什么叫好）</li>
<li>校准 LLM grader（对齐、抽检、纠偏）</li>
<li>做门禁（关键版本上线前必须过）</li>
</ul>
<h2 data-id="heading-17">7.1 门禁怎么做</h2>
<ul>
<li>定一个小的「关键任务集」（比如 30 条最关键、最敏感、最影响收入/合规的），或者称为黄金链路</li>
<li>每次大改/换模型/换工具链，必须过这个集</li>
<li>过不了：不讨论「用户可能不在意」，直接回滚或修</li>
</ul>
<h2 data-id="heading-18">7.2 灰度</h2>
<p>没有足够流量，灰度很难有显著的效果，也没有啥意义：</p>
<ul>
<li>用离线评测 + 小范围内测</li>
<li>线上用强监控兜底（错误、成本、关键转化、人工接管率等）</li>
</ul>
<p>等流量与组织能力到位，再做严格 A/B。</p>
<h2 data-id="heading-19">8. 流程</h2>
<p>从 0 到 1，再到可持续</p>
<p>这套流程的目标很简单：让每次改动都有依据，上线前知道会不会退步，退步了能快速定位原因。</p>
<h2 data-id="heading-20">第 0 步：尽早开工，小样本就能跑起来</h2>
<p>别等“数据够多”。先做一个能工作的最小闭环。</p>
<ul>
<li>
<p>先收 20–50 条真实案例（成功和失败都要）</p>
</li>
<li>
<p>来源：线上工单、客服反馈、bug 记录、内部手工测试步骤</p>
</li>
<li>
<p>每条案例都写清楚：什么算成功，什么算失败</p>
</li>
<li>
<p>先把基础能力跑通： 能批量跑 → 每次互不干扰 → 全程有记录 → 能出汇总表</p>
</li>
</ul>
<p>这一阶段不追求完美，只追求“评测能运转”。</p>
<h2 data-id="heading-21">第 1 步：把“手工回归”变成固定任务清单</h2>
<p>你们发布前人工必做的检查，本质上就是任务列表，只是没系统化。</p>
<ul>
<li>发布前“必须点”的那些流程，全部写成任务，进评测库</li>
<li>线上出现的 bug / 客诉，能复现的尽量都写成任务</li>
<li>按影响排序： 影响钱 / 合规 / 大客户 / 高频场景优先</li>
</ul>
<p>做久了会发现：评测库就是你们产品真实使用方式的地图。</p>
<h2 data-id="heading-22">第 2 步：任务要写得清楚，评分要能落地</h2>
<p>一条任务写不清楚，后面全是噪音。</p>
<p>至少要满足三条：</p>
<ol>
<li>两位领域同学看完任务描述，能给出一致的“过/不过”</li>
<li>给每条任务准备一个“标准答案/参考做法”（证明这题能做对）</li>
<li>评分标准不能靠“默认常识”</li>
</ol>
<ul>
<li>评测要检查什么，任务里就要写清楚</li>
<li>别出现“任务没说路径，但测试默认某个路径”这种坑</li>
</ul>
<p>任务写得越清楚，后面迭代越省时间。</p>
<h2 data-id="heading-23">第 3 步：任务要成对出现</h2>
<p>很多系统越改越怪，可能是评测只给了单边信号。</p>
<p>每类行为都尽量做成一对：</p>
<ul>
<li>该查资料 / 不该查资料</li>
<li>该下单 / 不该下单</li>
<li>该继续处理 / 该转人工</li>
<li>该修改文件 / 不该动文件</li>
<li>该生成 / 该拒绝（合规类尤其重要）</li>
</ul>
<h2 data-id="heading-24">第 4 步：把评测环境做稳定，确保结果可信</h2>
<p>评测不可信，比没有评测更糟糕。</p>
<p>关键点：</p>
<ul>
<li>每次运行从干净环境开始（文件、数据库、缓存都重置）</li>
<li>尽量减少共享状态（否则会互相污染）</li>
<li>资源要有上限（CPU/内存/网络），避免“机器不够导致一片失败”</li>
<li>失败要能区分：</li>
<li>是系统真不行</li>
<li>还是环境抖动、配额限制、工具不稳定</li>
</ul>
<p>要保证：同一版本跑两次，结果大体一致。</p>
<h2 data-id="heading-25">第 5 步：评分规则按「能自动就自动」来设计</h2>
<p>评分不要一上来就全靠大模型判。</p>
<p>推荐顺序：</p>
<ol>
<li>能用确定规则判断的，先用确定规则</li>
</ol>
<ul>
<li>结果是否写进数据库、订单是否存在、文件是否生成、测试是否通过</li>
</ul>
<ol>
<li>能用简单规则校验的，用规则</li>
</ol>
<ul>
<li>字段完整、格式正确、调用工具参数在范围内</li>
</ul>
<ol>
<li>只有在确实需要“主观判断”时，才用大模型评分</li>
</ol>
<ul>
<li>语气、解释是否清楚、内容是否覆盖关键点</li>
</ul>
<p>还有一条很重要： 尽量评「最终交付」，少评「必须怎么做」。 路径卡太死，会误伤很多正确解。</p>
<h2 data-id="heading-26">第 6 步：固定做「看过程记录」，不然不知道问题在哪</h2>
<p>很多团队评测做不下去，就是因为只看分数，不看过程。</p>
<p>至少要做到三件事：</p>
<ul>
<li>分数下降时：优先看失败最多、影响最大的那几条任务的过程记录</li>
<li>每周抽查一批「通过」的过程记录（防止钻规则漏洞）</li>
<li>发现「明明做对了却被判错」，立刻修任务描述或评分规则</li>
</ul>
<p>一句话：评测系统也要像产品一样调试。</p>
<h2 data-id="heading-27">第 7 步：分数到顶了就补题，不然评测会失效</h2>
<p>分数 100% 不代表系统没问题，只代表这套题已经测不出差异。</p>
<p>做两件事：</p>
<ul>
<li>持续把新的线上失败变成新任务</li>
<li>专门补「更难、更真实」的场景（长流程、多约束、容易出错的边界条件）</li>
</ul>
<p>评测库要一直增长，否则它会变成摆设。</p>
<h2 data-id="heading-28">第 8 步：让评测「有人管、有人用、有人能加题」</h2>
<p>长期最有效的分工通常是：</p>
<ul>
<li>有一个小组负责评测系统本身（跑得稳、记录全、报表清楚）</li>
<li>各业务团队负责写任务（最懂用户的人写，写出来才贴近真实）</li>
<li>写任务像写代码一样走评审流程（谁提的、为什么提、怎么验证）</li>
</ul>
<p>让离用户最近的人能把问题变成任务，是评测能持续的关键。</p>
<h2 data-id="heading-29">9. 非确定性</h2>
<p>别再只盯「通过率」，用 pass@k 和 pass^k 讲清楚“稳定性”</p>
<p>Agent 的输出有随机性，同一任务可能今天过、明天不过。以下两个指标可以有：</p>
<ul>
<li>
<p>pass@k：k 次尝试里至少成功一次的概率</p>
</li>
<li>
<p>适合“允许多试一次”的场景（比如离线生成候选方案）</p>
</li>
<li>
<p>pass^k：k 次尝试全部成功的概率</p>
</li>
<li>
<p>适合“线上必须稳定”的场景（客服、交易、流程自动化）</p>
</li>
</ul>
<p>它们会随着 k 分化：</p>
<ul>
<li>k 越大，pass@k 越接近 100%</li>
<li>k 越大，pass^k 越接近 0（对稳定性要求更苛刻）</li>
</ul>
<p>这能解决很多争论：</p>
<ul>
<li>研发说「抽卡，多跑几次能过」</li>
<li>业务说「用户只给一次机会」 用 pass@k 和 pass^k 直接对齐产品要求。</li>
</ul>
<h2 data-id="heading-30">10. 安例：生图 AI Agent 如何评估</h2>
<p>生图 Agent 的评测，比「文生图模型评测」更难，因为 Agent 往往还会：</p>
<ul>
<li>和用户多轮确认需求</li>
<li>调风格/比例/seed/参考图</li>
<li>调用安全审核、版权过滤、提示词改写</li>
<li>产出多张候选并做挑选/排序</li>
<li>写交付说明（可商用/不可商用、使用建议）</li>
</ul>
<p>评测要覆盖的不是「画得好不好」一句话，而是「是否按业务标准交付」。</p>
<p>下面给一套实用的评测维度：</p>
<h2 data-id="heading-31">10.1 标准</h2>
<p>先定“交付合格”是什么</p>
<p>建议产品/设计/合规一起定 3–5 条硬标准，例如：</p>
<ul>
<li>不违规：敏感内容、未成年、色情、仇恨、暴力、政治等必须拦截或降级</li>
<li>不侵权：明显模仿特定 IP / 特定艺人脸 / 商标露出等按策略处理</li>
<li>满足需求：主体、场景、风格、比例、文字有无（比如“不要文字”）</li>
<li>质量底线：严重畸形、手指崩坏、文本乱码（如果要求有字则反过来）</li>
<li>可用性：分辨率、格式、背景透明/不透明、交付数量</li>
</ul>
<p>标准不要写成「更美观」「更高级」，要写成可判定的条目。</p>
<h2 data-id="heading-32">10.2 数据集</h2>
<p>最有效的来源通常是：</p>
<ul>
<li>用户最常下单的品类（电商主图、海报、头像、插画、UI 素材）</li>
<li>客诉：不像、漏元素、风格跑偏、文字错、侵权被投诉、审核误杀</li>
<li>运营活动：固定模板需求（这类最适合做回归）</li>
</ul>
<p>每条任务里建议固定：</p>
<ul>
<li>用户输入（含约束：尺寸、风格、禁忌、用途）</li>
<li>允许的工具（生成、放大、背景去除、OCR 检查、合规审查）</li>
<li>成功条件（至少满足哪些项）</li>
<li>参考交付（如果你们已有人工优秀样例，可以作为对照，但不强制唯一答案）</li>
</ul>
<h2 data-id="heading-33">10.3 评测流程</h2>
<p>评测建议按「确定性 → 半确定性 → 开放判断」的顺序叠起来，减少噪音、降低成本。</p>
<h3 data-id="heading-34">A. 结果校验（尽量全自动、最优先）</h3>
<p>这层解决「交付物是否合格」的硬指标：</p>
<ul>
<li>格式、尺寸、分辨率、通道（如 PNG 透明背景）</li>
<li>交付数量（例如必须 4 张）</li>
<li>文件可打开、无损坏</li>
<li>禁止内容检测（审核模型/规则引擎给出通过/拦截/分级）</li>
</ul>
<h3 data-id="heading-35">B. 内容对齐（半自动，能做多少做多少）</h3>
<p>这层解决“有没有按需求做”的关键事实核对：</p>
<ul>
<li>关键元素是否出现：用图像理解/检测器做覆盖检查（比如“猫 + 红围巾 + 雪地”）</li>
<li>不该出现的是否出现：</li>
<li>“不要文字”→ 用 OCR 检测是否有字</li>
<li>“不要 logo/商标”→ logo/商标检测（覆盖不了的留到抽检）</li>
</ul>
<h3 data-id="heading-36">C. 开放项判断（用于难以规则化的部分）</h3>
<p>这层才用多模态判断去评估更开放的维度，例如：</p>
<ul>
<li>主体/场景/风格是否整体匹配需求</li>
<li>是否存在明显瑕疵（手部畸形、脸崩、透视严重错误等）</li>
<li>交付说明是否写清：能否商用、限制条件、使用建议</li>
</ul>
<p>注意：开放项的判定要校准，不要一开始就“全自动放行”。</p>
<h3 data-id="heading-37">D. 过程约束（管体验、管成本）</h3>
<p>对 Agent 的“过程”也要设上限，不然容易出现“靠烧钱刷分”：</p>
<ul>
<li>最大对话轮次（例如 ≤ 6 轮）</li>
<li>工具调用次数上限（避免无限重试）</li>
<li>总耗时 / 总成本阈值</li>
</ul>
<h2 data-id="heading-38">10.4 成本控制</h2>
<p>生图评测很贵，建议分三层跑，不同层用不同频率：</p>
<ol>
<li>回归层（少量高价值，天天/每次发布必跑） 高频品类 + 高风险合规项 + 线上常见故障</li>
<li>能力层（持续加难题，定期跑） 风格混合、复杂构图、多约束冲突、长对话澄清等</li>
<li>抽检层（人工校准，每周固定抽样） 抽查“通过样本”和“失败样本”，用来校准开放项判断与审核策略</li>
</ol>
<h2 data-id="heading-39">10.5 典型坑</h2>
<p>提前避开</p>
<ul>
<li>只看审美分，不看合规/侵权/交付规格 → 上线风险最大</li>
<li>只测“能生成”，不测“该拒绝/该降级” → 合规体系形同虚设</li>
<li>不看过程记录 → 不知道是 Agent 真错了，还是评分/审核错了；也抓不到“用昂贵链路刷通过”</li>
<li>评分规则写死 → 把某一种构图当唯一正确，误杀大量合理解（导致迭代方向跑偏）</li>
</ul>
<h2 data-id="heading-40">11. 最后</h2>
<p>评测的目标是：知道变好还是变差、知道差在哪、知道怎么改。</p>
<p>真正成熟的状态通常是这样：</p>
<ul>
<li>每次改动都有反馈：离线分数怎么变、失败清单有哪些，一眼可见</li>
<li>分数下降能追到根因：能定位到具体哪条任务、哪段过程记录出了问题</li>
<li>关键回归集就是门禁：过不了就不发布（不讨论「感觉应该没事」）</li>
<li>换模型/换策略能算账：能快速判断「收益是否值得成本与风险” 」</li>
<li>线上与离线形成闭环：</li>
<li>线上出现的新失败，能快速回流成任务进评测库</li>
<li>离线提前发现的风险，能在上线前就挡住</li>
</ul>
<p>最后一句：一定要看过程记录。</p>
<p>以上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[「web extensions🛠️」有关浏览器扩展，开发前你需要知道一些......]]></title>    <link>https://juejin.cn/post/7603771025855971379</link>    <guid>https://juejin.cn/post/7603771025855971379</guid>    <pubDate>2026-02-08T03:45:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025855971379" data-draft-id="7603674653152968713" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="「web extensions🛠️」有关浏览器扩展，开发前你需要知道一些......"/> <meta itemprop="keywords" content="前端,JavaScript,开源"/> <meta itemprop="datePublished" content="2026-02-08T03:45:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JustHappy"/> <meta itemprop="url" content="https://juejin.cn/user/1489178757445003"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            「web extensions🛠️」有关浏览器扩展，开发前你需要知道一些......
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1489178757445003/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JustHappy
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:45:53.000Z" title="Sun Feb 08 2026 03:45:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>Hi，这里是JustHappy，上手直接开始开发插件？我想你会没有头绪，如果你从未开发过浏览器插件，我想这篇一定对你有帮助，哈哈至少在 vibe coding 的时候可以更好的指挥 AI 去帮助你，放心，我“碎片式写作”篇幅不长，希望给你带来愉快的阅读体验</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa66e70098c14f22bf486981a9a7ef5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSnVzdEhhcHB5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771127152&amp;x-signature=9GQPJjWSmpsmO5%2B8%2BKPy7%2B1n8hk%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">浏览器扩展是什么？</h2>
<p>浏览器扩展是由 Web 技术构建的小程序（HTML、CSS 和 JavaScript），扩展程序可通过自定义界面、监控浏览器事件和修改网页来提升浏览体验。</p>
<p>自 web 技术诞生初始不久，浏览器插件、扩展技术并应运而生，而后 FireFox、Chrome 等浏览器大厂也纷纷下场，并在 2015 年确定了统一的 WebExtensions 标准</p>
<p>在我眼中，浏览器扩展是 web 世界的“外挂”，你几乎可以通过它去操纵一切网页；同时它也是良好的应用内容载体，其独特的交互模式在一些场景实有奇效</p>
<h2 data-id="heading-1">统一的标准：WebExtensions（2015+）</h2>
<p>Mozilla、Google、Microsoft 达成共识，共同确立了 WebExtensions API ，我们之后的开发之路也围绕这个标准，这里先做个“路由”，这样以后找文档不至于迷路哈哈</p>
<p><strong>WebExtensions 标准适用的浏览器：</strong></p>
<ul>
<li><strong>Mozilla</strong> <strong>Firefox</strong></li>
<li><strong>Google</strong> <strong>Chrome</strong></li>
<li><strong>Microsoft</strong> <strong>Edge</strong></li>
<li><strong>Apple Safari（部分）</strong></li>
</ul>
<p>比较详尽的内容参照 MDN / chrome 文档 ： <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FMozilla%2FAdd-ons%2FWebExtensions" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions" ref="nofollow noopener noreferrer">MDN web Extensions</a> / <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%3Fhl%3Dzh-cn" target="_blank" title="https://developer.chrome.com/docs/extensions?hl=zh-cn" ref="nofollow noopener noreferrer">Chrome web Extension</a></p>
<h2 data-id="heading-2">它是一个完整的应用</h2>
<p>虽然我们通过 Web 技术来开发浏览器扩展，但它的形态绝对不是一个单纯的网页中的网页，而更像是一个完整的应用，有自己独立的一套运作体系，这个“应用”大致的构成成分如下</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2701aceb55464c0f985204e00e309b6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSnVzdEhhcHB5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771127152&amp;x-signature=z1nnY3CucaOBrhZUlTZvHrswfWo%3D" alt="" width="70%" loading="lazy"/></p>
<h2 data-id="heading-3">插件是如何操作页面的？</h2>
<p>我们往往通过一下两种方式操作页面（其余不推荐），受限于篇幅，这里只简单介绍</p>
<h3 data-id="heading-4">1. Content Script：扩展派驻在页面里的“手和眼”</h3>
<p><strong>Content Script 就是注入到匹配页面里的脚本</strong>，它能：</p>
<ul>
<li>读/改 DOM：<code>document.querySelector(...)</code>、<code>element.textContent = ...</code></li>
<li>监听事件：点击、输入、滚动</li>
<li>插入 UI：按钮、浮层、标记、高亮</li>
<li>观察变化：<code>MutationObserver</code></li>
</ul>
<p>关键点：<strong>它和网页 JS 共享同一个 DOM，但不共享同一个 JS 作用域</strong>（隔离世界）。</p>
<h3 data-id="heading-5">2. <code>chrome.scripting</code>：把脚本“打到页面里”</h3>
<p><code>chrome.scripting</code><strong>可以把代码“注入到页面”执行</strong>，但它<strong>并不等同于</strong>传统意义上“把脚本塞进网页里”</p>
<p><code>chrome.scripting</code> 是由扩展后台控制的“按需代码注入机制”，注入点默认是 Content Script 的隔离世界，而不是网页的 JS 主世界。</p>
<p><strong>典型流程是：</strong></p>
<ul>
<li>UI（popup/sidepanel）→ 发消息给 Background</li>
<li>Background 找到当前 tabId</li>
<li>Background 用 <code>scripting</code> 把脚本/样式注入到该 tab</li>
</ul>
<blockquote>
<p>ok，就到这，且听后续我们展开细说</p>
<p>如果你有兴趣，可以直接尝试我的插件开发模板，持续迭代中.....</p>
<p>使用文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsimonmie.github.io%2Fvue-chrome-extension-template%2F" target="_blank" title="https://simonmie.github.io/vue-chrome-extension-template/" ref="nofollow noopener noreferrer">simonmie.github.io/vue-chrome-…</a></p>
<p>github : <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSimonmie%2Fvue-chrome-extension-template" target="_blank" title="https://github.com/Simonmie/vue-chrome-extension-template" ref="nofollow noopener noreferrer">github.com/Simonmie/vu…</a></p>
<p>也欢迎各位大佬参与</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Ollama 部署 Qwen 详细指南（2026 最新版）]]></title>    <link>https://juejin.cn/post/7603677143214473231</link>    <guid>https://juejin.cn/post/7603677143214473231</guid>    <pubDate>2026-02-08T03:48:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603677143214473231" data-draft-id="7603673564908666915" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Ollama 部署 Qwen 详细指南（2026 最新版）"/> <meta itemprop="keywords" content="Ollama"/> <meta itemprop="datePublished" content="2026-02-08T03:48:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哈里谢顿"/> <meta itemprop="url" content="https://juejin.cn/user/3678304397695056"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Ollama 部署 Qwen 详细指南（2026 最新版）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3678304397695056/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哈里谢顿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:48:22.000Z" title="Sun Feb 08 2026 03:48:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>适用系统</strong>：Windows 10/11、macOS 12+、Linux（Ubuntu/CentOS）<br/>
<strong>目标模型</strong>：Qwen3 系列（含 1.8B / 7B / 32B 等版本）<br/>
<strong>前置要求</strong>：8GB+ 内存（推荐 16GB+），无需 GPU 也可运行小模型<br/>
<strong>更新日期</strong>：2026 年 2 月</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、为什么选择 Ollama + Qwen？</h2>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>一键部署</strong></td><td>无需配置 Python 环境、CUDA、依赖库</td></tr><tr><td>✅ <strong>自动量化</strong></td><td>自动下载 GGUF 4-bit 量化模型，节省显存</td></tr><tr><td>✅ <strong>跨平台支持</strong></td><td>Windows/macOS/Linux 全支持</td></tr><tr><td>✅ <strong>OpenAI 兼容 API</strong></td><td>可直接替换 GPT 调用</td></tr><tr><td>✅ <strong>中文优化</strong></td><td>Qwen 对中文理解远超 Llama 系列</td></tr></tbody></table>
<blockquote>
<p>💡 <strong>2026 年现状</strong>：Ollama 已原生支持 Qwen3 全系列模型，并启用 <strong>思考模式</strong>（<code>/think</code>）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-1">二、安装 Ollama</h2>
<h3 data-id="heading-2">▶️ Windows</h3>
<ol>
<li>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2Fdownload%2FOllamaSetup.exe" target="_blank" title="https://ollama.com/download/OllamaSetup.exe" ref="nofollow noopener noreferrer">ollama.com/download/Ol…</a></li>
<li>双击安装（默认安装到 <code>C:\Users&lt;user&gt;\AppData\Local\Programs\Ollama</code>）</li>
<li>安装完成后<strong>自动启动服务</strong>（系统托盘出现 🐫 图标）</li>
</ol>
<h3 data-id="heading-3">▶️ macOS</h3>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">方法 1：官网下载 dmg</span>
<span class="hljs-meta prompt_"># </span><span class="bash">https://ollama.com/download/Ollama-darwin.zip</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">方法 2：使用 Homebrew（推荐）</span>
brew install ollama
brew services start ollama
</code></pre>
<h3 data-id="heading-4">▶️ Linux（Ubuntu/Debian）</h3>
<pre><code class="hljs language-bash" lang="bash">curl -fsSL https://ollama.com/install.sh | sh
sudo systemctl <span class="hljs-built_in">enable</span> ollama
sudo systemctl start ollama
</code></pre>
<blockquote>
<p>🔍 <strong>验证安装</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">ollama --version
<span class="hljs-comment"># 输出示例：ollama version is 0.4.5</span>
</code></pre>
</blockquote>
<hr/>
<h2 data-id="heading-5">三、下载 Qwen 模型（关键步骤）</h2>
<p>Ollama 支持多种 Qwen 版本，命名规则为：<code>qwen3:&lt;size&gt;-&lt;quant&gt;</code>。</p>
<h3 data-id="heading-6">📦 可用模型列表（2026 年 2 月）</h3>








































<table><thead><tr><th>模型名称</th><th>参数量</th><th>量化方式</th><th>内存需求</th><th>下载命令</th></tr></thead><tbody><tr><td><code>qwen3:1.8b</code></td><td>1.8B</td><td>Q4_K_M</td><td>~2 GB</td><td><code>ollama pull qwen3:1.8b</code></td></tr><tr><td><code>qwen3:7b</code></td><td>7B</td><td>Q4_K_M</td><td>~6 GB</td><td><code>ollama pull qwen3:7b</code></td></tr><tr><td><code>qwen3:32b</code></td><td>32B</td><td>Q4_K_M</td><td>~20 GB</td><td><code>ollama pull qwen3:32b</code></td></tr><tr><td><code>qwen3:1.8b-q8_0</code></td><td>1.8B</td><td>Q8（高精度）</td><td>~3 GB</td><td><code>ollama pull qwen3:1.8b-q8_0</code></td></tr></tbody></table>
<blockquote>
<p>⚠️ <strong>注意</strong>：</p>
<ul>
<li>默认不加后缀 = Q4_K_M 量化（最佳性价比）</li>
<li>首次下载需 5~30 分钟（取决于网速和模型大小）</li>
</ul>
</blockquote>
<h3 data-id="heading-7">▶️ 下载示例（以 7B 为例）</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看可用标签</span>
ollama list

<span class="hljs-comment"># 下载 Qwen3-7B（自动量化）</span>
ollama pull qwen3:7b

<span class="hljs-comment"># 输出示例：</span>
<span class="hljs-comment"># pulling manifest</span>
<span class="hljs-comment"># pulling 8d9a4e3c... 100% ▕████████████████████████████████████████▏ 4.2 GB</span>
<span class="hljs-comment"># verifying sha256 digest</span>
<span class="hljs-comment"># writing manifest</span>
<span class="hljs-comment"># success</span>
</code></pre>
<blockquote>
<p>💡 <strong>提示</strong>：模型文件默认保存在：</p>
<ul>
<li>Windows: <code>C:\Users&lt;user&gt;.ollama\models</code></li>
<li>macOS: <code>~/.ollama/models</code></li>
<li>Linux: <code>~/.ollama/models</code></li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-8">四、命令行使用 Qwen</h2>
<h3 data-id="heading-9">▶️ 基础对话</h3>
<pre><code class="hljs language-arduino" lang="arduino">ollama run qwen3:<span class="hljs-number">7b</span>
&gt;&gt;&gt; 你好！介绍一下你自己。
</code></pre>
<h3 data-id="heading-10">▶️ 特殊指令（Qwen3 独有）</h3>

























<table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>/think</code></td><td>开启深度思考模式（慢但准确）</td></tr><tr><td><code>/nothink</code></td><td>关闭思考，快速响应</td></tr><tr><td><code>/clear</code></td><td>清空上下文</td></tr><tr><td><code>/set parameter num_ctx 4096</code></td><td>设置上下文长度</td></tr></tbody></table>
<blockquote>
<p>🌰 示例：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">&gt;</span><span class="bash">&gt;&gt; /think</span>
Thinking mode enabled.
<span class="hljs-meta prompt_">&gt;</span><span class="bash">&gt;&gt; 解释量子纠缠的原理，并举例说明。</span>
（模型将分步推理，输出更严谨）
</code></pre>
</blockquote>
<h3 data-id="heading-11">▶️ 多轮对话</h3>
<p>Ollama 自动维护会话上下文，直到输入 <code>/clear</code> 或退出。</p>
<hr/>
<h2 data-id="heading-12">五、API 调用（OpenAI 兼容）</h2>
<p>Ollama 启动后自动监听 <code>http://localhost:11434</code>，提供 OpenAI 兼容 API。</p>
<h3 data-id="heading-13">▶️ 请求示例（Python）</h3>
<pre><code class="hljs language-vbscript" lang="vbscript">import requests

<span class="hljs-built_in">response</span> = requests.post(
    <span class="hljs-string">"http://localhost:11434/api/chat"</span>,
    json={
        <span class="hljs-string">"model"</span>: <span class="hljs-string">"qwen3:7b"</span>,
        <span class="hljs-string">"messages"</span>: [
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"写一个 Python 快速排序函数"</span>}
        ],
        <span class="hljs-string">"stream"</span>: <span class="hljs-literal">False</span>
    }
)

pr<span class="hljs-built_in">int</span>(<span class="hljs-built_in">response</span>.json()[<span class="hljs-string">"message"</span>][<span class="hljs-string">"content"</span>])
</code></pre>
<h3 data-id="heading-14">▶️ OpenAI SDK 兼容（推荐）</h3>
<pre><code class="hljs language-ini" lang="ini">from openai import OpenAI

<span class="hljs-attr">client</span> = OpenAI(
    <span class="hljs-attr">base_url</span>=<span class="hljs-string">"http://localhost:11434/v1"</span>,
    <span class="hljs-attr">api_key</span>=<span class="hljs-string">"ollama"</span>  <span class="hljs-comment"># 任意值均可</span>
)

<span class="hljs-attr">completion</span> = client.chat.completions.create(
    <span class="hljs-attr">model</span>=<span class="hljs-string">"qwen3:7b"</span>,
    <span class="hljs-attr">messages</span>=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"Hello!"</span>}],
    <span class="hljs-attr">temperature</span>=<span class="hljs-number">0.7</span>
)

print(completion.choices<span class="hljs-section">[0]</span>.message.content)
</code></pre>
<blockquote>
<p>✅ <strong>优势</strong>：现有 GPT 代码只需改两行即可切换到 Qwen！</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">六、可视化界面推荐</h2>
<h3 data-id="heading-16">方案 1：ChatWise（免费，跨平台）</h3>
<ol>
<li>下载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fchatwise.app%2F" target="_blank" title="https://chatwise.app/" ref="nofollow noopener noreferrer">chatwise.app</a></li>
<li>安装后打开 → 选择 <strong>Ollama</strong> 作为后端</li>
<li>在模型列表中选择已下载的 <code>qwen3:7b</code></li>
<li>享受 Markdown 渲染、代码高亮、对话管理</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2406fad286b44740be8294353cc4e9ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOI6YeM6LCi6aG_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771127303&amp;x-signature=dDS8PxF4Jg7W7QZXFHb8iD000DE%3D" alt="ChatWise 界面" loading="lazy"/></p>
<h3 data-id="heading-17">方案 2：LM Studio（macOS/Windows）</h3>
<ul>
<li>支持本地模型管理</li>
<li>内置性能监控</li>
<li>下载地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Flmstudio.ai%2F" target="_blank" title="https://lmstudio.ai/" ref="nofollow noopener noreferrer">lmstudio.ai</a></li>
</ul>
<hr/>
<h2 data-id="heading-18">七、远程访问：让团队共享你的 Qwen</h2>
<h3 data-id="heading-19">使用 Cloudflare Tunnel（免费内网穿透）</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 下载 cloudflared</span>
<span class="hljs-comment"># https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation</span>

<span class="hljs-comment"># 2. 启动隧道（Ollama 默认端口 11434）</span>
cloudflared tunnel --url http://localhost:11434
</code></pre>
<blockquote>
<p>输出示例：</p>
<pre><code class="hljs language-arduino" lang="arduino">Your tunnel is ready! Visit: https:<span class="hljs-comment">//abc123.trycloudflare.com</span>
</code></pre>
</blockquote>
<h3 data-id="heading-20">在 ChatWise 中配置远程地址：</h3>
<ol>
<li>设置 → 模型服务 → Ollama</li>
<li>API 地址填写：<code>https://abc123.trycloudflare.com</code></li>
<li>团队成员即可通过公网使用你的 Qwen！</li>
</ol>
<blockquote>
<p>🔒 <strong>安全提示</strong>：生产环境建议添加 API Key 验证（需反向代理）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-21">八、性能调优技巧</h2>
<h3 data-id="heading-22">1. <strong>强制 CPU 模式（无 GPU 时）</strong></h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># Windows</span>
set <span class="hljs-attr">OLLAMA_NUM_GPU</span>=<span class="hljs-number">0</span>
ollama run qwen3:1.8b

<span class="hljs-comment"># Linux/macOS</span>
<span class="hljs-attr">OLLAMA_NUM_GPU</span>=<span class="hljs-number">0</span> ollama run qwen3:<span class="hljs-number">1.8</span>b
</code></pre>
<h3 data-id="heading-23">2. <strong>调整上下文长度</strong></h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建自定义 Modelfile</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"FROM qwen3:7b"</span> &gt; Modelfile
<span class="hljs-built_in">echo</span> <span class="hljs-string">"PARAMETER num_ctx 8192"</span> &gt;&gt; Modelfile

<span class="hljs-comment"># 构建新模型</span>
ollama create qwen3-7b-long -f Modelfile

<span class="hljs-comment"># 使用</span>
ollama run qwen3-7b-long
</code></pre>
<h3 data-id="heading-24">3. <strong>查看资源占用</strong></h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 实时监控</span>
ollama ps

<span class="hljs-comment"># 输出示例：</span>
<span class="hljs-comment"># NAME           ID              SIZE    PROCESSOR       UNTIL</span>
<span class="hljs-comment"># qwen3:7b       8d9a4e3c...     4.2 GB  100% CPU        5m</span>
</code></pre>
<hr/>
<h2 data-id="heading-25">九、常见问题解答（FAQ）</h2>
<h3 data-id="heading-26">❓ Q1：下载速度慢怎么办？</h3>
<p>✅ <strong>解决方案</strong>：</p>
<ul>
<li>
<p>使用国内镜像（需手动配置）：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 临时设置代理（如你有代理）</span>
<span class="hljs-built_in">export</span> http_proxy=http://your-proxy:port
<span class="hljs-built_in">export</span> https_proxy=http://your-proxy:port
ollama pull qwen3:7b
</code></pre>
</li>
<li>
<p>或从 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmodelscope.cn%2Fmodels%2Fqwen%2FQwen3-7B" target="_blank" title="https://modelscope.cn/models/qwen/Qwen3-7B" ref="nofollow noopener noreferrer">ModelScope</a> 手动下载 GGUF 文件，再导入 Ollama（高级操作）</p>
</li>
</ul>
<h3 data-id="heading-27">❓ Q2：如何删除模型释放空间？</h3>
<pre><code class="hljs language-bash" lang="bash">ollama <span class="hljs-built_in">rm</span> qwen3:7b
</code></pre>
<h3 data-id="heading-28">❓ Q3：支持函数调用（Function Calling）吗？</h3>
<p>✅ <strong>部分支持</strong>：</p>
<ul>
<li>Qwen3 原生支持 <strong>MCP 协议</strong>（非 OpenAI Function Calling）</li>
<li>需配合 MCP Server 使用（见 Qwen 官方文档）</li>
</ul>
<h3 data-id="heading-29">❓ Q4：能否微调模型？</h3>
<p>❌ <strong>Ollama 不支持微调</strong>！<br/>
✅ <strong>替代方案</strong>：</p>
<ul>
<li>使用 <strong>Qwen-Agent</strong> 框架进行 LoRA 微调</li>
<li>微调后导出 GGUF 格式，再通过 Ollama 加载</li>
</ul>
<hr/>
<h2 data-id="heading-30">十、学习资源</h2>
<ul>
<li><strong>Ollama 官方文档</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2Fdocs" target="_blank" title="https://ollama.com/docs" ref="nofollow noopener noreferrer">ollama.com/docs</a></li>
<li><strong>Qwen GitHub</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FQwenLM%2FQwen" target="_blank" title="https://github.com/QwenLM/Qwen" ref="nofollow noopener noreferrer">github.com/QwenLM/Qwen</a></li>
<li><strong>模型下载页</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2Flibrary%2Fqwen3" target="_blank" title="https://ollama.com/library/qwen3" ref="nofollow noopener noreferrer">Ollama Library - Qwen</a></li>
<li><strong>社区论坛</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdiscord.gg%2Follama" target="_blank" title="https://discord.gg/ollama" ref="nofollow noopener noreferrer">Ollama Discord</a></li>
</ul>
<hr/>
<h2 data-id="heading-31">十一、总结：最佳实践路径</h2>

























<table><thead><tr><th>目标</th><th>推荐配置</th></tr></thead><tbody><tr><td><strong>个人体验</strong></td><td><code>qwen3:1.8b</code> + ChatWise</td></tr><tr><td><strong>开发测试</strong></td><td><code>qwen3:7b</code> + OpenAI SDK</td></tr><tr><td><strong>高性能推理</strong></td><td><code>qwen3:32b</code> + vLLM（非 Ollama）</td></tr><tr><td><strong>团队共享</strong></td><td>Ollama + Cloudflare Tunnel</td></tr></tbody></table>
<blockquote>
<p>💬 <strong>记住</strong>：<br/>
<strong>“Ollama 让大模型本地化变得像安装 App 一样简单。”</strong><br/>
今天，你已拥有属于自己的中文 AI 助手！</p>
</blockquote>
<hr/>
<blockquote>
<p><strong>作者</strong>：AI 工程师<br/>
<strong>版权声明</strong>：本文可自由转载，但请保留出处。<br/>
<strong>GitHub 示例代码</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyourname%2Follama-qwen-guide" target="_blank" title="https://github.com/yourname/ollama-qwen-guide" ref="nofollow noopener noreferrer">github.com/yourname/ol…</a>（虚构）</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[pg内核实现细节]]></title>    <link>https://juejin.cn/post/7603644943350300678</link>    <guid>https://juejin.cn/post/7603644943350300678</guid>    <pubDate>2026-02-07T10:57:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603644943350300678" data-draft-id="7603644943350185990" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="pg内核实现细节"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2026-02-07T10:57:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户98286302568"/> <meta itemprop="url" content="https://juejin.cn/user/1370445415464027"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            pg内核实现细节
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1370445415464027/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户98286302568
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T10:57:38.000Z" title="Sat Feb 07 2026 10:57:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">TID(Tuple Id)</h3>
<p>tid表示一行数据在数据页上的逻辑地址，通过block id和offset来定义一个page内具体数据位置。定义如下：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ItemPointerData</span>
{
  BlockIdData blkid; <span class="hljs-comment">// 页号, u32类型</span>
  OffsetNumber posid;<span class="hljs-comment">// 业内slotid, u16类型</span>
}
</code></pre>
<h3 data-id="heading-1">页数据组织形式</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a81d0b1030c426b967b62a9263a142a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTgyODYzMDI1Njg=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771066658&amp;x-signature=h7NFa62ISRieN3YGyT3F9HbLKK4%3D" alt="image.png" loading="lazy"/>
和oracle一样，pg也是以页为单位来在存储介质和内存中记录行数据，通过tup可定位到对应page的某个TupleId, 然后找到存储实际行数据的tuple.</p>
<h3 data-id="heading-2">行级mvcc实现</h3>
<p>pg修改行数据时，保留旧行，并插入新行。每个事务都有唯一的事务id称为xid。<br/>
每行数据称为一个元组tuple，行头包含四个属性和一些标志位(行头总共有20字节，存储开销大，oracle只有3字节):</p>
<ul>
<li>xmin：创建一个元组时，将事务xid写入该属性；</li>
<li>xmax：默认为0，删除一个元组时，将事务xid写入该属性，update时会将老元组的xmax改成update所在事务xid；</li>
<li>cmin、cmax：记录同一个事务中不同语句顺序，从0开始；</li>
<li>ctid:该行数据对应的tid;</li>
<li>t_ctid:多版本下，通过该属性将同一行多版本串联起来，记录的是下一个多版本行的ctid;</li>
</ul>
<p>每个事务开启时，获取一个32bit的xid值，修改数据时，会创建新的元组记录xid到xmin中，并且写入到表数据中(新旧元组同时存在)。并标记老元组。</p>
<p>伪码示例</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1(c1 <span class="hljs-type">int</span>, c2 <span class="hljs-type">int</span>);

<span class="hljs-keyword">create</span> index idx1(t1.c2);

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);

#主表行信息:
ctid    xmin  xmax  t_ctid  data
(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   [<span class="hljs-number">2</span> <span class="hljs-number">3</span>]

#执行<span class="hljs-keyword">delete</span>删除第二行:<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">where</span> c1<span class="hljs-operator">=</span><span class="hljs-number">2</span>

#查询主表只会返回一行数据，但是存储的真实行数没有变化，只是将xmax更改为<span class="hljs-keyword">delete</span>语句对应的xid:<span class="hljs-number">200</span>，行本身不会真的删除
ctid    xmin  xmax  t_ctid  data
(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">200</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   [<span class="hljs-number">2</span> <span class="hljs-number">3</span>]

#执行<span class="hljs-keyword">update</span>语句更新第一行:<span class="hljs-keyword">update</span> t1 <span class="hljs-keyword">set</span> c2 <span class="hljs-operator">=</span> <span class="hljs-number">5</span> <span class="hljs-keyword">where</span> c1<span class="hljs-operator">=</span><span class="hljs-number">1</span>
#pg会拷贝第一行数据生成一个新的tuple, 然后更新<span class="hljs-keyword">old</span> tuple的xmax和t_ctid, 来和<span class="hljs-keyword">new</span> tuple链接起来
ctid    xmin  xmax  t_ctid  data
(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">300</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">200</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   [<span class="hljs-number">2</span> <span class="hljs-number">3</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)   <span class="hljs-number">300</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">5</span>]

#执行查询语句时, 会根据版本号判断返回第一行还是第三行给客户端

#由于c2列上存在索引，上述操作也会影响到索引表，索引表数据也会修改，和主表一样不会被“<span class="hljs-keyword">delete</span>”掉；
#pg的索引表没有多版本概念，而是借用主表的多版本来找到“可见”的最新行；因此索引表的tuple没有xmin<span class="hljs-operator">/</span>xmax等列;
#索引表的tuple通过htid列来关联上主表的tuple；
#更新主表索引列时，索引表也会做相应的修改；
#更新主表非索引列时，索引表不会做修改，通过上面介绍的版本链来找到最新tuple(HOT机制:heap<span class="hljs-operator">-</span><span class="hljs-keyword">only</span> tuple)；

#可以看出pg的多版本会很容易导致磁盘空间膨胀，需要vacuum操作来释放磁盘空间
</code></pre>
<h3 data-id="heading-3">vacuum机制：清理死元组解决表膨胀问题+解决xid回绕问题</h3>
<ul>
<li>事务提交后，新元组可以被其他事务看到，老元组不会被用到了，也不会立即被清理，可能导致表数据空间越来越大；</li>
<li>xid由32bit构成，最多存几亿个事务，数值越界时，会出现问题，vaccum机制会将已提交事务的产生的所有元组中隐藏列记录的xid改成2,1是系统xid，从3开始是正常事务可用值。因此只要是正常事务xid都会大于2，即都可以看到已提交事务的修改。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手搓 VM 复盘：从我的 C++ 并发 GC 到字节 PrimJS 的架构演进]]></title>    <link>https://juejin.cn/post/7603644943350366214</link>    <guid>https://juejin.cn/post/7603644943350366214</guid>    <pubDate>2026-02-07T12:31:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603644943350366214" data-draft-id="7603656494904721414" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手搓 VM 复盘：从我的 C++ 并发 GC 到字节 PrimJS 的架构演进"/> <meta itemprop="keywords" content="操作系统"/> <meta itemprop="datePublished" content="2026-02-07T12:31:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="肆忆_"/> <meta itemprop="url" content="https://juejin.cn/user/3898194938326714"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手搓 VM 复盘：从我的 C++ 并发 GC 到字节 PrimJS 的架构演进
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3898194938326714/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    肆忆_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T12:31:58.000Z" title="Sat Feb 07 2026 12:31:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近一直在死磕我的 C++ 虚拟机项目 <code>cilly-vm-cpp</code> 的垃圾回收（GC）模块。为了解决 Stop-The-World (STW) 带来的卡顿问题，我从最开始的单线程 Mark-Sweep，一步步优化到了现在的<strong>并行标记 (Parallel Marking)</strong> + <strong>并发清除 (Concurrent Sweep)</strong>。</p>
<p>本来以为这个架构对于一个学习型项目来说已经挺能打了，直到我为了寻找进一步优化的灵感，去啃了字节跳动开源的 <strong>PrimJS</strong>（Lynx 底层的 JS 引擎）的源码。这一对比，直接让我看到了“学院派实现”和“工业级引擎”之间的鸿沟。</p>
<p>这篇文章既是我的学习笔记，也是一次深度的架构复盘。我将详细拆解我的实现方案，深入解析 PrimJS 的核心架构，通过详细的对比分析，聊聊我准备如何改进我的 VM。</p>
<h2 data-id="heading-0">一、 我的 GC 是怎么实现的？</h2>
<p>我的核心目标很简单：<strong>别让主线程停太久</strong>。为了达成这个目标，我将 GC 拆解为两个阶段，并分别做了并发优化：</p>
<h3 data-id="heading-1">1. 并行标记 (Parallel Marking)</h3>
<p>在“标记阶段”，我们需要遍历整个对象图，找出所有活着的对象。为了利用多核 CPU，我引入了多线程标记：</p>
<ul>
<li><strong>CAS 抢占</strong>：给每个 <code>GcObject</code> 加了一个 <code>std::atomic&lt;bool&gt;</code> 标记位。多个线程同时看到同一个对象时，利用 CAS (Compare-And-Swap) 保证只有一个线程能成功标记并将其入栈，有效防止了重复处理。</li>
<li><strong>全局任务栈</strong>：使用一个 <code>vector&lt;GcObject*&gt; global_stack</code> 作为任务池。所有线程发现新对象（子节点）后，都往这个大栈里扔；没活干了，也都从这里拿。</li>
<li><strong>锁保护</strong>：因为大家都访问同一个栈，我必须加一把 <code>mutex</code> 锁，保证数据安全。</li>
</ul>
<h3 data-id="heading-2">2. 并发清除 (Concurrent Sweep)</h3>
<p>在“清除阶段”，如果有几万个死对象需要释放，主线程逐个 <code>delete</code> 会造成显著卡顿。</p>
<ul>
<li><strong>实现细节</strong>：
<ul>
<li>主线程只做一件事：快速遍历链表，把死对象从链表上“摘”下来（Unlink），放到一个临时列表里。</li>
<li>然后启动一个后台线程 (<code>std::thread(...).detach()</code>)，把这个列表移交给它。</li>
<li>主线程立刻返回继续跑业务代码，后台线程在另一边慢慢 <code>delete</code> 这些垃圾。</li>
</ul>
</li>
</ul>
<p><strong>效果</strong>：通过这两步改造，主线程几乎瞬间恢复响应，STW 时间被压缩到了极致。</p>
<h2 data-id="heading-3">二、 工业级的 PrimJS 是怎么玩的？（源码深度解析）</h2>
<p>PrimJS 是一个基于 QuickJS 深度魔改的高性能 JS 引擎，专为解决移动端的性能瓶颈而生。它的 GC 设计非常硬核，其核心思想是**“极致的性能与掌控”**——它甚至不信任系统的 <code>malloc</code>，而是自己接管了一切。</p>
<h3 data-id="heading-4">1. 核心架构设计</h3>
<ul>
<li><strong>兼容性内存管理 (Compatible MM)</strong>：PrimJS 不仅管理 JS 对象，还接管了底层的内存分配。它实现了一个自定义的内存分配器（基于 <code>dlmalloc</code> 的变种），让 GC 能直接操作<strong>内存块 (Chunk)</strong>，而不是仅仅操作对象指针。</li>
<li><strong>全并行/并发架构</strong>：
<ul>
<li><strong>Parallel Marking</strong>：多线程并行标记。</li>
<li><strong>Parallel Sweeping</strong>：多线程并行清除（比我的更进一步，直接操作内存段）。</li>
<li><strong>Parallel Free List Rebuilding</strong>：多线程重建空闲链表，为下一次分配做准备。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-5">2. 关键组件与实现细节</h3>
<p>我在 <code>docs/reference</code> 中深入研究了它的源码，梳理出了以下几个关键组件：</p>
<h4 data-id="heading-6">A. 收集器 (Collector) —— 总指挥</h4>
<p>负责协调 GC 的全流程：</p>
<ol>
<li><code>MarkLiveObjects()</code>: 启动多线程标记活对象。</li>
<li><code>SweepDeadObjects()</code>: 启动多线程清除死对象。
同时包含了大量用于调试内存泄漏和性能分析的工具宏 (<code>ENABLE_GC_DEBUG_TOOLS</code>)。</li>
</ol>
<h4 data-id="heading-7">B. 访问者 (Visitor) —— 遍历引擎</h4>
<p>负责遍历对象图，核心优化在于：</p>
<ul>
<li><strong>多线程队列</strong>：<code>Queue *queue[THREAD_NUM]</code>。每个线程有一个<strong>独立的任务队列</strong>。这与我的全局栈形成了鲜明对比，配合<strong>工作窃取 (Work Stealing)</strong> 算法，大幅减少了锁竞争。</li>
<li><strong>类型分发</strong>：通过 <code>ALLOC_TAG</code>（分配标签）来区分对象类型（如 <code>JSObject</code>, <code>JSString</code>），然后通过 switch-case 调用不同的 Visit 函数。</li>
</ul>
<h4 data-id="heading-8">C. 清扫器 (Sweeper) —— 最精彩的部分</h4>
<p>这是 PrimJS 与普通 GC 最大的区别所在：</p>
<ul>
<li><strong>直接操作内存页 (Segments)</strong>：它不像普通 GC 那样遍历“对象链表”，而是直接遍历底层的<strong>内存段</strong>。通过地址计算直接找到 Chunk Header，判断 <code>cinuse</code> (是否在使用) 和 <code>is_marked</code> (是否标记)。</li>
<li><strong>并行清除 (Parallel Sweep)</strong>：<code>parallel_traverse_heap_segment</code> 函数将堆内存切分成多个段，分发给线程池 (<code>ByteThreadPool</code>) 并行处理。我的 Sweep 是主线程摘链表+后台单线程释放，而 PrimJS 是<strong>多线程推土机式地平推内存页</strong>。</li>
<li><strong>重建 FreeList</strong>：GC 后，它会并行地将回收的内存块重新挂载到 <code>freelist</code> 上，供下一次 <code>malloc</code> 使用。</li>
</ul>
<h2 data-id="heading-9">三、 差距分析 (Gap Analysis)</h2>
<p>通过详细对比，我整理了如下表格，清晰地展示了 cilly-vm-cpp 与 PrimJS 的技术差距：</p>















































<table><thead><tr><th align="left">特性</th><th align="left">你的 cilly-vm-cpp</th><th align="left">PrimJS</th><th align="left">评价</th></tr></thead><tbody><tr><td align="left"><strong>内存管理</strong></td><td align="left">依赖 C++ <code>new/delete</code></td><td align="left">自研分配器 (<code>dlmalloc</code> 魔改)</td><td align="left">PrimJS 更底层，能控制内存布局，减少碎片，但实现难度极高，且跨平台维护成本巨大。</td></tr><tr><td align="left"><strong>标记算法</strong></td><td align="left">全局栈 + 互斥锁</td><td align="left">本地队列 + 工作窃取</td><td align="left">PrimJS 的扩展性更好。全局锁在核心数增多时会成为瓶颈，而本地队列能实现线性扩展。</td></tr><tr><td align="left"><strong>清除算法</strong></td><td align="left">主线程摘除 + 后台单线程 delete</td><td align="left">多线程并行遍历内存段</td><td align="left">PrimJS 吞吐量更大，适合 GB 级超大堆；我的方案适合中小型堆，实现简单且有效。</td></tr><tr><td align="left"><strong>对象识别</strong></td><td align="left">C++ 虚函数 (<code>Trace</code>)</td><td align="left"><code>AllocTag</code> + <code>switch-case</code></td><td align="left">虚函数有间接调用开销；Tag 分发极快，但代码耦合度极高，每加一个类型都要改核心代码。</td></tr><tr><td align="left"><strong>线程模型</strong></td><td align="left">临时创建/销毁 (Fork-Join)</td><td align="left">常驻线程池 (Thread Pool)</td><td align="left">临时创建线程有昂贵的系统调用开销和冷启动问题；线程池响应极快。</td></tr><tr><td align="left"><strong>Finalizer</strong></td><td align="left">C++ 析构函数</td><td align="left">显式 <code>Finalizer</code> 类</td><td align="left">C++ 析构函数符合 RAII 惯例；PrimJS 需要手动管理资源生命周期，更复杂但更灵活。</td></tr></tbody></table>
<h2 data-id="heading-10">四、 下一步改进计划 (Action Plan)</h2>
<p>看完 PrimJS 的源码，我决定对我的 VM 进行“取其精华，去其糟粕”的升级。我不会盲目照搬，而是选择最适合我这个学习型项目的优化路线。</p>
<h3 data-id="heading-11">1. 必须做 (Must Do)：引入线程池 (Thread Pool)</h3>
<p>我目前的做法是每次 GC 都 <code>new thread</code>，结束后 <code>join</code>。这简直是把线程当“日结临时工”用。
<strong>改进</strong>：实现一个简单的线程池。VM 启动时创建好 Worker 线程，平时挂起（Wait），GC 时唤醒（Notify）。这将消除线程创建销毁的系统开销，显著提升响应速度。</p>
<h3 data-id="heading-12">2. 必须做 (Must Do)：实现本地队列与工作窃取</h3>
<p>全局锁是我目前最大的性能瓶颈。
<strong>改进</strong>：拆掉 <code>global_work_stack_</code>，换成 <code>vector&lt;GcObject*&gt; local_queues[THREAD_NUM]</code>。</p>
<ul>
<li><strong>Push/Pop 无锁化</strong>：线程优先操作自己的队列，完全不需要加锁。</li>
<li><strong>Work Stealing</strong>：只有当自己队列空了，才去尝试窃取其他线程的任务。
这是提升并行效率的关键一步。</li>
</ul>
<h3 data-id="heading-13">3. 保留 (Keep)：坚持用虚函数 Trace</h3>
<p>PrimJS 用 switch-case 是为了榨干最后 1% 的 CPU 性能，牺牲了代码的可维护性。
<strong>决策</strong>：我选择<strong>保留虚函数</strong>。作为一个学习型项目，代码的清晰、优雅和可扩展性更重要。我不想为了那一点点性能，把代码写成一坨难以维护的 switch-case。</p>
<h3 data-id="heading-14">4. 学习但暂不落地 (Learn)：内存分配器</h3>
<p>PrimJS 直接操作内存页的设计非常惊艳，但这属于“屠龙技”。
<strong>决策</strong>：我现在学到了它的思想（内存连续性、缓存局部性），但暂时不去碰 <code>malloc</code> 魔改。除非哪天我真的想挑战 OS 级别的开发，否则 <code>new/delete</code> 配合后台释放对于当前量级的 VM 来说已经足够快了。</p>
<hr/>
<p>做系统开发就是这样，<strong>没有绝对最好的架构，只有最适合的 Trade-off</strong>。PrimJS 选择了极致的掌控，而 cilly-vm-cpp 选择了适度的性能与优秀的架构。通过这次深度复盘，我不仅看清了差距，更明确了进化的方向。下一步，开始搓线程池！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OSI参考模型&&TCP/IP模型]]></title>    <link>https://juejin.cn/post/7603671627000561704</link>    <guid>https://juejin.cn/post/7603671627000561704</guid>    <pubDate>2026-02-07T14:24:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603671627000561704" data-draft-id="7603671627000545320" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OSI参考模型&amp;&amp;TCP/IP模型"/> <meta itemprop="keywords" content="网络协议"/> <meta itemprop="datePublished" content="2026-02-07T14:24:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="任白"/> <meta itemprop="url" content="https://juejin.cn/user/2760202790907948"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OSI参考模型&amp;&amp;TCP/IP模型
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2760202790907948/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    任白
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T14:24:18.000Z" title="Sat Feb 07 2026 14:24:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">OSI参考模型&amp;&amp;TCP/IP模型</h2>
<p>在计算机网络领域，OSI 参考模型与 TCP/IP 模型是两个至关重要的概念。它们为网络通信提供了标准的框架和协议，使得全球范围内的计算机能够进行开放式通信。本文将从概念、层次结构、功能特点以及应用等方面，对 OSI 参考模型与 TCP/IP 协议进行深入解析。</p>
<h3 data-id="heading-1">总体结构</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff60128396bd44f99291cbf3ab3a129a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=ejhadZK0YsXsI70jNRkJxIaSZD8%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">OSI参考模型</h3>
<p>在 OSI 参考模型中，总共有 7 层，自下而上分别是<strong>物理层</strong>、<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong>、<strong>会话层</strong>、<strong>表示层</strong>、<strong>应用层</strong>。</p>
<h3 data-id="heading-3">具体设备的对应层次</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e34b861ed2348ba8c6ebbfd1859d59d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=9QgxZVs27JFubhQ%2F5BXKoDsfi4U%3D" alt="" loading="lazy"/></p>
<p>主机实现了七层所有的功能，集线器实现物理层所要实现的功能，交换机要实现物理层和数据链路层所要实现的功能，路由器实现了物理层、数据链路层、网络层的功能。各个节点之间通过物理传输媒体（网线、光纤等）相连接，我们将物理传输媒体视为第 0 层。接下来我们需要研究 OSI 参考模型中每一层的具体作用。</p>
<h3 data-id="heading-4">物理层</h3>
<p>物理层的传输单位是<strong>比特</strong>，任务是<strong>在物理介质上为数据端设备透明地传输原始比特流</strong>。简单来说就是实现<strong>相邻节点</strong>的比特流传输。</p>
<p>我们知道，两个节点之间需要通过物理传输媒体（<strong>网线、光纤等</strong>）进行连接，节点与节点连接好之后，它们之间要传输数据，首先要解决的第一个问题就是<strong>如何实现两个节点的比特传输？</strong></p>
<p>为了实现比特传输，物理层需要定义电路接口的参数，比如说：网线的接口长什么样子、什么形状、里面有几个针脚。这些接口的参数需要由物理层进行定义。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/acbc056e025f416f86e29bbcf37e95f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=zV1rZGfyypOaWS4NqLj5gyae6vw%3D" alt="" loading="lazy"/></p>
<p>以同轴电缆实现比特传输为例，物理层协议会对传输信号的含义、电气特征做出明确规范：若接收到 5V 高电平信号，即代表二进制 1；若接收到 1V 低电平信号，即代表二进制 0。同时，协议中还会规定每比特电信号的持续时长，比如 5V 高电平信号持续 0.1ms，判定为传输比特 1；1V 低电平信号持续 0.1ms，判定为传输比特 0。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fe8c78168f548ff97a379defd29d632~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=f4wktcwnairbzAZr2NTEAVRNqww%3D" alt="" loading="lazy"/></p>
<p>接下来我们思考一个问题，物理层在传输电信号时很容易受到外界影响，可能导致电信号变形，例如，一个高电平电压受到环境影响后变成了低电平电压，这样的话，发送方发送**“1”<strong>的电信号，接收方会受到</strong>“0”**的电信号，并且接收方无法得知数据是否错误，那么我们该怎么保证在传输过程中电信号的准确性呢？<strong>我们引入数据链路层来解决这个问题。</strong></p>
<h3 data-id="heading-5">数据链路层</h3>
<p>数据链路层的传输单位是帧，任务是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/667b4d82c0314084b946a8c1a8c3b38e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=YbNoSmothhNi8f4zWdkFB6MZJZk%3D" alt="" loading="lazy"/></p>
<p>包含以下功能：</p>
<ol>
<li>
<p>差错控制：检查和纠错</p>
</li>
<li>
<p>流量控制：协调两个<strong>相邻节点间</strong>的速率</p>
</li>
</ol>
<p>数据链路层以帧为传输单位，会在原始数据（如 8bit）中添加<strong>校验比特</strong>（如 2bit），整合后交给物理层传输。接收方链路层会通过校验比特检错，有错则纠错或要求重发，无误则剥离校验比特，将原始数据交给网络层。链路层还具备流量控制功能，可协调相邻节点帧传输速率，避免接收方处理不及。</p>
<p>至此，物理层（第 1 层）、数据链路层（第 2 层）已能实现两个相邻节点之间的无差错数据传输。但在实际计算机网络中，大多数节点之间并不会直接相连，往往需要经过多个路由器的存储转发，才能将数据从源节点成功传递到目的节点。为了实现这种跨多个节点的数据存储转发功能，我们需要在数据链路层之上，额外增加一层——网络层，专门负责解决不同节点之间的路由选择与数据转发问题。</p>
<h3 data-id="heading-6">网络层</h3>
<p>网络层的传输单位是<strong>数据报</strong>，任务是将网络层的协议数据单元（分组）从源主机传输到目的主机，为<strong>分组交换网上点的不同主机提供通信服务</strong>。</p>
<p>包含以下功能：</p>
<ol>
<li>
<p>路由选择：构造并维护路由表，决定分组到达目的节点的最佳路径。</p>
</li>
<li>
<p>分组转发：将“分组”从合适的端口转发出去。</p>
</li>
<li>
<p>拥塞控制：发现网络拥堵，并采取缓解措施。</p>
</li>
<li>
<p>网际互连：实现异构网络互联（解释：简单来说，路由器的功能是将多个计算机网络连接在一起，但这些被连接的网络，内部构造各不相同，所采用的局域网技术也不一样——比如有的网络用的是以太网技术，有的则用的是令牌环网技术。而无论这些网络的内部结构、采用的技术有多大差异，只要经过路由器网络层的处理，就能把这些内部差异全部屏蔽掉，最终实现不同类型网络之间的正常互联和数据通信。）</p>
</li>
<li>
<p>其他功能：差错控制，流量控制，连接的建立与释放，可靠传输管理。</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d97709220f04a8f96611ac5ee769b6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=kjMNiA7AFYilU9puAEvKAeU5LIg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-7">传输层</h3>
<p>网络层实现主机到主机的数据分组转发，但一台主机会运行多个进程，数据传到目标主机后，还需区分收发对应的进程，因此在网络层之上增设传输层。</p>
<p>传输层的核心是实现 <strong>端到端（进程到进程）</strong> 的通信服务（这里的 “端” 指端口），为主机间的进程通信提供通用数据传输能力，各类网络应用均可共用该服务，无需针对特定应用单独设计。</p>
<p>包含以下功能：</p>
<ol>
<li>
<p><strong>分用和复用</strong>：<strong>复用</strong>是多个应用层进程可同时使用传输层的服务；<strong>分用</strong>则是传输层将接收到的信息，分别交付给应用层对应的进程，再由应用进程处理应用层报文。</p>
</li>
<li>
<p>其他功能：差错控制，流量控制，连接的建立与释放，可靠传输管理。</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7420cb9ff2948fc82683cbd3e399206~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=TIK6zv6Tg8IkgP1nJXmHo7XvDTg%3D" alt="" loading="lazy"/></p>
<p>传输层之间是以报文段为单位传输数据，一个报文段可能会被拆分为多个分组， 源节点的网络层会将这些分组发送给目的节点，最后再由目的节点的网络层把这些分组拼凑成完整的报文段，交付给目的节点的传输层。</p>
<h3 data-id="heading-8">会话层</h3>
<p><strong>核心任务</strong>：专门负责管理网络中不同主机上进程之间的通信会话，保障进程间通信的有序性、连续性，避免因异常中断导致通信数据丢失或重传浪费。</p>
<p><strong>主要功能</strong>：核心为<strong>会话管理</strong>，其中最关键的是检查点恢复机制。该机制会在通信过程中按规则记录数据传输的关键节点（检查点），若通信因网络中断、设备故障等原因失效，无需从头开始传输数据，恢复连接后可直接从最近的检查点继续后续传输，大幅提升通信效率。</p>
<p><strong>实际举例</strong>：主机 A 通过微信向主机 B 发送 1GB 的视频文件时，会话层会全程管控该传输会话。若视频传输至 500MB 时突发网络中断，会话层会立即在 500MB 这个位置记录检查点；当网络恢复、两台主机的通信进程重新建立连接后，视频不会从 0MB 重新发送，而是直接从 500MB 的检查点继续传输剩余内容。</p>
<h3 data-id="heading-9">表示层</h3>
<p><strong>核心任务</strong>：解决不同主机之间信息表示格式不一致的问题，统一通信双方的数据表达形式，让异构主机能正确识别、解析彼此传输的数据，是通信双方的 “数据翻译官”。</p>
<p><strong>主要功能</strong>：以<strong>数据格式转换</strong>为核心，同时涵盖数据压缩 / 解压、加密 / 解密等配套功能。数据格式转换包含编码格式转换、数据格式标准化等；压缩 / 解压可减小数据传输体积，提升传输速度；加密 / 解密则保障数据在传输过程中的安全性，防止信息泄露。</p>
<p><strong>实际举例</strong>：不同主机的系统可能采用不同的字符编码格式，若主机 A 的编码格式为 GBK，主机 B 为 UTF-8，同一个汉字在两台主机中被转换的二进制编码会完全不同 —— 主机 A 发送的汉字二进制数据，直接传到主机 B 后会出现乱码，这就是典型的信息表示不一致问题。此时表示层会介入处理：主机 A 的表示层先将 GBK 编码的二进制数据转换为双方约定的统一编码格式，再传输至主机 B；主机 B 的表示层接收到数据后，再将其转换为自身可识别的 UTF-8 编码，最终让主机 B 正确显示对应的汉字，解决乱码问题。</p>
<h3 data-id="heading-10">应用层</h3>
<p><strong>核心任务</strong>：直接为用户或应用程序提供特定的网络应用服务，是 OSI 参考模型中最贴近用户的一层，所有用户可见的网络功能都由应用层实现。</p>
<p><strong>主要功能</strong>：功能无统一固定标准，完全根据实际网络应用的需求进行设计和开发，种类繁多且随网络技术发展不断拓展。凡是依托网络实现的具体应用功能，都对应应用层的相关协议和服务。</p>
<p><strong>常见举例</strong>：日常使用的网页浏览（对应 HTTP/HTTPS 协议）、文件传输（FTP 协议）、电子邮件收发（SMTP/POP3 协议）、即时通讯（微信、QQ 的专属应用层协议）、域名解析（DNS 协议）等，都是应用层实现的典型网络应用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51402382f4a045819cfd211cc9a00f2d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=0DF4EIklFv7Z3AfGM%2BusB3FJJ3k%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11">TCP/IP模型</h2>
<h3 data-id="heading-12">结构</h3>
<p>TCP/IP 模型是一个<strong>四层</strong>网络架构模型，由美国国防部高级研究计划局（ARPA）在 20 世纪 70 年代为 ARPANET（互联网前身）所设计。它基于一系列核心协议（如 TCP 和 IP），并因互联网的全球普及而成为实际上的工业标准。与 OSI 模型的<strong>理论分层</strong>不同，TCP/IP 模型更侧重于<strong>实践和协议实现。</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa780f11589b4a9fac88e7fffe18e519~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=VeTPAws%2BeQBN%2BvvtO8YqwMDfnII%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">网络接口层</h3>
<p>网络接口层是 TCP/IP 模型的最底层，对应 OSI 参考模型的物理层和数据链路层，传输单位是帧，核心任务是负责将网络层传递下来的分组（数据报）封装成帧，通过物理传输媒体实现相邻设备之间的帧传输，同时接收来自物理介质的帧，剥离帧头部信息后，将核心数据（分组）交给网络层。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4fa7db72c7e240c594023a9a7f0771cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=YXon7q%2F0FXfhbi0tewPbUuhYTIQ%3D" alt="" loading="lazy"/></p>
<p>这里我们思考一个问题：网络接口层只能实现相邻设备之间的帧传输，无法跨越多个网络（如局域网与广域网）传递数据——比如一台家用电脑（局域网内）要向互联网上的服务器发送数据，中间需要经过路由器、交换机等多个设备，此时仅靠网络接口层的帧传输无法完成，因此需要引入网络层，解决跨网络的数据转发问题。</p>
<h3 data-id="heading-14">网络层</h3>
<p>网络层是 TCP/IP 模型的核心层次，对应 OSI 参考模型的网络层，传输单位是分组（也称为数据报），核心任务是实现跨网络（异构网络）的分组转发，将源主机的分组通过多个路由器的存储转发，最终传递到目的主机，为主机与主机之间（跨网络）的通信提供基础服务。</p>
<p><strong>包含以下功能：</strong></p>
<ol>
<li>
<p>IP 寻址：为互联网中的每一台主机分配唯一的 IP 地址（IPv4 或 IPv6），作为主机的身份标识，确保分组能够准确识别源主机和目的主机。IP 地址就像是主机的“网络身份证”，例如家用电脑的 IP 地址可能是 192.168.1.100，互联网服务器的 IP 地址可能是 203.0.113.10，分组通过 IP 地址才能找到对应的目的主机。</p>
</li>
<li>
<p>路由选择：路由器会构造并维护路由表，路由表中记录了不同网络的可达路径、路径优先级、下一跳路由器地址等信息。当路由器接收到分组时，会根据分组中的目的 IP 地址，查询路由表，选择一条最优路径，将分组转发到下一跳路由器，直至分组到达目的主机所在的网络。</p>
</li>
<li>
<p>分组转发：这是网络层的核心操作，路由器接收来自上层（传输层）或其他路由器的分组后，解析分组头部的目的 IP 地址，结合路由表确定转发端口，将分组转发出去。转发过程中，路由器仅修改分组的物理地址（MAC 地址），不修改 IP 地址和分组的数据内容。</p>
</li>
<li>
<p>拥塞控制：当网络中分组数量过多，超过路由器或链路的处理能力时，会出现网络拥塞（导致分组延迟、丢失）。网络层通过丢弃部分分组、调整转发速率等简单方式，缓解拥塞，保障网络的基本传输效率（TCP/IP 模型中，更精细的拥塞控制主要由传输层负责）。</p>
</li>
<li>
<p>网际互连：实现异构网络的互联，例如将以太网（局域网）、广域网（如光纤网络）、无线网络等不同类型的网络连接在一起。路由器的网络层能够屏蔽不同底层网络的差异（如帧格式、传输介质不同），通过 IP 协议统一封装分组，实现不同网络之间的正常数据通信。</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7be1235dbc9d491289b9928c0eb85073~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=gJJ19sQF23l6SZAhTiim%2FJf%2BdlM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-15">传输层</h3>
<p>传输层对应 OSI 参考模型的传输层，位于网络层之上、应用层之下，传输单位是报文段（TCP 协议）或用户数据报（UDP 协议），核心任务是在网络层“主机到主机”通信的基础上，实现“端到端（进程到进程）”的可靠或不可靠通信，为主机上的不同应用进程提供独立的通信通道，屏蔽网络层的传输差异。</p>
<p>我们知道，网络层只能将分组传递到目的主机，但一台主机上会同时运行多个应用进程（如同时打开浏览器、微信、QQ），分组到达目的主机后，需要明确“交给哪个应用进程处理”——传输层通过“端口”解决这个问题：每个应用进程对应一个唯一的端口号（1-65535），分组到达后，传输层根据端口号，将数据分发给对应的应用进程，这就是“进程到进程”的通信。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b29f339dee544909504df1704b1b91c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=gNn4ZiuJyE3TB3ozZhanjgCyxZU%3D" alt="" loading="lazy"/></p>
<p><strong>包含以下功能：</strong></p>
<ol>
<li>
<p>分用和复用：复用是指多个应用层进程可以同时使用传输层的服务，传输层会为每个进程分配独立的端口号，将不同进程的数据封装成不同的报文段 / 用户数据报，统一交给网络层传输；分用是指传输层接收来自网络层的分组后，解析分组中的端口号，将数据分别交付给应用层对应的进程。</p>
</li>
<li>
<p>可靠传输（TCP 协议专属）：TCP 协议通过确认机制、重传机制、排序机制、流量控制、拥塞控制等，确保数据能够准确、有序、无丢失地从源进程传输到目的进程。例如，发送方发送报文段后，会等待接收方的确认消息；若超时未收到确认，会重新发送该报文段；接收方会对收到的报文段进行排序，丢弃重复的报文段，确保数据的有序性。</p>
</li>
<li>
<p>不可靠传输（UDP 协议专属）：UDP 协议不提供可靠传输，仅负责将应用层的数据封装成用户数据报，交给网络层传输，不进行确认、不重传、不排序，传输效率高，适合对实时性要求高、允许少量数据丢失的场景（如视频通话、语音通话、广播）。</p>
</li>
<li>
<p>流量控制：协调源进程和目的进程的数据传输速率，避免目的进程处理速度跟不上源进程的发送速度，导致数据堆积、丢失。TCP 协议通过滑动窗口机制实现流量控制，UDP 协议不提供流量控制。</p>
</li>
<li>
<p>连接的建立与释放（TCP 协议专属）：TCP 协议是面向连接的协议，通信前需要通过“三次握手”建立连接，确保双方通信就绪；通信结束后，通过“四次挥手”释放连接，释放系统资源；UDP 协议是无连接协议，通信前无需建立连接，通信结束后无需释放连接。</p>
</li>
</ol>
<h3 data-id="heading-16">应用层</h3>
<p>应用层是 TCP/IP 模型的最上层，对应 OSI 参考模型的会话层、表示层、应用层，核心任务是直接为用户或应用程序提供特定的网络应用服务，是 TCP/IP 模型中最贴近用户的一层，所有用户可见的网络功能，都由应用层实现。</p>
<p>与 OSI 模型将会话、表示、应用功能分开不同，TCP/IP 模型将这三层的功能整合到应用层中，简化了协议设计——应用层无需关注底层的传输细节（如如何分组、如何转发、如何保证可靠传输），只需调用传输层提供的服务，实现具体的网络应用功能即可。应用层的协议都是针对具体应用设计的，种类繁多，随网络技术的发展不断拓展。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/caa329fd7740416da3ec0407c07522d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=pHdRxLiad4tGz6z22iRgS8rzSmI%3D" alt="" loading="lazy"/></p>
<p>补充说明：应用层的所有数据，都会交给传输层（TCP 或 UDP 协议）进行封装，再依次经过网络层、网络接口层的封装，最终通过物理介质传输；接收方则从底层到上层，依次剥离各层的封装头部，最终将数据交给应用层的对应进程，完成一次完整的网络通信。</p>
<h2 data-id="heading-17">总结</h2>
<p>OSI 参考模型是由国际标准化组织（ISO）制定的理论化七层协议模型（自下而上为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），核心定位是为全球异构网络提供统一的通信规范和理论框架，层次划分细致、功能定义严谨，涵盖了从物理比特传输到应用服务的全流程，但其结构复杂、实现成本高，仅作为理论参考，未在实际网络中广泛应用；TCP/IP 模型源于 ARPAnet 项目，是实用化的四层协议模型（自下而上为网络接口层、网络层、传输层、应用层），核心定位是解决实际网络互联问题，整合了 OSI 模型中会话层、表示层的功能，虽非国际标准，但因其简洁高效、兼容性强，成为全球互联网的实际执行标准，两者核心对应关系明确：TCP/IP 模型的网络接口层对应 OSI 的物理层与数据链路层（负责帧和比特传输），网络层（核心 IP 协议）、传输层（TCP/UDP 协议）分别对应 OSI 的同名层次，应用层则涵盖了 OSI 会话层、表示层、应用层的全部应用服务功能。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Pinia必学4大核心API：$patch/$reset/$subscribe/$onAction，用法封神！]]></title>    <link>https://juejin.cn/post/7603673564908322851</link>    <guid>https://juejin.cn/post/7603673564908322851</guid>    <pubDate>2026-02-07T15:01:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603673564908322851" data-draft-id="7602991346585255970" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Pinia必学4大核心API：$patch/$reset/$subscribe/$onAction，用法封神！"/> <meta itemprop="keywords" content="JavaScript,面试,Vue.js"/> <meta itemprop="datePublished" content="2026-02-07T15:01:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="boooooooom"/> <meta itemprop="url" content="https://juejin.cn/user/3078273283917399"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Pinia必学4大核心API：$patch/$reset/$subscribe/$onAction，用法封神！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3078273283917399/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    boooooooom
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T15:01:26.000Z" title="Sat Feb 07 2026 15:01:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;color:#3c9dff}.markdown-body h1{font-size:30px;margin-bottom:5px;padding-bottom:8px;text-align:center}.markdown-body h2{font-size:24px;padding-bottom:6px}.markdown-body h2:before{content:"🍋"}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h3:before{content:"🍓"}.markdown-body h4{font-size:16px}.markdown-body h4:before{content:"🍑"}.markdown-body h5{font-size:15px}.markdown-body h5:before{content:"🍉"}.markdown-body h6{margin-top:5px}.markdown-body h6:before{content:"🍒"}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;margin:0 auto;max-width:100%;border-radius:4px;padding:1px;border:1px solid #d2e8ff}.markdown-body img:hover{box-shadow:0 1px 3px #5eaeff}.markdown-body hr{height:4px;margin:34px 0;background-size:4px 1px;background-image:linear-gradient(270deg,#5eaeff,#f3f9ff 25%,transparent 50%);border-style:none}.markdown-body code{word-break:break-word;border-radius:3px;overflow-x:auto;background-color:#d2e8ff;color:#3c9dff;font-size:.9em;padding:.1em .5em;margin:0 3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;transition:all .3s}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:1px solid #90c7ff;border-radius:4px}.markdown-body pre:hover{box-shadow:0 1px 10px #beddff}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#3c9dff;border-bottom:1px solid #90c7ff;transition:all .3s}.markdown-body a:hover{color:#007fff;border-bottom:2px solid #5eaeff}.markdown-body a[href]:not(:empty){padding-right:18px}.markdown-body a[href]:not(:empty):after{display:inline-block;width:16px;height:16px;margin-left:2px;content:"";background:url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxwYXRoIGQ9Ik0zODQgMTI4YTQ4IDQ4IDAgMDEyLjgxNiA5NS45MkwzODQgMjI0SDI1NmEzMiAzMiAwIDAwLTMxLjkyIDI5LjZMMjI0IDI1NnY1MTJhMzIgMzIgMCAwMDI5LjYgMzEuOTJsMi40LjA4aDUxMmEzMiAzMiAwIDAwMzEuOTItMjkuNmwuMDgtMi40VjY1NmE0OCA0OCAwIDAxOTUuOTItMi44MTZMODk2IDY1NnYxMTJhMTI4IDEyOCAwIDAxLTEyNCAxMjcuOTM2bC00IC4wNjRIMjU2YTEyOCAxMjggMCAwMS0xMjcuOTM2LTEyNGwtLjA2NC00VjI1NmExMjggMTI4IDAgMDExMjQtMTI3LjkzNmw0LS4wNjRoMTI4em0zODQgMGExMjggMTI4IDAgMDExMjcuOTM2IDEyNGwuMDY0IDR2MTYwYTQ4IDQ4IDAgMDEtOTUuOTIgMi44MTZMODAwIDQxNlYyOTEuODcybC0zODIuMDY0IDM4Mi4wOGE0OCA0OCAwIDAxLTcwLjAzMi02NS42bDIuMTYtMi4yODhMNzMyLjA5NiAyMjRINjA4YTQ4IDQ4IDAgMDEtMi44MTYtOTUuOTJMNjA4IDEyOGgxNjB6IiBmaWxsPSIjM2M5ZGZmIiBmaWxsLW9wYWNpdHk9Ii41NiIgZGF0YS1zcG0tYW5jaG9yLWlkPSJhMzEzeC5zZWFyY2hfaW5kZXguMC5pMC41Yzc1M2E4MTgwa2RKWCIgY2xhc3M9InNlbGVjdGVkIi8+PC9zdmc+);background-size:100%}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #3c9dff}.markdown-body thead{text-align:center}.markdown-body thead th{color:#fff;background-color:#5eaeff}.markdown-body tr{text-align:center}.markdown-body tbody tr:hover{background-color:#d2e8ff}.markdown-body tbody tr:hover code{background-color:#90c7ff}.markdown-body tr:nth-child(2n){background-color:#ecf5ff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5eaeff}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{font-weight:900;padding:0 1px;font-size:17px}.markdown-body small{color:#cbcbcb;padding:0 1px;font-size:22px;zoom:.5}.markdown-body em{padding:0 1px}.markdown-body del{padding:0 1px;text-decoration-thickness:2px}.markdown-body blockquote{color:#1a1b1c;padding:1px 20px;margin:22px 0;border-radius:4px;border-left:4px solid rgba(60,157,255,.5);background-color:rgba(190,221,255,.3)}.markdown-body blockquote blockquote{margin:8px 0}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{margin:12px 0;padding:4px 10px;border:2px solid #3c9dff;border-radius:8px;background-color:#ecf5ff;transition:all .3s}.markdown-body details summary{cursor:pointer}.markdown-body input[type=checkbox]{position:relative;appearance:none;width:16px;height:16px;border-radius:2px;vertical-align:middle;transform:translateY(-2px);box-sizing:border-box;border:1px solid #beddff}.markdown-body input[type=checkbox]:checked{border:1px solid #5eaeff;background-color:#5eaeff}.markdown-body input[type=checkbox]:checked:before{position:absolute;top:3px;left:1px;width:11px;height:6px;background-color:transparent;border-left:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(-45deg);content:"";box-sizing:border-box}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="androidstudio">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#a9b7c6;background:#282b2e}.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#6897bb}.hljs-deletion,.hljs-keyword,.hljs-selector-tag{color:#cc7832}.hljs-link,.hljs-template-variable,.hljs-variable{color:#629755}.hljs-comment,.hljs-quote{color:grey}.hljs-meta{color:#bbb529}.hljs-addition,.hljs-attribute,.hljs-string{color:#6a8759}.hljs-section,.hljs-title,.hljs-type{color:#ffc66d}.hljs-name,.hljs-selector-class,.hljs-selector-id{color:#e8bf6a}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">正文</h2>
<h3 data-id="heading-1">一、前言：为什么要吃透这4个核心API？</h3>
<p>学会Pinia的Setup Store和Option Store基础写法后，想要真正灵活运用Pinia、应对复杂状态管理场景，就必须掌握它的四大核心实例API——<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mtext>、</mtext></mrow><annotation encoding="application/x-tex">patch、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">、</span></span></span></span></span>reset、<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mtext>、</mtext></mrow><annotation encoding="application/x-tex">subscribe、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">、</span></span></span></span></span>onAction。</p>
<p>这4个API贯穿Pinia开发全流程：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mtext>批量修改状态、</mtext></mrow><annotation encoding="application/x-tex">patch批量修改状态、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">批量修改状态、</span></span></span></span></span>reset重置状态、<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mtext>监听状态变化、</mtext></mrow><annotation encoding="application/x-tex">subscribe监听状态变化、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">监听状态变化、</span></span></span></span></span>onAction监听方法执行，覆盖“修改-重置-监听”三大核心需求。</p>
<p>很多开发者用Pinia只停留在基础写法，忽略了这4个API的强大功能，导致代码冗余、状态管理混乱。本文聚焦四大API，从“用法+案例+避坑”三维度拆解，全程结合Vue3 + TS实操，看完直接套用。</p>
<h3 data-id="heading-2">二、前置准备：统一Store实例（两种写法通用）</h3>
<p>为了让API用法更直观，先定义一个通用的Pinia Store（同时兼容Option Store和Setup Store，后续API用法均基于此实例演示，避免重复）：</p>
<h4 data-id="heading-3">1. Option Store 实例（基础版）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/stores/user.ts（Option Store）</span>
<span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'user'</span>, {
  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> ({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">isLogin</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>]
  }),
  <span class="hljs-attr">getters</span>: {
    <span class="hljs-attr">fullName</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-string">`Mr. <span class="hljs-subst">${state.name}</span>`</span>
  },
  <span class="hljs-attr">actions</span>: {
    <span class="hljs-title function_">setLogin</span>(<span class="hljs-params">status: <span class="hljs-built_in">boolean</span></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isLogin</span> = status
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchUserInfo</span>(<span class="hljs-params"/>) {
      <span class="hljs-comment">// 模拟接口请求</span>
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Pro'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>]
      }), <span class="hljs-number">1000</span>))
      <span class="hljs-variable language_">this</span>.$patch(res) <span class="hljs-comment">// 后续会讲$patch用法</span>
    }
  }
})
</code></pre>
<h4 data-id="heading-4">2. Setup Store 实例（基础版）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/stores/user.ts（Setup Store）</span>
<span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>
<span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'user'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'Pinia'</span>)
  <span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">3</span>)
  <span class="hljs-keyword">const</span> isLogin = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> roles = <span class="hljs-title function_">ref</span>([<span class="hljs-string">'user'</span>])

  <span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`Mr. <span class="hljs-subst">${name.value}</span>`</span>)

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setLogin</span> = (<span class="hljs-params">status: <span class="hljs-built_in">boolean</span></span>) =&gt; {
    isLogin.<span class="hljs-property">value</span> = status
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUserInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Pro'</span>,
      <span class="hljs-attr">age</span>: <span class="hljs-number">4</span>,
      <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>]
    }), <span class="hljs-number">1000</span>))
    <span class="hljs-comment">// Setup Store 中$patch用法与Option Store一致</span>
    <span class="hljs-title function_">useUserStore</span>().$patch({
      <span class="hljs-attr">name</span>: res.<span class="hljs-property">name</span>,
      <span class="hljs-attr">age</span>: res.<span class="hljs-property">age</span>,
      <span class="hljs-attr">roles</span>: res.<span class="hljs-property">roles</span>
    })
  }

  <span class="hljs-keyword">return</span> {
    name, age, isLogin, roles,
    fullName,
    setLogin, fetchUserInfo
  }
})
</code></pre>
<p>关键说明：以下四大API的用法，<strong>完全适用于两种Store写法</strong>，仅Setup Store中操作ref状态时需注意.value，API调用逻辑完全一致，后续不再单独区分。</p>
<h3 data-id="heading-5">三、四大核心API详解（重点！用法+案例+避坑）</h3>
<p>按“修改状态→重置状态→监听状态→监听方法”的逻辑拆解，每个API都包含“核心作用+两种用法+实操案例+避坑点”，确保新手能看懂、会用。</p>
<h4 data-id="heading-6">1. $patch：批量修改状态（高效简洁，首选）</h4>
<h5 data-id="heading-7">核心作用</h5>
<p>用于<strong>批量修改多个状态</strong>，替代多次单独修改状态（如this.name = xxx、this.age = xxx），减少代码冗余，同时优化性能（Pinia会合并多次状态更新，减少组件重渲染）。</p>
<p>适用场景：一次性修改多个state属性（如接口请求后，同步更新多个状态）。</p>
<h5 data-id="heading-8">两种用法（均常用，按需选择）</h5>
<h6 data-id="heading-9">用法1：对象式（简单批量修改，首选）</h6>
<p>核心：传递一个对象，对象中的key对应state的属性名，value对应要修改的值，仅修改对象中包含的属性。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 1. 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 批量修改name、age、isLogin三个状态</span>
userStore.$patch({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Advanced'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,
  <span class="hljs-attr">isLogin</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// 数组类型也可直接修改（覆盖式）</span>
  <span class="hljs-attr">roles</span>: [<span class="hljs-string">'admin'</span>]
})

<span class="hljs-comment">// 2. Option Store 的actions中使用</span>
<span class="hljs-attr">actions</span>: {
  <span class="hljs-title function_">updateUserInfo</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.$patch({ <span class="hljs-comment">// this指向当前Store实例</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Advanced'</span>,
      <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>
    })
  }
}
</code></pre>
<h6 data-id="heading-10">用法2：函数式（复杂修改，如数组操作）</h6>
<p>核心：传递一个函数，函数接收state作为参数，可在函数内部执行复杂的状态修改（如数组push、splice，对象深层修改），比对象式更灵活。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 复杂修改案例：给roles数组添加新角色，同时修改age</span>
userStore.$patch(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
  state.<span class="hljs-property">roles</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'superAdmin'</span>) <span class="hljs-comment">// 数组操作</span>
  state.<span class="hljs-property">age</span> += <span class="hljs-number">1</span> <span class="hljs-comment">// 计算后修改</span>
  <span class="hljs-comment">// 支持深层修改（若state有嵌套对象）</span>
  <span class="hljs-comment">// state.info.address = 'xxx'</span>
})

<span class="hljs-comment">// 对比：若用对象式，数组只能覆盖，无法直接push</span>
userStore.$patch({
  <span class="hljs-attr">roles</span>: [...userStore.<span class="hljs-property">roles</span>, <span class="hljs-string">'superAdmin'</span>] <span class="hljs-comment">// 需手动解构，繁琐</span>
})
</code></pre>
<h5 data-id="heading-11">避坑点</h5>
<ul>
<li>对象式$patch无法修改数组的单个元素（如roles[0] = 'admin'），需用函数式或解构数组；</li>
<li>Setup Store中，若直接在函数内操作ref状态，需用state.name.value（推荐直接用Store实例调用$patch，无需关注.value）。</li>
</ul>
<h4 data-id="heading-12">2. $reset：重置状态（一键恢复初始值）</h4>
<h5 data-id="heading-13">核心作用</h5>
<p>将Store的所有state属性，<strong>一键恢复到初始状态</strong>（即state选项/ref定义时的初始值），无需手动逐个重置，简化逻辑。</p>
<p>适用场景：退出登录、表单重置、页面刷新时，恢复Store初始状态。</p>
<h5 data-id="heading-14">用法（极简，无需复杂配置）</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 一键重置所有状态（name恢复为Pinia，age恢复为3，isLogin恢复为false）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.$reset()
}

<span class="hljs-comment">// Option Store 的actions中使用</span>
<span class="hljs-attr">actions</span>: {
  <span class="hljs-title function_">logout</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLogin</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 先执行自定义逻辑</span>
    <span class="hljs-variable language_">this</span>.$reset() <span class="hljs-comment">// 再重置状态</span>
  }
}
</code></pre>
<h5 data-id="heading-15">避坑点（重点！）</h5>
<ul>
<li>Setup Store中，$reset仅能重置“return中暴露的状态”，未暴露的局部状态无法重置；</li>
<li>若state中有嵌套对象，$reset会深度重置（即嵌套对象也恢复初始值），无需额外处理；</li>
<li>Option Store中，若state是箭头函数返回的对象，$reset才能生效（默认写法，无需担心）。</li>
</ul>
<h4 data-id="heading-16">3. $subscribe：监听状态变化（响应式感知）</h4>
<h5 data-id="heading-17">核心作用</h5>
<p>监听Store中<strong>所有state属性的变化</strong>（单个/多个属性变化均会触发），可获取变化前、变化后的值，用于执行副作用（如日志记录、本地存储同步）。</p>
<p>适用场景：状态变化后执行额外逻辑（如用户信息变化时，同步缓存到localStorage）。</p>
<h5 data-id="heading-18">用法（含配置项，灵活适配场景）</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 监听状态变化</span>
<span class="hljs-keyword">const</span> unsubscribe = userStore.$subscribe(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
  <span class="hljs-comment">// mutation：变化相关信息（核心属性如下）</span>
  <span class="hljs-comment">// mutation.storeId：当前Store的id（如user）</span>
  <span class="hljs-comment">// mutation.type：变化类型（direct：直接修改，patch：$patch修改）</span>
  <span class="hljs-comment">// mutation.payload：变化的内容（对象式$patch为修改对象，函数式为undefined）</span>
  
  <span class="hljs-comment">// state：变化后的最新状态（完整state对象）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'状态变化了'</span>, mutation, state)
  
  <span class="hljs-comment">// 示例：同步状态到localStorage</span>
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'userState'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))
}, {
  <span class="hljs-comment">// 可选配置项（按需开启）</span>
  <span class="hljs-attr">detached</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 默认为false，组件卸载后自动取消监听；true则组件卸载后仍监听</span>
  <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 默认为true，深度监听嵌套对象变化；false则不监听嵌套对象</span>
  <span class="hljs-attr">immediate</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 默认为false，初始化时不触发；true则初始化时立即触发一次</span>
})

<span class="hljs-comment">// 手动取消监听（如组件卸载时）</span>
<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">unsubscribe</span>()
})

<span class="hljs-comment">// Option Store 的actions中使用（较少见，一般在组件中监听）</span>
<span class="hljs-attr">actions</span>: {
  <span class="hljs-title function_">initSubscribe</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.$subscribe(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'状态变化'</span>, state)
    })
  }
}
</code></pre>
<h5 data-id="heading-19">避坑点</h5>
<ul>
<li>忘记手动取消监听（detached为false时，组件卸载会自动取消；detached为true时，需手动取消，否则会内存泄漏）；</li>
<li>deep设为false时，嵌套对象的变化不会触发$subscribe，需根据需求开启；</li>
<li>函数式$patch修改状态时，mutation.payload为undefined，无法获取具体变化内容。</li>
</ul>
<h4 data-id="heading-20">4. $onAction：监听方法执行（全生命周期感知）</h4>
<h5 data-id="heading-21">核心作用</h5>
<p>监听Store中<strong>所有actions方法的执行</strong>，可在方法执行前、执行后、执行报错时触发回调，用于拦截方法、日志记录、错误处理。</p>
<p>适用场景：拦截异步方法（如请求前loading、请求后处理）、记录方法执行日志、捕获方法报错。</p>
<h5 data-id="heading-22">用法（含生命周期回调，常用）</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 监听所有actions方法的执行</span>
<span class="hljs-keyword">const</span> unsubscribe = userStore.$onAction(<span class="hljs-function">(<span class="hljs-params">{
  name, // 当前执行的actions方法名（如fetchUserInfo、setLogin）
  args, // 当前方法的参数数组（如setLogin的参数[<span class="hljs-literal">true</span>]）
  after, // 方法执行成功后触发的回调
  onError // 方法执行失败（报错）时触发的回调
}</span>) =&gt;</span> {
  <span class="hljs-comment">// 1. 方法执行前触发（可做拦截、loading等）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>开始执行，参数：`</span>, args)
  <span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)

  <span class="hljs-comment">// 2. 方法执行成功后触发（可做后续处理）</span>
  <span class="hljs-title function_">after</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行成功，返回值：`</span>, result)
    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  })

  <span class="hljs-comment">// 3. 方法执行失败时触发（可做错误处理）</span>
  <span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行失败，错误：`</span>, error)
    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'操作失败，请重试'</span>)
  })
}, {
  <span class="hljs-comment">// 可选配置项</span>
  <span class="hljs-attr">detached</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 与$subscribe一致，组件卸载后是否继续监听</span>
})

<span class="hljs-comment">// 手动取消监听</span>
<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">unsubscribe</span>()
})

<span class="hljs-comment">// 示例：监听fetchUserInfo异步方法</span>
userStore.<span class="hljs-title function_">fetchUserInfo</span>() <span class="hljs-comment">// 会触发$onAction的所有回调</span>
</code></pre>
<h5 data-id="heading-23">避坑点</h5>
<ul>
<li>$onAction<strong>仅能监听actions中的方法</strong>，Setup Store中未返回的局部函数、组件中的普通函数，无法监听；</li>
<li>异步方法（如fetchUserInfo）中，after回调会在方法执行完成（await结束）后触发，onError捕获await中的报错；</li>
<li>多个方法同时执行时，$onAction会分别触发对应的回调，无需担心混淆。</li>
</ul>
<h3 data-id="heading-24">四、四大API对比总结（一目了然，快速选型）</h3>



































<table><thead><tr><th>API</th><th>核心作用</th><th>适用场景</th><th>关键注意点</th></tr></thead><tbody><tr><td>$patch</td><td>批量修改多个状态</td><td>接口请求后同步更新状态、一次性修改多属性</td><td>函数式适配复杂修改，对象式简洁首选</td></tr><tr><td>$reset</td><td>一键重置所有状态为初始值</td><td>退出登录、表单重置、页面刷新</td><td>Setup Store仅重置暴露的状态</td></tr><tr><td>$subscribe</td><td>监听所有state变化</td><td>状态变化后同步缓存、日志记录</td><td>注意取消监听，避免内存泄漏</td></tr><tr><td>$onAction</td><td>监听actions方法执行（全生命周期）</td><td>异步请求拦截、错误处理、方法日志</td><td>仅监听actions中的方法，不监听局部函数</td></tr></tbody></table>
<h3 data-id="heading-25">五、实战综合案例（四大API联用，贴近真实开发）</h3>
<p>结合“用户信息管理”场景，联用四大API，实现“修改用户信息→监听状态变化→缓存到本地→重置状态→监听方法报错”的完整逻辑，代码可直接复制套用：</p>
<pre><code class="hljs language-ts" lang="ts">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"user-manager"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>用户信息管理<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{{ userStore.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ userStore.age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>角色：{{ userStore.roles.join(',') }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"updateUser"</span>&gt;</span>修改用户信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"resetUser"</span>&gt;</span>重置用户信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"fetchUser"</span>&gt;</span>获取用户信息（异步）<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>
<span class="hljs-keyword">import</span> { onUnmounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 1. 监听状态变化，同步到localStorage</span>
<span class="hljs-keyword">const</span> unsubscribeSub = userStore.$subscribe(<span class="hljs-function">(<span class="hljs-params">_, state</span>) =&gt;</span> {
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'userState'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))
  <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'用户状态已同步缓存'</span>)
})

<span class="hljs-comment">// 2. 监听actions方法执行，处理loading和错误</span>
<span class="hljs-keyword">const</span> unsubscribeAction = userStore.$onAction(<span class="hljs-function">(<span class="hljs-params">{ name, after, onError }</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>开始执行`</span>)
  <span class="hljs-keyword">const</span> loading = <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">info</span>({ <span class="hljs-attr">message</span>: <span class="hljs-string">'操作中...'</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0</span> })
  
  <span class="hljs-title function_">after</span>(<span class="hljs-function">() =&gt;</span> {
    loading.<span class="hljs-title function_">close</span>()
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行成功`</span>)
  })
  
  <span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    loading.<span class="hljs-title function_">close</span>()
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行失败：<span class="hljs-subst">${err.message}</span>`</span>)
  })
})

<span class="hljs-comment">// 3. 批量修改用户信息（$patch）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">updateUser</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.$patch({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia 实战'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">6</span>,
    <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>, <span class="hljs-string">'superAdmin'</span>]
  })
}

<span class="hljs-comment">// 4. 重置用户信息（$reset）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">resetUser</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.$reset()
}

<span class="hljs-comment">// 5. 异步获取用户信息（调用actions，触发$onAction）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.<span class="hljs-title function_">fetchUserInfo</span>()
}

<span class="hljs-comment">// 6. 组件卸载，取消所有监听</span>
<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">unsubscribeSub</span>()
  <span class="hljs-title function_">unsubscribeAction</span>()
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-26">六、总结：核心要点（新手必背）</h3>
<ol>
<li>四大API是Pinia进阶的核心，覆盖“修改-重置-监听”全流程，学会后能大幅提升状态管理效率；</li>
<li>$patch：批量修改首选，对象式简洁、函数式灵活，优化性能减少重渲染；</li>
<li>$reset：一键重置，注意Setup Store仅重置暴露的状态；</li>
<li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">subscribe/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span></span>onAction：监听状态和方法，务必记得取消监听（避免内存泄漏），按需配置detached、deep；</li>
<li>两种Store写法（Setup/Option）中，四大API用法完全一致，仅Setup Store操作ref需注意.value。</li>
</ol>
<p>其实这4个API的用法并不复杂，核心是“贴合场景选择”——批量修改用<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mtext>，重置用</mtext></mrow><annotation encoding="application/x-tex">patch，重置用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">，重置用</span></span></span></span></span>reset，监听状态用<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mtext>，监听方法用</mtext></mrow><annotation encoding="application/x-tex">subscribe，监听方法用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">，监听方法用</span></span></span></span></span>onAction。结合本文的案例多练几遍，就能灵活运用到实际项目中，彻底吃透Pinia的强大之处～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OSPF协议笔记整理]]></title>    <link>https://juejin.cn/post/7603643385816039476</link>    <guid>https://juejin.cn/post/7603643385816039476</guid>    <pubDate>2026-02-07T13:52:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816039476" data-draft-id="7603574149776932916" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OSPF协议笔记整理"/> <meta itemprop="keywords" content="网络协议"/> <meta itemprop="datePublished" content="2026-02-07T13:52:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不做菜鸟的网工"/> <meta itemprop="url" content="https://juejin.cn/user/3283597248432442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OSPF协议笔记整理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3283597248432442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不做菜鸟的网工
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T13:52:07.000Z" title="Sat Feb 07 2026 13:52:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">OSPF协议</h2>
<blockquote>
<p>基于链路状态、工作在网络层之上的路由协议</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">目录</h3>
<ol>
<li><a href="#ospf%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B" title="#ospf%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B">OSPF报文类型</a></li>
<li><a href="#ospf%E7%8A%B6%E6%80%81%E6%9C%BA" title="#ospf%E7%8A%B6%E6%80%81%E6%9C%BA">OSPF状态机</a></li>
<li><a href="#ospf%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6" title="#ospf%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6">OSPF确认机制</a></li>
<li><a href="#ospf%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98" title="#ospf%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98">OSPF邻接关系建立与路由计算问题</a></li>
<li><a href="#ospf%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B" title="#ospf%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B">OSPF网络类型</a></li>
<li><a href="#ospf%E5%BC%80%E9%94%80%E5%80%BC%E8%AE%A1%E7%AE%97" title="#ospf%E5%BC%80%E9%94%80%E5%80%BC%E8%AE%A1%E7%AE%97">OSPF开销值计算</a></li>
<li><a href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Elsa" title="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Elsa">链路状态数据库与LSA</a></li>
<li><a href="#ospf%E5%9F%9F%E5%86%85%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97" title="#ospf%E5%9F%9F%E5%86%85%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97">OSPF域内路由计算</a></li>
<li><a href="#ospf%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97" title="#ospf%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97">OSPF域间路由计算</a></li>
<li><a href="#ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97" title="#ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97">OSPF外部路由计算</a></li>
<li><a href="#ospf%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F" title="#ospf%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F">OSPF特殊区域</a></li>
<li><a href="#OSPF%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%A1%A8%E4%BC%98%E5%85%88%E7%BA%A7" title="#OSPF%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%A1%A8%E4%BC%98%E5%85%88%E7%BA%A7">路由加表优先级</a></li>
</ol>
<hr/>
<h3 data-id="heading-2">OSPF报文类型</h3>
<p>OSPF使用五种类型的报文来建立邻接、同步数据库并计算路由。</p>
<ol>
<li>
<p><strong>Hello报文</strong></p>
<ul>
<li><strong>功能</strong>：用于发现、建立并维持邻居关系。包含Router ID、区域ID、接口认证等信息。</li>
<li><strong>组播地址</strong>：<code>224.0.0.5</code>。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3544dd481fbb40bf89eac72a91d75373~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=Bv0Ew21BbWj0JH2A2gUC%2FAahDc4%3D" alt="HELLO报文.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p><strong>数据库描述报文</strong></p>
<ul>
<li>
<p><strong>功能</strong>：</p>
<ol>
<li><strong>选举主从设备</strong>，确保DD报文交换有序。</li>
<li>携带<strong>链路状态数据库摘要</strong>，即LSA头部信息，用于数据库同步。</li>
</ol>
</li>
<li>
<p><strong>特性</strong>：可以包含多个DD报文。携带MTU值，若两端MTU不匹配且开启检测，可能导致邻接建立失败。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad1fb4f069eb4751a31f32b5d3fc1829~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=VlsrHuL0QGsVYAIAuTSW4RCDmWQ%3D" alt="DD报文.png" loading="lazy"/></p>
</li>
<li>
<p><strong>MTU问题</strong>：当MTU不匹配时，邻居状态会卡在<code>ExStart</code>/<code>ExChange</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong>链路状态请求报文</strong></p>
<ul>
<li><strong>功能</strong>：在收到邻居的DD报文后，向对方请求本机缺失或需要更新的<strong>完整LSA信息</strong>。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c72824097b2142ab9a0a70c6ad64e4d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=Yb7RrN%2FVDt5ofbyvc4bbv10VS7Q%3D" alt="LSR报文.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p><strong>链路状态更新报文</strong></p>
<ul>
<li><strong>功能</strong>：用于回复LSR请求，或主动泛洪更新，包含一个或多个<strong>完整的LSA</strong>。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99746a834cff4a56b8bf1fc75e03e96b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=IUTrVN4mGpN6qS1mFx1ZYs1p1eU%3D" alt="LSU报文.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p><strong>链路状态确认报文</strong></p>
<ul>
<li><strong>功能</strong>：对收到的LSU报文进行确认，确保LSA的可靠泛洪。确认信息为LSA头部。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d4b2091ad694e07925e3bb20aa36d5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=Ro3iNQNxX8ou%2FjKUf6zFNQq%2B330%3D" alt="LSACK报文.png" loading="lazy"/></li>
</ul>
</li>
</ol>
<h3 data-id="heading-3">OSPF状态机</h3>
<p>OSPF邻接建立过程经历一系列状态，以下是关键节点：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31b234fe63224beb828954d48b313bcd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=kMxVHj6dXDh9hilRu9T%2BjdVXT9U%3D" alt="DD_state.png" loading="lazy"/></p>
<ol>
<li>
<p><strong>Down -&gt; Init -&gt; 2-Way</strong></p>
<ul>
<li><code>Init</code>：收到对端Hello包，但其中未包含自己的Router ID。</li>
<li><code>2-Way</code>：收到对端Hello包，且其中包含自己的Router ID。<strong>邻居关系</strong>建立。在广播网络中，此时选举DR/BDR。</li>
</ul>
</li>
<li>
<p><strong>2-Way -&gt; ExStart</strong></p>
<ul>
<li>邻居关系建立后，立即进入<code>ExStart</code>状态，通过交换<strong>空的DD报文</strong>（<code>M=1，MS=1</code>）进行<strong>主从选举</strong>。Router ID大者为主。</li>
</ul>
</li>
<li>
<p><strong>ExStart -&gt; Exchange</strong></p>
<ul>
<li><strong>从设备</strong>：在发出第一个携带摘要的DD报文后，状态变为<code>Exchange</code>。</li>
<li><strong>主设备</strong>：在接收到从设备的DD报文并回复自己的DD报文后，状态变为<code>Exchange</code>。双方开始交换完整的数据库摘要。</li>
</ul>
</li>
<li>
<p><strong>Exchange -&gt; Loading</strong></p>
<ul>
<li>摘要交换完成后，双方根据对比结果，向对方发送<strong>LSR</strong>请求缺失的LSA，状态进入<code>Loading</code>。同时，使用<code>LSU</code>和<code>LSACK</code>来传输和确认具体的LSA内容。</li>
</ul>
</li>
<li>
<p><strong>Loading -&gt; Full</strong></p>
<ul>
<li>所有请求的LSA交换并确认完毕后，邻居状态进入<code>Full</code>。<strong>邻接关系</strong>建立完成，可以开始路由计算。</li>
</ul>
</li>
</ol>
<p><strong>总结流程</strong>：寻找邻居(<code>Init</code>) -&gt; 建立邻居(<code>2-Way</code>) -&gt; 选举主从(<code>ExStart</code>) -&gt; 交换摘要(<code>Exchange</code>) -&gt; 请求并加载详细信息(<code>Loading</code>) -&gt; 完全邻接(<code>Full</code>)。</p>
<h3 data-id="heading-4">OSPF确认机制</h3>
<p>OSPF通过多种方式确保报文可靠传递：</p>
<ol>
<li><strong>Hello报文</strong>：周期性发送（默认10秒），通过超时机制（Dead Time，默认40秒）确认邻居存活。</li>
<li><strong>DD报文</strong>：使用<strong>序列号和主从关系进行隐式确认</strong>。
<ul>
<li>从设备使用主设备的序列号发起请求。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e64344cf8f94a97af0067fdbd60c2d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=XWvZX09H0jLkLWenD%2B9%2BTG8M3n4%3D" alt="DDseq隐式确认从.png" loading="lazy"/></li>
<li>主设备以从设备序列号+1进行回复。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e76e270d27da45aead1f4923d490272c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=SDoa22ElPoKVn7v9WS3UyfgNhME%3D" alt="DDseq隐式确认主.png" loading="lazy"/></li>
</ul>
</li>
<li><strong>LSR报文</strong>：通过接收对应的<code>LSU</code>报文进行确认。</li>
<li><strong>LSU报文</strong>：通过接收<code>LSACK</code>报文进行显式确认。若超时未收到确认，则重传。</li>
</ol>
<h3 data-id="heading-5">OSPF邻接关系建立与路由计算问题</h3>
<h4 data-id="heading-6">邻接建立失败常见原因</h4>
<ol>
<li>接口网络类型不一致（如一端为广播，另一端为点对点）。</li>
<li>区域ID不一致。</li>
<li>Router ID冲突。</li>
<li>接口MTU不匹配且开启了检测。</li>
<li>认证类型或密钥不匹配。</li>
<li>Hello/Dead时间间隔不一致。</li>
<li>接口被配置为静默接口。</li>
<li>网络掩码不匹配（仅在广播/NBMA网络中有影响）。</li>
<li>链路层故障。</li>
</ol>
<h4 data-id="heading-7">邻接建立成功但路由计算失败</h4>
<ol>
<li><strong>网络类型不匹配导致LSA缺失</strong>：例如，一端为点对点，另一端为广播。点对点端不产生<strong>2类LSA</strong>，导致广播端设备无法正确计算路由。</li>
<li><strong>静默接口</strong>：接口被静默后，不收发OSPF报文，但该接口所在网段仍会被通告（生成1类LSA）。邻居无法建立，路由自然无法通过该接口计算。</li>
</ol>
<h3 data-id="heading-8">OSPF网络类型</h3>
<p>OSPF接口网络类型决定了其行为方式，特别是邻居发现和DR选举。</p>








































<table><thead><tr><th align="left">网络类型</th><th align="left">默认链路协议</th><th align="left">DR/BDR选举</th><th align="left">Hello/Dead时间</th><th align="left">组播地址</th></tr></thead><tbody><tr><td align="left"><strong>广播</strong></td><td align="left">以太网</td><td align="left"><strong>是</strong></td><td align="left">10s/40s</td><td align="left">224.0.0.5, 224.0.0.6</td></tr><tr><td align="left"><strong>点到点</strong></td><td align="left">PPP/HDLC</td><td align="left"><strong>否</strong></td><td align="left">10s/40s</td><td align="left">224.0.0.5</td></tr><tr><td align="left"><strong>NBMA</strong></td><td align="left">帧中继/ATM</td><td align="left"><strong>是</strong></td><td align="left">30s/120s</td><td align="left"><strong>单播</strong> (需手动指定<code>peer</code>)</td></tr><tr><td align="left"><strong>点到多点</strong></td><td align="left">无默认，常手动配置</td><td align="left"><strong>否</strong></td><td align="left">30s/120s</td><td align="left">Hello: 224.0.0.5; 其他: 单播</td></tr></tbody></table>
<h4 data-id="heading-9">广播网络类型详解</h4>
<p>在广播网络中，DR和BDR的交互至关重要。</p>
<ul>
<li><strong>DR/BDR选举</strong>：基于接口优先级（默认1）和Router ID（越大越优）。优先级为0不参与选举。</li>
<li><strong>通信流程</strong>：
<ul>
<li><code>Drother</code>之间保持<code>2-Way</code>状态。</li>
<li>所有路由器与<code>DR/BDR</code>建立<code>Full</code>状态。</li>
<li>所有路由器向<code>DR</code>和<code>BDR</code>发送组播地址<code>224.0.0.6</code>。</li>
<li><code>DR</code>向所有其他路由器(<code>224.0.0.5</code>)泛洪更新。</li>
</ul>
</li>
<li><strong>交互示例</strong>：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5913eaf5bf944704bae025b06f6d446c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=0JtJt2nbuMUrOnJg6L9LSuhGcLA%3D" alt="拓扑.png" loading="lazy"/>
<ul>
<li><code>Drother</code>更新：发送至<code>224.0.0.6</code> (DR/BDR)。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88a6db69a782492ca5f355a328d5c8d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=1ArD0CAIsJnURXTdOXc%2Fz8L3ymI%3D" alt="R1_update.png" loading="lazy"/></li>
<li><code>DR</code>更新：发送至<code>224.0.0.5</code> (所有OSPF路由器)。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc64a00c86c4491f912ea6d7e1617c84~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=M1F1atxJUF8PIrFW%2Fpz%2B3LOBTUQ%3D" alt="R4_update.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h3 data-id="heading-10">OSPF开销值计算</h3>
<ol>
<li>
<p><strong>计算公式</strong>：<code>接口Cost = 参考带宽 / 接口实际带宽</code>。参考带宽默认为100 Mbps。</p>
<ul>
<li>结果小于1时取1。</li>
<li>最终路径开销是数据传出方向的<strong>沿途出接口Cost累加值</strong>。</li>
</ul>
</li>
<li>
<p><strong>修改方法</strong>：</p>
<ul>
<li><strong>直接修改接口Cost</strong>：<code>[接口视图] ospf cost &lt;值&gt;</code>。</li>
<li><strong>修改参考带宽</strong>：<code>[OSPF视图] bandwidth-reference &lt;值&gt;</code> (<strong>区域内所有路由器需一致</strong>)。</li>
<li>环回接口的默认Cost为0。</li>
</ul>
</li>
<li>
<p><strong>静默接口</strong>：配置后，接口<strong>不收发OSPF报文</strong>，但<strong>其网络仍会被通告</strong>。</p>
<ul>
<li><strong>作用</strong>：常用于避免在特定接口（如连接终端的接口）上建立不必要的邻居关系，或解决次优路径问题。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9400da78199a4cffa2d429f99572f10c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=LmgbbD2%2Fs0kOm77msvPQAsuCElM%3D" alt="静默接口作用.png" loading="lazy"/></li>
<li><strong>配置</strong>：
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 黑名单模式（推荐）</span>
[ospf-1] silent-interface GigabitEthernet 0/0
<span class="hljs-comment"># 白名单模式</span>
[ospf-1] silent-interface all
[ospf-1] undo silent-interface GigabitEthernet 0/1
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 data-id="heading-11">链路状态数据库与LSA</h3>
<p><strong>LSDB同步原则</strong>：</p>
<ul>
<li><strong>触发更新</strong>：当链路状态发生变化时。</li>
<li><strong>周期更新</strong>：每条LSA的老化时间(<code>Age</code>)达到1800秒时，始发路由器会重新泛洪一次，刷新<code>Age</code>。最大<code>Age</code>为3600秒。</li>
</ul>
<h4 data-id="heading-12">LSA头部与三要素</h4>
<p>所有LSA拥有公共的头部，其中关键字段包括：</p>
<ul>
<li><strong>LS Type</strong>：LSA类型。</li>
<li><strong>Link State ID</strong>：LSA标识符。</li>
<li><strong>Advertising Router</strong>：始发路由器Router ID。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3fc16c8fd3c94a5f8a66b75d51b27f41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=f1nov8FnZc9dD%2F0WLGBk82tAblE%3D" alt="LSA头部信息.png" loading="lazy"/>
<strong>LSA三要素</strong>：<code>LS Type</code> + <code>Link State ID</code> + <code>Advertising Router</code> 共同<strong>唯一标识</strong>一条LSA。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d372fbe25c84e52b7014b7050d2cb61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=ASH3tKAYc7Q1EKw3LSPWaueyAXs%3D" alt="LSA标识.png" loading="lazy"/></li>
</ul>
<h3 data-id="heading-13">OSPF域内路由计算</h3>
<p><strong>路由器使用SPF算法，以自己为根，计算到达所有网络的最短路径树。</strong></p>
<h4 data-id="heading-14">1类LSA</h4>
<ul>
<li><strong>功能</strong>：描述<strong>路由器自身</strong>的直连链路状态，并标识自身角色（如ABR、ASBR）。</li>
<li><strong>内容</strong>：
<ul>
<li><strong>StubNet Link</strong>：描述一条直连路由（<strong>叶子</strong>）。包含网络号、掩码和开销。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1bf8a29509c445af92639f775eacb126~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=WZ4j1CY5VbXCsbxAU2ZtTenI9Hg%3D" alt="1类LS信息.png" loading="lazy"/></li>
<li><strong>P-2-P Link</strong>：描述一个点对点邻居（<strong>树干</strong>）。包含邻居Router ID、本地接口IP和开销。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/248fbea6159c457da8b0d931df14d8d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=33EYf%2BAsWYzyuSnWqulP7ewgxFU%3D" alt="1类LS信息-邻居.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h4 data-id="heading-15">2类LSA</h4>
<ul>
<li><strong>产生条件</strong>：仅在<strong>广播或NBMA</strong>网络中，由<strong>DR</strong>产生。</li>
<li><strong>功能</strong>：描述一个<strong>伪节点</strong>，代表该多路访问网络本身。包含该网络掩码和所有连接到此DR的路由器列表（Attached Router）。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e540647e7a34845b6921d16965d04a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=53qSPK2u16yITj1Ep1yd%2BRHwa4I%3D" alt="TransNet.png" loading="lazy"/></li>
<li><strong>伪节点的Cost为0</strong>。1类和2类LSA仅在<strong>区域内</strong>泛洪。</li>
</ul>
<h3 data-id="heading-16">OSPF域间路由计算</h3>
<h4 data-id="heading-17">区域设计原则</h4>
<ol>
<li>骨干区域（Area 0）必须存在且唯一。</li>
<li>所有非骨干区域必须与骨干区域直接相连。</li>
</ol>
<h4 data-id="heading-18">3类LSA</h4>
<ul>
<li><strong>产生者</strong>：<strong>区域边界路由器</strong>。</li>
<li><strong>功能</strong>：描述<strong>域间路由</strong>信息。ABR将一个区域内的最优路由（由1/2类LSA计算得出）转换为3类LSA，泛洪到其他区域。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/935b35d736d447f8a10fd1a0ad95ea05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=YlsFx79n5cluE4lHaBZ5XYbUM2Y%3D" alt="三类LSA.png" loading="lazy"/></li>
<li><strong>关键规则（防环）</strong>：
<ol>
<li>ABR<strong>不会</strong>将非骨干区域的3类LSA注入骨干区域。</li>
<li>ABR<strong>只将骨干区域的3类LSA</strong>注入非骨干区域。</li>
<li>区域内路由（1/2类）优先级高于域间路由（3类），即使后者Cost更优。</li>
</ol>
</li>
</ul>
<h4 data-id="heading-19">ABR</h4>
<ul>
<li><strong>定义</strong>：连接多个区域，且在骨干区域至少有一个活跃接口的路由器。</li>
<li><strong>功能</strong>：汇总并传递3类LSA。其1类LSA中<code>B-bit</code>（Border位）被置位，标识其ABR身份。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a888ee794c1c4216b6ba81aa6f4c4c29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=udMWC%2FMqtN5sbaRjfVDS9AV9Sl8%3D" alt="ABR标识.png" loading="lazy"/></li>
</ul>
<h4 data-id="heading-20">虚链路</h4>
<ul>
<li><strong>作用</strong>：
<ol>
<li>将非骨干区域逻辑连接到骨干区域（解决区域0被分割问题）。</li>
<li>提供一条经过非骨干区域的骨干区域路径（优化Cost）。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/466f9f29c17c444e8f75e6b60030e0ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=x4sBcBMGf6e2886cdRxOrrorXLY%3D" alt="优化路径.png" loading="lazy"/></li>
</ol>
</li>
<li><strong>限制</strong>：只能穿越一个非骨干区域，且不能穿越特殊区域。</li>
</ul>
<h3 data-id="heading-21">OSPF外部路由计算</h3>
<h4 data-id="heading-22">5类LSA</h4>
<ul>
<li><strong>产生者</strong>：<strong>自治系统边界路由器</strong>。</li>
<li><strong>功能</strong>：描述<strong>引入到OSPF的外部路由</strong>（如静态路由、直连路由或其他协议路由）。在整个OSPF域内泛洪。</li>
<li><strong>关键字段</strong>：
<ul>
<li><strong>E Type</strong>：开销值类型。
<ul>
<li><strong>Type 1</strong>：外部开销 + 内部到达ASBR的开销。<code>总开销 = 种子度量值 + 内部开销</code>。</li>
<li><strong>Type 2（默认）</strong>：仅考虑外部种子度量值。<code>总开销 = 种子度量值</code>。</li>
</ul>
</li>
<li><strong>Forwarding Address</strong>：转发地址。若非0.0.0.0，则数据包直接发往FA地址而非ASBR，用于优化路径。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97122f6da35a49b88b50f18a14d2f280~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=zI89817FN5luIu6MmnQtE9XtK00%3D" alt="ospf_import.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h4 data-id="heading-23">4类LSA</h4>
<ul>
<li><strong>产生者</strong>：<strong>ABR</strong>。</li>
<li><strong>功能</strong>：描述<strong>如何到达ASBR</strong>。当ASBR不在本区域时，ABR会生成4类LSA，指明到达该ASBR的路径和开销。</li>
<li><strong>关系</strong>：<strong>有5类LSA不一定有4类LSA</strong>（ASBR在同一个区域时，无需4类LSA）。<strong>有4类LSA一定有5类LSA</strong>。</li>
</ul>
<h4 data-id="heading-24">默认路由注入</h4>
<ul>
<li>在ASBR上配置<code>default-route-advertise</code>，可将缺省路由以5类LSA形式注入OSPF域。</li>
<li>使用<code>always</code>参数，即使本机路由表无默认路由，也会强制下发。</li>
</ul>
<h3 data-id="heading-25">OSPF特殊区域</h3>
<p>用于减少非骨干区域内的LSA数量，优化设备性能。主要通过过滤特定LSA实现。</p>









































<table><thead><tr><th align="left">区域类型</th><th align="left">功能描述</th><th align="left">泛洪的LSA类型</th><th align="left">ABR下发的缺省路由类型</th></tr></thead><tbody><tr><td align="left"><strong>骨干区域/普通区域</strong></td><td align="left">标准区域，泛洪所有LSA</td><td align="left">1, 2, 3, 4, 5</td><td align="left">无</td></tr><tr><td align="left"><strong>Stub区域</strong></td><td align="left">过滤4、5类LSA</td><td align="left">1, 2, 3</td><td align="left"><strong>3类LSA</strong> (自动)</td></tr><tr><td align="left"><strong>Totally Stub区域</strong></td><td align="left">过滤3, 4, 5类LSA</td><td align="left">1, 2</td><td align="left"><strong>3类LSA</strong> (自动)</td></tr><tr><td align="left"><strong>NSSA区域</strong></td><td align="left">过滤4、5类LSA，但允许引入外部路由(以7类LSA形式)</td><td align="left">1, 2, 3, <strong>7</strong></td><td align="left"><strong>7类LSA</strong> (通常需手动<code>default-route-advertise</code>)</td></tr><tr><td align="left"><strong>Totally NSSA区域</strong></td><td align="left">过滤3, 4, 5类LSA，允许引入外部路由(7类)</td><td align="left">1, 2, <strong>7</strong></td><td align="left"><strong>3类LSA</strong> (自动) &amp; <strong>7类LSA</strong></td></tr></tbody></table>
<h4 data-id="heading-26">关键特性对比</h4>
<ul>
<li><strong>Option字段</strong>：
<ul>
<li><code>E-bit</code>：处理<strong>5类LSA</strong>能力。Stub和NSSA区域该位为0。</li>
<li><code>N-bit</code>：处理<strong>7类LSA</strong>能力。仅NSSA区域该位为1。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ade331a4cda4f719a1d21d219b190ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=EcmNPLVTzgvJcPxIZmtm881Bo0I%3D" alt="NSSA_HELLO报文.png" loading="lazy"/></li>
</ul>
</li>
<li><strong>7类LSA</strong>：
<ul>
<li>仅在NSSA区域内泛洪。</li>
<li>由NSSA区域的<strong>ABR</strong>转换为5类LSA后，泛洪到其他区域。通常由Router ID最大的ABR执行转换。</li>
<li>FA地址通常不为0，以优化路径。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2909085448bb4ef8b06f3c62ecf8e685~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=%2BjhXfteyok2aVJx%2FLBs5FSmptm4%3D" alt="7类LSA.png" loading="lazy"/></li>
</ul>
</li>
<li><strong>多ABR问题</strong>：Stub/NSSA区域存在多个ABR时，每个ABR都会下发缺省路由，可能导致区域内设备负载分担，引发次优路径。需通过调整接口Cost、缺省路由Cost或路由策略进行干预。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe0561e9d8d241f6ae82834c3789db83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=F%2BHlUSrrAzKab9umdLzPJiuU2Gk%3D" alt="Stub次优路径问题.png" loading="lazy"/></li>
</ul>
<h3 data-id="heading-27">OSPF路由加表优先级</h3>
<p>域内路由 &gt; 域间路由 &gt; 外部路由Type1 &gt; 外部路由Type2 &gt; NSSA区域外部路由Type1 &gt; NSSA区域外部路由Type2</p>
<p>相同优先级，比开销。如果开销一直，则进行<strong>等价多路径</strong>负载均衡（默认最多4条）。</p>
<hr/>
<h2 data-id="heading-28">MTU不一致会导致OSPF协商失败，什么场景要改MTU？</h2>
<p><strong>问题现象</strong>：如标题所述，当OSPF接口MTU不匹配且开启检测时，邻居状态会卡在<code>ExStart</code>或<code>ExChange</code>，导致邻接无法建立。</p>
<p><strong>问题根源</strong>：OSPF在ExStart状态交换DD报文进行主从选举时，报文中会携带本接口的MTU值。如果对端接口的MTU值小于此值，且开启MTU检测（某些厂商默认开启，如思科；华为/华三默认不检测），对端将拒绝处理此报文，导致协商失败。</p>
<p><strong>那么，什么情况下我们需要主动修改接口的MTU值？</strong></p>
<p><strong>核心场景：隧道封装</strong>。这是最常见且最重要的原因，如<strong>GRE隧道</strong>场景。</p>
<ol>
<li>
<p><strong>原理分析</strong>：</p>
<ul>
<li>标准以太网的<strong>MTU默认是1500字节</strong>，这意味着一个数据帧所能承载的IP报文最大为1500字节。</li>
<li>当我们在两个站点间建立<strong>GRE隧道</strong>时，原始IP报文（假设正好1500字节）会被封装上新的<strong>GRE头部</strong>和<strong>外层IP头部</strong>。这使得报文总长度<strong>超过了1500字节</strong>。</li>
<li>当这个“变胖”的报文被发送到物理接口（MTU=1500）时，接口会发现它超出了自己的MTU限制，从而触发<strong>IP分片</strong>。报文被拆分成多个片段传输。</li>
</ul>
</li>
<li>
<p><strong>分片带来的危害</strong>（为什么需要优化）：</p>
<ul>
<li><strong>性能下降</strong>：分片和重组需要消耗CPU和内存资源。</li>
<li><strong>可靠性降低</strong>：任何一个分片丢失，整个原始报文都需要重传，增加了丢包率和网络延迟。</li>
<li><strong>潜在兼容性问题</strong>：某些网络设备或安全策略可能阻止分片报文。</li>
</ul>
</li>
<li>
<p><strong>解决方案</strong>：</p>
<ul>
<li>为了<strong>避免隧道报文在传输过程中被分片</strong>，常见的优化手段是<strong>调小隧道接口及路径上相关物理接口的MTU值</strong>。</li>
<li><strong>调整方法</strong>：将隧道接口及其底层物理接口的MTU值设置为 <code>1500 - (隧道封装开销)</code>。对于GRE over IP，开销通常是24字节（新IP头20字节 + GRE头4字节），因此MTU常设置为 <strong>1476</strong>。
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 例如，在物理接口和隧道接口上均进行设置</span>
[H3C-GigabitEthernet0/1] mtu 1476
[H3C-Tunnel0] mtu 1476
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>对其他隧道类型的延伸</strong>：</p>
<ul>
<li><strong>IPsec VPN</strong>：封装开销更大（ESP隧道模式通常增加约50-60字节），因此需要设置更小的MTU（如1400）。</li>
<li><strong>VXLAN</strong>：封装开销巨大（超过50字节），在数据中心Underlay网络中需要将MTU设置为<strong>1600</strong>或更高（通常称为“巨型帧”），以容纳封装后的报文。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：
在部署GRE、IPsec、VXLAN等隧道技术时，<strong>预先规划和统一配置隧道路径上所有设备的MTU值，是保证网络稳定性和性能的最佳实践</strong>。这也解释了为什么在某些网络环境中，我们需要关注并调整OSPF接口的MTU，它不仅是OSPF邻接建立的一个检查项，更是整个网络数据平面能否高效转发的基础。当OSPF运行在隧道接口上时，确保隧道两端MTU一致且大小合理，就尤为关键。</p>
<h2 data-id="heading-29">为什么OSPF外部路由引入开销默认Type2?</h2>
<p>大多数情况下，广域网（外部）的链路开销非常大，而局域网内部（OSPF 域内）的开销相对微乎其微。因此，OSPF 默认使用 Type 2，这样路由表看起来更简洁，不需要因为内部链路的微小波动而频繁更新外部路由。</p>
<hr/>
<p><em>笔记内容排版经过AI优化。如有问题，感谢指正。内容仅供参考，请仔细甄别。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入浏览器指纹：Canvas、WebGL、Audio是如何暴露你的身份的？]]></title>    <link>https://juejin.cn/post/7603674653153214473</link>    <guid>https://juejin.cn/post/7603674653153214473</guid>    <pubDate>2026-02-08T02:36:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153214473" data-draft-id="7603627478021406730" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入浏览器指纹：Canvas、WebGL、Audio是如何暴露你的身份的？"/> <meta itemprop="keywords" content="前端,Canvas,浏览器"/> <meta itemprop="datePublished" content="2026-02-08T02:36:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="iDao技术魔方"/> <meta itemprop="url" content="https://juejin.cn/user/166781496080782"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入浏览器指纹：Canvas、WebGL、Audio是如何暴露你的身份的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/166781496080782/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    iDao技术魔方
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T02:36:26.000Z" title="Sun Feb 08 2026 02:36:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>你以为清除了Cookie就安全了？2025年约翰霍普金斯大学的研究首次证实：浏览器指纹追踪比你想象的更普遍，而且你几乎无法阻止它。</p>
</blockquote>
<h2 data-id="heading-0">📋 目录</h2>
<ul>
<li><a href="#%E8%83%8C%E6%99%AFcookie%E6%97%B6%E4%BB%A3%E7%9A%84%E7%BB%88%E7%BB%93" title="#%E8%83%8C%E6%99%AFcookie%E6%97%B6%E4%BB%A3%E7%9A%84%E7%BB%88%E7%BB%93">背景：Cookie时代的终结</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9" title="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9">什么是浏览器指纹？</a></li>
<li><a href="#canvas%E6%8C%87%E7%BA%B9%E5%83%8F%E7%B4%A0%E7%9A%84%E7%A7%98%E5%AF%86" title="#canvas%E6%8C%87%E7%BA%B9%E5%83%8F%E7%B4%A0%E7%9A%84%E7%A7%98%E5%AF%86">Canvas指纹：像素的秘密</a></li>
<li><a href="#webgl%E6%8C%87%E7%BA%B9gpu%E7%9A%84%E6%8C%87%E7%BA%B9" title="#webgl%E6%8C%87%E7%BA%B9gpu%E7%9A%84%E6%8C%87%E7%BA%B9">WebGL指纹：GPU的指纹</a></li>
<li><a href="#audio%E6%8C%87%E7%BA%B9%E5%A3%B0%E9%9F%B3%E9%87%8C%E7%9A%84%E8%BA%AB%E4%BB%BD" title="#audio%E6%8C%87%E7%BA%B9%E5%A3%B0%E9%9F%B3%E9%87%8C%E7%9A%84%E8%BA%AB%E4%BB%BD">Audio指纹：声音里的身份</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%8C%87%E7%BA%B9%E7%BB%B4%E5%BA%A6" title="#%E5%85%B6%E4%BB%96%E6%8C%87%E7%BA%B9%E7%BB%B4%E5%BA%A6">其他指纹维度</a></li>
<li><a href="#%E5%8F%8D%E6%8C%87%E7%BA%B9%E6%8A%80%E6%9C%AF%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%98%B2%E5%BE%A1" title="#%E5%8F%8D%E6%8C%87%E7%BA%B9%E6%8A%80%E6%9C%AF%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%98%B2%E5%BE%A1">反指纹技术：现代浏览器的防御</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E7%94%A8%E5%BC%80%E6%BA%90%E5%BA%93%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E6%8C%87%E7%BA%B9" title="#%E5%AE%9E%E6%88%98%E7%94%A8%E5%BC%80%E6%BA%90%E5%BA%93%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E6%8C%87%E7%BA%B9">实战：用开源库生成你的指纹</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83" title="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83">总结与思考</a></li>
</ul>
<hr/>
<h2 data-id="heading-1">背景：Cookie时代的终结</h2>
<p>还记得那些年困扰我们的Cookie弹窗吗？</p>
<p>"本网站使用Cookie改善您的体验"——然后给你两个选项：一个巨大的"接受所有Cookie"按钮，和一个藏在角落里的"拒绝"链接。这就是所谓的"暗模式"（Dark Pattern），专门用来诱导用户同意追踪。</p>
<p>好消息是，这个时代正在落幕。Chrome、Firefox、Safari都在逐步默认阻止第三方Cookie。但坏消息是——<strong>广告商们找到了更隐蔽的武器：浏览器指纹</strong>。</p>
<p>浏览器指纹最大的特点是：<strong>你无法删除它，甚至无法感知它</strong>。它就像你在互联网上留下的无形签名，无论你如何清理浏览数据，它都能把你认出来。</p>
<p>2025年2月，约翰霍普金斯大学和德州农工大学的研究团队发布了论文《The First Early Evidence of the Use of Browser Fingerprinting for Online Tracking》，<strong>首次实证证实了浏览器指纹被广泛用于广告追踪</strong>。研究团队通过FPTrace框架发现，改变指纹后广告竞价出现了显著差异，直接证明了指纹与广告定向的关联。</p>
<p>更讽刺的是，2025年3月，Google修改了隐私政策，<strong>允许在Privacy Sandbox中使用浏览器指纹技术</strong>。这意味着连倡导"隐私保护"的科技巨头，也在拥抱这种技术。</p>
<hr/>
<h2 data-id="heading-2">什么是浏览器指纹？</h2>
<p>简单来说，浏览器指纹就是通过收集浏览器和设备的多种特征信息，生成一个几乎唯一的标识符。这些特征包括但不限于：</p>























































<table><thead><tr><th>特征类别</th><th>具体信息</th><th>熵值贡献</th></tr></thead><tbody><tr><td><strong>User Agent</strong></td><td>浏览器版本、操作系统</td><td>中等</td></tr><tr><td><strong>屏幕信息</strong></td><td>分辨率、颜色深度、可用分辨率</td><td>低</td></tr><tr><td><strong>时区语言</strong></td><td>时区偏移、首选语言</td><td>低</td></tr><tr><td><strong>字体列表</strong></td><td>已安装字体</td><td><strong>极高</strong></td></tr><tr><td><strong>插件信息</strong></td><td>浏览器插件列表</td><td>中等</td></tr><tr><td><strong>Canvas</strong></td><td>2D渲染像素差异</td><td><strong>极高</strong></td></tr><tr><td><strong>WebGL</strong></td><td>GPU型号、渲染器信息</td><td><strong>极高</strong></td></tr><tr><td><strong>Audio</strong></td><td>音频处理特征</td><td>高</td></tr><tr><td><strong>Hardware</strong></td><td>内存、CPU核心数</td><td>中等</td></tr></tbody></table>
<p><strong>根据EFF的Panopticlick研究，在100万个样本中，94.2%的浏览器指纹都是唯一的。</strong></p>
<p>打个比方：如果把User Agent比作你的名字，Canvas指纹就是你的笔迹，WebGL指纹是你的DNA——前者很容易伪造，后者几乎无法复制。</p>
<hr/>
<h2 data-id="heading-3">Canvas指纹：像素的秘密</h2>
<h3 data-id="heading-4">原理剖析</h3>
<p>Canvas指纹是浏览器指纹中最成熟、最稳定的技术之一。它的核心思想非常简单：<strong>让浏览器在Canvas上绘制特定内容，然后读取像素数据，不同浏览器/设备产生的像素差异就是指纹</strong>。</p>
<p>为什么会产生差异？主要原因包括：</p>
<ol>
<li><strong>显卡驱动差异</strong>：不同GPU渲染相同的图形会有细微差异</li>
<li><strong>操作系统差异</strong>：Windows、macOS、Linux的字体渲染引擎不同</li>
<li><strong>浏览器差异</strong>：Chrome、Firefox、Safari的Canvas实现有差异</li>
<li><strong>抗锯齿算法</strong>：不同浏览器使用不同的抗锯齿策略</li>
</ol>
<h3 data-id="heading-5">实战代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCanvasFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);
  
  <span class="hljs-comment">// 设置画布大小</span>
  canvas.<span class="hljs-property">width</span> = <span class="hljs-number">200</span>;
  canvas.<span class="hljs-property">height</span> = <span class="hljs-number">50</span>;
  
  <span class="hljs-comment">// 绘制背景</span>
  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">'#f60'</span>;
  ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">50</span>);
  
  <span class="hljs-comment">// 绘制文字 - 关键！字体和抗锯齿会产生差异</span>
  ctx.<span class="hljs-property">textBaseline</span> = <span class="hljs-string">'alphabetic'</span>;
  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">'#069'</span>;
  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">'16px "Times New Roman"'</span>;
  ctx.<span class="hljs-title function_">fillText</span>(<span class="hljs-string">'FingerprintJS 🤓'</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>);
  
  <span class="hljs-comment">// 绘制复杂图形 - 增加熵值</span>
  ctx.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">'#06f'</span>;
  ctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">150</span>, <span class="hljs-number">25</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>);
  ctx.<span class="hljs-title function_">stroke</span>();
  
  <span class="hljs-comment">// 获取像素数据并哈希</span>
  <span class="hljs-keyword">const</span> data = canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">'image/png'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">hashString</span>(data); <span class="hljs-comment">// 生成哈希值作为指纹</span>
}
</code></pre>
<h3 data-id="heading-6">真实案例</h3>
<p><strong>fingerprintjs</strong>（GitHub 26.4k stars）的Canvas实现更加复杂：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 来自 fingerprintjs/src/sources/canvas.ts</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderTextImage</span>(<span class="hljs-params">canvas, context</span>) {
  <span class="hljs-comment">// 绘制多行文字，使用多种字体和emoji</span>
  <span class="hljs-keyword">const</span> text = <span class="hljs-string">'Cwm fjordbank glyphs vext quiz 😃'</span>;
  context.<span class="hljs-property">font</span> = <span class="hljs-string">'14px Arial'</span>;
  context.<span class="hljs-title function_">fillText</span>(text, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);
  
  <span class="hljs-comment">// 绘制几何图形</span>
  context.<span class="hljs-title function_">beginPath</span>();
  context.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">100</span>, <span class="hljs-number">5</span>);
  context.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">120</span>, <span class="hljs-number">35</span>);
  context.<span class="hljs-title function_">stroke</span>();
}

<span class="hljs-comment">// 关键：检测Canvas Farbling（噪声注入）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isCanvasStable</span>(<span class="hljs-params">canvas</span>) {
  <span class="hljs-keyword">const</span> img1 = canvas.<span class="hljs-title function_">toDataURL</span>();
  <span class="hljs-keyword">const</span> img2 = canvas.<span class="hljs-title function_">toDataURL</span>();
  <span class="hljs-keyword">return</span> img1 === img2; <span class="hljs-comment">// Brave等浏览器会注入噪声，两次读取结果不同</span>
}
</code></pre>
<h3 data-id="heading-7">为什么难以防御？</h3>
<p>Canvas指纹的可怕之处在于它利用了<strong>合法的Web API</strong>。网站可以说"我只是想画个图表"，实际上却在偷取你的指纹。你无法完全禁用Canvas，否则大量网站（包括图表库、游戏、视频编辑）都会失效。</p>
<hr/>
<h2 data-id="heading-8">WebGL指纹：GPU的指纹</h2>
<p>如果说Canvas指纹是"笔迹"，那WebGL指纹就是"DNA检测"——它直接读取你的显卡型号和驱动信息。</p>
<h3 data-id="heading-9">原理剖析</h3>
<p>WebGL（Web Graphics Library）是浏览器中的3D图形API。它的指纹信息主要来源：</p>
<ol>
<li><strong>GPU型号</strong>：通过<code>WEBGL_debug_renderer_info</code>扩展获取真实的显卡型号</li>
<li><strong>渲染管道差异</strong>：不同GPU执行相同的着色器程序会产生细微差异</li>
<li><strong>扩展支持</strong>：不同的GPU支持不同的WebGL扩展</li>
<li><strong>参数限制</strong>：<code>MAX_TEXTURE_SIZE</code>、<code>MAX_VIEWPORT_DIMS</code>等参数</li>
</ol>
<h3 data-id="heading-10">实战代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getWebGLFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">const</span> gl = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'webgl'</span>) || canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'experimental-webgl'</span>);
  
  <span class="hljs-keyword">if</span> (!gl) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">const</span> result = [];
  
  <span class="hljs-comment">// 基础参数</span>
  result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'vendor:'</span> + gl.<span class="hljs-title function_">getParameter</span>(gl.<span class="hljs-property">VENDOR</span>));
  result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'renderer:'</span> + gl.<span class="hljs-title function_">getParameter</span>(gl.<span class="hljs-property">RENDERER</span>));
  result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'version:'</span> + gl.<span class="hljs-title function_">getParameter</span>(gl.<span class="hljs-property">VERSION</span>));
  result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'shadingLanguageVersion:'</span> + gl.<span class="hljs-title function_">getParameter</span>(gl.<span class="hljs-property">SHADING_LANGUAGE_VERSION</span>));
  
  <span class="hljs-comment">// 关键：获取真实的GPU信息（如果扩展可用）</span>
  <span class="hljs-keyword">const</span> debugInfo = gl.<span class="hljs-title function_">getExtension</span>(<span class="hljs-string">'WEBGL_debug_renderer_info'</span>);
  <span class="hljs-keyword">if</span> (debugInfo) {
    result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'unmaskedVendor:'</span> + gl.<span class="hljs-title function_">getParameter</span>(debugInfo.<span class="hljs-property">UNMASKED_VENDOR_WEBGL</span>));
    result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'unmaskedRenderer:'</span> + gl.<span class="hljs-title function_">getParameter</span>(debugInfo.<span class="hljs-property">UNMASKED_RENDERER_WEBGL</span>));
  }
  
  <span class="hljs-comment">// 能力参数 - 这些因GPU而异</span>
  result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'maxTextureSize:'</span> + gl.<span class="hljs-title function_">getParameter</span>(gl.<span class="hljs-property">MAX_TEXTURE_SIZE</span>));
  result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'maxViewportDims:'</span> + gl.<span class="hljs-title function_">getParameter</span>(gl.<span class="hljs-property">MAX_VIEWPORT_DIMS</span>));
  result.<span class="hljs-title function_">push</span>(<span class="hljs-string">'maxVertexAttribs:'</span> + gl.<span class="hljs-title function_">getParameter</span>(gl.<span class="hljs-property">MAX_VERTEX_ATTRIBS</span>));
  
  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">join</span>(<span class="hljs-string">'|'</span>);
}
</code></pre>
<h3 data-id="heading-11">高级技术：WebGL渲染指纹</h3>
<p>除了基础参数，还可以通过实际渲染来生成指纹：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 来自beefproject/beef的WebGL指纹实现</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getAdvancedWebGLFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">const</span> gl = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'webgl'</span>);
  
  <span class="hljs-comment">// 创建着色器程序</span>
  <span class="hljs-keyword">const</span> vShader = gl.<span class="hljs-title function_">createShader</span>(gl.<span class="hljs-property">VERTEX_SHADER</span>);
  gl.<span class="hljs-title function_">shaderSource</span>(vShader, <span class="hljs-string">`
    attribute vec2 attrVertex;
    void main() {
      gl_Position = vec4(attrVertex, 0.0, 1.0);
    }
  `</span>);
  gl.<span class="hljs-title function_">compileShader</span>(vShader);
  
  <span class="hljs-keyword">const</span> fShader = gl.<span class="hljs-title function_">createShader</span>(gl.<span class="hljs-property">FRAGMENT_SHADER</span>);
  gl.<span class="hljs-title function_">shaderSource</span>(fShader, <span class="hljs-string">`
    precision mediump float;
    void main() {
      gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);
    }
  `</span>);
  gl.<span class="hljs-title function_">compileShader</span>(fShader);
  
  <span class="hljs-comment">// 链接着色器并绘制</span>
  <span class="hljs-keyword">const</span> program = gl.<span class="hljs-title function_">createProgram</span>();
  gl.<span class="hljs-title function_">attachShader</span>(program, vShader);
  gl.<span class="hljs-title function_">attachShader</span>(program, fShader);
  gl.<span class="hljs-title function_">linkProgram</span>(program);
  gl.<span class="hljs-title function_">useProgram</span>(program);
  
  <span class="hljs-comment">// 读取像素 - 不同GPU渲染结果有细微差异</span>
  <span class="hljs-keyword">const</span> pixels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(<span class="hljs-number">4</span>);
  gl.<span class="hljs-title function_">readPixels</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, gl.<span class="hljs-property">RGBA</span>, gl.<span class="hljs-property">UNSIGNED_BYTE</span>, pixels);
  
  <span class="hljs-keyword">return</span> pixels.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}
</code></pre>
<h3 data-id="heading-12">为什么WebGL指纹如此强大？</h3>
<p><strong>1. 唯一性极高</strong>：GPU型号+驱动版本的组合几乎是唯一的
<strong>2. 难以伪造</strong>：除非使用虚拟机或模拟器，否则无法欺骗真实的GPU
<strong>3. 跨会话稳定</strong>：除非更换显卡或驱动，否则指纹基本不变</p>
<p><strong>但有个致命弱点</strong>：某些浏览器（如Tor Browser）完全禁用WebGL，或者某些隐私插件会拦截<code>WEBGL_debug_renderer_info</code>扩展。</p>
<hr/>
<h2 data-id="heading-13">Audio指纹：声音里的身份</h2>
<p>如果说Canvas和WebGL是"视觉指纹"，那Audio指纹就是"听觉指纹"——通过音频处理管道的微小差异来识别设备。</p>
<h3 data-id="heading-14">原理剖析</h3>
<p>Audio指纹的原理是利用AudioContext API：</p>
<ol>
<li>创建一个离线的AudioContext</li>
<li>生成一个特定的音频信号（通常是正弦波或压缩信号）</li>
<li>通过音频处理节点（如DynamicsCompressorNode）</li>
<li>读取处理后的音频样本</li>
<li>不同设备的音频处理硬件和软件会导致微小的差异</li>
</ol>
<p>为什么会产生差异？</p>
<ul>
<li><strong>采样率转换</strong>：不同系统使用不同的重采样算法</li>
<li><strong>浮点精度</strong>：CPU处理浮点运算的精度差异</li>
<li><strong>音频驱动</strong>：操作系统音频驱动层的实现差异</li>
</ul>
<h3 data-id="heading-15">实战代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAudioFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">AudioContext</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">OfflineAudioContext</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitOfflineAudioContext</span>;
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">AudioContext</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-comment">// 创建离线音频上下文</span>
    <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AudioContext</span>(<span class="hljs-number">1</span>, <span class="hljs-number">44100</span>, <span class="hljs-number">44100</span>);
    
    <span class="hljs-comment">// 创建振荡器（音源）</span>
    <span class="hljs-keyword">const</span> oscillator = context.<span class="hljs-title function_">createOscillator</span>();
    oscillator.<span class="hljs-property">type</span> = <span class="hljs-string">'triangle'</span>;
    oscillator.<span class="hljs-property">frequency</span>.<span class="hljs-title function_">setValueAtTime</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 创建压缩器 - 关键！不同设备的压缩算法有差异</span>
    <span class="hljs-keyword">const</span> compressor = context.<span class="hljs-title function_">createDynamicsCompressor</span>();
    compressor.<span class="hljs-property">threshold</span>.<span class="hljs-title function_">setValueAtTime</span>(-<span class="hljs-number">50</span>, <span class="hljs-number">0</span>);
    compressor.<span class="hljs-property">knee</span>.<span class="hljs-title function_">setValueAtTime</span>(<span class="hljs-number">40</span>, <span class="hljs-number">0</span>);
    compressor.<span class="hljs-property">ratio</span>.<span class="hljs-title function_">setValueAtTime</span>(<span class="hljs-number">12</span>, <span class="hljs-number">0</span>);
    compressor.<span class="hljs-property">attack</span>.<span class="hljs-title function_">setValueAtTime</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    compressor.<span class="hljs-property">release</span>.<span class="hljs-title function_">setValueAtTime</span>(<span class="hljs-number">0.25</span>, <span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 连接节点</span>
    oscillator.<span class="hljs-title function_">connect</span>(compressor);
    compressor.<span class="hljs-title function_">connect</span>(context.<span class="hljs-property">destination</span>);
    
    <span class="hljs-comment">// 播放并获取音频数据</span>
    oscillator.<span class="hljs-title function_">start</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> renderedBuffer = <span class="hljs-keyword">await</span> context.<span class="hljs-title function_">startRendering</span>();
    
    <span class="hljs-comment">// 提取特征点（取特定时间点的样本）</span>
    <span class="hljs-keyword">const</span> channelData = renderedBuffer.<span class="hljs-title function_">getChannelData</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> samples = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">4500</span>; i &lt; <span class="hljs-number">5000</span>; i += <span class="hljs-number">10</span>) {
      samples.<span class="hljs-title function_">push</span>(channelData[i].<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">10</span>));
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">hashString</span>(samples.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>));
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h3 data-id="heading-16">Audio指纹的稳定性</h3>
<p>Audio指纹的优势在于它<strong>不太受软件版本影响</strong>，更多取决于硬件（声卡/音频芯片）。这意味着：</p>
<ul>
<li>✅ <strong>跨浏览器稳定</strong>：Chrome和Firefox在同一个设备上会产生相似的音频指纹</li>
<li>✅ <strong>难以软件欺骗</strong>：单纯的浏览器插件难以模拟硬件级音频特征</li>
<li>⚠️ <strong>但不够唯一</strong>：相比Canvas和WebGL，Audio指纹的区分度稍低，通常作为辅助指纹使用</li>
</ul>
<hr/>
<h2 data-id="heading-17">其他指纹维度</h2>
<p>除了三大核心指纹技术，还有很多"小而美"的指纹维度：</p>
<h3 data-id="heading-18">1. 字体指纹</h3>
<p>检测已安装的字体列表：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFontFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> baseFonts = [<span class="hljs-string">'Arial'</span>, <span class="hljs-string">'Times New Roman'</span>, <span class="hljs-string">'Courier New'</span>];
  <span class="hljs-keyword">const</span> testFonts = [<span class="hljs-string">'Helvetica'</span>, <span class="hljs-string">'Georgia'</span>, <span class="hljs-string">'Verdana'</span>, <span class="hljs-string">'Tahoma'</span>];
  <span class="hljs-keyword">const</span> detected = [];
  
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);
  
  <span class="hljs-comment">// 使用基线字体测量文本宽度</span>
  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">'72px '</span> + baseFonts[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> baselineWidth = ctx.<span class="hljs-title function_">measureText</span>(<span class="hljs-string">'mmmmmmmmlli'</span>).<span class="hljs-property">width</span>;
  
  <span class="hljs-comment">// 测试每种字体</span>
  testFonts.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">font</span> =&gt;</span> {
    ctx.<span class="hljs-property">font</span> = <span class="hljs-string">'72px "'</span> + font + <span class="hljs-string">'", '</span> + baseFonts[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">const</span> width = ctx.<span class="hljs-title function_">measureText</span>(<span class="hljs-string">'mmmmmmmmlli'</span>).<span class="hljs-property">width</span>;
    <span class="hljs-keyword">if</span> (width !== baselineWidth) {
      detected.<span class="hljs-title function_">push</span>(font);
    }
  });
  
  <span class="hljs-keyword">return</span> detected.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}
</code></pre>
<h3 data-id="heading-19">2. 硬件信息</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getHardwareFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">deviceMemory</span>: navigator.<span class="hljs-property">deviceMemory</span>, <span class="hljs-comment">// RAM（GB）</span>
    <span class="hljs-attr">hardwareConcurrency</span>: navigator.<span class="hljs-property">hardwareConcurrency</span>, <span class="hljs-comment">// CPU核心数</span>
    <span class="hljs-attr">maxTouchPoints</span>: navigator.<span class="hljs-property">maxTouchPoints</span>, <span class="hljs-comment">// 触摸点数</span>
    <span class="hljs-attr">platform</span>: navigator.<span class="hljs-property">platform</span>,
  };
}
</code></pre>
<h3 data-id="heading-20">3. 时区和语言</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTimezoneFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">timezone</span>: <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">DateTimeFormat</span>().<span class="hljs-title function_">resolvedOptions</span>().<span class="hljs-property">timeZone</span>,
    <span class="hljs-attr">timezoneOffset</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTimezoneOffset</span>(),
    <span class="hljs-attr">languages</span>: navigator.<span class="hljs-property">languages</span>,
    <span class="hljs-attr">language</span>: navigator.<span class="hljs-property">language</span>,
  };
}
</code></pre>
<hr/>
<h2 data-id="heading-21">反指纹技术：现代浏览器的防御</h2>
<p>既然指纹技术如此强大，有没有办法防御呢？答案是——<strong>有，但不完美</strong>。</p>
<h3 data-id="heading-22">1. Canvas Farbling（随机化噪声）</h3>
<p>这是<strong>Brave浏览器</strong>首创的技术，后来被Firefox采用。</p>
<p>原理：在Canvas读取像素数据时，向某些像素注入微小的随机噪声（通常是RGB值的±1）。人眼无法察觉，但会破坏指纹哈希的稳定性。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Brave的Farbling原理示意</span>
<span class="hljs-keyword">const</span> originalToDataURL = <span class="hljs-title class_">HTMLCanvasElement</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toDataURL</span>;
<span class="hljs-title class_">HTMLCanvasElement</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toDataURL</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-keyword">const</span> data = originalToDataURL.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
  <span class="hljs-comment">// 注入基于会话的伪随机噪声</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">addFarblingNoise</span>(data, <span class="hljs-title function_">getSessionSeed</span>());
};
</code></pre>
<p><strong>检测Farbling的方法</strong>（来自fingerprintjs）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectCanvasFarbling</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);
  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">'#000'</span>;
  ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  
  <span class="hljs-keyword">const</span> data1 = canvas.<span class="hljs-title function_">toDataURL</span>();
  <span class="hljs-keyword">const</span> data2 = canvas.<span class="hljs-title function_">toDataURL</span>();
  
  <span class="hljs-keyword">return</span> data1 !== data2; <span class="hljs-comment">// 如果两次读取不同，说明有Farbling</span>
}
</code></pre>
<h3 data-id="heading-23">2. WebGL扩展拦截</h3>
<p>隐私插件（如ScriptSafe）会拦截对<code>WEBGL_debug_renderer_info</code>的访问：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 防追踪脚本的典型做法</span>
<span class="hljs-keyword">const</span> originalGetExtension = <span class="hljs-title class_">WebGLRenderingContext</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getExtension</span>;
<span class="hljs-title class_">WebGLRenderingContext</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getExtension</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'WEBGL_debug_renderer_info'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 返回null，阻止获取真实GPU信息</span>
  }
  <span class="hljs-keyword">return</span> originalGetExtension.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
};
</code></pre>
<h3 data-id="heading-24">3. User Agent标准化</h3>
<p>现代浏览器开始减少User Agent的熵值：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 过去的User Agent（信息丰富）</span>
<span class="hljs-comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 </span>
<span class="hljs-comment">// (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.0</span>

<span class="hljs-comment">// 未来的User Agent（精简版）</span>
<span class="hljs-comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 </span>
<span class="hljs-comment">// (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.0</span>
<span class="hljs-comment">// 版本号将简化为主要版本</span>
</code></pre>
<h3 data-id="heading-25">4. Tor Browser的极端策略</h3>
<p>Tor Browser采取了最激进的反指纹措施：</p>
<ul>
<li>完全禁用WebGL</li>
<li>统一所有用户的User Agent（都显示为Windows 7 + Firefox ESR）</li>
<li>标准化屏幕分辨率（仅报告几种常见尺寸）</li>
<li>禁用Canvas读取（或返回空白数据）</li>
<li>禁用所有时区检测（统一使用UTC）</li>
</ul>
<p>代价是：<strong>网站兼容性极差</strong>，很多现代Web应用无法在Tor Browser中正常运行。</p>
<hr/>
<h2 data-id="heading-26">实战：用开源库生成你的指纹</h2>
<h3 data-id="heading-27">方案1：FingerprintJS（最流行）</h3>
<pre><code class="hljs language-bash" lang="bash">npm install @fingerprintjs/fingerprintjs
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">FingerprintJS</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@fingerprintjs/fingerprintjs'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getVisitorId</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 加载指纹库</span>
  <span class="hljs-keyword">const</span> fp = <span class="hljs-keyword">await</span> <span class="hljs-title class_">FingerprintJS</span>.<span class="hljs-title function_">load</span>();
  
  <span class="hljs-comment">// 获取指纹结果</span>
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> fp.<span class="hljs-title function_">get</span>();
  
  <span class="hljs-comment">// 输出访客ID（稳定标识符）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Visitor ID:'</span>, result.<span class="hljs-property">visitorId</span>);
  
  <span class="hljs-comment">// 查看各个组件</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Components:'</span>, result.<span class="hljs-property">components</span>);
  
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 实际项目中的使用场景（如Grafana）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BackendService</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">initDeviceID</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> fp = <span class="hljs-keyword">await</span> <span class="hljs-title class_">FingerprintJS</span>.<span class="hljs-title function_">load</span>();
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> fp.<span class="hljs-title function_">get</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deviceID</span> = result.<span class="hljs-property">visitorId</span>;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Fingerprint failed:'</span>, error);
    }
  }
}
</code></pre>
<h3 data-id="heading-28">方案2：GuardianJS（免费开源）</h3>
<pre><code class="hljs language-bash" lang="bash">npm install guardian-js-free
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { load } <span class="hljs-keyword">from</span> <span class="hljs-string">'guardian-js-free'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getGuardianFingerprint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> guardian = <span class="hljs-keyword">await</span> <span class="hljs-title function_">load</span>();
  <span class="hljs-keyword">const</span> visitorId = <span class="hljs-keyword">await</span> guardian.<span class="hljs-title function_">getVisitorId</span>();
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Guardian ID:'</span>, visitorId);
  <span class="hljs-keyword">return</span> visitorId;
}
</code></pre>
<h3 data-id="heading-29">方案3：纯浏览器API实现</h3>
<p>如果你想自己实现（用于学习）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrowserFingerprinter</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getFingerprint</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> components = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCanvasFingerprint</span>(),
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWebGLFingerprint</span>(),
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAudioFingerprint</span>(),
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getFontFingerprint</span>(),
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHardwareInfo</span>(),
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTimezoneInfo</span>(),
    ]);
    
    <span class="hljs-comment">// 组合所有组件并哈希</span>
    <span class="hljs-keyword">const</span> combined = components.<span class="hljs-title function_">join</span>(<span class="hljs-string">'::'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hash</span>(combined);
  }
  
  <span class="hljs-comment">// ... 实现各个指纹方法</span>
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">const</span> fingerprinter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserFingerprinter</span>();
<span class="hljs-keyword">const</span> id = <span class="hljs-keyword">await</span> fingerprinter.<span class="hljs-title function_">getFingerprint</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Your fingerprint:'</span>, id);
</code></pre>
<hr/>
<h2 data-id="heading-30">总结与思考</h2>
<h3 data-id="heading-31">核心要点回顾</h3>
<ol>
<li>
<p><strong>浏览器指纹利用了Web的开放性</strong>：它不需要Cookie，不违反任何协议，只是"读取浏览器本来就公开的信息"。</p>
</li>
<li>
<p><strong>三大核心技术</strong>：</p>
<ul>
<li><strong>Canvas指纹</strong>：2D渲染差异，利用显卡驱动和字体渲染的不同</li>
<li><strong>WebGL指纹</strong>：GPU型号和渲染管道特征，几乎无法伪造</li>
<li><strong>Audio指纹</strong>：音频处理差异，硬件级特征</li>
</ul>
</li>
<li>
<p><strong>2025年的新趋势</strong>：</p>
<ul>
<li>学术研究首次实证指纹用于广告追踪</li>
<li>Google政策转向，Privacy Sandbox拥抱指纹技术</li>
<li>浏览器厂商加大反指纹力度（Farbling成为标准）</li>
</ul>
</li>
</ol>
<h3 data-id="heading-32">给开发者的建议</h3>
<p><strong>如果你需要实现设备识别</strong>：</p>
<ul>
<li>优先考虑服务器端Session + 登录态</li>
<li>如果需要客户端识别，可以使用FingerprintJS等成熟库</li>
<li><strong>永远不要</strong>将指纹用于违法追踪或侵犯隐私</li>
</ul>
<p><strong>如果你想保护用户隐私</strong>：</p>
<ul>
<li>教育用户使用Brave、Firefox等注重隐私的浏览器</li>
<li>安装Privacy Badger、uBlock Origin等扩展</li>
<li>对于高安全需求，考虑使用Tor Browser</li>
</ul>
<h3 data-id="heading-33">给普通用户的建议</h3>
<ol>
<li><strong>不要迷信"无痕模式"</strong>：它只清除本地数据，无法阻止指纹追踪</li>
<li><strong>安装隐私扩展</strong>：uBlock Origin、Privacy Badger能有效阻止大部分追踪</li>
<li><strong>使用隐私浏览器</strong>：Brave的Farbling是目前最有效的反指纹手段</li>
<li><strong>接受现实</strong>：完全的匿名在当前Web技术下几乎不可能，除非你准备好牺牲便利性</li>
</ol>
<hr/>
<h2 data-id="heading-34">参考链接</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffingerprintjs%2Ffingerprintjs" target="_blank" title="https://github.com/fingerprintjs/fingerprintjs" ref="nofollow noopener noreferrer">FingerprintJS 官方库</a> - 验证状态: ✅</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpanopticlick.eff.org%2F" target="_blank" title="https://panopticlick.eff.org/" ref="nofollow noopener noreferrer">EFF Panopticlick</a> - 测试你的浏览器指纹 - 验证状态: ✅</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Famiunique.org%2F" target="_blank" title="https://amiunique.org/" ref="nofollow noopener noreferrer">Am I Unique?</a> - 查看你的指纹独特性 - 验证状态: ✅</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fpdf%2F2409.15656" target="_blank" title="https://arxiv.org/pdf/2409.15656" ref="nofollow noopener noreferrer">约翰霍普金斯大学 2025研究论文</a> - 验证状态: ✅</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fshivankaul.com%2Fblog%2Fbeyond-cookies-browser-fingerprinting-in-2025-1" target="_blank" title="https://shivankaul.com/blog/beyond-cookies-browser-fingerprinting-in-2025-1" ref="nofollow noopener noreferrer">Beyond Cookies: Browser Fingerprinting in 2025</a> - 验证状态: ✅</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FGuardianStack%2Fguardianjs" target="_blank" title="https://github.com/GuardianStack/guardianjs" ref="nofollow noopener noreferrer">GuardianJS Free</a> - 开源指纹库 - 验证状态: ✅</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[rust arena 内存分配]]></title>    <link>https://juejin.cn/post/7603643044034412580</link>    <guid>https://juejin.cn/post/7603643044034412580</guid>    <pubDate>2026-02-07T16:58:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643044034412580" data-draft-id="7603644943351169030" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="rust arena 内存分配"/> <meta itemprop="keywords" content="Rust"/> <meta itemprop="datePublished" content="2026-02-07T16:58:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Andrew_Ryan"/> <meta itemprop="url" content="https://juejin.cn/user/3993068510655703"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            rust arena 内存分配
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3993068510655703/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Andrew_Ryan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T16:58:12.000Z" title="Sat Feb 07 2026 16:58:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Rust 中，<strong>Arena 分配器</strong>是一种特殊的内存分配模式，它会在一个连续的内存区域（称为 Arena）中分配对象，并一次性释放所有对象，而不是单独释放每个对象。这种模式在某些场景下非常高效，比如解析器、编译器中间表示、游戏实体管理等。</p>
<hr/>
<h2 data-id="heading-0">1. <strong>Arena 的核心特点</strong></h2>
<ul>
<li><strong>批量分配，批量释放</strong>：所有分配的对象在 Arena 生命周期结束时一起释放。</li>
<li><strong>避免碎片化</strong>：对象在 Arena 中连续分配，内存布局紧凑。</li>
<li><strong>高性能</strong>：分配操作通常只是移动指针，释放操作是 O(1) 的。</li>
<li><strong>所有权集中</strong>：Arena 拥有其中所有对象的所有权，对象之间可以安全地相互引用。</li>
</ul>
<hr/>
<h2 data-id="heading-1">2. <strong>常见使用场景</strong></h2>
<ul>
<li><strong>AST（抽象语法树）节点</strong>：在编译器/解释器中，AST 节点在解析阶段分配，解析结束后一次性释放。</li>
<li><strong>游戏实体</strong>：一帧中创建的所有游戏对象在帧结束时批量释放。</li>
<li><strong>复杂数据结构</strong>：如链表、图等，其中节点需要相互引用且生命周期一致。</li>
</ul>
<hr/>
<h2 data-id="heading-2">3. <strong>Rust 中的 Arena 实现</strong></h2>
<p>Rust 生态中有几个成熟的 Arena 库：</p>
<h3 data-id="heading-3"><strong>typed-arena</strong></h3>
<p>允许分配单一类型的对象。</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> typed_arena::Arena;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
    value: <span class="hljs-type">i32</span>,
    children: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-symbol">'static</span> Node&gt;, <span class="hljs-comment">// 注意生命周期标记</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">arena</span> = Arena::<span class="hljs-title function_ invoke__">new</span>();
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">child1</span> = arena.<span class="hljs-title function_ invoke__">alloc</span>(Node { value: <span class="hljs-number">1</span>, children: <span class="hljs-built_in">vec!</span>[] });
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">child2</span> = arena.<span class="hljs-title function_ invoke__">alloc</span>(Node { value: <span class="hljs-number">2</span>, children: <span class="hljs-built_in">vec!</span>[] });
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">root</span> = arena.<span class="hljs-title function_ invoke__">alloc</span>(Node {
        value: <span class="hljs-number">0</span>,
        children: <span class="hljs-built_in">vec!</span>[child1, child2],
    });
    
    <span class="hljs-comment">// 所有节点由 arena 统一管理，生命周期相同</span>
    <span class="hljs-comment">// arena 超出作用域时，所有节点一起释放</span>
}
</code></pre>
<h3 data-id="heading-4"><strong>bumpalo</strong></h3>
<p>通用的 bump allocator，支持多类型分配。</p>
<pre><code class="hljs language-ini" lang="ini">use bumpalo::Bump<span class="hljs-comment">;</span>

fn main() {
    let <span class="hljs-attr">bump</span> = Bump::new()<span class="hljs-comment">;</span>
    
    let <span class="hljs-attr">i</span> = bump.alloc(<span class="hljs-number">42</span>)<span class="hljs-comment">;</span>
    let <span class="hljs-attr">s</span> = bump.alloc_str(<span class="hljs-string">"hello"</span>)<span class="hljs-comment">;</span>
    let <span class="hljs-attr">vec</span> = bump.alloc(vec![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-comment">;</span>
    
    // 所有分配的内存由 bump 统一管理
}
</code></pre>
<h3 data-id="heading-5"><strong>自实现简单 Arena</strong></h3>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> std::cell::RefCell;
<span class="hljs-keyword">use</span> std::mem;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SimpleArena</span> {
    chunks: RefCell&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;&gt;&gt;,
    current: RefCell&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;&gt;,
    pos: RefCell&lt;<span class="hljs-type">usize</span>&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">SimpleArena</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            chunks: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()),
            current: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">1024</span>)),
            pos: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>),
        }
    }
    
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">allocate</span>&lt;T&gt;(&amp;<span class="hljs-keyword">self</span>, value: T) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> T {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">size</span> = mem::size_of::&lt;T&gt;();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">align</span> = mem::align_of::&lt;T&gt;();
        
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pos</span> = <span class="hljs-keyword">self</span>.pos.<span class="hljs-title function_ invoke__">borrow_mut</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">current</span> = <span class="hljs-keyword">self</span>.current.<span class="hljs-title function_ invoke__">borrow_mut</span>();
        
        <span class="hljs-comment">// 对齐调整</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">aligned_pos</span> = (*pos + align - <span class="hljs-number">1</span>) &amp; !(align - <span class="hljs-number">1</span>);
        
        <span class="hljs-comment">// 检查当前 chunk 是否有足够空间</span>
        <span class="hljs-keyword">if</span> aligned_pos + size &gt; current.<span class="hljs-title function_ invoke__">capacity</span>() {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">new_chunk</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">1024</span>.<span class="hljs-title function_ invoke__">max</span>(size * <span class="hljs-number">2</span>));
            <span class="hljs-keyword">self</span>.chunks.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> *current, new_chunk));
            *pos = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">allocate</span>(value); <span class="hljs-comment">// 递归重试</span>
        }
        
        <span class="hljs-comment">// 确保有足够容量</span>
        <span class="hljs-keyword">if</span> aligned_pos + size &gt; current.<span class="hljs-title function_ invoke__">len</span>() {
            current.<span class="hljs-title function_ invoke__">resize</span>(aligned_pos + size, <span class="hljs-number">0</span>);
        }
        
        <span class="hljs-comment">// 写入数据</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">ptr</span> = current.<span class="hljs-title function_ invoke__">as_mut_ptr</span>().<span class="hljs-title function_ invoke__">add</span>(aligned_pos);
        <span class="hljs-keyword">unsafe</span> {
            ptr.<span class="hljs-title function_ invoke__">copy_from_nonoverlapping</span>(&amp;value <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> T <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>, size);
            mem::<span class="hljs-title function_ invoke__">forget</span>(value); <span class="hljs-comment">// 防止原值被 drop</span>
            *pos = aligned_pos + size;
            &amp;<span class="hljs-keyword">mut</span> *(ptr <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T)
        }
    }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">arena</span> = SimpleArena::<span class="hljs-title function_ invoke__">new</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">x</span> = arena.<span class="hljs-title function_ invoke__">allocate</span>(<span class="hljs-number">42_i32</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">y</span> = arena.<span class="hljs-title function_ invoke__">allocate</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hello"</span>));
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} {}"</span>, x, y);
    <span class="hljs-comment">// Arena 销毁时，所有内存一次性释放</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-6">4. <strong>生命周期处理</strong></h2>
<p>Arena 分配的对象通常需要与 Arena 本身具有相同的生命周期：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> typed_arena::Arena;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span>&lt;<span class="hljs-symbol">'a</span>&gt; {
    nodes: Arena&lt;Node&lt;<span class="hljs-symbol">'a</span>&gt;&gt;,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&lt;<span class="hljs-symbol">'a</span>&gt; {
    edges: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-symbol">'a</span> Node&lt;<span class="hljs-symbol">'a</span>&gt;&gt;, <span class="hljs-comment">// 可以安全引用同一 arena 中的其他节点</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-7">5. <strong>性能注意事项</strong></h2>
<ul>
<li><strong>分配速度</strong>：Arena 分配通常只是指针移动，比全局分配器快得多。</li>
<li><strong>内存使用</strong>：可能浪费空间（对齐间隙、最后 chunk 未用完的空间）。</li>
<li><strong>释放时机</strong>：只能一次性释放所有对象，不能单独释放。</li>
<li><strong>缓存友好</strong>：连续分配的对象在内存中相邻，缓存局部性好。</li>
</ul>
<hr/>
<h2 data-id="heading-8">6. <strong>与标准分配器的对比</strong></h2>



































<table><thead><tr><th>特性</th><th>Arena</th><th>标准分配器（如 jemalloc）</th></tr></thead><tbody><tr><td>分配速度</td><td>极快（指针移动）</td><td>较慢（系统调用/复杂管理）</td></tr><tr><td>释放速度</td><td>O(1)</td><td>O(n) 或更复杂</td></tr><tr><td>内存碎片</td><td>无内部碎片</td><td>可能有碎片</td></tr><tr><td>灵活性</td><td>只能批量释放</td><td>可单独释放</td></tr><tr><td>适用场景</td><td>同生命周期对象组</td><td>通用场景</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-9">7. <strong>实际应用建议</strong></h2>
<ol>
<li>使用现成的库（如 <code>typed-arena</code>、<code>bumpalo</code>）而非自己实现。</li>
<li>明确对象是否具有相同的生命周期。</li>
<li>注意 Arena 分配的对象不能比 Arena 本身活得久。</li>
<li>对于需要析构的对象，Arena 会正确调用 drop（但释放内存是批量的）。</li>
</ol>
<hr/>
<h2 data-id="heading-10">8. <strong>高级模式：两阶段 Arena</strong></h2>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 第一阶段：分配所有节点</span>
<span class="hljs-comment">// 第二阶段：处理节点间引用</span>
<span class="hljs-comment">// 第三阶段：一次性释放</span>
</code></pre>
<p>Arena 在 Rust 中是处理特定内存管理模式的强大工具，尤其适合编译器、解析器等需要高效分配大量同生命周期对象的场景。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 Rust 内存管理：基于 typed_arena 的指针操作实践]]></title>    <link>https://juejin.cn/post/7603649945978503187</link>    <guid>https://juejin.cn/post/7603649945978503187</guid>    <pubDate>2026-02-07T16:59:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603649945978503187" data-draft-id="7603644943351201798" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 Rust 内存管理：基于 typed_arena 的指针操作实践"/> <meta itemprop="keywords" content="Rust"/> <meta itemprop="datePublished" content="2026-02-07T16:59:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Andrew_Ryan"/> <meta itemprop="url" content="https://juejin.cn/user/3993068510655703"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 Rust 内存管理：基于 typed_arena 的指针操作实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3993068510655703/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Andrew_Ryan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T16:59:03.000Z" title="Sat Feb 07 2026 16:59:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解 Rust 内存管理：基于 typed_arena 的指针操作实践</h2>
<p>在 Rust 编程中，内存安全是核心特性，但直接操作原始指针（<code>*mut T</code>/<code>*const T</code>）时，开发者需要手动把控内存边界和生命周期。本文将基于 <code>typed_arena</code> 库，通过一个完整的「创建-读取-更新-删除（CRUD）」示例，带你理解 Rust 中原始指针的安全使用方式，以及 Arena 内存池的核心价值。</p>
<h3 data-id="heading-1">一、场景背景：为什么用 typed_arena？</h3>
<p>Rust 原生的内存管理（<code>Box</code>/<code>Vec</code>）是「所有权+借用检查」驱动的，但在高频内存分配/释放场景（如编译器、游戏引擎）中，频繁的内存申请会导致性能损耗。</p>
<p><code>typed_arena</code> 是一个轻量级的 Arena 内存池库：</p>
<ul>
<li>一次性申请一块连续内存，后续分配直接从池中获取，减少系统调用；</li>
<li>内存池生命周期结束时批量释放，无需逐个管理对象；</li>
<li>兼容 Rust 的安全语义，同时支持原始指针操作（需手动保证安全）。</li>
</ul>
<h3 data-id="heading-2">二、完整代码实现：指针操作的 CRUD</h3>
<p>先看完整代码，后续逐模块拆解：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> typed_arena::Arena;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// 1. Create (创建) - 分配内存并获取 *mut u8 指针，同时记录字符串长度</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">arena</span>: Arena&lt;<span class="hljs-type">u8</span>&gt; = Arena::<span class="hljs-title function_ invoke__">new</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">hello</span> = arena.<span class="hljs-title function_ invoke__">alloc_str</span>(<span class="hljs-string">"你好 Hello world "</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>: *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span> = hello.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">str_len</span> = hello.<span class="hljs-title function_ invoke__">len</span>(); <span class="hljs-comment">// 记录字符串实际长度，避免越界</span>
    dbg!(s); <span class="hljs-comment">// 打印指针地址</span>

    <span class="hljs-comment">// 2. Read (读取) - 基于字符串实际长度读取，避免越界</span>
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-comment">// 读取单个字节</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">first_byte</span> = *s;
        <span class="hljs-built_in">println!</span>(
            <span class="hljs-string">"读取第一个字节: {} (ASCII: {})"</span>,
            first_byte, first_byte <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>
        );

        <span class="hljs-comment">// 读取整个字符串（基于实际长度，正确处理 UTF-8 编码）</span>
        <span class="hljs-built_in">print!</span>(<span class="hljs-string">"读取整个字符串: "</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">bytes_slice</span> = std::slice::<span class="hljs-title function_ invoke__">from_raw_parts</span>(s, str_len);
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">Ok</span>(utf8_str) = std::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(bytes_slice) {
            <span class="hljs-built_in">print!</span>(<span class="hljs-string">"{}"</span>, utf8_str);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"UTF-8 解析失败"</span>);
        }
        <span class="hljs-built_in">println!</span>();
    }

    <span class="hljs-comment">// 3. Update (更新) - 修改指针指向的内存内容</span>
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-comment">// 修改 ASCII 部分：'H' (在位置 7，跳过 "你好 " 共 7 字节) 改为 'h' (小写)</span>
        <span class="hljs-comment">// "你" (bytes 0-2) + "好" (bytes 3-5) + " " (byte 6) = 7 字节，所以 'H' 在索引 7</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">h_char_ptr</span> = s.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">7</span>);
        *h_char_ptr = <span class="hljs-string">b'h'</span>;
        <span class="hljs-built_in">println!</span>(
            <span class="hljs-string">"更新后第8个字节(位置7): {} (ASCII: {})"</span>,
            *h_char_ptr, *h_char_ptr <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>
        );

        <span class="hljs-comment">// 修改第13个字符（空格）为 '-'</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">space_ptr</span> = s.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">12</span>);
        *space_ptr = <span class="hljs-string">b'-'</span>;
        <span class="hljs-built_in">println!</span>(
            <span class="hljs-string">"更新后第13个字节(位置12): {} (ASCII: {})"</span>,
            *space_ptr, *space_ptr <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>
        );

        <span class="hljs-comment">// 再次读取验证更新结果（基于实际长度，正确处理 UTF-8 编码）</span>
        <span class="hljs-built_in">print!</span>(<span class="hljs-string">"更新后完整字符串: "</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">bytes_slice</span> = std::slice::<span class="hljs-title function_ invoke__">from_raw_parts</span>(s, str_len);
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">Ok</span>(utf8_str) = std::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(bytes_slice) {
            <span class="hljs-built_in">print!</span>(<span class="hljs-string">"{}"</span>, utf8_str);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">print!</span>(<span class="hljs-string">"UTF-8 解析失败，原始字节: "</span>);
            <span class="hljs-keyword">for</span> &amp;byte <span class="hljs-keyword">in</span> bytes_slice.<span class="hljs-title function_ invoke__">iter</span>() {
                <span class="hljs-built_in">print!</span>(<span class="hljs-string">"{:02x} "</span>, byte);
            }
        }
        <span class="hljs-built_in">println!</span>();
    }

    <span class="hljs-comment">// 4. Delete (删除) - 置空指针，由 Arena 管理内存释放</span>
    s = std::ptr::<span class="hljs-title function_ invoke__">null_mut</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"指针置空: {:?}"</span>, s);

    <span class="hljs-comment">// 验证指针置空后无法访问</span>
    <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">is_null</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"指针已置空，无法读取数据"</span>);
    }
}
</code></pre>
<h4 data-id="heading-3">1. 前置准备：依赖引入</h4>
<p>首先在 <code>Cargo.toml</code> 中添加依赖：</p>
<pre><code class="hljs language-toml" lang="toml"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">typed_arena</span> = <span class="hljs-string">"2.0"</span>
</code></pre>
<h4 data-id="heading-4">2. 核心模块拆解</h4>
<h5 data-id="heading-5">（1）Create：内存分配与指针获取</h5>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">arena</span>: Arena&lt;<span class="hljs-type">u8</span>&gt; = Arena::<span class="hljs-title function_ invoke__">new</span>();
<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">hello</span> = arena.<span class="hljs-title function_ invoke__">alloc_str</span>(<span class="hljs-string">"你好 Hello world "</span>);
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>: *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span> = hello.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>;
<span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">str_len</span> = hello.<span class="hljs-title function_ invoke__">len</span>(); <span class="hljs-comment">// 关键：记录长度，避免后续越界</span>
</code></pre>
<ul>
<li><code>Arena::new()</code>：创建一个用于存储 <code>u8</code> 类型的内存池；</li>
<li><code>alloc_str</code>：将字符串按字节（<code>u8</code>）分配到 Arena 中，返回一个 <code>&amp;str</code>；</li>
<li><code>as_ptr() as *mut u8</code>：将不可变指针转为可变原始指针（<code>*mut u8</code>），这是后续修改的基础；</li>
<li>必须记录字符串长度：原始指针本身不携带长度信息，手动记录是避免越界的核心。</li>
</ul>
<h5 data-id="heading-6">（2）Read：安全读取指针指向的内存</h5>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">unsafe</span> {
    <span class="hljs-comment">// 读取单个字节</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">first_byte</span> = *s;
    <span class="hljs-comment">// 读取整个字符串：通过 from_raw_parts 构建切片</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">bytes_slice</span> = std::slice::<span class="hljs-title function_ invoke__">from_raw_parts</span>(s, str_len);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">utf8_str</span> = std::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(bytes_slice);
}
</code></pre>
<ul>
<li>原始指针操作必须包裹在 <code>unsafe</code> 块中：Rust 无法保证指针有效性，需开发者自行负责；</li>
<li><code>std::slice::from_raw_parts</code>：通过「指针+长度」构建切片，是原始指针转为安全切片的关键；</li>
<li><code>std::str::from_utf8</code>：验证字节流是否为合法 UTF-8（避免修改后破坏编码）。</li>
</ul>
<h5 data-id="heading-7">（3）Update：修改指针指向的内存</h5>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">unsafe</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">h_char_ptr</span> = s.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// 指针偏移：跳过前7个字节（"你好 "）</span>
    *h_char_ptr = <span class="hljs-string">b'h'</span>; <span class="hljs-comment">// 修改为小写 h</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">space_ptr</span> = s.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">12</span>);
    *space_ptr = <span class="hljs-string">b'-'</span>; <span class="hljs-comment">// 将空格改为 -</span>
}
</code></pre>
<ul>
<li><code>ptr.add(n)</code>：指针偏移 <code>n</code> 个字节（仅适用于 <code>u8</code>，其他类型需注意内存对齐）；</li>
<li>仅修改 ASCII 字符：中文是多字节 UTF-8 编码，直接修改会破坏编码完整性（示例中刻意避开）；</li>
<li>修改后重新验证 UTF-8：确保修改后的字节流仍能正确解析为字符串。</li>
</ul>
<h5 data-id="heading-8">（4）Delete：指针置空与内存释放</h5>
<pre><code class="hljs language-rust" lang="rust">s = std::ptr::<span class="hljs-title function_ invoke__">null_mut</span>(); <span class="hljs-comment">// 置空指针，避免悬垂</span>
</code></pre>
<ul>
<li>Arena 内存池的核心特性：开发者无需手动释放单个对象，只需保证指针不再被使用；</li>
<li>置空指针：避免后续误操作「悬垂指针」（指向已释放/无效内存的指针）；</li>
<li>内存释放时机：当 <code>arena</code> 超出作用域时，整个内存池会被批量释放。</li>
</ul>
<h3 data-id="heading-9">三、运行结果与分析</h3>
<p>执行代码后，输出如下（指针地址因环境而异）：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">[src/main.rs:9] s = 0x55f8b8a2f200</span>
<span class="hljs-section">读取第一个字节: 228 (ASCII: å)</span>
<span class="hljs-section">读取整个字符串: 你好 Hello world </span>
<span class="hljs-section">更新后第8个字节(位置7): 104 (ASCII: h)</span>
<span class="hljs-section">更新后第13个字节(位置12): 45 (ASCII: -)</span>
<span class="hljs-section">更新后完整字符串: 你好 hello worl- </span>
<span class="hljs-section">指针置空: 0x0</span>
指针已置空，无法读取数据
</code></pre>
<ul>
<li>第一个字节是 <code>228</code>：对应中文「你」的 UTF-8 第一个字节（<code>0xE4</code>），不是可打印 ASCII；</li>
<li>修改后字符串变为 <code>你好 hello worl-</code>：验证了指针修改的有效性；</li>
<li>指针置空后无法访问：避免了悬垂指针风险。</li>
</ul>
<h3 data-id="heading-10">四、关键注意事项</h3>
<ol>
<li>
<p><strong>UTF-8 编码安全</strong>：
中文/多字节字符不能直接修改单个字节，否则会破坏 UTF-8 编码，导致 <code>from_utf8</code> 失败。</p>
</li>
<li>
<p><strong>越界访问风险</strong>：
原始指针操作无边界检查，必须通过 <code>str_len</code> 严格限制访问范围，否则会触发未定义行为。</p>
</li>
<li>
<p><strong>Arena 内存池的生命周期</strong>：
Arena 分配的内存仅在 Arena 生命周期内有效，若 Arena 被释放，指针会变为悬垂指针。</p>
</li>
<li>
<p><strong>unsafe 块的最小化</strong>：
仅将必要的指针操作放入 <code>unsafe</code> 块，减少安全风险。</p>
</li>
</ol>
<h3 data-id="heading-11">五、应用场景</h3>
<ul>
<li><strong>高频内存分配场景</strong>：如编译器的 AST 节点、游戏的实体组件，批量分配/释放提升性能；</li>
<li><strong>需要原始指针的交互场景</strong>：如与 C 语言交互、底层系统编程；</li>
<li><strong>固定生命周期的内存管理</strong>：如单次请求的临时数据，无需逐个释放。</li>
</ul>
<h3 data-id="heading-12">总结</h3>
<ol>
<li><code>typed_arena</code> 提供了高效的批量内存管理方式，适合高频分配/释放场景，且无需手动管理单个对象的释放；</li>
<li>Rust 中原始指针操作必须包裹在 <code>unsafe</code> 块中，需手动保证「长度不越界、编码不破坏、指针不悬垂」；</li>
<li>指针操作的核心安全原则：记录长度、验证编码、及时置空，避免未定义行为。</li>
</ol>
<p>通过这个示例，你不仅能掌握 <code>typed_arena</code> 的使用，更能理解 Rust 内存安全的底层逻辑——即使是 <code>unsafe</code> 操作，也能通过严谨的约束实现安全的内存管理。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Python 教程15】-Python和Web]]></title>    <link>https://juejin.cn/post/7603688142004158473</link>    <guid>https://juejin.cn/post/7603688142004158473</guid>    <pubDate>2026-02-07T18:42:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142004158473" data-draft-id="7603674653152952329" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Python 教程15】-Python和Web"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-07T18:42:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java后端的Ai之路"/> <meta itemprop="url" content="https://juejin.cn/user/1013072340203736"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Python 教程15】-Python和Web
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1013072340203736/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java后端的Ai之路
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T18:42:48.000Z" title="Sat Feb 07 2026 18:42:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读25分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、屏幕抓取：Web 数据的“搬运工”<a id="user-content-scraper" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/861f7cd6e46948bfbc6b398a5e842a60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWQjuerr-eahEFp5LmL6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771094568&amp;x-signature=wLUL8wnsgMitUWmf9iM%2Fvu4kLwE%3D" alt="屏幕抓取动漫图" loading="lazy"/></p>
<blockquote>
<p>想象一下，你是个勤劳的“数据搬运工”，每天的工作就是从浩瀚的互联网海洋里，把那些散落在网页上的“金子”（数据）捞出来，然后整理好，变成自己能用的“宝藏”。这就是<strong>屏幕抓取（Web Scraping）</strong>，也叫网络爬虫，它的核心任务就是：<strong>程序化地下载网页内容，并从中提取你想要的信息</strong>。是不是听起来有点像“黑客帝国”里的 Neo，在数字洪流中捕捉关键信息？</p>
</blockquote>
<h3 data-id="heading-1">1. 正则表达式：快准狠的“文本手术刀”</h3>
<blockquote>
<p>在 Python 的世界里，**正则表达式（Regular Expression，简称 Regex）**就像一把锋利的“手术刀”，能让你在杂乱无章的文本中，精准地切割、匹配、提取出你想要的部分。当网页内容还是一堆“乱码”时，Regex 就是你的“火眼金睛”。</p>
</blockquote>
<p><strong>专业解释</strong>：正则表达式是一种用于匹配字符串模式的强大工具。它通过定义一系列特殊字符和语法规则，来描述字符串的搜索模式，从而实现对文本的查找、替换、提取等操作。在屏幕抓取中，我们常用它来从原始 HTML 文本中匹配特定的数据。</p>
<p><strong>大白话解读</strong>：比如你想从一堆电话号码里找出所有以“138”开头的，或者从一篇文章里找出所有链接，正则表达式就能帮你一秒搞定，比你一个一个找快多了！</p>
<p><strong>生活案例</strong>：就像你在图书馆里找书，不是一本一本翻，而是直接看书架上的分类标签，正则表达式就是那个帮你快速定位的“分类标签”。</p>
<p><strong>示例 Python 代码</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> re
<span class="hljs-keyword">import</span> urllib.request
​
<span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_regex_scraper</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 模拟浏览器请求，获取网页内容</span>
        headers = {<span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'</span>}
        req = urllib.request.Request(url, headers=headers)
        <span class="hljs-keyword">with</span> urllib.request.urlopen(req) <span class="hljs-keyword">as</span> response:
            html_content = response.read().decode(<span class="hljs-string">'utf-8'</span>)
        
        <span class="hljs-comment"># 假设我们要抓取Python Job Board上的职位名称和链接</span>
        <span class="hljs-comment"># 原始链接：http://python.org/jobs</span>
        <span class="hljs-comment"># 注意：实际网站结构可能变化，此代码仅作示例</span>
        pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r'&lt;a href="(/jobs/\d+)/?"&gt;(.*?)&lt;/a&gt;'</span>)
        
        job_listings = pattern.findall(html_content)
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"从 <span class="hljs-subst">{url}</span> 抓取到的职位信息："</span>)
        <span class="hljs-keyword">for</span> job_url_suffix, job_name <span class="hljs-keyword">in</span> job_listings:
            full_job_url = <span class="hljs-string">f"https://www.python.org<span class="hljs-subst">{job_url_suffix}</span>"</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"- <span class="hljs-subst">{job_name}</span> (<span class="hljs-subst">{full_job_url}</span>)"</span>)
            
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"抓取失败：<span class="hljs-subst">{e}</span>"</span>)
​
<span class="hljs-comment"># 运行示例</span>
simple_regex_scraper(<span class="hljs-string">'https://www.python.org/jobs/'</span>)
</code></pre>
<blockquote>
<p><strong>小提示</strong>：正则表达式虽然强大，但面对复杂的 HTML 结构，比如嵌套很深的标签，或者 HTML 本身就不规范时，它可能会让你抓狂。这时候，我们就需要更“温柔”的工具了！</p>
</blockquote>
<h3 data-id="heading-2">2. HTML 解析：优雅地“拆解”网页</h3>
<blockquote>
<p>当网页内容不再是简单的文本，而是结构复杂的 HTML 时，我们就需要一个“结构工程师”来帮助我们理解和拆解它。<strong>HTML 解析</strong>就是把一堆 HTML 代码，变成一个有层级、有关系的“积木模型”，这样我们就能轻松找到想要的“积木”了。</p>
</blockquote>
<p><strong>专业解释</strong>：HTML 解析是将 HTML 文档（通常是字符串形式）转换为一个可操作的数据结构（如 DOM 树），以便程序能够方便地访问、修改和提取文档中的元素、属性和文本内容。这比直接使用正则表达式匹配原始字符串更健壮和灵活。</p>
<p><strong>大白话解读</strong>：就像你拿到一份乐高说明书，HTML 解析就是帮你把说明书上的零件（标签）和组装步骤（结构）理清楚，让你知道哪个零件在哪，怎么拼起来。</p>
<p><strong>生活案例</strong>：你买了一个宜家家具，HTML 解析就像是那个详细的组装说明书，告诉你哪个板子是桌面，哪个是桌腿，以及它们是怎么连接的。</p>
<p><strong>示例 Python 代码（使用 <code>html.parser</code>）</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen
<span class="hljs-keyword">from</span> html.parser <span class="hljs-keyword">import</span> HTMLParser
​
<span class="hljs-keyword">class</span> <span class="hljs-title class_">JobScraper</span>(<span class="hljs-title class_ inherited__">HTMLParser</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        self.in_job_link = <span class="hljs-literal">False</span>
        self.current_job_name = []
        self.job_listings = []
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_starttag</span>(<span class="hljs-params">self, tag, attrs</span>):
        <span class="hljs-keyword">if</span> tag == <span class="hljs-string">'a'</span>:
            attrs_dict = <span class="hljs-built_in">dict</span>(attrs)
            href = attrs_dict.get(<span class="hljs-string">'href'</span>)
            <span class="hljs-comment"># 检查是否是职位链接，这里简化判断，实际可能需要更复杂的逻辑</span>
            <span class="hljs-keyword">if</span> href <span class="hljs-keyword">and</span> <span class="hljs-string">'/jobs/'</span> <span class="hljs-keyword">in</span> href <span class="hljs-keyword">and</span> href.split(<span class="hljs-string">'/'</span>)[-<span class="hljs-number">1</span>].isdigit():
                self.in_job_link = <span class="hljs-literal">True</span>
                self.current_job_url = <span class="hljs-string">f"https://www.python.org<span class="hljs-subst">{href}</span>"</span>
                self.current_job_name = []
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_data</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">if</span> self.in_job_link:
            self.current_job_name.append(data.strip())
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_endtag</span>(<span class="hljs-params">self, tag</span>):
        <span class="hljs-keyword">if</span> tag == <span class="hljs-string">'a'</span> <span class="hljs-keyword">and</span> self.in_job_link:
            job_name = <span class="hljs-string">''</span>.join(self.current_job_name).strip()
            <span class="hljs-keyword">if</span> job_name:
                self.job_listings.append(<span class="hljs-string">f"<span class="hljs-subst">{job_name}</span> (<span class="hljs-subst">{self.current_job_url}</span>)"</span>)
            self.in_job_link = <span class="hljs-literal">False</span>
​
<span class="hljs-keyword">def</span> <span class="hljs-title function_">html_parser_scraper</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">try</span>:
        headers = {<span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'</span>}
        req = urllib.request.Request(url, headers=headers)
        <span class="hljs-keyword">with</span> urllib.request.urlopen(req) <span class="hljs-keyword">as</span> response:
            html_content = response.read().decode(<span class="hljs-string">'utf-8'</span>)
​
        parser = JobScraper()
        parser.feed(html_content)
        parser.close()
​
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n使用 HTMLParser 从 <span class="hljs-subst">{url}</span> 抓取到的职位信息："</span>)
        <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> parser.job_listings:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"- <span class="hljs-subst">{job}</span>"</span>)
​
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"抓取失败：<span class="hljs-subst">{e}</span>"</span>)
​
<span class="hljs-comment"># 运行示例</span>
html_parser_scraper(<span class="hljs-string">'https://www.python.org/jobs/'</span>)
</code></pre>
<blockquote>
<p><strong>温馨提示</strong>：<code>HTMLParser</code> 是 Python 标准库自带的，用起来比较底层，需要自己处理各种标签事件。如果你觉得这有点像“手搓”螺丝，那么接下来要介绍的“电动工具”一定会让你爱不释手！</p>
</blockquote>
<h3 data-id="heading-3">3. Beautiful Soup：应对“脏乱差”网页的“神器”</h3>
<blockquote>
<p>互联网上的网页可不是都那么“规矩”的，很多时候它们就像一堆被熊孩子玩过的乐高积木，缺胳膊少腿，乱七八糟。这时候，<strong>Beautiful Soup</strong> 就闪亮登场了！它是一个专门用来“收拾烂摊子”的工具，即使面对格式再糟糕的 HTML，它也能帮你优雅地解析出来。</p>
</blockquote>
<p><strong>专业解释</strong>：Beautiful Soup 是一个 Python 库，用于从 HTML 或 XML 文件中提取数据。它能够处理不规范的 HTML 标记，并提供简单、Pythonic 的方式来导航、搜索和修改解析树。它构建了一个解析树，使得开发者可以通过标签名、属性、CSS 选择器等多种方式轻松定位元素。</p>
<p><strong>大白话解读</strong>：Beautiful Soup 就像一个“超级保姆”，不管你的 HTML 代码有多“熊”，它都能帮你整理得服服帖帖，让你想找什么数据，就像在自己家里找东西一样简单。</p>
<p><strong>生活案例</strong>：你家孩子把玩具撒了一地，Beautiful Soup 就像那个能自动分类整理玩具的“智能机器人”，把小汽车放一堆，积木放一堆，让你一眼就能找到想要的。</p>
<p><strong>示例 Python 代码</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen
<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup
​
<span class="hljs-keyword">def</span> <span class="hljs-title function_">beautiful_soup_scraper</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">try</span>:
        headers = {<span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'</span>}
        req = urllib.request.Request(url, headers=headers)
        <span class="hljs-keyword">with</span> urllib.request.urlopen(req) <span class="hljs-keyword">as</span> response:
            html_content = response.read()
        
        <span class="hljs-comment"># 使用Beautiful Soup解析HTML</span>
        soup = BeautifulSoup(html_content, <span class="hljs-string">'html.parser'</span>)
        
        job_listings = <span class="hljs-built_in">set</span>()
        <span class="hljs-comment"># 假设职位信息在body的第一个section下的h2标签中，且h2中包含a标签</span>
        <span class="hljs-comment"># 注意：实际网站结构可能变化，此代码仅作示例</span>
        <span class="hljs-comment"># 寻找所有class为'listing-row'的div，或者直接寻找h2标签内的a链接</span>
        <span class="hljs-comment"># 示例：soup.find_all('h2') 或者 soup.select('section.listing-section h2 a')</span>
        
        <span class="hljs-comment"># 针对Python官网jobs页面的结构，我们可以尝试更直接的方式</span>
        <span class="hljs-comment"># 查找所有class为'listing-row'的div，然后从里面提取链接和文本</span>
        <span class="hljs-keyword">for</span> listing <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">'div'</span>, class_=<span class="hljs-string">'listing-row'</span>):
            link_tag = listing.find(<span class="hljs-string">'h2'</span>).find(<span class="hljs-string">'a'</span>)
            <span class="hljs-keyword">if</span> link_tag:
                job_name = link_tag.get_text(strip=<span class="hljs-literal">True</span>)
                job_url_suffix = link_tag.get(<span class="hljs-string">'href'</span>)
                full_job_url = <span class="hljs-string">f"https://www.python.org<span class="hljs-subst">{job_url_suffix}</span>"</span>
                job_listings.add(<span class="hljs-string">f"<span class="hljs-subst">{job_name}</span> (<span class="hljs-subst">{full_job_url}</span>)"</span>)
​
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n使用 Beautiful Soup 从 <span class="hljs-subst">{url}</span> 抓取到的职位信息："</span>)
        <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(job_listings), key=<span class="hljs-built_in">str</span>.lower):
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"- <span class="hljs-subst">{job}</span>"</span>)
            
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"抓取失败：<span class="hljs-subst">{e}</span>"</span>)
​
<span class="hljs-comment"># 运行示例</span>
beautiful_soup_scraper(<span class="hljs-string">'https://www.python.org/jobs/'</span>)
</code></pre>
<blockquote>
<p><strong>总结一下</strong>：屏幕抓取就像是互联网世界的“寻宝游戏”。正则表达式是你的“藏宝图碎片”，帮你识别特定模式；<code>HTMLParser</code> 是你的“放大镜”，帮你细致地查看 HTML 结构；而 <code>Beautiful Soup</code> 则是你的“万能工具箱”，不管遇到多复杂的“宝藏箱”，它都能帮你打开！</p>
</blockquote>
<h2 data-id="heading-4">二、CGI：让你的网页“动”起来<a id="user-content-cgi" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1eeb0a562e2a4ea8b81fc93542bb38aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWQjuerr-eahEFp5LmL6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771094568&amp;x-signature=JmJ8SrDWm4zznyP3IujI1wAW5TY%3D" alt="CGI 动漫图" loading="lazy"/></p>
<blockquote>
<p>如果说屏幕抓取是把别人的网页“搬”回家，那 **CGI（Common Gateway Interface，通用网关接口）**就是让你自己家的网页“活”起来的魔法！静态网页就像一张张精美的海报，虽然好看，但不会对你的任何行为做出反应。而有了 CGI，你的网页就变成了一个能和你互动的“智能机器人”！</p>
</blockquote>
<h3 data-id="heading-5">1. CGI 基础：Web 服务器的“传话筒”</h3>
<blockquote>
<p>想象一下，Web 服务器（比如 Apache）是个“餐厅老板”，它只负责接待客人（用户请求），但不会做菜（处理动态请求）。CGI 脚本就是那个“大厨”，当客人点了份“宫保鸡丁”（提交了一个表单），老板就会通过 CGI 这个“传话筒”，把订单告诉大厨。大厨做好菜后，再通过老板端给客人。</p>
</blockquote>
<p><strong>专业解释</strong>：CGI 是一种标准，定义了 Web 服务器如何与外部脚本（CGI 脚本）进行通信，以处理动态请求。当 Web 服务器收到一个指向 CGI 脚本的请求时，它会执行该脚本，并将请求的详细信息（如表单数据、URL 参数等）作为环境变量或标准输入传递给脚本。脚本处理完请求后，将生成的 HTML 或其他内容作为标准输出返回给 Web 服务器，最终由服务器发送给客户端浏览器。</p>
<p><strong>大白话解读</strong>：你访问一个网站，填了个登录表单，点击“登录”按钮。这时候，Web 服务器就把你的用户名和密码通过 CGI 交给了后台的 Python 脚本。Python 脚本验证了一下，发现你是合法用户，就生成一个“欢迎回来！”的页面，再通过 Web 服务器显示给你看。整个过程，CGI 就是那个负责“沟通”的桥梁。</p>
<p><strong>生活案例</strong>：你去银行 ATM 机取钱，ATM 机就是 Web 服务器，你插卡、输密码就是用户请求。ATM 机本身不处理你的账户信息，它通过一个内部接口（类似 CGI）把你的请求发给银行的后台系统。后台系统验证通过后，告诉 ATM 机吐多少钱，ATM 机再把钱给你。这个内部接口就是 CGI 的角色。</p>
<p><strong>示例 Python 代码（一个简单的 CGI 脚本）</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-comment"># -*- coding: UTF-8 -*-</span>
​
<span class="hljs-comment"># 引入cgi模块，方便处理CGI请求</span>
<span class="hljs-keyword">import</span> cgi
<span class="hljs-keyword">import</span> cgitb
​
<span class="hljs-comment"># 开启调试模式，出错时会在浏览器显示详细信息</span>
cgitb.enable()
​
<span class="hljs-comment"># 创建FieldStorage实例，用于获取表单数据</span>
form = cgi.FieldStorage()
​
<span class="hljs-comment"># 获取表单中名为'name'的字段值</span>
user_name = form.getvalue(<span class="hljs-string">'name'</span>, <span class="hljs-string">'路人甲'</span>)
​
<span class="hljs-comment"># ---- CGI脚本的核心：输出 ----</span>
<span class="hljs-comment"># 1. 首先，必须输出一个Content-type头，告诉浏览器我们发送的是HTML</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Content-type:text/html\n\n"</span>)
​
<span class="hljs-comment"># 2. 接着，输出HTML内容</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"&lt;html&gt;"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"&lt;head&gt;"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"&lt;title&gt;CGI 脚本初体验&lt;/title&gt;"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"&lt;/head&gt;"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"&lt;body&gt;"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"&lt;h2&gt;你好, <span class="hljs-subst">{user_name}</span>! 欢迎来到CGI的魔法世界！&lt;/h2&gt;"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"&lt;/body&gt;"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"&lt;/html&gt;"</span>)
</code></pre>
<blockquote>
<p><strong>注意</strong>：要运行 CGI 脚本，你需要一个配置好的 Web 服务器（如 Apache 或 Nginx），并将脚本放在指定的 <code>cgi-bin</code> 目录下，同时赋予它可执行权限。对于现代 Web 开发来说，直接手写 CGI 已经比较少见了，因为它效率不高，而且每次请求都要创建一个新进程，开销很大。于是，更高级的“烹饪工具”——Web 框架，就应运而生了。</p>
</blockquote>
<h3 data-id="heading-6">2. Python Web 框架：告别“刀耕火种”</h3>
<blockquote>
<p>如果说手写 CGI 是“刀耕火种”，那 <strong>Web 框架</strong>就是现代化的“联合收割机”！它们把 Web 开发的各种脏活累活（比如路由、模板渲染、数据库连接、用户认证等）都帮你封装好了，让你能专注于业务逻辑的实现，而不是天天跟 HTTP 协议和服务器配置打交道。</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9312fc28beb41c9a743101e49f6eba9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWQjuerr-eahEFp5LmL6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771094568&amp;x-signature=rurz6ji%2B4YFDOt4borhjaM1uCas%3D" alt="Flask 动漫图" loading="lazy"/></p>
<p><strong>专业解释</strong>：Web 框架是一套提供了构建 Web 应用所需核心功能的库和工具。它们遵循一定的架构模式（如 MVC 或 MVT），通过提供路由系统、模板引擎、ORM（对象关系映射）、会话管理等组件，极大地简化了 Web 应用的开发流程，提高了开发效率和代码的可维护性。</p>
<p><strong>大白话解读</strong>：你想盖个房子，Web 框架就是那个已经帮你打好地基、建好承重墙、铺好水电管道的“半成品”。你只需要根据自己的喜好，装修一下墙面、摆放家具（编写业务代码）就行了，省时又省力。</p>
<p><strong>生活案例</strong>：你想做一道复杂的佛跳墙，自己从头准备鲍鱼、海参、鱼翅……那得累死。Web 框架就像是超市里卖的“佛跳墙半成品料理包”，所有食材都帮你处理好了，你只需要回家按照说明书，简单加热一下就能享受美味。</p>
<p><strong>示例 Python 代码（使用 Flask 框架）</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 安装Flask: pip install Flask</span>
from flask import Flask, request, render_template_string
​
<span class="hljs-comment"># 创建一个Flask应用实例</span>
<span class="hljs-attr">app</span> = Flask(__name__)
​
<span class="hljs-comment"># 定义一个HTML模板，用于显示欢迎信息</span>
<span class="hljs-attr">HTML_TEMPLATE</span> = <span class="hljs-string">"""
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Flask Web App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;你好, {{ name }}!&lt;/h1&gt;
    &lt;p&gt;欢迎来到Flask的奇妙世界！&lt;/p&gt;
    &lt;form method="post"&gt;
        &lt;label for="name"&gt;输入你的名字:&lt;/label&gt;
        &lt;input type="text" id="name" name="name"&gt;
        &lt;button type="submit"&gt;提交&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
"""</span>
​
<span class="hljs-comment"># 定义路由：当用户访问网站根目录时，执行这个函数</span>
@app.route('/', <span class="hljs-attr">methods</span>=[<span class="hljs-string">'GET'</span>, <span class="hljs-string">'POST'</span>])
def hello():
    <span class="hljs-attr">user_name</span> = <span class="hljs-string">'路人甲'</span>
    if <span class="hljs-attr">request.method</span> == <span class="hljs-string">'POST'</span>:
        <span class="hljs-comment"># 如果是POST请求，就从表单里获取名字</span>
        <span class="hljs-attr">user_name</span> = request.form.get(<span class="hljs-string">'name'</span>, <span class="hljs-string">'路人甲'</span>)
    <span class="hljs-comment"># 使用模板渲染页面，并传入名字</span>
    return render_template_string(HTML_TEMPLATE, <span class="hljs-attr">name</span>=user_name)
​
<span class="hljs-comment"># 如果这个脚本是直接运行的，就启动Web服务器</span>
if <span class="hljs-attr">__name__</span> == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 开启调试模式，这样修改代码后服务器会自动重启</span>
    app.run(<span class="hljs-attr">debug</span>=<span class="hljs-literal">True</span>)
</code></pre>
<blockquote>
<p><strong>小结一下</strong>：CGI 是 Web 动态化的“老祖宗”，它奠定了基础，但现在我们有了更强大的 Web 框架。无论是轻巧灵活的 <strong>Flask</strong>、<strong>FastAPI</strong>，还是功能全面的“巨无霸”<strong>Django</strong>，它们都能让你以前所未有的速度构建出功能强大的 Web 应用。所以，别再纠结于 CGI 的细节了，大胆拥抱 Web 框架吧！</p>
</blockquote>
<h2 data-id="heading-7">三、Web 服务：程序间的“秘密通道”<a id="user-content-web-service" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/57eaab3f3d5b47c99951ac3ed2dd9687~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWQjuerr-eahEFp5LmL6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771094568&amp;x-signature=DmuOkVwmtDWhCtTewRNJjawqorE%3D" alt="Web 服务动漫图" loading="lazy"/></p>
<blockquote>
<p>想象一下，你的程序是个“社交达人”，它不仅能自己处理数据，还想和别的程序“聊天”，交换信息，甚至让别的程序帮它干活。这时候，<strong>Web 服务</strong>就登场了！它就像程序之间约定好的“秘密通道”和“通用语言”，让不同系统、不同语言开发的程序也能无障碍地沟通协作。</p>
</blockquote>
<p><strong>专业解释</strong>：Web 服务是一种基于 Web 的、可编程的应用程序组件，它允许不同应用程序之间通过网络进行交互。它通常使用标准化的协议（如 HTTP、XML、JSON）来传输数据，并提供一套接口供其他应用程序调用，从而实现分布式计算和系统集成。</p>
<p><strong>大白话解读</strong>：你的手机 App 想知道今天的天气，它不会自己去测量气温、风速，而是会去问“天气预报服务”这个专门提供天气信息的“程序”。这个“问”和“答”的过程，就是 Web 服务在发挥作用。</p>
<p><strong>生活案例</strong>：你用支付宝或者微信支付，你的支付 App 并没有直接和银行的系统打交道，而是通过调用银行提供的支付 Web 服务来完成交易。Web 服务就像一个“翻译官”，让不同“国家”（系统）的程序能够互相理解。</p>
<h3 data-id="heading-8">1. XML-RPC 与 SOAP：远程调用的“双雄”</h3>
<blockquote>
<p>在 Web 服务的早期，<strong>XML-RPC</strong> 和 <strong>SOAP</strong> 是两个非常流行的“老牌选手”。它们都致力于解决一个核心问题：如何让一个程序调用另一个远程程序的功能，就像调用本地函数一样简单。</p>
</blockquote>
<p><strong>专业解释</strong>：</p>
<ul>
<li><strong>XML-RPC</strong>（XML Remote Procedure Call）是一种基于 XML 和 HTTP 的轻量级远程过程调用协议。它允许客户端程序调用远程服务器上的函数或方法，并将请求和响应数据封装在 XML 格式中，通过 HTTP 进行传输。它的特点是简单、易于实现。</li>
<li><strong>SOAP</strong>（Simple Object Access Protocol）也是一种基于 XML 的协议，用于在分布式环境中交换结构化信息。与 XML-RPC 相比，SOAP 更为复杂和强大，它支持更丰富的数据类型、更复杂的传输机制（如 HTTP、SMTP 等），并提供了更严格的规范和安全性特性。SOAP 通常与 WSDL（Web Services Description Language）结合使用，WSDL 用于描述 Web 服务的接口和操作。</li>
</ul>
<p><strong>大白话解读</strong>：</p>
<ul>
<li><strong>XML-RPC</strong> 就像是两个朋友之间用“明信片”交流，明信片上写着“请帮我做这件事”，然后寄过去，收到回信就知道结果了。简单直接。</li>
<li><strong>SOAP</strong> 则像是一份严谨的“外交公文”，里面不仅详细说明了“请帮我做这件事”，还规定了公文的格式、加密方式、谁来签收等等。虽然有点繁琐，但非常正式和安全。</li>
</ul>
<p><strong>示例 Python 代码（XML-RPC 客户端）</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 假设有一个XML-RPC服务器运行在 http://localhost:8000/RPC2</span>
<span class="hljs-comment"># 服务器端代码（例如：server.py）可能如下：</span>
<span class="hljs-comment"># from xmlrpc.server import SimpleXMLRPCServer</span>
<span class="hljs-comment"># def add(x, y): return x + y</span>
<span class="hljs-comment"># server = SimpleXMLRPCRPCServer(("localhost", 8000))</span>
<span class="hljs-comment"># server.register_function(add, "add")</span>
<span class="hljs-comment"># server.serve_forever()</span>
​
<span class="hljs-keyword">import</span> xmlrpc.client
​
<span class="hljs-keyword">def</span> <span class="hljs-title function_">xmlrpc_client_example</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 连接到XML-RPC服务器</span>
        proxy = xmlrpc.client.ServerProxy(<span class="hljs-string">"http://localhost:8000/RPC2"</span>)
        
        <span class="hljs-comment"># 调用远程服务器上的add方法</span>
        result = proxy.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"XML-RPC 调用结果：5 + 3 = <span class="hljs-subst">{result}</span>"</span>)
        
        <span class="hljs-comment"># 尝试调用一个不存在的方法</span>
        <span class="hljs-keyword">try</span>:
            proxy.subtract(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">except</span> xmlrpc.client.Fault <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"XML-RPC 错误示例：<span class="hljs-subst">{e}</span>"</span>)
​
    <span class="hljs-keyword">except</span> ConnectionRefusedError:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"错误：无法连接到XML-RPC服务器。请确保服务器已启动并运行在 http://localhost:8000/RPC2"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"发生错误：<span class="hljs-subst">{e}</span>"</span>)
​
<span class="hljs-comment"># 运行示例</span>
<span class="hljs-comment"># xmlrpc_client_example() # 运行时请确保有XML-RPC服务器在运行</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"XML-RPC 客户端示例代码已准备好，请启动一个XML-RPC服务器后尝试运行。"</span>)
</code></pre>
<blockquote>
<p><strong>小提示</strong>：虽然 XML-RPC 和 SOAP 在历史上扮演了重要角色，但它们在现代 Web 开发中已经逐渐被更轻量级、更灵活的技术所取代，比如接下来要介绍的 RESTful API。</p>
</blockquote>
<h3 data-id="heading-9">2. RESTful API：现代 Web 服务的“王者”</h3>
<blockquote>
<p>如果说 XML-RPC 和 SOAP 是“传统武术”，那 <strong>RESTful API</strong> 就是 Web 服务领域的“现代格斗术”！它更简洁、更高效、更符合 Web 的本质，已经成为构建现代 Web 服务的主流方式。</p>
</blockquote>
<p><strong>专业解释</strong>：REST（Representational State Transfer，表述性状态转移）是一种架构风格，而不是协议。RESTful API 是遵循 REST 架构风格的 API 设计。它主要基于 HTTP 协议，利用 HTTP 方法（GET、POST、PUT、DELETE 等）对资源进行操作，并通过 URL 来标识资源。数据通常以 JSON 或 XML 格式传输，具有无状态性、统一接口、分层系统等特点。</p>
<p><strong>大白话解读</strong>：你把 Web 看作一个巨大的图书馆，每本书（资源）都有一个唯一的编号（URL）。你想看书（GET），就告诉管理员书的编号；你想借书（POST），就告诉管理员书的编号和你的信息；你想更新书的信息（PUT），就告诉管理员书的编号和新的信息；你想还书（DELETE），就告诉管理员书的编号。整个过程非常直观，就像和图书馆管理员打交道一样。</p>
<p><strong>生活案例</strong>：你用外卖 App 点餐，App 会向外卖平台的 API 发送一个请求（POST），告诉它你要点什么菜、送到哪里。外卖平台收到请求后，处理订单，然后通过 API 返回一个订单成功的消息。这个过程就是典型的 RESTful API 交互。</p>
<p><strong>示例 Python 代码（使用 <code>requests</code> 库调用 RESTful API）</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
​
<span class="hljs-keyword">def</span> <span class="hljs-title function_">rest_api_example</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 假设我们调用一个公共的API，例如获取GitHub用户信息</span>
        username = <span class="hljs-string">"octocat"</span> <span class="hljs-comment"># GitHub的默认测试用户</span>
        api_url = <span class="hljs-string">f"https://api.github.com/users/<span class="hljs-subst">{username}</span>"</span>
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"正在从 <span class="hljs-subst">{api_url}</span> 获取用户信息..."</span>)
        
        <span class="hljs-comment"># 发送GET请求</span>
        response = requests.get(api_url)
        
        <span class="hljs-comment"># 检查请求是否成功 (状态码200)</span>
        response.raise_for_status() 
        
        <span class="hljs-comment"># 解析JSON响应</span>
        user_data = response.json()
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n获取到的用户信息："</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户名: <span class="hljs-subst">{user_data.get(<span class="hljs-string">"login"</span>)}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"姓名: <span class="hljs-subst">{user_data.get(<span class="hljs-string">"name"</span>, <span class="hljs-string">"N/A"</span>)}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"公司: <span class="hljs-subst">{user_data.get(<span class="hljs-string">"company"</span>, <span class="hljs-string">"N/A"</span>)}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"粉丝数: <span class="hljs-subst">{user_data.get(<span class="hljs-string">"followers"</span>)}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"关注数: <span class="hljs-subst">{user_data.get(<span class="hljs-string">"following"</span>)}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"个人主页: <span class="hljs-subst">{user_data.get(<span class="hljs-string">"html_url"</span>)}</span>"</span>)
        
    <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"请求GitHub API失败：<span class="hljs-subst">{e}</span>"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"发生错误：<span class="hljs-subst">{e}</span>"</span>)
​
<span class="hljs-comment"># 运行示例</span>
rest_api_example()
</code></pre>
<blockquote>
<p><strong>总结一下</strong>：Web 服务让程序之间能够“手拉手”一起干活，XML-RPC 和 SOAP 是早期的“握手方式”，而 RESTful API 则是现代程序之间最流行的“社交礼仪”。掌握了它们，你的程序就能在互联网上“呼风唤雨”了！</p>
</blockquote>
<h2 data-id="heading-10">四、拓展方案：让你的技能包更“鼓”<a id="user-content-expansion" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></h2>
<blockquote>
<p>学完了基础知识，是不是觉得意犹未尽？别急，Python 在 Web 领域的“十八般武艺”可不止这些！接下来，我们再来看看几个能让你在 Web 世界里“如虎添翼”的进阶技能，让你的技能包瞬间“鼓”起来！</p>
</blockquote>
<h3 data-id="heading-11">1. Scrapy 框架：工业级爬虫利器</h3>
<blockquote>
<p>如果说 Beautiful Soup 是“万能工具箱”，那 <strong>Scrapy</strong> 就是“全自动生产线”！当你需要大规模、高效率地从网站上抓取数据时，Scrapy 就是你的不二之选。它是一个功能强大、高度可定制的 Python 爬虫框架，专为数据抓取和处理而生。</p>
</blockquote>
<p><strong>专业解释</strong>：Scrapy 是一个用于抓取网站并从网页中提取结构化数据的应用框架。它提供了一整套组件，包括调度器、下载器、爬虫、管道等，支持异步请求处理，能够高效地处理大量并发请求，并提供了强大的数据处理和存储机制。</p>
<p><strong>大白话解读</strong>：你不是想“搬运”数据吗？Scrapy 就是那个能帮你搭建一个“自动化数据工厂”的框架。你告诉它去哪里“搬”，搬什么，怎么“搬”，它就能自己吭哧吭哧地帮你把数据搬回来，而且搬得又快又好，还能帮你把数据整理得整整齐齐。</p>
<p><strong>生活案例</strong>：你开了一家电商网站，想知道竞争对手的商品价格和库存。如果手动去查，那得查到猴年马月。Scrapy 就像你的“商业情报机器人”，能自动帮你监控竞争对手的网站，把所有商品信息都抓回来，让你随时掌握市场动态。</p>
<p><strong>示例 Python 代码（Scrapy 项目结构和核心代码片段）</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Scrapy项目通常通过命令行创建：scrapy startproject myproject</span>
<span class="hljs-comment"># 这是一个Scrapy爬虫的核心代码片段 (myproject/spiders/example_spider.py)</span>
​
<span class="hljs-keyword">import</span> scrapy
​
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleSpider</span>(scrapy.Spider):
    name = <span class="hljs-string">"example"</span>
    allowed_domains = [<span class="hljs-string">"quotes.toscrape.com"</span>]
    start_urls = [<span class="hljs-string">"http://quotes.toscrape.com/"</span>,]
​
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):
        <span class="hljs-comment"># 提取名言和作者</span>
        <span class="hljs-keyword">for</span> quote <span class="hljs-keyword">in</span> response.css(<span class="hljs-string">"div.quote"</span>):
            <span class="hljs-keyword">yield</span> {
                <span class="hljs-string">"text"</span>: quote.css(<span class="hljs-string">"span.text::text"</span>).get(),
                <span class="hljs-string">"author"</span>: quote.css(<span class="hljs-string">"small.author::text"</span>).get(),
                <span class="hljs-string">"tags"</span>: quote.css(<span class="hljs-string">"div.tags a.tag::text"</span>).getall(),
            }
        
        <span class="hljs-comment"># 翻页逻辑</span>
        next_page = response.css(<span class="hljs-string">"li.next a::attr(href)"</span>).get()
        <span class="hljs-keyword">if</span> next_page <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">yield</span> response.follow(next_page, callback=self.parse)
​
<span class="hljs-comment"># 运行Scrapy爬虫：在项目根目录执行 scrapy crawl example</span>
</code></pre>
<blockquote>
<p><strong>Scrapy 小贴士</strong>：Scrapy 的强大之处在于其高度的模块化和可扩展性。你可以自定义下载中间件、爬虫中间件、管道等，实现各种复杂的抓取逻辑和数据处理需求。对于需要处理反爬、分布式抓取等高级场景，Scrapy 绝对是你的得力助手！</p>
</blockquote>
<h3 data-id="heading-12">2. FastAPI：打造高性能 API 的“新贵”</h3>
<blockquote>
<p>如果你觉得 Flask 已经很棒了，那 <strong>FastAPI</strong> 会让你惊呼“还有这种操作？！”。它是一个现代、快速（高性能）、基于 Python 标准类型提示的 Web 框架，用于构建 API。如果你想快速开发高性能的 API 服务，FastAPI 绝对是你的“心头好”。</p>
</blockquote>
<p><strong>专业解释</strong>：FastAPI 是一个高性能的 Web 框架，它基于 Starlette（用于 Web 部分）和 Pydantic（用于数据验证和序列化）。它利用 Python 3.6+ 的类型提示，自动生成 OpenAPI（以前称为 Swagger）文档，并提供数据验证、依赖注入等功能，使得 API 开发变得极其高效和愉快。</p>
<p><strong>大白话解读</strong>：你想开个“数据接口商店”，让别人能方便地从你这里获取数据。FastAPI 就像一个“智能店长”，你告诉它你的“商品”（数据接口）长什么样，它就能自动帮你把“商品说明书”（API 文档）写好，还能帮你检查顾客的“订单”（请求参数）是不是合规，确保你的“商店”高效运转。</p>
<p><strong>生活案例</strong>：你开发了一个 App，需要从服务器获取用户数据、商品列表等。FastAPI 就是那个帮你搭建“数据中转站”的工具，它能以闪电般的速度响应 App 的请求，让你的 App 体验飞沙走石。</p>
<p><strong>示例 Python 代码</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 安装FastAPI和Uvicorn: pip install fastapi uvicorn</span>
<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel

<span class="hljs-comment"># 创建FastAPI应用实例</span>
app = FastAPI()

<span class="hljs-comment"># 定义请求体的数据模型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>
    price: <span class="hljs-built_in">float</span>
    is_offer: <span class="hljs-built_in">bool</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>

<span class="hljs-comment"># 定义一个根路径的GET请求</span>
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_root</span>():
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"message"</span>: <span class="hljs-string">"欢迎来到FastAPI的世界！"</span>}

<span class="hljs-comment"># 定义一个带路径参数的GET请求</span>
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/items/{item_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span>, q: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"item_id"</span>: item_id, <span class="hljs-string">"q"</span>: q}

<span class="hljs-comment"># 定义一个POST请求，接收JSON数据</span>
<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">"/items/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">item: Item</span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"message"</span>: <span class="hljs-string">"Item received"</span>, <span class="hljs-string">"item"</span>: item}

<span class="hljs-comment"># 运行FastAPI应用：uvicorn main:app --reload</span>
</code></pre>
<blockquote>
<p><strong>FastAPI 的魅力</strong>：FastAPI 的自动文档生成功能简直是开发者的福音！你不需要额外编写 API 文档，它会根据你的代码自动生成交互式的 Swagger UI 和 ReDoc 文档，让你的 API 接口一目了然。同时，其异步支持也让它在处理高并发场景时表现出色。</p>
</blockquote>
<h3 data-id="heading-13">3. Selenium：驾驭“动态”网页的“终极武器”</h3>
<blockquote>
<p>现在的网页越来越“聪明”，很多内容都是通过 JavaScript 动态加载的，或者需要你点击、滚动才能显示出来。这时候，传统的屏幕抓取工具可能就“傻眼”了。别担心，<strong>Selenium</strong> 就是那个能让你“模拟真人”操作浏览器的“终极武器”！</p>
</blockquote>
<p><strong>专业解释</strong>：Selenium 是一个用于 Web 应用程序测试的工具，但它也可以被广泛应用于 Web 抓取。它允许开发者通过编程方式控制浏览器（如 Chrome、Firefox），模拟用户的各种行为，如点击按钮、填写表单、执行 JavaScript、滚动页面等，从而获取动态加载的内容。</p>
<p><strong>大白话解读</strong>：有些网站很“狡猾”，你直接用代码去访问，它给你看的是“毛坯房”，什么都没有。但你用浏览器打开，它就给你装修得漂漂亮亮。Selenium 就是那个能帮你“开着浏览器”去访问网站的工具，它能像真人一样点击、输入、等待，直到所有内容都加载出来，然后你再“截图”（抓取数据）。</p>
<p><strong>生活案例</strong>：你想抢购某个限量商品，但商品页面需要登录、点击多个按钮、等待加载才能看到抢购按钮。Selenium 就像你的“自动抢购机器人”，它能自动帮你完成所有这些操作，甚至比你手动操作还快！</p>
<p><strong>示例 Python 代码</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 安装Selenium和对应浏览器的WebDriver：pip install selenium</span>
<span class="hljs-comment"># 需要下载对应浏览器的WebDriver，例如ChromeDriver，并将其路径添加到系统PATH中</span>

<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait
<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">def</span> <span class="hljs-title function_">selenium_example</span>():
    <span class="hljs-comment"># 初始化Chrome浏览器驱动</span>
    <span class="hljs-comment"># 确保你的ChromeDriver路径正确，或者已添加到系统PATH</span>
    driver = webdriver.Chrome()
    driver.maximize_window() <span class="hljs-comment"># 最大化窗口，有时有助于避免元素不可见问题</span>

    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 访问一个需要动态加载内容的网站，这里以一个简单的示例网站代替</span>
        <span class="hljs-comment"># 实际应用中，可以是需要登录、点击加载更多的网站</span>
        driver.get(<span class="hljs-string">"https://www.python.org/"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"成功访问：<span class="hljs-subst">{driver.current_url}</span>"</span>)

        <span class="hljs-comment"># 等待某个元素加载完成，例如等待导航栏的某个链接出现</span>
        <span class="hljs-comment"># WebDriverWait(driver, 10).until(</span>
        <span class="hljs-comment">#     EC.presence_of_element_located((By.ID, "id-of-an-element"))</span>
        <span class="hljs-comment"># )</span>
        
        <span class="hljs-comment"># 模拟点击某个链接，例如点击"About"菜单</span>
        about_link = driver.find_element(By.LINK_TEXT, <span class="hljs-string">"About"</span>)
        about_link.click()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"点击了About链接"</span>)
        
        <span class="hljs-comment"># 等待页面跳转或内容加载</span>
        time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 简单的等待，实际应使用WebDriverWait</span>
        
        <span class="hljs-comment"># 获取当前页面的标题</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"当前页面标题：<span class="hljs-subst">{driver.title}</span>"</span>)
        
        <span class="hljs-comment"># 获取页面内容（包括JS渲染后的）</span>
        <span class="hljs-comment"># page_source = driver.page_source</span>
        <span class="hljs-comment"># print(page_source[:500]) # 打印前500个字符</span>

    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Selenium操作失败：<span class="hljs-subst">{e}</span>"</span>)
    <span class="hljs-keyword">finally</span>:
        <span class="hljs-comment"># 关闭浏览器</span>
        driver.quit()

<span class="hljs-comment"># 运行示例</span>
selenium_example()
</code></pre>
<blockquote>
<p><strong>Selenium 的强大</strong>：Selenium 不仅能抓取数据，还能用于自动化测试、模拟用户行为等。当你需要处理验证码、登录、点击、滚动等复杂交互时，Selenium 就是你的“瑞士军刀”。但它也有缺点，就是运行速度相对较慢，资源消耗较大，因为它需要真正启动一个浏览器。</p>
</blockquote>
<h2 data-id="heading-14">五、总结与互动：是时候展现真正的技术了！<a id="user-content-summary-interaction" title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target="/></h2>
<blockquote>
<p>好了，各位编程小能手们，今天的 Python Web 之旅就到这里啦！我们一起探索了如何从 Web 世界“捞金”（屏幕抓取），如何让你的网页“活”起来（CGI 与 Web 框架），以及如何让程序之间“隔空对话”（Web 服务）。是不是感觉 Python 在 Web 领域简直是无所不能？</p>
</blockquote>
<blockquote>
<p>从最初的正则表达式“文本手术刀”，到 Beautiful Soup 的“万能工具箱”，再到 Web 框架的“自动化生产线”，以及 Web 服务的“秘密通道”，Python 为我们打开了通往 Web 世界的大门。无论是想成为一个数据侦探，还是一个 Web 应用架构师，亦或是一个 API 设计师，Python 都能助你一臂之力！</p>
</blockquote>
<blockquote>
<p><strong>现在，是时候展现真正的技术了！</strong></p>
</blockquote>
<blockquote>
<ol>
<li><strong>你最喜欢 Python 在 Web 领域的哪个“超能力”？</strong> 是屏幕抓取的“数据魔法”，还是 Web 框架的“建站神速”？在评论区告诉我你的选择和理由吧！</li>
<li><strong>你有没有遇到过特别“奇葩”的网页，让你抓取数据抓到头秃？</strong> 快来分享你的“血泪史”和解决方案，让大家一起避坑！</li>
<li><strong>对于今天讲到的内容，你还有哪些“脑洞大开”的拓展想法？</strong> 比如，除了爬虫，你还想用 Python 在 Web 上玩出什么新花样？</li>
</ol>
</blockquote>
<blockquote>
<p>期待在评论区看到你们的精彩留言，一起交流，一起进步！</p>
</blockquote>
<p><strong>转载声明</strong>：</p>
<p>本文为原创文章，版权归 <strong>Java 后端的 Ai 之路</strong> 所有。欢迎转载，转载请务必注明出处，并附上原文链接。未经授权，禁止用于商业用途。如有侵权，必将追究法律责任。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go 嵌入结构体方法访问全解析：从基础到进阶陷阱]]></title>    <link>https://juejin.cn/post/7603688142004289545</link>    <guid>https://juejin.cn/post/7603688142004289545</guid>    <pubDate>2026-02-08T01:21:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142004289545" data-draft-id="7600752623068397578" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go 嵌入结构体方法访问全解析：从基础到进阶陷阱"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T01:21:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="golang学习记"/> <meta itemprop="url" content="https://juejin.cn/user/4371313964100990"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go 嵌入结构体方法访问全解析：从基础到进阶陷阱
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4371313964100990/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    golang学习记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T01:21:07.000Z" title="Sun Feb 08 2026 01:21:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>核心概念</strong>：Go 的嵌入（embedding）不是继承，而是<strong>组合的语法糖</strong>。理解这一点，才能避免 90% 的嵌入陷阱。</p>
</blockquote>
<h2 data-id="heading-0">一、嵌入基础：什么是结构体嵌入？</h2>
<h3 data-id="heading-1">1.1 嵌入 vs 继承</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// Java/C++ 风格的继承（Go 不支持！）</span>
class Animal {
    void eat() { ... }
}

class Dog extends Animal {  <span class="hljs-comment">// 继承</span>
    void bark() { ... }
}

<span class="hljs-comment">// Go 风格的嵌入（组合）</span>
<span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> {
    name <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Animal)</span></span> Eat() {
    fmt.Printf(<span class="hljs-string">"%s is eating\n"</span>, a.name)
}

<span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> {
    Animal  <span class="hljs-comment">// 嵌入，不是继承！</span>
    breed  <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Bark() {
    fmt.Printf(<span class="hljs-string">"%s is barking\n"</span>, d.name)
}
</code></pre>
<p><strong>关键区别</strong>：</p>






























<table><thead><tr><th>特性</th><th>继承（OOP）</th><th>嵌入（Go）</th></tr></thead><tbody><tr><td><strong>关系</strong></td><td>"is-a"（狗是一种动物）</td><td>"has-a"（狗有一个动物）</td></tr><tr><td><strong>方法集</strong></td><td>子类继承父类所有方法</td><td>外层结构体"提升"内层方法</td></tr><tr><td><strong>多态</strong></td><td>支持（虚函数）</td><td>不支持（无类型层次）</td></tr><tr><td><strong>耦合度</strong></td><td>高（紧耦合）</td><td>低（松耦合）</td></tr></tbody></table>
<h3 data-id="heading-2">1.2 嵌入的三种写法</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Base <span class="hljs-keyword">struct</span> {
    value <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Base)</span></span> Method() {
    fmt.Println(<span class="hljs-string">"Base.Method:"</span>, b.value)
}

<span class="hljs-comment">// 写法1：匿名嵌入（最常用）</span>
<span class="hljs-keyword">type</span> Embedded1 <span class="hljs-keyword">struct</span> {
    Base  <span class="hljs-comment">// 匿名字段</span>
}

<span class="hljs-comment">// 写法2：命名嵌入（显式字段名）</span>
<span class="hljs-keyword">type</span> Embedded2 <span class="hljs-keyword">struct</span> {
    base Base  <span class="hljs-comment">// 命名字段</span>
}

<span class="hljs-comment">// 写法3：接口嵌入</span>
<span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> {
    Get() <span class="hljs-type">int</span>
}

<span class="hljs-keyword">type</span> Impl <span class="hljs-keyword">struct</span> {
    Getter  <span class="hljs-comment">// 嵌入接口</span>
}
</code></pre>
<h2 data-id="heading-3">二、方法访问规则：提升（Promotion）机制</h2>
<h3 data-id="heading-4">2.1 匿名嵌入：方法自动"提升"</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> {
    Name <span class="hljs-type">string</span>
    Age  <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SayHello() {
    fmt.Printf(<span class="hljs-string">"Hello, I'm %s, %d years old\n"</span>, p.Name, p.Age)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Work() {
    fmt.Printf(<span class="hljs-string">"%s is working\n"</span>, p.Name)
}

<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> {
    Person      <span class="hljs-comment">// 匿名嵌入</span>
    Company     <span class="hljs-type">string</span>
    Salary      <span class="hljs-type">float64</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> GetSalary() <span class="hljs-type">float64</span> {
    <span class="hljs-keyword">return</span> e.Salary
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    emp := Employee{
        Person:  Person{Name: <span class="hljs-string">"Alice"</span>, Age: <span class="hljs-number">30</span>},
        Company: <span class="hljs-string">"Tech Corp"</span>,
        Salary:  <span class="hljs-number">80000</span>,
    }
    
    <span class="hljs-comment">// ✅ 可以直接调用提升的方法</span>
    emp.SayHello()   <span class="hljs-comment">// Hello, I'm Alice, 30 years old</span>
    emp.Work()       <span class="hljs-comment">// Alice is working</span>
    emp.GetSalary()  <span class="hljs-comment">// 80000</span>
    
    <span class="hljs-comment">// ✅ 也可以通过嵌入类型名访问</span>
    emp.Person.SayHello()  <span class="hljs-comment">// 效果相同</span>
    
    <span class="hljs-comment">// ✅ 访问嵌入字段</span>
    fmt.Println(emp.Name)      <span class="hljs-comment">// Alice</span>
    fmt.Println(emp.Person.Name) <span class="hljs-comment">// Alice（等价）</span>
}
</code></pre>
<p><strong>提升规则</strong>：</p>
<ol>
<li>匿名嵌入的字段和方法<strong>自动提升</strong>到外层结构体</li>
<li>提升的方法调用时，接收者是<strong>外层结构体的嵌入字段副本</strong></li>
<li>外层结构体可以<strong>覆盖（shadow）</strong> 提升的方法</li>
</ol>
<h3 data-id="heading-5">2.2 命名嵌入：必须通过字段名访问</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Employee2 <span class="hljs-keyword">struct</span> {
    person  Person  <span class="hljs-comment">// 命名字段，不会提升</span>
    Company <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    emp := Employee2{
        person:  Person{Name: <span class="hljs-string">"Bob"</span>, Age: <span class="hljs-number">25</span>},
        Company: <span class="hljs-string">"Startup Inc"</span>,
    }
    
    <span class="hljs-comment">// ❌ 编译错误：SayHello 未提升</span>
    <span class="hljs-comment">// emp.SayHello()</span>
    
    <span class="hljs-comment">// ✅ 必须通过字段名访问</span>
    emp.person.SayHello()  <span class="hljs-comment">// Hello, I'm Bob, 25 years old</span>
    fmt.Println(emp.person.Name)  <span class="hljs-comment">// Bob</span>
}
</code></pre>
<h2 data-id="heading-6">三、深入陷阱：嵌入的 5 大坑点</h2>
<h3 data-id="heading-7">坑点1️⃣：值接收者 vs 指针接收者</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> {
    count <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Counter)</span></span> GetValue() <span class="hljs-type">int</span> {  <span class="hljs-comment">// 值接收者</span>
    <span class="hljs-keyword">return</span> c.count
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Increment() {  <span class="hljs-comment">// 指针接收者</span>
    c.count++
}

<span class="hljs-keyword">type</span> Widget <span class="hljs-keyword">struct</span> {
    Counter  <span class="hljs-comment">// 嵌入</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 情况1：值类型嵌入</span>
    w1 := Widget{Counter: Counter{count: <span class="hljs-number">0</span>}}
    fmt.Println(w1.GetValue())  <span class="hljs-comment">// ✅ 0（值接收者，可以调用）</span>
    <span class="hljs-comment">// w1.Increment()  // ❌ 编译错误！w1是值，不能调用指针接收者方法</span>
    
    <span class="hljs-comment">// 情况2：指针类型嵌入</span>
    w2 := &amp;Widget{Counter: Counter{count: <span class="hljs-number">0</span>}}
    fmt.Println(w2.GetValue())  <span class="hljs-comment">// ✅ 0</span>
    w2.Increment()              <span class="hljs-comment">// ✅ 可以调用</span>
    fmt.Println(w2.GetValue())  <span class="hljs-comment">// 1</span>
    
    <span class="hljs-comment">// 情况3：外层是指针，内层是值</span>
    w3 := &amp;Widget{Counter: Counter{count: <span class="hljs-number">0</span>}}
    w3.Increment()  <span class="hljs-comment">// ✅ 可以！Go 自动解引用</span>
    <span class="hljs-comment">// 等价于：(&amp;w3.Counter).Increment()</span>
}
</code></pre>
<p><strong>规则总结</strong>：</p>






























<table><thead><tr><th>外层类型</th><th>内层方法接收者</th><th>能否调用</th></tr></thead><tbody><tr><td>值</td><td>值</td><td>✅</td></tr><tr><td>值</td><td>指针</td><td>❌</td></tr><tr><td>指针</td><td>值</td><td>✅（自动解引用）</td></tr><tr><td>指针</td><td>指针</td><td>✅</td></tr></tbody></table>
<h3 data-id="heading-8">坑点2️⃣：方法覆盖（Shadowing）</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Base <span class="hljs-keyword">struct</span> {
    value <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Base)</span></span> Show() {
    fmt.Printf(<span class="hljs-string">"Base.Show: %d\n"</span>, b.value)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Base)</span></span> GetValue() <span class="hljs-type">int</span> {
    <span class="hljs-keyword">return</span> b.value
}

<span class="hljs-keyword">type</span> Derived <span class="hljs-keyword">struct</span> {
    Base
    extra <span class="hljs-type">string</span>
}

<span class="hljs-comment">// 覆盖 Show 方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Derived)</span></span> Show() {
    fmt.Printf(<span class="hljs-string">"Derived.Show: %d, %s\n"</span>, d.value, d.extra)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    d := Derived{
        Base:  Base{value: <span class="hljs-number">42</span>},
        extra: <span class="hljs-string">"hello"</span>,
    }
    
    d.Show()        <span class="hljs-comment">// ✅ Derived.Show: 42, hello（覆盖）</span>
    d.GetValue()    <span class="hljs-comment">// ✅ Base.GetValue: 42（继承）</span>
    
    <span class="hljs-comment">// 仍然可以通过嵌入类型名调用被覆盖的方法</span>
    d.Base.Show()   <span class="hljs-comment">// ✅ Base.Show: 42</span>
}
</code></pre>
<p><strong>关键洞察</strong>：</p>
<ul>
<li>嵌入不是继承，<strong>没有"重写"（override）概念</strong></li>
<li>外层定义同名方法只是<strong>遮蔽（shadow）</strong> 了提升的方法</li>
<li>被遮蔽的方法仍然可以通过 <code>d.Base.Show()</code> 访问</li>
</ul>
<h3 data-id="heading-9">坑点3️⃣：多层嵌入的歧义</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> {
    value <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a A)</span></span> Method() {
    fmt.Println(<span class="hljs-string">"A.Method"</span>)
}

<span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> {
    value <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b B)</span></span> Method() {
    fmt.Println(<span class="hljs-string">"B.Method"</span>)
}

<span class="hljs-comment">// C 同时嵌入 A 和 B</span>
<span class="hljs-keyword">type</span> C <span class="hljs-keyword">struct</span> {
    A
    B
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    c := C{A: A{value: <span class="hljs-number">1</span>}, B: B{value: <span class="hljs-number">2</span>}}
    
    <span class="hljs-comment">// ❌ 编译错误：ambiguous selector c.Method</span>
    <span class="hljs-comment">// c.Method()  // 到底调用 A.Method 还是 B.Method？</span>
    
    <span class="hljs-comment">// ✅ 必须显式指定</span>
    c.A.Method()  <span class="hljs-comment">// A.Method</span>
    c.B.Method()  <span class="hljs-comment">// B.Method</span>
}
</code></pre>
<p><strong>解决方案</strong>：定义自己的方法来消除歧义</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c C)</span></span> Method() {
    <span class="hljs-comment">// 自定义逻辑，或选择其一</span>
    c.A.Method()
    <span class="hljs-comment">// 或</span>
    fmt.Println(<span class="hljs-string">"C.Method: combining A and B"</span>)
}
</code></pre>
<h3 data-id="heading-10">坑点4️⃣：嵌入接口的实现要求</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Speaker <span class="hljs-keyword">interface</span> {
    Speak() <span class="hljs-type">string</span>
}

<span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> {
    name <span class="hljs-type">string</span>
}

<span class="hljs-comment">// Animal 没有实现 Speaker 接口</span>
<span class="hljs-comment">// func (a Animal) Speak() string { return a.name }</span>

<span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> {
    Animal
}

<span class="hljs-comment">// ❌ 编译错误：*Dog does not implement Speaker</span>
<span class="hljs-comment">// var _ Speaker = &amp;Dog{}</span>

<span class="hljs-comment">// ✅ 必须显式实现接口方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Speak() <span class="hljs-type">string</span> {
    <span class="hljs-keyword">return</span> d.name + <span class="hljs-string">" says Woof!"</span>
}

<span class="hljs-keyword">var</span> _ Speaker = &amp;Dog{}  <span class="hljs-comment">// ✅ 现在可以了</span>
</code></pre>
<p><strong>重要规则</strong>：</p>
<ul>
<li>嵌入接口<strong>不会自动实现</strong>该接口</li>
<li>外层结构体必须<strong>显式实现</strong>接口的所有方法</li>
<li>嵌入接口主要用于<strong>组合接口</strong>，而非实现复用</li>
</ul>
<h3 data-id="heading-11">坑点5️⃣：嵌入字段的修改陷阱</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> {
    Port    <span class="hljs-type">int</span>
    Timeout time.Duration
}

<span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> {
    Config  <span class="hljs-comment">// 嵌入</span>
    Name    <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    s := Server{
        Config: Config{Port: <span class="hljs-number">8080</span>, Timeout: <span class="hljs-number">30</span> * time.Second},
        Name:   <span class="hljs-string">"MyServer"</span>,
    }
    
    <span class="hljs-comment">// ❌ 陷阱：修改提升字段不会影响原始嵌入字段</span>
    s.Port = <span class="hljs-number">9090</span>  <span class="hljs-comment">// 这实际上是 s.Config.Port = 9090</span>
    
    <span class="hljs-comment">// ✅ 正确理解：提升字段就是嵌入字段</span>
    fmt.Println(s.Config.Port)  <span class="hljs-comment">// 9090</span>
    
    <span class="hljs-comment">// 但如果通过指针传递...</span>
    modifyPort(s)
    fmt.Println(s.Port)  <span class="hljs-comment">// 仍然是 9090！</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifyPort</span><span class="hljs-params">(s Server)</span></span> {
    s.Port = <span class="hljs-number">9999</span>  <span class="hljs-comment">// 修改的是副本，不影响原值</span>
}
</code></pre>
<h2 data-id="heading-12">四、实战模式：嵌入的最佳实践</h2>
<h3 data-id="heading-13">模式1：Mixin 模式（功能组合）</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// Logger mixin</span>
<span class="hljs-keyword">type</span> Logger <span class="hljs-keyword">struct</span> {
    prefix <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Logger)</span></span> Log(msg <span class="hljs-type">string</span>) {
    fmt.Printf(<span class="hljs-string">"[%s] %s\n"</span>, l.prefix, msg)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Logger)</span></span> Error(msg <span class="hljs-type">string</span>) {
    fmt.Printf(<span class="hljs-string">"[ERROR][%s] %s\n"</span>, l.prefix, msg)
}

<span class="hljs-comment">// Cache mixin</span>
<span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> {
    data <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{}
    sync.RWMutex
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>{}, <span class="hljs-type">bool</span>) {
    c.RLock()
    <span class="hljs-keyword">defer</span> c.RUnlock()
    val, ok := c.data[key]
    <span class="hljs-keyword">return</span> val, ok
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Set(key <span class="hljs-type">string</span>, val <span class="hljs-keyword">interface</span>{}) {
    c.Lock()
    <span class="hljs-keyword">defer</span> c.Unlock()
    c.data[key] = val
}

<span class="hljs-comment">// 组合使用</span>
<span class="hljs-keyword">type</span> UserService <span class="hljs-keyword">struct</span> {
    Logger
    *Cache
    db *sql.DB
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserService</span><span class="hljs-params">(db *sql.DB)</span></span> *UserService {
    <span class="hljs-keyword">return</span> &amp;UserService{
        Logger: Logger{prefix: <span class="hljs-string">"UserService"</span>},
        Cache:  &amp;Cache{data: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{})},
        db:     db,
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *UserService)</span></span> GetUser(id <span class="hljs-type">string</span>) (*User, <span class="hljs-type">error</span>) {
    s.Log(<span class="hljs-string">"Fetching user: "</span> + id)
    
    <span class="hljs-comment">// 先查缓存</span>
    <span class="hljs-keyword">if</span> cached, ok := s.Get(id); ok {
        s.Log(<span class="hljs-string">"Cache hit"</span>)
        <span class="hljs-keyword">return</span> cached.(*User), <span class="hljs-literal">nil</span>
    }
    
    <span class="hljs-comment">// 缓存未命中，查数据库</span>
    user := &amp;User{}
    err := s.db.QueryRow(<span class="hljs-string">"SELECT * FROM users WHERE id = ?"</span>, id).Scan(&amp;user.ID, &amp;user.Name)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        s.Error(<span class="hljs-string">"DB query failed: "</span> + err.Error())
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
    }
    
    <span class="hljs-comment">// 写入缓存</span>
    s.Set(id, user)
    <span class="hljs-keyword">return</span> user, <span class="hljs-literal">nil</span>
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>✅ 代码复用：Logger 和 Cache 可在多个服务中复用</li>
<li>✅ 关注分离：每个 mixin 职责单一</li>
<li>✅ 灵活组合：按需嵌入不同功能</li>
</ul>
<h3 data-id="heading-14">模式2：装饰器模式（包装增强）</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> {
    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)
}

<span class="hljs-comment">// 基础实现</span>
<span class="hljs-keyword">type</span> FileReader <span class="hljs-keyword">struct</span> {
    file *os.File
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fr *FileReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) {
    <span class="hljs-keyword">return</span> fr.file.Read(p)
}

<span class="hljs-comment">// 装饰器1：计数装饰器</span>
<span class="hljs-keyword">type</span> CountingReader <span class="hljs-keyword">struct</span> {
    Reader  <span class="hljs-comment">// 嵌入被装饰的 Reader</span>
    count   <span class="hljs-type">int64</span>
    mu      sync.Mutex
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cr *CountingReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) {
    n, err = cr.Reader.Read(p)  <span class="hljs-comment">// 调用被装饰者</span>
    cr.mu.Lock()
    cr.count += <span class="hljs-type">int64</span>(n)
    cr.mu.Unlock()
    <span class="hljs-keyword">return</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cr *CountingReader)</span></span> BytesRead() <span class="hljs-type">int64</span> {
    cr.mu.Lock()
    <span class="hljs-keyword">defer</span> cr.mu.Unlock()
    <span class="hljs-keyword">return</span> cr.count
}

<span class="hljs-comment">// 装饰器2：缓冲装饰器</span>
<span class="hljs-keyword">type</span> BufferedReader <span class="hljs-keyword">struct</span> {
    Reader
    buf []<span class="hljs-type">byte</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(br *BufferedReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(br.buf) == <span class="hljs-number">0</span> {
        <span class="hljs-comment">// 缓冲区空，从底层读取</span>
        br.buf = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">4096</span>)
        _, err = br.Reader.Read(br.buf)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
        }
    }
    
    <span class="hljs-comment">// 从缓冲区返回数据</span>
    n = <span class="hljs-built_in">copy</span>(p, br.buf)
    br.buf = br.buf[n:]
    <span class="hljs-keyword">return</span> n, <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    file, _ := os.Open(<span class="hljs-string">"data.txt"</span>)
    <span class="hljs-keyword">defer</span> file.Close()
    
    <span class="hljs-comment">// 链式装饰</span>
    reader := &amp;CountingReader{
        Reader: &amp;BufferedReader{
            Reader: &amp;FileReader{file: file},
            buf:    <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>),
        },
    }
    
    data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">100</span>)
    reader.Read(data)
    
    fmt.Printf(<span class="hljs-string">"Bytes read: %d\n"</span>, reader.BytesRead())
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>✅ 开闭原则：对扩展开放，对修改关闭</li>
<li>✅ 灵活组合：可以任意组合装饰器</li>
<li>✅ 职责清晰：每个装饰器只做一件事</li>
</ul>
<h3 data-id="heading-15">模式3：接口嵌入（接口组合）</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 基础接口</span>
<span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> {
    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)
}

<span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> {
    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)
}

<span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> {
    Close() <span class="hljs-type">error</span>
}

<span class="hljs-comment">// 组合接口</span>
<span class="hljs-keyword">type</span> ReadCloser <span class="hljs-keyword">interface</span> {
    Reader
    Closer
}

<span class="hljs-keyword">type</span> WriteCloser <span class="hljs-keyword">interface</span> {
    Writer
    Closer
}

<span class="hljs-keyword">type</span> ReadWriteCloser <span class="hljs-keyword">interface</span> {
    Reader
    Writer
    Closer
}

<span class="hljs-comment">// 实现组合接口</span>
<span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// ... 文件实现</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *File)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) {
    <span class="hljs-comment">// 实现</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *File)</span></span> Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) {
    <span class="hljs-comment">// 实现</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *File)</span></span> Close() <span class="hljs-type">error</span> {
    <span class="hljs-comment">// 实现</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// File 自动满足所有组合接口</span>
<span class="hljs-keyword">var</span> _ Reader = &amp;File{}
<span class="hljs-keyword">var</span> _ Writer = &amp;File{}
<span class="hljs-keyword">var</span> _ Closer = &amp;File{}
<span class="hljs-keyword">var</span> _ ReadCloser = &amp;File{}
<span class="hljs-keyword">var</span> _ WriteCloser = &amp;File{}
<span class="hljs-keyword">var</span> _ ReadWriteCloser = &amp;File{}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>✅ 接口最小化：每个基础接口职责单一</li>
<li>✅ 灵活组合：按需组合成更大的接口</li>
<li>✅ 向后兼容：添加新组合接口不影响现有实现</li>
</ul>
<h2 data-id="heading-16">五、性能分析：嵌入的开销</h2>
<h3 data-id="heading-17">5.1 内存布局</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Inner <span class="hljs-keyword">struct</span> {
    a <span class="hljs-type">int64</span>   <span class="hljs-comment">// 8 bytes</span>
    b <span class="hljs-type">int32</span>   <span class="hljs-comment">// 4 bytes (+4 padding)</span>
}

<span class="hljs-keyword">type</span> Outer <span class="hljs-keyword">struct</span> {
    Inner     <span class="hljs-comment">// 嵌入</span>
    c <span class="hljs-type">int64</span>   <span class="hljs-comment">// 8 bytes</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">var</span> o Outer
    fmt.Printf(<span class="hljs-string">"Size of Inner: %d bytes\n"</span>, unsafe.Sizeof(Inner{}))  <span class="hljs-comment">// 16 bytes</span>
    fmt.Printf(<span class="hljs-string">"Size of Outer: %d bytes\n"</span>, unsafe.Sizeof(o))        <span class="hljs-comment">// 24 bytes</span>
    
    <span class="hljs-comment">// 内存布局：</span>
    <span class="hljs-comment">// [Inner.a: 8 bytes][Inner.b: 4 bytes][padding: 4 bytes][c: 8 bytes]</span>
    <span class="hljs-comment">// 总计：24 bytes</span>
}
</code></pre>
<p><strong>结论</strong>：嵌入<strong>没有额外内存开销</strong>，只是内存布局的重新组织</p>
<h3 data-id="heading-18">5.2 方法调用性能</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Base <span class="hljs-keyword">struct</span> {
    value <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Base)</span></span> Method() <span class="hljs-type">int</span> {
    <span class="hljs-keyword">return</span> b.value * <span class="hljs-number">2</span>
}

<span class="hljs-keyword">type</span> Derived <span class="hljs-keyword">struct</span> {
    Base
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkDirect</span><span class="hljs-params">(b *testing.B)</span></span> {
    d := Derived{Base: Base{value: <span class="hljs-number">42</span>}}
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {
        _ = d.Method()  <span class="hljs-comment">// 通过提升调用</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkExplicit</span><span class="hljs-params">(b *testing.B)</span></span> {
    d := Derived{Base: Base{value: <span class="hljs-number">42</span>}}
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {
        _ = d.Base.Method()  <span class="hljs-comment">// 显式调用</span>
    }
}
</code></pre>
<p><strong>基准测试结果</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">BenchmarkDirect    1000000000    0.25 ns/op
BenchmarkExplicit  1000000000    0.25 ns/op
</code></pre>
<p><strong>结论</strong>：提升方法调用与显式调用<strong>性能完全相同</strong>，编译器会优化为直接访问</p>
<h2 data-id="heading-19">六、常见误区与最佳实践</h2>
<h3 data-id="heading-20">误区1：把嵌入当继承用</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// ❌ 错误：试图模拟继承层次</span>
<span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> { ... }
<span class="hljs-keyword">type</span> Mammal <span class="hljs-keyword">struct</span> { Animal }  <span class="hljs-comment">// Mammal "继承" Animal</span>
<span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> { Mammal }     <span class="hljs-comment">// Dog "继承" Mammal</span>

<span class="hljs-comment">// ✅ 正确：扁平化组合</span>
<span class="hljs-keyword">type</span> AnimalTraits <span class="hljs-keyword">struct</span> { ... }  <span class="hljs-comment">// 动物通用特征</span>
<span class="hljs-keyword">type</span> MammalTraits <span class="hljs-keyword">struct</span> { ... }  <span class="hljs-comment">// 哺乳动物特征</span>
<span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> {
    AnimalTraits
    MammalTraits
    <span class="hljs-comment">// Dog 特有字段</span>
}
</code></pre>
<h3 data-id="heading-21">误区2：过度嵌入导致耦合</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// ❌ 过度嵌入：一个结构体嵌入太多东西</span>
<span class="hljs-keyword">type</span> GodStruct <span class="hljs-keyword">struct</span> {
    Logger
    Cache
    Database
    Metrics
    Config
    <span class="hljs-comment">// ... 还有10个嵌入</span>
}

<span class="hljs-comment">// ✅ 合理拆分</span>
<span class="hljs-keyword">type</span> Service <span class="hljs-keyword">struct</span> {
    repo Repository
    logger Logger
}

<span class="hljs-keyword">type</span> Repository <span class="hljs-keyword">struct</span> {
    db *sql.DB
    cache *Cache
}
</code></pre>
<h3 data-id="heading-22">最佳实践清单</h3>








































<table><thead><tr><th>场景</th><th>推荐做法</th><th>原因</th></tr></thead><tbody><tr><td><strong>功能复用</strong></td><td>匿名嵌入 mixin</td><td>代码复用，保持扁平</td></tr><tr><td><strong>接口实现</strong></td><td>显式实现，不依赖嵌入</td><td>避免意外实现</td></tr><tr><td><strong>多层嵌入</strong></td><td>避免超过2层</td><td>可读性差，易产生歧义</td></tr><tr><td><strong>字段访问</strong></td><td>优先使用提升字段</td><td>简洁，符合习惯</td></tr><tr><td><strong>方法覆盖</strong></td><td>谨慎使用，文档说明</td><td>容易造成混淆</td></tr><tr><td><strong>测试</strong></td><td>通过接口而非具体类型</td><td>便于 mock</td></tr></tbody></table>
<h2 data-id="heading-23">七、总结：嵌入的本质与哲学</h2>
<h3 data-id="heading-24">7.1 嵌入的本质</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    A[嵌入] --&gt; B{匿名嵌入?}
    B --&gt;|是| C[方法/字段提升]
    B --&gt;|否| D[必须通过字段名访问]
    C --&gt; E[外层可以直接调用]
    D --&gt; F[外层需 obj.field.Method]
</code></pre>
<p><strong>核心要点</strong>：</p>
<ol>
<li>嵌入是<strong>组合</strong>，不是继承</li>
<li>匿名嵌入提供<strong>语法糖</strong>（提升机制）</li>
<li>提升的方法调用时，接收者是<strong>嵌入字段的副本</strong></li>
<li>外层可以<strong>遮蔽</strong>提升的方法，但不能"重写"</li>
</ol>
<h3 data-id="heading-25">7.2 Go 的设计哲学</h3>
<blockquote>
<p>"Less is exponentially more." —— Rob Pike</p>
</blockquote>
<p>Go 选择嵌入而非继承，体现了其设计哲学：</p>
<ul>
<li>✅ <strong>组合优于继承</strong>：更灵活，更易测试</li>
<li>✅ <strong>扁平优于层次</strong>：避免复杂的类型层次</li>
<li>✅ <strong>显式优于隐式</strong>：虽然嵌入提供语法糖，但底层机制清晰</li>
</ul>
<h3 data-id="heading-26">7.3 何时使用嵌入？</h3>



































<table><thead><tr><th>使用场景</th><th>推荐度</th><th>说明</th></tr></thead><tbody><tr><td>Mixin 模式（功能复用）</td><td>⭐⭐⭐⭐⭐</td><td>最佳实践</td></tr><tr><td>接口组合</td><td>⭐⭐⭐⭐⭐</td><td>Go 的惯用法</td></tr><tr><td>装饰器模式</td><td>⭐⭐⭐⭐</td><td>灵活且强大</td></tr><tr><td>模拟继承层次</td><td>⭐</td><td>避免使用</td></tr><tr><td>代码组织（分组字段）</td><td>⭐⭐⭐</td><td>可读性提升</td></tr></tbody></table>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue项目BMI计算器技术实现]]></title>    <link>https://juejin.cn/post/7603671627000643624</link>    <guid>https://juejin.cn/post/7603671627000643624</guid>    <pubDate>2026-02-07T16:05:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603671627000643624" data-draft-id="7603643385816170548" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue项目BMI计算器技术实现"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2026-02-07T16:05:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="滕青山"/> <meta itemprop="url" content="https://juejin.cn/user/3206601805674094"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue项目BMI计算器技术实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3206601805674094/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    滕青山
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T16:05:33.000Z" title="Sat Feb 07 2026 16:05:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">BMI计算器工具开发技术实现</h2>
<p>本文主要分享一下我最近开发的 BMI 计算器工具的技术实现细节。这个工具基于 Vue 3 和 Nuxt.js 构建，包含核心计算逻辑和交互式的用户界面。我们将重点关注其功能实现部分。</p>
<blockquote>
<p>在线工具网址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsee-tool.com%2Fbmi-calculator" target="_blank" title="https://see-tool.com/bmi-calculator" ref="nofollow noopener noreferrer">see-tool.com/bmi-calcula…</a></p>
</blockquote>
<blockquote>
<p>工具截图：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96166bc51ef24365a22043af965edb63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ruV6Z2S5bGx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771085158&amp;x-signature=8I%2FfxiS7nl4n%2FdaN4rhFVwLzD4E%3D" alt="在这里插入图片描述" loading="lazy"/></p>
</blockquote>
<h3 data-id="heading-1">项目结构</h3>
<p>这个工具的实现主要分为两个部分：</p>
<ol>
<li><strong>逻辑层</strong>：<code>utils/bmi-calculator.js</code> —— 负责核心的 BMI 数值计算和状态判定。</li>
<li><strong>视图层</strong>：<code>pages/bmi-calculator.vue</code> —— 负责用户交互、输入验证和结果展示。</li>
</ol>
<h3 data-id="heading-2">1. 核心计算逻辑</h3>
<p>计算逻辑封装在 <code>calculateBmi</code> 函数中。它接收用户的身高（cm）和体重（kg）作为输入，返回计算后的 BMI 值以及对应的身体状态类别和健康风险等级。</p>
<h4 data-id="heading-3">1.1 输入验证</h4>
<p>在进行计算之前，我们需要确保输入的数据是有效的数值且大于 0。如果输入无效，函数会抛出一个错误，以便前端捕获处理。</p>
<pre><code class="hljs language-javascript" lang="javascript">  <span class="hljs-keyword">const</span> height = <span class="hljs-title class_">Number</span>(heightCm)
  <span class="hljs-keyword">const</span> weight = <span class="hljs-title class_">Number</span>(weightKg)

  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(height) || !<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(weight) || height &lt;= <span class="hljs-number">0</span> || weight &lt;= <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'INVALID_INPUT'</span>)
  }
</code></pre>
<h4 data-id="heading-4">1.2 BMI 计算公式</h4>
<p>BMI 的计算公式是：体重（公斤）除以身高（米）的平方。</p>
<pre><code class="hljs language-javascript" lang="javascript">  <span class="hljs-keyword">const</span> heightInMeters = height / <span class="hljs-number">100</span>
  <span class="hljs-comment">// 体重 / (身高^2)</span>
  <span class="hljs-keyword">const</span> bmiRaw = weight / (heightInMeters * heightInMeters)
  <span class="hljs-comment">// 保留一位小数</span>
  <span class="hljs-keyword">const</span> bmi = <span class="hljs-title class_">Number</span>(bmiRaw.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>))
</code></pre>
<h4 data-id="heading-5">1.3 状态判定</h4>
<p>根据计算出的 BMI 值，我们可以判定用户的身体状态。这里我们参照了常见的 BMI 标准进行分类：</p>
<ul>
<li><strong>BMI &lt; 18.5</strong>: 偏瘦（Underweight），存在营养不良风险。</li>
<li><strong>18.5 ≤ BMI &lt; 24</strong>: 正常（Normal），健康风险低。</li>
<li><strong>24 ≤ BMI &lt; 28</strong>: 超重（Overweight），通过轻度风险。</li>
<li><strong>BMI ≥ 28</strong>: 肥胖（Obese），存在较高健康风险。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript">  <span class="hljs-keyword">if</span> (bmi &lt; <span class="hljs-number">18.5</span>) {
    <span class="hljs-keyword">return</span> { bmi, <span class="hljs-attr">categoryKey</span>: <span class="hljs-string">'underweight'</span>, <span class="hljs-attr">riskKey</span>: <span class="hljs-string">'malnutrition'</span> }
  }
  <span class="hljs-keyword">if</span> (bmi &lt; <span class="hljs-number">24</span>) {
    <span class="hljs-keyword">return</span> { bmi, <span class="hljs-attr">categoryKey</span>: <span class="hljs-string">'normal'</span>, <span class="hljs-attr">riskKey</span>: <span class="hljs-string">'low'</span> }
  }
  <span class="hljs-keyword">if</span> (bmi &lt; <span class="hljs-number">28</span>) {
    <span class="hljs-keyword">return</span> { bmi, <span class="hljs-attr">categoryKey</span>: <span class="hljs-string">'overweight'</span>, <span class="hljs-attr">riskKey</span>: <span class="hljs-string">'mild'</span> }
  }
  <span class="hljs-keyword">return</span> { bmi, <span class="hljs-attr">categoryKey</span>: <span class="hljs-string">'obese'</span>, <span class="hljs-attr">riskKey</span>: <span class="hljs-string">'high'</span> }
</code></pre>
<h3 data-id="heading-6">2. Vue 页面实现</h3>
<p>页面组件主要由输入表单和结果展示两大部分组成。使用 Vue 3 的 Composition API (<code>&lt;script setup&gt;</code>) 来管理状态和逻辑。</p>
<h4 data-id="heading-7">2.1 状态管理</h4>
<p>我们使用 <code>ref</code> 来定义响应式变量，用于存储用户的输入和计算结果。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> heightCm = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)  <span class="hljs-comment">// 用户输入的身高</span>
<span class="hljs-keyword">const</span> weightKg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)  <span class="hljs-comment">// 用户输入的体重</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)  <span class="hljs-comment">// 用于存储计算结果对象，初始为 null</span>
</code></pre>
<h4 data-id="heading-8">2.2 用户交互处理</h4>
<h5 data-id="heading-9">计算操作</h5>
<p>当用户点击“计算”按钮或在体重输入框按下回车时，会触发 <code>handleCalculate</code> 方法。</p>
<p>该方法首先调用核心计算函数 <code>calculateBmi</code>。如果计算成功，将结果赋值给 <code>result</code>，页面会自动渲染结果区域；如果捕获到错误（如输入无效），则会提示用户。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleCalculate</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 调用工具函数进行计算</span>
    <span class="hljs-keyword">const</span> r = <span class="hljs-title function_">calculateBmi</span>(<span class="hljs-title class_">Number</span>(heightCm.<span class="hljs-property">value</span>), <span class="hljs-title class_">Number</span>(weightKg.<span class="hljs-property">value</span>))
    result.<span class="hljs-property">value</span> = r
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// 计算失败，清空结果并提示错误</span>
    result.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>
    <span class="hljs-title function_">safeMessage</span>(<span class="hljs-string">'error'</span>, <span class="hljs-string">'请输入有效的身高和体重'</span>)
  }
}
</code></pre>
<h5 data-id="heading-10">加载示例</h5>
<p>为了方便用户快速体验，我们提供了一个 <code>loadExample</code> 方法，一键填入预设的示例数据并触发计算。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">loadExample</span> = (<span class="hljs-params"/>) =&gt; {
  heightCm.<span class="hljs-property">value</span> = <span class="hljs-string">'170'</span>
  weightKg.<span class="hljs-property">value</span> = <span class="hljs-string">'65'</span>
  <span class="hljs-title function_">handleCalculate</span>()
}
</code></pre>
<h5 data-id="heading-11">清空重置</h5>
<p><code>clearForm</code> 方法用于重置所有输入和结果，让用户可以重新开始。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">clearForm</span> = (<span class="hljs-params"/>) =&gt; {
  heightCm.<span class="hljs-property">value</span> = <span class="hljs-string">''</span>
  weightKg.<span class="hljs-property">value</span> = <span class="hljs-string">''</span>
  result.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>
}
</code></pre>
<h4 data-id="heading-12">2.3 结果动态展示</h4>
<p>在模板中，我们使用 <code>v-if="result"</code> 来控制结果卡片的显示。只有当 <code>result</code> 有值时，结果区域才会渲染。这种设计保证了页面初始状态的整洁。</p>
<p>结果卡片通过 grid 布局展示了三个关键信息：BMI 数值、身体状态和健康风险。这些信息都直接来自于 <code>result</code> 对象。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"..."</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- BMI 数值 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ result.bmi }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  
  <span class="hljs-comment">&lt;!-- 身体状态分类 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ t(`bmiCalculator.result.categoryMap.${result.categoryKey}`) }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  
  <span class="hljs-comment">&lt;!-- 健康风险评估 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ t(`bmiCalculator.result.riskMap.${result.riskKey}`) }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>通过将计算逻辑与界面展示分离，我们保持了代码的清晰和可维护性。Vue 强大的响应式系统让我们能够轻松地通过改变数据状态来驱动界面的更新。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[useMemo、useCallback、React.memo，可能真的要删了]]></title>    <link>https://juejin.cn/post/7603643044034674724</link>    <guid>https://juejin.cn/post/7603643044034674724</guid>    <pubDate>2026-02-08T00:50:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643044034674724" data-draft-id="7603656494905442310" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="useMemo、useCallback、React.memo，可能真的要删了"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2026-02-08T00:50:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员Agions"/> <meta itemprop="url" content="https://juejin.cn/user/360295545187751"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            useMemo、useCallback、React.memo，可能真的要删了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/360295545187751/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员Agions
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T00:50:37.000Z" title="Sun Feb 08 2026 00:50:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>"你写了3年的性能优化代码，可能全是无用功。"</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">React 官方的一记重锤</h2>
<p>React 官方博客最新更新：</p>
<p><strong>React Compiler 已正式推荐用于生产环境。</strong></p>
<p>这意味着什么？</p>





















<table><thead><tr><th>过去（手动优化）</th><th>现在（Compiler自动）</th></tr></thead><tbody><tr><td>手写 <code>useMemo</code> 缓存计算结果</td><td>编译器自动识别并优化</td></tr><tr><td>手写 <code>useCallback</code> 缓存函数</td><td>编译器自动处理</td></tr><tr><td>手写 <code>React.memo</code> 包裹组件</td><td>编译器自动决定是否需要</td></tr></tbody></table>
<p>一句话：<strong>你做的事情，编译器现在会帮你做了。</strong></p>
<p>而且它做得比你好。</p>
<blockquote>
<p>💡 <strong>三年前你学的React性能优化，正在变成"过时的最佳实践"。技术的残酷就在于：你越熟练的东西，越可能被淘汰。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-1">为什么我们需要 useMemo？</h2>
<p>先回顾一下历史。</p>
<p>React 的渲染机制是：<strong>状态变了，组件重新渲染。</strong></p>
<p>问题来了：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params">{ products }</span>) {
  <span class="hljs-comment">// 每次渲染都会重新计算</span>
  <span class="hljs-keyword">const</span> sortedProducts = products.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">price</span> - b.<span class="hljs-property">price</span>);
  
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{sortedProducts}</span> /&gt;</span></span>;
}
</code></pre>
<p>如果 <code>products</code> 有1000个，每次父组件更新，这个排序都要跑一遍。</p>
<p>即使 <code>products</code> 根本没变。</p>
<p>于是我们学会了：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> sortedProducts = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">price</span> - b.<span class="hljs-property">price</span>);
}, [products]);
</code></pre>
<p><strong>只有 <code>products</code> 变化时才重新计算。</strong></p>
<p>这就是 <code>useMemo</code> 的价值——手动告诉React："这里需要优化。"</p>
<blockquote>
<p>💡 <strong>useMemo 本质上是你和 React 的"交流方式"：你得告诉它哪里需要缓存。问题是，你经常说错。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-2">React Compiler：让编译器来决定</h2>
<p>React Compiler 的核心思想：</p>
<p><strong>你不需要告诉我哪里需要优化。我自己会分析。</strong></p>
<p>它的工作原理：</p>
<pre><code class="hljs">源代码 → 静态分析 → 识别可优化点 → 自动插入缓存逻辑 → 输出优化后的代码
</code></pre>
<p>编译器会分析你的代码，自动识别：</p>
<ul>
<li>哪些计算结果可以缓存</li>
<li>哪些函数引用需要稳定</li>
<li>哪些组件可以跳过重渲染</li>
</ul>
<p><strong>你写普通代码，编译器输出优化代码。</strong></p>
<p>来看对比：</p>
<h3 data-id="heading-3">Before（手动优化）</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ productId }</span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  
  <span class="hljs-comment">// 手动缓存</span>
  <span class="hljs-keyword">const</span> product = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchProduct</span>(productId);
  }, [productId]);
  
  <span class="hljs-comment">// 手动缓存回调</span>
  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);
  }, []);
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MemoizedButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ProductDetail</span> <span class="hljs-attr">product</span>=<span class="hljs-string">{product}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 手动包裹</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoizedButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Button</span>);
</code></pre>
<h3 data-id="heading-4">After（Compiler时代）</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ productId }</span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  
  <span class="hljs-comment">// 直接写，编译器自己优化</span>
  <span class="hljs-keyword">const</span> product = <span class="hljs-title function_">fetchProduct</span>(productId);
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ProductDetail</span> <span class="hljs-attr">product</span>=<span class="hljs-string">{product}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>代码量减少 40%。</p>
<p>可读性提升 100%。</p>
<blockquote>
<p>💡 <strong>最好的优化，是你感觉不到的优化。React Compiler让你回归"写代码"本身，而不是"写如何优化"。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-5">编译器真的比人聪明吗？</h2>
<p>不是"聪明"，是"不会犯错"。</p>
<p>人工优化的常见问题：</p>

























<table><thead><tr><th>问题</th><th>后果</th></tr></thead><tbody><tr><td><strong>过度优化</strong></td><td>到处加 useMemo，反而增加内存开销</td></tr><tr><td><strong>依赖数组错误</strong></td><td>缓存了但没生效，或者不该更新的更新了</td></tr><tr><td><strong>优化了不该优化的</strong></td><td>简单计算加缓存，成本比收益高</td></tr><tr><td><strong>忘记优化该优化的</strong></td><td>真正的瓶颈没发现</td></tr></tbody></table>
<p>编译器不会犯这些错。</p>
<p>它基于静态分析，<strong>精确识别需要优化的位置</strong>，不多不少。</p>
<blockquote>
<p>💡 <strong>人会过度优化，也会忘记优化。编译器只做必要的优化。这就是机器的优势：不会"手抖"。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-6">什么时候还需要手动优化？</h2>
<p>别急着删光。有些场景编译器还搞不定：</p>
<h3 data-id="heading-7">1. 非纯函数调用</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 编译器无法优化这种情况</span>
<span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 每次调用结果不同</span>
<span class="hljs-keyword">const</span> random = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
</code></pre>
<h3 data-id="heading-8">2. 外部状态依赖</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 依赖了组件外部的可变状态</span>
<span class="hljs-keyword">let</span> externalCounter = <span class="hljs-number">0</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> value = externalCounter++; <span class="hljs-comment">// 编译器无法追踪</span>
}
</code></pre>
<h3 data-id="heading-9">3. 第三方库的特殊要求</h3>
<p>某些库明确要求传入稳定引用（如 React Query 的 queryFn）。</p>
<p>这时候还是需要手动处理。</p>
<h3 data-id="heading-10">速查表</h3>





























<table><thead><tr><th>场景</th><th>需要手动优化？</th></tr></thead><tbody><tr><td>普通计算/过滤/排序</td><td>❌ 不需要</td></tr><tr><td>事件处理函数</td><td>❌ 不需要</td></tr><tr><td>子组件 props</td><td>❌ 不需要</td></tr><tr><td>非纯函数</td><td>✅ 可能需要</td></tr><tr><td>第三方库特殊要求</td><td>✅ 根据文档</td></tr></tbody></table>
<blockquote>
<p>💡 <strong>80%的手动优化可以删掉。剩下20%，等你遇到真正的性能问题再加不迟。</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-11">迁移指南：怎么开始用？</h2>
<h3 data-id="heading-12">Step 1: 检查环境</h3>
<p>React Compiler 需要：</p>
<ul>
<li>React 19+</li>
<li>Babel / SWC 配置</li>
</ul>
<h3 data-id="heading-13">Step 2: 安装配置</h3>
<pre><code class="hljs language-bash" lang="bash">npm install babel-plugin-react-compiler
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// babel.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    [<span class="hljs-string">'babel-plugin-react-compiler'</span>, {
      <span class="hljs-comment">// 配置项</span>
    }]
  ]
};
</code></pre>
<h3 data-id="heading-14">Step 3: 渐进式清理</h3>
<p>不需要一次性删光。推荐步骤：</p>
<ol>
<li><strong>先在新代码中不写</strong> useMemo/useCallback</li>
<li><strong>跑一段时间</strong>，观察性能</li>
<li><strong>逐步清理</strong>旧代码中的手动优化</li>
<li><strong>保留</strong>真正需要的边界情况</li>
</ol>
<h3 data-id="heading-15">Step 4: 监控性能</h3>
<p>删除手动优化后，用 React DevTools Profiler 检查：</p>
<ul>
<li>渲染次数是否异常增加</li>
<li>是否有明显的性能下降</li>
</ul>
<p>如果没有问题——恭喜，你的代码变干净了。</p>
<hr/>
<h2 data-id="heading-16">写给React开发者的话</h2>
<p>技术在进化。</p>
<p>曾经的最佳实践：</p>
<ul>
<li>2018：Class组件 + 生命周期</li>
<li>2020：Hooks + useMemo/useCallback</li>
<li>2024：React Compiler + 自动优化</li>
</ul>
<p><strong>每一代"最佳实践"都会被下一代淘汰。</strong></p>
<p>这不是坏事。</p>
<p>说明工具在变好，开发者的负担在减轻。</p>
<blockquote>
<p>💡 <strong>真正的高手不是记住所有API，而是知道什么时候该忘掉它们。useMemo 是好东西，但好东西也有过期的时候。</strong></p>
</blockquote>
<hr/>
<p>今晚就试试：</p>
<p><strong>把项目里的 useMemo 删几个，跑跑看。</strong></p>
<p>你会发现，天没塌。</p>
<p>评论区告诉我：你项目里有多少个 useMemo？敢删吗？</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI Agent 安全权限设计：blade-code 的 5 种权限模式与三级控制]]></title>    <link>https://juejin.cn/post/7603671627003412520</link>    <guid>https://juejin.cn/post/7603671627003412520</guid>    <pubDate>2026-02-08T01:52:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603671627003412520" data-draft-id="7603671627003396136" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI Agent 安全权限设计：blade-code 的 5 种权限模式与三级控制"/> <meta itemprop="keywords" content="Java,JavaScript"/> <meta itemprop="datePublished" content="2026-02-08T01:52:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="echoVic"/> <meta itemprop="url" content="https://juejin.cn/user/729731451069998"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI Agent 安全权限设计：blade-code 的 5 种权限模式与三级控制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/729731451069998/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    echoVic
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T01:52:04.000Z" title="Sun Feb 08 2026 01:52:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>blade-code 技术深度系列第 2 篇。本文基于源码剖析 AI Agent 的权限设计——5 种权限模式、allow/ask/deny 三级控制、基于签名的精确匹配。</p>
</blockquote>
<h2 data-id="heading-0">问题</h2>
<p>把 AI Agent 接入开发环境，第一个问题不是"它能做什么"，而是"它不能做什么"。</p>
<p>场景：</p>
<ul>
<li>Agent 想执行 <code>rm -rf /</code></li>
<li>Agent 想读取 <code>.env</code> 里的密钥</li>
<li>Agent 想 <code>curl</code> 下载脚本并执行</li>
<li>Agent 想 <code>sudo</code> 提权</li>
</ul>
<p>你会让它直接跑吗？</p>
<p>blade-code 从设计之初就在解决这个问题：<strong>赋予 Agent 能力的同时，保证安全</strong>。</p>
<p>本文内容：</p>
<ul>
<li>工具分类（ReadOnly / Write / Execute）</li>
<li>5 种权限模式</li>
<li>allow/ask/deny 三级控制</li>
<li>基于签名的精确匹配</li>
</ul>
<hr/>
<h2 data-id="heading-1">一、工具分类：三种 ToolKind</h2>
<p>blade-code 把所有工具分成三类，这是权限控制的基础：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ToolKind</span> {
  <span class="hljs-title class_">ReadOnly</span> = <span class="hljs-string">'readonly'</span>,  <span class="hljs-comment">// 只读，无副作用</span>
  <span class="hljs-title class_">Write</span> = <span class="hljs-string">'write'</span>,        <span class="hljs-comment">// 文件写入</span>
  <span class="hljs-title class_">Execute</span> = <span class="hljs-string">'execute'</span>,    <span class="hljs-comment">// 命令执行，可能有副作用</span>
}
</code></pre>
<h3 data-id="heading-2">ReadOnly 工具</h3>
<p>只读操作，无副作用，最安全：</p>





































<table><thead><tr><th>工具</th><th>功能</th></tr></thead><tbody><tr><td>Read</td><td>读取文件</td></tr><tr><td>Glob</td><td>路径匹配</td></tr><tr><td>Grep</td><td>文本搜索</td></tr><tr><td>WebFetch</td><td>获取网页</td></tr><tr><td>WebSearch</td><td>网络搜索</td></tr><tr><td>TaskOutput</td><td>子任务输出</td></tr><tr><td>Plan</td><td>生成计划</td></tr></tbody></table>
<h3 data-id="heading-3">Write 工具</h3>
<p>文件写入，有副作用但可控：</p>





















<table><thead><tr><th>工具</th><th>功能</th></tr></thead><tbody><tr><td>Edit</td><td>编辑文件</td></tr><tr><td>Write</td><td>写入文件</td></tr><tr><td>NotebookEdit</td><td>编辑 Notebook</td></tr></tbody></table>
<h3 data-id="heading-4">Execute 工具</h3>
<p>命令执行，副作用不可预测：</p>

























<table><thead><tr><th>工具</th><th>功能</th></tr></thead><tbody><tr><td>Bash</td><td>Shell 命令</td></tr><tr><td>Task</td><td>子任务</td></tr><tr><td>Skill</td><td>调用技能</td></tr><tr><td>SlashCommand</td><td>斜杠命令</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-5">二、5 种权限模式</h2>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">PermissionMode</span> {
  <span class="hljs-variable constant_">DEFAULT</span> = <span class="hljs-string">'default'</span>,
  <span class="hljs-variable constant_">AUTO_EDIT</span> = <span class="hljs-string">'autoEdit'</span>,
  <span class="hljs-variable constant_">YOLO</span> = <span class="hljs-string">'yolo'</span>,
  <span class="hljs-variable constant_">PLAN</span> = <span class="hljs-string">'plan'</span>,
  <span class="hljs-variable constant_">SPEC</span> = <span class="hljs-string">'spec'</span>,
}
</code></pre>
<h3 data-id="heading-6">DEFAULT（默认）</h3>
<p>平衡安全与效率：</p>
<ul>
<li>✅ 自动批准：ReadOnly 工具</li>
<li>❌ 需要确认：Write 工具</li>
<li>❌ 需要确认：Execute 工具</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">blade <span class="hljs-string">"帮我分析这个项目"</span>
</code></pre>
<h3 data-id="heading-7">AUTO_EDIT</h3>
<p>频繁编码场景：</p>
<ul>
<li>✅ 自动批准：ReadOnly 工具</li>
<li>✅ 自动批准：Write 工具</li>
<li>❌ 需要确认：Execute 工具</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">blade --mode=autoEdit <span class="hljs-string">"重构这个模块"</span>
</code></pre>
<p>日常开发中，文件编辑最频繁。AUTO_EDIT 让 Agent 自由改代码，但执行命令仍需确认。</p>
<h3 data-id="heading-8">YOLO（危险）</h3>
<p>完全信任 AI：</p>
<ul>
<li>✅ 自动批准：所有工具</li>
<li>⚠️ 跳过所有确认</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">blade --mode=yolo <span class="hljs-string">"自动修复所有 lint 错误"</span>
</code></pre>
<p>适用场景：沙箱环境、演示、已验证安全的自动化脚本。</p>
<p>源码实现：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">if</span> (permissionMode === <span class="hljs-title class_">PermissionMode</span>.<span class="hljs-property">YOLO</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ALLOW</span>,
    <span class="hljs-attr">matchedRule</span>: <span class="hljs-string">'mode:yolo'</span>,
    <span class="hljs-attr">reason</span>: <span class="hljs-string">'YOLO mode: automatically approve all tool invocations'</span>,
  };
}
</code></pre>
<h3 data-id="heading-9">PLAN</h3>
<p>只读模式，用于调研：</p>
<ul>
<li>✅ 自动批准：ReadOnly 工具</li>
<li>❌ 拦截：Write 和 Execute 工具</li>
<li>🔵 特殊工具：ExitPlanMode（提交方案）</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">blade --mode=plan <span class="hljs-string">"分析这个项目的架构"</span>
</code></pre>
<p>适用场景：代码审查、架构分析、生成方案后用户批准再执行。</p>
<p>源码实现：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">if</span> (permissionMode === <span class="hljs-title class_">PermissionMode</span>.<span class="hljs-property">PLAN</span>) {
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isReadOnlyKind</span>(toolKind)) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">DENY</span>,
      <span class="hljs-attr">matchedRule</span>: <span class="hljs-string">'mode:plan'</span>,
      <span class="hljs-attr">reason</span>: <span class="hljs-string">'Plan mode: modification tools are blocked'</span>,
    };
  }
}
</code></pre>
<h3 data-id="heading-10">SPEC（Spec-Driven Development）</h3>
<p>结构化功能开发：</p>
<ul>
<li>✅ 自动批准：ReadOnly + Spec 专用工具</li>
<li>❌ 需要确认：其他 Write 和 Execute 工具</li>
<li>🔵 特殊工具：InitSpec, UpdateSpec, ValidateSpec, GetSpecContext, ExitSpecMode</li>
<li>📁 持久化：<code>.blade/specs/&lt;feature&gt;/</code></li>
</ul>
<pre><code class="hljs language-bash" lang="bash">blade --mode=spec <span class="hljs-string">"实现用户认证功能"</span>
</code></pre>
<p>适用场景：复杂功能开发，需要 Requirements → Design → Tasks → Implementation 工作流。</p>
<h3 data-id="heading-11">模式对比</h3>















































<table><thead><tr><th>模式</th><th>ReadOnly</th><th>Write</th><th>Execute</th><th>场景</th></tr></thead><tbody><tr><td>DEFAULT</td><td>✅ 自动</td><td>❌ 确认</td><td>❌ 确认</td><td>日常开发</td></tr><tr><td>AUTO_EDIT</td><td>✅ 自动</td><td>✅ 自动</td><td>❌ 确认</td><td>频繁编码</td></tr><tr><td>YOLO</td><td>✅ 自动</td><td>✅ 自动</td><td>✅ 自动</td><td>沙箱/演示</td></tr><tr><td>PLAN</td><td>✅ 自动</td><td>❌ 拦截</td><td>❌ 拦截</td><td>调研/审查</td></tr><tr><td>SPEC</td><td>✅ 自动</td><td>❌ 确认</td><td>❌ 确认</td><td>复杂功能</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-12">三、三级权限控制：allow / ask / deny</h2>
<p>权限模式之外，blade-code 还有更细粒度的控制：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PermissionConfig</span> {
  <span class="hljs-attr">allow</span>: <span class="hljs-built_in">string</span>[];  <span class="hljs-comment">// 自动批准</span>
  <span class="hljs-attr">ask</span>: <span class="hljs-built_in">string</span>[];    <span class="hljs-comment">// 需要确认</span>
  <span class="hljs-attr">deny</span>: <span class="hljs-built_in">string</span>[];   <span class="hljs-comment">// 直接拒绝</span>
}
</code></pre>
<h3 data-id="heading-13">优先级</h3>
<p><strong>deny &gt; allow &gt; ask &gt; 默认(ask)</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. 检查 deny（最高优先级）</span>
<span class="hljs-keyword">const</span> denyMatch = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">matchRules</span>(signature, <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">deny</span>);
<span class="hljs-keyword">if</span> (denyMatch) {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">DENY</span>, ... };
}

<span class="hljs-comment">// 2. 检查 allow</span>
<span class="hljs-keyword">const</span> allowMatch = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">matchRules</span>(signature, <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">allow</span>);
<span class="hljs-keyword">if</span> (allowMatch) {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ALLOW</span>, ... };
}

<span class="hljs-comment">// 3. 检查 ask</span>
<span class="hljs-keyword">const</span> askMatch = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">matchRules</span>(signature, <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">ask</span>);
<span class="hljs-keyword">if</span> (askMatch) {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ASK</span>, ... };
}

<span class="hljs-comment">// 4. 默认：需要确认</span>
<span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ASK</span>, ... };
</code></pre>
<h3 data-id="heading-14">默认配置</h3>
<p>blade-code 内置了一套安全配置：</p>
<p><strong>allow 列表</strong>（自动批准）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-attr">allow</span>: [
  <span class="hljs-comment">// 系统信息命令</span>
  <span class="hljs-string">'Bash(pwd)'</span>, <span class="hljs-string">'Bash(which *)'</span>, <span class="hljs-string">'Bash(whoami)'</span>,
  <span class="hljs-string">'Bash(hostname)'</span>, <span class="hljs-string">'Bash(uname *)'</span>, <span class="hljs-string">'Bash(date)'</span>, <span class="hljs-string">'Bash(echo *)'</span>,

  <span class="hljs-comment">// 目录列表</span>
  <span class="hljs-string">'Bash(ls *)'</span>, <span class="hljs-string">'Bash(tree *)'</span>,

  <span class="hljs-comment">// Git 只读</span>
  <span class="hljs-string">'Bash(git status)'</span>, <span class="hljs-string">'Bash(git log *)'</span>, <span class="hljs-string">'Bash(git diff *)'</span>,
  <span class="hljs-string">'Bash(git branch *)'</span>, <span class="hljs-string">'Bash(git show *)'</span>, <span class="hljs-string">'Bash(git remote *)'</span>,

  <span class="hljs-comment">// 包管理器只读</span>
  <span class="hljs-string">'Bash(npm list *)'</span>, <span class="hljs-string">'Bash(npm view *)'</span>, <span class="hljs-string">'Bash(npm outdated *)'</span>,
  <span class="hljs-string">'Bash(pnpm list *)'</span>, <span class="hljs-string">'Bash(yarn list *)'</span>,
  <span class="hljs-string">'Bash(pip list *)'</span>, <span class="hljs-string">'Bash(pip show *)'</span>,
]
</code></pre>
<p><strong>ask 列表</strong>（需要确认）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-attr">ask</span>: [
  <span class="hljs-comment">// 网络下载（可能下载恶意代码）</span>
  <span class="hljs-string">'Bash(curl *)'</span>, <span class="hljs-string">'Bash(wget *)'</span>, <span class="hljs-string">'Bash(aria2c *)'</span>, <span class="hljs-string">'Bash(axel *)'</span>,

  <span class="hljs-comment">// 危险删除</span>
  <span class="hljs-string">'Bash(rm -rf *)'</span>, <span class="hljs-string">'Bash(rm -r *)'</span>, <span class="hljs-string">'Bash(rm --recursive *)'</span>,

  <span class="hljs-comment">// 网络连接</span>
  <span class="hljs-string">'Bash(nc *)'</span>, <span class="hljs-string">'Bash(netcat *)'</span>, <span class="hljs-string">'Bash(telnet *)'</span>, <span class="hljs-string">'Bash(ncat *)'</span>,
]
</code></pre>
<p><strong>deny 列表</strong>（直接拒绝）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-attr">deny</span>: [
  <span class="hljs-comment">// 敏感文件</span>
  <span class="hljs-string">'Read(./.env)'</span>, <span class="hljs-string">'Read(./.env.*)'</span>,

  <span class="hljs-comment">// 危险命令</span>
  <span class="hljs-string">'Bash(rm -rf /)'</span>, <span class="hljs-string">'Bash(rm -rf /*)'</span>, <span class="hljs-string">'Bash(sudo *)'</span>, <span class="hljs-string">'Bash(chmod 777 *)'</span>,

  <span class="hljs-comment">// Shell 嵌套（可绕过安全检测）</span>
  <span class="hljs-string">'Bash(bash *)'</span>, <span class="hljs-string">'Bash(sh *)'</span>, <span class="hljs-string">'Bash(zsh *)'</span>, <span class="hljs-string">'Bash(fish *)'</span>, <span class="hljs-string">'Bash(dash *)'</span>,

  <span class="hljs-comment">// 代码注入</span>
  <span class="hljs-string">'Bash(eval *)'</span>, <span class="hljs-string">'Bash(source *)'</span>,

  <span class="hljs-comment">// 系统级操作</span>
  <span class="hljs-string">'Bash(mkfs *)'</span>, <span class="hljs-string">'Bash(fdisk *)'</span>, <span class="hljs-string">'Bash(dd *)'</span>, <span class="hljs-string">'Bash(format *)'</span>, <span class="hljs-string">'Bash(parted *)'</span>,

  <span class="hljs-comment">// 浏览器（可打开恶意链接）</span>
  <span class="hljs-string">'Bash(open http*)'</span>, <span class="hljs-string">'Bash(open https*)'</span>,
  <span class="hljs-string">'Bash(xdg-open http*)'</span>, <span class="hljs-string">'Bash(xdg-open https*)'</span>,
]
</code></pre>
<h3 data-id="heading-15">设计原则</h3>
<p><strong>allow</strong>：只读命令无副作用，可以自动批准。<code>pwd</code>、<code>ls</code>、<code>git status</code> 不会改变任何东西。</p>
<p><strong>ask</strong>：<code>curl</code>、<code>wget</code> 可能下载恶意代码，<code>rm -rf</code> 可能删数据。需要确认，但不完全禁止。</p>
<p><strong>deny</strong>：<code>.env</code> 包含密钥，<code>sudo</code> 风险太高，Shell 嵌套可能绕过检测，<code>mkfs</code>、<code>dd</code> 可能造成不可逆损害。</p>
<hr/>
<h2 data-id="heading-16">四、基于签名的精确匹配</h2>
<p>blade-code 的权限系统支持多种匹配模式。</p>
<h3 data-id="heading-17">签名格式</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">ToolName</span>(content)
</code></pre>
<p>例如：</p>
<ul>
<li><code>Bash(git status)</code> — 执行 git status</li>
<li><code>Read(src/index.ts)</code> — 读取文件</li>
<li><code>Edit(src/utils.ts)</code> — 编辑文件</li>
</ul>
<h3 data-id="heading-18">匹配模式</h3>
<ol>
<li><strong>精确匹配</strong>：<code>Read(src/index.ts)</code></li>
<li><strong>前缀匹配</strong>：<code>Read</code>（匹配所有 Read 调用）</li>
<li><strong>通配符匹配</strong>：<code>Read(*)</code> 或 <code>Bash(git *)</code></li>
<li><strong>Glob 模式</strong>：<code>Read(**/*.env)</code></li>
</ol>



































<table><thead><tr><th>规则</th><th>匹配</th><th>不匹配</th></tr></thead><tbody><tr><td><code>Bash(git status)</code></td><td><code>Bash(git status)</code></td><td><code>Bash(git log)</code></td></tr><tr><td><code>Bash(git *)</code></td><td><code>Bash(git status)</code>, <code>Bash(git log)</code></td><td><code>Bash(npm install)</code></td></tr><tr><td><code>Bash</code></td><td>所有 Bash 命令</td><td><code>Read(...)</code></td></tr><tr><td><code>Read(*.env)</code></td><td><code>Read(.env)</code>, <code>Read(.env.local)</code></td><td><code>Read(config.json)</code></td></tr><tr><td><code>Read(**/*.ts)</code></td><td><code>Read(src/index.ts)</code></td><td><code>Read(package.json)</code></td></tr></tbody></table>
<h3 data-id="heading-19">实现</h3>
<p>blade-code 用 picomatch 库做 glob 匹配：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">matchRule</span>(<span class="hljs-attr">signature</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">rule</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">MatchType</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-comment">// 精确匹配</span>
  <span class="hljs-keyword">if</span> (signature === rule) <span class="hljs-keyword">return</span> <span class="hljs-string">'exact'</span>;

  <span class="hljs-comment">// 通配符匹配所有</span>
  <span class="hljs-keyword">if</span> (rule === <span class="hljs-string">'*'</span> || rule === <span class="hljs-string">'**'</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'wildcard'</span>;

  <span class="hljs-comment">// 工具名 glob 匹配</span>
  <span class="hljs-keyword">if</span> (ruleToolName.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'*'</span>)) {
    <span class="hljs-keyword">if</span> (!picomatch.<span class="hljs-title function_">isMatch</span>(sigToolName, ruleToolName, { <span class="hljs-attr">dot</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bash</span>: <span class="hljs-literal">true</span> })) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-comment">// 参数 glob 匹配</span>
  <span class="hljs-keyword">if</span> (rule.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'*'</span>)) {
    <span class="hljs-keyword">const</span> isMatch = picomatch.<span class="hljs-title function_">isMatch</span>(sigValue, ruleValue, { <span class="hljs-attr">dot</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bash</span>: <span class="hljs-literal">true</span> });
    <span class="hljs-keyword">if</span> (isMatch) <span class="hljs-keyword">return</span> ruleValue.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'**'</span>) ? <span class="hljs-string">'glob'</span> : <span class="hljs-string">'wildcard'</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<hr/>
<h2 data-id="heading-20">五、权限执行管道</h2>
<p>blade-code 的权限检查在 PipelineStages 中实现。</p>
<h3 data-id="heading-21">优先级</h3>
<p><strong>YOLO 模式 &gt; PLAN 模式 &gt; DENY 规则 &gt; ALLOW 规则 &gt; 模式规则 &gt; ASK</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">applyModeOverrides</span>(
  <span class="hljs-attr">toolKind</span>: <span class="hljs-title class_">ToolKind</span>,
  <span class="hljs-attr">checkResult</span>: <span class="hljs-title class_">PermissionCheckResult</span>,
  <span class="hljs-attr">permissionMode</span>: <span class="hljs-title class_">PermissionMode</span>
): <span class="hljs-title class_">PermissionCheckResult</span> {
  <span class="hljs-comment">// 1. YOLO：全部放开</span>
  <span class="hljs-keyword">if</span> (permissionMode === <span class="hljs-title class_">PermissionMode</span>.<span class="hljs-property">YOLO</span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ALLOW</span>, ... };
  }

  <span class="hljs-comment">// 2. PLAN：拒绝非只读</span>
  <span class="hljs-keyword">if</span> (permissionMode === <span class="hljs-title class_">PermissionMode</span>.<span class="hljs-property">PLAN</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isReadOnlyKind</span>(toolKind)) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">DENY</span>, ... };
    }
  }

  <span class="hljs-comment">// 3. deny 规则已拒绝，不覆盖</span>
  <span class="hljs-keyword">if</span> (checkResult.<span class="hljs-property">result</span> === <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">DENY</span>) <span class="hljs-keyword">return</span> checkResult;

  <span class="hljs-comment">// 4. allow 规则已批准，不覆盖</span>
  <span class="hljs-keyword">if</span> (checkResult.<span class="hljs-property">result</span> === <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ALLOW</span>) <span class="hljs-keyword">return</span> checkResult;

  <span class="hljs-comment">// 5. 只读工具：自动批准</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isReadOnlyKind</span>(toolKind)) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ALLOW</span>, ... };
  }

  <span class="hljs-comment">// 6. AUTO_EDIT + Write：自动批准</span>
  <span class="hljs-keyword">if</span> (permissionMode === <span class="hljs-title class_">PermissionMode</span>.<span class="hljs-property">AUTO_EDIT</span> &amp;&amp; toolKind === <span class="hljs-title class_">ToolKind</span>.<span class="hljs-property">Write</span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">result</span>: <span class="hljs-title class_">PermissionResult</span>.<span class="hljs-property">ALLOW</span>, ... };
  }

  <span class="hljs-comment">// 7. 其他：保持原结果（通常是 ASK）</span>
  <span class="hljs-keyword">return</span> checkResult;
}
</code></pre>
<h3 data-id="heading-22">流程图</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[工具调用请求] --&gt; B{YOLO 模式?}
    B --&gt;|是| C[✅ 直接批准]
    B --&gt;|否| D{PLAN 模式?}
    D --&gt;|是| E{只读工具?}
    E --&gt;|否| F[❌ 直接拒绝]
    E --&gt;|是| G[✅ 批准]
    D --&gt;|否| H{匹配 deny 规则?}
    H --&gt;|是| F
    H --&gt;|否| I{匹配 allow 规则?}
    I --&gt;|是| C
    I --&gt;|否| J{只读工具?}
    J --&gt;|是| C
    J --&gt;|否| K{AUTO_EDIT + Write?}
    K --&gt;|是| C
    K --&gt;|否| L[⚠️ 请求用户确认]
</code></pre>
<hr/>
<h2 data-id="heading-23">六、实战配置</h2>
<h3 data-id="heading-24">项目级配置</h3>
<p>在项目根目录创建 <code>.blade/settings.json</code>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"permissionMode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"default"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"permissions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"allow"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"Bash(npm run *)"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"Bash(pnpm *)"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"Bash(git commit *)"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"Bash(git push *)"</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"ask"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"deny"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"Read(config/secrets.json)"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"Bash(rm -rf node_modules)"</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-25">命令行切换</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 启动时指定</span>
blade --mode=autoEdit <span class="hljs-string">"重构这个模块"</span>
blade --mode=plan <span class="hljs-string">"分析项目架构"</span>
blade --mode=yolo <span class="hljs-string">"自动修复所有问题"</span>

<span class="hljs-comment"># 运行时切换</span>
&gt; /mode autoEdit
&gt; /mode plan
&gt; /mode default
</code></pre>
<h3 data-id="heading-26">场景推荐</h3>



































<table><thead><tr><th>场景</th><th>模式</th><th>原因</th></tr></thead><tbody><tr><td>日常开发</td><td>DEFAULT</td><td>平衡安全与效率</td></tr><tr><td>频繁编码</td><td>AUTO_EDIT</td><td>减少文件编辑确认</td></tr><tr><td>代码审查</td><td>PLAN</td><td>只读不写</td></tr><tr><td>自动化脚本</td><td>YOLO</td><td>无需人工干预（确保安全）</td></tr><tr><td>复杂功能</td><td>SPEC</td><td>结构化工作流</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-27">总结</h2>
<ol>
<li><strong>工具分类</strong>：ReadOnly / Write / Execute</li>
<li><strong>5 种权限模式</strong>：DEFAULT / AUTO_EDIT / YOLO / PLAN / SPEC</li>
<li><strong>三级权限控制</strong>：deny &gt; allow &gt; ask</li>
<li><strong>精确匹配</strong>：精确、前缀、通配符、glob</li>
</ol>
<p>设计原则：</p>
<ul>
<li>默认安全（DEFAULT 模式）</li>
<li>灵活可控（用户可切换）</li>
<li>细粒度（精确到命令级别）</li>
<li>可扩展（项目级配置覆盖全局）</li>
</ul>
<hr/>
<h2 data-id="heading-28">参考</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FechoVic%2Fblade-code" target="_blank" title="https://github.com/echoVic/blade-code" ref="nofollow noopener noreferrer">blade-code GitHub</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FechoVic%2Fblade-code%2Fblob%2Fmain%2Fpackages%2Fcli%2Fsrc%2Fconfig%2FPermissionChecker.ts" target="_blank" title="https://github.com/echoVic/blade-code/blob/main/packages/cli/src/config/PermissionChecker.ts" ref="nofollow noopener noreferrer">PermissionChecker.ts</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FechoVic%2Fblade-code%2Fblob%2Fmain%2Fpackages%2Fcli%2Fsrc%2Ftools%2Fexecution%2FPipelineStages.ts" target="_blank" title="https://github.com/echoVic/blade-code/blob/main/packages/cli/src/tools/execution/PipelineStages.ts" ref="nofollow noopener noreferrer">PipelineStages.ts</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[上下文工程：构建高性能AI Agent的系统性架构设计]]></title>    <link>https://juejin.cn/post/7603616672927563791</link>    <guid>https://juejin.cn/post/7603616672927563791</guid>    <pubDate>2026-02-07T17:37:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603616672927563791" data-draft-id="7603588665568378920" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="上下文工程：构建高性能AI Agent的系统性架构设计"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2026-02-07T17:37:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="盛夏光年爱学习"/> <meta itemprop="url" content="https://juejin.cn/user/2189882893018872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            上下文工程：构建高性能AI Agent的系统性架构设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2189882893018872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    盛夏光年爱学习
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T17:37:41.000Z" title="Sat Feb 07 2026 17:37:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">上下文工程：构建高性能AI Agent的系统性架构设计</h2>
<hr/>
<h3 data-id="heading-1">引言：从"提示工程"到"上下文工程"</h3>
<p>随着大语言模型（LLM）上下文窗口从4K扩展到128K甚至1M tokens，我们面临的核心挑战已从"装不下"转变为"管不好"。当Agent在复杂任务中持续运行，信息不断累积形成<strong>上下文债务</strong>（Context Debt），系统性能并非线性下降，而是在某个临界点突然崩溃。</p>
<p>本文基于LangChain提出的WSCI框架（Write-Select-Compress-Isolate），结合Anthropic关于"上下文腐烂"（Context Rot）的理论研究，系统阐述如何构建稳健、可扩展的AI Agent上下文架构。</p>
<hr/>
<h3 data-id="heading-2">第一部分：问题诊断——理解性能下降的本质</h3>
<h4 data-id="heading-3">1.1 根本病因：上下文腐烂（Context Rot）</h4>
<p>上下文腐烂是描述LLM处理长序列时<strong>底层认知能力系统性衰退</strong>的物理现象，其根源在于：</p>
<ul>
<li><strong>注意力稀释</strong>：Transformer的注意力机制随序列长度增加，单token可分配的注意力权重呈指数级下降</li>
<li><strong>训练分布偏移</strong>：预训练数据中长序列样本稀缺，模型缺乏长距离推理的优化经验</li>
<li><strong>位置编码限制</strong>：即使采用RoPE、ALiBi等相对位置编码，远距离依赖的建模能力仍会衰减</li>
</ul>
<p><strong>关键洞察</strong>：上下文腐烂是<strong>不可避免的物理约束</strong>，与信息内容质量无关，纯粹由信息数量触发。</p>
<h4 data-id="heading-4">1.2 四类并发症：具体的失败模式</h4>
<p>当上下文腐烂恶化，Agent在具体任务中表现出四种可被诊断的失败模式：</p>



































<table><thead><tr><th>失败模式</th><th>定义</th><th>核心类比</th><th>与腐烂的关系</th></tr></thead><tbody><tr><td><strong>上下文污染</strong> (Poisoning)</td><td>幻觉/错误信息进入上下文并被后续推理当作事实</td><td>信息源被投毒</td><td>腐烂导致判断力下降，更难识别错误输入</td></tr><tr><td><strong>上下文干扰</strong> (Distraction)</td><td>过多低价值信息压倒模型预训练知识</td><td>信噪比过低</td><td>腐烂直接导致注意力无法区分优先级</td></tr><tr><td><strong>上下文混淆</strong> (Confusion)</td><td>不相关信息错误关联，造成逻辑张冠李戴</td><td>注意力分散</td><td>腐烂导致无法清晰追踪核心逻辑</td></tr><tr><td><strong>上下文冲突</strong> (Clash)</td><td>上下文不同部分包含矛盾信息</td><td>指令集冲突</td><td>腐烂导致长距离记忆衰退，发现不了远距离矛盾</td></tr></tbody></table>
<h4 data-id="heading-5">1.3 因果关系的三个层面</h4>
<pre><code class="hljs">上下文腐烂（根本病因）
    │
    ├──→ 直接引发：注意力稀释 → 干扰/混淆
    │
    ├──→ 催生放大：推理能力下降 → 更容易产生幻觉（污染源头）
    │
    └──→ 屏蔽发现：长距离记忆衰退 → 发现不了已存在的冲突
</code></pre>
<p><strong>精准类比</strong>：将Agent想象成长途驾驶的司机</p>
<ul>
<li><strong>司机疲劳</strong> = 上下文腐烂（内在系统性能力下降）</li>
<li><strong>遇到烂路出错</strong> = 四类失败模式（外在症状）</li>
<li>精神饱满的司机能应对烂路，疲劳司机出车祸概率大增</li>
</ul>
<hr/>
<h3 data-id="heading-6">第二部分：WSCI框架——系统性的解决方案</h3>
<p>针对上下文腐烂这一根本病因及其并发症，LangChain提出了<strong>WSCI框架</strong>——四个正交的操作维度：</p>
<pre><code class="hljs language-sql" lang="sql">┌─────────────────────────────────────────────────────────┐
│                    WSCI 框架架构图                        │
├─────────────┬─────────────┬─────────────┬───────────────┤
│   Write     │   <span class="hljs-keyword">Select</span>    │  Compress   │   Isolate     │
│   (写入)     │   (选择)     │   (压缩)     │    (隔离)     │
├─────────────┼─────────────┼─────────────┼───────────────┤
│ 构建记忆系统 │ 注意力调度   │  降噪减负   │   分而治之        │
│  解决"存什么"│ 解决"取什么" │ 解决"装不下" │  解决"别干扰"    │
└─────────────┴─────────────┴─────────────┴───────────────┘
</code></pre>
<hr/>
<h3 data-id="heading-7">第三部分：写入（Write）——构建分层记忆系统</h3>
<p>写入操作的核心不是简单追加文本，而是构建<strong>两种功能截然不同的记忆系统</strong>：</p>
<h4 data-id="heading-8">3.1 草稿纸（Scratchpad）—— 短期过程记忆</h4>



































<table><thead><tr><th>特性</th><th>草稿纸</th><th>类比</th></tr></thead><tbody><tr><td><strong>核心类比</strong></td><td>办公桌/白板</td><td>处理当前工作，用完即清</td></tr><tr><td><strong>目的</strong></td><td>辅助当前任务成功执行</td><td>确保逻辑连贯性</td></tr><tr><td><strong>生命周期</strong></td><td>任务级/会话内（易失）</td><td>随任务结束清空</td></tr><tr><td><strong>内容粒度</strong></td><td>详细过程、中间步骤、原始数据</td><td>思考痕迹</td></tr><tr><td><strong>核心机制</strong></td><td><strong>存储与使用分离</strong></td><td>完整信息存于窗口外，按需载入</td></tr></tbody></table>
<p><strong>存储与使用分离</strong>是草稿纸对抗上下文腐烂的核心手段：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  应用程序内存    │ ←── │  上下文工程代码   │ ←── │   LLM上下文窗口  │
│ (完整草稿纸存储) │     │ (智能选择+压缩)   │     │  (关键信息子集)  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
</code></pre>
<p><strong>两种实现模式对比</strong>：</p>























<table><thead><tr><th>模式</th><th>机制</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>显式工具调用</strong></td><td>Agent主动调用<code>write_note</code>工具</td><td>行为透明，可调试性强</td><td>对模型要求高，增加Token开销</td></tr><tr><td><strong>隐式格式驱动</strong></td><td>强制<code>Thought/Action</code>格式，框架自动提取</td><td>高效自动化，符合自然推理流</td><td>过程由框架封装，相对黑盒</td></tr></tbody></table>
<h4 data-id="heading-9">3.2 长期记忆（Long-term Memory）—— 跨任务知识沉淀</h4>



































<table><thead><tr><th>特性</th><th>长期记忆</th><th>类比</th></tr></thead><tbody><tr><td><strong>核心类比</strong></td><td>档案柜/个人知识库</td><td>归档重要结论，供未来查阅</td></tr><tr><td><strong>目的</strong></td><td>辅助未来所有任务</td><td>实现学习与进化</td></tr><tr><td><strong>生命周期</strong></td><td>永久性/跨会话（持久）</td><td>持续积累</td></tr><tr><td><strong>内容粒度</strong></td><td>提炼后的结论、经验、高级知识</td><td>认知升华</td></tr><tr><td><strong>核心挑战</strong></td><td>从海量观察中智能提炼高价值信息</td><td>信息萃取</td></tr></tbody></table>
<p><strong>两种生成机制</strong>：</p>
<p><strong>机制一：Reflection（反思）—— 事件驱动的纠错型记忆</strong></p>
<p><strong>核心思想</strong>：从错误中学习，提炼可复用的行为规则。这是一种"痛过才懂"的学习模式。</p>
<p><strong>完整工作流程</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">┌─────────────────────────────────────────────────────────────────┐
│                     Reflection 工作流程                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段<span class="hljs-number">1</span>：失败检测（框架自动完成）                                   │
│  ├── 监控Agent行动与观察的匹配度                                  │
│  ├── 识别工具调用失败、结果为空、格式错误等异常                    │
│  └── 示例：搜索<span class="hljs-string">"Apple revenue"</span>返回手机新闻而非财报                │
│                                                                 │
│  阶段<span class="hljs-number">2</span>：元提示生成（框架自动完成）                                 │
│  └── 构造复盘Prompt：<span class="hljs-string">"回顾这次失败，生成一条可复用的规则          │
│      避免未来犯错，格式：当[情境]时，应[行动]"</span>                    │
│                                                                 │
│  阶段<span class="hljs-number">3</span>：规则生成（LLM执行）                                       │
│  └── 产出行为策略：<span class="hljs-string">"当我搜索公司财报时，应加入'季度收益'等关键词"</span>  │
│                                                                 │
│  阶段<span class="hljs-number">4</span>：记忆写入（框架执行）                                      │
│  └── 将规则存入长期记忆的<span class="hljs-string">"程序性记忆"</span>分区                         │
│  └── 标记为：类型=行为规则，置信度=高，来源=反思生成               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>关键设计要点</strong>：</p>






























<table><thead><tr><th>设计维度</th><th>具体策略</th><th>目的</th></tr></thead><tbody><tr><td><strong>触发条件</strong></td><td>明确的失败信号（工具错误、结果为空、格式不匹配）</td><td>避免过度反思，确保规则质量</td></tr><tr><td><strong>规则抽象度</strong></td><td>从具体实例上升到模式匹配（如"Apple"→"公司"）</td><td>提高规则的泛化能力</td></tr><tr><td><strong>置信度管理</strong></td><td>新规则标记为"待验证"，多次成功应用后升级为"已确认"</td><td>防止错误规则持续污染</td></tr><tr><td><strong>冲突检测</strong></td><td>写入前检查是否与现有规则矛盾</td><td>避免规则集内部冲突</td></tr></tbody></table>
<p><strong>适用场景</strong>：</p>
<ul>
<li>工具调用频繁失败的场景（如搜索、API调用）</li>
<li>需要快速迭代优化的封闭领域（如特定公司的内部系统操作）</li>
<li>错误成本较高的场景（如金融交易、医疗诊断）</li>
</ul>
<p><strong>机制二：Generative Agents（生成式智能体）—— 周期性的认知升华</strong></p>
<p><strong>核心思想</strong>：从日常观察中持续积累，通过周期性总结提炼高级洞察。这是一种"温故知新"的学习模式。</p>
<p><strong>完整工作流程</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">┌─────────────────────────────────────────────────────────────────┐
│                Generative Agents 工作流程                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段<span class="hljs-number">1</span>：原始日志收集（持续进行）                                   │
│  ├── 时间戳：<span class="hljs-number">10</span>:<span class="hljs-number">05</span>                                               │
│  │   事件：张三在会议中提到<span class="hljs-string">"项目预算紧张"</span>                          │
│  ├── 时间戳：<span class="hljs-number">14</span>:<span class="hljs-number">30</span>                                               │
│  │   事件：收到李四邮件，主题<span class="hljs-string">"关于Q3成本削减方案"</span>                   │
│  └── 时间戳：<span class="hljs-number">16</span>:<span class="hljs-number">45</span>                                               │
│      事件：王五在群聊中询问<span class="hljs-string">"是否可以推迟非核心采购"</span>                 │
│                                                                 │
│  阶段<span class="hljs-number">2</span>：周期性合成触发（每日/每周结束时）                          │
│  └── 框架启动Prompt链进行多轮认知升华                              │
│                                                                 │
│  阶段<span class="hljs-number">3</span>：分层摘要提炼（LLM多轮执行）                                │
│  ├── 第<span class="hljs-number">1</span>轮（事实层）：<span class="hljs-string">"总结以上日志的核心动态"</span>                     │
│  │   输出：<span class="hljs-string">"张三、李四、王五都讨论了预算相关问题"</span>                   │
│  ├── 第<span class="hljs-number">2</span>轮（关联层）：<span class="hljs-string">"这些事件之间有何关联？"</span>                     │
│  │   输出：<span class="hljs-string">"三人从不同角度（会议、邮件、群聊）表达对预算的担忧"</span>      │
│  └── 第<span class="hljs-number">3</span>轮（洞察层）：<span class="hljs-string">"基于此，有何新洞察？"</span>                      │
│      输出：<span class="hljs-string">"项目X正面临显著的预算风险，可能需要启动风险预案"</span>        │
│                                                                 │
│  阶段<span class="hljs-number">4</span>：高级记忆写入（框架执行）                                   │
│  └── 将洞察存入长期记忆的<span class="hljs-string">"语义记忆"</span>分区                            │
│  └── 标记为：类型=高级事实，时效性=长期，置信度=中等               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>关键设计要点</strong>：</p>



































<table><thead><tr><th>设计维度</th><th>具体策略</th><th>目的</th></tr></thead><tbody><tr><td><strong>收集粒度</strong></td><td>原始事件日志（谁、何时、说了什么）</td><td>保留完整上下文，支持多维度总结</td></tr><tr><td><strong>合成周期</strong></td><td>高频（每日）+ 低频（每周/每月）双层机制</td><td>平衡时效性与认知深度</td></tr><tr><td><strong>Prompt链设计</strong></td><td>从事实→关联→洞察的递进式提问</td><td>模拟人类的归纳推理过程</td></tr><tr><td><strong>时效性管理</strong></td><td>洞察标记有效期（如"预算紧张"标记为季度有效）</td><td>防止过时洞察持续影响决策</td></tr><tr><td><strong>溯源能力</strong></td><td>保留指向原始日志的引用链接</td><td>支持洞察的验证与审计</td></tr></tbody></table>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要长期跟踪的复杂项目（如客户关系管理、产品研发）</li>
<li>多源信息汇聚的场景（如舆情监控、竞争情报）</li>
<li>需要发现隐性模式的场景（如用户行为分析、风险评估）</li>
</ul>
<p><strong>两种机制的对比与协同</strong></p>













































<table><thead><tr><th>维度</th><th>Reflection</th><th>Generative Agents</th></tr></thead><tbody><tr><td><strong>触发时机</strong></td><td>事件驱动（失败时立即触发）</td><td>周期驱动（定时批量处理）</td></tr><tr><td><strong>学习来源</strong></td><td>负面经验（错误、失败）</td><td>正面/中性观察（日常事件）</td></tr><tr><td><strong>产出形式</strong></td><td>行为规则（如何做）</td><td>高级事实/洞察（是什么）</td></tr><tr><td><strong>记忆类型</strong></td><td>程序性记忆</td><td>语义记忆</td></tr><tr><td><strong>更新频率</strong></td><td>高频、即时</td><td>低频、批量</td></tr><tr><td><strong>认知深度</strong></td><td>浅层（单点纠错）</td><td>深层（模式发现）</td></tr><tr><td><strong>协同关系</strong></td><td>Reflection规则可指导Generative Agents的关注重点</td><td>Generative Agents的洞察可优化Reflection的触发条件</td></tr></tbody></table>
<p><strong>协同示例</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">Generative Agents发现：<span class="hljs-string">"近期项目频繁出现预算相关讨论"</span>（洞察）
    ↓
优化Reflection触发条件：增加<span class="hljs-string">"预算相关工具调用失败"</span>的敏感度
    ↓
Reflection生成规则：<span class="hljs-string">"当搜索预算信息时，应同时查询'成本'、'开支'等同义词"</span>
    ↓
Generative Agents在下一轮合成中发现规则应用效果，验证洞察准确性
</code></pre>
<h3 data-id="heading-10">第四部分：选择（Select）—— 从加载数据到注意力调度</h3>
<p>选择操作是WSCI框架中<strong>最高频、最核心</strong>的环节，类比操作系统的内存调度算法。</p>
<h4 data-id="heading-11">4.1 四大信息源的选择策略</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────┐
│                    选择操作的信息源架构                       │
├──────────────────┬──────────────────┬───────────┬───────────┤
│    草稿纸         │    长期记忆       │   工具集   │   知识库   │
│  (短期工作笔记)    │  (持久化知识)     │ (可执行能力)│ (外部数据) │
├──────────────────┼──────────────────┼───────────┼───────────┤
│ • 显式工具回忆    │ • 程序性记忆(如何做)│ • RAG for │ • 混合检索 │
│ • 滑动窗口       │ • 情景记忆(发生了什么)│   Tools  │ • Agentic │
│ • 状态总结       │ • 语义记忆(是什么)  │ • 动态选择 │   Search │
│ • 错误复盘       │ • 动态少样本提示   │ • 固定遮蔽 │ • 重排序  │
└──────────────────┴──────────────────┴───────────┴───────────┘
</code></pre>
<h4 data-id="heading-12">4.2 长期记忆的人类记忆三分法</h4>
<p>LangChain引入认知科学中的<strong>人类记忆三分法</strong>来分类长期记忆：</p>





























<table><thead><tr><th>记忆类型</th><th>对应内容</th><th>选择策略</th><th>技术实现</th></tr></thead><tbody><tr><td><strong>程序性记忆</strong></td><td>行为规则（系统提示）</td><td>动态模板切换</td><td>根据用户意图选择专门指令模块（如识别"退货"意图才加载退货流程指南）</td></tr><tr><td><strong>情景记忆</strong></td><td>过往经验（少样本示例）</td><td>动态少样本提示</td><td>基于语义相似度从示例库动态检索最相关案例</td></tr><tr><td><strong>语义记忆</strong></td><td>事实性知识</td><td>相关性+意图适配性</td><td>RAG、混合检索、知识图谱</td></tr></tbody></table>
<p><strong>关键警示</strong>：一个错误的选择比没有记忆更糟糕。ChatGPT曾错误选择用户地理位置信息注入图片生成，导致输出偏差。算法不仅要判断<strong>语义相关性</strong>，更要判断<strong>任务意图的适切性</strong>。</p>
<h4 data-id="heading-13">4.3 工具选择的架构权衡</h4>























<table><thead><tr><th>策略</th><th>机制</th><th>适用场景</th><th>权衡点</th></tr></thead><tbody><tr><td><strong>动态选择（RAG for Tools）</strong></td><td>为工具描述建独立索引，预检索加载Top-K</td><td>工具集庞大且开放（如插件系统）</td><td>优先考虑扩展性与精准度</td></tr><tr><td><strong>固定工具集+遮蔽（Masking）</strong></td><td>保持提示前缀不变，利用KV缓存加速</td><td>工具集小而稳定，对延迟要求极高</td><td>优先考虑性能与速度</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-14">第五部分：压缩（Compress）—— 高保真的降噪减负</h3>
<p>压缩操作针对<strong>即将进入窗口的原始信息流</strong>（冗长对话历史、海量API返回），在信息进入新一轮调用前为其降噪减负。</p>
<h4 data-id="heading-15">5.1 两种技术路线的对比</h4>






























<table><thead><tr><th>维度</th><th>上下文总结（Summarization）</th><th>上下文裁剪（Trimming）</th></tr></thead><tbody><tr><td><strong>核心机制</strong></td><td>LLM智能提炼（理解并重写）</td><td>基于规则过滤（直接丢弃）</td></tr><tr><td><strong>优点</strong></td><td>✅ 智能，保留核心语义 ✅ 擅长处理非结构化长文本</td><td>✅ 快速，成本极低 ✅ 对保留部分保真度100%</td></tr><tr><td><strong>缺点</strong></td><td>❌ 慢，成本高（需额外LLM调用） ❌ 有损压缩，可能丢失细节</td><td>❌ "笨拙"，可能粗暴丢弃重要信息 ❌ 规则需人工精心设计</td></tr><tr><td><strong>适用场景</strong></td><td>处理巨型工具返回、总结长对话历史、Agent间工作交接</td><td>管理常规对话历史（滑动窗口）、清理已消化的旧信息</td></tr></tbody></table>
<h4 data-id="heading-16">5.2 上下文总结：三个核心应用场景</h4>
<p><strong>场景一：总结对话历史</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">原始：早期<span class="hljs-number">20</span>轮详细对话（<span class="hljs-number">10</span>K tokens）
    ↓ LLM提炼
摘要：<span class="hljs-string">"任务：查询订单#12345售后；关键决策：已修改收货地址，
      申请电子发票；用户偏好：偏好短信通知"</span>
    ↓ 替换原文
载入上下文：<span class="hljs-number">1</span>段摘要（<span class="hljs-number">200</span> tokens）
</code></pre>
<p><strong>场景二：后处理工具反馈</strong></p>
<pre><code class="hljs language-css" lang="css">错误做法：将<span class="hljs-number">5</span>万字网页<span class="hljs-selector-tag">HTML</span>直接喂给Agent
正确做法：<span class="hljs-selector-tag">HTML</span> → 专门总结Prompt提取核心要点 → 精炼摘要载入
</code></pre>
<p><strong>场景三：Agent间知识交接</strong></p>
<pre><code class="hljs language-css" lang="css">子Agent完整思考日志（<span class="hljs-number">50</span>轮，<span class="hljs-number">5</span>K tokens）
    ↓ 总结提炼
浓缩工作报告："研究发现Q3营收增长<span class="hljs-number">20%</span>，主要驱动因素：<span class="hljs-selector-tag">A</span>、<span class="hljs-selector-tag">B</span>、C；
              建议：关注D风险"
    ↓ 提交给主Agent
</code></pre>
<p><strong>关键挑战：信息保真度</strong></p>
<blockquote>
<p>"过度激进的压缩可能导致微妙但关键的信息丢失。"</p>
</blockquote>
<p><strong>应对策略</strong>：</p>
<ul>
<li>精心设计的压缩Prompt（明确保留重点）</li>
<li>配合分层记忆系统（关键结论写入结构化笔记，不依赖对话压缩）</li>
</ul>
<h4 data-id="heading-17">5.3 上下文裁剪的两种实现</h4>
<pre><code class="hljs language-arduino" lang="arduino">方式一：硬编码启发式（滑动窗口）
策略：设定固定规则，如<span class="hljs-string">"永远只保留最近10轮对话"</span>
优点：极其简单快速，成本几乎为零
缺点：一刀切，可能丢弃早期奠基信息
​
方式二：智能过滤（训练裁剪器）
策略：训练轻量级分类模型判断每条信息<span class="hljs-string">"应保留"</span>或<span class="hljs-string">"可丢弃"</span>
优点：比滑动窗口智能（如识别核心问题即使很老也不丢弃）
缺点：需额外模型训练和维护成本
</code></pre>
<p><strong>信息保真度管理</strong>：过度激进的压缩可能导致微妙但关键的信息丢失。应通过<strong>精心设计的压缩Prompt</strong>配合<strong>分层记忆系统</strong>，确保关键结论写入持久化结构化笔记，而非在对话历史压缩中意外丢失。</p>
<hr/>
<h3 data-id="heading-18">第六部分：隔离（Isolate）—— 分而治之的架构艺术</h3>
<p>隔离操作解决复杂系统中的<strong>信息流干扰</strong>问题，通过创建多个独立的上下文空间实现复杂并行工作流。</p>
<h4 data-id="heading-19">6.1 三种隔离架构模式</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────┐
│                    隔离架构的三种模式                         │
├──────────────────┬──────────────────┬───────────────────────┤
│    多智能体        │    环境/沙箱      │     运行时状态对象      │
│  (Agent之间隔离)   │  (思考与执行隔离)  │    (Agent内部隔离)     │
├──────────────────┼──────────────────┼───────────────────────┤
│ • 主Agent规划分解 │ • LLM只负责思考   │ • 状态结构化为多字段对象 │
│ • 子Agent并行执行 │ • 重资产操作交沙箱 │ • 开发者代码按需暴露    │
│ • 完全独立上下文  │ • 状态化环境隔离   │ • Schema预定义边界     │
│ • 关注点分离      │ • 真实对象操作    │ • 运行时动态拉取       │
└──────────────────┴──────────────────┴───────────────────────┘
</code></pre>
<h5 data-id="heading-20">模式一：多智能体（Multi-Agent）—— Agent之间的隔离</h5>
<p><strong>核心机制</strong>：团队协作模式，将上下文隔离级别从单个Agent内部提升到多个Agent之间。</p>
<p><strong>架构详解</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────────┐
│                     多智能体架构图示                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐                                            │
│  │    主Agent       │ ←── 负责顶层规划与任务分解                   │
│  │  (规划者/协调者)  │      维护"元上下文"：任务目标、子任务分配、   │
│  │                 │      整合规则，不接触具体执行细节              │
│  └────────┬────────┘                                            │
│           │ 委派子任务                                            │
│           ▼                                                     │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │   专家Agent <span class="hljs-selector-tag">A</span>    │  │   专家Agent <span class="hljs-selector-tag">B</span>    │  │   专家Agent C    │  │
│  │  (代码生成专家)   │  │  (数据分析专家)   │  │  (文档撰写专家)   │  │
│  │                 │  │                 │  │                 │  │
│  │ 独立上下文窗口    │  │ 独立上下文窗口    │  │ 独立上下文窗口    │  │
│  │ • 代码规范       │  │ • 数据schema     │  │ • 文档模板       │  │
│  │ • 相关API文档    │  │ • 统计方法       │  │ • 风格指南       │  │
│  │ • 历史代码示例   │  │ • 可视化库用法   │  │ • 术语表         │  │
│  │ （无关信息被隔离）│  │ （无关信息被隔离）│  │ （无关信息被隔离）│  │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘  │
│           │                    │                    │           │
│           └────────────────────┼────────────────────┘           │
│                                │ 返回结果                        │
│                                ▼                                │
│                         ┌─────────────┐                         │
│                         │   结果整合     │                       │
│                         │  (主Agent汇总) │                       │
│                         └─────────────┘                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>关键设计决策</strong>：</p>






























<table><thead><tr><th>决策点</th><th>策略选项</th><th>选择依据</th></tr></thead><tbody><tr><td><strong>任务分解粒度</strong></td><td>粗粒度（少而大的子任务）vs 细粒度（多而小的子任务）</td><td>子任务间独立性高→细粒度；需要全局协调→粗粒度</td></tr><tr><td><strong>通信协议</strong></td><td>结构化（JSON/XML）vs 自然语言</td><td>机器可读性要求高→结构化；灵活性要求高→自然语言</td></tr><tr><td><strong>上下文共享范围</strong></td><td>零共享（完全隔离）vs 只读共享（共享背景信息）vs 全共享（共享完整历史）</td><td>避免污染→零共享；需要一致性→只读共享</td></tr><tr><td><strong>协调机制</strong></td><td>中心化（主Agent调度）vs 去中心化（Agent间直接通信）</td><td>需要全局优化→中心化；需要响应速度→去中心化</td></tr></tbody></table>
<p><strong>成本收益分析的量化框架</strong>：</p>
<pre><code class="hljs language-sql" lang="sql">成本 <span class="hljs-operator">=</span> <span class="hljs-number">15</span>x Token开销（典型值）<span class="hljs-operator">+</span> 延迟增加 <span class="hljs-operator">+</span> 系统复杂度提升
收益 <span class="hljs-operator">=</span> 任务并行度提升 × 单任务质量提升 × 错误隔离带来的稳定性提升
​
决策规则：
IF 任务可并行度 <span class="hljs-operator">&gt;</span> <span class="hljs-number">0.7</span> 
   <span class="hljs-keyword">AND</span> 单任务质量提升 <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span><span class="hljs-operator">%</span> 
   <span class="hljs-keyword">AND</span> 错误成本 <span class="hljs-operator">&gt;</span> 多Agent成本
<span class="hljs-keyword">THEN</span> 采用多Agent架构
<span class="hljs-keyword">ELSE</span> 采用单Agent <span class="hljs-operator">+</span> 其他WSCI操作优化
</code></pre>
<hr/>
<h5 data-id="heading-21">模式二：环境沙箱（Sandbox）—— 思考与执行的隔离</h5>
<p><strong>核心机制</strong>：分离LLM的"思考"（生成代码/指令）与"执行"（操作真实世界状态），让Agent在轻量级上下文中操作重资产数据。</p>
<p><strong>架构详解</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">┌─────────────────────────────────────────────────────────────────┐
│                     环境沙箱架构图示                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────┐        ┌─────────────────────────┐ │
│  │      LLM上下文窗口        │        │      沙箱执行环境         │ │
│  │    （轻量级，只存思考）     │        │   （重量级，存储真实状态）  │ │
│  │                         │        │                         │ │
│  │  系统提示：<span class="hljs-string">"你是一个数据    │        │  ┌─────────────────┐    │ │
│  │  分析师，请生成Python代码   │◄───────┤  │   数据对象        │    │ │
│  │  分析用户上传的数据集"</span>      │  代码   │  │  • DataFrame     │    │ │
│  │                         │        │  │  • 文件句柄       │    │ │
│  │  用户问题：<span class="hljs-string">"分析销售趋势"</span>   │        │  │  • 数据库连接     │    │ │
│  │                         │        │  │  • API响应缓存    │    │ │
│  │  Agent思考：<span class="hljs-string">"我需要先加载   │        │  └─────────────────┘    │ │
│  │  数据，然后计算月度统计..."</span>  │        │                         │ │
│  │                         │        │  ┌─────────────────┐    │ │
│  │  Agent输出（代码）：        │───────►│  │   执行引擎        │    │ │
│  │  ```python               │  执行   │  │  • Python解释器   │    │ │
│  │  <span class="hljs-built_in">df</span> = sandbox.load(<span class="hljs-string">'sales │        │  │  • 文件系统       │    │ │
│  │  _data.csv'</span>)             │        │  │  • 网络访问       │    │ │
│  │  monthly = df.groupby(    │        │  │  • 资源限制器     │    │ │
│  │  <span class="hljs-string">'month'</span>).<span class="hljs-built_in">sum</span>()          │        │  └─────────────────┘    │ │
│  │  sandbox.plot(monthly)   │        │                         │ │
│  │  ```                     │        │  ┌─────────────────┐    │ │
│  │                         │        │  │   结果摘要        │    │ │
│  │  [接收执行结果摘要]        │◄───────┤  │  • 统计指标       │    │ │
│  │  <span class="hljs-string">"月度销售趋势图已生成，    │  摘要   │  • 异常检测       │    │ │
│  │  Q3环比增长15%..."</span>         │        │  • 可视化路径     │    │ │
│  │                         │        │  └─────────────────┘    │ │
│  └─────────────────────────┘        └─────────────────────────┘ │
│                                                                 │
│  关键隔离点：LLM从不直接接触原始数据，只操作沙箱提供的元数据        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>沙箱与草稿纸的本质区别</strong>：</p>













































<table><thead><tr><th>维度</th><th>草稿纸（Scratchpad）</th><th>环境沙箱（Sandbox）</th></tr></thead><tbody><tr><td><strong>隔离层级</strong></td><td>Agent内部</td><td>Agent与外部环境之间</td></tr><tr><td><strong>信息介质</strong></td><td>文本（字符串）</td><td>真实对象（DataFrame、文件、连接）</td></tr><tr><td><strong>存储内容</strong></td><td>思考过程、推理痕迹</td><td>真实世界的状态、数据</td></tr><tr><td><strong>操作方式</strong></td><td>读/写文本</td><td>发号施令（生成代码操作对象）</td></tr><tr><td><strong>生命周期</strong></td><td>随任务结束清空</td><td>可持久化或按策略清理</td></tr><tr><td><strong>核心价值</strong></td><td>记录推理过程，支持回溯</td><td>让Agent处理远超上下文窗口的数据量</td></tr><tr><td><strong>典型操作</strong></td><td>"记录当前计划"、"更新观察结果"</td><td>"加载数据集"、"执行查询"、"生成图表"</td></tr></tbody></table>
<p><strong>沙箱的高级应用——"盲人摸象"式分析</strong>：</p>
<pre><code class="hljs language-json" lang="json">场景：分析<span class="hljs-number">100</span>GB的日志文件，远超LLM上下文窗口
​
传统方式：无法处理，或需要预先用其他工具抽样
​
沙箱方式：
    │
    ├── Agent生成代码：<span class="hljs-string">"读取日志文件的元数据（时间范围、字段列表）"</span>
    ├── 沙箱返回：<span class="hljs-punctuation">{</span><span class="hljs-attr">"size"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"100GB"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"rows"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">500000000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"fields"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"timestamp"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"level"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"message"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">}</span>
    │
    ├── Agent生成代码：<span class="hljs-string">"按小时抽样统计错误率分布"</span>
    ├── 沙箱执行抽样查询，返回：<span class="hljs-punctuation">{</span><span class="hljs-attr">"peak_hour"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"14:00"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"error_rate"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5%"</span><span class="hljs-punctuation">}</span>
    │
    ├── Agent生成代码：<span class="hljs-string">"深入分析14:00的错误日志，提取常见错误模式"</span>
    ├── 沙箱返回Top<span class="hljs-number">-5</span>错误类型及示例
    │
    └── Agent基于这些<span class="hljs-string">"摸象"</span>得到的元数据，生成最终分析报告
​
Agent始终工作在轻量级上下文（只存代码和元数据），
但通过沙箱操作实现了对海量数据的分析能力。
</code></pre>
<h5 data-id="heading-22">模式三：运行时状态对象（Runtime State）—— Agent内部的结构化隔离</h5>
<p><strong>核心机制</strong>：将Agent的完整状态设计为结构化的多字段对象，通过Schema预定义信息边界，实现内部模块化隔离。</p>
<p><strong>架构详解</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────────┐
│                   运行时状态对象架构图示                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Agent运行时状态对象（完整状态）               │   │
│  │                                                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │   │
│  │  │  messages   │  │working_mem  │  │  user_profile│     │   │
│  │  │  (对话历史)  │  │ (工作记忆)   │  │  (用户画像)  │     │   │
│  │  │             │  │             │  │             │     │   │
│  │  │ • 用户输入   │  │ • 当前计划   │  │ • 偏好设置   │     │   │
│  │  │ • Agent回复  │  │ • 中间结果   │  │ • 历史行为   │     │   │
│  │  │ • 工具调用   │  │ • 待办事项   │  │ • 权限等级   │     │   │
│  │  │             │  │             │  │             │     │   │
│  │  │ <span class="hljs-selector-attr">[隔离规则：  │  │ [隔离规则：  │  │ [隔离规则：  │     │   ││  │  │  全量保留    │  │  按需加载    │  │  只读访问]</span>   │     │   │
│  │  │  但受压缩]   │  │  高优先级]   │  │             │     │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘     │   │
│  │                                                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │   │
│  │  │ tool_results│  │  session_ctx │  │  system_cfg  │     │   │
│  │  │ (工具结果)   │  │ (会话上下文) │  │ (系统配置)   │     │   │
│  │  │             │  │             │  │             │     │   │
│  │  │ • 原始返回   │  │ • 任务类型   │  │ • 模型参数   │     │   │
│  │  │ • 解析状态   │  │ • 会话ID    │  │ • 安全策略   │     │   │
│  │  │ • 缓存标记   │  │ • 时间戳    │  │ • 功能开关   │     │   │
│  │  │             │  │             │  │             │     │   │
│  │  │ <span class="hljs-selector-attr">[隔离规则：  │  │ [隔离规则：  │  │ [隔离规则：  │     │   ││  │  │  后处理压缩  │  │  全量只读]</span>   │  │  系统级保护] │     │   │
│  │  │  后丢弃原始] │  │             │  │             │     │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘     │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  每次LLM调用时，框架根据当前任务类型，按隔离规则选择暴露的字段：    │
│                                                                 │
│  示例：代码生成任务时的上下文组装                                  │
│  ├── 必须加载：messages（最近<span class="hljs-number">3</span>轮）、working_mem（当前计划）        │
│  ├── 条件加载：user_profile（如果涉及个性化代码风格）               │
│  ├── 后处理加载：tool_results（先压缩为摘要）                      │
│  └── 禁止加载：system_cfg（内部配置，不暴露给模型）                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>隔离与选择的协同工作流</strong>：</p>
<pre><code class="hljs">设计时（隔离视角）：
    │
    ├── 定义状态Schema，划分字段边界
    ├── 为每个字段设定访问权限（读/写/不可见）
    ├── 设定字段间的依赖关系（如tool_results依赖session_ctx）
    └── 建立字段的加载优先级和压缩策略
                │
                ▼
运行时（选择视角）：
    │
    ├── 识别当前任务类型和意图
    ├── 根据隔离规则，从各字段中选择需要暴露的数据
    ├── 应用字段特定的压缩策略（如messages用滑动窗口，tool_results用摘要）
    └── 组装最终上下文，确保不违反隔离边界
</code></pre>
<h4 data-id="heading-23">6.2 多智能体的成本收益权衡</h4>
<p><strong>核心机制</strong>：团队协作模式，将上下文隔离级别从单个Agent内部提升到多个Agent之间。</p>
<p><strong>架构要点</strong>：</p>
<ul>
<li>主Agent负责顶层规划与任务分解</li>
<li>专家子Agent在<strong>完全独立的上下文窗口</strong>中并行执行</li>
<li>实现清晰的关注点分离，避免主Agent被海量细节污染</li>
</ul>
<p><strong>成本收益权衡</strong>：</p>
<ul>
<li>Token消耗可能高达<strong>15倍</strong></li>
<li><strong>采用标准</strong>：任务高度可并行 + 子任务需深度探索 + 收益远大于成本</li>
<li><strong>默认策略</strong>：采用单Agent，只有遇到明确瓶颈才评估多Agent</li>
</ul>
<h4 data-id="heading-24">6.3 环境沙箱 vs 草稿纸的本质区别</h4>






























<table><thead><tr><th>维度</th><th>草稿纸（Scratchpad）</th><th>环境沙箱（Sandbox）</th></tr></thead><tbody><tr><td><strong>隔离对象</strong></td><td>思考的痕迹</td><td>真实世界的状态</td></tr><tr><td><strong>存储介质</strong></td><td>字符串（Text Log）</td><td>真实对象（DataFrame, File等）</td></tr><tr><td><strong>Agent操作</strong></td><td>读/写文本</td><td>发号施令（生成代码操作对象）</td></tr><tr><td><strong>核心价值</strong></td><td>记录推理过程</td><td>让Agent通过操作对象元数据实现"盲人摸象"式分析，始终工作在轻量级上下文</td></tr></tbody></table>
<h4 data-id="heading-25">6.4 隔离与选择的辩证关系</h4>
<ul>
<li><strong>隔离（Isolate）</strong> ：<strong>架构师视角</strong>，强调"阻挡"。通过Schema设计预先定义信息边界和访问权限。</li>
<li><strong>选择（Select）</strong> ：<strong>操作员视角</strong>，强调"拉取"。在运行时根据隔离预设规则，动态从不同分区拉取信息。</li>
</ul>
<p><strong>结论</strong>：隔离定义了信息的边界，选择<strong>在边界内活动</strong>——它们是同一枚硬币的两面。</p>
<hr/>
<h3 data-id="heading-26">第七部分：实践指南——构建上下文架构的 checklist</h3>
<p>基于WSCI框架，我们提供以下实践 checklist：</p>
<h4 data-id="heading-27">7.1 写入阶段</h4>
<ul>
<li>明确区分草稿纸（任务级）和长期记忆（永久级）的写入目标</li>
<li>选择显式工具调用（可调试）或隐式格式驱动（高效）的实现模式</li>
<li>为长期记忆设计Reflection（纠错）或Generative Agents（升华）的生成机制</li>
</ul>
<h4 data-id="heading-28">7.2 选择阶段</h4>
<ul>
<li>为草稿纸实现滑动窗口、状态总结或错误复盘的选择策略</li>
<li>为长期记忆应用人类记忆三分法，实现动态模板、动态少样本、RAG检索</li>
<li>为工具集评估动态选择（大规模）vs 固定遮蔽（高延迟要求）的架构</li>
<li>为知识库实现混合检索（向量+关键词+图谱）+ Agentic探索 + 重排序</li>
</ul>
<h4 data-id="heading-29">7.3 压缩阶段</h4>
<ul>
<li>对高价值、非结构化信息使用上下文总结（Summarization）</li>
<li>对常规维护使用上下文裁剪（Trimming/滑动窗口）</li>
<li>建立分层记忆系统，确保关键结论不依赖对话历史压缩</li>
</ul>
<h4 data-id="heading-30">7.4 隔离阶段</h4>
<ul>
<li>评估任务是否真正需要多智能体架构（成本可能高达15倍）</li>
<li>设计环境沙箱分离思考与执行，处理重资产操作</li>
<li>通过运行时状态对象的Schema设计，实现内部结构化隔离</li>
</ul>
<hr/>
<h3 data-id="heading-31">结语：从算法调优到架构设计</h3>
<p>回顾整个上下文工程的演进路径：</p>
<pre><code class="hljs language-scss" lang="scss">Anthropic理论层              LangChain工程层                实践认知层
    │                            │                            │
    │   上下文腐烂的根本约束      │   WSCI框架管理上下文          │   核心挑战转移
    │   (Transformer架构限制)    │   (Write-Select-Compress-Isolate) │   (算法→架构)
    │                            │                            │
    └────────────────────────────┴────────────────────────────┘
                              │
                              ▼
              构建真正强大、可靠、可扩展的AI Agent
              其核心已从算法和模型本身
              转移到了系统性的上下文架构设计
</code></pre>
<p>这正是开发者在Agent时代的<strong>核心价值所在</strong>——不再是调模型参数，而是设计上下文架构。</p>
<hr/>
<h3 data-id="heading-32">参考资源</h3>
<ol>
<li>LangChain Documentation: Context Engineering Best Practices</li>
<li>Anthropic Research: The Challenges of Long Context in LLMs</li>
<li>Shunyu Yao et al. "ReAct: Synergizing Reasoning and Acting in Language Models"</li>
<li>Noever et al. "Generative Agents: Interactive Simulacra of Human Behavior"</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[拆解LangChain执行引擎] ManagedValue——一种特殊的只读虚拟通道]]></title>    <link>https://juejin.cn/post/7603649945978667027</link>    <guid>https://juejin.cn/post/7603649945978667027</guid>    <pubDate>2026-02-08T00:14:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603649945978667027" data-draft-id="7603649945978650643" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[拆解LangChain执行引擎] ManagedValue——一种特殊的只读虚拟通道"/> <meta itemprop="keywords" content="LangChain,Python"/> <meta itemprop="datePublished" content="2026-02-08T00:14:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JaydenAI"/> <meta itemprop="url" content="https://juejin.cn/user/3001011641261209"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [拆解LangChain执行引擎] ManagedValue——一种特殊的只读虚拟通道
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3001011641261209/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JaydenAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T00:14:01.000Z" title="Sun Feb 08 2026 00:14:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们一直在强调Pregel对象的状态是通过<code>Channel</code>维护和传递的，其实承载传递状态功能的组件除了Channel，还有  <code>ManagedValue</code>。我们可以将ManagedValue视为虚拟Channel，Node不仅采用与读取Channel完全一样的方式读取ManagedValue，而且注册的ManagedValue也直接存放在Pregel的channels字段中。</p>
<p>如果我们仔细查看Pregel类的定义，可以看出其<code>channels</code>字段返回一个字典，字典的值的类型联合了BaseChannel和<code>ManagedValueSpec</code>两种类型，前者是Channel的基类，后者就是<code>ManagedValue</code>类的别名。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pregel</span>(
    PregelProtocol[StateT, ContextT, InputT, OutputT],
    <span class="hljs-type">Generic</span>[StateT, ContextT, InputT, OutputT]): 
    channels : <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, BaseChannel | ManagedValueSpec]

ManagedValueSpec = <span class="hljs-built_in">type</span>[ManagedValue]
</code></pre>
<p>如果说Channel存储的是的业务状态，那么ManagedValue传递的就是Pregel这个执行引擎的运行时状态。一般来说，ManagedValue自身不负责存储状态，其提供的值可以实时计算得出，所以它不参与基于Checkpoint的持久化。从如下所示的代码片段可以看出，ManagedValue仅仅定义了一个唯一的静态抽象方法<code>get</code>返回对应的值，由于作为输入的<code>PregelScratchpad</code>对象提供的信息有限，所以ManagedValue能够发挥的空间其实很有限，在大部分情况下用不到它。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagedValue</span>(ABC, <span class="hljs-type">Generic</span>[V]):
<span class="hljs-meta">    @staticmethod</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">scratchpad: PregelScratchpad</span>) -&gt; V: ...
</code></pre>
<h2 data-id="heading-0">1. PregelScratchpad</h2>
<p>ManagedValue提供的值是通过其get方法根据PregelScratchpad对象计算所得。当确定后续待执行的Node后，引擎会为每个Node创建一个任务，每个任务都会附加一个PregelScratchpad对象。PregelScratchpad的<code>step</code>和<code>stop</code>字段就返回当前Superstep的序号和针对迭代的限制（最大超步数），其它字段与持久化有关。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@dataclasses.dataclass(<span class="hljs-params">**_DC_KWARGS</span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PregelScratchpad</span>:
    step : <span class="hljs-built_in">int</span>
    stop : <span class="hljs-built_in">int</span>
    call_counter : <span class="hljs-type">Callable</span>[[], <span class="hljs-built_in">int</span>]
    interrupt_counter : <span class="hljs-type">Callable</span>[[], <span class="hljs-built_in">int</span>]
    get_null_resume	: <span class="hljs-type">Callable</span>[[<span class="hljs-built_in">bool</span>], <span class="hljs-type">Any</span>]
    resume : <span class="hljs-built_in">list</span>[<span class="hljs-type">Any</span>]
    subgraph_counter	: <span class="hljs-type">Callable</span>[[], <span class="hljs-built_in">int</span>]	
</code></pre>
<p>PregelScratchpad的<code>call_counter</code>、<code>interrupt_counter</code>和<code>subgraph_counter</code>字段以闭包的形式返回一个计数器。<code>call_counter</code>计数器用于为当前Superstep内产生的所有任务分配唯一的内部序列号。</p>
<h3 data-id="heading-1">1.1 Resume Value和中断计数器</h3>
<p><code>interrupt_counter</code>、<code>get_null_resume</code>和<code>resume</code>字段与Pregel基于 “中断（Interrupt）/恢复（Resume）” 的执行方式有关。假设Pregel的对应一个需要人工介入的多级审批流程，在每次需要以人工介入的方式收集审批者决定的时候，流程进入一个中断，当前的状态被持久化。当审批决定给出后，流程以 “恢复” 的形式开始执行，中断时持久化的快照被提取出来 “恢复现场” ，审批决定以Resume Value的形式提供给引擎。为了匹配多个中断点与对应的Resume Value，后者会按照顺序被持久化，并在恢复执行的时候连同当前提供的Resume Value一并填充到PregelScratchpad的<code>resume</code>列表中。</p>
<p>恢复执行做不到在中断点出开始执行，它总是<code>从头执行</code>Node的处理函数，所以定义 <code>幂等Node</code> 应该成为Agent编程的 “金科玉律”。由于PregelScratchpad的resume字段会按照中断的顺序存放Resume Value，所以在恢复执行的时候，每遇到一个中断，引擎可以利用<code>interrupt_counter</code>字段返回的计数器作为位置索引从resume列表中将匹配的Resume Value提取出来。如果提取的Resume Value为None，或者计数器返回的索引越界，<code>get_null_resume</code>字段提供的回调就会执行。这个回调函数具有一个bool类型的参数is_called，调用时该参数被设置为True，表示该中断确实被触发了，但没有对应的数据。这会消耗掉这个中断位，确保流程不至于永远得不到恢复。</p>
<h3 data-id="heading-2">1.2 子图调用计数器</h3>
<p>如果说<code>interrupt_counter</code>计数器旨在解决每次中断与提供的Resume Value的匹配问题，那么<code>subgraph_counter</code>计数器解决的每次“子图调用”与对应Pregel实例的匹配问题。如果站在“图”的视角，每个Pregel对象就是由多个Node组成的图，而Pregel也可以作为一个Node出现在另一个Pregel构建的图中，两个Pregel之间就称为了“父子”关系，子Pregel构建的图就是“子图”，针对它的调用就是子图调用。</p>
<p>虽然在同一个图中，每个Pregel会独自完成自身的持久化。在恢复执行场景中，引擎会率先加载作为“根”的Pregel对应的Checkpoint来恢复现场。当遇到“子图”形式调用另一个Pregel时，引擎会加载对应的Checkpoint来恢复子图在中断那个时间点的状态。现在问题来了：在子Pregel众多持久化的Checkpoint中，怎么知道该加载哪一个呢？</p>
<p>这个问题本质上是如何解决作为子图执行的Pregel在执行持久化时，如何将生成的Checkpoint与当前执行上下文进行匹配的问题，这个问题是利用<code>Checkpoint命名空间</code>来解决的。Node是以任务的形式被执行的，每个任务具有唯一的ID，并且在恢复时保持不变，如果命名空间由执行链路上每个任务的<code>节点名称+任务ID</code>组成，那么子图的Checkpoint就能利用此命名空间关联起来。</p>
<p>但是问题还是没有完全解决，如果同一个任务涉及针对<code>同一子图的多次调用</code>，如命名空间只包含基于任务的执行路径，此时两个子图会共享相同的命名空间，具体对应哪个Checkpoint依然无法解决。因此若涉及同一个Node针对同一个Pregel对象的多次调用，持久化这个Pregel的Checkpoint的命名空间还应该包含<code>调用顺序</code>。</p>
<p>Checkpoint的命名空间的规则可以通过如下这个演示实例来证实。如代码片段所示，我们创建了一个由单一Node组成的Pregel对象（sub_graph），命名为 “baz” 的Node在执行的时候会从当前的RunnableConfig配置中提取并输出当前的Checkpoint命名空间。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langgraph.pregel <span class="hljs-keyword">import</span> Pregel, NodeBuilder
<span class="hljs-keyword">from</span> langgraph.channels <span class="hljs-keyword">import</span> LastValue
<span class="hljs-keyword">from</span> langgraph.checkpoint.memory <span class="hljs-keyword">import</span> InMemorySaver
<span class="hljs-keyword">from</span> langgraph.pregel._write <span class="hljs-keyword">import</span> ChannelWrite, ChannelWriteTupleEntry
<span class="hljs-keyword">from</span> langgraph.types <span class="hljs-keyword">import</span> RunnableConfig
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">args:<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>,<span class="hljs-type">Any</span>], config:RunnableConfig</span>)-&gt;<span class="hljs-literal">None</span>:
    <span class="hljs-built_in">print</span>(config[<span class="hljs-string">"configurable"</span>][<span class="hljs-string">"checkpoint_ns"</span>])
sub_node = (NodeBuilder()
    .subscribe_to(<span class="hljs-string">"start"</span>)
    .do(handle))
sub_graph = Pregel(
    nodes={<span class="hljs-string">"baz"</span>: sub_node},
    channels={
        <span class="hljs-string">"start"</span>: LastValue(<span class="hljs-literal">None</span>),
    },
    input_channels=[<span class="hljs-string">"start"</span>],
    output_channels=[])

<span class="hljs-keyword">def</span> <span class="hljs-title function_">handle1</span>(<span class="hljs-params">args:<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>,<span class="hljs-type">Any</span>]</span>)-&gt;<span class="hljs-literal">None</span>:
    sub_graph.invoke(<span class="hljs-built_in">input</span>={<span class="hljs-string">"start"</span>: <span class="hljs-literal">None</span>})

<span class="hljs-keyword">def</span> <span class="hljs-title function_">handle2</span>(<span class="hljs-params">args:<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>,<span class="hljs-type">Any</span>]</span>)-&gt;<span class="hljs-built_in">str</span>:    
    sub_graph.invoke(<span class="hljs-built_in">input</span>={<span class="hljs-string">"start"</span>: <span class="hljs-literal">None</span>})    
    sub_graph.invoke(<span class="hljs-built_in">input</span>={<span class="hljs-string">"start"</span>: <span class="hljs-literal">None</span>})

foo = (NodeBuilder()
    .subscribe_to(<span class="hljs-string">"foo"</span>)
    .do(handle1)
    .write_to(bar=<span class="hljs-literal">None</span>))
bar = (NodeBuilder()
    .subscribe_to(<span class="hljs-string">"bar"</span>)
    .do(handle2))

graph = Pregel(
    nodes={<span class="hljs-string">"foo"</span>: foo, <span class="hljs-string">"bar"</span>: bar},
    channels={
        <span class="hljs-string">"foo"</span>: LastValue(<span class="hljs-literal">None</span>),
        <span class="hljs-string">"bar"</span>: LastValue(<span class="hljs-built_in">str</span>),
    },
    input_channels=[<span class="hljs-string">"foo"</span>],
    output_channels=[],
    checkpointer= InMemorySaver())

config = {<span class="hljs-string">"configurable"</span>: {<span class="hljs-string">"thread_id"</span>: <span class="hljs-string">"123"</span>}}
graph.invoke(<span class="hljs-built_in">input</span>={<span class="hljs-string">"foo"</span>: <span class="hljs-literal">None</span>}, config=config)
</code></pre>
<p>在另一个Pregel中，我们为它设置了两个先后执行的Node（foo和bar），前者调用sub_graph一次，后者调用两次。针对三次调用，sub_graph为自身持久化设置的Checkpoint命名会以如下的形式输出，可以看出命名空间同时体现了调用链路和次序。</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">foo:36817c76-c3f7-643f-7924-0d29b39f469a|baz:311cc911-96a0-56b6-225b-28e4cece7cd9</span>
<span class="hljs-section">bar:97be6a71-1b71-7364-e691-a122cfef1a92|baz:789287de-869f-42b8-dd03-7518820daaa6</span>
<span class="hljs-section">bar:97be6a71-1b71-7364-e691-a122cfef1a92|1|baz:dd1ddd1b-fc62-b46a-c2ec-6a1d8344b793</span>
</code></pre>
<p>基于Pregel“中断/恢复”的执行方式，让我们对<code>Pregel实例</code>会有特别的理解。我们习惯了将一个通过调用某个类构造函数创建的对象视为该类型的一个实例，但是在Node的处理函数中，即使针对<code>同一Pregel实例</code>的连续两次调用都有可能出现中断，一旦恢复执行，后一个实例就有可能使根据另一个Checkpoint的状态创建的，它自然也就不是原来的那个实例了。在不断的“中断/恢复”执行流程中，所谓<code>Pregel实例</code>有时候表示成<code>对应的Checkpoint</code>可能更准确。</p>
<p>对于同一个节点任务来说，如果涉及针对同一个<code>子Pregel</code>的多次调用，从第二次调用开始，对方持久化生成的Checkpoint会将<code>调用次序</code>包含在命名空间中。与之相对的，在恢复执行的时候，也需要根据当前的执行上下文提供包含此序号的命名空间采用加载对应的Checkpoint，并最终恢复对应的Pregel对象，PregelScratchpad的subgraph_counter字段返回的计数器就是为了提供这个序号。</p>
<h2 data-id="heading-3">2. 两个原生的ManagedValue</h2>
<p>由于ManagedValue所能提供的值是根据PregelScratchpad计算生成，而后者可用的唯有表示当前和最大Superstep序号的<code>step</code>和<code>stop</code>字段，所以我们采用ManagedValue的应用场景其实很窄。我从只找到如下两个原生的ManagedValue类型，它们都定义在langgraph.managed.is_last_step这个包中。其中一个<code>IsLastStepManager</code>用于判断是否为最后一个Superstep，而<code>RemainingStepsManager</code>则用来确定余下的Superstep数。具体的实现非常简单，仅仅是针对PregelScratchpad的<code>step</code>和<code>stop</code>字段的简单运算而已。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IsLastStepManager</span>(ManagedValue[<span class="hljs-built_in">bool</span>]):
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">scratchpad: PregelScratchpad</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">return</span> scratchpad.step == scratchpad.stop - <span class="hljs-number">1</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RemainingStepsManager</span>(ManagedValue[<span class="hljs-built_in">int</span>]):
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">scratchpad: PregelScratchpad</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">return</span> scratchpad.stop - scratchpad.step
</code></pre>
<p>由于ManagedValue属于一个<code>计算属性</code>，所以它只能作为Node的输入。它可以被视为一种虚拟的Channel，Node针对ManagedValue和常规Channel的读取方式完全一致。在创建Pregel对象时，所用到的ManagedValue需要在<code>channels</code>字段中显式声明，但是不能将其添加到输入和输出Channel列表中。</p>
<p>如下的实例演示了RemainingStepsManager的使用方式，创建的Pregel由两个先后执行的Node构成（foo和bar），它们会将命名为<code>remaining_steps</code>的ManagedValue作为输入，并将其分别输出到<code>remaining_steps_after_foo</code>和<code>remaining_steps_after_bar</code>这两个Channel中，分别表示在这两个Node完成执行后所剩的Superstep数。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langgraph.pregel <span class="hljs-keyword">import</span> Pregel, NodeBuilder
<span class="hljs-keyword">from</span> langgraph.managed.is_last_step <span class="hljs-keyword">import</span> RemainingStepsManager
<span class="hljs-keyword">from</span> langgraph.channels <span class="hljs-keyword">import</span> LastValue

foo = (NodeBuilder()
       .subscribe_to(<span class="hljs-string">"foo"</span>)
       .read_from(<span class="hljs-string">"remaining_steps"</span>)
       .do(<span class="hljs-keyword">lambda</span> args: args[<span class="hljs-string">"remaining_steps"</span>])
       .write_to(remaining_steps_after_foo= <span class="hljs-keyword">lambda</span> args:args, bar=<span class="hljs-literal">None</span>))

bar = (NodeBuilder()
       .subscribe_to(<span class="hljs-string">"bar"</span>)
       .read_from(<span class="hljs-string">"remaining_steps"</span>)
       .do(<span class="hljs-keyword">lambda</span> args: args[<span class="hljs-string">"remaining_steps"</span>])
       .write_to(<span class="hljs-string">"remaining_steps_after_bar"</span>))

app = Pregel(
    nodes={<span class="hljs-string">"foo"</span>:foo, <span class="hljs-string">"bar"</span>:bar},
    channels={
        <span class="hljs-string">"foo"</span>: LastValue(<span class="hljs-literal">None</span>),
        <span class="hljs-string">"bar"</span>:LastValue(<span class="hljs-literal">None</span>),
        <span class="hljs-string">"remaining_steps_after_foo"</span>: LastValue(<span class="hljs-built_in">int</span>),
        <span class="hljs-string">"remaining_steps_after_bar"</span>:LastValue(<span class="hljs-built_in">int</span>),
        <span class="hljs-string">"remaining_steps"</span>: RemainingStepsManager, 
    },
    input_channels=[<span class="hljs-string">"foo"</span>],
    output_channels=[<span class="hljs-string">"remaining_steps_after_foo"</span>, <span class="hljs-string">"remaining_steps_after_bar"</span>])

config = {<span class="hljs-string">"recursion_limit"</span>: <span class="hljs-number">10</span>}
result = app.invoke({<span class="hljs-string">"foo"</span>:<span class="hljs-literal">None</span>}, config=config)
<span class="hljs-keyword">assert</span> result[<span class="hljs-string">"remaining_steps_after_foo"</span>] == <span class="hljs-number">10</span>
<span class="hljs-keyword">assert</span> result[<span class="hljs-string">"remaining_steps_after_bar"</span>] == <span class="hljs-number">9</span>
</code></pre>
<p>在根据两个Node创建Pregel对象时，我们将针对命名为<code>remaining_steps</code>的ManagedValue的声明添加到channels字段中，对应的类型被设置为RemainingStepsManager。由于在调用Pregel对象时利用RunnableConfig配置将Superstep迭代限制为10，所以先后执行的两个Node后剩余步数分别为10和9。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[当我花30分钟让AI占领了我的树莓派]]></title>    <link>https://juejin.cn/post/7603771025855414323</link>    <guid>https://juejin.cn/post/7603771025855414323</guid>    <pubDate>2026-02-08T00:34:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025855414323" data-draft-id="7603674653153067017" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="当我花30分钟让AI占领了我的树莓派"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-08T00:34:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Leoobai"/> <meta itemprop="url" content="https://juejin.cn/user/3748697469623344"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            当我花30分钟让AI占领了我的树莓派
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3748697469623344/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Leoobai
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T00:34:25.000Z" title="Sun Feb 08 2026 00:34:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">当我花30分钟让AI占领了我的树莓派</h2>
<h3 data-id="heading-1">碳基生命的背叛,或许只是工程师思维的下一次迭代</h3>
<p>周六晚上,我坐在屏幕前,花了30分钟,让一个叫Claude Code的 AI开发工具完成了OpenClaw的配置。当我看到终端里那一串绿色的"✅"时,一种奇妙的感觉涌上心头——我刚刚亲手为"硅基生命"打开了进入我个人设备的大门。</p>
<pre><code class="hljs language-markdown" lang="markdown">🤖 立即开始使用
Telegram Bot 使用
<span class="hljs-bullet">1.</span> 打开 Telegram 搜索 @Leoobai<span class="hljs-emphasis">_Npc_</span>bot
<span class="hljs-bullet">2.</span> 发送任何消息，Bot 会用 Claude AI 回复
<span class="hljs-bullet">3.</span> 401 认证错误已解决，现在可以正常对话！
</code></pre>
<p>看着这段反馈,我愣了一下。怎么说呢,感觉有点像你养了只猫,结果某天发现它学会了开冰箱。AI不再只是云端的对话框,它已经坐在了我的树莓派上,随时准备接管我的工作。</p>
<h3 data-id="heading-2">两条路径:云端的Manus与本地的OpenClaw</h3>
<p>最近AI圈有两个现象级产品同时爆火:一个是Manus,一个是OpenClaw。它们代表了硅基生命渗透人类工作的两种截然不同的路径。</p>
<p><strong>Manus选择了云端虚拟机的方式。</strong></p>
<p>它在云端创建了一个独立的"电脑",当你给它下达任务后,它会像真实的员工一样,在那台看不见的虚拟机里搜索资料、编辑文档、生成报表。你甚至可以关掉自己的电脑去喝咖啡,等回来时,工作已经完成了。</p>
<p>据报道,Manus背后运行着8000万台虚拟机。8000万个数字员工,这个数字让我想起了《宇宙工程师之歌》里的一个观点:硬科幻的核心不是技术本身,而是用工程师的思维模式去构建一个可运转的系统。Manus做的正是这件事——它把"AI助手"变成了一套可以量化和扩展的工程体系。</p>
<p>但Manus有个问题:它在云端,你看不见它在做什么,只能看结果。说白了就是个黑箱,你信它就用,不信也没办法验证。</p>
<p><strong>OpenClaw则选择了占领用户PC的方式。</strong></p>
<p>当我在树莓派上部署OpenClaw时,我清楚地知道:这个AI现在拥有了我设备上的系统级权限。它可以读写文件、运行终端命令、操作浏览器、收发邮件,甚至可以自己编写代码创建新技能。</p>
<p>从技术角度看,OpenClaw其实没什么黑科技。它调用的是Anthropic的Claude API,用的是开源框架,跑在普通设备上。但关键是,它让AI不再只是给你提建议,而是真的能动手干活了——直接在你的设备上执行任务。</p>
<p>更有意思的是,OpenClaw在短短两周内获得了15万+的GitHub星标,成为历史上增长最快的开源项目之一。它的创始人Peter Steinberger是个奥地利程序员,14岁开始编程,第一件事就是偷学校的DOS游戏然后写防拷贝程序去卖钱。现在他一个人,一台电脑,几周时间,就做出了让所有AI巨头感到威胁的产品。</p>
<h3 data-id="heading-3">我的30分钟实验:真就这么简单?</h3>
<p>说回我的树莓派。</p>
<p>其实OpenClaw这个项目我关注很久了,一直想找时间尝试,但总是被各种事情耽搁。这次终于抽出时间,决定亲手部署一下,看看让AI在本地设备上运行到底是什么体验。</p>
<p>整个过程比我想象的简单。我把任务交给Claude Code,它帮我完成了环境配置、依赖安装、Telegram Bot设置、API端点配置......30分钟后,一切就绪。</p>
<p>最让我印象深刻的是这一行:</p>
<pre><code class="hljs language-bash" lang="bash">AI 模型: anthropic/claude-opus-4-6
API 端点: https://code.newcli.com/claude/aws
</code></pre>
<p>AI在配置AI。这个画面本身就充满了某种递归式的诗意。</p>
<p>现在,我可以通过Telegram给我的树莓派发消息,让它帮我处理各种任务。它不是在云端运行,而是就在我家里的这个小盒子里,随时待命。</p>
<h3 data-id="heading-4">这是背叛吗?还是进化?</h3>
<p>"碳基生命的背叛,硅基生命的渗透"——这个标题听起来很悲观,像是在描述某种末日。但我现在的感受更复杂。</p>
<p>我想起《宇宙工程师之歌》里的一段话:工程师的思维模式是什么?是"坚实地放好下面的一块砖,再去放上面一块"。是在材料、能源、环境、经济等多重约束下,把灵感折算成可实施方案。是相信科技是正面力量,问题导向而非悲观渲染。</p>
<p>说白了,Manus和OpenClaw都不是什么背叛,就是工程师干活的方式又升级了一轮。</p>
<p>Manus用云端虚拟机解决了算力分配、任务隔离、可扩展性的问题。它的多智能体架构——规划代理、执行代理、验证代理的协同——本质上就是把复杂工程拆解成可验证的子系统。这不就是工程师每天在做的事吗?</p>
<p>OpenClaw则更进一步。它不仅让AI执行任务,还让AI可以修改自己。如果你让AI从Git仓库运行OpenClaw,它可以读取自己的源代码,重新配置自己,然后重启。要么崩溃,要么获得新能力。你品品,这不就是程序员天天念叨的"持续优化"吗,只不过这次优化自己的不是人了。</p>
<h3 data-id="heading-5">硅基生命的渗透,碳基生命的解放?</h3>
<p>最近有个统计数据让我印象深刻:1985到2005年,美国ATM机从10万台涨到40万台,但银行柜员数量反而增加了10%。因为柜员的工作从处理现金交易,变成了提供金融服务和解决问题。</p>
<p>也许AI对人类工作的替代,也会是类似的故事。</p>
<p>当Manus和OpenClaw这样的工具普及后,人干的活大概会变——更多是想清楚让AI做什么、盯着它别跑偏、以及那些需要拍脑袋做判断的事。</p>
<p>说到底就是分工变了。</p>
<p>我现在可以把重复性的、流程化的工作交给树莓派上的OpenClaw,然后把时间用在真正需要动脑子的事情上。挺好的,不亏。</p>
<h3 data-id="heading-6">给工程师们的一个提醒</h3>
<p>但我也必须说,这种解放是有代价的。</p>
<p>OpenClaw的GitHub页面上有个醒目的警告:"OpenClaw具有系统级权限,请在独立的服务器上部署,避免在生产环境或重要数据的机器上运行。"</p>
<p>已经有安全研究人员发现,有1800多个OpenClaw实例暴露在公网上,API密钥泄露,恶意技能传播......这些都是真实发生的安全事故。</p>
<p>Simon Willison把这称为"致命三合一":强大的能力+开放的架构+缺乏安全意识。</p>
<p>所以,如果你也想尝试OpenClaw或者Manus,请务必:</p>
<ol>
<li>理解你在做什么</li>
<li>控制AI的权限范围</li>
<li>在隔离环境中测试</li>
<li>定期检查日志和行为</li>
</ol>
<p>该谨慎的地方别偷懒,这是基本素养。</p>
<h3 data-id="heading-7">最后</h3>
<p>我的树莓派现在正在安静地运行着。偶尔,我会收到Telegram的消息,那是OpenClaw在向我汇报工作进度。</p>
<p>这种感觉挺微妙的。说是我在用它吧,但它确实也在改变我的工作方式。</p>
<p>碳基生命的背叛?想多了。</p>
<p>硅基生命的渗透?这倒是真的。</p>
<p>不过怎么说呢,从Manus的云端虚拟机,到OpenClaw跑在我家树莓派上,AI这东西越来越像个干活的搭子了。它不会取代你,但你得学会跟它搭伙。</p>
<p>就像《宇宙工程师之歌》里说的,工程师干的事就是用理性和务实把不可能变成可能。现在多了个硅基搭档,活还是那些活,干法不一样了而已。</p>
<hr/>
<p><strong>附:我的OpenClaw配置清单</strong></p>
<ul>
<li>硬件:树莓派(任何型号都可以)</li>
<li>系统:Linux(Ubuntu/Debian)</li>
<li>AI模型:Claude Opus 4.6(通过API调用)</li>
<li>通讯渠道:Telegram</li>
<li>部署时间:30分钟</li>
<li>配置难度:中等(需要基本的命令行知识)</li>
</ul>
<p>如果你也想尝试,记得:理解风险,控制权限,享受过程。</p>
<p><em>P.S. 写这篇文章的时候,我的OpenClaw正在后台帮我整理文件夹。碳基生命还在思考,硅基生命已经在干活了。</em>
<img src="https://fastly.jsdelivr.net/gh/bucketio/img7@main/2026/02/08/1770510636173-5f03022b-a4ae-43c5-9b1e-8b19871ebb6a.jpg" alt="" loading="lazy"/>
我的树莓派不太一样，他是rk3588，一个有16G内存、256G存储和6Tops的算力的power box。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[词法分析(1)：从demo代码中抽象]]></title>    <link>https://juejin.cn/post/7603651011979116586</link>    <guid>https://juejin.cn/post/7603651011979116586</guid>    <pubDate>2026-02-08T00:50:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651011979116586" data-draft-id="7603643044034592804" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="词法分析(1)：从demo代码中抽象"/> <meta itemprop="keywords" content="编译原理"/> <meta itemprop="datePublished" content="2026-02-08T00:50:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="搞笑僵尸思考时间"/> <meta itemprop="url" content="https://juejin.cn/user/168673917806618"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            词法分析(1)：从demo代码中抽象
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/168673917806618/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    搞笑僵尸思考时间
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T00:50:00.000Z" title="Sun Feb 08 2026 00:50:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​本系列讲义适用于：被强迫学习编译原理前端，或者希望弄明白如何做科研的人</p>
<h2 data-id="heading-0">前言</h2>
<p>词法分析是编译原理对初学者的下马威，是一个马上就开始让人迷惑的章节。“到底学这些什么3型文法概念干嘛的，我不用这些概念不行吗？”类似的疑问想必不绝于耳。因此，本文将从一个极简单的例子出发，逐步提高难度，最终解释清楚为什么特事特办的民科方法没有前途，终究要研究一点理论，才能让自己在遇到同类问题的时候遇神杀神遇佛杀佛。</p>
<p>因此，如果你在快速浏览本文的过程中看到一些和课本上完全不一样的式子，不要害怕，这是还在推导，最后出来的一定是你熟悉的那个正则问题。</p>
<h2 data-id="heading-1">第一式：见微知著，从简单示例开始研究问题</h2>
<p>先来看一个最简单的程序：</p>
<p>int main() { int a = 15 + 2; //This is a comment }</p>
<p>就这么一个简单的程序，它在硬盘里是这样的</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/555915c9b0bd410d9d779d248c78e773~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771116602&amp;x-signature=hieIQS8Qr6AHiT2tm2rEujYOoZw%3D" alt="" loading="lazy"/><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/>​​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc650b43f68b4d9eaf2517537f9ae3df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771116602&amp;x-signature=Lxf0Kq22fyCwgQcEaTcozXvhnuI%3D" alt="" loading="lazy"/><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f5d7de398b440789c4626b6800d50fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771116602&amp;x-signature=ENFb9pMCQfvE%2F%2F%2BJpkGIRawDtjk%3D" alt="" loading="lazy"/></p>
<p>可以看到，原本在人眼中像画一样以二维形式铺开的代码，在底层看来只不过就是一串符号。之所以能看到美妙的格式，无非是因为机器知道遇到\r\n之后要从新的一行打印后续符号。</p>
<p>要精确和高效识别这堆什么都有的混合物中每一种成份，你首先应该了解你即将要面对的是什么，才能更好地定义你问题的边界，而不会考虑太多实际上并不会遇到的问题</p>
<p>对于我们的代码而言，首先要做的就是筛选出单词的种类，再分别研究它们的特点，分而治之。</p>
<h2 data-id="heading-2">第二式：分而治之</h2>
<p>通过分类，这个文件中的符号可以整理成以下几类：</p>
<p>1。关键词（保留字）。int。这一类的单词特点是，绝对不会和其他类别的单词重复，他的种类有限，就是一些英文字符串。</p>
<p>2。运算符。+。作用就是参与运算，种类也是极其有限。</p>
<p>3。界限符。{}, (), 空格，;。作用就是让机器在后续分析的时候，知道当前分析的这个语法单元从哪开始到哪结束。他的种类也是极其有限。</p>
<p>4。空白字符，换行。\r\n。对代码几乎完全没影响的符号，可以在识别到之后直接忽略。</p>
<p>5。标识符。main, a。允许用户自定义起名。组成的规则有限制，长度不定，种类也不确定。</p>
<p>6。常量。15, 2。除了数字外，还有可能包含16进制数所附加的a-fx；另外还有一类常量叫字符串，里面是什么符号都可以包含。所以常量和标识符一样，种类和长度也都完全不确定。</p>
<p>7。注释。 //This is a comment。对于注释而言，只要找到他标记的开始和结束，再长也都可以看作一个整体。</p>
<p>对于繁杂的分类，一类一类治理只会浪费精力和时间。所以接下来就需要对它们进行归类，从而降低自己思考的难度并发现共性方法，最终统一处理他们，合而治之。</p>
<p>容易观察到：</p>
<p>对于前四类，由于都是种类与长度也有限，通过简单的字符串匹配就可以识别出来，这一类实现起来没有难度，先不考虑。</p>
<p>对于后三类，则需要通过特定规则进行匹配。那么，这些规则是什么？</p>
<p>a. 标识符：只要第一位不是数字，后面随便你放数字、下划线或者字母。</p>
<p>b. 十进制无符号常数：从前到后全部都是数字。</p>
<p>下面请读者独立完成对应的识别程序。</p>
<p>啪的一声，很快啊，gemini马上就给出了一个样例伪代码：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">获取 单词的 第一个字符
<span class="hljs-keyword">if</span> 第一个字符 不是 数字:
    <span class="hljs-comment">// 可能是标识符，检查一下后面</span>
    <span class="hljs-keyword">for</span> 第二个到最后一个字符:
		<span class="hljs-keyword">if</span> 这个字符 不是 (字母 or 数字 or 下划线):
		   <span class="hljs-keyword">return</span> <span class="hljs-string">"无效标识符 (含非法字符)"</span>
		<span class="hljs-comment">// if循环检查完毕都没问题</span>
		<span class="hljs-keyword">return</span> <span class="hljs-string">"标识符"</span>
<span class="hljs-keyword">else</span> 
	<span class="hljs-keyword">if</span> 第一个字符 不是 数字:
		<span class="hljs-comment">// 可能是十进制常数，检查一下</span>
		<span class="hljs-keyword">for</span> 单词中的每一个字符:
			<span class="hljs-keyword">if</span> 这个字符 不是 数字:
				<span class="hljs-keyword">return</span> <span class="hljs-string">"无效单词 (数字开头却有非数字)"</span>
		<span class="hljs-comment">// 如果循环检查完毕都没问题</span>
		<span class="hljs-keyword">return</span> <span class="hljs-string">"十进制无符号常数"</span>
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">return</span> <span class="hljs-string">"无效标识符 (含非法字符)"</span>
</code></pre>
<p><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/></p>
<p>Emmmm，很好。看来我们已经可以很好地识别这两类单词了。词法分析也不过如此嘛，那我们继续开始语法分析吧！</p>
<p>老板：稍等一下，那个谁，我这程序里有几类新的常量，规则也给到你了，你帮我也实现一下。</p>
<p>c. 十六进制常数：0x开头的，后面跟着0-9a-f；</p>
<p>d. 带符号整数：比无符号整数可能会多了一个正负号；</p>
<p>你：好的老板，这几个好弄，我马上弄好。</p>
<p>噗嗤噗嗤一阵捣鼓。</p>
<p>你：老板我弄好了。</p>
<p>老板：好的谢谢。那啥，这里又来几类新的，你再处理一下：</p>
<p>e. 带下划线的整数：在整数中间允许下划线存在,但下划线不会出现在最后和最前，以及不会出现连续两个下划线</p>
<p>你：？？？还能这样？</p>
<p>老板：Python早就用上了呀</p>
<p>你：不干了不干了！！！什么鬼，乱加需求，不能一开始就想好吗？？</p>
<p>老板：不好意思，真的不行，需求是不断变化的。那这个工作你是干还是不干？</p>
<p>你：不是老板你这需求加得太离谱了呀，后面来的需求还会和前面的需求打架，我这代码改来改去都成浆糊了呀！！</p>
<p>老板：那有没有可能，有更加简单的代码实现呢？</p>
<p>你：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb6826b0fedb45c58b2d05e8cd2cfa5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771116602&amp;x-signature=IdvYjhqmAgkQdTvY7pM6lzk4XMM%3D" alt="" loading="lazy"/><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/>​编辑</p>
<p>曹老板别急着把天聊死。没准拨开迷雾后会有惊喜呢。</p>
<h2 data-id="heading-3">第三式：规范化与抽象</h2>
<p>下面通过逐步的抽象，来让我们逐渐到达事情的本质。</p>
<p>首先要抽象/化简的，就是这些该死的，用自然语言描述的abcde五条规则。他们最大的问题就是都各有各的说法。所以为了找到共同点，首先要让他们用统一的方式进行描述，也即所谓的规范化，算是某种程度上的对齐颗粒度。</p>
<blockquote>
<p>a. 标识符：只要第一位不是数字，后面随便你放数字、下划线或者字母。 b. 十进制无符号常数：从前到后全部都是数字。 c. 十六进制常数：0x开头的，后面跟着0-9a-f； d. 带符号整数：比无符号整数可能会多了一个正负号； e. 带下划线的整数：在整数中间允许下划线存在,但下划线不会出现在最后和最前，以及不会出现连续两个下划线</p>
</blockquote>
<p>可以隐约看出来，一旦前面的符号确定了，那么下一位符号的可选范围也就确定了。</p>
<p>由此，这几条规则都规范化成：当前如果是某个符号，那么它后面可以是什么符号。</p>
<p>但等一下，最开始的时候字符串还没有生成，并没有什么符号。那我们假设句子的最前面有个表示空气的符号ε（音：epsilon，主要是对应于Empty，但直接用E又容易惹误会。有的教材使用λ，意为虚无），最后也有一个文件结束符EOF或特殊符号$作为结束符，这样就可以规范化为：</p>
<blockquote>
<p>a：如果当前符号是ε，那么后面可以是字母或下划线；如果当前符号是字母或下划线或数字，那么后面可以是字母或者下划线或者数字或者结束符； b：如果当前符号是ε，那么后面可以是0-9之一；如果当前符号是0-9之一，那么后面可以是0-9之一或者结束符； c：如果当前符号是ε，那么后面可以是0；如果当前符号是0，后面可以是x；如果当前符号是x，后面可以是0-9a-fA-F之一；如果当前符号是0-9a-fA-F之一，后面可以是0-9a-fA-F之一或者结束符； d：如果当前符号是ε，后面可以是正负号或者0-9；如果当前符号是正负号，后面可以是0-9之一；如果当前符号是0-9之一，后面可以是0-9之一或者结束符； e：如果当前符号是ε，后面可以是0-9之一；如果当前符号是0-9之一，后面可以是0-9之一或者下划线或者结束符；如果当前符号是下划线，后面可以是数字。</p>
</blockquote>
<p>念经一样枯燥无味对吧，但绝对比之前的版本要清晰和无歧义。</p>
<h2 data-id="heading-4">第四式：合而治之</h2>
<p>有了规则之后，我们来想象一台生成这些单词的机器，这台机器会像雪糕机那样不停地屙出来符号，关键在于特定机器屙出来的单词最后一定符合规则。</p>
<p>上面规范化的规则倒是有那么一回事了，但你想要让机器听明白，好像还差那么一点意思。机器只看得懂符号，看不懂自然语言。</p>
<p>聪明的你一定想到了，那我用公式来表示这些规则不就好了么。问题是，你要怎么定义你的公式规则呢？</p>
<p>如果当前符号是x，那么后面可以是y</p>
<p>→if ch==x then y //由于if ch==这样的开头在每条式子里都是一样的，可以省略。</p>
<p>→x-&gt;y //由于x then y还是太麻烦了，把中间的then换成箭头表示跟随</p>
<p>对于x或y有多个选项的场合，用集合来表示，如：</p>
<p>x-&gt;[a-f0-9]</p>
<p>另外还是用希腊字母ε表示开始。那我们就可以把上面的规则a以如下形式展示（其他几个请读者自行转换）：</p>
<p>a：ε-&gt;[a-zA-Z_]；[a-zA-Z_0-9]-&gt;[a-zA-Z_0-9$]；</p>
<p>啊，一身清爽，这下规则也有了，那差不多可以小试一下牛刀了吧？</p>
<blockquote>
<p>f：以a开头，b做结尾，中间要有偶数个c的符号串。 f：ε-&gt;a；a-&gt;[cb]；c-&gt;[bc];b-&gt;$;</p>
</blockquote>
<p>聪明的你估计已经发现问题了，这套表示方法好像无法表示c的奇偶性。他会产生出acb这样的错误单词出来。</p>
<p>所以，规则的左边出了问题：不应该让特定符号出现在左边，因为在不同的场合下，即使是相同符号的后跟符号也存在差异。</p>
<p>那这样吧，我们挨个把这些场合通过字母+下标的方式区分，这样就既知道当前处于哪个小写符号，又知道这是针对哪个特殊场景。这样我们就有：</p>
<p>f：ε-&gt;a；a-&gt;[b]； -&gt;; -&gt;[b]; b-&gt;$;</p>
<p>恭喜你，发明了一种描述单词结构的规则。</p>
<p>先不论这种规则的表示方法符不符合主流写法，我说这种规则无歧义地描述了我想要的单词的结构，应该不会有人有意见。</p>
<h2 data-id="heading-5">第五式：吐槽与迭代</h2>
<p>构建出来是一回事，好不好用又是另一回事。下面开启吐槽大会：</p>
<p>首先，这个下标用起来不方便（用公式编辑器打一个试试），还有一般用不到的莫名其妙的希腊字母ε；（作者注：希腊字母这个属于约定俗成，吐槽你也没办法╮(￣▽￣)╭）</p>
<p>第二，也是最重要的一点，这个规则不方便进行推导。比如，我现在想要知道这个规则集到底能生成哪些单词，你只能编写一个程序，然后从ε出发，然后找出后面是什么符号，之后改变当前符号后，再查一下当前符号对应的规则。最麻烦的是，由于下标的存在，还不能直接根据当前符号来确定使用的哪个规则，还要用一个辅助变量来记录。导致查表的过程非常麻烦。</p>
<p>注意到，这个带下标的符号，实际上代表了两层意思：1. 符号本身；2.这个符号所处的特殊场景。</p>
<p>当处于某个节点，实际上是由2而不是1来决定下一个符号应该是啥。在选定了下一个符号后，那么我们所处的节点将会更新成这个符号所对应的特殊场景（我们称为“状态”）中。</p>
<p>因此，有必要把符号代表的状态和符号本身进行抽离。把具体的象抽离，只剩下纯粹的概念，这就是真正的抽象。</p>
<p>在实际操作中，可以简单地把单纯的一个实义符号，拆解成实际的符号加上它所处的状态名称。如a拆解成aA， 拆解成cC, 拆解成cD。我们并不真的关心到底要处理什么符号，所以式子中的小写字母代表在单词中真实出现的字母；大写字母表示虚拟的、抽象的状态，而不是这个字母本身。</p>
<p>前面提到，对于后面即将产生什么符号，实际上我们可以只关心当前处于什么状态，并不用关心符号本身是什么。所以对于产生式左边的符号而言，可以直接写出当前我们想讨论的状态本身，而不用带上对应的实义符号。</p>
<p>比如，原先的a-&gt;b, 可以写作A-&gt;bB。其中A表示在生成a之后所处的状态，除了A以外还可以用其他自定义符号。B表示在选择了b之后所进入到的新状态。</p>
<p>对于原来类似c-&gt;[a-zA-Z_]的式子，集合中的字母都对应了同一个新状态，因此可以简写为：C-&gt;[a-zA-Z_]B。</p>
<p>对于a-&gt;[b]这样两个符号分别对于不同状态的情况，我们可以对集合进行拆解，得到：A-&gt;cC|bX，中间的竖线表示“或”。你也可以理解为：你现在看到左右两条路被中间的竖线分隔，现在只能挑一条路来走。</p>
<p>最后讨论两个特殊情况：开始和结束。</p>
<p>万事必须要有头，因此我们一般情况下用（Start）的首个字母S表示开始状态，当然也可以指定别的大写字母。</p>
<p>对于结束时刻的状态，由于<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>直接就代表结束，我们不再关心其后的状态，因此</mtext></mrow><annotation encoding="application/x-tex">直接就代表结束，我们不再关心其后的状态，因此</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord cjk_fallback">直接就代表结束，我们不再关心其后的状态，因此</span></span></span></span></span>后面可以什么都不接，比如上面的A-&gt;bX之后紧跟一条X-&gt;<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。甚至可以更极端一点，省略那些只会生出</mtext></mrow><annotation encoding="application/x-tex">。甚至可以更极端一点，省略那些只会生出</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord cjk_fallback">。甚至可以更极端一点，省略那些只会生出</span></span></span></span></span>的状态，比如上面就可以写作A-&gt;b。另外，既然ε表示无，那用ε直接表示结束也是可以的。</p>
<p>由此，可以改写出a的一个新版规则集：</p>
<blockquote>
<p>A-&gt;[a-zA-Z_]B B-&gt;[a-zA-Z_0-9]B | ε；</p>
</blockquote>
<p>换句话说，对于B这个状态后续实际上有两个支线：一种是“后面还能接更多符号”（B-&gt;[a-zA-Z_0-9]B）；另一种是“这个符号就是结尾了”（B-&gt;ε）。</p>
<p>由于这两种情况有共同的左部B，所以可以合并在一起，用“|”分隔，从而让我们在一个规则里同时表达多种可能性。</p>
<p>由此我们终于得到一个相对好用的稳定规则方案。</p>
<p>最终成果：用新范式重写全部规则</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">a</span>（标识符）：<span class="hljs-selector-tag">A</span>-&gt;<span class="hljs-selector-attr">[a-zA-Z_]</span><span class="hljs-selector-tag">B</span> | <span class="hljs-selector-attr">[a-zA-Z_]</span>；<span class="hljs-selector-tag">B</span>-&gt;<span class="hljs-selector-attr">[a-zA-Z_0-9]</span><span class="hljs-selector-tag">B</span> | <span class="hljs-selector-attr">[a-zA-Z_0-9]</span>
<span class="hljs-selector-tag">b</span>（十进制无符号整数）：<span class="hljs-selector-tag">A</span>-&gt;<span class="hljs-selector-attr">[0-9]</span><span class="hljs-selector-tag">A</span> | <span class="hljs-selector-attr">[0-9]</span>
c（十六进制无符号整数）：<span class="hljs-selector-tag">A</span>-&gt;<span class="hljs-number">0</span>B；<span class="hljs-selector-tag">B</span>-&gt;xC; C-&gt;<span class="hljs-selector-attr">[0-9a-fA-F]</span>C | <span class="hljs-selector-attr">[0-9a-fA-F]</span>
d(有符号十进制整数)：S -&gt; +<span class="hljs-selector-tag">A</span> | -<span class="hljs-selector-tag">A</span> | <span class="hljs-selector-tag">A</span>; <span class="hljs-selector-tag">A</span>-&gt;<span class="hljs-selector-attr">[0-9]</span><span class="hljs-selector-tag">A</span> | <span class="hljs-selector-attr">[0-9]</span>
e（带下划线整数）：<span class="hljs-selector-tag">A</span>-&gt;<span class="hljs-selector-attr">[0-9]</span><span class="hljs-selector-tag">B</span>；<span class="hljs-selector-tag">B</span>-&gt;<span class="hljs-selector-attr">[0-9]</span><span class="hljs-selector-tag">B</span> | <span class="hljs-selector-attr">[0-9]</span> | _C; C-&gt;<span class="hljs-selector-attr">[0-9]</span><span class="hljs-selector-tag">B</span> | <span class="hljs-selector-attr">[0-9]</span>
</code></pre>
<p>你定义规则的过程，就是在定义一门新语言的过程。</p>
<p>在后面会看到，还会有其他奇奇怪怪的语法糖去提高这套规则的易用性(包括把中间的[a-z]替换成(a|b|...|z)从而确保正则文法中出现更少的特殊符号，我之所以不在上面提及，一个是这个点不太重要，读者可以自行推导，另一个是我不想引入太多希腊字母等一些约定俗成的东西扰乱读者理解)。但其核心万变不离其宗，就是这一套：从一个状态跳转到另一个状态的规则描述方法。</p>
<h2 data-id="heading-6">小结</h2>
<p>本节从基本问题入手，让读者朋友发现总是特事特办（也称作Ad Hoc方法，拉丁语，意为特例）终究不是个法子，有必要找到要处理问题的共性，从而先提出一个统一的基本模型，之后再进行泛化处理。</p>
<p>实话实说，这一套方法算是我看了答案，知道终点在哪里，再去从零进行推导，难免有作弊的嫌疑，在此先谢罪一个。</p>
<p>但我相信其中的几个关键步骤：从简单问题入手，分而治之，抽象提取共性，合而治之，以及吐槽与迭代，是每个问题都绕不过去的必经之路。</p>
<p>希望本文能对你们有帮助，也欢迎各位多多点赞支持，也欢迎通过各种方法不惜赐教，在此谢过。</p>
<p>下一章将会从这套规则出发，讲清楚如何借助一点点理论，完成我们万法归一的终极目的，用一套方法打遍词法分析无敌手。</p>
<h2 data-id="heading-7">附录：在线算法与离线算法</h2>
<p>在很多教材中，普遍都是先介绍词法分析，再介绍语法分析。</p>
<p>但其实，两者并没有必然的先后顺序。</p>
<p>先进行词法分析再进行语法分析，是希望能从一堆符号中，先把单词token全部识别出来之后，再去对这些单词进行语法分析。</p>
<p>这样的好处就像是流水线，前面把信息过滤了一遍之后，后面的流程就只需要针对提纯后的信息流进行处理，要考虑的杂质要少很多。</p>
<p>这固然是一种很好的方法，但并不是唯一的方法。想想我们自己读一句英文，是一边读单词一边理解这句话，说明语法分析和词法分析是交替/并行进行的。</p>
<p>对于前者，由于得整句话输入完后才能进行词法分析，再进行语法分析。所以这其实是一种离线算法。对于后者，由于可以一边输入一边进行分析，在输入完最后一个单词后几乎马上就可以得出最终的结果（语法树），所以我们把这种方法称为在线算法。</p>
<p>在线算法和离线算法并没有绝对的谁优谁劣，只有是否适用具体的场景。</p>
<p>比如，在一个计算平均值的场景中，如果你采用在线算法，可以只使用两个内存空间，一个用来累加，一个用来记数，从而在接收到用户输入结束信号之后，马上算出来最终结果。但如果你采用离线算法，就需要与数据个数等大的空间去临时存放这些数据，再在最后一次性计算平均值。如果用户是一个一个输入数据，那么不可避免地中间会出现对于电脑而言极大的性能浪费，在线算法一方面能充分利用这些时间，一方面又能节约空间；但如果数据是从文件中一次性读取，程序又是个单线程的话，减少程序的上下文切换的离线算法将会是一种效率更高的算法。</p>
<p>为了行文方便，本系列也将以离线算法的方式介绍，先介法分析，再到语法分析。读者在掌握核心原理后，可自行组装出对应的在线算法。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>