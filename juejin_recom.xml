<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[pgadmin的导出图实现，还在搞先美容后拍照再恢复？]]></title>    <link>https://juejin.cn/post/7603895839557550143</link>    <guid>https://juejin.cn/post/7603895839557550143</guid>    <pubDate>2026-02-09T03:20:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603895839557550143" data-draft-id="7603895839557517375" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="pgadmin的导出图实现，还在搞先美容后拍照再恢复？"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T03:20:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="lyrieek"/> <meta itemprop="url" content="https://juejin.cn/user/1398234521275102"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            pgadmin的导出图实现，还在搞先美容后拍照再恢复？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1398234521275102/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    lyrieek
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:20:26.000Z" title="Mon Feb 09 2026 03:20:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>PostgreSQL18的pgadmin中有一个<code>ERDTool.jsx</code>有1132行，这个体量理论上说非常庞大，但做过现实工程的都知道，其实只能算重组件中的mini尺寸了。pgadmin功能并不算有多丰富，怎么还是做成这样呢，当然不是维护团队不会拆分，毕竟还是做了199个jsx的。</p>
<p>首先映入眼帘的是<code>registerEvents</code>对19个<code>EventBus</code>的监听，这东西让人倒吸一口凉气，其中最醒目的莫过于<code>this.eventBus.registerListener(ERD_EVENTS.DOWNLOAD_IMAGE, this.onImageClick)</code>，名字就不对劲，实现能如何呢？那么看一下这个<code>onImageClick()</code>：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-title function_">onImageClick</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLoading</span>(<span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Preparing the image...'</span>));

    <span class="hljs-comment">/* Move the diagram temporarily to align it to top-left of the canvas so that when
     * taking the snapshot all the nodes are covered. Once the image is taken, repaint
     * the canvas back to original state.
     * Code referred from - zoomToFitNodes function.
     */</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagramContainerRef</span>.<span class="hljs-property">current</span>?.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'ERDTool-html2canvasReset'</span>);
    <span class="hljs-keyword">const</span> margin = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> nodesRect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getEngine</span>().<span class="hljs-title function_">getBoundingNodesRect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getModel</span>().<span class="hljs-title function_">getNodes</span>());
    <span class="hljs-keyword">let</span> linksRect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getBoundingLinksRect</span>();

    <span class="hljs-comment">// Check what is to the most top left - links or nodes?</span>
    <span class="hljs-keyword">let</span> topLeftXY = {
      <span class="hljs-attr">x</span>: nodesRect.<span class="hljs-title function_">getTopLeft</span>().<span class="hljs-property">x</span>,
      <span class="hljs-attr">y</span>: nodesRect.<span class="hljs-title function_">getTopLeft</span>().<span class="hljs-property">y</span>
    };
    <span class="hljs-keyword">if</span>(topLeftXY.<span class="hljs-property">x</span> &gt; linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">x</span>) {
      topLeftXY.<span class="hljs-property">x</span> = linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">x</span>;
    }
    <span class="hljs-keyword">if</span>(topLeftXY.<span class="hljs-property">y</span> &gt; linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">y</span>) {
      topLeftXY.<span class="hljs-property">y</span> = linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">y</span>;
    }
    topLeftXY.<span class="hljs-property">x</span> -= margin;
    topLeftXY.<span class="hljs-property">y</span> -= margin;

    <span class="hljs-keyword">let</span> canvasRect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-title function_">getBoundingClientRect</span>();
    <span class="hljs-keyword">let</span> canvasTopLeftOnScreen = {
      <span class="hljs-attr">x</span>: canvasRect.<span class="hljs-property">left</span>,
      <span class="hljs-attr">y</span>: canvasRect.<span class="hljs-property">top</span>
    };
    <span class="hljs-keyword">let</span> nodeLayerTopLeftPoint = {
      <span class="hljs-attr">x</span>: canvasTopLeftOnScreen.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getModel</span>().<span class="hljs-title function_">getOffsetX</span>(),
      <span class="hljs-attr">y</span>: canvasTopLeftOnScreen.<span class="hljs-property">y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getModel</span>().<span class="hljs-title function_">getOffsetY</span>()
    };
    <span class="hljs-keyword">let</span> nodesRectTopLeftPoint = {
      <span class="hljs-attr">x</span>: nodeLayerTopLeftPoint.<span class="hljs-property">x</span> + topLeftXY.<span class="hljs-property">x</span>,
      <span class="hljs-attr">y</span>: nodeLayerTopLeftPoint.<span class="hljs-property">y</span> + topLeftXY.<span class="hljs-property">y</span>
    };

    <span class="hljs-keyword">let</span> prevTransform = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div'</span>).<span class="hljs-property">style</span>.<span class="hljs-property">transform</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">childNodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>)=&gt;</span>{
      ele.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate(<span class="hljs-subst">${nodeLayerTopLeftPoint.x - nodesRectTopLeftPoint.x}</span>px, <span class="hljs-subst">${nodeLayerTopLeftPoint.y - nodesRectTopLeftPoint.y}</span>px) scale(1.0)`</span>;
    });

    <span class="hljs-comment">// Capture the links beyond the nodes as well.</span>
    <span class="hljs-keyword">const</span> linkOutsideWidth = linksRect.<span class="hljs-property">BR</span>.<span class="hljs-property">x</span> - nodesRect.<span class="hljs-title function_">getBottomRight</span>().<span class="hljs-property">x</span>;
    <span class="hljs-keyword">const</span> linkOutsideHeight = linksRect.<span class="hljs-property">BR</span>.<span class="hljs-property">y</span> - nodesRect.<span class="hljs-title function_">getBottomRight</span>().<span class="hljs-property">y</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollWidth</span> + (linkOutsideWidth &gt; <span class="hljs-number">0</span> ? linkOutsideWidth : <span class="hljs-number">0</span>) + margin + <span class="hljs-string">'px'</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollHeight</span> + (linkOutsideHeight &gt; <span class="hljs-number">0</span> ? linkOutsideHeight : <span class="hljs-number">0</span>) + margin + <span class="hljs-string">'px'</span>;

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>{
      <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollWidth</span> + <span class="hljs-number">10</span>;
      <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollHeight</span> + <span class="hljs-number">10</span>;
      <span class="hljs-keyword">let</span> isCut = <span class="hljs-literal">false</span>;
      <span class="hljs-comment">/* Canvas limitation - https://html2canvas.hertzen.com/faq */</span>
      <span class="hljs-keyword">if</span>(width &gt;= <span class="hljs-number">32767</span>){
        width = <span class="hljs-number">32766</span>;
        isCut = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span>(height &gt;= <span class="hljs-number">32767</span>){
        height = <span class="hljs-number">32766</span>;
        isCut = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-title function_">toPng</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>, {width, height, <span class="hljs-attr">pixelRatio</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">preferences</span>.<span class="hljs-property">image_pixel_ratio</span> || <span class="hljs-number">1</span>})
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dataUrl</span>)=&gt;</span>{
          <span class="hljs-title class_">DownloadUtils</span>.<span class="hljs-title function_">downloadBase64UrlData</span>(dataUrl, <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.getCurrentProjectName()}</span>.png`</span>);
        }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>{
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
          <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Unknown error. Check console logs'</span>);
          <span class="hljs-keyword">if</span>(err.<span class="hljs-property">name</span>) {
            msg = <span class="hljs-string">`<span class="hljs-subst">${err.name}</span>: <span class="hljs-subst">${err.message}</span>`</span>;
          }
          pgAdmin.<span class="hljs-property">Browser</span>.<span class="hljs-property">notifier</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Error'</span>), msg);
        }).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>{
          <span class="hljs-comment">/* Revert back to the original CSS styles */</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagramContainerRef</span>.<span class="hljs-property">current</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'ERDTool-html2canvasReset'</span>);
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">''</span>;
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">''</span>;
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">childNodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>)=&gt;</span>{
            ele.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = prevTransform;
          });
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">null</span>);
          <span class="hljs-keyword">if</span>(isCut) {
            pgAdmin.<span class="hljs-property">Browser</span>.<span class="hljs-property">notifier</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Maximum image size limit'</span>),
              <span class="hljs-title function_">gettext</span>(<span class="hljs-string">'The downloaded image has exceeded the maximum size of 32767 x 32767 pixels, and has been cropped to that size.'</span>));
          }
        });
    }, <span class="hljs-number">1000</span>);
  }
</code></pre>
<p>这种百行级函数，存在合理性且不论，无论如何它都不应该叫xxClick了，毕竟谁敢相信它所有的代码都是为了完成一个导出png功能？</p>
<p>当然只笼统的说它完成了「一个功能」，那也是委屈它了，这函数实质上究竟做了什么？</p>
<ul>
<li>状态管理： setLoading。</li>
<li>DOM 劫持： 直接操作样式和类名。</li>
<li>复杂的几何计算： 处理包围盒（Bounding Box）。</li>
<li>IO 操作： 生成图片并触发下载。</li>
<li>异常处理： 恢复状态弹出 notifier 警告。</li>
</ul>
<p>每一项都是焦点，如果换成Java，这段代码还能再套上10个trycatch膨胀到500行，当然如果换成Java必然能规矩许多，不至于如此粗糙。</p>
<p>当然这函数远不止违法单一原则那么简单，几何计算中 margin = 10 和屏幕坐标转换逻辑非常硬核且粗糙，几乎宣判了这块UI已经不可更改了，同时否定了缩放/偏移变化，非常容易出 off-by-one 错误，已经消耗极大了，不想做复杂只想简单实现也可以克隆DOM做一个离屏渲染，还不需要关心什么margin偏移。</p>
<p><code>toPng</code>还是<code>html-to-image</code>的，这种场景用这个本身就如同儿戏，而且既然都做这么复杂了，哪怕直接再补上一套原生代码，手动绘制，全丢这函数里，不用任何库，这段代码也不会更丑了。</p>
<p>检测到图片到了浏览器 canvas 限制，就直接剪裁+警告，不做一个执行前popup确认和zoom，可以说有些不可理喻了，现实中这个警告几乎不可能弹出来，因为符合的这个逻辑时，其占用的原始内存将达到惊人的 4GB，做这种巨型 DOM 树时UI会进行密集的像素计算。而且计算是同步的，会直接锁死浏览器主线程！程序早已卡死，一行代码都别想执行了。</p>
<p>还有<code>setTimeout</code>为什么 1000ms？为什么不是 500 或 2000？这是典型的“等它渲染完”的 hack，因为修改 transform / width/height 后，浏览器需要时间重排/重绘，<code>html2canvas</code>才能捕获正确内容。用<code>requestAnimationFrame </code>循环检查或<code>MutationObserver</code> / <code>ResizeObserver</code>来检测实际变化完成不好么？</p>
<p>最后还是回到名字上，一个函数如果叫“xx点击”，它就没有资格去负责“计算并导出32767像素的位图”。</p>
<p>不过综合来说，这东西整体上也算勉强还行了，毕竟它是一个最终节点组件，而且基本上不太可能被依赖，只是功能性问题，不像它旁边那个1560行有15个useEffect的<code>ResultSet.jsx</code>，那都不能叫组件了，那是试图给React塞一个子系统，等PostgreSQL20发布，估计就没人敢改它了。还有用1300行的<code>FormInput.tsx</code>管理着FormIcon、StyledGrid、FormInput、InputSQL、FormInputSQL等子组件的超级组件，这几乎是想做一套扩展UI库。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[「九九八十一难」第一难：前端数据mock指南（TS + VUE）]]></title>    <link>https://juejin.cn/post/7604084016510631977</link>    <guid>https://juejin.cn/post/7604084016510631977</guid>    <pubDate>2026-02-09T03:58:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510631977" data-draft-id="7604155045235785763" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="「九九八十一难」第一难：前端数据mock指南（TS + VUE）"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T03:58:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="从文处安"/> <meta itemprop="url" content="https://juejin.cn/user/1315432730731224"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            「九九八十一难」第一难：前端数据mock指南（TS + VUE）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1315432730731224/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    从文处安
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:58:41.000Z" title="Mon Feb 09 2026 03:58:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    16
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue3 + TypeScript 项目中使用 Mock 数据指南</h2>
<h3 data-id="heading-1">背景</h3>
<p>产品：这里有个需求，计划月底上线，你们评估下开发时间，保证月底能上线现网。</p>
<p>测试：我需要一周的测试时间，包括功能测试、性能测试、兼容性测试等。</p>
<p>UI：我需要一周时间，包括页面布局、交互设计、颜色方案等。</p>
<p>后端：我需要两周时间，包括数据库设计、接口开发、业务逻辑实现等。</p>
<p>前端：我走？</p>
<p>产品：你想想办法。</p>
<p>前端：我可以牺牲自己的开发时间，通过接口mock来并行开发，需要后端提前提供接口文档，我同步进行页面开发和逻辑实现。</p>
<p>为了需求正常上线，无私的前端又为自己找了个加班的机会。</p>
<h3 data-id="heading-2">前言</h3>
<p>在前端开发过程中，我们经常会遇到后端接口尚未完成，但前端需要提前开发页面和功能的情况。
这时，使用 Mock 数据就成为了一种非常有效的解决方案。
本文将介绍如何在 Vue3 + TypeScript 项目中搭建和使用 Mock 数据。</p>
<h3 data-id="heading-3">什么是 Mock 数据</h3>
<h4 data-id="heading-4">概念</h4>
<p>Mock 数据是指在开发过程中，为了模拟后端接口返回的数据，而创建的虚假数据。</p>
<h4 data-id="heading-5">作用</h4>
<ol>
<li>
<p><strong>并行开发</strong>：前端可以与后端同时开发，不需要等待后端接口完成</p>
</li>
<li>
<p><strong>独立测试</strong>：可以模拟各种边界情况和错误场景</p>
</li>
<li>
<p><strong>性能测试</strong>：可以模拟大量数据，测试前端性能</p>
</li>
<li>
<p><strong>演示效果</strong>：在没有后端服务的情况下，也能展示完整的功能</p>
</li>
</ol>
<h4 data-id="heading-6">优势</h4>
<ol>
<li>
<p><strong>提高开发效率</strong>：减少等待后端接口的时间</p>
</li>
<li>
<p><strong>增强代码健壮性</strong>：可以测试各种异常情况</p>
</li>
<li>
<p><strong>改善团队协作</strong>：明确接口规范，减少沟通成本</p>
</li>
<li>
<p><strong>简化测试流程</strong>：可以快速模拟各种场景</p>
</li>
</ol>
<h3 data-id="heading-7">环境搭建</h3>
<h4 data-id="heading-8">安装依赖</h4>
<p>在 Vue3 + TypeScript 项目中，需要安装以下依赖：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装 mockjs 库</span>
npm install mockjs --save-dev

<span class="hljs-comment"># 安装 vite-plugin-mock 插件</span>
npm install vite-plugin-mock --save-dev

<span class="hljs-comment"># 安装 @types/mockjs 类型定义（可选但推荐）</span>
npm install --save-dev @types/mockjs
</code></pre>
<h4 data-id="heading-9">配置 Vite</h4>
<p>在 <code>vite.config.ts</code> 文件中配置 <code>vite-plugin-mock</code> 插件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-vue"</span>;
<span class="hljs-keyword">import</span> { resolve } <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> { viteMockServe } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">vue</span>(),
    <span class="hljs-title function_">viteMockServe</span>({
      <span class="hljs-comment">// mock 文件存放路径</span>
      <span class="hljs-attr">mockPath</span>: <span class="hljs-string">"./mock"</span>,
      <span class="hljs-comment">// 启用 mock 功能</span>
      <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-comment">// 显示请求日志</span>
      <span class="hljs-attr">logger</span>: <span class="hljs-literal">true</span>,
    }),
  ],
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-string">"@"</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src"</span>),
    },
  },
});
</code></pre>
<h4 data-id="heading-10">配置 TypeScript</h4>
<p>在 <code>tsconfig.app.json</code> 文件中配置路径别名，确保 TypeScript 能够正确解析 <code>@/</code> 路径：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"extends"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@vue/tsconfig/tsconfig.dom.json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tsBuildInfoFile"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./node_modules/.tmp/tsconfig.app.tsbuildinfo"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src/*"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-comment">/* Linting */</span>
    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUnusedLocals"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUnusedParameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noFallthroughCasesInSwitch"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUncheckedSideEffectImports"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/**/*.ts"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"src/**/*.tsx"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"src/**/*.vue"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-11">配置 Mock 数据</h3>
<h4 data-id="heading-12">快速开始 - 最简单的用例</h4>
<p>模拟第一个简单接口</p>
<h5 data-id="heading-13">第一步：创建最简单的 Mock 接口</h5>
<p>在 <code>mock</code> 文件夹下创建一个简单的 <code>hello.ts</code> 文件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// mock/hello.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MockMethod</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/hello"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: <span class="hljs-string">"Hello, Mock!"</span>,
      };
    },
  },
] <span class="hljs-keyword">as</span> <span class="hljs-title class_">MockMethod</span>[];
</code></pre>
<h5 data-id="heading-14">第二步：在组件中调用</h5>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;{{ message }}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted } from "vue";
import axios from "axios";

const message = ref("");

onMounted(async () =&gt; {
  try {
    const response = await axios.get("/api/hello");
    message.value = response.data.data;
  } catch (error) {
    console.error("请求失败:", error);
  }
});
&lt;/script&gt;
</code></pre>
<p><strong>运行结果</strong>：页面显示 "Hello, Mock!"</p>
<hr/>
<h4 data-id="heading-15">中级用例 - 简单数据列表</h4>
<p>这个用例展示如何返回一个简单的数据列表。</p>
<h5 data-id="heading-16">创建 Mock 接口</h5>
<p>在 <code>mock</code> 文件夹下创建 <code>products.ts</code> 文件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// mock/products.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MockMethod</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/products"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: [
          { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"商品1"</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">99</span> },
          { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"商品2"</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">199</span> },
          { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"商品3"</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">299</span> },
        ],
      };
    },
  },
] <span class="hljs-keyword">as</span> <span class="hljs-title class_">MockMethod</span>[];
</code></pre>
<h5 data-id="heading-17">在组件中调用</h5>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;商品列表&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for="product in products" :key="product.id"&gt;
        {{ product.name }} - ¥{{ product.price }}
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted } from "vue";
import axios from "axios";

interface Product {
  id: number;
  name: string;
  price: number;
}

const products = ref&lt;Product[]&gt;([]);

onMounted(async () =&gt; {
  try {
    const response = await axios.get("/api/products");
    products.value = response.data.data;
  } catch (error) {
    console.error("获取商品列表失败:", error);
  }
});
&lt;/script&gt;
</code></pre>
<p><strong>运行结果</strong>：页面显示商品列表，包含3个商品的信息。</p>
<hr/>
<h4 data-id="heading-18">进阶用例 - 用户数据管理</h4>
<p>接下来，我们创建一个更完整的贴合业务场景的用例。</p>
<h5 data-id="heading-19">创建 Mock 文件</h5>
<p>创建一个 <code>user.ts</code> 文件来模拟用户相关的接口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// mock/user.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MockMethod</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/user/list"</span>, <span class="hljs-comment">// 接口路径</span>
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>, <span class="hljs-comment">// 请求方法</span>
    <span class="hljs-attr">response</span>: <span class="hljs-function">(<span class="hljs-params">{ query }: { query: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; }</span>) =&gt;</span> {
      <span class="hljs-comment">// 模拟分页数据</span>
      <span class="hljs-keyword">const</span> page = <span class="hljs-built_in">parseInt</span>(query.<span class="hljs-property">page</span>) || <span class="hljs-number">1</span>;
      <span class="hljs-keyword">const</span> limit = <span class="hljs-built_in">parseInt</span>(query.<span class="hljs-property">limit</span>) || <span class="hljs-number">10</span>;
      <span class="hljs-keyword">const</span> total = <span class="hljs-number">100</span>;

      <span class="hljs-comment">// 生成模拟数据</span>
      <span class="hljs-keyword">const</span> list = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; limit; i++) {
        <span class="hljs-keyword">const</span> index = (page - <span class="hljs-number">1</span>) * limit + i;
        <span class="hljs-keyword">if</span> (index &lt; total) {
          list.<span class="hljs-title function_">push</span>({
            <span class="hljs-attr">id</span>: index + <span class="hljs-number">1</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">`用户<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>`</span>,
            <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">30</span>) + <span class="hljs-number">18</span>,
            <span class="hljs-attr">email</span>: <span class="hljs-string">`user<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>@example.com`</span>,
            <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
          });
        }
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: {
          list,
          total,
          page,
          limit,
        },
      };
    },
  },
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/user/detail"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">(<span class="hljs-params">{ query }: { query: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; }</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> id = query.<span class="hljs-property">id</span>;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: {
          id,
          <span class="hljs-attr">name</span>: <span class="hljs-string">`用户<span class="hljs-subst">${id}</span>`</span>,
          <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">30</span>) + <span class="hljs-number">18</span>,
          <span class="hljs-attr">email</span>: <span class="hljs-string">`user<span class="hljs-subst">${id}</span>@example.com`</span>,
          <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
          <span class="hljs-attr">address</span>: <span class="hljs-string">"北京市朝阳区"</span>,
          <span class="hljs-attr">phone</span>: <span class="hljs-string">"13800138000"</span>,
        },
      };
    },
  },
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/user/create"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"post"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">(<span class="hljs-params">{ body }: { body: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; }</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">id</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10000</span>),
          ...body,
        },
      };
    },
  },
] <span class="hljs-keyword">as</span> <span class="hljs-title class_">MockMethod</span>[];
</code></pre>
<h3 data-id="heading-20">调用 Mock 数据</h3>
<p>mock数据的调用使用 <code>axios</code> 实现，本文暂不做过多覆盖。</p>
<h4 data-id="heading-21">创建 API 服务</h4>
<p>在 <code>src/api</code> 目录下创建 <code>user.ts</code> 文件，定义 API 调用函数：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/api/user.ts</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;

<span class="hljs-comment">/**
 * 获取用户列表
 * <span class="hljs-doctag">@param</span> params 分页参数
 * <span class="hljs-doctag">@returns</span> Promise 响应数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = (<span class="hljs-params">params: { page: <span class="hljs-built_in">number</span>; limit: <span class="hljs-built_in">number</span> }</span>) =&gt; {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/user/list"</span>, { params });
};

<span class="hljs-comment">/**
 * 获取用户详情
 * <span class="hljs-doctag">@param</span> id 用户ID
 * <span class="hljs-doctag">@returns</span> Promise 响应数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserDetail</span> = (<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =&gt; {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/user/detail"</span>, { <span class="hljs-attr">params</span>: { id } });
};

<span class="hljs-comment">/**
 * 创建用户
 * <span class="hljs-doctag">@param</span> data 用户数据
 * <span class="hljs-doctag">@returns</span> Promise 响应数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createUser</span> = (<span class="hljs-params">data: {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
  email: <span class="hljs-built_in">string</span>;
}</span>) =&gt; {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/api/user/create"</span>, data);
};
</code></pre>
<h4 data-id="heading-22">在组件中使用</h4>
<p>在 Vue 组件中使用 API 服务调用 Mock 数据：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-list"&gt;
    &lt;h2&gt;用户列表&lt;/h2&gt;
    &lt;div v-if="loading"&gt;加载中...&lt;/div&gt;
    &lt;div v-else&gt;
      &lt;ul&gt;
        &lt;li v-for="user in userList" :key="user.id"&gt;
          {{ user.name }} - {{ user.age }}岁 - {{ user.email }}
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="pagination"&gt;
        &lt;button @click="changePage(1)" :disabled="currentPage === 1"&gt;
          首页
        &lt;/button&gt;
        &lt;button
          @click="changePage(currentPage - 1)"
          :disabled="currentPage === 1"
        &gt;
          上一页
        &lt;/button&gt;
        &lt;span&gt;第 {{ currentPage }} 页，共 {{ totalPages }} 页&lt;/span&gt;
        &lt;button
          @click="changePage(currentPage + 1)"
          :disabled="currentPage === totalPages"
        &gt;
          下一页
        &lt;/button&gt;
        &lt;button
          @click="changePage(totalPages)"
          :disabled="currentPage === totalPages"
        &gt;
          末页
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, computed, onMounted } from "vue";
import { getUserList } from "@/api/user";

// 响应式数据
const userList = ref&lt;any[]&gt;([]);
const loading = ref(false);
const currentPage = ref(1);
const pageSize = ref(10);
const total = ref(0);

// 计算属性
const totalPages = computed(() =&gt; {
  return Math.ceil(total.value / pageSize.value);
});

/**
 * 获取用户列表数据
 */
const fetchUserList = async () =&gt; {
  loading.value = true;
  try {
    const response = await getUserList({
      page: currentPage.value,
      limit: pageSize.value,
    });
    userList.value = response.data.data.list;
    total.value = response.data.data.total;
  } catch (error) {
    console.error("获取用户列表失败:", error);
  } finally {
    loading.value = false;
  }
};

/**
 * 切换页码
 * @param page 页码
 */
const changePage = (page: number) =&gt; {
  currentPage.value = page;
  fetchUserList();
};

// 组件挂载时获取数据
onMounted(() =&gt; {
  fetchUserList();
});
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-23">常见用例和最佳实践</h3>
<h4 data-id="heading-24">常见用例</h4>
<ol>
<li>
<p><strong>分页数据</strong>：模拟带分页的列表数据</p>
</li>
<li>
<p><strong>详情数据</strong>：模拟单个资源的详细信息</p>
</li>
<li>
<p><strong>表单提交</strong>：模拟创建、更新操作</p>
</li>
<li>
<p><strong>错误场景</strong>：模拟各种错误状态码和错误信息</p>
</li>
<li>
<p><strong>文件上传</strong>：模拟文件上传接口</p>
</li>
</ol>
<h4 data-id="heading-25">最佳实践</h4>
<ol>
<li>
<p><strong>目录结构清晰</strong>：按模块组织 mock 文件</p>
</li>
<li>
<p><strong>数据结构一致</strong>：与后端接口保持一致的数据结构</p>
</li>
<li>
<p><strong>模拟真实场景</strong>：包括正常、异常、边界等各种场景</p>
</li>
<li>
<p><strong>使用 TypeScript</strong>：为 mock 数据添加类型定义</p>
</li>
<li>
<p><strong>注释完善</strong>：为复杂的 mock 逻辑添加注释</p>
</li>
<li>
<p><strong>定期更新</strong>：根据后端接口变化及时更新 mock 数据</p>
</li>
</ol>
<h3 data-id="heading-26">故障排除提示</h3>
<ol>
<li><strong>mock 数据不生效</strong></li>
</ol>
<ul>
<li>
<p>检查 <code>vite.config.ts</code> 中的 <code>mockPath</code> 配置是否正确</p>
</li>
<li>
<p>检查 mock 文件是否在正确的目录下</p>
</li>
<li>
<p>检查接口路径是否匹配</p>
</li>
</ul>
<ol start="2">
<li><strong>TypeScript 类型错误</strong></li>
</ol>
<ul>
<li>
<p>确保安装了 <code>@types/mockjs</code> 类型定义</p>
</li>
<li>
<p>为 mock 数据添加正确的类型注解</p>
</li>
</ul>
<ol start="3">
<li><strong>生产环境泄露</strong></li>
</ol>
<ul>
<li>确保在生产环境中禁用 mock 功能</li>
</ul>
<ol start="4">
<li><strong>性能问题</strong></li>
</ol>
<ul>
<li>
<p>避免在 mock 函数中执行复杂的计算</p>
</li>
<li>
<p>对于大量数据，考虑使用分页或虚拟滚动</p>
</li>
</ul>
<h3 data-id="heading-27">常见问题</h3>
<h4 data-id="heading-28">1. 路径别名问题</h4>
<p><strong>问题</strong>：找不到模块 "@/api/user" 或其相应的类型声明。</p>
<p><strong>原因</strong>：虽然在 <code>vite.config.ts</code> 中配置了路径别名，但在 <code>tsconfig.app.json</code> 中没有配置相应的 <code>paths</code>。</p>
<p><strong>解决方案</strong>：在 <code>tsconfig.app.json</code> 中添加 <code>paths</code> 配置：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-comment">// ... 其他配置</span>
    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src/*"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-29">2. 接口实现不完整</h4>
<p><strong>问题</strong>：调用某个 API 函数时返回 404 错误。</p>
<p><strong>原因</strong>：在 mock 文件中没有实现对应的接口。</p>
<p><strong>解决方案</strong>：确保所有 API 调用都有对应的 mock 接口实现。</p>
<h4 data-id="heading-30">3. 类型定义缺失</h4>
<p><strong>问题</strong>：使用 mockjs 时缺少类型定义。</p>
<p><strong>原因</strong>：没有安装 <code>@types/mockjs</code> 类型定义文件。</p>
<p><strong>解决方案</strong>：安装类型定义文件：</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev @types/mockjs
</code></pre>
<h3 data-id="heading-31">替代方案比较</h3>
<h4 data-id="heading-32">Mock.js vs JSON Server</h4>
<ul>
<li>
<p><strong>Mock.js</strong>：专注于数据模拟，功能强大，支持各种数据类型和随机数据生成</p>
</li>
<li>
<p><strong>JSON Server</strong>：快速创建 RESTful API，基于 JSON 文件，适合简单场景</p>
</li>
</ul>
<h4 data-id="heading-33">Mock.js vs MSW (Mock Service Worker)</h4>
<ul>
<li>
<p><strong>Mock.js</strong>：在构建工具层面拦截请求，配置简单</p>
</li>
<li>
<p><strong>MSW</strong>：在浏览器层面拦截请求，支持 Service Worker，更接近真实网络请求</p>
</li>
</ul>
<h4 data-id="heading-34">Mock.js vs 手写本地存储</h4>
<ul>
<li>
<p><strong>Mock.js</strong>：功能完整，支持各种 HTTP 方法和场景</p>
</li>
<li>
<p><strong>手写本地存储</strong>：简单直接，适合非常简单的场景</p>
</li>
</ul>
<h3 data-id="heading-35">注意事项</h3>
<ol>
<li>
<p><strong>环境隔离</strong>：确保 mock 功能只在开发和测试环境启用</p>
</li>
<li>
<p><strong>数据安全</strong>：不要在 mock 数据中使用真实的敏感信息</p>
</li>
<li>
<p><strong>接口一致性</strong>：与后端保持接口规范一致，避免后期大量修改</p>
</li>
<li>
<p><strong>代码管理</strong>：将 mock 相关代码与业务代码分离，便于维护</p>
</li>
<li>
<p><strong>性能考虑</strong>：避免生成过多数据，影响前端性能</p>
</li>
<li>
<p><strong>测试覆盖</strong>：确保真实接口对接后，进行完整的回归测试</p>
</li>
</ol>
<h3 data-id="heading-36">总结</h3>
<p>Mock 数据是前端开发中的重要工具，它可以帮助我们提高开发效率，增强代码健壮性，改善团队协作。</p>
<p><code>「九九八十一难，难难皆是修行」</code></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[在 VS Code中，vue2-vuex 使用终于有体验感增强的插件了。]]></title>    <link>https://juejin.cn/post/7604155045235916835</link>    <guid>https://juejin.cn/post/7604155045235916835</guid>    <pubDate>2026-02-09T04:30:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604155045235916835" data-draft-id="7603895839557632063" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="在 VS Code中，vue2-vuex 使用终于有体验感增强的插件了。"/> <meta itemprop="keywords" content="Vue.js,Vuex"/> <meta itemprop="datePublished" content="2026-02-09T04:30:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小书包酱"/> <meta itemprop="url" content="https://juejin.cn/user/184373685008184"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            在 VS Code中，vue2-vuex 使用终于有体验感增强的插件了。
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/184373685008184/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小书包酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:30:36.000Z" title="Mon Feb 09 2026 04:30:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    12
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vuex Helper</h2>
<p>适用于 Vuex 2 的 VS Code 插件，提供 <strong>跳转定义</strong>、<strong>代码补全</strong> 和 <strong>悬浮提示</strong> 功能。支持 State, Getters, Mutations 和 Actions。</p>
<h3 data-id="heading-1">引言</h3>
<blockquote>
<p>在 AI 时代，为什么要搞一个老掉牙的 vue2 的 vuex 增强插件？可以想象，现在起步应该都会是 vue3 或者 react 的框架。但<strong>老项目永远不会少</strong>，除非下定决心去重构，否则永远都要面对老项目，那在vscode中，遇到 vue2 项目的调试过程中，vuex 的跳转定义永远是我开发与迭代时遇到的痛点，AI 给了我机会，让我无需在繁重的业务需求之外，额外耗费太多的时间去学习插件怎么使用，而直接上手去把我的思路交予实现。感谢 AI，让我有能力去完成一些平时不可及的小事情。</p>
</blockquote>
<h3 data-id="heading-2">功能特性</h3>
<h4 data-id="heading-3">1. 跳转定义 (Go to Definition)</h4>
<p>从组件中直接跳转到 Vuex Store 的定义处。</p>
<h5 data-id="heading-4">演示：跳转定义</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c773c66a7ac144429996aeaf36c1bcc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=TjRG%2FP7%2FxyFiKuoanfXYjxx%2Bq0g%3D" alt="jump_definition.gif" loading="lazy"/></p>
<ul>
<li><strong>支持</strong>: <code>this.$store.state/getters/commit/dispatch</code></li>
<li><strong>Map 辅助函数</strong>: <code>mapState</code>, <code>mapGetters</code>, <code>mapMutations</code>, <code>mapActions</code></li>
<li><strong>命名空间</strong>: 完美支持 Namespaced 模块及其嵌套。</li>
</ul>
<h4 data-id="heading-5">2. 智能代码补全 (Intelligent Code Completion)</h4>
<p>智能提示 Vuex 的各种 Key 以及组件中映射的方法。</p>
<h5 data-id="heading-6">演示：智能补全</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/753860d9860c41828bfd55b71ee0da06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=pi7kabadmE51E1ABFAjaqguO6NE%3D" alt="auto_tips_and_complete_for_var.gif" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8bf012de79ba4fab8dcbbb577a6f5860~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=fiSB5wta6aeWCaqQq5wEdePzg%2Fk%3D" alt="auto_tips_and_complete_for_func.gif" loading="lazy"/></p>
<ul>
<li><strong>上下文感知</strong>: 在 <code>dispatch</code> 中提示 Actions，在 <code>commit</code> 中提示 Mutations。</li>
<li><strong>命名空间过滤</strong>: 当使用 <code>mapState('user', [...])</code> 时，会自动过滤并仅显示 <code>user</code> 模块下的内容。</li>
<li><strong>组件映射方法</strong>: 输入 <code>this.</code> 即可提示映射的方法（例如 <code>this.increment</code> 映射自 <code>...mapMutations(['increment'])</code>）。</li>
<li><strong>语法支持</strong>: 支持数组语法和对象别名语法 (例如 <code>...mapActions({ alias: 'name' })</code>)。</li>
</ul>
<h4 data-id="heading-7">3. 悬浮提示与类型推导 (Hover Information &amp; Type Inference)</h4>
<p>无需跳转即可查看文档、类型详情。</p>
<h5 data-id="heading-8">演示：悬浮文档</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/659696bacfd64f7096fae1dc5173a563~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=meaY9dItS9ORHJp0D5F4F6twjdo%3D" alt="hover_info_and_type_inference.gif" loading="lazy"/></p>
<ul>
<li><strong>JSDoc 支持</strong>: 提取并显示 Store 定义处的 <code>/** ... */</code> 注释文档。</li>
<li><strong>State 类型</strong>: 在悬浮提示中自动推导并显示 State 属性的类型 (例如 <code>(State) appName: string</code>)。</li>
<li><strong>详细信息</strong>: 显示类型（State/Mutation等）及定义所在的文件路径。</li>
<li><strong>映射方法</strong>: 支持查看映射方法的 Store 文档。</li>
</ul>
<h4 data-id="heading-9">4. Store 内部调用 (Store Internal Usage)</h4>
<p>同样支持在 Vuex Store 内部 代码补全、跳转、悬浮提示。</p>
<h5 data-id="heading-10">演示：Store 内部 代码补全、跳转、悬浮提示</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8315d95ba2294d3aa57b071111876b75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=%2Fx5CjrkrjGrPW7N32MwLSN3FFJo%3D" alt="internal_usage.gif" loading="lazy"/></p>
<ul>
<li><strong>模块作用域</strong>: 当在模块文件（如 <code>user.js</code>）中编写 Action 时，<code>commit</code> 和 <code>dispatch</code> 的代码补全会自动过滤并仅显示当前模块的内容。</li>
</ul>
<p>同样支持在 Vuex Store 内部 代码补全、跳转、悬浮提示。</p>
<h3 data-id="heading-11">支持的语法示例</h3>
<ul>
<li><strong>辅助函数 (Helpers)</strong>:
<pre><code class="hljs language-javascript" lang="javascript">...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">'count'</span>])
...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">'user'</span>, [<span class="hljs-string">'name'</span>]) <span class="hljs-comment">// 命名空间支持</span>
...<span class="hljs-title function_">mapActions</span>({ <span class="hljs-attr">add</span>: <span class="hljs-string">'increment'</span> }) <span class="hljs-comment">// 对象别名支持</span>
...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">'add/increment'</span>])
</code></pre>
</li>
<li><strong>Store 方法</strong>:
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">"SET_NAME"</span>, value);
<span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"user/updateName"</span>, value);
</code></pre>
</li>
<li><strong>组件方法</strong>:
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 映射自 mapMutations</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">appName</span>; <span class="hljs-comment">// 映射自 mapState</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-12">使用要求</h3>
<ul>
<li>使用 Vuex 的 Vue 2 项目。</li>
<li>Store 入口位于 <code>src/store/index.js</code> 或 <code>src/store/index.ts</code>（支持自动探测）。</li>
<li>若无法自动找到，请在设置中配置 <code>vuexHelper.storeEntry</code>。</li>
</ul>
<h3 data-id="heading-13">配置项</h3>
<ul>
<li><code>vuexHelper.storeEntry</code>: 手动指定 Store 入口文件路径。支持：
<ul>
<li>别名路径: <code>@/store/index.js</code> (需在 jsconfig/tsconfig 中配置)</li>
<li>相对路径: <code>src/store/index.js</code></li>
<li>绝对路径: <code>/User/xxx/project/src/store/index.js</code></li>
</ul>
</li>
</ul>
<h3 data-id="heading-14">更新日志</h3>
<h4 data-id="heading-15">0.0.1</h4>
<p>初始版本，支持功能：</p>
<ul>
<li>全面支持 State, Getters, Mutations, Actions</li>
<li>支持命名空间过滤 (Namespace Filtering)</li>
<li>支持 JSDoc 悬浮文档显示</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从页面加载过程看 Kuikly 的多线程架构]]></title>    <link>https://juejin.cn/post/7603958579180486656</link>    <guid>https://juejin.cn/post/7603958579180486656</guid>    <pubDate>2026-02-09T04:28:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603958579180486656" data-draft-id="7604155045235900451" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从页面加载过程看 Kuikly 的多线程架构"/> <meta itemprop="keywords" content="Kotlin"/> <meta itemprop="datePublished" content="2026-02-09T04:28:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我有与与症"/> <meta itemprop="url" content="https://juejin.cn/user/4466629837071787"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从页面加载过程看 Kuikly 的多线程架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4466629837071787/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我有与与症
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:28:04.000Z" title="Mon Feb 09 2026 04:28:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文适合 Kotlin/Kuikly 初学者阅读。我们不做泛泛而谈，而是以"一个页面是怎么被加载出来的"这条主线为脉络，一步一步跟踪源码，彻底弄清 Kuikly 的双线程模型是什么、为什么这么设计、以及它如何保证高性能和线程安全。</p>
</blockquote>
<h2 data-id="heading-0">1. 为什么需要双线程？</h2>
<p>在理解 Kuikly 的多线程模型之前，我们先想一个问题：<strong>如果把所有事情都放在主线程做，会怎样？</strong></p>
<p>一个 UI 框架需要做两大类事情：</p>




















<table><thead><tr><th>类别</th><th>具体工作</th><th>耗时特征</th></tr></thead><tbody><tr><td><strong>逻辑计算</strong></td><td>执行业务代码、构建虚拟视图树、计算 Flexbox 布局、处理响应式更新</td><td>CPU 密集</td></tr><tr><td><strong>原生渲染</strong></td><td>创建平台 View、设置属性、设置 frame、插入视图层级</td><td>必须在 UI 线程</td></tr></tbody></table>
<p>如果全放主线程，逻辑计算会阻塞 UI 渲染，用户看到的就是"卡"。React Native 很早就采用了类似的双线程方案——JS 线程做逻辑，主线程做渲染。Kuikly 的思路一脉相承：</p>
<blockquote>
<p><strong>Context 线程</strong>（也叫 Kuikly 线程）：运行 Kotlin 业务逻辑、DSL 构建、布局计算<br/>
<strong>Main 线程</strong>（UI 线程）：执行原生 View 的创建、属性设置、帧布局</p>
</blockquote>
<p>这种分工带来三个核心优势：</p>
<ol>
<li><strong>不卡主线程</strong>：无论你的业务逻辑多复杂，用户的滑动、点击永远流畅</li>
<li><strong>批量上屏</strong>：Context 线程产生的 UI 指令可以攒一批再一次性提交给主线程，减少线程切换开销</li>
<li><strong>架构清晰</strong>：Kotlin 侧完全不需要关心线程问题，因为它永远运行在同一条线程上</li>
</ol>
<hr/>
<h2 data-id="heading-1">2. 两条线程各自负责什么</h2>
<p>让我们用一张表格来明确两条线程的职责边界：</p>
<pre><code class="hljs language-sql" lang="sql">┌─────────────────────────────────────────────────────────────┐
│                    Context 线程 (Kuikly 线程)                 │
│                                                              │
│  ✦ Kotlin 业务代码执行                                         │
│  ✦ Pager 生命周期（willInit → didInit → body → createBody）    │
│  ✦ DSL 构建（attr{} <span class="hljs-operator">/</span> event{} 块的执行）                       │
│  ✦ Flexbox 布局计算（flexNode.calculateLayout）                │
│  ✦ 响应式系统（observable 变化 → 重新执行绑定块）                  │
│  ✦ 协程调度（setTimeout、LifecycleScope）                      │
│  ✦ <span class="hljs-keyword">Module</span> 调用的发起端                                         │
│                                                              │
│  产出：一系列"UI 指令"（创建 <span class="hljs-keyword">View</span>、设属性、设 Frame……）           │
│       通过 BridgeManager.callNativeMethod() 发送给 Native 侧  │
└──────────────────────┬──────────────────────────────────────┘
                       │ UI 指令
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    Main 线程 (UI 线程)                        │
│                                                              │
│  ✦ 接收 UI 指令并批量执行                                       │
│  ✦ 创建原生 <span class="hljs-keyword">View</span>（TextView、ImageView……）                      │
│  ✦ 设置 <span class="hljs-keyword">View</span> 属性（背景色、字体、圆角……）                        │
│  ✦ 设置 <span class="hljs-keyword">View</span> Frame（位置和大小）                                │
│  ✦ 插入 <span class="hljs-keyword">View</span> 到父视图                                          │
│  ✦ 事件触发后通知 Context 线程                                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<hr/>
<h2 data-id="heading-2">3. 完整的页面加载时序</h2>
<p>在深入每一步之前，先看完整的时序图，对全局有个概念：</p>
<pre><code class="hljs language-scss" lang="scss">时间轴 ──────────────────────────────────────────────────────────→

<span class="hljs-selector-tag">Main</span> 线程    Context 线程    说明
    │              │
    │ <span class="hljs-built_in">init</span>()       │         ① 用户调用 KuiklyRenderView<span class="hljs-selector-class">.init</span>()
    │──schedule──→│         ② 切换到 Context 线程
    │              │
    │         <span class="hljs-built_in">initContext</span>()  ③ 加载 Kotlin 引擎、创建 NativeBridge
    │              │
    │        callKotlinMethod  ④ 调用 CREATE_INSTANCE
    │          (CREATE_INSTANCE)
    │              │
    │         PagerManager     ⑤ 通过页面注册表找到 creator
    │          <span class="hljs-selector-class">.createPager</span>()
    │              │
    │         pager<span class="hljs-selector-class">.onCreatePager</span>()  ⑥ Pager 生命周期开始
    │           ├─ <span class="hljs-built_in">willInit</span>()
    │           ├─ <span class="hljs-built_in">initModule</span>()
    │           ├─ <span class="hljs-built_in">didInit</span>() → <span class="hljs-selector-tag">body</span>()  ← 构建虚拟视图树
    │           └─ <span class="hljs-built_in">createBody</span>()
    │               ├─ <span class="hljs-built_in">createFlexNode</span>()
    │               ├─ <span class="hljs-built_in">createRenderView</span>()  → <span class="hljs-built_in">callNative</span>(CREATE_RENDER_VIEW)
    │               ├─ <span class="hljs-built_in">setViewProp</span>()       → <span class="hljs-built_in">callNative</span>(SET_VIEW_PROP)  ×N
    │               └─ <span class="hljs-built_in">layoutIfNeed</span>()      → <span class="hljs-built_in">callNative</span>(SET_RENDER_VIEW_FRAME) ×N
    │              │
    │              │  ── 上面这些 callNative 是异步的，被收集到 UIScheduler ──
    │              │
    │←─batch UI──│         ⑦ UIScheduler 批量提交到主线程
    │              │
    │ 执行 UI 指令   │         ⑧ 主线程依次执行：创建 View、设属性、设 Frame
    │ <span class="hljs-built_in">createView</span>()  │
    │ <span class="hljs-built_in">setProp</span>()     │
    │ <span class="hljs-built_in">setFrame</span>()    │
    │              │
    │ 首屏渲染完成    │         ⑨ viewDidLoad，触发 FirstFramePaint
    │──sendEvent─→│
    │         onReceivePagerEvent   ⑩ Kotlin 收到首屏事件
    │          ("pageFirstFramePaint")
</code></pre>
<p>现在，让我们逐步深入每一个阶段的源码实现。</p>
<hr/>
<h2 data-id="heading-3">4. 第一阶段：主线程上的准备工作</h2>
<h3 data-id="heading-4">4.1 Android 端入口</h3>
<p>一切从 <code>KuiklyRenderView.init()</code> 开始。这个方法<strong>必须在主线程调用</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderView.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(contextCode: <span class="hljs-type">String</span>, pageName: <span class="hljs-type">String</span>, 
                  params: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, Any&gt;, size: <span class="hljs-type">Size</span>?, assetsPath: <span class="hljs-type">String</span>?)</span></span> {
    assert(isMainThread())  <span class="hljs-comment">// ← 断言：必须在主线程</span>
    initKuiklyClassLoaderIfNeed(contextCode)
    <span class="hljs-keyword">val</span> initRenderCoreTask = { sz: SizeF -&gt;
        initRenderCore(contextCode, pageName, params, sz, assetsPath)
    }
    <span class="hljs-comment">// 如果已知 size，立即初始化；否则等 onSizeChanged 回调</span>
}
</code></pre>
<p><strong>为什么必须在主线程？</strong> 因为 <code>KuiklyRenderView</code> 本身是一个 Android <code>View</code>，View 的初始化、添加子 View 等操作都必须在 UI 线程。</p>
<h3 data-id="heading-5">4.2 iOS 端入口</h3>
<p>iOS 端同理，<code>KuiklyRenderView</code> 是一个 <code>UIView</code>：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderView.m</span>
- (<span class="hljs-keyword">instancetype</span>)initWithSize:(<span class="hljs-built_in">CGSize</span>)size contextCode:(<span class="hljs-built_in">NSString</span> *)contextCode
    contextParam:(KuiklyContextParam *)contextParam params:(<span class="hljs-built_in">NSDictionary</span> *)params
    delegate:(<span class="hljs-type">id</span>&lt;KuiklyRenderViewDelegate&gt;)delegate {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) {
        _renderCore = [[KuiklyRenderCore alloc] initWithRootView:<span class="hljs-keyword">self</span>
                                                     contextCode:contextCode
                                                    contextParam:contextParam
                                                          params:coreParams
                                                        delegate:<span class="hljs-keyword">self</span>];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
</code></pre>
<p>两端的模式完全一致：主线程创建宿主 View → 初始化 RenderCore → RenderCore 内部切换到 Context 线程。</p>
<hr/>
<h2 data-id="heading-6">5. 第二阶段：切换到 Context 线程创建页面</h2>
<h3 data-id="heading-7">5.1 KuiklyRenderCore.init() —— 关键的线程切换点</h3>
<p>这是整个页面加载过程中<strong>最重要的线程切换</strong>。我们以 Android 端为例：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(...)</span></span> {
    <span class="hljs-comment">// 还在主线程：创建调度器</span>
    uiScheduler = KuiklyRenderCoreUIScheduler { ... }
    renderLayerHandler = KuiklyRenderLayerHandler().apply { <span class="hljs-keyword">init</span>(renderView) }
    initNativeMethodRegisters()  <span class="hljs-comment">// 注册 Native 方法回调表</span>

    <span class="hljs-comment">// ★★★ 关键：切换到 Context 线程 ★★★</span>
    performOnContextQueue {
        initContextHandler(contextCode, url, params, contextInitCallback)
    }
}
</code></pre>
<p><code>performOnContextQueue</code> 是什么？让我们看看 Context 线程是怎么创建的。</p>
<h3 data-id="heading-8">5.2 Android 的 Context 线程：HandlerThread</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCoreContextScheduler.kt</span>
<span class="hljs-keyword">object</span> KuiklyRenderCoreContextScheduler : IKuiklyRenderCoreScheduler {

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> THREAD_NAME = <span class="hljs-string">"HRContextQueueHandlerThread"</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler <span class="hljs-keyword">by</span> lazy {
        Handler(<span class="hljs-keyword">object</span> : HandlerThread(THREAD_NAME, Process.THREAD_PRIORITY_FOREGROUND) {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLooperPrepared</span><span class="hljs-params">()</span></span> { 
                NativeBridge.isContextThread = <span class="hljs-literal">true</span>  <span class="hljs-comment">// ← 标记当前线程为 Context 线程</span>
            }
        }.apply { start() }.looper)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleTask</span><span class="hljs-params">(delayMs: <span class="hljs-type">Long</span>, task: <span class="hljs-type">KuiklyRenderCoreTask</span>)</span></span> {
        handler.postDelayed(task, delayMs)  <span class="hljs-comment">// 把任务 post 到 Context 线程的消息队列</span>
    }
}
</code></pre>
<p><strong>Kotlin 语法讲解</strong>——这段代码有几个值得深入理解的语法：</p>
<h4 data-id="heading-9"><code>object</code> 单例声明</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">object</span> KuiklyRenderCoreContextScheduler : IKuiklyRenderCoreScheduler { ... }
</code></pre>
<p>Kotlin 的 <code>object</code> 声明创建了一个<strong>单例</strong>。整个 App 进程中只有一个 <code>KuiklyRenderCoreContextScheduler</code> 实例，这意味着只有一条 Context 线程。所有 Kuikly 页面共享这一条线程。</p>
<h4 data-id="heading-10"><code>by lazy</code> 懒初始化</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler <span class="hljs-keyword">by</span> lazy { ... }
</code></pre>
<p><code>by lazy</code> 是属性委托的一种，它的含义是：<strong>第一次访问 <code>handler</code> 时才执行花括号里的代码</strong>。这保证了 Context 线程不会在 App 启动时就被创建，而是在第一个 Kuikly 页面加载时才创建。</p>
<h4 data-id="heading-11"><code>HandlerThread</code></h4>
<p><code>HandlerThread</code> 是 Android 提供的一个带消息循环的线程。它内部有一个 <code>Looper</code>（消息泵），配合 <code>Handler</code> 使用时，可以不断地从消息队列取任务执行。这就是 Context 线程的本质：<strong>一个串行的任务队列</strong>，所有 Kotlin 逻辑都按顺序在这里执行。</p>
<h4 data-id="heading-12"><code>ThreadLocal</code> 标记</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// NativeBridge.kt (Android)</span>
<span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _isContextThread = ThreadLocal&lt;<span class="hljs-built_in">Boolean</span>&gt;()
    <span class="hljs-keyword">var</span> isContextThread: <span class="hljs-built_in">Boolean</span>
        <span class="hljs-keyword">get</span>() = _isContextThread.<span class="hljs-keyword">get</span>() ?: <span class="hljs-literal">false</span>
        <span class="hljs-keyword">set</span>(value) { _isContextThread.<span class="hljs-keyword">set</span>(value) }
}
</code></pre>
<p><code>ThreadLocal</code> 是 Java/Kotlin 的线程局部变量。每个线程都有自己独立的 <code>isContextThread</code> 值。当 Context 线程启动时，<code>onLooperPrepared</code> 被调用，此时在 Context 线程内将 <code>isContextThread</code> 设为 <code>true</code>。之后任何地方调用 <code>NativeBridge.isContextThread</code> 都能判断当前是否在 Context 线程上。</p>
<h3 data-id="heading-13">5.3 iOS 的 Context 线程：GCD 串行队列</h3>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderThreadManager.m</span>
<span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_queue_t</span> gContextQueue = <span class="hljs-literal">NULL</span>;

+ (<span class="hljs-built_in">dispatch_queue_t</span>)contextQueue {
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;
    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^{
        dispatch_queue_attr_t queue_attr = dispatch_queue_attr_make_with_qos_class(
            DISPATCH_QUEUE_SERIAL,          <span class="hljs-comment">// 串行队列</span>
            QOS_CLASS_USER_INTERACTIVE, <span class="hljs-number">0</span>); <span class="hljs-comment">// 最高 QoS 优先级</span>
        gContextQueue = dispatch_queue_create(<span class="hljs-string">"com.tencent.kuikly.context"</span>, queue_attr);
        dispatch_queue_set_specific(gContextQueue, &amp;gContextQueue, ...);
    });
    <span class="hljs-keyword">return</span> gContextQueue;
}
</code></pre>
<p>iOS 使用 GCD（Grand Central Dispatch）的串行队列。注意两个关键选择：</p>
<ol>
<li><strong><code>DISPATCH_QUEUE_SERIAL</code></strong>（串行）：保证所有任务按顺序执行，不会并发，因此不需要锁</li>
<li><strong><code>QOS_CLASS_USER_INTERACTIVE</code></strong>（用户交互级）：这是 iOS 最高优先级的 QoS，告诉系统"这个队列的任务很紧急，直接影响用户体验"</li>
</ol>
<p>判断是否在 Context 队列上：</p>
<pre><code class="hljs language-objc" lang="objc">+ (<span class="hljs-type">BOOL</span>)isContextQueue {
    <span class="hljs-keyword">if</span> (dispatch_get_specific(&amp;gContextQueue)) {  <span class="hljs-comment">// ← 用 queue-specific data 判断</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;
}
</code></pre>
<p><code>dispatch_get_specific</code> 是 GCD 提供的一个机制：你可以给队列绑定一个 key-value，然后在任意地方查询当前队列是否绑定了这个 key。如果返回非 NULL，说明当前代码正在这个队列上执行。</p>
<h3 data-id="heading-14">5.4 在 Context 线程上初始化 Kotlin 引擎</h3>
<p>切换到 Context 线程后，<code>initContextHandler</code> 做了三件事：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initContextHandler</span><span class="hljs-params">(contextCode: <span class="hljs-type">String</span>, url: <span class="hljs-type">String</span>, params: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, Any&gt;, ...)</span></span> {
    <span class="hljs-comment">// 1. 创建 ContextHandler（通过反射加载 KuiklyCoreEntry）</span>
    contextHandler = KuiklyRenderJvmContextHandler()
    
    contextHandler?.apply {
        <span class="hljs-comment">// 2. 注册 Kotlin→Native 的回调通道</span>
        registerCallNative { method, args -&gt;
            performNativeMethodWithMethod(method, args)
        }
        
        <span class="hljs-comment">// 3. 初始化 Kotlin 引擎</span>
        <span class="hljs-keyword">init</span>(contextCode)
        
        <span class="hljs-comment">// 4. ★ 调用 CREATE_INSTANCE，触发 Kotlin 侧创建页面 ★</span>
        call(KuiklyRenderContextMethodCreateInstance, listOf(instanceId, url, params))
    }
}
</code></pre>
<p>其中第 4 步的 <code>call(CREATE_INSTANCE, ...)</code> 最终会进入 Kotlin 侧的 <code>BridgeManager.callKotlinMethod()</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// BridgeManager.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callKotlinMethod</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, arg0: <span class="hljs-type">Any</span>?, arg1: <span class="hljs-type">Any</span>?, ...)</span></span> {
    currentPageId = arg0 <span class="hljs-keyword">as</span> String
    <span class="hljs-keyword">when</span> (methodId) {
        KotlinMethod.CREATE_INSTANCE -&gt; {
            PagerManager.createPager(arg0 <span class="hljs-keyword">as</span> String, arg1 <span class="hljs-keyword">as</span> String, arg2 <span class="hljs-keyword">as</span> String)
        }
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>然后进入 <code>PagerManager.createPager()</code>，通过之前 <code>@Page</code> 注解注册的 creator 创建页面实例：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// PagerManager.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createPager</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>, url: <span class="hljs-type">String</span>, pagerData: <span class="hljs-type">String</span>)</span></span> {
    <span class="hljs-keyword">val</span> pagerName = pageNameFromUrl(url)
    reactiveObserverMap[pagerId] = ReactiveObserver()
    <span class="hljs-keyword">val</span> pager: IPager? = pagerCreator(pagerName)?.invoke()  <span class="hljs-comment">// ← 调用注册的 creator 创建 Pager 实例</span>
    pagerMap[pagerId] = pager
    pager.onCreatePager(pagerId, JSONObject(pagerData))      <span class="hljs-comment">// ← 进入页面生命周期</span>
}
</code></pre>
<blockquote>
<p><strong>以上所有代码都在 Context 线程上执行</strong>。从 <code>performOnContextQueue</code> 开始，后面的一切逻辑——页面创建、body 构建、布局计算——全部在 Context 线程上串行运行。</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">6. 第三阶段：Kotlin→Native 通信——同步 vs 异步</h2>
<p>页面在 Context 线程上执行 <code>onCreatePager()</code> 时，会调用 <code>body()</code> 方法构建虚拟视图树，然后 <code>createBody()</code> 进行布局计算。在此过程中，Kotlin 需要告诉 Native 端"帮我创建一个 TextView"、"把它的背景色设为红色"、"把它放到 (10, 20) 位置"等。</p>
<p>这些指令通过 <code>BridgeManager</code> 发出：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// BridgeManager.kt 中定义的 Native 方法</span>
<span class="hljs-keyword">object</span> NativeMethod {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CREATE_RENDER_VIEW = <span class="hljs-number">1</span>      <span class="hljs-comment">// 创建原生 View</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REMOVE_RENDER_VIEW = <span class="hljs-number">2</span>      <span class="hljs-comment">// 移除原生 View</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> INSERT_SUB_RENDER_VIEW = <span class="hljs-number">3</span>  <span class="hljs-comment">// 插入子 View</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SET_VIEW_PROP = <span class="hljs-number">4</span>           <span class="hljs-comment">// 设置 View 属性</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SET_RENDER_VIEW_FRAME = <span class="hljs-number">5</span>   <span class="hljs-comment">// 设置 View 的位置和大小</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALCULATE_RENDER_VIEW_SIZE = <span class="hljs-number">6</span>  <span class="hljs-comment">// 计算 View 尺寸（同步！）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CREATE_SHADOW = <span class="hljs-number">9</span>           <span class="hljs-comment">// 创建 Shadow 节点（同步！）</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 data-id="heading-16">6.1 关键设计：哪些是同步的？哪些是异步的？</h3>
<p>这是 Kuikly 多线程模型中最精妙的设计之一。让我们看 Native 端收到 Kotlin 调用时的处理：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt (Android)</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performNativeMethodWithMethod</span><span class="hljs-params">(method: <span class="hljs-type">KuiklyRenderNativeMethod</span>, args: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span>: Any? {
    <span class="hljs-keyword">val</span> cb = nativeMethodRegistry[method.value]
    cb?.also {
        assert(!isMainThread())  <span class="hljs-comment">// ← 断言：当前在 Context 线程</span>

        <span class="hljs-keyword">if</span> (isSyncMethodCall(method, args)) {
            <span class="hljs-comment">// ★ 同步方法：直接在 Context 线程执行，立即返回结果</span>
            <span class="hljs-keyword">return</span> it(method, args)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// ★ 异步方法：加入 UIScheduler 的任务队列，稍后批量在主线程执行</span>
            uiScheduler?.scheduleTask {
                it(method, args)
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}
</code></pre>
<p>iOS 端的逻辑完全一致：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderCore.m</span>
- (<span class="hljs-type">id</span>)p_performNativeMethodWithMethod:(KuiklyRenderNativeMethod)method args:(<span class="hljs-built_in">NSArray</span> *)args {
    KuiklyRenderNativeMethodCallback methodCallback = _nativeMethodRegistry[@(method)];
    <span class="hljs-keyword">if</span> (methodCallback) {
        [KuiklyRenderThreadManager assertContextQueue];
        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> p_shouldSyncCallWithWithMethod:method args:args]) {
            <span class="hljs-keyword">return</span> methodCallback(method, args);  <span class="hljs-comment">// 同步执行</span>
        } <span class="hljs-keyword">else</span> {
            [<span class="hljs-keyword">self</span>.uiScheduler addTaskToMainQueueWithTask:^{  <span class="hljs-comment">// 异步批量</span>
                methodCallback(method, args);
            }];
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;
}
</code></pre>
<p>哪些方法是同步的？</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// iOS 端的判断逻辑</span>
- (<span class="hljs-type">BOOL</span>)p_shouldSyncCallWithWithMethod:(KuiklyRenderNativeMethod)method args:(<span class="hljs-built_in">NSArray</span> *)args {
    <span class="hljs-keyword">return</span> method == KuiklyRenderNativeMethodCalculateRenderViewSize ||  <span class="hljs-comment">// 计算 View 尺寸</span>
           method == KuiklyRenderNativeMethodCreateShadow ||             <span class="hljs-comment">// 创建 Shadow</span>
           method == KuiklyRenderNativeMethodRemoveShadow ||             <span class="hljs-comment">// 移除 Shadow</span>
           method == KuiklyRenderNativeMethodSetShadowForView ||         <span class="hljs-comment">// 设置 Shadow</span>
           method == KuiklyRenderNativeMethodSetShadowProp ||            <span class="hljs-comment">// Shadow 属性</span>
           method == KuiklyRenderNativeMethodSetTimeout ||               <span class="hljs-comment">// 定时器</span>
           method == KuiklyRenderNativeMethodCallShadowMethod ||         <span class="hljs-comment">// Shadow 方法</span>
           method == KuiklyRenderNativeMethodSyncFlushUI ||              <span class="hljs-comment">// 同步刷新</span>
           <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>为什么要区分同步和异步？</strong> 因为有些操作，Kotlin 侧必须<strong>立即</strong>拿到结果才能继续。比如：</p>
<ul>
<li><strong><code>CALCULATE_RENDER_VIEW_SIZE</code></strong>：计算 Text 的实际尺寸。Kotlin 的 Flexbox 布局引擎需要知道一段文本在给定宽度下会占多高，这个值必须同步返回，布局计算才能继续</li>
<li><strong><code>CREATE_SHADOW</code></strong>：创建 Shadow 节点（如文本的阴影计算）需要 Native 端立即返回</li>
</ul>
<p>而像 <code>CREATE_RENDER_VIEW</code>、<code>SET_VIEW_PROP</code>、<code>SET_RENDER_VIEW_FRAME</code> 这些纯 UI 操作，Kotlin 不需要返回值，可以攒起来批量执行。</p>
<h3 data-id="heading-17">6.2 NativeBridge 的 expect/actual 机制</h3>
<p><code>BridgeManager</code> 通过 <code>NativeBridge</code> 与 Native 通信。这里用到了 Kotlin Multiplatform 的核心机制——<code>expect/actual</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// commonMain（公共层）——只声明接口，不提供实现</span>
<span class="hljs-keyword">expect</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeBridge</span>() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toNative</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, arg0: <span class="hljs-type">Any</span>?, arg1: <span class="hljs-type">Any</span>?, ...)</span></span>: Any?
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>
}
</code></pre>
<p><code>expect</code> 关键字的含义是："我声明了这个东西存在，但具体实现由各平台提供。"</p>
<p>Android 实现：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// androidMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeBridge</span> <span class="hljs-title">actual</span> <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">var</span> delegate: NativeBridgeDelegate? = <span class="hljs-literal">null</span>
    
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toNative</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, ...)</span></span>: Any? {
        <span class="hljs-keyword">return</span> delegate?.callNative(methodId, ...)  <span class="hljs-comment">// 调用 Java/Kotlin 层的回调</span>
    }
}
</code></pre>
<p>iOS 实现：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// appleMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeBridge</span> <span class="hljs-title">actual</span> <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">var</span> iosNativeBridgeDelegate: IOSNativeBridgeDelegate? = <span class="hljs-literal">null</span>
    
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toNative</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, ...)</span></span>: Any? {
        <span class="hljs-keyword">return</span> iosNativeBridgeDelegate?.callNative(methodId, ...)  <span class="hljs-comment">// 调用 ObjC 层的回调</span>
    }
}
</code></pre>
<p>这样，公共层的 <code>BridgeManager</code> 调用 <code>nativeBridge.toNative()</code> 时，<strong>编译器会自动根据目标平台选择正确的实现</strong>。这就是 Kotlin Multiplatform 的"同一份代码，多平台运行"的基础机制。</p>
<hr/>
<h2 data-id="heading-18">7. 第四阶段：UIScheduler——批量上屏的艺术</h2>
<p>UIScheduler 是 Kuikly 多线程模型中<strong>性能优化</strong>的核心。它的设计思想是：</p>
<blockquote>
<p><strong>不要来一条 UI 指令就切一次线程，而是攒一批指令，一次性切到主线程全部执行完。</strong></p>
</blockquote>
<h3 data-id="heading-19">7.1 Android 端实现</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCoreUIScheduler.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">KuiklyRenderCoreUIScheduler</span>(...) : IKuiklyRenderCoreScheduler {
    
    <span class="hljs-comment">// Context 线程上暂存的任务列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mainThreadTasksOnContextQueue: MutableList&lt;KuiklyRenderCoreTaskExecutor&gt;? = <span class="hljs-literal">null</span>
    <span class="hljs-comment">// 主线程上待执行的任务列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mainThreadTasks = mutableListOf&lt;KuiklyRenderCoreTaskExecutor&gt;()
    
    <span class="hljs-comment">// 在 Context 线程调用——收集任务</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addTaskToMainQueue</span><span class="hljs-params">(task: <span class="hljs-type">KuiklyRenderCoreTaskExecutor</span>)</span></span> {
        assert(!isMainThread())  <span class="hljs-comment">// ← 必须在 Context 线程</span>
        <span class="hljs-keyword">val</span> tasks = mainThreadTasksOnContextQueue ?: mutableListOf&lt;KuiklyRenderCoreTaskExecutor&gt;().apply {
            mainThreadTasksOnContextQueue = <span class="hljs-keyword">this</span>
        }
        tasks.add(task)
        setNeedSyncMainQueueTasks()  <span class="hljs-comment">// ← 标记"有任务需要同步到主线程"</span>
    }
}
</code></pre>
<p><code>setNeedSyncMainQueueTasks</code> 的实现非常精巧：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setNeedSyncMainQueueTasks</span><span class="hljs-params">()</span></span> {
    assert(!isMainThread())
    <span class="hljs-keyword">if</span> (needSyncMainQueueTasksBlock != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// ← 已经标记过了，不重复标记！这就是"批量"的秘诀</span>
    }
    
    <span class="hljs-comment">// 创建"同步闭包"——包含了把 Context 线程任务搬到主线程的逻辑</span>
    needSyncMainQueueTasksBlock = { sync -&gt;
        <span class="hljs-keyword">val</span> performTasks = mainThreadTasksOnContextQueue
        mainThreadTasksOnContextQueue = <span class="hljs-literal">null</span>
        synchronized(<span class="hljs-keyword">this</span>) {
            mainThreadTasks.addAll(performTasks?.toList() ?: listOf())
        }
        performOnMainQueueWithTask(sync = sync) {
            <span class="hljs-comment">// 在主线程执行所有任务</span>
            <span class="hljs-keyword">var</span> tasks: List&lt;KuiklyRenderCoreTaskExecutor&gt;?
            synchronized(<span class="hljs-keyword">this</span>) {
                tasks = mainThreadTasks.toList()
                mainThreadTasks.clear()
            }
            runMainQueueTasks(tasks)
        }
    }
    
    <span class="hljs-comment">// ★ 关键：把"执行同步闭包"这件事，再 post 到 Context 线程消息队列的尾部</span>
    KuiklyRenderCoreContextScheduler.scheduleTask {
        performSyncMainQueueTasksBlockIfNeed(<span class="hljs-literal">false</span>)
    }
}
</code></pre>
<p><strong>为什么要 post 到 Context 线程队列尾部？</strong> 因为当前 Context 线程正在执行 Kotlin 逻辑（比如 body 方法还没执行完），会不断产生新的 UI 指令。把"同步到主线程"这个动作 post 到队列尾部，就能保证<strong>当前一轮逻辑全部执行完后，再一次性把所有指令提交给主线程</strong>。</p>
<p>让我们画出这个时序：</p>
<pre><code class="hljs language-css" lang="css">Context 线程的消息队列
┌─────────────────────────────────────────────┐
│ <span class="hljs-selector-attr">[当前任务: 执行 body、布局计算、产生 UI 指令]</span>      │
│ <span class="hljs-selector-attr">[排队: performSyncMainQueueTasksBlockIfNeed]</span> │  ← 在当前任务结束后执行
└─────────────────────────────────────────────┘

当前任务执行过程中，产生的 UI 指令被收集到 mainThreadTasksOnContextQueue
当前任务执行完，轮到 performSync... → 把收集的指令批量 post 到主线程
</code></pre>
<h3 data-id="heading-20">7.2 iOS 端实现</h3>
<p>iOS 的逻辑完全一致，只是用 ObjC + GCD 实现：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderUIScheduler.m</span>
- (<span class="hljs-type">void</span>)addTaskToMainQueueWithTask:(dispatch_block_t)taskBlock {
    KR_ASSERT_CONTEXT_HTREAD;  <span class="hljs-comment">// 断言在 Context 线程</span>
    [_mainThreadTasksOnContextQueue addObject:taskBlock];
    [<span class="hljs-keyword">self</span> p_setNeedSyncMainQuequeTasks];
}

- (<span class="hljs-type">void</span>)p_setNeedSyncMainQuequeTasks {
    <span class="hljs-keyword">if</span> (!_needSyncMainQueueTasksBlock) {
        KR_WEAK_SELF
        <span class="hljs-keyword">self</span>.needSyncMainQueueTasksBlock = ^{
            <span class="hljs-comment">// 同步 UI 任务前，先通知 Kotlin 做 layoutIfNeed</span>
            [strongSelf p_dispatchWillPerformUITasksDelegator];
            <span class="hljs-built_in">NSArray</span> *tasks = weakSelf.mainThreadTasksOnContextQueue;
            weakSelf.mainThreadTasksOnContextQueue = <span class="hljs-literal">nil</span>;
            <span class="hljs-comment">// 加锁搬运任务</span>
            [weakSelf.threadLock threadSafeInBlock:^{
                [weakSelf.mainThreadTasks addObjectsFromArray:tasks];
            }];
            <span class="hljs-comment">// 切到主线程批量执行</span>
            [KuiklyRenderThreadManager performOnMainQueueWithTask:^{
                <span class="hljs-keyword">for</span> (dispatch_block_t task <span class="hljs-keyword">in</span> mainThreadTasks) {
                    task();
                }
            } sync:[<span class="hljs-built_in">NSThread</span> isMainThread]];
        };
        <span class="hljs-comment">// 再调度一次到 Context 线程尾部</span>
        [KuiklyRenderThreadManager performOnContextQueueWithBlock:^{
            [weakSelf performSyncMainQueueTasksBlockIfNeed];
        }];
    }
}
</code></pre>
<h3 data-id="heading-21">7.3 一个容易被忽略的细节：layoutIfNeed 的时机</h3>
<p>注意 iOS 端有一行 <code>[strongSelf p_dispatchWillPerformUITasksDelegator]</code>，Android 端对应的是 UIScheduler 构造时传入的闭包：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
uiScheduler = KuiklyRenderCoreUIScheduler {
    <span class="hljs-comment">// 同步主线程任务前，告诉 Kotlin 侧去 layoutIfNeed</span>
    contextHandler?.call(KuiklyRenderContextMethodLayoutView, listOf(instanceId))
}
</code></pre>
<p>这个回调在"把 UI 指令提交给主线程之前"被调用，它的作用是确保 <strong>Kotlin 侧已经完成布局计算</strong>，所有 View 的 Frame 都已经确定。否则可能出现"View 已经创建了，但还不知道放在哪里"的情况。</p>
<hr/>
<h2 data-id="heading-22">8. 第五阶段：首屏完成与后续事件闭环</h2>
<h3 data-id="heading-23">8.1 首屏渲染完成</h3>
<p>UIScheduler 在主线程执行完第一批 UI 指令后，会标记 <code>viewDidLoad = true</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCoreUIScheduler.kt</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runMainQueueTasks</span><span class="hljs-params">(tasks: <span class="hljs-type">List</span>&lt;<span class="hljs-type">KuiklyRenderCoreTaskExecutor</span>&gt;?)</span></span> {
    assert(isMainThread())
    <span class="hljs-keyword">val</span> uiTasks = tasks ?: <span class="hljs-keyword">return</span>
    isPerformingMainQueueTask = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">for</span> (task <span class="hljs-keyword">in</span> uiTasks) {
        task.execute()
    }
    isPerformingMainQueueTask = <span class="hljs-literal">false</span>
    
    <span class="hljs-keyword">if</span> (!viewDidLoad) {
        viewDidLoad = <span class="hljs-literal">true</span>           <span class="hljs-comment">// ← 首屏标记</span>
        performViewDidLoadTasksIfNeed()  <span class="hljs-comment">// ← 执行等待首屏完成的任务</span>
    }
}
</code></pre>
<p>然后 Native 端会通过 <code>sendEvent</code> 通知 Kotlin 侧"首屏完成了"：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">sendEvent</span>("pageFirstFramePaint") → Context 线程 → Pager<span class="hljs-selector-class">.onReceivePagerEvent</span>()
</code></pre>
<h3 data-id="heading-24">8.2 后续事件——从主线程回到 Context 线程</h3>
<p>用户的触摸、滑动等事件发生在主线程，需要通知到 Context 线程的 Kotlin 逻辑。以 <code>sendEvent</code> 为例：</p>
<p>Android 端：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendEvent</span><span class="hljs-params">(event: <span class="hljs-type">String</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, Any&gt;, shouldSync: <span class="hljs-type">Boolean</span>)</span></span> {
    performOnContextQueue(sync = shouldSync) {  <span class="hljs-comment">// ← 切到 Context 线程</span>
        contextHandler?.call(KuiklyRenderContextMethodUpdateInstance,
            listOf(instanceId, event, <span class="hljs-keyword">data</span>))
    }
}
</code></pre>
<p>iOS 端：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderCore.m</span>
- (<span class="hljs-type">void</span>)sendWithEvent:(<span class="hljs-built_in">NSString</span> *)event data:(<span class="hljs-built_in">NSDictionary</span> *)data {
    [KuiklyRenderThreadManager performOnContextQueueWithBlock:^{
        [<span class="hljs-keyword">self</span>.contextHandler callWithMethod:KuiklyRenderContextMethodUpdateInstance
                                      args:@[<span class="hljs-keyword">self</span>.instanceId, event, data]];
    } sync:![<span class="hljs-built_in">NSThread</span> isMainThread]];  <span class="hljs-comment">// ← 非主线程时同步调用</span>
}
</code></pre>
<p>注意 iOS 端的 <code>sync:![NSThread isMainThread]</code>：如果当前已经在 Context 线程上（非主线程），就用 <code>dispatch_sync</code> 直接同步执行；如果在主线程上，就用 <code>dispatch_async</code> 异步投递（避免主线程阻塞等待 Context 线程）。</p>
<p>这样就形成了完整的事件循环：</p>
<pre><code class="hljs language-scss" lang="scss">用户操作(主线程) → sendEvent → Context 线程(Kotlin 处理逻辑)
                                    ↓
                              产生新的 UI 指令
                                    ↓
                              UIScheduler 批量
                                    ↓
                              主线程执行(UI 更新)
</code></pre>
<hr/>
<h2 data-id="heading-25">9. iOS 端 vs Android 端的线程实现对比</h2>























































<table><thead><tr><th>维度</th><th>Android</th><th>iOS</th></tr></thead><tbody><tr><td><strong>Context 线程</strong></td><td><code>HandlerThread</code>（基于 Java 的 Looper/Handler 机制）</td><td>GCD <code>dispatch_queue_create</code>（串行队列）</td></tr><tr><td><strong>线程优先级</strong></td><td><code>Process.THREAD_PRIORITY_FOREGROUND</code></td><td><code>QOS_CLASS_USER_INTERACTIVE</code></td></tr><tr><td><strong>判断是否在 Context 线程</strong></td><td><code>ThreadLocal&lt;Boolean&gt;</code>（<code>NativeBridge.isContextThread</code>）</td><td><code>dispatch_get_specific</code>（queue-specific data）</td></tr><tr><td><strong>切到 Context 线程</strong></td><td><code>handler.post { task }</code></td><td><code>dispatch_async(contextQueue, task)</code></td></tr><tr><td><strong>切到主线程</strong></td><td><code>Handler(Looper.getMainLooper()).post { task }</code></td><td><code>dispatch_async(dispatch_get_main_queue(), task)</code></td></tr><tr><td><strong>UIScheduler</strong></td><td>基于 <code>MutableList</code> + <code>synchronized</code> 锁</td><td>基于 <code>NSMutableArray</code> + <code>KuiklyRenderThreadLock</code></td></tr><tr><td><strong>线程间同步调用</strong></td><td><code>ConditionVariable</code>（<code>BlockingRunnable</code>）</td><td><code>dispatch_sync</code></td></tr><tr><td><strong>Kotlin→Native 桥接</strong></td><td>反射加载 <code>KuiklyCoreEntry</code> 类（JVM）</td><td>ObjC 反射加载 Kotlin/Native Framework</td></tr><tr><td><strong>Native→Kotlin 调用</strong></td><td><code>IKuiklyCoreEntry.callKotlinMethod()</code></td><td><code>[contextHandler callWithMethod:args:]</code></td></tr></tbody></table>
<p>虽然实现方式不同，但<strong>架构完全一致</strong>：单一 Context 线程 + UIScheduler 批量提交 + 主线程执行。</p>
<h3 data-id="heading-26">9.1 iOS 特有的 C 桥接</h3>
<p>iOS 端还额外提供了一组 C 函数，供 Kotlin/Native 编译出的代码调用：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// KuiklyRenderThreadBridge.m</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">com_tencent_kuikly_ScheduleContextTask</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pagerId, 
                                             <span class="hljs-type">void</span> (*onSchedule)(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*))</span> {
    NSString *pId = [NSString stringWithUTF8String:pagerId];
    [KuiklyRenderThreadManager performOnContextQueueWithBlock:^{
        onSchedule([pId UTF8String]);
    } sync:NO];
}

<span class="hljs-type">bool</span> <span class="hljs-title function_">com_tencent_kuikly_IsCurrentOnContextThread</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pagerId)</span> {
    <span class="hljs-keyword">return</span> [KuiklyRenderThreadManager isContextQueue];
}
</code></pre>
<p>为什么需要 C 函数？因为 Kotlin/Native 编译为 iOS 的 Framework 时，不能直接调用 ObjC 的类方法（除非通过 cinterop），但可以调用 C 函数。这些 C 函数充当了"桥梁"角色。</p>
<hr/>
<h2 data-id="heading-27">10. 从其他线程回到 Kuikly 线程</h2>
<p>当你在 Kotlin 中使用了多线程（比如 KMP 的 expect/actual 机制、或者 kotlinx 协程切换到 IO 线程），完成异步操作后需要回到 Kuikly 线程更新 UI。Kuikly 提供了 <code>KuiklyContextScheduler</code> 来实现这一点。</p>
<h3 data-id="heading-28">10.1 公共层 API</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyContextScheduler.kt (commonMain)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> KuiklyContextScheduler : SynchronizedObject() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>, block: (<span class="hljs-type">cancel</span>: <span class="hljs-type">Boolean</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
        <span class="hljs-comment">// 如果已经在 Kuikly 线程上，直接执行</span>
        <span class="hljs-keyword">if</span> (platformIsOnKuiklyThread(pagerId)) {
            block(<span class="hljs-literal">false</span>)
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-comment">// 否则，调度到 Kuikly 线程</span>
        addTask(pagerId, block)
        platformScheduleOnKuiklyThread(pagerId)
    }
}
</code></pre>
<p>注意 <code>block: (cancel: Boolean) -&gt; Unit</code> 的设计——参数 <code>cancel</code> 告诉你页面是否已经销毁。如果页面已经销毁（<code>BridgeManager.containNativeBridge(pagerId)</code> 返回 false），<code>cancel</code> 为 true，你应该放弃操作。这是一个很好的<strong>安全机制</strong>。</p>
<h3 data-id="heading-29">10.2 Android 实现</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyContextScheduler.android.kt</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformIsOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> NativeBridge.isContextThread  <span class="hljs-comment">// ← 读 ThreadLocal</span>
}

<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformScheduleOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span> {
    KuiklyRenderCoreContextScheduler.scheduleTask {
        KuiklyContextScheduler.runTask(pagerId)  <span class="hljs-comment">// ← post 到 Context 线程</span>
    }
}
</code></pre>
<h3 data-id="heading-30">10.3 iOS 实现</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyContextScheduler.ios.kt</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformIsOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> com_tencent_kuikly_IsCurrentOnContextThread(pagerId)  <span class="hljs-comment">// ← 调用 C 函数</span>
}

<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformScheduleOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span> {
    com_tencent_kuikly_ScheduleContextTask(pagerId, staticCFunction { pIdPtr -&gt;
        <span class="hljs-comment">// 这个 staticCFunction 是 Kotlin/Native 提供的机制</span>
        <span class="hljs-comment">// 它将 Kotlin 函数转为 C 函数指针，以便 ObjC/C 代码回调</span>
        <span class="hljs-keyword">val</span> pId = pIdPtr!!.toKString()
        KuiklyContextScheduler.runTask(pId)
    })
}
</code></pre>
<h3 data-id="heading-31">10.4 使用 Dispatchers.Kuikly</h3>
<p>如果你使用 kotlinx 协程，可以通过自定义 Dispatcher 切回 Kuikly 线程：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    <span class="hljs-comment">// 在 Kuikly 线程启动协程</span>
    GlobalScope.launch(Dispatchers.Kuikly[ctx]) {
        <span class="hljs-comment">// 切到 IO 线程做耗时操作</span>
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) {
            fetchDataFromNetwork()
        }
        <span class="hljs-comment">// 自动回到 Kuikly 线程，安全更新 UI</span>
        ctx.dataObservable = <span class="hljs-keyword">data</span>
    }
}
</code></pre>
<p><code>Dispatchers.Kuikly[ctx]</code> 的实现原理就是把协程的恢复操作调度到 <code>KuiklyContextScheduler.runOnKuiklyThread()</code> 上。</p>
<hr/>
<h2 data-id="heading-32">11. 线程安全验证机制</h2>
<p>Kuikly 提供了开发阶段的线程安全验证：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Pager.kt</span>
<span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">var</span> VERIFY_THREAD
        <span class="hljs-keyword">get</span>() = com.tencent.kuikly.core.utils.VERIFY_THREAD
        <span class="hljs-keyword">set</span>(value) { com.tencent.kuikly.core.utils.VERIFY_THREAD = value }
    
    <span class="hljs-keyword">var</span> VERIFY_REACTIVE_OBSERVER
        <span class="hljs-keyword">get</span>() = com.tencent.kuikly.core.utils.VERIFY_REACTIVE_OBSERVER
        <span class="hljs-keyword">set</span>(value) { com.tencent.kuikly.core.utils.VERIFY_REACTIVE_OBSERVER = value }
}
</code></pre>
<p>开启方式：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Page(<span class="hljs-string">"DebugPage"</span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugPage</span> : <span class="hljs-type">BasePager</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">willInit</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.willInit()
        Pager.VERIFY_THREAD = <span class="hljs-literal">true</span>             <span class="hljs-comment">// 开启线程校验</span>
        Pager.VERIFY_REACTIVE_OBSERVER = <span class="hljs-literal">true</span>   <span class="hljs-comment">// 开启响应式观察者校验</span>
        
        Pager.verifyFailed { exception -&gt;
            <span class="hljs-comment">// 自定义验证失败的处理</span>
            println(<span class="hljs-string">"线程安全验证失败: <span class="hljs-subst">${exception.message}</span>"</span>)
            <span class="hljs-keyword">throw</span> exception  <span class="hljs-comment">// 开发阶段直接崩溃，方便定位</span>
        }
    }
}
</code></pre>
<p>当 <code>VERIFY_THREAD = true</code> 时，如果你在非 Context 线程访问了 <code>observable</code> 属性或调用了 UI 相关 API，框架会立即抛出异常。<strong>强烈建议在开发阶段开启这两个选项。</strong></p>
<hr/>
<h2 data-id="heading-33">12. 三种异步编程方式的选择</h2>
<p>理解了多线程模型后，让我们看看 Kuikly 提供的三种异步编程方案以及它们的适用场景：</p>
<h3 data-id="heading-34">方式一：Module 机制 + Kuikly 内建协程</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    lifecycleScope.launch {
        <span class="hljs-keyword">val</span> type = fetchLocal()       <span class="hljs-comment">// 挂起函数（底层通过 Module 调 Native）</span>
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = fetchRemote(type)  <span class="hljs-comment">// 挂起函数</span>
        ctx.dataObservable = <span class="hljs-keyword">data</span>     <span class="hljs-comment">// 安全更新 UI</span>
    }
}
</code></pre>
<ul>
<li><strong>线程模型</strong>：始终在 Kuikly 线程。异步操作通过 Module 下沉到 Native 层执行（Native 可以自由使用多线程），结果通过回调返回到 Kuikly 线程</li>
<li><strong>优势</strong>：无线程安全问题，支持动态化，无额外依赖</li>
<li><strong>适用场景</strong>：大多数业务需求（网络请求、本地存储、系统 API 调用）</li>
</ul>
<h3 data-id="heading-35">方式二：KMP 多线程 + kuiklyx 回调</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    asyncKmpFetchData { <span class="hljs-keyword">data</span> -&gt;
        KuiklyContextScheduler.runOnKuiklyThread(ctx.pagerId) { cancel -&gt;
            <span class="hljs-keyword">if</span> (cancel) <span class="hljs-keyword">return</span><span class="hljs-symbol">@runOnKuiklyThread</span>
            ctx.dataObservable = <span class="hljs-keyword">data</span>  <span class="hljs-comment">// 回到 Kuikly 线程更新 UI</span>
        }
    }
}
</code></pre>
<ul>
<li><strong>线程模型</strong>：KMP 代码可以在任意线程执行，完成后显式切回 Kuikly 线程</li>
<li><strong>优势</strong>：无通信开销（直接跨平台调用，不经过 Bridge）</li>
<li><strong>劣势</strong>：不支持动态化，需要手动管理线程切换</li>
<li><strong>适用场景</strong>：对性能要求极高、不需要动态化的场景</li>
</ul>
<h3 data-id="heading-36">方式三：kotlinx 协程 + Dispatchers.Kuikly</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    GlobalScope.launch(Dispatchers.Kuikly[ctx]) {
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) {
            kmpFetchData()  <span class="hljs-comment">// 在 IO 线程执行</span>
        }
        <span class="hljs-comment">// 自动回到 Kuikly 线程</span>
        ctx.dataObservable = <span class="hljs-keyword">data</span>
    }
}
</code></pre>
<ul>
<li><strong>线程模型</strong>：利用 kotlinx 协程的 Dispatcher 机制自由切换线程</li>
<li><strong>优势</strong>：代码可读性最好，与 Kotlin 社区标准对齐</li>
<li><strong>劣势</strong>：不支持动态化，需要引入 kotlinx 协程库 + kuiklyx 协程库</li>
<li><strong>适用场景</strong>：复杂的异步逻辑，需要协程语法提升可读性</li>
</ul>
<h3 data-id="heading-37">选择决策树</h3>
<pre><code class="hljs language-markdown" lang="markdown">你需要动态化吗？
├─ 是 → 方式一（Module + Kuikly 内建协程）
└─ 否 → 你需要多线程执行耗时任务吗？
<span class="hljs-code">         ├─ 否 → 方式一
         └─ 是 → 你需要协程语法吗？
                  ├─ 否 → 方式二（KMP + kuiklyx 回调）
                  └─ 是 → 方式三（kotlinx + Dispatchers.Kuikly）
</span></code></pre>
<hr/>
<h2 data-id="heading-38">13. 总结：一张图看清全貌</h2>
<pre><code class="hljs language-scss" lang="scss">                          ┌──────────────────────────────────────┐
                          │           主线程 (UI Thread)           │
                          │                                      │
                          │   KuiklyRenderView                   │
                          │     ├─ <span class="hljs-built_in">init</span>()  ──schedule──→ ①       │
                          │     │                                │
                          │   UIScheduler ←─── 批量UI指令 ←─ ④  │
                          │     ├─ <span class="hljs-built_in">createView</span>()                  │
                          │     ├─ <span class="hljs-built_in">setProp</span>()                     │
                          │     ├─ <span class="hljs-built_in">setFrame</span>()                    │
                          │     └─ viewDidLoad ──sendEvent──→ ⑤ │
                          │                                      │
                          └──────────────┬───────────────────────┘
                                         │ ①②④⑤ 线程间通信
                          ┌──────────────┴───────────────────────┐
                          │       Context 线程 (Kuikly Thread)     │
                          │                                      │
                          │ ② initContextHandler                 │
                          │     ├─ 加载 KuiklyCoreEntry           │
                          │     ├─ 注册 callNative 回调           │
                          │     └─ <span class="hljs-built_in">call</span>(CREATE_INSTANCE)         │
                          │                                      │
                          │ ③ PagerManager<span class="hljs-selector-class">.createPager</span>()         │
                          │     └─ pager<span class="hljs-selector-class">.onCreatePager</span>()         │
                          │         ├─ <span class="hljs-built_in">willInit</span>()                │
                          │         ├─ <span class="hljs-built_in">initModule</span>()              │
                          │         ├─ <span class="hljs-built_in">didInit</span>() → <span class="hljs-selector-tag">body</span>()        │
                          │         └─ <span class="hljs-built_in">createBody</span>()              │
                          │             ├─ <span class="hljs-built_in">createFlexNode</span>()      │
                          │             ├─ <span class="hljs-built_in">layoutIfNeed</span>()        │
                          │             └─ callNative ×N ──→ ④  │
                          │                                      │
                          │ ⑤ onReceivePagerEvent                │
                          │     ("pageFirstFramePaint")          │
                          │                                      │
                          │ ⑥ 后续：响应式更新、事件处理、协程...    │
                          │     └─ 新的 callNative → UIScheduler │
                          │                                      │
                          └──────────────────────────────────────┘

线程间通信方式：
  ① 主线程 → Context: handler.<span class="hljs-built_in">post</span>() / <span class="hljs-built_in">dispatch_async</span>(contextQueue)
  ④ Context → 主线程: UIScheduler 批量 → uiHandler.<span class="hljs-built_in">post</span>() / <span class="hljs-built_in">dispatch_async</span>(mainQueue)
  ⑤ 主线程 → Context: sendEvent → performOnContextQueue
  
同步调用（不经 UIScheduler，Context 线程直接执行并返回）：
  CalculateRenderViewSize、CreateShadow、SetTimeout 等
</code></pre>
<h3 data-id="heading-39">核心要点</h3>
<ol>
<li><strong>两条线程，各司其职</strong>：Context 线程负责全部 Kotlin 逻辑，主线程负责 Native View 操作</li>
<li><strong>所有 Kuikly 的 UI 类（View、Attr、Event、Observable）只能在 Context 线程访问</strong></li>
<li><strong>UIScheduler 是性能关键</strong>：收集 UI 指令、批量提交、减少线程切换次数</li>
<li><strong>同步方法 vs 异步方法</strong>：需要返回值的（如计算尺寸）同步执行，纯 UI 操作异步批量</li>
<li><strong>回到 Kuikly 线程</strong>：使用 <code>KuiklyContextScheduler.runOnKuiklyThread()</code> 或 <code>Dispatchers.Kuikly</code></li>
<li><strong>串行 = 安全</strong>：Context 线程是串行的，不存在并发竞争，不需要加锁</li>
</ol>
<p>理解了这条链路，你就掌握了 Kuikly 框架最核心的架构设计。无论是排查性能问题、理解页面加载慢的原因、还是正确处理异步逻辑，都能做到心中有数。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SKAdNetwork 6.0 深度实战：多窗口转化值（Conversion Value）建模与数据分层架构]]></title>    <link>https://juejin.cn/post/7603958579180470272</link>    <guid>https://juejin.cn/post/7603958579180470272</guid>    <pubDate>2026-02-09T04:00:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603958579180470272" data-draft-id="7603699739223932943" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SKAdNetwork 6.0 深度实战：多窗口转化值（Conversion Value）建模与数据分层架构"/> <meta itemprop="keywords" content="iOS"/> <meta itemprop="datePublished" content="2026-02-09T04:00:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="山水域"/> <meta itemprop="url" content="https://juejin.cn/user/2260251635887309"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SKAdNetwork 6.0 深度实战：多窗口转化值（Conversion Value）建模与数据分层架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2260251635887309/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    山水域
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:00:32.000Z" title="Mon Feb 09 2026 04:00:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>摘要</strong>：随着 iOS 隐私政策的持续演进，SKAdNetwork (SKAN) 6.0 已成为移动营销衡量的新标准。本文将深入探讨 SKAN 6.0 的核心机制，重点解析如何针对三个转化窗口进行科学的转化值（CV）建模，并构建适配分层数据（Hierarchical Data）的归因架构，帮助高级 iOS 开发者与 AdTech 专家在隐私保护时代重构数据增长引擎。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、 SKAN 6.0：从“黑盒”到“多维度透明”</h2>
<p>SKAdNetwork 6.0（随 iOS 17.4+ 发布）在 4.0 的基础上进一步深化了隐私与效果的平衡。相比早期版本，SKAN 6.0 的核心进步在于通过<strong>多窗口回传（Multiple Postbacks）<strong>和</strong>分层源标识符（Hierarchical Source IDs）</strong>，提供了更长的生命周期观测能力和更灵活的数据粒度。</p>
<h3 data-id="heading-1">核心变化点：</h3>
<ol>
<li><strong>三段式转化窗口</strong>：
<ul>
<li><strong>Window 1 (P1)</strong>: 0-2 天，支持精细化（Fine-grained, 0-63）或粗略化（Coarse-grained）CV。</li>
<li><strong>Window 2 (P2)</strong>: 3-7 天，仅支持粗略化 CV。</li>
<li><strong>Window 3 (P3)</strong>: 8-35 天，仅支持粗略化 CV。</li>
</ul>
</li>
<li><strong>分层源标识符（Source ID）</strong>：从 2 位扩展到 4 位，根据人群匿名度（Crowd Anonymity）阶梯式释放数据。</li>
<li><strong>广告主域名（Advertising Domain）</strong>：增强了网页到 App 归因的安全性与透明度。</li>
</ol>
<hr/>
<h2 data-id="heading-2">二、 多窗口转化值（CV）建模策略</h2>
<p>在 SKAN 6.0 中，CV 建模不再是单一维度的映射，而是一场关于“时间”与“价值”的博弈。</p>
<h3 data-id="heading-3">2.1 Window 1 (P1)：精细化建模（0-63）</h3>
<p>P1 决定了初始出价模型的准确性。建议采用“收入+行为”混合模型：</p>
<ul>
<li><strong>Bits 0-3 (Value 0-15)</strong>：代表收入区间（e.g., <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">0, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"/><span class="mord">0</span><span class="mpunct">,</span></span></span></span></span>0.99-$4.99, ...）。</li>
<li><strong>Bits 4-5 (Value 16-63)</strong>：代表关键转化行为（e.g., 完成新手引导、加入购物车、订阅尝试）。</li>
</ul>
<h3 data-id="heading-4">2.2 Window 2 &amp; 3 (P2/P3)：粗略化建模（Low/Medium/High）</h3>
<p>由于仅支持三个档位，建模应侧重于<strong>长期留存</strong>与<strong>LTV 预测</strong>：</p>
<ul>
<li><strong>Low</strong>: 用户仅启动过 App（维持活跃）。</li>
<li><strong>Medium</strong>: 用户完成了中层转化（e.g., 累计在线时长 &gt; 10min 或 完成 3 次关卡）。</li>
<li><strong>High</strong>: 高价值行为（e.g., 再次复购或触发深度互动）。</li>
</ul>
<h3 data-id="heading-5">2.3 锁窗机制（LockWindow）的应用</h3>
<p>开发者可以通过 <code>lockWindow()</code> 提前锁定当前的转化窗口，以缩短数据回传的延迟。
<strong>实战建议</strong>：当用户触发了预期的最高价值行为（如首充）后立即锁窗，以最快速度将数据反馈给投放渠道。</p>
<hr/>
<h2 data-id="heading-6">三、 适配分层数据（Hierarchical Data）的架构设计</h2>
<p>SKAN 6.0 的数据产出取决于“人群匿名度”。这种不确定性要求服务端架构具备极强的鲁棒性。</p>
<h3 data-id="heading-7">3.1 数据分层接收流程</h3>
<ol>
<li><strong>捕获原始回传</strong>：服务端需能够处理不同粒度的 JSON。</li>
<li><strong>映射解析层</strong>：根据 <code>source-identifier</code> 的位数（2/3/4位）决定关联的广告层级（Campaign vs Ad Group vs Creative）。</li>
<li><strong>延迟修正模型</strong>：利用 Apple 定义的时间随机延迟（Window 1: 24-48h; Window 2/3: 24-144h）进行数据对齐。</li>
</ol>
<h3 data-id="heading-8">3.2 代码示例：更新转化值与锁定窗口（Swift）</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> StoreKit

<span class="hljs-keyword">func</span> <span class="hljs-title function_">updateSKANConversion</span>(<span class="hljs-params">revenue</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">isDeepConversion</span>: <span class="hljs-type">Bool</span>) {
    <span class="hljs-keyword">let</span> cvValue <span class="hljs-operator">=</span> calculateFineGrainedCV(revenue) <span class="hljs-comment">// 自定义映射逻辑</span>
    <span class="hljs-keyword">let</span> coarseValue: <span class="hljs-type">SKAdNetwork</span>.<span class="hljs-type">CoarseConversionValue</span> <span class="hljs-operator">=</span> revenue <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span> <span class="hljs-operator">?</span> .high : .medium
    
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">16.1</span>, <span class="hljs-operator">*</span>) {
        <span class="hljs-type">SKAdNetwork</span>.updatePostbackConversionValue(cvValue, coarseValue: coarseValue) { error <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error <span class="hljs-operator">=</span> error {
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"SKAN Update Failed: <span class="hljs-subst">\(error.localizedDescription)</span>"</span>)
            }
        }
        
        <span class="hljs-comment">// 如果是关键高价值行为，锁定窗口以加速回传</span>
        <span class="hljs-keyword">if</span> isDeepConversion {
            <span class="hljs-type">SKAdNetwork</span>.updatePostbackConversionValue(cvValue, coarseValue: coarseValue, lockWindow: <span class="hljs-literal">true</span>) { error <span class="hljs-keyword">in</span>
                <span class="hljs-comment">// 处理回调</span>
            }
        }
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-9">四、 总结与最佳实践</h2>
<ol>
<li><strong>组合建模</strong>：利用 P1 优化 CPI/tROAS，利用 P2/P3 观测用户留存。</li>
<li><strong>阈值监控</strong>：实时监控 <code>postback</code> 中的数据粒度，若频繁出现低位 Source ID，说明样本量不足以触发隐私阈值，需调整投放预算集中度。</li>
<li><strong>混合归因</strong>：将 SKAN 数据与自建的概率性归因（Probabilistic Attribution）进行交叉校验，构建更完整的用户画像。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开源 Claude Code + Codex + 面板 的未来vibecoding平台]]></title>    <link>https://juejin.cn/post/7604690250342809650</link>    <guid>https://juejin.cn/post/7604690250342809650</guid>    <pubDate>2026-02-09T05:38:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604690250342809650" data-draft-id="7604012106154983470" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开源 Claude Code + Codex + 面板 的未来vibecoding平台"/> <meta itemprop="keywords" content="前端,后端,GitHub"/> <meta itemprop="datePublished" content="2026-02-09T05:38:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="朱昆鹏"/> <meta itemprop="url" content="https://juejin.cn/user/2788017219055175"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开源 Claude Code + Codex + 面板 的未来vibecoding平台
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2788017219055175/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    朱昆鹏
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T05:38:55.000Z" title="Mon Feb 09 2026 05:38:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一句话介绍</h3>
<p><strong>CodeMoss</strong> =</p>
<ul>
<li>多AI联动：Claude Code + Codex + Gemini + OpenCode + ......</li>
<li>多端使用：客户端 + Jetbrains + Vscode + 移动端</li>
<li>多周边集成：AI面板 + AI记忆 + Superpowers + OpenSpec + Spec-kit + ...</li>
</ul>
<blockquote>
<p>说了这么多功能，直接放实机图更容易理解</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ca3a052d2b145e385c849123967241f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=nn0sfSGVe8SCmJhyegPUQthmaPQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7fe14972acb469084b0c60d0d558814~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=NU52DPK8Lm2G%2B9xpxbCw22iTjh0%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<blockquote>
<p>总之一句话：CodeMoss 目标打造 下一代的vibecoding 入口</p>
</blockquote>
<p>开源地址（感谢你的Star和推荐，这将让更多人用到）</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhukunpenglinyutong%2Fcodemoss" target="_blank" title="https://github.com/zhukunpenglinyutong/codemoss" ref="nofollow noopener noreferrer">github.com/zhukunpengl…</a></p>
<hr/>
<h3 data-id="heading-1">详细介绍</h3>
<h5 data-id="heading-2">对话过程页面</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea4d23aabf7646c395e29b8a44a34b66~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=c3QPYmb1GfoFrytKQXFtsM9WhOg%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-3">侧边栏GIT模块</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06dd3656613146ccbb9cda85860b6a13~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=LN762OBz34XAd3G4yrP3tn8u6hk%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-4">侧边栏文件管理模块</h5>
<blockquote>
<p>真的可以编辑哦~</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88d15377ba374873b9e4df738851cb05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=QFYzxbRbR1tCSuEzx6B6oWd9iTI%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-5">面板模式</h5>
<blockquote>
<p>这不是普通的面板哦~，是真的可以并行执行任务，有完整交互的AI面板哦~</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adfaccd9f8cb4b9a8a0abc47679939be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=PxJ4XU6%2BtRxC8ysMbkrTqhiX%2FYs%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/505c1c2cb910498db91cd4871fd4fdee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=cuz5SdkkWUFnZlAurLR8XArccoE%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-6">侧边栏展示</h5>
<blockquote>
<p>支持claude code + codex 多cli数据共同展示</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79209c020a4646e694c680e832bc3d2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=%2Fg9PkLAb06JrJzxT3vjnhm5oWIE%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-7">终端展示</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/304d9c7d34cc49e29ca1578418f392b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=EWwAc4%2BchrQmw0Mccj995MNLkDk%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-8">支持多平台</h5>
<p>支持Mac 和 window 多平台</p>
<hr/>
<h3 data-id="heading-9">下载安装体验</h3>
<p>功能太多了，就不赘述了，大家可以下载之后自行探索</p>
<p>下载地址（纯开源，无商业，放心食用）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.codemoss.ai%2Fdownload" target="_blank" title="https://www.codemoss.ai/download" ref="nofollow noopener noreferrer">www.codemoss.ai/download</a></p>
<hr/>
<h3 data-id="heading-10">未来迭代</h3>
<p>目前虽然能用，但是细节打磨的还不满意，我至少会每天迭代一个版本，先迭代100个版本，欢迎大家使用提出问题</p>
<p>开源地址（感谢你的Star和推荐，这将让更多人用到）</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhukunpenglinyutong%2Fcodemoss" target="_blank" title="https://github.com/zhukunpenglinyutong/codemoss" ref="nofollow noopener noreferrer">github.com/zhukunpengl…</a></p>
<blockquote>
<p>再次声明：本项目完全开源，0商业，使用过程全程无广，请放心食用</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[5个实用Python小脚本，新手也能轻松实现（附完整代码）]]></title>    <link>https://juejin.cn/post/7603959423129042944</link>    <guid>https://juejin.cn/post/7603959423129042944</guid>    <pubDate>2026-02-09T03:16:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603959423129042944" data-draft-id="7603959423129026560" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="5个实用Python小脚本，新手也能轻松实现（附完整代码）"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-09T03:16:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="躺平大鹅"/> <meta itemprop="url" content="https://juejin.cn/user/2455634286221657"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            5个实用Python小脚本，新手也能轻松实现（附完整代码）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2455634286221657/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    躺平大鹅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:16:44.000Z" title="Mon Feb 09 2026 03:16:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>对于Python新手来说，学习语法的最终目的是“解决实际问题”，而简单的小脚本既能巩固基础语法，又能带来成就感，同时还能用到日常工作和学习中，一举三得。</p>
<p>今天分享5个实用的Python小脚本，覆盖文件处理、数据统计、日常工具等场景，每篇脚本都有完整代码和详细注释，新手复制就能运行，还能根据自己的需求修改优化，快速提升编程能力～</p>
<h3 data-id="heading-0">脚本一：文件批量重命名（批量修改文件名，高效便捷）</h3>
<p>适用场景：批量修改文件夹中的文件名称（比如批量修改图片、文档、代码文件的名称），避免手动逐个修改，节省时间。</p>
<p>核心知识点：os模块（文件操作）、for循环，掌握os.listdir()、os.rename()的用法。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os  <span class="hljs-comment"># 导入os模块，用于操作文件和文件夹</span>

<span class="hljs-comment"># 1. 定义要批量重命名的文件夹路径（替换成你的文件夹路径，注意路径中的反斜杠用//或/）</span>
folder_path = <span class="hljs-string">"D://test//images"</span>

<span class="hljs-comment"># 2. 获取文件夹中的所有文件（返回一个列表，包含所有文件名）</span>
file_list = os.listdir(folder_path)

<span class="hljs-comment"># 3. 循环遍历所有文件，逐个重命名</span>
<span class="hljs-keyword">for</span> index, file_name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(file_list):
    <span class="hljs-comment"># 跳过文件夹（只重命名文件，不处理子文件夹）</span>
    <span class="hljs-keyword">if</span> os.path.isfile(os.path.join(folder_path, file_name)):
        <span class="hljs-comment"># 分割文件名和后缀（比如"1.jpg"分割成["1", "jpg"]）</span>
        file_ext = os.path.splitext(file_name)[<span class="hljs-number">1</span>]
        <span class="hljs-comment"># 定义新的文件名（比如"image_01.jpg"、"image_02.jpg"，index从0开始，+1让序号从1开始）</span>
        new_file_name = <span class="hljs-string">f"image_<span class="hljs-subst">{index+<span class="hljs-number">1</span>:02d}</span><span class="hljs-subst">{file_ext}</span>"</span>
        <span class="hljs-comment"># 拼接旧文件路径和新文件路径</span>
        old_path = os.path.join(folder_path, file_name)
        new_path = os.path.join(folder_path, new_file_name)
        <span class="hljs-comment"># 执行重命名操作</span>
        os.rename(old_path, new_path)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"已修改：<span class="hljs-subst">{file_name}</span> → <span class="hljs-subst">{new_file_name}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"批量重命名完成！"</span>)
    
</code></pre>
<p>💡 使用说明：替换folder_path为自己的文件夹路径，运行脚本，即可将文件夹中的文件批量命名为“image_01.后缀”“image_02.后缀”，序号自动递增。</p>
<h3 data-id="heading-1">脚本二：简单文本统计工具（统计字数、行数、空格数）</h3>
<p>适用场景：统计文本文件（.txt、.md等）的字数、行数、空格数，比如统计论文字数、笔记字数，无需手动计数。</p>
<p>核心知识点：文件读写（open()函数）、字符串操作、for循环。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 1. 定义要统计的文本文件路径（替换成你的文件路径）</span>
file_path = <span class="hljs-string">"D://test//note.txt"</span>

<span class="hljs-comment"># 2. 初始化统计变量</span>
line_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 行数</span>
char_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 总字符数（包含空格、标点）</span>
space_count = <span class="hljs-number">0</span> <span class="hljs-comment"># 空格数</span>
word_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 单词数（以空格分隔）</span>

<span class="hljs-comment"># 3. 打开文件，读取内容（encoding="utf-8"避免中文乱码）</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"r"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-comment"># 逐行读取文件内容</span>
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
        line_count += <span class="hljs-number">1</span>  <span class="hljs-comment"># 每读一行，行数+1</span>
        space_count += line.count(<span class="hljs-string">" "</span>)  <span class="hljs-comment"># 统计当前行的空格数，累加到总空格数</span>
        char_count += <span class="hljs-built_in">len</span>(line.replace(<span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>))  <span class="hljs-comment"># 统计当前行的字符数（去掉换行符）</span>
        word_count += <span class="hljs-built_in">len</span>(line.split())  <span class="hljs-comment"># 统计当前行的单词数（以空格分隔）</span>

<span class="hljs-comment"># 4. 输出统计结果</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"文本文件统计结果："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总行数：<span class="hljs-subst">{line_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总字符数（不含换行符）：<span class="hljs-subst">{char_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总空格数：<span class="hljs-subst">{space_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总单词数（以空格分隔）：<span class="hljs-subst">{word_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
    
</code></pre>
<p>💡 使用说明：替换file_path为自己的文本文件路径，运行脚本，即可快速得到文本的各项统计数据，支持中文文本。</p>
<h3 data-id="heading-2">脚本三：随机密码生成器（生成安全、复杂的密码）</h3>
<p>适用场景：生成随机密码（包含大小写字母、数字、特殊符号），用于注册账号、登录密码，比手动设置的密码更安全。</p>
<p>核心知识点：random模块（随机生成）、字符串拼接、for循环。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> random  <span class="hljs-comment"># 导入random模块，用于生成随机数</span>
<span class="hljs-keyword">import</span> string  <span class="hljs-comment"># 导入string模块，获取大小写字母、数字、特殊符号</span>

<span class="hljs-comment"># 1. 定义密码包含的字符集（可根据需求修改，比如去掉特殊符号）</span>
<span class="hljs-comment"># 大小写字母 + 数字 + 特殊符号（!@#$%^&amp;*()_+-=）</span>
chars = string.ascii_letters + string.digits + <span class="hljs-string">"!@#$%^&amp;*()_+-="</span>

<span class="hljs-comment"># 2. 定义密码长度（可自定义，比如8位、12位、16位，越长越安全）</span>
password_length = <span class="hljs-number">12</span>

<span class="hljs-comment"># 3. 生成随机密码（从chars中随机选择password_length个字符，拼接成字符串）</span>
password = <span class="hljs-string">""</span>.join(random.choice(chars) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(password_length))

<span class="hljs-comment"># 4. 输出生成的密码</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"生成的随机密码：<span class="hljs-subst">{password}</span>"</span>)
    
</code></pre>
<p>💡 拓展优化：新手可以修改password_length，生成不同长度的密码；也可以修改chars，去掉不需要的字符（比如不需要特殊符号，就删除chars中的特殊符号部分）。</p>
<h3 data-id="heading-3">脚本四：批量提取文本中的邮箱地址</h3>
<p>适用场景：从大量文本中，批量提取所有邮箱地址（比如从文档、日志、网页源码中提取邮箱），避免手动查找，高效便捷。</p>
<p>核心知识点：re模块（正则表达式，用于匹配邮箱格式）、文件读写。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> re  <span class="hljs-comment"># 导入re模块，用于正则表达式匹配</span>

<span class="hljs-comment"># 1. 定义要提取邮箱的文本文件路径（替换成你的文件路径）</span>
file_path = <span class="hljs-string">"D://test//data.txt"</span>

<span class="hljs-comment"># 2. 定义邮箱正则表达式（匹配绝大多数邮箱格式，如xxx@xxx.com、xxx@xxx.cn）</span>
email_pattern = <span class="hljs-string">r"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+"</span>

<span class="hljs-comment"># 3. 读取文本文件内容</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"r"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
    text = f.read()  <span class="hljs-comment"># 读取整个文件的内容</span>

<span class="hljs-comment"># 4. 匹配文本中的所有邮箱地址，返回一个列表</span>
emails = re.findall(email_pattern, text)

<span class="hljs-comment"># 5. 输出提取结果</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"共提取到 <span class="hljs-subst">{<span class="hljs-built_in">len</span>(emails)}</span> 个邮箱地址："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span>*<span class="hljs-number">50</span>)
<span class="hljs-keyword">for</span> email <span class="hljs-keyword">in</span> emails:
    <span class="hljs-built_in">print</span>(email)
    
</code></pre>
<p>💡 使用说明：替换file_path为自己的文本文件路径，运行脚本，即可提取文本中所有符合格式的邮箱地址，适合批量处理大量文本。</p>
<h3 data-id="heading-4">脚本五：简易天气预报查询（输入城市，查询实时天气）</h3>
<p>适用场景：输入城市名称，查询该城市的实时天气（温度、天气状况、风力等），无需打开浏览器，直接运行脚本即可查询。</p>
<p>核心知识点：requests模块（发送网络请求）、JSON数据解析，新手需要先安装requests模块（命令：pip install requests）。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests  <span class="hljs-comment"># 导入requests模块，用于发送网络请求</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_weather</span>(<span class="hljs-params">city</span>):
    <span class="hljs-comment"># 免费天气接口（无需注册，直接使用，返回JSON格式数据）</span>
    url = <span class="hljs-string">f"https://v0.yiketianqi.com/api?unescape=1&amp;version=v61&amp;appid=79334739&amp;appsecret=5S8IYq6Q&amp;city=<span class="hljs-subst">{city}</span>"</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 发送GET请求，获取天气数据</span>
        response = requests.get(url)
        response.raise_for_status()  <span class="hljs-comment"># 若请求失败，抛出异常</span>
        weather_data = response.json()  <span class="hljs-comment"># 解析JSON数据，转为字典</span>
        
        <span class="hljs-comment"># 提取需要的天气信息</span>
        city_name = weather_data[<span class="hljs-string">"city"</span>]  <span class="hljs-comment"># 城市名称</span>
        temp = weather_data[<span class="hljs-string">"tem"</span>]        <span class="hljs-comment"># 当前温度</span>
        weather = weather_data[<span class="hljs-string">"wea"</span>]     <span class="hljs-comment"># 天气状况（如晴、阴、雨）</span>
        wind = weather_data[<span class="hljs-string">"win"</span>]        <span class="hljs-comment"># 风力</span>
        humidity = weather_data[<span class="hljs-string">"humidity"</span>]<span class="hljs-comment"># 湿度</span>
        
        <span class="hljs-comment"># 输出天气信息</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"【<span class="hljs-subst">{city_name}</span> 实时天气预报】"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"当前温度：<span class="hljs-subst">{temp}</span>℃"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"天气状况：<span class="hljs-subst">{weather}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"风力：<span class="hljs-subst">{wind}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"湿度：<span class="hljs-subst">{humidity}</span>%"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"查询失败！原因：<span class="hljs-subst">{<span class="hljs-built_in">str</span>(e)}</span>"</span>)

<span class="hljs-comment"># 主程序</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 输入要查询的城市名称</span>
    city = <span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入要查询天气的城市（如北京、上海）："</span>)
    <span class="hljs-comment"># 调用函数，查询天气</span>
    get_weather(city)
    
</code></pre>
<p>💡 使用说明：</p>
<ol>
<li>
<p>先打开终端，输入命令 <code>pip install requests</code>，安装requests模块；</p>
</li>
<li>
<p>运行脚本，输入城市名称（如“北京”“广州”），即可查询该城市的实时天气。</p>
</li>
</ol>
<h3 data-id="heading-5">最后</h3>
<p>以上5个小脚本，都是日常能用得上的实用工具，同时覆盖了Python的核心基础知识点，新手可以先复制运行，理解每一行代码的含义，再尝试修改优化，比如给文件重命名脚本添加自定义前缀、给密码生成器添加密码强度检测等。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026版Java面试八股文总结（春招+秋招+社招），建议收藏。]]></title>    <link>https://juejin.cn/post/7604012106155049006</link>    <guid>https://juejin.cn/post/7604012106155049006</guid>    <pubDate>2026-02-09T05:46:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604012106155049006" data-draft-id="7604344066579939379" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026版Java面试八股文总结（春招+秋招+社招），建议收藏。"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-09T05:46:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java编程爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/819554264300154"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026版Java面试八股文总结（春招+秋招+社招），建议收藏。
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/819554264300154/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java编程爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T05:46:59.000Z" title="Mon Feb 09 2026 05:46:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>今年的行情，让招聘面试变得雪上加霜。已经有不少大厂，如腾讯、字节跳动的招聘名额明显减少，面试门槛却一再拔高，如果不用心准备，很可能就被面试官怼得哑口无言，甚至失去了难得的机会。</p>
<p>现如今，情势依然严峻，未来充满着不定性，想要跳槽涨薪的小伙伴，<strong>在面试前更是要做好充足的准备</strong>！</p>
<p>如果你<strong>参加过一些大厂面试，肯定会遇到一些这样</strong>的问题：</p>
<ul>
<li><strong>应届生</strong>：你该如何准备简历，面试项目和面试说辞？<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3DSpring%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=Spring&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Spring</a> 底层逻辑是什么？</li>
<li><strong>1-3 年经验的程序员</strong>：面试中你该讲哪些值钱的技术？如何用这些值钱的技术最大程度展示自己的技能？分布式组件底层逻辑是什么？</li>
<li><strong>3-5 年经验的程序员</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3Dk8s%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=k8s&amp;zhida_source=entity" ref="nofollow noopener noreferrer">k8s</a> 怎么搭建实践？</li>
</ul>
<p>是不是看上去很难，是不是和自己准备的“题库”中的问题不一样？不知道从何处下手？</p>
<p>所以，要想在这个<strong>金三银四拿下心仪的Offer</strong>，咱就一定要做好准备，把那些必考点、套路都给吃透了！</p>
<p>今天为大家整理了Java工程师高级面试题及一些大厂Java开发面试宝典，面试经验技巧等，应届生，实习生，企业工作过的，都可参考学习！</p>
<h2 data-id="heading-0">Java基础—基础知识</h2>
<p><strong>一、八种基本数据类型的大小，以及他们的封装类。</strong><br/>
byte(Byte) 1 ，short(Short) 2 ,int(Integer) 4 ,long(Long) 8 ,float(Float) 4 ,double(Double)8,boolean(Boolean),char(Character)2</p>
<p><strong>二、Switch能否用string做参数？</strong><br/>
switch语句中的变量类型可以使byte，short，int，char。从jdk1.7后可以使用String类型，是通过switch中的String.hashcode将String转换成int进行判断的。</p>
<p><strong>三、equals与==的区别。</strong><br/>
==操作符是用来比较两个变量的值是否相等，即就是比较变量在内存中的存储地址是否相同，equals（）方法时String类从Object类中继承的，被用来检测两个对象的内容是否相同。</p>
<p><strong>四、String s=new String(‘xyz’);创建了几个object对象?</strong><br/>
会创建一个String类型的变量s。在类加载到此处之前没有出现“xyz”字面量的话，加载此处会创建一个对应“xyz”的String常量对象。在符合规范的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3DJVM%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=JVM&amp;zhida_source=entity" ref="nofollow noopener noreferrer">JVM</a>上，执行到此处new关键字会创建一个String对象。</p>
<blockquote>
<p>**这里也整理了Java架构学习资料，学习技术内容包含有：Spring，Dubbo，MyBatis, RPC,源码分析，高并发、高性能、分布式,性能优化，微服务 高级架构开发等等。有需要的可以直接扫一扫获取</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a0cccad521ae4c9e95692198613614b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220819&amp;x-signature=nR9y9IG5QD2cUsWLBpCVsq5LY6I%3D" alt="736abc1217fd502b3f31018e5d5eaa2.jpg" loading="lazy"/></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d500c9fc4f04ba6b1beaa431bdcfba3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220819&amp;x-signature=Sk204espNAGqTCI%2Fod5fHZQ15C0%3D" alt="" loading="lazy"/></p>
<p><strong>五、 Object有哪些公用方法？</strong><br/>
1、clone()创建斌返回此对象的副本<br/>
2、equals()判断<br/>
3、getclass（）返回object的运行类<br/>
4、hashcode（）返回对象的哈希码值<br/>
5、notify（）唤醒正在等待对象监听器的单个进程<br/>
6、notifyAll（）唤醒正在等待对象监听器的所有进程<br/>
7、wait（）导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。<br/>
8、toString（）返回此对象的字符串表示形式<br/>
9、finalize（）当垃圾收集确定不需要该对象时，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%259E%2583%25E5%259C%25BE%25E5%259B%259E%25E6%2594%25B6%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">垃圾回收器</a>调用该方法</p>
<p><strong>六、Java的四种引用，强弱软虚，用到的场景。</strong><br/>
强引用：垃圾回收器不会回收<br/>
软引用：如果内存空间足够，垃圾回收器就不会进行回收，如果内存空间不足，垃圾回收器就会进行回收<br/>
弱引用：一旦发现了只有弱引用的对象，垃圾回收器就会进行回收。<br/>
虚引用：如果发现该对象还具有虚引用，就会在回收该对象之前，吧这个虚引用加入到与之关联的引用队列中。</p>
<p><strong>七、静态变量和实例变量的区别。</strong><br/>
静态变量前要加上关键字static，实例变量则不会。<br/>
实例变量是属于某个对象的属性，必须创建了实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。静态变量不属于任何的实例对象，而是属于类，也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。总之就是，静态变量不需要创建任何的对象就可以直接使用，而实例变量需要先创建实例对象才能被使用。</p>
<p><strong>八、 Overload和Override的区别：</strong><br/>
重载Overload表示的是同一个类中可以有多个相同名称的方法，但这些方法的参数列表不同，即就是参数参数或参数类型不同。重载时返回值当然可以不一样，但是如果参数列表完全一致时，不能通过返回类型不一致而实现重载，这是不可以的。<br/>
重写Override表示子类中的方法可以与父类中的方法名称和参数完全相同，通过子类创建的对象来调用这个方法时，将调用子类中定义的方法，即就是子类中的该方法将父类的该方法覆盖了。子类覆盖父类方法时只能抛比父类更少或者更小的异常。重写的方法其返回必须和被覆盖的方法返回一致。</p>
<p><strong>九、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%258A%25BD%25E8%25B1%25A1%25E7%25B1%25BB%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;zhida_source=entity" ref="nofollow noopener noreferrer">抽象类</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%258E%25A5%25E5%258F%25A3%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E6%8E%A5%E5%8F%A3&amp;zhida_source=entity" ref="nofollow noopener noreferrer">接口</a>的区别。</strong><br/>
抽象类可以有默认的方法进行实现，可以有构造器，可以有main方法进行运行，可以直接在该类中添加实现的方法接口没有默认的方法进行实现，没有构造器，不可以使用main方法进行运行，在接口中添加方法时需要在具体实现的类中添加方法。</p>
<p><strong>十、String、StringBuffer与StringBuilder的区别。</strong><br/>
String表示内容不可修改的字符串，StringBuffer表示内容可以修改的字符串，String覆盖了equals（）方法和hashcode（）方法，而StringBuffer没有覆盖两个方法，，所以StringBuffer对象存储到java集合类中时会出现问题。<br/>
StringBulider也表示内容可以修改的字符串，但是其线程是不安全的，运行效率高。</p>
<p><strong>十一、 Java面向对象的特征与含义。</strong><br/>
封装、继承、抽象、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25A4%259A%25E6%2580%2581%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%A4%9A%E6%80%81&amp;zhida_source=entity" ref="nofollow noopener noreferrer">多态</a><br/>
1、封装：封装的目的在于实现程序的“高内聚，低耦合”，防止程序相互依赖而带来的变动影响。封装是保证是把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和他操作的数据放在同一个类中。<br/>
2、抽象：抽象就是找出事物的相似和共性，然后将这些事物归为同一类，这个类只考虑这些事物的相似和共性，忽略和当前主题不相关的因素。<br/>
3、继承：子类继承父类的内容作为自己的内容，可以加入新的内容或者是修改父类的内容而更加适合特殊的需要。提高了额程序的可重用性和可扩张性。<br/>
4、多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p><strong>十二、java多态的实现</strong><br/>
接口实现，继承父类进行方法重写，<br/>
同一个类中进行方法重载。</p>
<p><strong>十三、error和exception区别</strong><br/>
error表示有可能恢复但比较困难的的一种严重问题，程序是不能进行处理的exception表示一种设计或者实现问题。</p>
<p><strong>十四、运行时异常和一般异常的区别</strong><br/>
异常表示程序运行过程中可能出现的非正常状态。运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见的运行错误。java编译器要求方法必须声明抛出可能出现的非运行时异常，但是并不要求必须声明抛出未被捕获的异常</p>
<p><strong>十五、Java中的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25BC%2582%25E5%25B8%25B8%25E5%25A4%2584%25E7%2590%2586%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">异常处理机制</a>和简单原理和应用</strong><br/>
JAVA程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发 NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw关键字引发异常。所有的异常都是java.lang.Thowable的子类。</p>
<p><strong>十六、Java语言如何进行异常处理，throws，throw，try catch finally代表什么意义，try块中可以抛出异常吗?</strong><br/>
Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个<br/>
方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br/>
用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。<br/>
throw语句用来明确地抛出一个”异常”。<br/>
throws用来标明一个成员函数可能抛出的各种”异常”。<br/>
Finally为确保一段代码不管发生什么”异常”都被执行一段代码。<br/>
可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常”的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。</p>
<p><strong>十七、 try catch finally，try里有return，finally还执行么？</strong><br/>
1、finally语句总会执行<br/>
2、如果try、catch中有return语句，finally中没有return，那么在finally中修改除包装类型和静态变量、全局变量以外的数据都不会对try、catch中返回的变量有任何的影响（包装类型、静态变量会改变、全局变量）<br/>
3、尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生。<br/>
4、finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略</p>
<p><strong>十八、 Java中final、finally和finalize的区别</strong><br/>
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br/>
内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……<br/>
finally是异常处理语句结构的一部分，表示总是执行。<br/>
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。</p>
<p><strong>十九、 常见的运行时异常</strong><br/>
系统异常是RuntimeException的子类，常见的系统异常有：<br/>
ArrayIndexOutOfBoundsException - 数组越界访问<br/>
ClassCastException - 类型转换异常<br/>
NullPointerException - 试图访问一空对象的变量、方法或空数组的元素<br/>
IllegalArgumentException - 方法的参数无效<br/>
NoClassDefFoundException - JAVA运行时系统找不到所引用的类</p>
<p><strong>二十、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3DCollection%25E6%25A1%2586%25E6%259E%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=Collection%E6%A1%86%E6%9E%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Collection框架</a>的结构</strong><br/>
集合框架(Collection Framework)泛指java.util包的若干个类和接口.如Collection,List,ArrayList,LinkedList,Vector(自动增长数组),HashSet,HashMap等。<br/>
集合框架中的类主要封装的是典型的数据结构,如动态数组,链表,堆栈,集合,哈希表等.<br/>
集合框架类似编程中经常用到的工具类,使得编码这专注于业务层的实现,不需要从底层实现相关细节—“数据结构的封装”和”典型算法的实现”。</p>
<p><strong>二十一、Collection包结构</strong><br/>
Collection是集合类的上级接口，是单列集合。继承他的接口主要有Set 和List.<br/>
Set接口的子接口有：HashSet，TreeSet<br/>
List接口的子接口有：Arraylist，LinkedList，Vector</p>
<p><strong>二十二、Collection与Collections的区别。</strong><br/>
Collection是集合类的上级接口，继承他的接口有Set和List<br/>
Collections是针对集合类的一个帮助类，它提供一系列的静态方法实现集合的搜索，排序，线程安全等操作。</p>
<p><strong>二十三、 Colection框架中实现比较要实现什么接口？</strong><br/>
comparable：只包含compareTo（）方法<br/>
comparator：compare（）和equals（）</p>
<p><strong>二十四、Map、Set、List、Queue、Stack的特点与用法。</strong><br/>
1、Map是以键值对的形式进行存储的，其中key是唯一不可重复的，value的可以重复，当插入的值是key相同，后加入的会将已有的覆盖。他有几个具体的实现类，包括Treemap和HashMap，TreeMap是有序的，HashMap是无序的。<br/>
2、List 有序，可重复<br/>
|–ArrayList<br/>
底层数据结构是数组，查询快，增删慢，线程不安全，效率高<br/>
|–Vector<br/>
底层数据结构是数组，查询快，增删慢，线程不安全，效率高<br/>
|–LinkedList<br/>
底层数据结构是链表，查询慢，增删块，线程安全，效率低<br/>
3、Set 无序，唯一<br/>
|–HashSet<br/>
底层数据结构是哈希表<br/>
如何保证元素的唯一性：<br/>
依赖两个方法，hashCode（）和equals（）<br/>
|–LinkedHashSet<br/>
底层数据结构是链表和哈希表，由链表保证元素有序，由哈希表保证元素唯一<br/>
|–TreeSet底层数据结构是红黑树，<br/>
如何保证元素的排序：<br/>
自然排序：让元素所属的类实现Comparable接口<br/>
比较器排序：让集合接收一个Comparator的实现类对象<br/>
如何保证元素的唯一性：<br/>
根据比较的返回值是否是0来决定的<br/>
4、Query队列遵循先进先出的原则，不允许插入null值，其中提供了相应的进队和出队的方法，建议使用offer（）方法来添加元素，使用poll（）方法删除元素<br/>
5、Stack遵从后进先出的原则，继承自Vector。他通过5个操作对Vector类进行扩展，它提供了push和pop操作，以及去堆栈顶点的peek（）方法，测试堆栈是否为空的empty方法<br/>
6、使用方法：<br/>
如果涉及到堆栈，队列等操作，建议使用List<br/>
对于快速插入和删除元素建议使用LinkedList<br/>
需要快速随机访问元素建议使用ArrayList</p>
<p><strong>二十五、 Set里面的元素不能重复，用什么方法区分重复与否？</strong><br/>
Set里的元素是唯一不能重复的，元素是否重复使用equals（）方法进行判断。<br/>
equals（）方法和==方法决定引用值是否指向同一对象equals（）在类中被覆盖，为的是两个分离的对象的内容和类型相匹配的话，返回真值。</p>
<p><strong>二十六、HashMap和Hashtable的区别。</strong><br/>
1、Hashtable是基于Dictionary类的，HashMap是Map接口的一个实现类<br/>
2、Hashtable是线程安全的，即是同步的；HashMap线程不是安全的，不是同步的。<br/>
3、HashMap可以将空值作为key或value</p>
<p><strong>二十七、 HashMap、LinkedHashMap、TreeMap的区别。</strong><br/>
1、HashMap是根据键的hashcode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，取得的数据完全是随机的<br/>
2、LinkedHashMap保存了记录的插入顺序，在使用Iterator进行遍历的时候，先得到的肯定是先插入的数据，可以在构造时带参数，按照应用次数来进行排序<br/>
3、TreeMap实现SortMap接口，能够把它保存的记录根据键排序。默认的是升序排序，也可以指定排序的比较器，进行遍历的时候得到的是排序过的记录。</p>
<p><strong>二十八、HashMap、LinkedHashMap、ConcurrentHashMap、ArrayList、LinkedList的底层实现。</strong><br/>
1、HashMap是java数据结构中两大结构数组和链表的组合。HashMap底层数组，数组中的每一项又是一个链表。程序会先根据key的hashcode（）方法返回值决定该Entry在数组中的<br/>
存储位置，如果该位置上没有元素，就会将元素放置在此位置上，如果两个Entry的key相同，会调用equals，返回值是true则覆盖原来的value值，返回false则会形成Entry链，位于头部。<br/>
2、ArrrayList的底层实现是数组，在执行add操作时，会先检查数组 大小是否可以容纳新的元素，如果不够就会进行扩容。然后会将原来的数据拷贝到新的数组中。<br/>
3、LinkedList底层是一个链表，其实现增删改查和数据结构中的操作完全相同，而且插入是有序的。<br/>
4、LinkedHashMap的底层结构式是双链表，其他的逻辑处理与HashMap一致，同样没有锁保护，多线程使用时存在风险。<br/>
5、ConcurrentHashMap是segment数组结构和HashEntry数组结构组成的，segment在ConcurrentHashMap中充当锁的角色，HashEntry用于存储键值对数据。segment的结构是数组和链表，一个segment中有一个HashEntry，每个HashEntry是一个链表结构的元素。对HashEntry中的数据进行修改时，需要先获得它所对应的segment锁。每个ConcurrentHashMap默认有16个segment。</p>
<p><strong>二十九、迭代器Iterator</strong><br/>
Iterator提供了统一遍历操作集合元素的统一接口，Collection接口实现Iterator接口。每个集合都通过实现Iterator接口中的iterator（）方法返回实例，然后对元素进行迭代操作，但是在迭代元素的时候不能使用集合的方法删除元素，否则会抛出异常，可以使用Iterator接口中的remove（）方法进行删除。</p>
<p><strong>三十、 快速失败（fail-fast）和安全失败（fail-safe）的区别。</strong><br/>
Iterator的安全失败是基于对底层集合做拷贝，因此它不受源集合修改的影响。util包下的所有集合类都是快速失败的，util.concurren包下面的所有类都是安全失败的。<br/>
Java基础—集合框架/<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%25B3%259B%25E5%259E%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E6%B3%9B%E5%9E%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">泛型</a>/<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25AE%25B9%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%AE%B9%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">容器</a><br/>
<strong>概念</strong><br/>
一、容器（Container）Spring 提供容器功能，容器可以管理对象的生命周期、对象与对象之间的依赖关系，您可以使用一个配置文件（通常是 XML），在上面定义好对象的名称、如何产生（Prototype 方式或 Singleton 方式）、哪个对象产生之后必须设定成为某个对象的属性等，在启动容器之后，所有的对象都可以直接取用，不用编写任何一行程序代码来产生对象，或是建立对象与对象之间的依赖关系。换个更直白点的说明方式：容器是一个 Java 所编写的程序，原先必须自行编写程序以管理对象关系，现在容器都会自动帮您作好。常用容器：WebSphere,WebLogic,Resin,Tomcat。<br/>
<strong>容器类</strong><br/>
容器类 其实就是一种用来存储数据的数据结构，在 JAVA 中容器可分为即 “集合”（Set）、“列表”(List)、“映射”(Map)。至于，为什么需要容器，总的来说，主要是在以数组作为数据的存储结构中，其长度难以扩充，同时数组中元素类型必须相同。而容器可以弥补数组的这两个缺陷。<br/>
Java 容器类包含 List、ArrayList、Vector 及 map、HashTable、HashMap。<br/>
ArrayList 和 HashMap 是异步的，Vector 和 HashTable 是同步的，所以 Vector 和 HashTable 是线程安全的，而 ArrayList 和 HashMap 并不是线程安全的。因为同步需要花费机器时间，所以 Vector 和 HashTable 的执行效率要低于 ArrayList 和 HashMap。</p>
<h2 data-id="heading-1"><strong>二、集合框架的说明</strong></h2>
<p>所有集合类都位于 java.util 包下。Java 的集合类主要由两个接口派生而出：Collection 和 Map，Collection 和 Map 是 Java 集合框架的根接口，这两个接口又包含了一些子接口或实现类。<br/>
1.Set、List 和 Map 可以看做集合的三大类：<br/>
2.List 集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。<br/>
Set 集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。<br/>
3.Map 集合中保存 Key-value 对形式的元素，访问时只能根据每项元素的 key 来访问其 value。</p>
<h2 data-id="heading-2"><strong>三、集合框架详细说明</strong></h2>
<p>1、Collection 是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection 包含了 List 和 Set 两大分支。</p>
<ul>
<li>List 是一个 有序的队列，每一个元素都有它的索引。第一个元素的索引值是 0。List 的实现类有 LinkedList, ArrayList, Vector, Stack。</li>
<li>Set 是一个不允许有重复元素的集合。Set 的实现类有 HastSet 和 TreeSet。 HashSet 依赖于 HashMap，它实际上是通过 HashMap 实现的；TreeSet 依赖于 TreeMap，它实际上是通过 TreeMap 实现的。</li>
</ul>
<p>2、Map 是一个映射接口，即 key-value 键值对。Map 中的每一个元素包含 “一个 key” 和 “key 对应的 value”。AbstractMap 是个抽象类，它实现了 Map 接口中的大部分 API。而 HashMap，TreeMap，WeakHashMap 都是继承于 AbstractMap。Hashtable 虽然继承于 Dictionary，但它实现了 Map 接口。</p>
<p>3、接下来，再看 Iterator。它是遍历集合的工具，即我们通常通过 Iterator 迭代器来遍历集合。我们说 Collection 依赖于Iterator，是因为 Collection 的实现类都要实现 iterator () 函数，返回一个 Iterator 对象。ListIterator 是专门为遍历 List 而存在的。</p>
<p>4、再看 Enumeration，它是 JDK 1.0 引入的抽象类。作用和 Iterator 一样，也是遍历集合；但是 Enumeration 的功能要比 Iterator 少。在上面的框图中， Enumeration 只能在 Hashtable, Vector, Stack 中使用。</p>
<p>5、最后，看 Arrays 和 Collections。它们是操作数组、集合的两个工具类。</p>
<h2 data-id="heading-3">Java基础—多线程</h2>
<p>一、多线程基本概念<br/>
二、线程相关的常用方法<br/>
三、继承Thread类<br/>
四、实现Runnable 接口<br/>
五、Java 分为两种线程：用户线程和守护线程<br/>
六、用户线程就是前台线程，守护线程就是后台线程<br/>
七、什么是可重入锁？<br/>
八、Lock 与 synchronized 的不同<br/>
九、synchronized的使用<br/>
十、atomic 包底层实现原理<br/>
十一、Lock底层原理<br/>
十二、多线程不安全的底层原因以及两种加锁方式的区别<br/>
十三、Java多线程中 的各种锁<br/>
十四、Java多线程中 的各种锁（补充）<br/>
十五、阻塞队列BlockingQueue<br/>
十六、Java线程池、Java线程池进阶、Java中的ThreadLocal</p>
<h2 data-id="heading-4">Java基础—框架基础：注解/反射/流行框架</h2>
<p>一、优化 Hibernate 所鼓励的7大措施<br/>
二、序列化和反序列化<br/>
三、Java中池的概念<br/>
四、Java反射<br/>
五、Spring的IOC和AOP概念和实现原理<br/>
六、 仿照 Spring 实现简单的 IOC<br/>
七、仿照 Spring 实现简单的 AOP<br/>
八、Spring bean 的生命流程<br/>
九、仿写Spring 进阶之 AOP和IOC协作</p>
<h2 data-id="heading-5">Java基础—面向对象：继承/多态/封装</h2>
<p>一、重写与重载<br/>
二、单继承和多继承<br/>
三、多态<br/>
四、super和this关键字</p>
<h2 data-id="heading-6">Java基础—设计模式</h2>
<p>一、单例模式之懒汉式和饿汉式<br/>
二、设计模式之观察者模式<br/>
三、设计模式之工厂模式<br/>
四、设计模式之代理模式</p>
<h2 data-id="heading-7">Java基础—JVM/类加载</h2>
<p>一、初始化执行代码顺序（包含static块和构造块）以及类方法和实例方法<br/>
二、JVM内存结构<br/>
三、JVM组成部分<br/>
四、类加载机制<br/>
五、类加载器<br/>
六、Java类加载器之间的关系<br/>
七、虚拟机中的对象<br/>
八、虚拟机 分配内存<br/>
九、Java中的引用类型<br/>
十、JVM如何判断是否回收对象<br/>
十一、垃圾回收算法<br/>
十二、JVM运行时数据区域<br/>
十三、JVM垃圾收集器<br/>
十四、JVM垃圾回收<br/>
十五、Java中的内存泄露和内存溢出</p>
<h2 data-id="heading-8">Java基础——I/O</h2>
<p>一、I/O 基本概念<br/>
二、I/O 模型 ——阻塞、非阻塞、多路复用、异步<br/>
三、JAVA中 BIO 与 NIO、AIO</p>
<h2 data-id="heading-9">网络编程和计网</h2>
<p>一、Java中的原码、反码和补码<br/>
二、forward 和 redirect<br/>
三、URL的组成<br/>
四、通信的基础——IP、DNS、MAC地址<br/>
五、关于ip地址的理解<br/>
六、GFW（中国防火长城）工作原理<br/>
七、OSI七层模型和 五层体系结构<br/>
八、TCP 三次握手和四次挥手协议<br/>
九、TCP协议 （可靠保证、TCP、UDP、拥塞、ARQ）<br/>
十、HTTP 和 HTTPS<br/>
十一、Http/1.0、Http/1.1、Http2<br/>
十二、Https 加密过程详解<br/>
十三、HTTP协议的补充（POST、GET请求方法、幂等性）<br/>
十四、网络攻击（XSS、CSRF）详解<br/>
十五、DDoS 攻击详解<br/>
十六、SQL注入攻击详解</p>
<h2 data-id="heading-10">数据库</h2>
<p>一、结果集 (ResultSet)全面解析<br/>
二、基本概念<br/>
三、索引<br/>
四、事务<br/>
五、存储引擎<br/>
六、数据库优化<br/>
七、数据库锁<br/>
八、主从复制和读写分离</p>
<h2 data-id="heading-11">操作系统</h2>
<p>一、线程进程部分<br/>
二、内存和中断<br/>
三、互斥和同步<br/>
四、Linux相关命令<br/>
五、Linux IO 模式及 select、poll、epoll 详解</p>
<h2 data-id="heading-12">数据结构</h2>
<p>一、链表、数组、字符、树篇<br/>
二、堆、栈、队列篇<br/>
三、B树、B+树、B*树<br/>
四、Java实现排序算法，比较时间复杂度<br/>
五、红黑树<br/>
六、数据结构之栈<br/>
七、搜索与回溯算法-Java实现<br/>
八、高效判断一个数，是不是素数</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python3基础：基础实战巩固，从“会用”到“活用”]]></title>    <link>https://juejin.cn/post/7604093823958614035</link>    <guid>https://juejin.cn/post/7604093823958614035</guid>    <pubDate>2026-02-09T04:34:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604093823958614035" data-draft-id="7604175912480800774" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python3基础：基础实战巩固，从“会用”到“活用”"/> <meta itemprop="keywords" content="后端,Python"/> <meta itemprop="datePublished" content="2026-02-09T04:34:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="怒放吧德德"/> <meta itemprop="url" content="https://juejin.cn/user/2502950820787672"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python3基础：基础实战巩固，从“会用”到“活用”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2502950820787672/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    怒放吧德德
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:34:30.000Z" title="Mon Feb 09 2026 04:34:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">第七阶段：基础实战巩固，从“会用”到“活用”</h2>
<blockquote>
<p>😄生命不息，写作不止</p>
<p>🔥 继续踏上学习之路，学之分享笔记</p>
<p>👊 总有一天我也能像各位大佬一样</p>
<p>🏆 <a href="https://juejin.cn/user/2502950820787672" target="_blank" title="https://juejin.cn/user/2502950820787672">博客首页</a>   <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Flyd-code%2F" target="_blank" title="https://www.cnblogs.com/lyd-code/" ref="nofollow noopener noreferrer">@怒放吧德德</a>  <a href="https://link.juejin.cn?target=https%3A%2F%2Flydandtry.github.io%2F" target="_blank" title="https://lydandtry.github.io/" ref="nofollow noopener noreferrer">To记录领地</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_43843951%3Ftype%3Dblog" target="_blank" title="https://blog.csdn.net/qq_43843951?type=blog" ref="nofollow noopener noreferrer">@一个有梦有戏的人</a></p>
<p>🌝分享学习心得，欢迎指正，大家一起学习成长！</p>
<p>🔥豆包AI</p>
</blockquote>
<p><em>转发请携带作者信息</em>  <strong>@怒放吧德德(掘金) @一个有梦有戏的人(CSDN)</strong></p>
<h3 data-id="heading-1">前言</h3>
<p>恭喜大家成功通关Python3基础学习第六阶段「进阶基础」！在第六阶段，我们掌握了模块与包、文件操作、异常处理、面向对象基础四大核心技能，终于跳出了“单纯记语法”的范畴，具备了编写模块化、健壮性代码的能力。</p>
<p>而第七阶段「基础实战巩固」，是Python基础学习中“承上启下”的关键一环——核心目标不是学习新的复杂语法，而是<strong>将前六阶段的所有知识点串联起来，通过实战场景落地应用</strong>，帮大家摆脱“看得懂、写不出”的困境，巩固基础、查漏补缺，同时掌握常用工具（内置函数、标准库）和基础并发/网络能力，为后续学习复杂项目、框架打下坚实的实战基础。</p>
<p>本阶段我们将聚焦四大实战方向，全程围绕“实战场景+可运行代码+避坑实战”展开，每个知识点都结合前阶段内容设计实战案例，跟着敲代码、练案例，既能巩固旧知识，又能掌握新工具，真正实现从“会用”到“活用”的跨越，稳步向“能独立编写简单项目的Python初学者”迈进～</p>
<h3 data-id="heading-2">1 常用内置函数：Python自带的“实用工具”，提升编码效率</h3>
<p>在前面的学习中，我们其实已经零散用到过一些内置函数（比如print()、input()），但Python自带了大量无需导入、直接可用的内置函数，它们就像“现成的工具”，能帮我们快速解决常见问题（比如计算长度、生成序列、筛选数据），避免重复编写代码。</p>
<p>本阶段重点掌握8个高频实用的内置函数，覆盖日常编码80%的场景，结合实战案例讲解，重点理解“什么时候用、怎么用”，而非死记硬背。</p>
<h4 data-id="heading-3">1.1 核心内置函数</h4>
<p>每个函数均搭配“语法解析+实战代码+场景说明”，代码可直接复制运行，贴合新手实战需求：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 1. len()：计算可迭代对象的长度（字符串、列表、字典、元组等）</span>
<span class="hljs-comment"># 实战场景：统计用户输入的字符数、列表中元素个数</span>
str1 = <span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入一段文字："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"输入文字的长度（含空格）：<span class="hljs-subst">{<span class="hljs-built_in">len</span>(str1)}</span>"</span>)

list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"Python"</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"列表的元素个数：<span class="hljs-subst">{<span class="hljs-built_in">len</span>(list1)}</span>"</span>)  <span class="hljs-comment"># 输出5（嵌套列表算1个元素）</span>

dict1 = {<span class="hljs-string">"name"</span>: <span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">18</span>, <span class="hljs-string">"gender"</span>: <span class="hljs-string">"男"</span>}
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"字典的键值对个数：<span class="hljs-subst">{<span class="hljs-built_in">len</span>(dict1)}</span>"</span>)  <span class="hljs-comment"># 输出3</span>

<span class="hljs-comment"># 2. range()：生成指定范围的整数序列（左闭右开）</span>
<span class="hljs-comment"># 实战场景：配合for循环实现固定次数的迭代（替代手动写列表）</span>
<span class="hljs-comment"># 语法：range(开始值, 结束值, 步长)，开始值默认0，步长默认1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"生成0-9的整数："</span>, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))  <span class="hljs-comment"># 输出[0,1,2,...,9]</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"生成1-10的整数："</span>, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)))  <span class="hljs-comment"># 输出[1,2,...,10]</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"生成1-10的奇数："</span>, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>)))  <span class="hljs-comment"># 步长2，输出[1,3,...,9]</span>

<span class="hljs-comment"># 实战：用range()循环打印1-5的平方（结合前阶段的循环、函数）</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{i}</span>的平方：<span class="hljs-subst">{i**<span class="hljs-number">2</span>}</span>"</span>)

<span class="hljs-comment"># 3. enumerate()：遍历可迭代对象时，同时获取索引和对应的值</span>
<span class="hljs-comment"># 实战场景：遍历列表/元组时，需要知道元素的位置（避免手动定义索引变量）</span>
<span class="hljs-comment"># 语法：enumerate(可迭代对象, start=起始索引)，start默认0</span>
fruits = [<span class="hljs-string">"苹果"</span>, <span class="hljs-string">"香蕉"</span>, <span class="hljs-string">"橙子"</span>, <span class="hljs-string">"葡萄"</span>]
<span class="hljs-comment"># 默认start=0，索引从0开始</span>
<span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"索引<span class="hljs-subst">{index}</span>：<span class="hljs-subst">{value}</span>"</span>)
<span class="hljs-comment"># start=1，索引从1开始（适合计数场景）</span>
<span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits, start=<span class="hljs-number">1</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"第<span class="hljs-subst">{index}</span>个水果：<span class="hljs-subst">{value}</span>"</span>)

<span class="hljs-comment"># 4. zip()：将多个可迭代对象（列表、元组等）“配对”，合并成一个迭代器</span>
<span class="hljs-comment"># 实战场景：批量处理多组关联数据（比如姓名和年龄、学号和成绩）</span>
names = [<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王五"</span>]
ages = [<span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>]
scores = [<span class="hljs-number">90</span>, <span class="hljs-number">85</span>, <span class="hljs-number">95</span>]

<span class="hljs-comment"># 配对多个列表，遍历获取关联数据</span>
<span class="hljs-keyword">for</span> name, age, score <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(names, ages, scores):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"姓名：<span class="hljs-subst">{name}</span>，年龄：<span class="hljs-subst">{age}</span>，成绩：<span class="hljs-subst">{score}</span>"</span>)

<span class="hljs-comment"># 补充：zip()返回的是迭代器，可转换为列表查看</span>
zip_result = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(names, ages))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"zip配对结果："</span>, zip_result)  <span class="hljs-comment"># 输出[('张三',18), ('李四',19), ('王五',20)]</span>

<span class="hljs-comment"># 5. sorted()：对可迭代对象进行排序，返回排序后的新列表（不改变原对象）</span>
<span class="hljs-comment"># 实战场景：对列表、元组、字典的值进行排序</span>
nums = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
sorted_nums = <span class="hljs-built_in">sorted</span>(nums)  <span class="hljs-comment"># 默认升序</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"升序排序："</span>, sorted_nums)  <span class="hljs-comment"># 输出[1,2,3,4,5]</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"原列表（未改变）："</span>, nums)  <span class="hljs-comment"># 输出[3,1,4,2,5]</span>

<span class="hljs-comment"># 降序排序，指定reverse=True</span>
sorted_nums_desc = <span class="hljs-built_in">sorted</span>(nums, reverse=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"降序排序："</span>, sorted_nums_desc)

<span class="hljs-comment"># 实战：对字典按值排序（结合前阶段的字典知识）</span>
score_dict = {<span class="hljs-string">"张三"</span>: <span class="hljs-number">90</span>, <span class="hljs-string">"李四"</span>: <span class="hljs-number">85</span>, <span class="hljs-string">"王五"</span>: <span class="hljs-number">95</span>}
<span class="hljs-comment"># 按成绩升序排序，返回包含元组的列表</span>
sorted_score = <span class="hljs-built_in">sorted</span>(score_dict.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">"按成绩升序排序："</span>, sorted_score)

<span class="hljs-comment"># 6. map()：对可迭代对象的每个元素，应用指定函数，返回迭代器</span>
<span class="hljs-comment"># 实战场景：批量处理数据（比如所有元素平方、转换数据类型）</span>
<span class="hljs-comment"># 示例1：将列表中所有整数转换为字符串</span>
nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
str_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"整数转字符串："</span>, str_nums)  <span class="hljs-comment"># 输出['1','2','3','4','5']</span>

<span class="hljs-comment"># 示例2：计算列表中所有元素的平方（结合lambda匿名函数）</span>
square_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"所有元素平方："</span>, square_nums)  <span class="hljs-comment"># 输出[1,4,9,16,25]</span>

<span class="hljs-comment"># 7. filter()：对可迭代对象的元素进行筛选，保留符合条件的元素</span>
<span class="hljs-comment"># 实战场景：筛选符合要求的数据（比如筛选偶数、筛选大于某个值的元素）</span>
<span class="hljs-comment"># 示例1：筛选列表中的偶数</span>
nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
even_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"筛选偶数："</span>, even_nums)  <span class="hljs-comment"># 输出[2,4,6]</span>

<span class="hljs-comment"># 示例2：筛选列表中大于3的元素</span>
greater_3 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x &gt; <span class="hljs-number">3</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"筛选大于3的元素："</span>, greater_3)  <span class="hljs-comment"># 输出[4,5,6]</span>

<span class="hljs-comment"># 8. abs()：返回数字的绝对值</span>
<span class="hljs-comment"># 实战场景：处理负数（比如计算距离、误差，绝对值避免负号影响）</span>
num1 = -<span class="hljs-number">5</span>
num2 = <span class="hljs-number">3.14</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"-5的绝对值：<span class="hljs-subst">{<span class="hljs-built_in">abs</span>(num1)}</span>"</span>)  <span class="hljs-comment"># 输出5</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"3.14的绝对值：<span class="hljs-subst">{<span class="hljs-built_in">abs</span>(num2)}</span>"</span>)  <span class="hljs-comment"># 输出3.14</span>
</code></pre>
<h4 data-id="heading-4">1.2 新手避坑指南</h4>
<ul>
<li>避坑1：len()计算嵌套列表时，嵌套的子列表算“1个元素”，不会递归计算子列表内部的长度；</li>
<li>避坑2：range()是“左闭右开”区间，比如range(1, 10)生成1-9的整数，不会包含10；步长为负数时，开始值要大于结束值（比如range(10, 0, -1)生成10-1）；</li>
<li>避坑3：enumerate()的start参数只是“修改索引的显示值”，不会改变元素本身的位置；</li>
<li>避坑4：zip()会以“最短的可迭代对象”为准配对，多余的元素会被舍弃（比如3个姓名、2个年龄，会只配对前2组）；且zip()返回的迭代器只能遍历一次，再次遍历会为空；</li>
<li>避坑5：sorted()会返回新列表，不会修改原对象；而列表自带的sort()方法会修改原列表，无返回值（新手易混淆两者）；</li>
<li>避坑6：map()和filter()返回的是迭代器，需转换为列表（list()）才能直观查看结果。</li>
</ul>
<h3 data-id="heading-5">2 简单标准库使用：活用Python自带“工具包”，高效编码</h3>
<p>在第六阶段，我们学习了模块与包的基础用法，而Python自带的“标准库”，就是一组官方编写的、无需额外安装的实用模块集合。它们覆盖了数学计算、随机数生成、时间处理等常见场景，熟练使用这些标准库，能大幅提升编码效率，避免重复造轮子。</p>
<p>本阶段重点掌握3个最常用的标准库（math、random、time），结合实战场景讲解核心用法，不深入复杂功能，聚焦“新手能快速上手、日常能用得上”的知识点。</p>
<h4 data-id="heading-6">2.1 math库：数学计算工具，解决基础数学问题</h4>
<p>math库提供了大量基础数学运算函数（如圆周率、三角函数、取整、开平方等），适合解决日常编程中的数学计算场景，核心用法如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> math  <span class="hljs-comment"># 导入math库（无需安装，直接导入）</span>

<span class="hljs-comment"># 1. 常用常量（实战常用）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"圆周率π："</span>, math.pi)  <span class="hljs-comment"># 输出3.141592653589793</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"自然常数e："</span>, math.e)  <span class="hljs-comment"># 输出2.718281828459045</span>

<span class="hljs-comment"># 2. 基础运算（实战重点）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"16的平方根："</span>, math.sqrt(<span class="hljs-number">16</span>))  <span class="hljs-comment"># 输出4.0（开平方）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"2的3次方："</span>, math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 输出8.0（幂运算，等同于2**3）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"绝对值："</span>, math.fabs(-<span class="hljs-number">5.2</span>))  <span class="hljs-comment"># 输出5.2（绝对值，比abs()更适合浮点数）</span>

<span class="hljs-comment"># 3. 取整函数（新手易混淆，重点区分）</span>
num = <span class="hljs-number">3.7</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向下取整（&lt;=3.7的最大整数）："</span>, math.floor(num))  <span class="hljs-comment"># 输出3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向上取整（&gt;=3.7的最小整数）："</span>, math.ceil(num))  <span class="hljs-comment"># 输出4</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"四舍五入（保留整数）："</span>, <span class="hljs-built_in">round</span>(num))  <span class="hljs-comment"># 输出4（round是内置函数，非math库）</span>

num2 = <span class="hljs-number">3.1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向下取整："</span>, math.floor(num2))  <span class="hljs-comment"># 输出3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向上取整："</span>, math.ceil(num2))  <span class="hljs-comment"># 输出4</span>

<span class="hljs-comment"># 4. 实战案例：计算圆的周长和面积（结合前阶段的函数知识）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_circle</span>(<span class="hljs-params">radius</span>):
    <span class="hljs-string">"""计算圆的周长和面积"""</span>
    <span class="hljs-keyword">if</span> radius&lt;= <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"半径必须为正数！"</span>)
        <span class="hljs-keyword">return</span>
    circumference = <span class="hljs-number">2</span> * math.pi * radius  <span class="hljs-comment"># 周长公式：2πr</span>
    area = math.pi * math.<span class="hljs-built_in">pow</span>(radius, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 面积公式：πr²</span>
    <span class="hljs-keyword">return</span> circumference, area

<span class="hljs-comment"># 调用函数，获取结果</span>
circum, area = calc_circle(<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"半径为3的圆：周长=<span class="hljs-subst">{<span class="hljs-built_in">round</span>(circum, <span class="hljs-number">2</span>)}</span>，面积=<span class="hljs-subst">{<span class="hljs-built_in">round</span>(area, <span class="hljs-number">2</span>)}</span>"</span>)  <span class="hljs-comment"># 保留2位小数</span>
</code></pre>
<h4 data-id="heading-7">2.2 random库：随机数工具，实现随机场景</h4>
<p>random库用于生成随机数、随机选择、随机打乱等操作，适合抽奖、验证码生成、随机分组等实战场景，核心用法如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> random  <span class="hljs-comment"># 导入random库</span>

<span class="hljs-comment"># 1. 生成随机浮点数（0.0 &lt;= 浮点数 &lt; 1.0）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机浮点数（0-1）："</span>, random.random())

<span class="hljs-comment"># 2. 生成随机整数（左闭右开，包含start和end）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机整数（1-10）："</span>, random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机整数（0-9，步长2）："</span>, random.randrange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 只生成偶数</span>

<span class="hljs-comment"># 3. 随机选择（实战常用）</span>
<span class="hljs-comment"># 从序列中随机选择1个元素</span>
fruits = [<span class="hljs-string">"苹果"</span>, <span class="hljs-string">"香蕉"</span>, <span class="hljs-string">"橙子"</span>, <span class="hljs-string">"葡萄"</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机选择1个水果："</span>, random.choice(fruits))

<span class="hljs-comment"># 从序列中随机选择多个不重复元素（比如抽奖选3人）</span>
nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>))  <span class="hljs-comment"># 1-20的整数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机选择3个不重复数字："</span>, random.sample(nums, <span class="hljs-number">3</span>))

<span class="hljs-comment"># 4. 随机打乱（原地打乱列表，修改原对象）</span>
random.shuffle(fruits)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"打乱后的水果列表："</span>, fruits)

<span class="hljs-comment"># 5. 实战案例：生成6位数字验证码（实战高频场景）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_verify_code</span>():
    <span class="hljs-string">"""生成6位数字验证码"""</span>
    code = <span class="hljs-string">""</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):
        <span class="hljs-comment"># 生成0-9的随机整数，转换为字符串拼接</span>
        code += <span class="hljs-built_in">str</span>(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>))
    <span class="hljs-keyword">return</span> code

<span class="hljs-comment"># 调用函数，生成验证码</span>
verify_code = generate_verify_code()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"6位数字验证码："</span>, verify_code)
</code></pre>
<h4 data-id="heading-8">2.3 time库：时间工具，处理时间相关场景</h4>
<p>time库用于获取当前时间、格式化时间、设置程序延迟等操作，适合日志记录、程序计时、延迟执行等实战场景，核心用法如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> time  <span class="hljs-comment"># 导入time库</span>

<span class="hljs-comment"># 1. 获取当前时间（三种常用格式）</span>
<span class="hljs-comment"># 格式1：时间戳（从1970年1月1日00:00:00到当前的秒数，浮点数）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前时间戳："</span>, time.time())

<span class="hljs-comment"># 格式2：结构化时间（包含年、月、日、时、分、秒等信息）</span>
struct_time = time.localtime()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"结构化时间："</span>, struct_time)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前年份："</span>, struct_time.tm_year)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前月份："</span>, struct_time.tm_mon)

<span class="hljs-comment"># 格式3：格式化时间（人类可读，常用）</span>
<span class="hljs-comment"># 常用占位符：%Y（4位年份）、%m（2位月份）、%d（2位日期）、%H（24小时制）、%M（分钟）、%S（秒）</span>
format_time1 = time.strftime(<span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>, struct_time)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前时间（年-月-日 时:分:秒）："</span>, format_time1)

format_time2 = time.strftime(<span class="hljs-string">"%Y年%m月%d日 %H时%M分%S秒"</span>, struct_time)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前时间（中文格式）："</span>, format_time2)

<span class="hljs-comment"># 2. 程序延迟执行（sleep(秒数)，实战常用）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"程序开始执行..."</span>)
time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 延迟2秒（让程序暂停2秒再执行后续代码）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"延迟2秒后，程序继续执行..."</span>)

<span class="hljs-comment"># 3. 实战案例：计算代码执行时间（优化代码常用）</span>
start_time = time.time()  <span class="hljs-comment"># 记录开始时间（时间戳）</span>

<span class="hljs-comment"># 模拟一段需要执行的代码（比如循环10000次）</span>
total = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):
    total += i

end_time = time.time()  <span class="hljs-comment"># 记录结束时间</span>
execution_time = end_time - start_time  <span class="hljs-comment"># 计算执行时间（秒）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"代码执行完毕，总耗时：<span class="hljs-subst">{<span class="hljs-built_in">round</span>(execution_time, <span class="hljs-number">4</span>)}</span>秒"</span>)
</code></pre>
<h4 data-id="heading-9">2.4 新手避坑指南（标准库实战必看）</h4>
<ul>
<li>避坑1：math库的函数参数多为“弧度”（而非角度），比如math.sin()计算的是弧度的正弦值，若用角度需先转换（弧度=角度×math.pi/180）；</li>
<li>避坑2：random库生成的是“伪随机数”（基于种子生成），若设置固定种子（random.seed(10)），每次运行生成的随机数会相同（适合调试）；</li>
<li>避坑3：random.shuffle()会“原地打乱”列表，修改原对象，若不想修改原列表，需先复制（比如new_list = list1.copy()，再shuffle(new_list)）；</li>
<li>避坑4：time.strftime()的占位符区分大小写，比如%Y是4位年份，%y是2位年份；%H是24小时制，%I是12小时制，新手易混淆；</li>
<li>避坑5：导入标准库时，模块名不要写错（比如math不要写成Math、random不要写成Random），否则会报错“模块不存在”。</li>
</ul>
<blockquote>
<p>以上这些你们会记嘛？不用记，现在 ai 这么发达，只要有印象，到时候 ai 一下就出来了。</p>
</blockquote>
<h3 data-id="heading-10">3 网络编程基础：实现简单的跨程序通信</h3>
<p>网络编程是Python实战中的重要技能，核心是实现“不同设备、不同程序之间的数据传输”。作为基础实战阶段，我们不深入复杂的网络协议，重点掌握<strong>TCP协议的基础用法</strong>（最常用、最可靠的网络协议），实现“本地客户端与服务器端的简单通信”，理解网络编程的核心流程，为后续学习网络爬虫、接口开发打下基础。</p>
<p>核心概念（新手必懂）： - 客户端（Client）：主动发起连接、请求数据的一方（比如我们的浏览器、手机APP）； - 服务器端（Server）：被动接收连接、响应请求的一方（比如网站的服务器）； - Socket（套接字）：网络通信的“桥梁”，客户端和服务器端通过Socket建立连接、传输数据。</p>
<h4 data-id="heading-11">3.1 网络编程核心流程（TCP协议）</h4>
<p>TCP协议的通信流程遵循“三次握手建立连接→传输数据→四次挥手关闭连接”，新手重点掌握“建立连接→传输数据→关闭连接”的基础流程，用Python的socket库实现（内置库，无需额外安装）：</p>
<p>流程拆解： 服务器端：创建Socket→绑定IP和端口→监听连接→接受连接→接收/发送数据→关闭连接； 客户端：创建Socket→连接服务器（IP+端口）→发送/接收数据→关闭连接。</p>
<h4 data-id="heading-12">3.2 实战代码：本地TCP客户端与服务器端通信</h4>
<p>以下代码分为“服务器端”和“客户端”两部分，需分别运行（先运行服务器端，再运行客户端），实现本地（127.0.0.1，本机IP）的简单通信：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ------------- 服务器端代码（server.py）-------------</span>
<span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 1. 创建Socket对象（AF_INET：IPv4协议，SOCK_STREAM：TCP协议）</span>
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span class="hljs-comment"># 2. 绑定IP地址和端口（IP：127.0.0.1，本机IP；端口：9999，自定义，1024以上避免冲突）</span>
server_addr = (<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9999</span>)
server_socket.bind(server_addr)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"服务器已启动，绑定地址：<span class="hljs-subst">{server_addr}</span>，等待客户端连接..."</span>)

<span class="hljs-comment"># 3. 监听连接（参数5：最大等待连接数）</span>
server_socket.listen(<span class="hljs-number">5</span>)

<span class="hljs-comment"># 4. 接受客户端连接（阻塞式，等待客户端发起连接）</span>
client_socket, client_addr = server_socket.accept()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"客户端<span class="hljs-subst">{client_addr}</span>已连接！"</span>)

<span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># 5. 接收客户端发送的数据（recv(1024)：每次最多接收1024字节，需解码为字符串）</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        data = client_socket.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">"utf-8"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 若客户端关闭连接，data为空，退出循环</span>
            <span class="hljs-keyword">break</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"收到客户端<span class="hljs-subst">{client_addr}</span>的消息：<span class="hljs-subst">{data}</span>"</span>)
        
        <span class="hljs-comment"># 6. 向客户端发送响应数据（需编码为bytes类型）</span>
        response = <span class="hljs-string">f"服务器已收到消息：<span class="hljs-subst">{data}</span>，时间：<span class="hljs-subst">{time.strftime(<span class="hljs-string">'%H:%M:%S'</span>)}</span>"</span>
        client_socket.send(response.encode(<span class="hljs-string">"utf-8"</span>))
<span class="hljs-keyword">finally</span>:
    <span class="hljs-comment"># 7. 关闭连接（先关闭客户端连接，再关闭服务器端连接）</span>
    client_socket.close()
    server_socket.close()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"与客户端<span class="hljs-subst">{client_addr}</span>的连接已关闭，服务器已停止运行"</span>)

<span class="hljs-comment"># ------------- 客户端代码（client.py）-------------</span>
<span class="hljs-keyword">import</span> socket

<span class="hljs-comment"># 1. 创建Socket对象（与服务器端一致，IPv4+TCP）</span>
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span class="hljs-comment"># 2. 连接服务器（指定服务器的IP和端口，与服务器端一致）</span>
server_addr = (<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9999</span>)
<span class="hljs-keyword">try</span>:
    client_socket.connect(server_addr)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"成功连接到服务器<span class="hljs-subst">{server_addr}</span>！"</span>)
    
    <span class="hljs-comment"># 3. 向服务器发送数据（输入消息，发送给服务器）</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        msg = <span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入要发送给服务器的消息（输入'quit'退出）："</span>)
        <span class="hljs-keyword">if</span> msg == <span class="hljs-string">"quit"</span>:
            <span class="hljs-keyword">break</span>
        <span class="hljs-comment"># 发送数据：字符串编码为bytes类型</span>
        client_socket.send(msg.encode(<span class="hljs-string">"utf-8"</span>))
        
        <span class="hljs-comment"># 4. 接收服务器的响应数据</span>
        response = client_socket.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">"utf-8"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"服务器响应：<span class="hljs-subst">{response}</span>"</span>)
<span class="hljs-keyword">finally</span>:
    <span class="hljs-comment"># 5. 关闭连接</span>
    client_socket.close()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"与服务器的连接已关闭"</span>)
</code></pre>
<h4 data-id="heading-13">3.3 代码运行说明与实战拓展</h4>
<ul>
<li>运行步骤：① 新建两个.py文件（server.py、client.py），分别复制上面的代码；② 先运行server.py（服务器启动，等待连接）；③ 再运行client.py（客户端连接服务器）；④ 在客户端输入消息，即可实现双向通信，输入“quit”退出。</li>
<li>实战拓展：将前阶段的“文件操作”结合进来，实现“客户端向服务器发送文件内容，服务器接收后保存到本地”（比如客户端读取test.txt文件，发送给服务器，服务器保存为server_test.txt）。</li>
</ul>
<h4 data-id="heading-14">3.4 新手避坑指南（网络编程基础必看）</h4>
<ul>
<li>避坑1：必须“先启动服务器端，再启动客户端”，否则客户端会报错“连接拒绝”；</li>
<li>避坑2：IP地址和端口必须一致，服务器端绑定的IP和端口，客户端必须完全对应（比如服务器绑定127.0.0.1:9999，客户端也要连接这个地址）；</li>
<li>避坑3：TCP通信中，send()发送的是bytes类型数据，recv()接收的也是bytes类型，必须用encode("utf-8")编码、decode("utf-8")解码，否则会报错或出现乱码；</li>
<li>避坑4：端口号需选择1024以上的（1024以下是系统标准端口，可能被占用），若运行时报错“端口已被占用”，可更换端口（比如改为10000）；</li>
<li>避坑5：服务器端的accept()、recv()是“阻塞式”的，会一直等待客户端的连接/数据，新手无需深究，后续进阶再学习非阻塞编程；</li>
<li>避坑6：通信结束后，必须关闭Socket连接（close()），避免资源泄露。</li>
</ul>
<h3 data-id="heading-15">4 多线程基础：实现程序的并发执行</h3>
<p>在前面的学习中，我们编写的代码都是“单线程”的——程序从上到下，依次执行，一次只能做一件事（比如程序执行延迟时，会一直卡住，无法做其他操作）。而“多线程”，能让程序“同时执行多个任务”（并发执行），提升程序效率，尤其适合I/O密集型任务（比如文件操作、网络请求、延迟执行）。</p>
<p>作为基础实战阶段，我们重点掌握Python threading模块的基础用法（内置库，无需额外安装），实现简单的多线程并发，理解多线程的核心概念和优势，不深入复杂的线程安全、锁机制（后续进阶再学习）。</p>
<p>核心概念（新手必懂）： - 线程（Thread）：程序执行的最小单位，一个程序可以包含多个线程； - 主线程：程序启动后，默认创建的线程（比如我们之前写的代码，都是主线程在执行）； - 子线程：我们手动创建的线程，用于执行额外的任务，与主线程并发执行。</p>
<h4 data-id="heading-16">4.1 多线程基础用法（两种常用方式）</h4>
<p>新手重点掌握两种创建子线程的方式：① 传入target函数（推荐，简单易懂）；② 继承Thread类（进阶用法，简单了解），结合实战案例讲解：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># ---------------- 方式1：传入target函数（推荐，新手首选）----------------</span>
<span class="hljs-comment"># 定义要在子线程中执行的函数（比如模拟下载任务）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">download_task</span>(<span class="hljs-params">task_name, delay</span>):
    <span class="hljs-string">"""模拟下载任务：延迟delay秒，模拟下载耗时"""</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程启动：开始下载<span class="hljs-subst">{task_name}</span>，预计耗时<span class="hljs-subst">{delay}</span>秒"</span>)
    time.sleep(delay)  <span class="hljs-comment"># 模拟下载耗时（I/O阻塞）</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程结束：<span class="hljs-subst">{task_name}</span>下载完成！"</span>)

<span class="hljs-comment"># 1. 创建子线程（target：子线程要执行的函数；args：传入函数的参数，元组类型）</span>
thread1 = threading.Thread(target=download_task, args=(<span class="hljs-string">"电影A"</span>, <span class="hljs-number">3</span>))
thread2 = threading.Thread(target=download_task, args=(<span class="hljs-string">"音乐B"</span>, <span class="hljs-number">2</span>))

<span class="hljs-comment"># 2. 启动子线程（start()：启动线程，自动调用target函数）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"主线程：开始执行程序"</span>)
thread1.start()
thread2.start()

<span class="hljs-comment"># 3. 等待子线程执行完毕（join()：阻塞主线程，等待子线程结束后，主线程再继续）</span>
thread1.join()
thread2.join()

<span class="hljs-built_in">print</span>(<span class="hljs-string">"主线程：所有子线程执行完毕，程序结束"</span>)

<span class="hljs-comment"># ---------------- 方式2：继承Thread类（简单了解）----------------</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(threading.Thread):
    <span class="hljs-string">"""自定义线程类，继承Thread类，重写run()方法"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, task_name, delay</span>):
        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类的初始化方法</span>
        self.task_name = task_name
        self.delay = delay
    
    <span class="hljs-comment"># 重写run()方法：子线程启动后，会自动执行run()方法中的代码</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程启动：开始下载<span class="hljs-subst">{self.task_name}</span>，预计耗时<span class="hljs-subst">{self.delay}</span>秒"</span>)
        time.sleep(self.delay)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程结束：<span class="hljs-subst">{self.task_name}</span>下载完成！"</span>)

<span class="hljs-comment"># 创建自定义线程对象</span>
thread3 = MyThread(<span class="hljs-string">"图片C"</span>, <span class="hljs-number">1</span>)
thread4 = MyThread(<span class="hljs-string">"文档D"</span>, <span class="hljs-number">4</span>)

<span class="hljs-comment"># 启动子线程</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n主线程：开始执行自定义线程程序"</span>)
thread3.start()
thread4.start()

<span class="hljs-comment"># 等待子线程结束</span>
thread3.join()
thread4.join()

<span class="hljs-built_in">print</span>(<span class="hljs-string">"主线程：所有自定义线程执行完毕，程序结束"</span>)
</code></pre>
<h4 data-id="heading-17">4.2 多线程的优势（实战对比）</h4>
<p>通过“单线程”与“多线程”的执行时间对比，直观感受多线程的并发优势（适合I/O密集型任务）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 定义任务函数（模拟I/O阻塞，比如下载、文件读取）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name, delay</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"任务<span class="hljs-subst">{name}</span>开始执行，耗时<span class="hljs-subst">{delay}</span>秒"</span>)
    time.sleep(delay)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"任务<span class="hljs-subst">{name}</span>执行完毕"</span>)

<span class="hljs-comment"># ---------------- 单线程执行（依次执行3个任务）----------------</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 单线程执行 ==="</span>)
start_time1 = time.time()

task(<span class="hljs-string">"A"</span>, <span class="hljs-number">3</span>)
task(<span class="hljs-string">"B"</span>, <span class="hljs-number">2</span>)
task(<span class="hljs-string">"C"</span>, <span class="hljs-number">1</span>)

end_time1 = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"单线程总耗时：<span class="hljs-subst">{<span class="hljs-built_in">round</span>(end_time1 - start_time1, <span class="hljs-number">2</span>)}</span>秒\n"</span>)  <span class="hljs-comment"># 总耗时约6秒</span>

<span class="hljs-comment"># ---------------- 多线程执行（3个任务并发执行）----------------</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 多线程执行 ==="</span>)
start_time2 = time.time()

<span class="hljs-comment"># 创建3个子线程</span>
t1 = threading.Thread(target=task, args=(<span class="hljs-string">"A"</span>, <span class="hljs-number">3</span>))
t2 = threading.Thread(target=task, args=(<span class="hljs-string">"B"</span>, <span class="hljs-number">2</span>))
t3 = threading.Thread(target=task, args=(<span class="hljs-string">"C"</span>, <span class="hljs-number">1</span>))

<span class="hljs-comment"># 启动所有子线程</span>
t1.start()
t2.start()
t3.start()

<span class="hljs-comment"># 等待所有子线程结束</span>
t1.join()
t2.join()
t3.join()

end_time2 = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"多线程总耗时：<span class="hljs-subst">{<span class="hljs-built_in">round</span>(end_time2 - start_time2, <span class="hljs-number">2</span>)}</span>秒"</span>)  <span class="hljs-comment"># 总耗时约3秒（取决于最长任务）</span>
</code></pre>
<p>运行结果分析：单线程执行3个任务，总耗时是3+2+1=6秒；多线程并发执行，总耗时约3秒（等于最长任务的耗时），明显提升了程序效率——这就是多线程的核心优势，适合处理“需要等待的任务”。</p>
<h4 data-id="heading-18">4.3 新手避坑指南（多线程基础必看）</h4>
<ul>
<li>避坑1：启动线程必须用 <code>start()</code> 方法，不能用 <code>run()</code> 方法——start()会创建子线程，并发执行；run()只是普通函数调用，还是单线程执行；</li>
<li>避坑2：<code>join()</code> 方法的作用是“阻塞主线程”，等待子线程执行完毕，若不调用join()，主线程会直接结束，子线程可能还未执行完就被终止；</li>
<li>避坑3：Python中存在“全局解释器锁（GIL）”，同一时刻只有一个线程能执行Python代码——多线程适合I/O密集型任务（如下载、延迟），不适合CPU密集型任务（如大量计算），新手无需深究GIL，知道这个特性即可；</li>
<li>避坑4：多个子线程共享全局变量时，可能会出现“线程安全问题”（比如多个线程同时修改一个全局变量，导致数据错误），基础阶段暂时不处理，后续进阶学习“锁机制”解决；</li>
<li>避坑5：不要创建过多的子线程（比如几百、几千个），会占用大量系统资源，导致程序卡顿，按需创建即可。</li>
</ul>
<h3 data-id="heading-19">5 总结</h3>
<p>恭喜大家！Python3基础学习第七阶段「基础实战巩固」的核心内容，到这里就全部梳理完毕了！这一阶段，我们没有学习新的复杂语法，而是聚焦“实战巩固”，将前六阶段的知识串联起来，通过四大实战方向，实现了从“会用”到“活用”的跨越：</p>
<ul>
<li>常用内置函数：掌握了len、range、enumerate、zip等高频工具，学会用内置函数简化代码，提升编码效率；</li>
<li>简单标准库：熟练使用math、random、time三个常用标准库，能解决数学计算、随机场景、时间处理等日常实战需求；</li>
<li>网络编程基础：掌握TCP协议的核心流程，实现了本地客户端与服务器端的简单通信，理解了跨程序通信的原理；</li>
<li>多线程基础：学会用threading模块创建子线程，实现程序的并发执行，提升I/O密集型任务的效率。</li>
</ul>
<p>本阶段的核心重点是“实战”——新手不要只看代码、记语法，一定要亲手敲写每个案例，调试报错，结合前阶段的知识（函数、模块、文件操作等）拓展实战场景，比如：用多线程实现多文件下载、用网络编程+文件操作实现文件传输、用内置函数+标准库编写简单的验证码生成器。</p>
<p>对于新手来说，本阶段可能会觉得多线程、网络编程有点难度，尤其是“并发”“Socket连接”的逻辑，容易混淆步骤——没关系，多动手练习，先掌握基础用法，再逐步理解原理，重点是能独立写出可运行的实战代码，巩固基础。</p>
<p>到这里，Python3基础学习的七个阶段就全部结束了！通过这七个阶段的学习，你已经掌握了Python的核心基础语法、模块化编程、面向对象、实战工具、网络与并发基础，具备了独立编写简单Python项目的能力。</p>
<p>接下来，你可以尝试挑战简单的实战项目（比如学生管理系统、通讯录、简易爬虫、验证码生成器），将七个阶段的知识综合运用，查漏补缺。后续我们还会进入Python进阶学习阶段，学习更复杂的框架、项目开发技巧，继续加油，你已经离“合格的Python开发者”越来越近啦～</p>
<hr/>
<p><em>转发请携带作者信息</em>  <strong>@怒放吧德德 @一个有梦有戏的人</strong><br/>
持续创作很不容易，作者将以尽可能的详细把所学知识分享各位开发者，一起进步一起学习。<strong>转载请携带链接，转载到微信公众号请勿选择原创，谢谢！</strong><br/>
👍创作不易，如有错误请指正，感谢观看！记得点赞哦！👍<br/>
谢谢支持！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OoderAgent 相比主流Agent框架的五大核心独特优势]]></title>    <link>https://juejin.cn/post/7603895839557730367</link>    <guid>https://juejin.cn/post/7603895839557730367</guid>    <pubDate>2026-02-09T04:49:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603895839557730367" data-draft-id="7604084016510713897" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OoderAgent 相比主流Agent框架的五大核心独特优势"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-09T04:49:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OoderAgent 相比主流Agent框架的五大核心独特优势
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:49:47.000Z" title="Mon Feb 09 2026 04:49:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>截至 2026 年初，ooderAgent（特别是 Nexus / 2.0 版本）在众多 AI Agent 框架中展现出显著且系统性的独特优势。它并非在单一功能上“微创新”，而是从架构哲学、能力抽象、人机协同、企业落地四个维度重构了 AI 应用的开发与运行范式。</p>
<p>以下是 ooderAgent 相比主流框架（如 LangChain、Dify、AutoGen、CrewAI 等）的 五大核心独特优势：</p>
<p>✅ 1. 以 Skill 为中心的能力抽象（而非 LLM 为中心）
这是最根本的差异：ooderAgent 把 AI 能力当作“可治理的服务”，而不是“大模型的插件”。
对比项   ooderAgent   其他框架（LangChain/Dify 等）
最小单元   Skill（AIBridge）• 强 Schema 约束• 版本管理• 上下文隔离• 可审计、可回滚   Tool / Function / Node• 多为函数包装• 无标准输入/输出契约• 依赖开发者自律</p>
<p>能力边界   支持 LLM + 规则 + 数据库 + API 混合执行   多数仅封装 LLM 调用或简单工具</p>
<p>复用机制   通过 Nexus 技能中心 注册、发现、订阅   手动复制代码或依赖 LangServe</p>
<p>💡 价值：Skill 成为企业数字资产，可积累、沉淀、复用，避免“每次重写 prompt”。</p>
<p>✅ 2. 原生 P2P 分布式架构（支持边缘自治 + 断网可用）
唯一真正实现“去中心化但可控”的企业级 Agent 框架。</p>
<ul>
<li>三层 P2P 架构：
<ul>
<li>End Agent：部署在业务终端（如工厂 PC、门店 POS），本地执行 Skill；</li>
<li>Route Agent：动态路由通信，支持 NAT 穿透；</li>
<li>MCP Agent：提供全局能力（模型池、安全认证）。</li>
</ul>
</li>
<li>关键能力：
<ul>
<li>断网仍可运行：End Agent 缓存常用 Skill，离线处理任务；</li>
<li>数据不出域：敏感操作在本地完成，仅同步结果；</li>
<li>CAP 快速重连：网络恢复后自动状态同步。</li>
</ul>
</li>
</ul>
<p>🌐 对比：LangChain、Dify、FastGPT 均为中心化架构，断网即失效；AutoGen 仅为本地模拟，无法跨设备协作。</p>
<p>✅ 3. A2UI + BridgeCode：AI 驱动的动态 UI（体验革命）
让 AI 输出直接变成“可操作界面”，而非一段文本。</p>
<ul>
<li>
<p>传统方案：LLM → JSON/Markdown → 前端解析 → 渲染（体验割裂、易出错）</p>
</li>
<li>
<p>ooderAgent 方案：
// Skill 返回结构化 UIComponent
return UIC.form()
.addField("orderId", "订单号")
.addButton("submit", "确认发货")
.onSubmit(handleShipping);</p>
<ul>
<li>前端通过 BridgeCode 引擎 自动渲染为表单、图表、按钮；</li>
<li>用户点击“确认发货”直接触发新 Skill，形成闭环。</li>
</ul>
</li>
</ul>
<p>🎯 效果：非技术人员也能高效完成复杂任务，大幅提升任务完成率。</p>
<p>✅ 4. 人在回路（Human-in-the-Loop）自动进化机制
AI 系统能从用户修正中学习，并沉淀为新能力。</p>
<p>流程：</p>
<ol>
<li>用户调用 Skill A（如“生成周报”）；</li>
<li>手动修改结果（调整格式、补充数据）；</li>
<li>系统自动捕获修正行为；</li>
<li>生成新 Skill B（“市场部周报模板 v2”）；</li>
<li>经审核后发布到 Nexus，供团队复用。</li>
</ol>
<p>🔁 形成“使用 → 修正 → 沉淀 → 复用”的正向飞轮，这是 LangChain 等框架完全不具备的持续进化能力。</p>
<p>✅ 5. 企业级工程就绪：安全、合规、可观测
不是 Demo 框架，而是为生产环境设计。
能力   ooderAgent 实现
安全   DID 身份 + E2EE 加密 + RBAC 权限 + VFS 数据沙箱</p>
<p>合规   操作日志全审计，满足 GDPR/等保要求</p>
<p>可观测   OpenTelemetry 全链路追踪，Skill 调用可监控</p>
<p>集成   Spring Boot 注解驱动，无缝嵌入现有 Java 系统</p>
<p>协议   MIT 开源，无商业限制</p>
<p>🏢 这使得 ooderAgent 能真正进入金融、政务、制造等强监管场景，而多数开源框架止步于“技术演示”。</p>
<p>🆚 横向对比总结
能力维度   ooderAgent   LangChain   Dify/FastGPT   AutoGen
架构模式   ✅ P2P 分布式   ❌ 中心化   ❌ SaaS/私有中心   ⚠️ 本地模拟</p>
<p>能力抽象   ✅ Skill（可治理资产）   ⚠️ Tool（函数）   ⚠️ Node（配置块）   ⚠️ Agent（对话角色）</p>
<p>离线能力   ✅ End Agent 本地运行   ❌ 依赖 LLM API   ❌ 依赖后端服务   ✅ 但仅限单机</p>
<p>动态 UI   ✅ A2UI 原生支持   ❌ 需自行实现   ⚠️ 固定组件   ❌ 无</p>
<p>持续进化   ✅ 人在回路 → 新 Skill   ❌ 无   ⚠️ 仅人工审批   ❌ 无</p>
<p>企业合规   ✅ 全栈支持   ⚠️ 需自行补足   ⚠️ 基础支持   ❌ 无</p>
<p>🎯 结论：ooderAgent 的独特定位</p>
<p>它不是“另一个 LLM 编排工具”，而是试图成为“AI 原生时代的企业应用操作系统”。</p>
<ul>
<li>
<p>适合谁：<br/>
✔ 有复杂业务流程的企业<br/>
✔ 需要 AI 与现有系统深度集成<br/>
✔ 重视安全、治理、长期演进</p>
</li>
<li>
<p>不适合谁：<br/>
✖ 只想快速搭个聊天机器人<br/>
✖ 团队无 Java/Spring 工程能力<br/>
✖ 追求“零代码”但不愿定义业务规则</p>
</li>
</ul>
<p>如果你正在寻找一个能伴随企业 AI 战略长期演进、可积累智能资产、支持边缘与中心协同的框架，ooderAgent 是目前最值得投入的开源选项之一。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实测可用｜一文搞定OpenClaw部署，免费kimi-k2.5+飞书远程，新手也能秒上手]]></title>    <link>https://juejin.cn/post/7604093823958040595</link>    <guid>https://juejin.cn/post/7604093823958040595</guid>    <pubDate>2026-02-09T02:05:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604093823958040595" data-draft-id="7604084016510091305" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实测可用｜一文搞定OpenClaw部署，免费kimi-k2.5+飞书远程，新手也能秒上手"/> <meta itemprop="keywords" content="人工智能,LLM,NVIDIA"/> <meta itemprop="datePublished" content="2026-02-09T02:05:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lethehong"/> <meta itemprop="url" content="https://juejin.cn/user/1567216547423136"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实测可用｜一文搞定OpenClaw部署，免费kimi-k2.5+飞书远程，新手也能秒上手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1567216547423136/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lethehong
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:05:41.000Z" title="Mon Feb 09 2026 02:05:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近亲测完成了 OpenClaw 的部署，把全程步骤整理出来分享给大家，适配中国大陆网络环境，还会教大家配置英伟达免费的 AI 模型（包含 kimi-k2.5），所有代码直接复制就能用，跟着步骤走全程无坑～  </p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2053e925f1240bda8ee1cdaa876b6dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Bpqq0kPYj9BiR4mReuAS34GmW0c%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">第一步：版本检测，确认系统初始状态</h2>
<p>先检查服务器里有没有装过 OpenClaw，或者它的旧版本 Moltbot/Clawdbot，避免版本冲突，直接执行下面的检测命令就行：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw --version 2&gt;/dev/null &amp;&amp; echo "OpenClaw 已安装" || echo "未安装 OpenClaw"; moltbot --version 2&gt;/dev/null &amp;&amp; echo "Moltbot 已安装（旧版本）" || echo "未安装 Moltbot"; clawdbot --version 2&gt;/dev/null &amp;&amp; echo "Clawdbot 已安装（旧版本）" || echo "未安装 Clawdbot"
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b248efca82e48dbbe8fe6e07590f919~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=D7SG0Gd16xO9TzI1ZxgBtqsBg1I%3D" alt="" loading="lazy"/></p>
<p>我这边检测结果是啥都没装，直接走完整的部署流程就可以。</p>
<h2 data-id="heading-1">第二步：环境检测，核对服务器配置</h2>
<p>安装前先确认服务器配置是否达标，同时检查 Node.js 和 Git 这两个必备依赖有没有装，执行下面的命令一次性检测所有关键指标：</p>
<pre><code class="hljs language-plain" lang="plain">echo "=== 环境检测开始 ===" &amp;&amp; echo "1. 操作系统信息：" &amp;&amp; cat /etc/os-release | grep PRETTY_NAME &amp;&amp; echo "2. CPU核心数：" &amp;&amp; nproc &amp;&amp; echo "3. 内存大小（MB）：" &amp;&amp; free -m | awk 'NR==2{print $2}' &amp;&amp; echo "4. 磁盘可用空间：" &amp;&amp; df -h / | awk 'NR==2{print $4}' &amp;&amp; echo "5. Node.js版本：" &amp;&amp; node --version 2&gt;/dev/null || echo "未安装" &amp;&amp; echo "6. Git版本：" &amp;&amp; git --version 2&gt;/dev/null || echo "未安装" &amp;&amp; echo "=== 环境检测结束 ==="
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f01a7c6b6a144178fc036a614dc9782~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=jN5TkJ8s8uwimRZ%2FZKTK2OWvytQ%3D" alt="" loading="lazy"/></p>
<p> 我用的服务器是 Ubuntu 22.04 LTS 系统，2 核 CPU、1.9GB 内存、42GB 磁盘空间，Node.js v22.22.0 和 Git 也都提前装好了，完全满足安装要求，不用额外装依赖，直接下一步。  </p>
<h2 data-id="heading-2">第三步：安装 OpenClaw，适配国内镜像源</h2>
<p>因为是国内服务器，先配置国内的镜像源避免下载卡顿，本来试了 yarn 安装，后来觉得 npm 更稳定可靠，就直接用 npm 装了，先设腾讯云的 npm 镜像，再全局安装最新版 OpenClaw，执行这条命令就行：</p>
<pre><code class="hljs language-plain" lang="plain">npm config set registry https://mirrors.cloud.tencent.com/npm/ &amp;&amp; npm install -g openclaw@latest
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c982002be94b4950b1420ad149588c09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=MJx%2FfCduKKuK4OpOEksQWmlB%2Bw0%3D" alt="" loading="lazy"/></p>
<p>安装过程会自动装 700 多个包，中间会出几个过时包的警告，不用管，不影响正常使用，等待安装完成就好。</p>
<h2 data-id="heading-3">第四步：验证安装，确认 OpenClaw 可用</h2>
<p>装完之后一定要检查下版本，确认安装成功，命令很简单：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw --version
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c58aeb0afe144ae946a25999d020adb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=DX%2BVbnD7FDPbw0TI9ZnsZ6p483g%3D" alt="" loading="lazy"/></p>
<p>我这边成功装到了 2026.2.2-3 版本，到这一步 OpenClaw 就装好了～</p>
<h2 data-id="heading-4">重点步骤：配置英伟达免费 AI 模型（含 kimi-k2.5）</h2>
<p>这一步教大家白嫖英伟达的免费 AI 模型，里面包含 kimi-k2.5，跟着三步来就行，全程免费：</p>
<h3 data-id="heading-5">1. 注册英伟达账号并获取 API Key</h3>
<p>先打开英伟达的地址注册：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbuild.nvidia.com%2F" target="_blank" title="https://build.nvidia.com/" ref="nofollow noopener noreferrer">build.nvidia.com/</a>，建议用谷歌账号直接登录，方便快捷；登录后点左上角的头像，新建一个专属的 API Key，保存好别弄丢了。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/292b336ef61e4791b7ac89cb9d1fceda~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Wx%2FNJdVnWRtpFfc9V1avOSAEyeA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">2. 修改 OpenClaw 配置文件</h3>
<p>需要打开 OpenClaw 的配置文件，在指定位置添加英伟达模型的配置，<strong>重点注意</strong>：providers 外面要包一层 models，如果文件里本来就有 models，直接加进原有内容里就行，其他代码千万别改！执行命令打开配置文件：</p>
<pre><code class="hljs language-plain" lang="plain">vi ~/.openclaw/openclaw.json  
</code></pre>
<p>然后在 models 部分添加下面的代码，记得把里面的 apiKey 换成你自己刚创建的：</p>
<pre><code class="hljs language-plain" lang="plain">帮我打开 ~/.openclaw/openclaw.json文件，在 models 部分增加下面的代码，注意：providers 外面还要加一层 models，如果原来配置有models就加到原来的里面
{
  ... 其他内容不要改
  "models": {
   "providers":{
        "英伟达nvidia": {
            "baseUrl": "https://integrate.api.nvidia.com/v1",
            "apiKey": "nvapi-HxKN8Zp2-xxxxx-替换成你的 key,
            "api": "openai-completions",
            "models": [
              {
                "id": "moonshotai/kimi-k2.5",
                "name": "moonshotai/kimi-k2.5",
                "reasoning": false,
                "input": [
                  "image",
                  "text"
                ],
                "cost": {
                  "input": 0,
                  "output": 0,
                  "cacheRead": 0,
                  "cacheWrite": 0
                },
                "contextWindow": 200000,
                "maxTokens": 8192
              }
            ]
        }
        ... 其他内容不要改
    }
    ... 其他内容不要改
  }
}
</code></pre>
<h3 data-id="heading-7">3. 运行配置向导，完成剩余设置</h3>
<p>模型配置好后，运行 OpenClaw 的配置向导，跟着提示完成其他基础设置就行：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw onboard
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca0b966cfd8e4e6c90fdf814e07cdfe4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=3yswGF1z2uzjrc7392VvMtZRDlI%3D" alt="" loading="lazy"/></p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/314adb61460d41afbb889c5cabfbd666~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=dFLzqSdedjaUVEoeVSAti0DgEso%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-8">修复安全权限警告</h2>
<p>配置完会出现安全权限的警告，用下面的命令修复一下，给配置目录设置专属权限，执行后会提示修复完成：</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88ca4d56405f47c5b6e495740e69451d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Ha9iQe038qL9waz4dMNayXBvt1M%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-plain" lang="plain">chmod 700 /root/.openclaw &amp;&amp; echo "安全权限已修复"
</code></pre>
<h2 data-id="heading-9">最后一步：启动 OpenClaw 核心网关服务</h2>
<p>所有配置和修复都完成后，重启 OpenClaw 的网关服务</p>
<pre><code class="hljs language-plain" lang="plain">openclaw gateway restart
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cfae565b3df748eaa929b950ffcbc4bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=jte3CzAXpWjVGhfmpMUQRgqVhkc%3D" alt="" loading="lazy"/></p>
<p>到这里，OpenClaw 就完成全部部署和配置了，启动网关服务后就能正常使用，还能直接调用英伟达免费的 kimi-k2.5 模型，亲测全程流畅，有问题的小伙伴可以留言交流～</p>
<p>接下来启动网关并测试模型，步骤超简单：先执行<code>openclaw gateway --force</code>重启网关服务，再输入<code>openclaw tui</code>打开交互测试界面，最后直接问一句「你是干嘛的」，就能验证配置是否生效啦。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b6d7f9824634dcabdde5a5bff5d951d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=juw%2BnO3bVDKUkoIH2WcHKnnsY8c%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">进阶实操：接入飞书，实现手机远程操控（必看！）</h2>
<p>作为AI玩家，我必须说一句：本地运行够用，但远程操控才是精髓！守在电脑前太束缚，接入飞书（Lark）后，手机揣兜里，随时随地给家里/服务器的OpenClaw下指令，躺平操作不香吗？🤫 这部分我把自己踩过的坑都标出来了，跟着我的步骤走，零失败！</p>
<p>先搞飞书开放平台的基础配置，打开这个地址：<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">open.feishu.cn/app</a>，点击“新建应用”，页面上的基础信息（应用名称、描述之类的）随便填，不用纠结，填完保存就行，全程跟着页面提示走，没有复杂操作，新手也能秒上手。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a75c2b1eafe2476e965de3c09cddaf68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=9zT0siac10We1nGH%2FJXBlEtnVL4%3D" alt="" loading="lazy"/>关键一步：新建应用后，会自动生成「App ID」和「App Secret」，这俩是飞书和OpenClaw对接的“钥匙”，一定要复制保存好，最好存到记事本里，丢了就得重新创建应用，巨浪费时间！我第一次就忘存，返工半小时谁懂啊…</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d1aa9383fdc45d8b9b9c979fb30732d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=ydv2j2GKk8r0FW3kXVCYswZ%2BFDk%3D" alt="" loading="lazy"/></p>
<p>回到应用配置页，找到「添加应用能力」选项，点开后直接选「机器人」，点击“添加”就完事，不用额外勾选其他东西，多余操作反而容易出问题。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/15b95bfd81fa411e9db3f946bb18e200~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=37aJTxQuzGVt8%2B3NXPkHUmDgFkw%3D" alt="" loading="lazy"/></p>
<p>避坑重点（敲黑板！）：给刚添加的机器人，开通「全部权限」！没错，是全部，一个都别漏！我第一次图省事漏勾了两个，结果后面对接一直失败，排查了半天才发现是权限不够，血的教训！</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2bca473d6f94b178cd5c8c54e3fff5f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=JWj8kR5%2FifbEsTAkbLthsM4NuAw%3D" alt="" loading="lazy"/></p>
<p>权限搞定，就该装对接插件了——这个插件是飞书和OpenClaw的“桥梁”，没有它俩就无法通信，直接复制下面的命令安装，注意别手滑输错字符：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw plugins install @m1heng-clawd/feishu
</code></pre>
<p>插件安装完成，接下来把之前保存的「App ID」和「App Secret」配置进去，三条命令依次执行，重点提醒：把命令里的“cli_xxxxx”和“your_app_secret”，替换成你自己的，别直接复制运行！否则会报错，还得重启网关重来！</p>
<pre><code class="hljs language-plain" lang="plain">openclaw config set channels.feishu.appId "cli_xxxxx"   #换为你自己在步骤2得到的
openclaw config set channels.feishu.appSecret "your_app_secret"  #换为你自己在步骤2得到的
openclaw config set channels.feishu.enabled true
</code></pre>
<p>配置生效的关键：重启网关！执行下面这条命令，重启完成后，配置才会真正生效，别偷懒跳过这一步：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw gateway restart
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/93bf101fa2be4b08ba34c9fff12ec250~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Ms1RbbV00pve%2B6rjjtqTpKtwlXs%3D" alt="" loading="lazy"/></p>
<p>再回到飞书开放平台，找到「事件与回调」——这两个选项缺一不可，必须都配置好！然后在回调方式里，选择「长连接」，保存即可。如果提示连接失败，不用慌，大概率是上一步网关没重启到位，回去再执行一次重启命令，基本都能解决，我亲测过三次，都是这个问题！</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4640228cb82b4639826b0eaf8ef33204~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=R3Gn6rGWZLdt01Kdb1QHvdRjf%2FY%3D" alt="" loading="lazy"/></p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7439c92265c34dff9c5da36b9ee63c52~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=6HUxYCXEMW7j6ZiEPnkLBtq%2FAcg%3D" alt="" loading="lazy"/></p>
<p>还有一个细节：添加事件的时候，把里面所有的事件都勾选上，别漏一个！少勾一个事件，后面飞书就可能无法正常接收/执行指令，比如没法远程下达操作命令，到时候又得回头排查，得不偿失。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3511fbbcfa814d44b27fa558d243cf70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=656K8aXYRXZyVOx3dlKXW8Nu3Qs%3D" alt="" loading="lazy"/></p>
<p>最后一步，发布插件才能用！点击左侧菜单栏的「版本管理与发布」，先点击「创建版本」，不用改其他设置，直接提交，然后点击「申请发布」，飞书的审核很快，几分钟就通过，发布完成后，插件就正式生效了。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a82bcfc55dd4571a2a87ac89c44c6ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=RVCMUcSPj%2BrUrJtvlmGhPrx2iR8%3D" alt="" loading="lazy"/></p>
<p>大功告成！打开你手机上的飞书，找到刚才创建的那个机器人，发送消息就能测试，比如之前教的“你是什么模型”，就能远程操控OpenClaw执行指令，再也不用守在电脑前，随时随地都能操作，这才是OpenClaw的正确打开方式啊！</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f58e041101e64393892344c309e0eb99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=7qWRcMbzZkEqUJ8%2FLab2sJ9wxX4%3D" alt="" loading="lazy"/></p>
<p>到这里，OpenClaw的完整部署、英伟达免费模型配置，还有飞书远程操控接入，就全部完成了！全程亲测流畅无bug，每一步都标了避坑点，新手也能轻松上手。如果操作中遇到问题，评论区留言，我看到都会回复，一起交流一起折腾～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[第二章: 图像处理基本操作]]></title>    <link>https://juejin.cn/post/7603854784865779752</link>    <guid>https://juejin.cn/post/7603854784865779752</guid>    <pubDate>2026-02-09T02:46:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865779752" data-draft-id="7604045354070097954" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="第二章: 图像处理基本操作"/> <meta itemprop="keywords" content="算法"/> <meta itemprop="datePublished" content="2026-02-09T02:46:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="宝贝儿好"/> <meta itemprop="url" content="https://juejin.cn/user/2737129399522635"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            第二章: 图像处理基本操作
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2737129399522635/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    宝贝儿好
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:46:30.000Z" title="Mon Feb 09 2026 02:46:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">第二章: 图像处理基本操作</h3>
<h4 data-id="heading-1">一、图像的表示方法</h4>
<ul>
<li><strong>二值图像：</strong> 每个像素点不是白色就是黑色；一个像素点只要一个bit位就能表示；用0或1表示每个像素点。</li>
<li><strong>灰度图像：</strong> 图像只有一种颜色，比如图像可以是红色，可以是灰色，可以蓝色，可以是绿色等等，但不管什么颜色都是只有一种颜色。但是这一种颜色我们给它分成了256个等级，就是256个灰度级，可以理解成256个不同程度的明暗度。比如一张红色的灰度图像，像素值=0就是最暗，黑色，像素值=255就是最亮，就是最亮的红色。255中明暗度正好可以用8位也就是1字节byte表示。</li>
<li><strong>彩色图像：</strong> 图像是彩色的，图像的每个像素点都是由三种颜色混合而成。这三种颜色是R G B, 每种颜色的取值都在0-255之间。每种颜色是一个通道，所以彩图一般都是3通道。少数图像是4通道，因为还有一个0-1之间的透明度。</li>
</ul>
<h4 data-id="heading-2">二、像素处理</h4>
<pre><code class="hljs language-scss" lang="scss">#例<span class="hljs-number">2.1</span> 生成一个<span class="hljs-number">10</span>x10大小的黑色图像，并且对其像素进行修改，显示修改前后的图像，理解数据和图像之间的一一对应关系。
import cv2
import numpy as np
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">10</span>,<span class="hljs-number">10</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-built_in">print</span>('请看下面图像数据长的样子吧：\n', img, '\n')   #\n表示回车重启一行
cv2<span class="hljs-selector-class">.imshow</span>('one', img)         #图像窗口显示图像
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0:3,3:6]</span>=<span class="hljs-number">255</span>               #把<span class="hljs-selector-tag">img</span>图像上的第<span class="hljs-number">0</span>行到第<span class="hljs-number">2</span>行，第<span class="hljs-number">3</span>列到第<span class="hljs-number">5</span>列的像素点切出来，并且给它们赋值为<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>('请看切出来像素的值，是不是从<span class="hljs-number">0</span>变为<span class="hljs-number">255</span>了：\n', img)
cv2<span class="hljs-selector-class">.imshow</span>('two', img)
cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">20000</span>)          <span class="hljs-selector-id">#20</span>秒后就执行下面语句吧，程序别老卡在这条语句上了。
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()     #这么图片窗口都统统消失吧

请看下面图像数据长的样子吧：
 <span class="hljs-selector-attr">[[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>] 

请看切出来像素的值，是不是从<span class="hljs-number">0</span>变为<span class="hljs-number">255</span>了：
 <span class="hljs-selector-attr">[[  0   0   0 255 255 255   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0 255 255 255   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0 255 255 255   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>]

#例<span class="hljs-number">2.2</span> 读取一个灰度图像，并对其指定的像素进行修改
import cv2                                                 #倒库
lena = cv2<span class="hljs-selector-class">.imread</span>(r'C:\Users\<span class="hljs-number">25584</span>\Desktop\lena.bmp',<span class="hljs-number">0</span>)    #把lena读到内存
cv2<span class="hljs-selector-class">.imshow</span>('the first', lena)                              #用一个窗口把lena显示出来
for hang in <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>):       #A                 
    for lie in <span class="hljs-built_in">range</span>(<span class="hljs-number">80</span>, <span class="hljs-number">200</span>):
        lena[hang, lie]=<span class="hljs-number">255</span>
cv2.<span class="hljs-built_in">imshow</span>(<span class="hljs-string">'the second'</span>, lena)
cv2.<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">20000</span>)
cv2.<span class="hljs-built_in">destroyAllWindows</span>()
</code></pre>
<ul>
<li><strong>A:</strong> 代码中使用了一个双层嵌套循环把lena图像数据中的 <strong>第10行到第99行、第80列到199列</strong> 的数据索引出来，并且把这些数据重新赋值为255.</li>
<li><strong>知识点：</strong><br/>
1、容器的概念，range()函数、list列表 等都是容器。是容器就可以对里面的元素进行遍历，也就是进行循环。<br/>
2、for循环、嵌套循环，都是基础必须完全熟练。</li>
</ul>
<h4 data-id="heading-3">三、彩色图像基本知识点</h4>
<p>我们平时看到的彩色图像，不管什么格式的，一般都是RGB色彩通道模式的图片，就是图片的每个像素都有三个数字，第一个数字是R红色通道的红光强度值，第二个数字是G绿色通道的绿光强度值，第三个数字是B蓝色通道的蓝光的强度值。<br/>
但是opencv在读取彩色图片的数据时，是将图片里面的数据以行方向顺序读取，并且以BGR的默认模式存放在数组ndarray中的。就相当于把一张图片从左上角的第一个像素开始，按行依次垂直排列，拍成一条数直的长线，线上的每个点都是三个数字，但这三个数字默认的BGR通道。<br/>
image[0,0,0] 第一个参数0表示第0行，第二个参数0表示第0列，第三个参数表示第0个通道。由于opencv读出来的三个通道是BGR顺序的，所以第三个参数0在opencv中是切出来的像素点就是image这张图片中的左上角第一个像素点B通道的蓝光强度值。</p>
<pre><code class="hljs language-scss" lang="scss">#例<span class="hljs-number">2.3</span> 先生成一个三维全是<span class="hljs-number">0</span>的ndarray数组，然后切出第一个通道的数据并改为<span class="hljs-number">255</span>，然后再显示这个三维数据图像。依次类推把三个通道都操作一遍。即根据图像的通道操作整张图像。
import numpy as np
import cv2
blue = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)   #用np<span class="hljs-selector-class">.zeros</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>], dtype=np.uint8)理解这个函数
blue<span class="hljs-selector-attr">[:,:,0]</span>=<span class="hljs-number">255</span>                                  <span class="hljs-selector-id">#np</span><span class="hljs-selector-class">.zeros</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>], dtype=np.uint8)<span class="hljs-selector-attr">[:,:,0]</span>=<span class="hljs-number">255</span>，尝试用小数据切一切认识数据
<span class="hljs-built_in">print</span>(blue)
cv2<span class="hljs-selector-class">.imshow</span>('blue', blue)
<span class="hljs-built_in">print</span>('------------------------------------------------')
green = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>) 
green<span class="hljs-selector-attr">[:,:,1]</span>=<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>(green)
cv2<span class="hljs-selector-class">.imshow</span>('green', green)
<span class="hljs-built_in">print</span>('------------------------------------------------')
red = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>) 
red<span class="hljs-selector-attr">[:,:,2]</span>=<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>(red)
cv2<span class="hljs-selector-class">.imshow</span>('red', red)
<span class="hljs-built_in">print</span>('------------------------------------------------')
colorfull = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>) 
colorfull<span class="hljs-selector-attr">[:,:,0]</span>=<span class="hljs-number">255</span>     #蓝色
colorfull<span class="hljs-selector-attr">[:,:,1]</span>=<span class="hljs-number">0</span>       #绿色
colorfull<span class="hljs-selector-attr">[:,:,2]</span>=<span class="hljs-number">255</span>     #红色
<span class="hljs-built_in">print</span>(colorfull)
cv2<span class="hljs-selector-class">.imshow</span>('colorfull', colorfull)

cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">10000</span>)
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()



#例<span class="hljs-number">2.4</span>   观察一张图像的部分像素点的某个通道上的数值改变，这张图像跟着怎么变化。
import numpy as np
import cv2
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">300</span>,<span class="hljs-number">300</span>,<span class="hljs-number">3</span>),dtype=np<span class="hljs-selector-class">.uint8</span>)  #数据太多看不明白到底哪些数据被改了，就用小数据实验：<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>),dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 0:100, 0]</span>=<span class="hljs-number">255</span>     #蓝色通道                                                                   #  <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 0:1, 0]</span>=<span class="hljs-number">255</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:,100:200, 1]</span>=<span class="hljs-number">255</span>    #绿色通道                                                                    #  <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:,1:3, 1]</span>=<span class="hljs-number">255</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 200:300, 2]</span>=<span class="hljs-number">255</span>   #红色通道                                                                   #  <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 3:6, 2]</span>=<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>(img)
cv2<span class="hljs-selector-class">.imshow</span>('img', img)
cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">10000</span>)
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()



#例<span class="hljs-number">2.5</span>  手动生成一张BGR模式的彩色图像
import numpy as np
import cv2
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-built_in">print</span>(img, '\n--------- \n', img[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>], '\n--------- \n', img[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])
cv2<span class="hljs-selector-class">.imshow</span>('img', img)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0,3]</span>=<span class="hljs-number">255</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0,0]</span>=<span class="hljs-selector-attr">[66,77,88]</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,1,1]</span> = <span class="hljs-number">3</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,2]</span> = <span class="hljs-number">4</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0,2,0]</span> = <span class="hljs-number">5</span>
<span class="hljs-built_in">print</span>('\n--------- \n', img, '\n--------- \n', img[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])
cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">10000</span>)
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()



#例<span class="hljs-number">2.6</span> 读取lenacolor图片，用循环更改图片的某些区域的像素值
import cv2
lena_color = cv2<span class="hljs-selector-class">.imread</span>(r'C:\Users\<span class="hljs-number">25584</span>\Desktop\lenacolor.png') 
cv2<span class="hljs-selector-class">.imshow</span>('before', lena_color)
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">50</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>])

for <span class="hljs-selector-tag">i</span> in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>):
    for j in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):
        for k in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>):
            lena_color[i,j,k]=<span class="hljs-number">255</span>
            
for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>):
    for j in <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>):
        lena_color[i,j]=[<span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>]
        
for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>, <span class="hljs-number">150</span>):
    for j in <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>, <span class="hljs-number">300</span>):
        lena_color[i,j]=<span class="hljs-number">0</span>
        
cv2.<span class="hljs-built_in">imshow</span>(<span class="hljs-string">'after'</span>, lena_color)
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], lena_color[<span class="hljs-number">50</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>])
cv2.<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">10000</span>)
cv2.<span class="hljs-built_in">destroyAllWindows</span>()
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-id">#2</span><span class="hljs-selector-class">.7</span> 练习函数<span class="hljs-built_in">item</span>()和函数<span class="hljs-built_in">itemset</span>()的用法
import numpy as np
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randint</span>(<span class="hljs-number">10</span>, <span class="hljs-number">99</span>, size=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-built_in">print</span>(img, '\n', img.item(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))
<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">3</span>,<span class="hljs-number">2</span>), <span class="hljs-number">255</span>)
<span class="hljs-selector-tag">img</span>
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<ul>
<li>
<p><strong>np.random.randint(a,b, size, dtype)函数</strong><br/>
函数的功能是随机生成一些整数。第一个参数是要生成的数的起始值，第二个参数是最大值，第三个参数是要生成的整数的形状，第四个参数是要生成的数的类型。</p>
</li>
<li>
<p><strong>函数item(a,b)</strong><br/>
函数的功能是索引出要访问的图像的某个像素点。函数返回要索引的像素点的值。<br/>
函数有两个参数，第一个参数是像素点的行，第二个参数是像素点的列。</p>
</li>
<li>
<p><strong>函数itemset((a,b),c)</strong> 函数用来修改指定像素点的像素值。本函数直接在原图像上修改，不返回任何值。 函数有两个参数，第一个参数是要修改的像素点，第二个参数是要修改的像素的值。</p>
</li>
<li>
<p><strong>说明</strong><br/>
item()函数和itemset()都是只能索引或者修个一个像素点！！！如果我们想索引或修改一批像素点时，我们就要用循环一个个像素点进行修改！！！</p>
<p>#例2.8 生成一个像素值为随机数的灰度图像<br/>
import numpy as np
import cv2
img = np.random.randint(0,256, size=(300, 300), dtype=np.uint8)
img
cv2.imshow('demo', img)
cv2.waitKey(10000)
cv2.destroyAllWindows()</p>
<p>#例2.9 读取灰度图像lena.bmp，并对其像素值进行索引、修改<br/>
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lena.bmp', 0)
#修改一个像素点：
print(lena.item(2,3))
lena.itemset((2, 3), 255)<br/>
print(lena.item(2, 3))
#修改一个区域的像素点：
cv2.imshow('xiu gai qian', lena)
for i in range(10, 50):
for j in range(20, 100):
lena.itemset((i,j), 255)
cv2.imshow('xiu gai hou', lena)
cv2.waitKey(10000)
cv2.destroyAllWindows()</p>
</li>
</ul>
<p><img alt="" src="" loading="lazy"/></p>
<pre><code class="hljs language-css" lang="css">#例<span class="hljs-number">2.10</span> 生成一个像素值为随机数的彩色图像，练习item()函数和itemset()函数：
import numpy as np
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randint</span>(<span class="hljs-number">10</span>, <span class="hljs-number">99</span>, size=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-selector-tag">img</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,0]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2, 1]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,2]</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.item</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.item</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.item</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>), <span class="hljs-number">255</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), <span class="hljs-number">255</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), <span class="hljs-number">255</span>)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,0]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2, 1]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,2]</span>
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#例2.11 生成一个像素值为随机数的彩色图像</span>
img = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>, size=(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>), dtype=np.uint8)
cv2.imshow(<span class="hljs-string">'random colorfull img'</span>, img)
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()



<span class="hljs-comment">#例2.12 读取彩色图像lenacolor.png, 并对图像进行修改</span>
<span class="hljs-keyword">import</span> cv2
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
lena_color = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>)
cv2.imshow(<span class="hljs-string">'xiu gai qian'</span>, lena_color)
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">200</span>):
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>):
            lena_color.itemset((i,j,k),<span class="hljs-number">255</span>)
cv2.imshow(<span class="hljs-string">'xiu gai hou'</span>, lena_color)    
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<h4 data-id="heading-4">四、ROI, Region of Interest, 感兴趣区域</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#例2.13 获取lena的脸部信息，并将其显示出来</span>
<span class="hljs-keyword">import</span> cv2
lena = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>, -<span class="hljs-number">1</span>)
lena_face = lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">220</span>:<span class="hljs-number">350</span>]    <span class="hljs-comment">#用切片获取ROI</span>
cv2.imshow(<span class="hljs-string">'lena'</span>, lena)    
cv2.imshow(<span class="hljs-string">'lena face'</span>, lena_face)
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()



<span class="hljs-comment">#例2.14 给lena的脸部打码</span>
<span class="hljs-keyword">import</span> cv2
lena = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>, -<span class="hljs-number">1</span>)
cv2.imshow(<span class="hljs-string">'lena'</span>, lena)

roi_1 = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>, (<span class="hljs-number">180</span>, <span class="hljs-number">130</span>,<span class="hljs-number">3</span>), dtype=np.uint8)
lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">220</span>:<span class="hljs-number">350</span>]=roi_1
cv2.imshow(<span class="hljs-string">'color mask'</span>, lena)

roi_2 = np.zeros((<span class="hljs-number">180</span>, <span class="hljs-number">130</span>,<span class="hljs-number">3</span>),dtype=np.uint8)
roi_2[:,:,:]=<span class="hljs-number">255</span>
lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">220</span>:<span class="hljs-number">350</span>]=roi_2
cv2.imshow(<span class="hljs-string">'white mask'</span>, lena)

cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()



<span class="hljs-comment">#例2.15 将一幅图像内的ROI复制到另一幅图像内：给dollar换脸</span>
<span class="hljs-keyword">import</span> cv2
lena = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lena512.bmp'</span>, -<span class="hljs-number">1</span>)
dollar = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\dollar.bmp'</span>, -<span class="hljs-number">1</span>)
cv2.imshow(<span class="hljs-string">'lena'</span>, lena)
cv2.imshow(<span class="hljs-string">'dollar'</span>, dollar)
lena_face = lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">250</span>:<span class="hljs-number">350</span>]
dollar[<span class="hljs-number">160</span>:<span class="hljs-number">340</span>, <span class="hljs-number">200</span>:<span class="hljs-number">300</span>]=lena_face
cv2.imshow(<span class="hljs-string">'dollar2'</span>, dollar)
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()
</code></pre>
<h4 data-id="heading-5">五、通道操作</h4>
<p>一个RGB彩色图像，在opencv中，它是按照B通道-G通道-R通道 的顺序存储的。</p>
<ul>
<li>
<p>通道拆分<br/>
1、索引方式拆分<br/>
2、函数方式拆分</p>
</li>
<li>
<p>通道合并</p>
<p>#例2.16 编写程序，演示图像通道拆分及通道值改变对彩色图像的影响
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')
cv2.imshow('lena', lena)</p>
<p>b_tongdao = lena[:, :, 0]
g_tongdao = lena[:, :, 1]
r_tongdao = lena[:, :, 2]
cv2.imshow('b', b_tongdao)
cv2.imshow('g', g_tongdao)
cv2.imshow('r', r_tongdao)</p>
<p>lena[:, :, 0]=0
cv2.imshow('b_0', lena)
lena[:, :, 1]=0
cv2.imshow('g_0', lena)</p>
<p>cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
<p>#例2.17 使用函数cv2.split()函数拆图像通道, 并显示三个通道图像。
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')
b,g,r = cv2.split(lena)
cv2.imshow('b', b)
cv2.imshow('g', g)
cv2.imshow('r', r)
cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
<p>#自主练习：把一张彩图的三个通道数据分别切出来，仍以彩图形式显示图像。
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')</p>
<p>lena1 = lena.copy()
lena1[:,:,1:3]=0
cv2.imshow('b', lena1)</p>
<p>lena2 = lena.copy()
lena2[:,:,0]=0
lena2[:,:,2]=0
cv2.imshow('g', lena2)</p>
<p>lena3 = lena.copy()
lena3[:,:,0:2]=0
cv2.imshow('r', lena3)</p>
<p>cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
<p>#例2.18 通道合并，使用函数cv2.merge()函数合并通道
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')
b,g,r = cv2.split(lena)
bgr = cv2.merge([b,g,r])
rgb = cv2.merge([r,g,b])</p>
<p>cv2.imshow('bgr', bgr)
cv2.imshow('rgb', rgb)</p>
<p>cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
</li>
</ul>
<p><strong>说明：通道顺序改变后，图像的显示效果也发生了改变。</strong></p>
<h4 data-id="heading-6">六、获取图像属性</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#例2.19 观察图像的常用属性值 </span>
<span class="hljs-keyword">import</span> cv2
lena_gray = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lena.bmp'</span>,<span class="hljs-number">0</span>)  <span class="hljs-comment">#参数0表示图像被调整为单通道的灰度图像</span>
lena_color = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>)  <span class="hljs-comment">#彩色图像</span>
lena_gray.shape
lena_color.shape

lena_gray.size
lena_color.size

lena_gray.dtype
lena_color.dtype

dtype(<span class="hljs-string">'uint8'</span>)
</code></pre>
<p><strong>说明：</strong><br/>
shape属性是用来判断一幅图像是灰度图像还是彩色图像。<br/>
size属性返回的是图像的像素数目，即图像的'行x列x通道数'。灰度图像的通道数为1，彩色图像的通道数为3。<br/>
dtype属性返回图像的数据类型。</p>
<h4 data-id="heading-7">七、在图像上绘制几何图形</h4>
<p>绘制直线：cv.line(img, start, end, color, thickness) #img:要绘制直线的图像；start,end直线的起点和终点；color线条的颜色；thickness线条的宽度。<br/>
绘制圆形：cv.circle(img, centerpoint, r, color, thickness) #thickness表示线条的宽度，当这个参数=-1时生成闭合图案并填充颜色。<br/>
绘制矩形：cv.rectangle(img, leftupper, rightdown, color, thickness) #设置矩形的左上角和右下角坐标即可。<br/>
在图像中添加文字：cv.putText(img, text, station, font,fontsize, color, thickness, cv.LINE_AA) #text:要写入的文字；station:文本在图像中的放置位置(左下角)；字体、字体大小、颜色、宽度。</p>
<pre><code class="hljs language-scss" lang="scss">#例<span class="hljs-number">2.20</span> 生成一个全黑的图像，在图像上绘制上面的图形并添加文字  
import numpy as np
import cv2
import matplotlib<span class="hljs-selector-class">.pyplot</span> as plt
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), np<span class="hljs-selector-class">.uint8</span>)

cv2<span class="hljs-selector-class">.line</span>(img, (<span class="hljs-number">0</span>,<span class="hljs-number">20</span>), (<span class="hljs-number">300</span>, <span class="hljs-number">200</span>), (<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">5</span>)   #线段起点、终点、颜色、粗细
cv2<span class="hljs-selector-class">.rectangle</span>(img, (<span class="hljs-number">50</span>, <span class="hljs-number">80</span>), (<span class="hljs-number">120</span>, <span class="hljs-number">250</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>), <span class="hljs-number">3</span>)  #左上角坐标，右下角坐标
cv2<span class="hljs-selector-class">.circle</span>(img, (<span class="hljs-number">200</span>, <span class="hljs-number">200</span>),<span class="hljs-number">60</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),-<span class="hljs-number">1</span>)    #圆心坐标，半径，-<span class="hljs-number">1</span>表示圆形里面填充颜色。
cv2<span class="hljs-selector-class">.putText</span>(img, 'opencv', (<span class="hljs-number">70</span>,<span class="hljs-number">40</span>), cv2<span class="hljs-selector-class">.FONT_HERSHEY_SIMPLEX</span>, <span class="hljs-number">2</span>, (<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>), <span class="hljs-number">2</span>)   #左下角坐标

plt<span class="hljs-selector-class">.imshow</span>(img[:,:,::-<span class="hljs-number">1</span>])
plt<span class="hljs-selector-class">.title</span>('case show')
plt<span class="hljs-selector-class">.show</span>()
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LangChain 框架核心向量存储]]></title>    <link>https://juejin.cn/post/7604344066579267635</link>    <guid>https://juejin.cn/post/7604344066579267635</guid>    <pubDate>2026-02-09T02:47:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604344066579267635" data-draft-id="7604039449468059698" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LangChain 框架核心向量存储"/> <meta itemprop="keywords" content="LangChain"/> <meta itemprop="datePublished" content="2026-02-09T02:47:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="草帽lufei"/> <meta itemprop="url" content="https://juejin.cn/user/501033035632093"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LangChain 框架核心向量存储
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/501033035632093/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    草帽lufei
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:47:11.000Z" title="Mon Feb 09 2026 02:47:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;color:#3c9dff}.markdown-body h1{font-size:30px;margin-bottom:5px;padding-bottom:8px;text-align:center}.markdown-body h2{font-size:24px;padding-bottom:6px}.markdown-body h2:before{content:"🍋"}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h3:before{content:"🍓"}.markdown-body h4{font-size:16px}.markdown-body h4:before{content:"🍑"}.markdown-body h5{font-size:15px}.markdown-body h5:before{content:"🍉"}.markdown-body h6{margin-top:5px}.markdown-body h6:before{content:"🍒"}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;margin:0 auto;max-width:100%;border-radius:4px;padding:1px;border:1px solid #d2e8ff}.markdown-body img:hover{box-shadow:0 1px 3px #5eaeff}.markdown-body hr{height:4px;margin:34px 0;background-size:4px 1px;background-image:linear-gradient(270deg,#5eaeff,#f3f9ff 25%,transparent 50%);border-style:none}.markdown-body code{word-break:break-word;border-radius:3px;overflow-x:auto;background-color:#d2e8ff;color:#3c9dff;font-size:.9em;padding:.1em .5em;margin:0 3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;transition:all .3s}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:1px solid #90c7ff;border-radius:4px}.markdown-body pre:hover{box-shadow:0 1px 10px #beddff}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#3c9dff;border-bottom:1px solid #90c7ff;transition:all .3s}.markdown-body a:hover{color:#007fff;border-bottom:2px solid #5eaeff}.markdown-body a[href]:not(:empty){padding-right:18px}.markdown-body a[href]:not(:empty):after{display:inline-block;width:16px;height:16px;margin-left:2px;content:"";background:url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxwYXRoIGQ9Ik0zODQgMTI4YTQ4IDQ4IDAgMDEyLjgxNiA5NS45MkwzODQgMjI0SDI1NmEzMiAzMiAwIDAwLTMxLjkyIDI5LjZMMjI0IDI1NnY1MTJhMzIgMzIgMCAwMDI5LjYgMzEuOTJsMi40LjA4aDUxMmEzMiAzMiAwIDAwMzEuOTItMjkuNmwuMDgtMi40VjY1NmE0OCA0OCAwIDAxOTUuOTItMi44MTZMODk2IDY1NnYxMTJhMTI4IDEyOCAwIDAxLTEyNCAxMjcuOTM2bC00IC4wNjRIMjU2YTEyOCAxMjggMCAwMS0xMjcuOTM2LTEyNGwtLjA2NC00VjI1NmExMjggMTI4IDAgMDExMjQtMTI3LjkzNmw0LS4wNjRoMTI4em0zODQgMGExMjggMTI4IDAgMDExMjcuOTM2IDEyNGwuMDY0IDR2MTYwYTQ4IDQ4IDAgMDEtOTUuOTIgMi44MTZMODAwIDQxNlYyOTEuODcybC0zODIuMDY0IDM4Mi4wOGE0OCA0OCAwIDAxLTcwLjAzMi02NS42bDIuMTYtMi4yODhMNzMyLjA5NiAyMjRINjA4YTQ4IDQ4IDAgMDEtMi44MTYtOTUuOTJMNjA4IDEyOGgxNjB6IiBmaWxsPSIjM2M5ZGZmIiBmaWxsLW9wYWNpdHk9Ii41NiIgZGF0YS1zcG0tYW5jaG9yLWlkPSJhMzEzeC5zZWFyY2hfaW5kZXguMC5pMC41Yzc1M2E4MTgwa2RKWCIgY2xhc3M9InNlbGVjdGVkIi8+PC9zdmc+);background-size:100%}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #3c9dff}.markdown-body thead{text-align:center}.markdown-body thead th{color:#fff;background-color:#5eaeff}.markdown-body tr{text-align:center}.markdown-body tbody tr:hover{background-color:#d2e8ff}.markdown-body tbody tr:hover code{background-color:#90c7ff}.markdown-body tr:nth-child(2n){background-color:#ecf5ff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5eaeff}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{font-weight:900;padding:0 1px;font-size:17px}.markdown-body small{color:#cbcbcb;padding:0 1px;font-size:22px;zoom:.5}.markdown-body em{padding:0 1px}.markdown-body del{padding:0 1px;text-decoration-thickness:2px}.markdown-body blockquote{color:#1a1b1c;padding:1px 20px;margin:22px 0;border-radius:4px;border-left:4px solid rgba(60,157,255,.5);background-color:rgba(190,221,255,.3)}.markdown-body blockquote blockquote{margin:8px 0}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{margin:12px 0;padding:4px 10px;border:2px solid #3c9dff;border-radius:8px;background-color:#ecf5ff;transition:all .3s}.markdown-body details summary{cursor:pointer}.markdown-body input[type=checkbox]{position:relative;appearance:none;width:16px;height:16px;border-radius:2px;vertical-align:middle;transform:translateY(-2px);box-sizing:border-box;border:1px solid #beddff}.markdown-body input[type=checkbox]:checked{border:1px solid #5eaeff;background-color:#5eaeff}.markdown-body input[type=checkbox]:checked:before{position:absolute;top:3px;left:1px;width:11px;height:6px;background-color:transparent;border-left:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(-45deg);content:"";box-sizing:border-box}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">前言</h2>
<p>之前学习了LangChain中的嵌入，接下来学习LangChain中的向量存储</p>
<h2 data-id="heading-1">概念</h2>
<p>向量存储（Vector Store）是 LangChain 中用于存储和检索嵌入向量的组件</p>
<p>用于存储、管理文本 / 多模态数据转换后的向量，同时提供高效相似性检索能力</p>
<p>是 RAG（检索增强生成）、AI Agent 记忆、知识库问答等场景的基础，解决了大模型上下文窗口有限、无法记住海量外部知识的核心问题</p>
<h3 data-id="heading-2">什么是向量</h3>
<p>下面是自然语言处理和机器学习中的向量概念：</p>
<p>向量（Vector）是一个数值数组，用于表示文本或文档的语义信息。每个元素都代表了文本中的一个特征或维度，而向量的长度则决定了该文本的特征数量。</p>
<p>例如，考虑一个简单的文本分类任务，我们有两个类别：“情感分析”和“主题分类”。我们可以使用向量来表示每个文本的特征，例如：</p>
<ul>
<li>情感分析向量：[0.2, -0.3, 0.5]</li>
<li>主题分类向量：[-0.1, 0.4, -0.2]</li>
</ul>
<p>这些向量可以用于表示不同的文本，并且可以通过计算相似度来判断它们之间的关系</p>
<p>跨专业学习需要恶补的东西还是挺多的，概念的有时候看的也是似懂非懂(很多时候是一脸懵逼)</p>
<h2 data-id="heading-3">LangChain VectorStores 的核心功能</h2>
<p>看下常见的向量存储方案</p>
<h3 data-id="heading-4">FAISS</h3>
<p>FAISS 是 Facebook 开源的高效向量相似度检索库，全名是 Facebook AI Similarity Search。不得不感叹大厂是真叼，日常工作生活大部分都是大厂的产品和服务</p>
<p>FAISS 是 LangChain VectorStore 中最常用的本地向量存储方案之一，核心优势是开源免费、本地部署无额外成本、相似度检索速度极快，尤其适合中小规模向量数据（百万级以内）的 AI Agent、知识库问答等场景</p>
<p>这不完美匹配了我这种开发者现在的需求的吗，本地开发研究，再用个本地的知识库，用着 Ollama 跑起来的本地模型</p>
<h3 data-id="heading-5">Pinecone</h3>
<p>Pinecone 是 LangChain VectorStore 生态中托管式云向量数据库的代表，核心优势是全托管免运维、分布式高可用、超大规模向量检索快，无需本地部署索引，适配生产环境和大规模向量场景，适合需要稳定服务、不想维护底层存储的开发场景</p>
<p>Pinecone 就是云端网盘（平台托管、随时访问、支持超大文件、付费使用）</p>
<p>大规模企业级场景下用的，不适合个人学习研究场景</p>
<h3 data-id="heading-6">Chroma</h3>
<p>Chroma 是一款专为 LLM 应用设计的轻量级开源向量数据库，核心定位是「让向量存储变得简单」—— 无需复杂部署，一行代码即可启动，支持向量的存储、相似度检索、动态增删改，还能关联元数据（如文档来源、类型），像一个「专为 LLM 打造的本地向量记事本」</p>
<p>类比场景：FAISS 是一次性写入的本地 U 盘，Chroma 是可随时增删文件的本地移动硬盘，Pinecone 是云端网盘，Chroma 兼顾了本地的便捷性和动态更新的灵活性</p>
<h3 data-id="heading-7">Milvus</h3>
<p>Milvus 是 LangChain VectorStore 生态里工业级、开源、分布式、可扩展的向量数据库，主打大规模向量（亿级）、高性能检索、动态更新、高可用，是从本地开发到企业级生产的全链路向量存储方案，完美衔接 FAISS/Chroma（本地轻量）与 Pinecone（云端托管）的中间地带</p>
<p>类比：FAISS 是本地 U 盘，Chroma 是本地移动硬盘，Milvus 是本地可扩展服务器 + 云端集群，既能本地快速跑，也能支撑企业级大规模向量服务Milvus</p>
<p>上面的这些向量存储方案都实现了 <code>创建向量存储</code>、<code>相似度搜索</code>、<code>带分数的相似度搜索</code>、<code>最大边际相关性搜索</code>、<code>保存和加载</code> 等核心功能</p>
<h2 data-id="heading-8">相似度搜索的原理</h2>
<p>相似度搜索是向量存储的核心功能，基本原理是将查询文本转换为向量，计算查询向量与存储中所有向量的相似度，返回相似度最高的前几个结果</p>
<p>常用的相似度度量方法包括 <code>余弦相似度</code>、<code>欧氏距离</code>、<code>点积</code> 等</p>
<h2 data-id="heading-9">代码示例</h2>
<p>下面是 <code>FAISS</code> 向量存储的基础代码示例，其他类型的存储方案就先不写了，项目级层面用到再看</p>
<h3 data-id="heading-10">注意</h3>
<p><code>from langchain_community.embeddings import HuggingFaceEmbeddings</code> 为老版本写法，我这里运行时出现问题，需用新版本</p>
<p>新版本写法更简单，直接从 <code>langchain_huggingface</code> 导入 <code>HuggingFaceEmbeddings</code> 即可</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> FAISS
<span class="hljs-comment"># from langchain_community.embeddings import HuggingFaceEmbeddings</span>
<span class="hljs-keyword">from</span> langchain_huggingface <span class="hljs-keyword">import</span> HuggingFaceEmbeddings

<span class="hljs-comment"># 核心示例：FAISS 向量存储完整流程</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">faiss_vector_store_core_demo</span>():
    <span class="hljs-comment"># 1. 准备基础文本数据（待向量化的原始内容）</span>
    documents = [
        <span class="hljs-string">"LangChain 是用于开发语言模型应用的框架。"</span>,
        <span class="hljs-string">"FAISS 是 Facebook 开发的高效相似度搜索库。"</span>,
        <span class="hljs-string">"Embedding 模型将文本转换为数值向量表示。"</span>
    ]

    <span class="hljs-comment"># 2. 初始化嵌入模型（核心：文本转向量的工具）</span>
    <span class="hljs-comment"># 选用多语言模型，适配中文场景</span>
    embeddings = HuggingFaceEmbeddings(
        model_name=<span class="hljs-string">"sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2"</span>
    )

    <span class="hljs-comment"># 3. 创建 FAISS 向量存储（核心步骤：文本→向量→入库）</span>
    <span class="hljs-comment"># from_texts 方法会自动完成：遍历文本→调用嵌入模型生成向量→存入 FAISS 索引</span>
    vector_store = FAISS.from_texts(documents, embeddings)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">" FAISS 向量库创建完成（文本已转为向量并存储）"</span>)

    <span class="hljs-comment"># 4. 向量检索（核心功能：根据查询向量找相似文本）</span>
    query = <span class="hljs-string">"什么是 FAISS？"</span>
    <span class="hljs-comment"># similarity_search：根据查询文本生成向量，在 FAISS 中找最相似的 top-k 结果</span>
    results = vector_store.similarity_search(query, k=<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n 检索查询：<span class="hljs-subst">{query}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"检索结果：<span class="hljs-subst">{results[<span class="hljs-number">0</span>].page_content}</span>"</span>)

    <span class="hljs-comment"># 5. 向量库持久化（核心：保存到本地，避免重复生成向量）</span>
    save_path = <span class="hljs-string">"./faiss_core_index"</span>
    vector_store.save_local(save_path)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n 向量库已保存到本地：<span class="hljs-subst">{save_path}</span>"</span>)

    <span class="hljs-comment"># 6. 加载本地向量库（核心：复用已生成的向量库）</span>
    loaded_vector_store = FAISS.load_local(
        save_path, 
        embeddings,
        allow_dangerous_deserialization=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 本地加载必需参数</span>
    )
    <span class="hljs-comment"># 验证加载结果</span>
    test_query = <span class="hljs-string">"什么是 Embedding？"</span>
    loaded_result = loaded_vector_store.similarity_search(test_query, k=<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n 加载后验证 - 查询：<span class="hljs-subst">{test_query}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"验证结果：<span class="hljs-subst">{loaded_result[<span class="hljs-number">0</span>].page_content}</span>"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    faiss_vector_store_core_demo()

</code></pre>
<p>代码运行结果</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9d48fe634da48029d36b63432ce536e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I2J5bi9bHVmZWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210033&amp;x-signature=hlGz2QQ5zxPCR7kPHcg5bAd4ZI0%3D" alt="" loading="lazy"/></p>
<p>向量库持久化到本地会在项目对应目录生成 <code>faiss_core_index</code> 文件夹，包含索引文件和配置文件</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88ae14cf0d144af1a7bfb92bde6cc017~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I2J5bi9bHVmZWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210033&amp;x-signature=52lISNE80Plr%2FNe8Mh3mD2NyqXA%3D" alt="" loading="lazy"/></p>
<p>这种文件是无法直接在编辑器中打开的</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fb74d6a736b4211973e713be39f4d00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I2J5bi9bHVmZWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210033&amp;x-signature=Fzr1CxgdWnbKmNWyq2FYZIH30SI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11">小结</h2>
<p>LangChain VectorStores 向量存储相关知识就基本了解了，并了解了 FAISS 向量存储的基本原理和代码实现，其他类型目前没有合适的时机和项目场景去尝试，就不展开了</p>
<p>接下来将在本地实现一个基于知识库的问答系统，实战操作一波</p>
<blockquote>
<p>欢迎留言交流，如果觉得有帮助，可以<code>点个赞</code>支持一下</p>
<p>公众号：草帽lufei</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[全网最火的 Agent Skills 都在这了！这 7 个宝藏市场建议收藏]]></title>    <link>https://juejin.cn/post/7603854784865927208</link>    <guid>https://juejin.cn/post/7603854784865927208</guid>    <pubDate>2026-02-09T03:05:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865927208" data-draft-id="7604036853129789455" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="全网最火的 Agent Skills 都在这了！这 7 个宝藏市场建议收藏"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-09T03:05:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="悟鸣"/> <meta itemprop="url" content="https://juejin.cn/user/4107431171852270"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            全网最火的 Agent Skills 都在这了！这 7 个宝藏市场建议收藏
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4107431171852270/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    悟鸣
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:05:36.000Z" title="Mon Feb 09 2026 03:05:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近 Agent Skills 特别火，很多朋友都想找一些特别好用的、特别有用的 skills。</p>
<p>这篇文章给大家盘点一下比较知名且相对比较火爆的一些 skills 市场。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/492607feafb04371a21693726c832fc4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=S4oDZE1Ga7h%2BD6MxYF8HsRx9ZJ4%3D" alt="图片" loading="lazy"/></p>
<p>Anthropic 官方市场：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a>  ，官方的咱就不用多说了。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/405379c69ee74abe8c821173f724a9ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=uVMGEC7PqxyLZ9OkACeJioaSG5M%3D" alt="图片" loading="lazy"/></p>
<p>Anthropic 黑客松冠军大佬的：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faffaan-m%2Feverything-claude-code" target="_blank" title="https://github.com/affaan-m/everything-claude-code" ref="nofollow noopener noreferrer">github.com/affaan-m/ev…</a></p>
<p>不仅包括 skills，还包括 commands、subagents、rules、hooks 等，搞 AI Coding 一定不能错过。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3bdeb4d54c6b417b840aa0316fe25370~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=dUb7thzNve3PbwluuyOKulV0CEM%3D" alt="图片" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fobra%2Fsuperpowers" target="_blank" title="https://github.com/obra/superpowers" ref="nofollow noopener noreferrer">github.com/obra/superp…</a>  另外一个比较火爆的 Coding 相关的仓库。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b74f456ac1e42b790b86431e4a0284f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=602rvJyRpZsYxqI6BU7U4fpZAOg%3D" alt="图片" loading="lazy"/></p>
<p>我的 Skills 插件市场（夹带一下私货，哈哈，完全免费）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchujianyun%2Fskills" target="_blank" title="https://github.com/chujianyun/skills" ref="nofollow noopener noreferrer">github.com/chujianyun/…</a>  包括提示词自动优化和 skills 自动同步。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec6e915e6e8441fe89596151b9c124c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=e2cxr2vyMtMMnwaWAYBaWv4sDTw%3D" alt="图片" loading="lazy"/></p>
<p>很多朋友写提示词时存在两个痛点，一个是可能会说得不够清楚，存在歧义，还有一个痛点就是不知道有哪些专业的框架记不住，然后也不会写。</p>
<p>身边有朋友做 AI  业务自己写一个初版提示词，然后用我的提示词自动优化 skill 匹配最专业的框架，然后澄清和进行优化，反馈效果有提升。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be287f7690b24d6f893fe86e3fed3695~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=ICD%2B2EnyyGkx%2FE7UHSQuBsyn2fM%3D" alt="图片" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fskills.sh%2F" target="_blank" title="https://skills.sh/" ref="nofollow noopener noreferrer">skills.sh/</a>  这个网站的最大特色就是支持一个指令，自动检测多个知名 Agent，自动一键安装。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2f6df4ace104d6e82ce4741c50cb3c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=oMsCRRrb5QG4OVYnnsVWH6lsH28%3D" alt="图片" loading="lazy"/></p>
<p>Qoder 社区 <a href="https://link.juejin.cn?target=https%3A%2F%2Fqoder-community.pages.dev%2Fzh%2Fskills%2F" target="_blank" title="https://qoder-community.pages.dev/zh/skills/" ref="nofollow noopener noreferrer">qoder-community.pages.dev/zh/skills/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f655c1c3b7344b5be55dec89a69577e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=k882SUB0l%2FRhsCDOdNNX3dS4yo0%3D" alt="图片" loading="lazy"/></p>
<p>这里提供了很多 skills，比较大的特色就是按照岗位进行分类。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ced235b80bec45f38117d78454a7af1f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=6M5ewUckYyJinLzt6EWENgSwzdo%3D" alt="图片" loading="lazy"/></p>
<p>官方也会精选一些高质量的 skills。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51a49cb0358b42de80637cb70f225d65~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=ud%2BNfcWxhRHGHkYvaJDVAk1s%2FJg%3D" alt="图片" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fskillsmp.com%2F" target="_blank" title="https://skillsmp.com/" ref="nofollow noopener noreferrer">skillsmp.com/</a>  可以看到 skills 的增长趋势。里面的 skills 非常齐全，而且支持分类和排序。</p>
<hr/>
<p>你还有其他非常好的 skills 插件和聚合市场？欢迎留言补充！</p>
<p>欢迎关注我的公众号：<strong>悟鸣AI</strong>，后续会陆续分享比较有用的 AI 工具和比较好的 AI 经验，比较客观理性的 AI 观点等。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/274f08d089e94a15b0e0636a834f983d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=EzbZBGqHFdAI04PIul6sCDMtelk%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[单点登录（SSO）系统]]></title>    <link>https://juejin.cn/post/7604080364354043931</link>    <guid>https://juejin.cn/post/7604080364354043931</guid>    <pubDate>2026-02-09T03:07:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604080364354043931" data-draft-id="7604080364353962011" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="单点登录（SSO）系统"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T03:07:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Aniugel"/> <meta itemprop="url" content="https://juejin.cn/user/3034307824198407"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            单点登录（SSO）系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3034307824198407/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Aniugel
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:07:21.000Z" title="Mon Feb 09 2026 03:07:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、整体架构设计（核心原则）</h3>
<p>先明确整体流程和核心约束，确保 Cookies 仅存储在认证中心域名下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc3290f3e98a42318021eae316cebada~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQW5pdWdlbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211240&amp;x-signature=dD7QRuoDyilshbCVGxgN2XepNUc%3D" alt="deepseek_mermaid_20260209_441885.png" loading="lazy"/></p>
<p>核心约束：</p>
<ul>
<li>仅 <strong>SSO 认证中心域名</strong> 下存储登录态 Cookie（如 <code>sso_token</code>）；</li>
<li>各业务系统前端<strong>不存储任何登录态 Cookie</strong>，仅在内存 /localStorage 存储临时业务 token；</li>
<li>跨域登录态通过「授权码模式」传递，避免 Cookie 跨域问题。</li>
</ul>
<h3 data-id="heading-1">二、各角色职责与提供的服务</h3>
<h4 data-id="heading-2">1. 前端（Vue3）：核心职责是「无 Cookie 登录态管理 + 跨域认证跳转」</h4>
<h5 data-id="heading-3">核心职责</h5>








































<table><thead><tr><th>职责项</th><th>具体操作</th><th>技术实现</th></tr></thead><tbody><tr><td>登录态检测</td><td>初始化时检测当前是否有有效业务 token，无则跳转认证中心</td><td>路由守卫（beforeEach）</td></tr><tr><td>认证跳转</td><td>拼接认证中心地址 + 业务系统回调地址，跳转至 SSO 登录页</td><td>动态拼接 URL 参数</td></tr><tr><td>授权码处理</td><td>认证中心重定向回业务系统时，解析 URL 中的授权码</td><td>URLSearchParams</td></tr><tr><td>临时 token 管理</td><td>存储业务后端返回的临时 token（内存 /localStorage），无 Cookie</td><td>Pinia/Vuex + 内存变量</td></tr><tr><td>接口请求拦截</td><td>所有接口请求携带临时 token（Header 中），无 Cookie 传递</td><td>Axios 拦截器</td></tr><tr><td>登出处理</td><td>跳转认证中心登出接口，清除本地临时 token</td><td>跳转 SSO 登出地址 + 清除本地存储</td></tr></tbody></table>
<h5 data-id="heading-4">前端提供的服务</h5>
<ul>
<li>标准化的认证跳转组件（可复用的 SSO 登录跳转逻辑）；</li>
<li>统一的 token 管理工具（Pinia/Vuex 模块，封装 token 增删查）；</li>
<li>跨域认证回调处理页面（callback.vue）；</li>
<li>无 Cookie 的接口请求封装（Axios 拦截器）。</li>
</ul>
<h4 data-id="heading-5">2. 后端：核心职责是「授权码校验 + 业务 token 生成 + 跨域认证接口」</h4>
<h5 data-id="heading-6">核心职责（分「认证中心后端」和「业务系统后端」）</h5>













































<table><thead><tr><th>角色</th><th>职责项</th><th>具体操作</th></tr></thead><tbody><tr><td>认证中心后端</td><td>登录接口</td><td>验证用户名密码，生成 sso_token，存储至认证中心 Cookie（仅本域名）</td></tr><tr><td>认证中心后端</td><td>授权码生成</td><td>验证业务系统合法性，生成一次性授权码，重定向回业务系统</td></tr><tr><td>认证中心后端</td><td>授权码校验</td><td>接收业务后端的校验请求，验证授权码有效性，返回 sso_token</td></tr><tr><td>认证中心后端</td><td>登出接口</td><td>清除认证中心 Cookie 中的 sso_token，并重定向至各业务系统登出页</td></tr><tr><td>业务系统后端</td><td>授权码兑换</td><td>接收前端的授权码，调用认证中心接口校验，获取 sso_token</td></tr><tr><td>业务系统后端</td><td>业务 token 生成</td><td>基于 sso_token 生成业务系统专属临时 token（JWT），返回前端</td></tr><tr><td>业务系统后端</td><td>接口鉴权</td><td>校验前端携带的业务 token，无 Cookie 校验</td></tr></tbody></table>
<h5 data-id="heading-7">后端提供的服务</h5>
<ul>
<li>认证中心：登录 / 登出 / 授权码生成 / 授权码校验接口；</li>
<li>业务系统：授权码兑换接口、业务 token 校验接口、统一鉴权拦截器；</li>
<li>跨域配置：允许业务系统前端跨域调用认证中心接口（CORS 配置）；</li>
<li>安全策略：Cookie 的 HttpOnly/Secure/SameSite 配置，防止 CSRF/XSS。</li>
</ul>
<h4 data-id="heading-8">3. 运维：核心职责是「域名 / 网络配置 + 安全策略 + 部署运维」</h4>
<h5 data-id="heading-9">核心职责</h5>








































<table><thead><tr><th>职责项</th><th>具体操作</th><th>技术实现</th></tr></thead><tbody><tr><td>域名规划</td><td>独立的认证中心域名（如<a href="https://link.juejin.cn?target=https%3A%2F%2Fsso.yourdomain.com" target="_blank" title="https://sso.yourdomain.com" ref="nofollow noopener noreferrer">sso.yourdomain.com</a>），与业务系统域名隔离</td><td>DNS 解析配置</td></tr><tr><td>HTTPS 配置</td><td>所有域名强制 HTTPS（Cookie 的 Secure 属性要求）</td><td>Nginx 配置 + SSL 证书部署</td></tr><tr><td>跨域配置</td><td>Nginx 层面配置 CORS，允许业务系统跨域访问认证中心</td><td>Nginx 的 add_header Access-Control-*</td></tr><tr><td>Cookie 安全配置</td><td>确保认证中心 Cookie 仅在本域名生效，禁止跨域携带</td><td>Nginx / 后端双重配置 Cookie 属性</td></tr><tr><td>部署架构</td><td>认证中心服务高可用部署，业务系统与认证中心网络互通</td><td>负载均衡（LB）+ 集群部署</td></tr><tr><td>日志监控</td><td>监控认证中心登录 / 登出日志，排查跨域认证问题</td><td>ELK/Prometheus + Grafana</td></tr></tbody></table>
<h5 data-id="heading-10">运维提供的服务</h5>
<ul>
<li>独立的 SSO 认证中心域名及 SSL 证书部署；</li>
<li>各业务系统域名与认证中心域名的 DNS 解析；</li>
<li>Nginx 层面的 HTTPS 强制跳转、CORS 配置、Cookie 安全配置；</li>
<li>认证中心服务的高可用部署（集群 / 负载均衡）；</li>
<li>日志监控系统（认证中心登录日志、跨域访问日志）；</li>
<li>安全策略配置（WAF 防护、接口限流、Cookie 防篡改）。</li>
</ul>
<h3 data-id="heading-11">三、关键安全注意事项</h3>
<ol>
<li>认证中心 Cookie 必须配置：<code>HttpOnly=true</code>（防止 XSS）、<code>Secure=true</code>（仅 HTTPS）、<code>SameSite=Strict</code>（禁止跨域携带）；</li>
<li>授权码必须是<strong>一次性、短期有效</strong>（如 5 分钟），防止复用；</li>
<li>业务系统临时 token 建议<strong>短期有效</strong>（如 2 小时），前端定期静默刷新（调用业务后端刷新接口，再调用认证中心校验 sso_token）；</li>
<li>所有接口必须 HTTPS，防止 token 明文传输。</li>
</ol>
<h3 data-id="heading-12">总结</h3>
<ol>
<li><strong>前端（Vue3）</strong> ：核心是「无 Cookie 登录态管理」，通过路由守卫跳转认证中心，解析授权码兑换临时 token，接口请求携带 token（Header）；</li>
<li><strong>后端</strong>：认证中心负责生成 sso_token 并存储至自身 Cookie，业务系统负责校验授权码、生成业务临时 token；</li>
<li><strong>运维</strong>：核心是域名隔离、HTTPS 配置、Cookie 安全策略，确保仅认证中心存储 Cookie，杜绝跨域 Cookie 风险。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python——彻底明白Super() 该如何使用]]></title>    <link>https://juejin.cn/post/7603854784865796136</link>    <guid>https://juejin.cn/post/7603854784865796136</guid>    <pubDate>2026-02-09T02:52:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865796136" data-draft-id="7603584155785691186" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python——彻底明白Super() 该如何使用"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-09T02:52:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AbsoluteLogic"/> <meta itemprop="url" content="https://juejin.cn/user/2068626334032586"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python——彻底明白Super() 该如何使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2068626334032586/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AbsoluteLogic
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:52:14.000Z" title="Mon Feb 09 2026 02:52:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">什么是Super()</h3>
<p>如果把类比作表演者的话，<code>Super()</code>则是按照清单（MRO）让下一位表演者“继续”他的表演</p>
<p>没听明白没关系，我们通过实际的例子来逐步拆解<code>Super()</code>的运行逻辑，到时候我们就能明白这句话的含义</p>
<h3 data-id="heading-1">为什么要用Super()</h3>
<p>和拆解<code>Property</code>一样，我们在拆解<code>Super()</code>前也要知道我们为什么要用它</p>
<p>我们同样通过实际的代码示例来理解</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicOrder</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, price</span>):
        self.price = price
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 返回基础价格</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price * <span class="hljs-number">0.9</span>
        <span class="hljs-comment"># 返回会员折后价</span>
        
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PromotionOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> self.price - <span class="hljs-number">20</span>
            <span class="hljs-comment"># 满减条件</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.price
        
a = BasicOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(a.get_total())
<span class="hljs-comment"># 原价</span>
b = MemberOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(b.get_total())
<span class="hljs-comment"># 会员折后价</span>
c = PromotionOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(c.get_total())
<span class="hljs-comment"># 满减价格</span>
</code></pre>
<p>我们定义了两种折扣机制，一种是会员价，一种是满减。我们可以根据不同的折扣方式，算出打折后的价格</p>
<p>但是，有一种情况我们并没有考虑，那就是两种折扣同时触发的情况。如果我们规定，当两个折扣方式同时满足时，先计算会员折后价，再考虑满减，我们该如何修改这段代码呢？</p>
<p>很简单，我们再定义一个类，就像这样</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicOrder</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, price</span>):
        self.price = price

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 返回基础价格</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price * <span class="hljs-number">0.9</span>
        <span class="hljs-comment"># 返回会员折后价</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PromotionOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> self.price - <span class="hljs-number">20</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 触发满减</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(<span class="hljs-title class_ inherited__">MemberOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        member_price = MemberOrder.get_total(self)
        <span class="hljs-keyword">if</span> member_price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> member_price - <span class="hljs-number">20</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> member_price
        
a = BasicOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(a.get_total())
<span class="hljs-comment"># 原价</span>
b = MemberOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(b.get_total())
<span class="hljs-comment"># 会员折后价</span>
c = PromotionOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(c.get_total())
<span class="hljs-comment"># 满减价格</span>
d = FinalOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(d.get_total())
<span class="hljs-comment"># 双重折扣后的价格</span>
</code></pre>
<p>如果要更换折扣顺序，先计算满减，再计算会员价，只要对<code>FinalOrder</code>进行修改就好</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(<span class="hljs-title class_ inherited__">PromotionOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        count_price = PromotionOrder.get_total(self)
        <span class="hljs-keyword">return</span> count_price * <span class="hljs-number">0.9</span>
</code></pre>
<p>我们这种修改，在类的数量也就是折扣方式比较少时没什么问题。但如果类的数量比较多，我们就要想办法，如何不用进行这么复杂的修改。这就是我们使用<code>super()</code>的原因</p>
<h3 data-id="heading-2">Super()的作用</h3>
<p>我们用<code>super()</code>对上面的代码进行优化</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicOrder</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, price</span>):
        self.price = price

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 返回基础价格</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total() * <span class="hljs-number">0.9</span>
        <span class="hljs-comment"># 返回会员折后价</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PromotionOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">super</span>().self.price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total() - <span class="hljs-number">20</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total()
        <span class="hljs-comment"># 触发满减</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(MemberOrder, PromotionOrder):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total()
        
a = BasicOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(a.get_total())
<span class="hljs-comment"># 原价</span>
b = MemberOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(b.get_total())
<span class="hljs-comment"># 会员折后价</span>
c = PromotionOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(c.get_total())
<span class="hljs-comment"># 满减价格</span>
d = FinalOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(d.get_total())
<span class="hljs-comment"># 双重折扣后的价格</span>
<span class="hljs-built_in">print</span>(FinalOrder.mro())
<span class="hljs-comment"># 打印Mro清单</span>
</code></pre>
<p>我们要注意最后的<code>Mro清单</code>，它的输出结果是<code>[&lt;class '__main__.FinalOrder'&gt;, &lt;class '__main__.MemberOrder'&gt;, &lt;class '__main__.PromotionOrder'&gt;, &lt;class '__main__.BasicOrder'&gt;, &lt;class 'object'&gt;]</code>。这也就是当我们计算<code>FinalOrder</code>中的最后价格时，程序的执行顺序</p>
<p>python按照这个顺序，先从<code>FinalOrder-MemberOrder-PromotionOrder-BasicOrder</code>这个链条进行递进寻找，然后再从反方向<code>BasicOrder-PromotionOrder-MemberOrder-FinalOrder</code>进行回归计算</p>
<p>上面的代码就是按照这个顺序，先把原价<code>BasicOrder</code>给<code>PromotionOrder</code>计算满减，再将满减后的值给<code>MemberOrder</code>计算会员折扣价，最后把值给<code>FinalOrder</code></p>
<p><code>return super().get_total()</code>其实就可以理解为<code>请MRO链条上的下一位先算出结果给我</code></p>
<p>如果我们需要改变折扣计算的方式，我们也无须对<code>FinalOrder</code>中的内容进行修改，只需要修改继承顺序，也就是对这个“链条”进行调整就好</p>
<p>当我们修改某些类名时，我们也不用像之前的“硬编码”那样逐个修改，只要确保继承的类名正确，<code>super()</code>会自己按照MRO这个链条进行寻找</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(PromotionOrder, MemberOrder):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total()
</code></pre>
<h3 data-id="heading-3">结语</h3>
<p>如果文章中有什么错误或者可以优化的地方，欢迎大家指正，感谢！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端视角详解 Agent Skill]]></title>    <link>https://juejin.cn/post/7604012106154754094</link>    <guid>https://juejin.cn/post/7604012106154754094</guid>    <pubDate>2026-02-09T03:14:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604012106154754094" data-draft-id="7604646882015232051" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端视角详解 Agent Skill"/> <meta itemprop="keywords" content="前端,JavaScript,后端"/> <meta itemprop="datePublished" content="2026-02-09T03:14:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="随意_"/> <meta itemprop="url" content="https://juejin.cn/user/4222562141210478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端视角详解 Agent Skill
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4222562141210478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    随意_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:14:42.000Z" title="Mon Feb 09 2026 03:14:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>在 AI 赋能前端开发的浪潮中，Agent 已从“辅助聊天”升级为“可落地的开发助手”，而 Agent Skill（智能体技能）正是让 Agent 摆脱“只会说不会做”、真正适配前端开发场景的核心能力支撑。对于前端开发者而言，Agent Skill 不是抽象的技术概念，而是能直接降低重复工作、规范开发流程、提升协作效率的实用工具——小到组件模板生成、代码格式化，大到批量重构、接口联调校验，都能通过定制 Skill 实现自动化落地。</p>
<p>本文将完全贴合前端开发实际，从 Agent Skill 的出现背景、核心价值、Cursor 实操 demo、加载逻辑、高级用法（Reference/Script 加载）、Token 消耗解析，到与 MCP 的核心区别，逐一拆解，让你既能快速上手使用，也能理解底层逻辑，真正把 Agent Skill 融入日常开发。</p>
<h2 data-id="heading-1">一、Agent Skill 出现背景：前端开发中，AI 的“痛点”催生需求</h2>
<p>在 Agent Skill 出现之前，前端开发者使用 AI 工具（如 Cursor、Copilot）时，始终面临三个无法解决的核心痛点，这些痛点直接限制了 AI 从“辅助工具”向“高效助手”的跨越，也正是 Agent Skill 诞生的核心原因：</p>
<h3 data-id="heading-2">1. 重复Prompt，效率低下</h3>
<p>前端开发中存在大量“固定流程类”工作，比如“生成符合项目规范的 Vue3 组件”，“格式化 Axios 请求拦截器”，“检查代码中的 ESLint 错误并修复”。每次使用 AI 时，都需要重复输入冗长的 Prompt，明确项目规范、代码风格、功能要求——比如每次生成组件，都要说明“使用 Setup 语法糖、配合 TailwindCSS、Props 需做类型校验、包含 emits 声明”，重复操作占用大量开发时间。</p>
<h3 data-id="heading-3">2. 上下文割裂，适配性差</h3>
<p>AI 无法“记住”项目的个性化规则：比如项目中自定义的工具函数、接口请求规范、路由配置逻辑、UI 组件库的封装规范等。每次提问都需要重新提供这些上下文，否则生成的代码会与项目脱节（比如生成的按钮组件不匹配项目封装的 Button 组件、接口请求未遵循全局拦截器规则），后续需要手动修改，反而增加工作量。</p>
<h3 data-id="heading-4">3. 能力局限，无法联动执行</h3>
<p>传统 AI 只能“生成代码”，无法“执行操作”：比如生成批量修改文件名的脚本后，需要开发者自己复制脚本、在终端执行；生成接口文档后，无法自动关联到项目的 Swagger 文档中；发现代码中的路径错误后，无法自动定位并修改。AI 与实际开发流程脱节，无法形成“提出需求→AI 处理→完成落地”的闭环。</p>
<p>为了解决这些痛点，Agent Skill 应运而生——它本质是“给 Agent 预设的、可复用的技能模板”，把前端开发中的固定流程、项目规范、操作逻辑，封装成 Agent 能直接调用的“技能”，无需重复 Prompt、无需反复提供上下文，Agent 就能精准适配项目需求，甚至联动执行相关操作，真正实现“一次封装，多次复用”的高效开发模式。</p>
<h2 data-id="heading-5">二、Agent Skill 核心价值：解决前端 AI 开发的 3 大痛点</h2>
<p>结合前端开发场景，Agent Skill 的核心价值的是“标准化、自动化、可复用”，精准解决上述痛点，具体落地为 3 点，每一点都能直接提升开发效率：</p>
<ol>
<li><strong>省去重复 Prompt</strong>：将项目规范、操作流程封装成 Skill，调用时只需输入简单指令（如“生成用户卡片组件”），Agent 就会按照 Skill 中的预设规则执行，无需重复说明细节；</li>
<li><strong>关联项目上下文</strong>：Skill 可内置项目的个性化配置（如工具函数、接口规范、组件风格），Agent 调用 Skill 时自动加载这些上下文，生成的代码直接适配项目，无需手动修改；</li>
<li><strong>联动执行操作</strong>：通过 Skill 中的脚本（Script）和参考资料（Reference），Agent 不仅能生成代码，还能执行脚本、读取参考文档，实现“生成→执行→校验”的闭环（如批量重构代码、自动校验接口参数）。</li>
</ol>
<p>简单来说，Agent Skill 就像给前端 AI 助手“制定了详细的工作手册”，手册中明确了“做什么、怎么做、遵循什么规则、需要用到什么资料”，让 AI 从“只会猜”变成“懂规则、会操作”的专属助手，这也是其与传统 Prompt 最大的区别。</p>
<h2 data-id="heading-6">三、实操 Demo：用 Cursor 玩转 Agent Skill</h2>
<p>Cursor 是前端开发者最常用的 AI 代码编辑器，其内置的 Agent Skill 功能简洁、易上手，完全贴合前端开发场景。下面我们以“前端最常用的 2 个场景”为例，一步步演示 Agent Skill 的安装、配置、调用全过程，新手也能快速上手（全程无需复杂操作，纯前端视角，不涉及后端部署）。</p>
<p>前置准备：确保 Cursor 已更新至最新版本，我是用的 目前是 <code>2.4.28</code>，打开 Cursor 设置（Ctrl+Shift+J / Cmd+Shift+J），开启“Agent Skills”开关（默认开启）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41f6b5003c3946c691c1f9796d6e5c4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=ntDelE5KLq9%2BIgqwcX5l%2BnU2mbY%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">Demo 1：基础用法——封装“Vue3 组件生成 Skill”，一键生成符合项目规范的组件</h3>
<p>场景：前端项目中，所有 Vue3 组件都需遵循“Setup 语法糖+TailwindCSS+Props 类型校验+emits 声明”的规范，每次生成组件都要重复说明，我们通过封装 Skill 解决这个问题。</p>
<ol>
<li>
<p>打开 Cursor，进入当前前端项目（如 Vue3+Tailwind 项目）；</p>
</li>
<li>
<p>开 Cursor 设置（Ctrl+Shift+J / Cmd+Shift+J）,点击创建 skills</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d69ddd424c914b188782d32e8422c565~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=Qr50YqXveCoRA%2BWB19k3WS9dn%2Bo%3D" alt="image.png" loading="lazy"/>
3. 此时agent对话框展开，使用agent生成 对应的skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e04c9aefac7144aeafcd219f09162a26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=%2FSCGPBMkf7A4hkgO7i97Gzi0CEI%3D" alt="image.png" loading="lazy"/></p>
<ol start="4">
<li>可以看见 已经生成了 项目级别的  skill</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b5649f08cf4f442682c084544c8233de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=hZ7u8V1Ad%2BYOWjUGXCVH3LsugyU%3D" alt="image.png" loading="lazy"/></p>
<p>你也可以复制对应的 提示词</p>
<pre><code class="hljs language-md" lang="md">
/create-skill Help me create this skill for Cursor: /create-skill Help me create this skill for Cursor: 名字为：vue3-component-gen 适用范围是这个 vue3-skills的 项目， 内容规则为： # Vue3 组件生成技能（前端专用）

<span class="hljs-section">## 技能描述</span>

根据用户需求，生成符合项目规范的 Vue3 单文件组件（SFC），严格遵循以下规则：

<span class="hljs-bullet">1.</span> 语法：使用 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span> 语法糖，不使用 Options API；

<span class="hljs-bullet">2.</span> 样式：使用 TailwindCSS，不写原生 CSS，样式需简洁、适配响应式；

<span class="hljs-bullet">3.</span> Props：所有传入参数需用 defineProps 定义，并做类型校验（使用 TypeScript）；

<span class="hljs-bullet">4.</span> Emits：组件触发的事件需用 defineEmits 声明，明确事件参数类型；

<span class="hljs-bullet">5.</span> 结构：模板结构清晰，包含注释，组件根节点使用 div，添加基础样式类；

<span class="hljs-bullet">6.</span> 依赖：不引入项目中未使用的依赖，如需使用 UI 组件，仅使用 Element Plus。

  


<span class="hljs-section">## 使用场景</span>

用户输入“生成XX组件”“写一个XX组件”时，自动触发该技能，无需额外提示。

  


<span class="hljs-section">## 示例</span>

用户需求：生成用户卡片组件（包含头像、姓名、手机号）

生成结果需符合上述所有规则，Props 包含 avatar（字符串）、name（字符串）、phone（字符串），emits 包含 click（参数为用户信息对象）。
</code></pre>
<h4 data-id="heading-8">步骤 2：调用 Skill，一键生成组件</h4>
<ol>
<li>
<p>重启 Cursor（确保 Skill 被识别）；</p>
</li>
<li>
<p>打开 Cursor 的 Agent 聊天框（Ctrl+L / Cmd+L），输入简单指令：<code>生成用户卡片组件，包含头像、姓名、手机号、邮箱， 使用的哪些skill 请你列出来</code>；</p>
</li>
<li>
<p>无需额外补充规范，Cursor 会自动触发 <code>vue3-component-gen</code> Skill，生成符合项目规范的组件代码，直接复制使用即可（无需手动修改语法、样式规范）。</p>
</li>
</ol>
<p>效果如下 ，注意会列出 使用的 skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89b3a2da962e41ca920c5c018924473d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=FzNltfQpDXrDZMhazpPKxqrB%2BmQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bac39798999c4cf285199f2b7c11680c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=%2BQWxIZVO8FqttxLGMYepST6XjPo%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce77f31abc2b439da225d3b12971e482~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=3aSaiuspn9PmKJl2KNEeO9320JE%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-9">Demo 2：进阶用法——封装“ESLint 错误修复 Skill”，自动修复代码规范问题</h3>
<p>场景：前端项目使用 ESLint 规范代码（如禁止 var 声明、强制使用单引号、禁止console.log），每次写完代码都要手动修复 ESLint 错误，效率低下，我们通过 Skill 实现自动修复。</p>
<p>创建的流程如第一demo，提示词如下</p>
<pre><code class="hljs language-md" lang="md">/create-skill Help me create this skill for Cursor: 帮我创建 名字是：eslint-fix 作用域是当前项目，内容是 # ESLint 错误修复技能（前端专用）

<span class="hljs-section">## 技能描述</span>

识别用户提供的前端代码（JS/TS/Vue）中的 ESLint 错误，自动修复，严格遵循项目 ESLint 规范：

<span class="hljs-bullet">1.</span> 变量声明：禁止使用 var，优先使用 const，可变变量使用 let；

<span class="hljs-bullet">2.</span> 引号：所有字符串强制使用单引号，禁止双引号；

<span class="hljs-bullet">3.</span> 控制台输出：禁止使用 console.log、console.warn 等控制台打印语句，直接删除；

<span class="hljs-bullet">4.</span> 分号：语句结尾不添加分号（适配前端项目常见规范）；

<span class="hljs-bullet">5.</span> 缩进：使用 2 个空格缩进，禁止使用 Tab；

<span class="hljs-bullet">6.</span> 结尾：修复后，需输出修复说明（列出修复的错误类型及数量）。

  


<span class="hljs-section">## 使用场景</span>

用户输入“修复这段代码的 ESLint 错误”“ESLint 校验修复”，或直接粘贴存在 ESLint 错误的代码，自动触发该技能。

  


<span class="hljs-section">## 注意事项</span>

修复时不改变代码原有功能，仅修复 ESLint 规范相关问题；若有无法自动修复的错误，需提示用户手动修改。
</code></pre>
<p>创建成功 你可以看到 多了一个 <code>eslint-fix</code>的skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5564d8bee9b94746badfca100fa385c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=49qRv1PaSXEYV7GKk%2FzJKc90N5E%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-10">步骤 2：调用 Skill 修复代码</h4>
<ol>
<li>在项目中 创建一个js文件 输入有eslint报错的 js如下</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d51612945ce49cf9564beae90174c08~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=JqJXha%2BfU5pdzxAXW0XxLYuFum4%3D" alt="image.png" loading="lazy"/></p>
<ol start="2">
<li>选中 并添加 chat，你可以使用  <code>ctrl+k</code> 快捷键实现</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/722205a0ed4b4725bf53093c193ce210~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=4wqF7YWP0Rb4WeNIKj%2BBwvl%2BXDc%3D" alt="image.png" loading="lazy"/></p>
<ol start="3">
<li>在 Agent 聊天框中输入指令：<code>修复这段代码的 ESLint 错误 ，并列出你使用了哪些skill</code></li>
<li>Cursor 自动触发 <code>eslint-fix</code> Skill，修复后的代码如下（完全符合规范），并输出修复说明</li>
</ol>
<p>可以看见 被修复了 列出了 修改的 内容说明</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc391effcb9d458a9de501560d7ef195~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=LRcPF2Q1%2F%2BUKh0qpYRsEszioJBM%3D" alt="image.png" loading="lazy"/></p>
<p>通过这两个 Demo 可以发现，Agent Skill 完全贴合前端开发的实际需求，核心是“一次封装，无限复用”，把重复、机械的工作交给 AI，开发者专注于核心业务逻辑——这也是 Agent Skill 最受前端开发者欢迎的原因。</p>
<h2 data-id="heading-11">四、Agent Skill 高级用法：Reference 与 Script 加载方式</h2>
<p>对于前端开发者而言，基础的 Skill（仅配置 SKILL.md）只能满足“生成、修复代码”等简单场景；而高级用法——Reference（参考资料加载）和 Script（脚本加载），能让 Agent Skill 实现更复杂的前端开发需求（如接口联调、批量重构、规范校验），也是前端开发者需要重点掌握的内容。</p>
<p>下面我们分别拆解 Reference 和 Script 的核心作用、加载方式，结合前端实际场景（如接口联调、批量修改组件名称），让你能直接落地使用。</p>
<h3 data-id="heading-12">1. Reference 加载：按需加载“参考资料”，让 Skill 更贴合项目</h3>
<h4 data-id="heading-13">核心作用</h4>
<p>Reference 是 Agent Skill 的“参考资料库”，可存放前端项目中的个性化配置、规范文档、接口信息等，Skill 执行时，按需加载这些资料，让生成的代码、执行的操作完全适配项目——比如存放项目的接口文档、ESLint 配置、UI 组件封装规范等，避免每次调用 Skill 都手动提供这些上下文，本质是“给 Skill 提供项目专属的‘知识库’”。</p>
<h4 data-id="heading-14">前端常用场景</h4>
<ul>
<li>
<p>场景 1：接口联调 Skill，加载项目的接口文档（如 Swagger 导出的 JSON 文件），生成符合接口规范的请求代码（自动匹配接口地址、请求方式、参数类型）；</p>
</li>
<li>
<p>场景 2：组件生成 Skill，加载项目的 UI 组件封装规范（如自定义 Button、Card 组件的使用文档），生成的组件自动复用项目封装的 UI 组件；</p>
</li>
<li>
<p>场景 3：路由配置 Skill，加载项目的路由规范（如路由命名规则、嵌套路由配置要求），生成符合规范的路由配置代码。</p>
</li>
</ul>
<h4 data-id="heading-15">加载方式（结合 Cursor 实操）</h4>
<p>Reference 的加载方式是“条件触发、按需加载”，步骤如下（贴合前端项目结构）：</p>
<ol>
<li>步骤 1：在 Skill 文件夹中，创建 <code>reference</code> 子文件夹（固定名称，Cursor 会自动识别）；</li>
<li>步骤 2：将需要的参考资料放入该文件夹（支持多种格式：.md、.json、.js、.txt 等，前端常用 .md 文档和 .json 接口文档）；</li>
<li>步骤 3：在 SKILL.md 中，明确“加载条件”——即“什么时候需要加载这份参考资料”；</li>
<li>步骤 4：调用 Skill 时，当满足加载条件，Cursor 会自动加载对应的 Reference 文件，执行完成后自动释放。</li>
</ol>
<h4 data-id="heading-16">实操示例：接口请求 Skill 加载 Reference 接口文档</h4>
<ol>
<li>
<p>新建 Skill  <code>api-request-gen</code>，创建 <code>reference</code> 子文件夹，放入项目的接口文档 <code>api-docs.md</code>（内容示例：用户列表接口：GET /api/user/list，参数：pageNum（number）、pageSize（number），返回值：{ code: 200, data: { list: [], total: 0 } }）；</p>
</li>
<li>
<p>在 <code>SKILL.md</code> 中添加加载条件：</p>
</li>
</ol>

<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 接口请求代码生成 Skill</span>
<span class="hljs-meta">## 技能描述</span>
生成符合项目接口规范的 Axios 请求代码，自动匹配接口地址、请求方式、参数类型。
<span class="hljs-meta">## Reference 加载条件</span>
当用户需要生成“接口请求代码”，且提及具体接口名称（如用户列表、登录接口）时，自动加载 reference/api-docs.md 文档，获取接口信息。
<span class="hljs-meta">## 规则</span>
<span class="hljs-number">1.</span> 请求代码使用项目全局封装的 Axios 实例（import request <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>）；
<span class="hljs-number">2.</span> 生成请求函数，包含参数类型校验（TypeScript）；
<span class="hljs-number">3.</span> 处理请求异常（<span class="hljs-keyword">try</span>/<span class="hljs-keyword">catch</span> 包裹，抛出异常提示）。
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3bed830464a4bdaa189d6607ce5bd41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=Lp31V3PPbgWA6FI8Z5Nj6xPRG%2B0%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/734e4ed19faf49e7b015a67873bc3bed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=uXvX1mNoclOjE8m10qxfBKqLKx0%3D" alt="image.png" loading="lazy"/></p>
<ol start="3">
<li>调用 Skill：输入“生成用户列表接口的请求代码，保存在user.js里面，没有的你创建一个js”，Cursor 会自动加载 <code>reference/api-docs.md</code>，生成符合项目接口规范的请求代码，无需手动输入接口地址、参数类型：</li>
</ol>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>

<span class="hljs-comment">/**
 * 用户列表接口请求函数
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">params</span> - 请求参数
 * <span class="hljs-doctag">@param</span> params.pageNum - 页码（必填）
 * <span class="hljs-doctag">@param</span> params.pageSize - 每页条数（必填）
 * <span class="hljs-doctag">@returns</span> 用户列表数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">params: { pageNum: <span class="hljs-built_in">number</span>; pageSize: <span class="hljs-built_in">number</span> }</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>({
      <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/user/list'</span>,
      <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
      params
    })
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取用户列表失败：'</span>, error)
    <span class="hljs-keyword">throw</span> error
  }
}
</code></pre>
<p>可以看见输出结果
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c2706f1a406e46479c4c7b47ad2e1846~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=uldiduZ4KOwl6%2Bl6ArFwGQvY5e4%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-17">2. Script 加载：按需加载“可执行脚本”，让 Skill 实现“自动操作”</h3>
<h4 data-id="heading-18">核心作用</h4>
<p>Script 是 Agent Skill 的“可执行操作模块”，可存放前端常用的脚本（如 JS/TS 脚本），Skill 执行时，按需加载并执行这些脚本，实现“生成代码→自动执行操作”的闭环——比如批量修改组件文件名、自动格式化所有 Vue 文件、批量替换接口地址等，本质是“给 Skill 赋予‘执行操作’的能力”，解决传统 AI“只会生成、不会执行”的痛点。</p>
<h4 data-id="heading-19">前端常用场景</h4>
<ul>
<li>
<p>场景 1：批量重构脚本：将项目中所有的 Vue2 组件，批量修改为 Vue3 Setup 语法（无需手动逐个修改）；</p>
</li>
<li>
<p>场景 2：文件操作脚本：批量修改组件文件名（如将 UserCard.vue 改为 UserCardItem.vue），同时修改组件内部的引入路径；</p>
</li>
<li>
<p>场景 3：规范校验脚本：遍历项目所有 JS/TS 文件，检查是否存在未使用的变量，自动删除冗余代码。</p>
</li>
</ul>
<h4 data-id="heading-20">加载方式（结合 Cursor 实操）</h4>
<p>Script 的加载方式是“执行时加载、沙箱运行”，步骤如下（贴合前端项目结构），重点注意：前端脚本仅在 Cursor 内置的沙箱环境中执行，不会影响本地项目文件（需手动确认执行结果后，再应用到本地项目，避免误操作）：</p>
<ol>
<li>步骤 1：在 Skill 文件夹中，创建 <code>scripts</code> 子文件夹（固定名称，Cursor 会自动识别）；</li>
<li>步骤 2：将可执行脚本放入该文件夹（前端常用 JS/TS 脚本，需保证脚本可独立执行，不依赖项目外部依赖）；</li>
<li>步骤 3：在 SKILL.md 中，明确“脚本执行条件”——即“什么时候需要执行这份脚本”；</li>
<li>步骤 4：调用 Skill 时，当满足执行条件，Cursor 会自动加载对应的 Script 脚本，在沙箱环境中执行，执行完成后输出结果，用户确认无误后，可将结果应用到本地项目。</li>
</ol>
<h4 data-id="heading-21">实操示例：批量修改组件文件名脚本（前端高频需求）</h4>
<ol>
<li>新建 Skill 文件夹 <code>batch-rename-component</code>，创建 <code>scripts</code> 子文件夹，放入脚本文件 <code>rename-component.js</code>（前端常用 JS 脚本，功能：批量将项目中所有“Card.vue”结尾的组件，改为“CardItem.vue”，同时修改组件内部的引入路径）：</li>
</ol>

<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// scripts/rename-component.js</span>
<span class="hljs-comment">// 批量修改组件文件名脚本（Cursor 沙箱执行，不直接修改本地文件）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fs</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">'path'</span>)

<span class="hljs-comment">// 项目组件目录（前端项目常见目录）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">componentDir</span> = path.<span class="hljs-title function_ invoke__">join</span>(__dirname, <span class="hljs-string">'../../src/components'</span>)

<span class="hljs-comment">// 遍历目录，修改文件名和引入路径</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">renameComponents</span> = () =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">files</span> = fs.<span class="hljs-title function_ invoke__">readdirSync</span>(componentDir)
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">modifiedFiles</span> = []
  
  files.<span class="hljs-title function_ invoke__">forEach</span>(file =&gt; {
    <span class="hljs-keyword">if</span> (file.<span class="hljs-title function_ invoke__">endsWith</span>(<span class="hljs-string">'Card.vue'</span>)) {
      <span class="hljs-comment">// 新文件名</span>
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">newFileName</span> = file.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">'Card.vue'</span>, <span class="hljs-string">'CardItem.vue'</span>)
      <span class="hljs-comment">// 旧文件路径和新文件路径</span>
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">oldPath</span> = path.<span class="hljs-title function_ invoke__">join</span>(componentDir, file)
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">newPath</span> = path.<span class="hljs-title function_ invoke__">join</span>(componentDir, newFileName)
      
      <span class="hljs-comment">// 读取文件内容，修改引入路径</span>
      let content = fs.<span class="hljs-title function_ invoke__">readFileSync</span>(oldPath, <span class="hljs-string">'utf8'</span>)
      content = content.<span class="hljs-title function_ invoke__">replace</span>(/import .* <span class="hljs-keyword">from</span> <span class="hljs-string">'./(.*)Card'</span>/g, (<span class="hljs-keyword">match</span>, p1) =&gt; {
        <span class="hljs-keyword">return</span> `import ${p1}CardItem <span class="hljs-keyword">from</span> <span class="hljs-string">'./${p1}CardItem'</span>`
      })
      
      <span class="hljs-comment">// 模拟修改（沙箱环境中不实际写入文件，仅输出结果）</span>
      modifiedFiles.<span class="hljs-title function_ invoke__">push</span>({
        <span class="hljs-attr">oldName</span>: file,
        <span class="hljs-attr">newName</span>: newFileName,
        <span class="hljs-attr">path</span>: componentDir
      })
    }
  })
  
  <span class="hljs-keyword">return</span> {
    success: <span class="hljs-literal">true</span>,
    modifiedCount: modifiedFiles.length,
    modifiedFiles
  }
}

<span class="hljs-comment">// 执行脚本并输出结果</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = <span class="hljs-title function_ invoke__">renameComponents</span>()
console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">'批量修改结果：'</span>, result)
</code></pre>
<p>2.  在 <code>SKILL.md</code> 中添加脚本执行条件：</p>

<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 组件批量重命名 Skill</span>
<span class="hljs-section">## 技能描述</span>
批量修改项目中 Vue 组件的文件名，同时修改组件内部的引入路径，避免路径错误。
<span class="hljs-section">## Script 执行条件</span>
当用户输入“批量修改组件文件名”“批量重命名 Card 组件”时，自动加载 scripts/rename-component.js 脚本，执行批量修改操作。
<span class="hljs-section">## 注意事项</span>
<span class="hljs-bullet">1.</span> 脚本在 Cursor 沙箱环境中执行，不直接修改本地文件；
<span class="hljs-bullet">2.</span> 执行完成后，输出修改结果（修改的文件列表、数量）；
<span class="hljs-bullet">3.</span> 用户确认无误后，可手动将修改结果应用到本地项目。
</code></pre>
<p>3.  调用 Skill：输入“批量重命名 Card 组件”，Cursor 会自动加载并执行 <code>rename-component.js</code> 脚本，输出修改结果（如“修改了 3 个文件，分别是 UserCard.vue → UserCardItem.vue、GoodsCard.vue → GoodsCardItem.vue”），用户确认无误后，可手动修改本地文件，完成批量重构。</p>
<h3 data-id="heading-22">Reference 与 Script 加载核心区别（前端视角）</h3>























<table><thead><tr><th>加载类型</th><th>核心作用</th><th>加载时机</th><th>前端类比</th></tr></thead><tbody><tr><td>Reference</td><td>提供参考资料，让 Skill 贴合项目</td><td>满足触发条件时加载，执行完成后释放</td><td>组件加载时，按需引入的配置文件（如 .env 文件）</td></tr><tr><td>Script</td><td>执行具体操作，实现自动化闭环</td><td>满足执行条件时加载，执行完成后销毁</td><td>组件挂载后，按需执行的工具函数（如批量处理数据的函数）</td></tr></tbody></table>
<h2 data-id="heading-23">五、Agent Skill 加载逻辑</h2>
<p>很多前端开发者使用 Agent Skill 时会有疑问：“我封装了很多 Skill，会不会占用过多资源？会不会影响 AI 响应速度？” 答案是不会——因为 Agent Skill 采用了“按需加载”的核心逻辑，与前端的“路由懒加载”“组件按需引入”原理完全一致，都是“需要时加载，不需要时不占用资源”，最大化提升效率、节省开销。</p>
<p>结合前端开发的认知，我们把 Agent Skill 的加载逻辑拆解为“三个阶段”，每个阶段对应明确的加载时机和内容，同时结合 Cursor 的实际加载行为，让你一看就懂：</p>
<h3 data-id="heading-24">1. 初始化阶段：仅加载“Skill 元数据”（轻量加载）</h3>
<p>当你打开 Cursor 并进入项目时，Cursor 会自动扫描项目根目录下的 <code>.cursor/skills</code> 文件夹，此时仅加载每个 Skill 的“元数据”——也就是 Skill 的名称、描述（来自 SKILL.md 中的“技能描述”部分），相当于前端项目初始化时，仅加载路由表（不加载具体组件）。</p>
<p>特点：元数据体积极小，加载速度极快，几乎不占用资源（类比前端加载路由表，仅包含路径和组件名称，不加载组件代码）；此时 Skill 并未真正“激活”，仅让 Cursor 知道“当前项目有哪些 Skill，每个 Skill 能做什么”。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32235b1b69b4423589fb4b5fa5dca86b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=9nTOuvJe6gVAyHRlRpV9eFL6ErA%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-25">2. 触发阶段：按需加载“Skill 核心规则”（精准加载）</h3>
<p>当你输入指令，Cursor 判定需要调用某个 Skill 时（比如输入“生成 Vue3 组件”，Cursor 匹配到 <code>vue3-component-gen</code> Skill），才会加载该 Skill 的核心规则——也就是 SKILL.md 中的全部内容（规则、场景、示例等），相当于前端点击某个路由时，才懒加载对应的组件代码。</p>
<p>特点：仅加载“当前需要的 Skill”，其他 Skill 仍处于“元数据状态”，不占用额外资源；比如你调用“ESLint 修复 Skill”时，仅加载 <code>eslint-fix</code> 的 SKILL.md 内容，<code>vue3-component-gen</code> 仍仅保留元数据，不会被加载。</p>
<h3 data-id="heading-26">3. 执行阶段：按需加载“Skill 依赖资源”（按需中的按需）</h3>
<p>当 Skill 执行过程中，需要用到参考资料（Reference）或脚本（Script）时，才会加载对应的依赖资源——比如某个 Skill 需要读取项目的 ESLint 配置文件（.eslintrc.js），才会加载该参考文件；需要执行批量修改脚本，才会加载对应的 Script 文件，相当于前端组件渲染时，按需加载依赖的图片、工具函数（不渲染时不加载）。</p>
<p>特点：依赖资源仅在“需要时”加载，执行完成后自动释放，避免资源占用；比如 Skill 执行完成后，加载的参考文件、脚本会自动销毁，不会一直占用内存（类比前端组件卸载时，销毁组件实例和依赖资源）。</p>
<h3 data-id="heading-27">核心总结</h3>
<p>Agent Skill 的加载逻辑 = 前端“路由懒加载” + “组件按需引入”的结合体：</p>
<ul>
<li>元数据加载 → 路由表加载（初始化轻量加载）；</li>
<li>核心规则加载 → 路由对应组件加载（触发时精准加载）；</li>
<li>依赖资源加载 → 组件依赖的图片/工具函数加载（执行时按需加载）。</li>
</ul>
<p>这种加载逻辑，既保证了 Skill 调用的高效性，又避免了资源浪费，完全适配前端开发中“轻量初始化、按需加载”的核心需求，这也是 Agent Skill 能在前端开发中广泛应用的重要原因之一。</p>
<h2 data-id="heading-28">六、按需加载的 Token 消耗解析（前端开发者必看）</h2>
<p>对于使用 AI 工具（如 Cursor、Claude）的前端开发者而言，Token 消耗直接关系到使用成本（部分工具按 Token 收费），而 Agent Skill 的“按需加载”逻辑，核心优势之一就是“精准控制 Token 消耗”——避免加载无用内容，最大化节省 Token，这也是前端开发者使用 Skill 时需要重点关注的点。</p>
<p>下面我们从“Token 消耗的核心逻辑”“不同加载阶段的 Token 消耗”“前端场景下的 Token 节省技巧”三个维度，结合实测数据，详细解析，让你既能明白“Token 花在哪”，也能学会“如何省 Token”。</p>
<h3 data-id="heading-29">1. 核心前提：Agent Skill 的 Token 消耗逻辑</h3>
<p>首先明确一个核心逻辑：AI 工具的 Token 消耗，本质是“加载的文本内容长度”——文本越长，Token 消耗越多（类比前端的“文件体积越大，加载时间越长”）。</p>
<p>Agent Skill 的按需加载，本质是“只加载当前需要的文本内容”：不触发 Skill 时，仅加载轻量的元数据（Token 消耗极少）；触发 Skill 时，仅加载该 Skill 的核心规则；不使用 Reference/Script 时，不加载对应的文件，从而避免加载无用的文本内容，减少 Token 消耗。实测数据显示，在处理前端长流程任务时，按需加载架构能将上下文 Token 消耗降低 60%-80%，节省效果显著。</p>
<h3 data-id="heading-30">2. 不同加载阶段的 Token 消耗</h3>
<p>结合前面提到的“三个加载阶段”，我们分别解析每个阶段的 Token 消耗，同时给出前端场景下的实测数据（以 Cursor 为例，Token 计算规则与 Claude 一致，1000 字符 ≈ 750 Token），让你有直观认知：</p>
<h4 data-id="heading-31">（1）初始化阶段：元数据加载（Token 消耗极低，可忽略）</h4>
<p>加载内容：每个 Skill 的名称、简短描述（约 50-100 字符/个）；</p>
<p>Token 消耗：单个 Skill 约 30-75 Token，10 个 Skill 仅消耗 300-750 Token；</p>
<p>前端场景类比：相当于加载前端项目的路由表（仅包含路径和组件名称），文件体积极小，加载时的资源消耗可忽略。</p>
<h4 data-id="heading-32">（2）触发阶段：核心规则加载（Token 消耗中等，可控）</h4>
<p>加载内容：当前触发的 Skill 的 SKILL.md 全部内容（前端场景下，SKILL.md 长度约 500-2000 字符，包含规则、场景、示例）；</p>
<p>Token 消耗：单个 Skill 约 375-1500 Token；</p>
<p>关键说明：仅加载“当前触发的 Skill”，其他 Skill 不加载，比如同时封装了 10 个 Skill，调用 1 个时，仅消耗该 Skill 的 Token，其他 9 个仍仅消耗元数据的少量 Token；</p>
<p>前端场景优化：SKILL.md 中仅保留核心规则，删除冗余描述（如无需详细写示例，仅保留关键规则），可进一步降低 Token 消耗。</p>
<h4 data-id="heading-33">（3）执行阶段：Reference/Script 加载（Token 消耗按需，可控制）</h4>
<p>加载内容：仅加载当前需要的 Reference 文件或 Script 脚本（文本长度决定 Token 消耗）；</p>
<p>Token 消耗：</p>
<ul>
<li>Reference：前端常用的接口文档、规范文档（约 1000-5000 字符），Token 消耗约 750-3750 Token；</li>
<li>Script：前端脚本（约 500-2000 字符），Token 消耗约 375-1500 Token；</li>
</ul>
<p>关键说明：</p>
<ul>
<li>不使用 Reference/Script 时，不消耗对应的 Token（按需加载的核心优势）；</li>
<li>Script 脚本仅加载“文本内容”，执行时不额外消耗 Token（类比前端加载 JS 文件，仅加载文件内容，执行时不消耗额外网络资源）；</li>
<li>Reference 文件可拆分（如将庞大的接口文档拆分为“用户接口.md”“商品接口.md”），需要时仅加载对应拆分文件，进一步节省 Token（类比前端拆分组件，按需引入）。实测显示，将庞大知识库拆分为按需加载的 Reference 文件，比全量加载的 Token 成本节省 92% 以上，同时加载速度提升 45%。</li>
</ul>
<h3 data-id="heading-34">3. 前端场景下的 Token 节省技巧（实用可落地）</h3>
<p>结合前端开发的实际使用场景，分享 3 个实用的 Token 节省技巧，直接降低使用成本：</p>
<ol>
<li>精简 SKILL.md 内容：仅保留核心规则，删除冗余的示例、描述（如示例可简化，无需写完整代码，仅写关键片段）；</li>
<li>拆分 Reference 文件：将庞大的参考资料拆分为多个小文件（如接口文档按模块拆分），需要时仅加载对应模块，避免全量加载；</li>
<li>避免同时触发多个 Skill：每次仅调用 1 个需要的 Skill，避免多个 Skill 同时加载，导致 Token 浪费（类比前端避免同时加载多个不必要的组件）。</li>
</ol>
<h2 data-id="heading-35">七、Agent Skill 与 MCP 的核心区别</h2>
<p>很多前端开发者会混淆 Agent Skill 和 MCP，甚至认为“两者是一回事”——其实两者的核心定位、作用、使用场景完全不同，简单来说：Agent Skill 是“给 AI 用的技能模板”，聚焦“AI 操作的标准化、自动化”；MCP 是“前端项目的构建/部署工具”，聚焦“项目的构建、打包、部署流程”，两者无直接关联，但可能在前端开发中配合使用。</p>
<p>下面我们从“ 6 个维度”，详细对比两者的区别，结合前端实际使用场景，让你彻底分清，避免使用时混淆：</p>








































<table><thead><tr><th>对比维度</th><th>Agent Skill</th><th>MCP（前端常用，如 Webpack、Vite、Rollup）</th></tr></thead><tbody><tr><td>核心定位</td><td>AI 智能体的“技能模板”，用于规范、自动化 AI 的操作（生成代码、修复代码、执行脚本），本质是“AI 的操作手册”，核心是“赋能 AI”，让 AI 更适配前端开发场景。</td><td>前端项目的“构建/部署工具”，用于将前端源码（JS/Vue/TS/CSS）打包、压缩、优化，生成可部署的静态文件，本质是“项目的加工工具”，核心是“处理项目文件”。</td></tr><tr><td>核心作用</td><td>1. 省去重复 Prompt，提升 AI 生成代码的效率；2. 关联项目上下文，让 AI 生成的代码适配项目规范；3. 执行自动化操作（如批量重构、代码修复），实现 AI 操作闭环。</td><td>1. 打包：将多个源码文件合并为单个/多个静态文件；2. 优化：压缩代码、图片，提升项目加载速度；3. 构建：处理 ES6+ 语法、CSS 预处理器，让浏览器可识别；4. 部署：部分 MCP 支持自动部署到服务器。</td></tr><tr><td>使用场景</td><td>前端开发的“编码阶段”：生成组件、修复代码、接口请求代码生成、批量重构、规范校验等，与 AI 工具（Cursor、Claude）配合使用，核心是“辅助编码”。</td><td>前端开发的“构建/部署阶段”：编码完成后，打包源码、优化项目、部署上线，核心是“处理项目输出”，与前端框架（Vue、React）配合使用。</td></tr><tr><td>依赖环境</td><td>依赖支持 Agent Skill 的 AI 工具（如 Cursor、Claude），无需额外部署，仅需在项目中创建 Skill 配置文件，AI 工具自动识别。</td><td>依赖 Node.js 环境，需在项目中配置（如 webpack.config.js、vite.config.js），部分 MCP 需额外安装插件（如 CSS 预处理器插件），配置相对复杂。</td></tr><tr><td>操作对象</td><td>操作的是“AI 的指令和行为”，间接作用于前端源码（通过 AI 生成、修改源码），不直接处理项目文件（Script 脚本仅在沙箱执行，需手动应用到本地）。</td><td>直接操作“前端源码文件”，对源码进行打包、压缩、优化，直接输出可部署的静态文件，直接作用于项目文件。</td></tr><tr><td>前端开发者关联度</td><td>可选但推荐使用：不使用也能编码，但使用后能大幅提升编码效率，减少重复工作，尤其适合大型项目（规范多、重复工作多）。</td><td>必用：前端项目（尤其是框架开发）必须使用 MCP，否则源码无法打包、优化，无法部署上线（原生 JS 项目可不用，但实际开发中极少）。</td></tr></tbody></table>
<h3 data-id="heading-36">一句话分清</h3>
<p>Agent Skill：<strong>辅助 AI 帮你写代码、修代码、做批量操作</strong>，聚焦“编码效率”，配合 Cursor 等 AI 工具使用；</p>
<p>MCP：<strong>帮你把写好的代码打包、优化、部署上线</strong>，聚焦“项目输出”，配合 Vue、React 等框架使用；</p>
<p>两者配合场景：用 Agent Skill 辅助编码（生成、修复代码）→ 编码完成后，用 MCP 打包、优化项目 → 部署上线，形成前端开发的完整流程。</p>
<h2 data-id="heading-37">八、总结：前端开发者如何高效用好 Agent Skill</h2>
<p>结合本文的全维度解析，Agent Skill 对于前端开发者而言，核心价值是“解放双手、提升效率”——把重复、机械、规范的编码工作，交给 AI 自动完成，开发者专注于核心业务逻辑（如业务流程设计、交互优化）。</p>
<p>最后，给前端开发者 3 个实用建议，帮助你快速落地 Agent Skill，最大化发挥其价值：</p>
<ol>
<li>从高频场景入手：优先封装前端开发中“重复次数最多”的 Skill（如组件生成、ESLint 修复、接口请求生成），快速看到效率提升，避免一开始就封装复杂 Skill；</li>
<li>贴合项目规范：封装 Skill 时，严格遵循项目的代码规范、接口规范、组件规范，让生成的代码无需手动修改，真正实现“拿来就用”，这也是 Skill 最核心的价值；</li>
<li>合理使用 Reference/Script：简单场景用基础 Skill（仅 SKILL.md），复杂场景（接口联调、批量重构）结合 Reference 和 Script，同时注意控制 Token 消耗，避免浪费。</li>
</ol>
<p>随着 AI 技术在前端开发中的普及，Agent Skill 会逐渐成为前端开发者的“必备工具”——它不是“替代开发者”，而是“成为开发者的专属 AI 助手”，帮你省去重复工作，提升编码效率，让你有更多时间专注于更有价值的开发工作。</p>
<p>后续你可以根据自己的项目场景，不断优化、扩展 Skill 库，让 AI 助手越来越适配你的开发习惯，真正实现“高效编码、轻松开发”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Agent Skill与Rules的区别——以Cursor为例]]></title>    <link>https://juejin.cn/post/7604012106154819630</link>    <guid>https://juejin.cn/post/7604012106154819630</guid>    <pubDate>2026-02-09T03:25:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604012106154819630" data-draft-id="7604080364354142235" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Agent Skill与Rules的区别——以Cursor为例"/> <meta itemprop="keywords" content="前端,后端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-09T03:25:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="随意_"/> <meta itemprop="url" content="https://juejin.cn/user/4222562141210478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Agent Skill与Rules的区别——以Cursor为例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4222562141210478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    随意_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:25:12.000Z" title="Mon Feb 09 2026 03:25:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>在AI Agent（智能代理）的运行逻辑中，Agent Skill（智能体技能）与Rules（规则）是两个基础且易混淆的核心概念。二者共同支撑AI工具完成指定任务，但在本质、运行逻辑、灵活度及应用场景上存在根本性差异。Cursor作为一款主打代码编写的AI工具，其背后的运行机制恰好清晰地体现了这两者的区别——Rules构建了工具的“底线框架”，而Agent Skill赋予了工具“灵活解题”的能力。本文将以Cursor为具体案例，从多维度详细拆解二者的核心差异，尤其补充“携带方式”的区别，帮助我们更深刻理解AI工具的工作原理。</p>
<h2 data-id="heading-1">一、先明确核心定义：两个概念的本质差异</h2>
<p>要区分Agent Skill与Rules，首先要跳出“都是完成任务的方式”这一表层认知，抓住二者的本质内核。简单来说，<strong>Rules是“预设的固定指令”，是AI必须遵守的“硬约束”；而Agent Skill是“习得的灵活能力”，是AI运用知识解决问题的“软能力”</strong> 。二者的定义差异，直接决定了它们在AI工具中扮演的不同角色，也决定了其携带方式的本质区别——Rules是AI工具始终携带、全程生效的“基础准则”，而Agent Skill是AI工具按需调用、不持续占用资源、未使用时不主动触发的“专项能力”。</p>
<h3 data-id="heading-2">1. Rules（规则）：AI的“行为手册”，固定且不可逾越，全程携带生效</h3>
<p>Rules是由开发者预先定义的、明确的、刚性的指令集合，核心作用是划定AI的行为边界、规范基础操作流程，回答“什么可以做、什么不能做，以及基础操作要遵循什么步骤”。它不具备学习能力和灵活调整性，无论输入场景如何变化，只要触发了规则条件，AI就必须按照预设指令执行，不存在“变通”的可能。</p>
<p>Rules的核心特征是“确定性”——输入与输出之间存在固定对应关系，如同工厂流水线的操作规范，每一个步骤都有明确要求，不允许偏差。更关键的是，Rules是AI工具<strong>全程携带、实时生效</strong>的，无论用户是否触发相关功能，Rules都会持续存在于工具的运行逻辑中，随时准备检测违规行为、规范基础操作。对于Cursor而言，其内置的Rules的核心目的是保障工具运行的稳定性、安全性，以及基础功能的一致性，这种保障需要全程生效，因此Rules必须一直携带。</p>
<h3 data-id="heading-3">2. Agent Skill（智能体技能）：AI的“解题能力”，灵活且可迭代，按需调用、不持续携带</h3>
<p>Agent Skill是AI通过训练（数据训练、强化学习等）习得的、能够灵活应对复杂场景、解决具体问题的能力，核心作用是“高效完成目标任务”，回答“遇到具体问题时，如何最优地解决它”。它具备一定的灵活性和适应性，能够根据输入的差异、场景的变化，调整解决问题的方式，甚至在遇到新场景时，基于已有技能进行合理适配（而非机械遵循固定指令）。</p>
<p>Agent Skill的核心特征是“灵活性”——输入与输出之间没有固定对应关系，AI会根据自身习得的知识和经验，选择最优路径完成任务，如同人类的专业技能（如程序员编写代码、设计师绘制图纸），能够应对不同场景下的复杂需求。与Rules不同，Agent Skill是AI工具<strong>按需调用、不持续携带</strong>的：当用户没有触发相关需求时，Skill不会主动生效，也不会持续占用工具资源；只有当用户提出具体任务需求（如生成代码、修复错误）时，工具才会调用对应的Skill，完成任务后，Skill会回归“休眠”状态，不再主动参与工具运行。</p>
<h2 data-id="heading-4">二、以Cursor为案例：多维度拆解二者的具体区别</h2>
<p>Cursor的核心功能是代码生成、代码优化、错误修复、语法提示等，其背后同时依赖Rules的“刚性约束”和Agent Skill的“灵活解题”。我们从7个核心维度（新增携带方式），结合Cursor的实际功能，拆解二者的具体差异，让抽象概念落地。</p>
<h3 data-id="heading-5">维度1：运行逻辑——“按指令执行”vs“按能力解题”</h3>
<p>Rules的运行逻辑是“条件-触发-执行”，完全依赖预设指令，不涉及任何“判断”和“适配”；而Agent Skill的运行逻辑是“需求-分析-解题”，依赖自身习得的知识，具备主动分析和灵活适配的能力。</p>
<p>以Cursor的“语法规范”相关功能为例：</p>
<ul>
<li>Rules层面：开发者预先为每一种编程语言（Python、JavaScript、Java等）定义了明确的语法规则——比如Python中“缩进必须用4个空格”“语句结尾不能加分号”“关键字不能作为变量名”，这些都是固定的Rules。当用户在Cursor中输入“if a == 1:”后忘记缩进，Cursor会立即报错，原因是触发了“Python条件语句后必须缩进”的Rules，此时Cursor的行为是“检测到违规→执行预设提示（报错）”，没有任何灵活调整，完全遵循固定指令。</li>
<li>Agent Skill层面：当用户输入“用Python写一个读取Excel文件并筛选数据的代码”时，Cursor的核心行为的是“分析需求→调用代码编写技能→生成适配的代码”。此时，Cursor不会机械遵循某一条固定指令，而是会根据用户的具体需求（读取Excel、筛选数据），结合自身习得的Python编程知识，选择合适的库（如pandas）、合适的代码逻辑，生成可直接运行的代码。如果用户后续补充“筛选出大于100的数据并保存为新文件”，Cursor还能灵活调整代码，无需开发者新增额外Rules——这就是Agent Skill的“解题能力”，而非“指令执行”。</li>
</ul>
<h3 data-id="heading-6">维度2：灵活度——“刚性不可变”vs“弹性可适配”</h3>
<p>Rules的最大特点是“刚性”，一旦定义完成，无法根据场景变化灵活调整，除非开发者手动修改Rules；而Agent Skill的最大特点是“弹性”，能够根据输入差异、需求变化，灵活调整解决问题的方式，甚至适配未预设的新场景。</p>
<p>结合Cursor的“代码优化”功能进一步说明：</p>
<p>Cursor的Rules中，有一条固定规则是“不生成恶意代码”——无论用户输入什么需求，只要涉及恶意代码（如窃取数据、攻击系统的代码），Cursor都会直接拒绝生成，这是刚性约束，没有任何变通的可能，哪怕用户伪装需求，只要触发了“恶意代码”的判断规则，就会执行拒绝指令。</p>
<p>而Cursor的“代码优化技能”则具备极强的灵活性：当用户输入一段冗余的Python代码（如重复的循环、不必要的变量定义），Cursor会分析代码的核心功能，结合自身习得的“代码简洁化”技能，对代码进行优化——比如将重复循环替换为列表推导式，删除无用变量。如果用户输入的是一段JavaScript冗余代码，Cursor同样能适配，优化逻辑会根据JavaScript的语法特点和编程习惯调整，而非沿用Python的优化规则。这种“根据语言类型、代码场景灵活调整优化方式”的能力，就是Agent Skill，它不依赖固定指令，而是依赖自身习得的多语言编程技能。</p>
<h3 data-id="heading-7">维度3：学习与迭代——“不可学习”vs“可迭代升级”</h3>
<p>Rules是“静态”的，本身不具备任何学习能力，无法从用户的使用场景、新的需求中积累经验，其迭代只能依赖开发者手动修改、新增或删除规则；而Agent Skill是“动态”的，能够通过持续的训练（如用户反馈、新的训练数据）不断迭代升级，提升解题能力，甚至习得新的技能。</p>
<p>这一点在Cursor的版本更新中体现得尤为明显：</p>
<ul>
<li>Rules的迭代：Cursor早期版本中，对“TypeScript语法规则”的支持并不完整，比如未覆盖某些新增的语法特性（如可选链操作符?.），此时用户输入相关语法会报错——这是因为Rules中未包含该语法的判断规则。要解决这个问题，只能依靠开发者手动更新Rules，添加对该语法的支持，Cursor本身无法通过使用场景“学习”到这条新规则。</li>
<li>Agent Skill的迭代：Cursor的“代码错误修复技能”在早期版本中，只能修复简单的语法错误（如拼写错误、缺少括号），但随着版本更新，通过大量的错误代码案例训练，该技能不断升级，如今能够修复更复杂的逻辑错误（如循环条件错误、变量作用域错误），甚至能够识别代码中的潜在bug（如内存泄漏风险）并给出修复建议。这种升级不需要开发者手动定义“如何修复逻辑错误”的规则，而是Agent Skill通过学习不断积累经验、提升能力的结果。</li>
</ul>
<h3 data-id="heading-8">维度4：应用场景——“保障基础规范”vs“解决复杂需求”</h3>
<p>Rules的应用场景主要是“基础约束”，聚焦于保障AI工具的运行安全、操作规范、输出一致性，解决的是“不出错”的问题；而Agent Skill的应用场景主要是“复杂解题”，聚焦于满足用户的具体需求、提升任务完成效率，解决的是“做得好”的问题。</p>
<p>我们可以将Cursor的功能拆解为“基础规范层”和“复杂需求层”，分别对应Rules和Agent Skill：</p>
<ul>
<li>Rules覆盖的基础规范场景： 这些场景的核心目的是“保障Cursor的基础运行不出错、不违规”，没有这些Rules，Cursor会出现语法混乱、输出不安全代码、功能无序等问题。</li>
<li>编程语言语法校验（如Python缩进、JavaScript分号规范）；</li>
<li>代码安全约束（拒绝生成恶意代码、隐私泄露相关代码）；</li>
<li>基础操作规范（如代码格式化的默认缩进距离、注释规范）；</li>
<li>功能权限约束（如免费版用户无法使用高级代码优化功能）。</li>
<li>Agent Skill覆盖的复杂需求场景： 这些场景的核心目的是“满足用户的具体编程需求”，没有这些Agent Skill，Cursor只是一个普通的代码编辑器，无法实现“AI辅助编程”的核心价值。</li>
<li>根据自然语言需求生成代码（如“写一个二分查找算法”“用React写一个登录页面组件”）；</li>
<li>代码优化（如简化冗余代码、提升代码运行效率、优化代码可读性）；</li>
<li>复杂错误修复（如逻辑错误、依赖冲突、兼容性问题）；</li>
<li>代码解释与调试（如解释一段陌生代码的功能、指导用户调试报错代码）。</li>
</ul>
<h3 data-id="heading-9">维度5：输入与输出的关系——“一一对应”vs“多对多对应”</h3>
<p>Rules的输入与输出是“一一对应”的，即一个触发条件对应一个固定的输出结果，不存在“一个输入对应多个输出”的情况；而Agent Skill的输入与输出是“多对多对应”的，即同一个需求可以有多种解题方式，同一个输入可以对应多个不同的输出（均满足需求），AI会选择最优解。</p>
<p>以Cursor的“代码格式化”功能为例：</p>
<p>Rules层面：Cursor预设了“Python代码格式化规则”——缩进4个空格、函数之间空两行、注释独占一行，这些规则是固定的。当用户触发“格式化代码”指令时，无论这段Python代码的原始格式如何（如缩进2个空格、函数之间空一行），Cursor都会按照预设规则进行格式化，输出格式是固定的——这就是“输入（任意Python代码+格式化指令）→固定输出（符合预设规则的代码）”的一一对应关系。</p>
<p>Agent Skill层面：当用户输入“用Python写一个计算斐波那契数列的代码”时，Cursor的输出并不是固定的。它可以生成递归版本的代码，也可以生成循环版本的代码，还可以生成优化后的动态规划版本的代码——这三种输出都满足用户的需求，只是效率和可读性不同。Cursor会根据自身习得的技能，选择最优的方式（通常是效率更高的循环或动态规划版本）生成代码，这就是“输入（斐波那契数列需求）→多输出（多种代码实现）”的多对多对应关系，体现了Agent Skill的灵活性。</p>
<h3 data-id="heading-10">维度6：依赖主体——“依赖开发者预设”vs“依赖训练数据与模型”</h3>
<p>Rules的存在完全依赖开发者的预设，开发者定义什么规则，AI就遵守什么规则，规则的完整性、合理性完全由开发者决定；而Agent Skill的存在完全依赖训练数据与AI模型，训练数据的质量、数量，模型的训练方式，直接决定了Agent Skill的能力强弱。</p>
<p>回到Cursor的案例：</p>
<p>Cursor的Rules（如语法规则、安全规则），都是由Cursor的开发团队手动定义、梳理的——开发团队需要梳理每一种编程语言的语法细节，定义恶意代码的判断标准，预设操作规范，这些规则的好坏，完全取决于开发团队的专业能力。如果开发团队遗漏了某一种Python语法规则，Cursor就无法识别该语法错误。</p>
<p>而Cursor的Agent Skill（如代码生成、错误修复），则依赖于大量的编程数据训练——开发团队会收集海量的代码案例、编程问题及解决方案，输入到AI模型中进行训练，让模型习得“如何根据需求生成代码”“如何修复错误”。如果训练数据中包含大量高质量的Python代码案例，Cursor的Python代码生成技能就会更强；如果训练数据中缺少某类场景（如区块链相关代码），Cursor在应对这类需求时，技能表现就会较弱。</p>
<h3 data-id="heading-11">维度7：携带方式——“全程携带、实时生效”vs“按需调用、不持续携带”</h3>
<p>这是二者易被忽略但关键的区别：Rules是AI工具从启动到关闭，全程携带、实时生效的“基础准则”，无需用户触发，始终存在于工具运行逻辑中；Agent Skill是AI工具根据用户需求，按需调用、用完即“休眠”的“专项能力”，未使用时不主动生效、不持续占用资源，仅在触发特定任务时被调用。</p>
<p>结合Cursor的实际使用场景，这种区别十分直观，我们从“工具运行全流程”拆解：</p>
<ul>
<li>Rules：全程携带、实时生效。从你打开Cursor的那一刻起，其内置的所有Rules就已经启动并持续生效——无论你是否开始编写代码、是否触发某一功能，Rules都会实时检测你的操作。比如，你打开Cursor后，只是新建文件、未输入任何内容，Rules仍在后台运行（如检测文件格式规范）；当你输入第一个字符，若违反语法规则（如Python中输入“if a == 1”后未加冒号），Rules会立即触发报错，无需你手动调用“语法检测”功能。哪怕你关闭代码编写窗口、仅保留Cursor主界面，Rules依然携带生效，确保你后续任何操作都不违反预设规范。这种“全程携带”是为了保障工具运行的安全性和规范性，避免因Rules未生效导致违规操作（如生成恶意代码、语法混乱）。</li>
<li>Agent Skill：按需调用、不持续携带。当你打开Cursor后，若仅新建文件、未输入任何需求（如未要求生成代码、优化代码），则Cursor的所有Agent Skill（代码生成、错误修复、代码优化等）都处于“休眠”状态，未被调用、也不占用额外资源；只有当你触发特定需求时，对应的Skill才会被调用。比如，你输入“用Python写一个冒泡排序代码”，Cursor会立即调用“代码生成Skill”，完成代码生成后，该Skill就回归“休眠”状态；若你后续不再提出新需求，该Skill不会持续生效、也不会主动参与工具运行。再比如，你输入一段有逻辑错误的代码，只有当你点击“修复错误”按钮，或输入“修复这段代码”的需求时，“错误修复Skill”才会被调用，未触发时，该Skill不会主动检测代码错误（检测语法错误是Rules的功能，而非Skill）。</li>
</ul>
<p>补充一点：Rules的“全程携带”是被动的、强制的，由工具自身启动并维持；Agent Skill的“按需调用”是主动的、灵活的，由用户需求触发，调用何种Skill、何时调用，完全取决于用户的具体任务，工具不会主动调用Skill。</p>
<h2 data-id="heading-12">三、总结：二者相辅相成，缺一不可</h2>
<p>通过以上7个维度的拆解，我们可以清晰地看出Agent Skill与Rules的核心区别：Rules是AI工具的“骨架”，构建了工具的基础边界和规范，以“全程携带、实时生效”的方式，保障工具“不越界、不出错”；Agent Skill是AI工具的“血肉”，赋予了工具解决复杂问题的能力，以“按需调用、不持续携带”的方式，实现工具的核心价值，提升任务完成效率。二者并非对立关系，而是相辅相成、缺一不可。</p>






























<table><thead><tr><th>对比维度</th><th>Rules（规则）</th><th>Agent Skill（智能体技能）</th></tr></thead><tbody><tr><td>核心作用</td><td>构建基础边界和规范，保障工具“不越界、不出错”</td><td>赋予解题能力，实现工具核心价值，提升任务效率</td></tr><tr><td>携带方式</td><td>全程携带、实时生效，被动强制启动</td><td>按需调用、不持续携带，用户需求触发后“休眠”</td></tr><tr><td>Cursor中的作用</td><td>保障代码语法规范、运行安全，维持工具正常运行</td><td>实现代码生成、优化、错误修复等AI辅助编程核心功能</td></tr><tr><td>缺失影响</td><td>代码语法混乱、存在安全风险，工具无法正常运行</td><td>沦为普通代码编辑器，无法满足复杂编程需求</td></tr></tbody></table>
<p>延伸到整个AI Agent领域，无论是ChatGPT、MidJourney，还是各类行业AI工具，其运行逻辑都离不开这两者的配合：Rules划定边界（全程携带），Agent Skill实现价值（按需调用）。理解二者的区别，尤其是携带方式的差异，不仅能帮助我们更清晰地认识AI工具的工作原理，也能让我们在使用AI工具（如Cursor）时，更清楚地知道“工具能做什么、不能做什么”，更高效地利用工具解决自身需求。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[不要在简历上写精通 Vue3？来自面试官的真实劝退]]></title>    <link>https://juejin.cn/post/7603958579180355584</link>    <guid>https://juejin.cn/post/7603958579180355584</guid>    <pubDate>2026-02-09T03:27:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603958579180355584" data-draft-id="7604036853129723919" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="不要在简历上写精通 Vue3？来自面试官的真实劝退"/> <meta itemprop="keywords" content="前端,Vue.js,JavaScript"/> <meta itemprop="datePublished" content="2026-02-09T03:27:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"/> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            不要在简历上写精通 Vue3？来自面试官的真实劝退
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:27:58.000Z" title="Mon Feb 09 2026 03:27:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a0066014f0d4804a728e9603d8c187d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212478&amp;x-signature=QDQ5PcudN83PggT1ZI7Yxca2zi0%3D" alt="image.png" loading="lazy"/></p>
<p>最近在面试，说实话，每次看到 <strong>精通</strong> 这俩字，我这心里就咯噔一下。不是我不信你，是这俩字太重了。这不仅仅是自信，这简直就是给面试官下战书😥。</p>
<p>你写 <strong>熟悉</strong>，我问你 API 怎么用，能干活就行。</p>
<p>你写 <strong>精通</strong>，那我身体里的胜负欲瞬间就被你点燃了：既然你都精通了，那咱们就别聊怎么写代码了，咱们聊聊尤雨溪写这行代码时在想啥吧😒。</p>
<p>结果呢？三个问题下去，我看对面兄弟的汗都下来了，我都不好意思再问。</p>
<p>今天真心给大伙提个醒，简历上这 <strong>精通</strong> 二字，就是个巨大的坑，谁踩谁知道。</p>
<p>来，我给你们复盘一下，什么叫面试官眼里的精通。</p>
<h3 data-id="heading-0">你别只背八股文</h3>
<p>我上来通常先问个简单的热身：</p>
<p><strong>Vue3 到底为啥要用 Proxy 换掉 Object.defineProperty？</strong></p>
<p>大部分人张口就来：因为 defineProperty 监听不到数组下标，还监听不到对象新增属性。Proxy 啥都能拦，所以牛逼。</p>
<p>这话错没错？没错。</p>
<p>但这只是 60 分的回答，属于背诵全文🤔。</p>
<p><strong>敢写精通的，你得这么跟我聊：</strong></p>
<p>老哥，其实数组和新增属性那都是次要的。最核心的痛点是 <strong>性能</strong>，特别是初始化时候的性能。</p>
<p>Vue2 那个 defineProperty 是上来就得递归，把你对象里里外外每一层都给劫持了。对象一深，初始化直接卡顿。</p>
<p>Vue3 的 Proxy 是 <strong>惰性的</strong>。你访问第一层，我劫持第一层；你访问深层，我再临时去劫持深层。我不访问，我就不干活。</p>
<p>而且，这里面还有个 <strong>this 指向</strong> 的坑。Vue3 源码里用 Reflect.get 传了个 receiver 参数进去，就是为了保证有继承关系时，this 能指对地方，不然依赖收集就乱套了。</p>








































<table><thead><tr><th>能力</th><th>Vue2（defineProperty）</th><th>Vue3（Proxy）</th></tr></thead><tbody><tr><td>监听对象新增/删除</td><td>❌</td><td>✅</td></tr><tr><td>监听数组索引/length</td><td>❌</td><td>✅</td></tr><tr><td>一次性代理整个对象</td><td>❌</td><td>✅</td></tr><tr><td>性能上限</td><td>❌ 越大越慢</td><td>✅ 更平滑</td></tr><tr><td>Map / Set</td><td>❌</td><td>⚠️ 部分支持</td></tr><tr><td>实现复杂度</td><td>高</td><td>低</td></tr></tbody></table>
<p>你要能说到 <strong>懒劫持</strong> 和 <strong>Reflect 的 receiver</strong> 这一层，我才觉得你可能看过源码🙂‍↔️。</p>
<h3 data-id="heading-1">Diff 算法别光扯最长递增子序列</h3>
<p>第二个问题，稍微上点强度：</p>
<p><strong>Vue3 的 diff 算法快在哪？</strong></p>
<p>别一上来就跟我背什么最长递增子序列，那只是最后一步。</p>
<p>你得从 <strong>编译阶段</strong> 开始聊。</p>
<p>Vue2 是个老实人，数据变了，它就把整棵树拿来从头比到尾，哪怕你那是个静态的写死的 div，它也要比一下。</p>
<p>Vue3 变聪明了，它搞了个 <strong>动静分离</strong>。</p>
<p>在编译的时候，它就给那些会变的节点打上了标记，叫 <strong>PatchFlag</strong>。这个是文本变，那个是 class 变，都记好了。</p>
<p>等到真要 diff 的时候，Vue3 直接无视那些静态节点，只盯着带标记的节点看。</p>
<p>这就好比老师改卷子，以前是从头读到尾，现在是只看你改过的错题。这效率能一样吗？</p>
<p>这叫 <strong>靶向更新</strong>。能扯出这个词，才算摸到了 Vue3 的门道。</p>
<h3 data-id="heading-2">Ref 的那些坑说一说？</h3>
<p>最后问个细节，看你平时踩没踩过坑：</p>
<p><strong>Ref 在模板里不用写 .value，在 reactive 里也不用写。那为啥有时候在 Map 里又要写了呢？</strong></p>
<p>很多人这就懵了：啊？不都是自动解包吗？</p>
<p><strong>精通</strong> 的人会告诉我：</p>
<p>Vue 的自动解包是有底线的。</p>
<p>模板里那是亲儿子待遇，帮你解了。</p>
<p>reactive 对象里那是干儿子待遇，get 拦截器里帮你解了。</p>
<p>但是 <strong>Map</strong> 和 <strong>Set</strong> 这种数据结构，Vue 为了保证语义不乱，是不敢乱动的。你在 Map 里存个 ref，取出来它还是个 ref，必须得手写 .value。👇</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)

<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'count'</span>, count)

map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'count'</span>)        <span class="hljs-comment">// 拿到的是 ref 对象</span>
map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'count'</span>).<span class="hljs-property">value</span> <span class="hljs-comment">// 这是正确取值</span>

</code></pre>
<blockquote>
<p>Map / Set / WeakMap 不是 Vue 的响应式代理对象</p>
</blockquote>
<p>这种细枝末节，没在真实项目里被毒打过，是很难注意到的。</p>
<hr/>
<p>面试其实就是一场 <strong>心理博弈</strong>。</p>
<p>你写 <strong>精通</strong>，我对你的预期就是 <strong>行业顶尖</strong>。你答不上来，落差感太强，直接挂。</p>
<p>你写 <strong>熟练掌握</strong> 或者 <strong>有丰富实战经验</strong>，哪怕你答出上面这些深度的 50%，我都觉得这小伙子爱钻研，是个惊喜🥱。</p>
<p>在这个行业里，<strong>精通</strong> 真的不是终点，而是一个无限逼近的过程。</p>
<p>我自己写了这么多年代码，现在简历上也只敢写 <strong>熟练</strong>🤷‍♂️。</p>
<p>把 <strong>精通</strong> 换成 <strong>实战案例</strong> 吧，比如 <strong>我在项目中重写了虚拟列表</strong>，或者 <strong>我给 Vue 生态贡献过 PR</strong>。</p>
<p>这比那两个干巴巴的汉字，有力一万倍。</p>
<p>听哥一句劝，Flag 别乱搞，Offer 自然就会来😒。</p>
<p>你们说呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ffdaf315a33141f6bc3929a5d259f726~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212478&amp;x-signature=VLZPpX6fhiD%2Bbbk5av2aBOh7Rg0%3D" alt="Suggestion.gif" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[xxl-job 和 elastic-job，哪个更好？]]></title>    <link>https://juejin.cn/post/7604155045235818531</link>    <guid>https://juejin.cn/post/7604155045235818531</guid>    <pubDate>2026-02-09T03:35:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604155045235818531" data-draft-id="7604045354070409250" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="xxl-job 和 elastic-job，哪个更好？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-09T03:35:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苏三说技术"/> <meta itemprop="url" content="https://juejin.cn/user/465848661970824"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            xxl-job 和 elastic-job，哪个更好？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/465848661970824/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苏三说技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:35:17.000Z" title="Mon Feb 09 2026 03:35:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是苏三，又跟大家见面了。</p>
<p> </p>
<h2 data-id="heading-0">前言</h2>
<p>今天我们来探讨一个让许多技术团队纠结的问题：在分布式任务调度领域，<code>XXL-JOB</code>和<code>Elastic-Job</code>，到底哪个更好？</p>
<p>有些小伙伴在工作中第一次接触分布式任务调度时，可能会有这样的困惑：我们的定时任务在单机跑得好好的，为什么需要引入分布式调度框架？</p>
<p>当系统从单体架构演进到微服务架构，当数据量从几千条暴涨到几百万条，当业务要求从“按时执行”升级到“高效稳定”，单机任务调度就显得力不从心了。</p>
<p>我曾经经历过这样的架构演进：早期使用<code>Quartz</code>配合数据库锁，后来在千万级用户量的电商平台深度使用<code>XXL-JOB</code>，接着在数据处理量极大的金融项目中采用了<code>Elastic-Job</code>。</p>
<p>今天这篇文章就专门跟大家一起聊聊这个话题，希望对你会有所帮助。</p>
<h2 data-id="heading-1">01 设计哲学</h2>
<p>要理解这两个框架的差异，首先要从它们的设计哲学说起。</p>
<p><strong>XXL-JOB采用中心化架构</strong>，它的核心理念是“简单清晰、开箱即用”。</p>
<p>设计者许雪里在框架诞生之初就明确提出：“调度中心和执行器分离，调度中心负责统一调度，执行器负责接收调度请求并执行任务”。</p>
<p>这种设计让<code>XXL-JOB</code>像一个<strong>集中指挥中心</strong>，所有调度决策都由调度中心统一做出。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f39d5c121d84481b7c68799011c0045~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5LiJ6K-05oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212918&amp;x-signature=LgFmoRTaD6iz%2B7krHVowY%2BzYU7M%3D" alt="图片" loading="lazy"/></p>
<p><strong>Elastic-Job则采用去中心化架构</strong>，它的设计理念是“弹性调度、分布式协调”。</p>
<p>框架基于<code>ZooKeeper</code>实现分布式协调，各个节点通过<code>ZooKeeper</code>选举和监听机制协同工作，没有单点中心调度器。</p>
<p>这就像一个<strong>自治的分布式系统</strong>，每个节点都知道自己该做什么。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de567abf258b45aebf37a7849534f2b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5LiJ6K-05oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212918&amp;x-signature=8eS5WzCTTg0qwVfXWSMK4Yh3DO0%3D" alt="图片" loading="lazy"/></p>
<p>这两种设计哲学的选择，直接影响了两者在不同场景下的表现。中心化架构简化了系统的复杂度，而去中心化架构则提供了更好的弹性。</p>
<h2 data-id="heading-2">02 核心架构深度剖析</h2>
<h3 data-id="heading-3">XXL-JOB：简洁优雅的中心化设计</h3>
<p><code>XXL-JOB</code>的架构非常清晰，主要由三部分组成：</p>
<ol>
<li>1. <strong>调度中心（Scheduler Center）</strong> ：负责管理调度信息、发出调度请求</li>
<li>2. <strong>执行器（Executor）</strong> ：负责接收调度请求、执行任务</li>
<li>3. <strong>管理控制台（Admin Console）</strong> ：提供可视化界面进行任务管理</li>
</ol>
<p>让我们通过一个实际的例子来看看如何在Spring Boot项目中集成<code>XXL-JOB</code>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. 执行器配置</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxlJobConfig</span> {
    
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${xxl.job.admin.addresses}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> adminAddresses;
    
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${xxl.job.executor.appname}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> appName;
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">XxlJobSpringExecutor</span> <span class="hljs-title function_">xxlJobExecutor</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">XxlJobSpringExecutor</span> xxlJobSpringExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XxlJobSpringExecutor</span>();
        xxlJobSpringExecutor.<span class="hljs-title function_">setAdminAddresses</span>(adminAddresses);
        xxlJobSpringExecutor.<span class="hljs-title function_">setAppname</span>(appName);
        xxlJobSpringExecutor.<span class="hljs-title function_">setPort</span>(<span class="hljs-number">9999</span>);
        xxlJobSpringExecutor.<span class="hljs-title function_">setLogPath</span>(<span class="hljs-string">"/data/applogs/xxl-job/jobhandler/"</span>);
        xxlJobSpringExecutor.<span class="hljs-title function_">setLogRetentionDays</span>(<span class="hljs-number">30</span>);
        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;
    }
}

<span class="hljs-comment">// 2. 任务处理器示例</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleXxlJobHandler</span> {
    
    <span class="hljs-meta">@XxlJob</span>(<span class="hljs-string">"demoJobHandler"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">demoJobHandler</span>(<span class="hljs-title class_">String</span> param) throws <span class="hljs-title class_">Exception</span> {
        <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"XXL-JOB, 开始执行任务"</span>);
        
        <span class="hljs-comment">// 模拟业务处理</span>
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
            <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"执行进度: {}"</span>, i);
            <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">2</span>);
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReturnT</span>.<span class="hljs-property">SUCCESS</span>;
    }
    
    <span class="hljs-meta">@XxlJob</span>(<span class="hljs-string">"shardingJobHandler"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">shardingJobHandler</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> param</span>) {
        <span class="hljs-comment">// 分片参数</span>
        <span class="hljs-title class_">ShardingUtil</span>.<span class="hljs-property">ShardingVO</span> shardingVO = <span class="hljs-title class_">ShardingUtil</span>.<span class="hljs-title function_">getShardingVo</span>();
        int shardIndex = shardingVO.<span class="hljs-title function_">getIndex</span>();  <span class="hljs-comment">// 当前分片序号</span>
        int shardTotal = shardingVO.<span class="hljs-title function_">getTotal</span>();  <span class="hljs-comment">// 总分片数</span>
        
        <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span>, shardIndex, shardTotal);
        
        <span class="hljs-comment">// 根据分片参数处理数据</span>
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; dataList = <span class="hljs-title function_">queryDataByShard</span>(shardIndex, shardTotal);
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> data : dataList) {
            <span class="hljs-title function_">processData</span>(data);
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReturnT</span>.<span class="hljs-property">SUCCESS</span>;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">queryDataByShard</span>(<span class="hljs-params">int shardIndex, int shardTotal</span>) {
        <span class="hljs-comment">// 根据分片参数查询需要处理的数据</span>
        <span class="hljs-comment">// 例如：SELECT * FROM order_table WHERE MOD(id, #{shardTotal}) = #{shardIndex}</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-string">"data1"</span>, <span class="hljs-string">"data2"</span>, <span class="hljs-string">"data3"</span>);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> data</span>) {
        <span class="hljs-comment">// 处理数据逻辑</span>
        <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"处理数据: {}"</span>, data);
    }
}
</code></pre>
<h3 data-id="heading-4">Elastic-Job：基于分布式协调的弹性设计</h3>
<p><code>Elastic-Job</code>的架构更加分布式，它没有中心调度节点，而是通过<code>ZooKeeper</code>实现节点间的协调：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. Elastic-Job配置类</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElasticJobConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CoordinatorRegistryCenter</span> <span class="hljs-title function_">registryCenter</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">CoordinatorRegistryCenter</span> regCenter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperRegistryCenter</span>(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperConfiguration</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-string">"elastic-job-demo"</span>));
        regCenter.<span class="hljs-title function_">init</span>();
        <span class="hljs-keyword">return</span> regCenter;
    }
    
    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">"init"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">SpringJobScheduler</span> <span class="hljs-title function_">simpleJobScheduler</span>(<span class="hljs-params">
            final SimpleJob simpleJob,
            final CoordinatorRegistryCenter regCenter</span>) {
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringJobScheduler</span>(
            simpleJob,
            regCenter,
            <span class="hljs-title function_">getLiteJobConfiguration</span>(
                simpleJob.<span class="hljs-title function_">getClass</span>(),
                <span class="hljs-string">"0/5 * * * * ?"</span>,  <span class="hljs-comment">// 每5秒执行一次</span>
                <span class="hljs-number">3</span>,                 <span class="hljs-comment">// 分片总数</span>
                <span class="hljs-string">"0=北京,1=上海,2=广州"</span>  <span class="hljs-comment">// 分片参数</span>
            )
        );
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">LiteJobConfiguration</span> <span class="hljs-title function_">getLiteJobConfiguration</span>(<span class="hljs-params">
            Class&lt;? <span class="hljs-keyword">extends</span> SimpleJob&gt; jobClass,
            <span class="hljs-built_in">String</span> cron,
            int shardingTotalCount,
            <span class="hljs-built_in">String</span> shardingItemParameters</span>) {
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">LiteJobConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleJobConfiguration</span>(
                <span class="hljs-title class_">JobCoreConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
                    jobClass.<span class="hljs-title function_">getName</span>(),
                    cron,
                    shardingTotalCount
                ).<span class="hljs-title function_">shardingItemParameters</span>(shardingItemParameters).<span class="hljs-title function_">build</span>(),
                jobClass.<span class="hljs-title function_">getCanonicalName</span>()
            )
        ).<span class="hljs-title function_">overwrite</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">build</span>();
    }
}

<span class="hljs-comment">// 2. 简单的作业实现</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimpleJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SimpleJob</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">ShardingContext context</span>) {
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业执行，分片项: {}, 总分片数: {}"</span>, 
                 context.<span class="hljs-title function_">getShardingItem</span>(), 
                 context.<span class="hljs-title function_">getShardingTotalCount</span>());
        
        <span class="hljs-keyword">switch</span> (context.<span class="hljs-title function_">getShardingItem</span>()) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                <span class="hljs-comment">// 处理北京的数据</span>
                <span class="hljs-title function_">processData</span>(<span class="hljs-string">"北京"</span>, <span class="hljs-title function_">getBeijingData</span>());
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-comment">// 处理上海的数据</span>
                <span class="hljs-title function_">processData</span>(<span class="hljs-string">"上海"</span>, <span class="hljs-title function_">getShanghaiData</span>());
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-comment">// 处理广州的数据</span>
                <span class="hljs-title function_">processData</span>(<span class="hljs-string">"广州"</span>, <span class="hljs-title function_">getGuangzhouData</span>());
                <span class="hljs-keyword">break</span>;
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">getBeijingData</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 查询北京相关的数据</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-string">"北京数据1"</span>, <span class="hljs-string">"北京数据2"</span>);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> region, List&lt;<span class="hljs-built_in">String</span>&gt; dataList</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> data : dataList) {
            log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"处理{}的数据: {}"</span>, region, data);
            <span class="hljs-comment">// 实际的数据处理逻辑</span>
        }
    }
}
</code></pre>
<p>从架构对比可以看出，<code>XXL-JOB</code>更像是传统的C/S架构，而<code>Elastic-Job</code>则是真正的分布式架构。</p>
<p>这种差异带来了不同的特性和适用场景。</p>
<h2 data-id="heading-5">03 分片机制：手动分片 vs 智能分片</h2>
<p>分片处理是大数据量任务调度的核心需求。两个框架在分片机制上采取了完全不同的策略。</p>
<h3 data-id="heading-6">XXL-JOB：灵活的手动分片</h3>
<p><code>XXL-JOB</code>采用<strong>手动分片</strong>策略，调度中心将分片参数传递给执行器，执行器根据这些参数处理对应的数据。</p>
<pre><code class="hljs language-vbnet" lang="vbnet">@XxlJob(<span class="hljs-string">"orderProcessJob"</span>)
<span class="hljs-keyword">public</span> ReturnT&lt;<span class="hljs-type">String</span>&gt; orderProcessJob(<span class="hljs-type">String</span> param) {
    
    // 获取分片参数
    int shardIndex = XxlJobHelper.getShardIndex();
    int shardTotal = XxlJobHelper.getShardTotal();
    
    log.info(<span class="hljs-string">"开始处理订单数据，分片参数: index={}, total={}"</span>, shardIndex, shardTotal);
    
    // <span class="hljs-number">1</span>. 根据分片参数查询需要处理的订单
    List&lt;<span class="hljs-keyword">Order</span>&gt; orders = orderService.findOrdersByShard(shardIndex, shardTotal);
    
    // <span class="hljs-number">2</span>. 处理订单
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">Order</span> <span class="hljs-keyword">order</span> : orders) {
        <span class="hljs-keyword">try</span> {
            processOrder(<span class="hljs-keyword">order</span>);
            log.info(<span class="hljs-string">"订单处理成功: {}"</span>, <span class="hljs-keyword">order</span>.getOrderNo());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.<span class="hljs-keyword">error</span>(<span class="hljs-string">"订单处理失败: {}"</span>, <span class="hljs-keyword">order</span>.getOrderNo(), e);
            XxlJobHelper.handleFail(<span class="hljs-string">"订单处理失败: "</span> + <span class="hljs-keyword">order</span>.getOrderNo());
        }
    }
    
    <span class="hljs-keyword">return</span> ReturnT.SUCCESS;
}

// 在数据库中按分片查询的示例SQL
// <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_table 
// <span class="hljs-keyword">WHERE</span> status = <span class="hljs-comment">'待处理' </span>
//   <span class="hljs-built_in">AND</span> <span class="hljs-built_in">MOD</span>(order_id % #{shardTotal}) = #{shardIndex}
// <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time 
// LIMIT <span class="hljs-number">1000</span>
</code></pre>
<p><strong>手动分片的优势</strong>：</p>
<ol>
<li>1. <strong>灵活性高</strong>：开发者可以完全控制分片逻辑</li>
<li>2. <strong>数据划分灵活</strong>：可以根据业务特点自定义分片策略</li>
<li>3. <strong>容错性强</strong>：单个分片失败不影响其他分片</li>
</ol>
<p><strong>手动分片的不足</strong>：</p>
<ol>
<li>1. <strong>实现复杂</strong>：需要开发者自己实现分片逻辑</li>
<li>2. <strong>弹性不足</strong>：增加或减少节点时，需要手动调整分片策略</li>
</ol>
<h3 data-id="heading-7">Elastic-Job：智能的自动分片</h3>
<p><code>Elastic-Job</code>采用<strong>智能分片</strong>策略，框架自动根据当前在线节点数进行分片分配。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 数据流作业示例 - 更适合大数据处理场景</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataflowJobExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataflowJob</span>&lt;<span class="hljs-title class_">String</span>&gt; {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">ShardingContext context</span>) {
        <span class="hljs-comment">// 根据分片参数获取数据</span>
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; data = <span class="hljs-title function_">fetchDataByShard</span>(
            context.<span class="hljs-title function_">getShardingItem</span>(),
            context.<span class="hljs-title function_">getShardingTotalCount</span>()
        );
        
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"获取到{}条数据待处理"</span>, data.<span class="hljs-title function_">size</span>());
        <span class="hljs-keyword">return</span> data;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">ShardingContext context, List&lt;<span class="hljs-built_in">String</span>&gt; data</span>) {
        <span class="hljs-comment">// 处理数据</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> item : data) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-title function_">processItem</span>(item);
                log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"数据处理成功: {}"</span>, item);
            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"数据处理失败: {}"</span>, item, e);
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">fetchDataByShard</span>(<span class="hljs-params">int shardIndex, int shardTotal</span>) {
        <span class="hljs-comment">// 模拟从数据库或消息队列获取数据</span>
        <span class="hljs-comment">// 实际项目中这里可能是：</span>
        <span class="hljs-comment">// 1. 从数据库查询：WHERE MOD(id, #{shardTotal}) = #{shardIndex}</span>
        <span class="hljs-comment">// 2. 从消息队列消费特定分区的数据</span>
        <span class="hljs-comment">// 3. 从文件中读取特定部分的数据</span>
        
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % shardTotal == shardIndex) {
                data.<span class="hljs-title function_">add</span>(<span class="hljs-string">"data-"</span> + i);
            }
        }
        <span class="hljs-keyword">return</span> data;
    }
}
</code></pre>
<p><strong>智能分片的优势</strong>：</p>
<ol>
<li>1. <strong>自动化程度高</strong>：框架自动处理分片分配</li>
<li>2. <strong>弹性扩展</strong>：节点增减时，分片自动重新分配</li>
<li>3. <strong>负载均衡</strong>：自动确保各节点负载相对均衡</li>
</ol>
<p><strong>智能分片的不足</strong>：</p>
<ol>
<li>1. <strong>灵活性受限</strong>：分片策略由框架控制，自定义空间较小</li>
<li>2. <strong>学习成本高</strong>：需要理解框架的分片分配机制</li>
</ol>
<h2 data-id="heading-8">04 高可用性设计对比</h2>
<p>分布式系统的核心要求之一就是高可用性。两个框架在高可用设计上采用了不同的策略。</p>
<h3 data-id="heading-9">XXL-JOB的高可用设计</h3>
<p><code>XXL-JOB</code>通过数据库锁和心跳检测实现高可用：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 调度中心集群部署时，通过数据库锁保证只有一个调度中心工作</span>
<span class="hljs-comment">// 核心伪代码逻辑：</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduleThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Thread</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">while</span> (!stopped) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 1. 尝试获取数据库锁</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">tryLock</span>()) {
                    <span class="hljs-comment">// 2. 获取锁成功，执行调度</span>
                    <span class="hljs-title function_">scheduleJobs</span>();
                    
                    <span class="hljs-comment">// 3. 保持锁，直到调度完成</span>
                    <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">5</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 4. 获取锁失败，等待重试</span>
                    <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">10</span>);
                }
            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"调度线程异常"</span>, e);
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">tryLock</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 通过数据库行锁实现分布式锁</span>
        <span class="hljs-comment">// INSERT INTO xxl_job_lock (lock_name) VALUES ('schedule_lock')</span>
        <span class="hljs-comment">// 或者使用SELECT ... FOR UPDATE</span>
        <span class="hljs-keyword">return</span> dbLockService.<span class="hljs-title function_">acquireLock</span>(<span class="hljs-string">"schedule_lock"</span>);
    }
}

<span class="hljs-comment">// 执行器心跳检测</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorHeartbeat</span> {
    
    <span class="hljs-meta">@Scheduled</span>(fixedRate = <span class="hljs-number">30000</span>) <span class="hljs-comment">// 每30秒发送一次心跳</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendHeartbeat</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 向调度中心注册或更新心跳</span>
            registryService.<span class="hljs-title function_">registry</span>(
                executorConfig.<span class="hljs-title function_">getAppName</span>(),
                executorConfig.<span class="hljs-title function_">getAddress</span>()
            );
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
            log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"心跳发送失败"</span>, e);
        }
    }
}
</code></pre>
<h3 data-id="heading-10">Elastic-Job的高可用设计</h3>
<p><code>Elastic-Job</code>通过<code>ZooKeeper</code>的临时节点和监听机制实现高可用：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 基于ZooKeeper的分布式协调实现高可用</span>
public class ElectionListenerManager {
    
    public void <span class="hljs-built_in">start</span>() {
        <span class="hljs-comment">// 1. 创建Leader节点选举</span>
        leaderService<span class="hljs-selector-class">.electLeader</span>();
        
        <span class="hljs-comment">// 2. 监听分片节点变化</span>
        <span class="hljs-built_in">addShardingListener</span>();
        
        <span class="hljs-comment">// 3. 监听作业服务器变化</span>
        <span class="hljs-built_in">addJobServerListener</span>();
    }
    
    private void <span class="hljs-built_in">addShardingListener</span>() {
        <span class="hljs-comment">// 监听分片节点的变化</span>
        zookeeperRegistryCenter<span class="hljs-selector-class">.addCacheData</span>("/${jobName}/sharding");
        
        zookeeperRegistryCenter<span class="hljs-selector-class">.getClient</span>()
            <span class="hljs-selector-class">.getCuratorFramework</span>()
            <span class="hljs-selector-class">.getChildren</span>()
            <span class="hljs-selector-class">.usingWatcher</span>((CuratorWatcher) event -&gt; {
                <span class="hljs-comment">// 分片节点变化，重新分片</span>
                if (event.getType() == Watcher<span class="hljs-selector-class">.Event</span><span class="hljs-selector-class">.EventType</span><span class="hljs-selector-class">.NodeChildrenChanged</span>) {
                    reshardingService<span class="hljs-selector-class">.resharding</span>();
                }
            })
            <span class="hljs-selector-class">.forPath</span>("/${jobName}/sharding");
    }
    
    private void <span class="hljs-built_in">addJobServerListener</span>() {
        <span class="hljs-comment">// 监听作业服务器的上下线</span>
        zookeeperRegistryCenter<span class="hljs-selector-class">.addCacheData</span>("/${jobName}/servers");
        
        zookeeperRegistryCenter<span class="hljs-selector-class">.getClient</span>()
            <span class="hljs-selector-class">.getCuratorFramework</span>()
            <span class="hljs-selector-class">.getChildren</span>()
            <span class="hljs-selector-class">.usingWatcher</span>((CuratorWatcher) event -&gt; {
                <span class="hljs-comment">// 服务器节点变化，重新分配任务</span>
                if (event.getType() == Watcher<span class="hljs-selector-class">.Event</span><span class="hljs-selector-class">.EventType</span><span class="hljs-selector-class">.NodeChildrenChanged</span>) {
                    serverService<span class="hljs-selector-class">.syncServers</span>();
                }
            })
            <span class="hljs-selector-class">.forPath</span>("/${jobName}/servers");
    }
}
</code></pre>
<p><strong>高可用性对比分析</strong>：</p>



































<table><thead><tr><th>高可用维度</th><th>XXL-JOB</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>调度中心高可用</strong></td><td>数据库锁，同一时间只有一个调度中心工作</td><td>无中心调度器，天然无单点</td></tr><tr><td><strong>执行器高可用</strong></td><td>心跳检测，失败后任务路由到其他执行器</td><td>ZooKeeper临时节点，节点失效自动重新分片</td></tr><tr><td><strong>网络分区容忍</strong></td><td>调度中心与执行器断开后，任务暂停</td><td>ZooKeeper会话超时后，分片重新分配</td></tr><tr><td><strong>恢复时间</strong></td><td>依赖心跳间隔（默认30秒）</td><td>依赖ZooKeeper会话超时时间（默认60秒）</td></tr><tr><td><strong>实现复杂度</strong></td><td>简单直观</td><td>复杂但更健壮</td></tr></tbody></table>
<h2 data-id="heading-11">05 监控与管理能力</h2>
<p>对于生产系统来说，监控和管理能力同样重要。</p>
<h3 data-id="heading-12">XXL-JOB：完善的可视化管理</h3>
<p><code>XXL-JOB</code>提供了完整的Web管理界面，这是它的一大亮点：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 调度中心管理控制台的主要功能</span>
<span class="hljs-variable">@RestController</span>
<span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">"/jobadmin"</span>)
public class JobAdminController {
    
    <span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">"/add"</span>)
    public ReturnT&lt;String&gt; <span class="hljs-built_in">addJob</span>(<span class="hljs-variable">@RequestBody</span> XxlJobInfo jobInfo) {
        <span class="hljs-comment">// 添加任务</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">xxlJobService</span><span class="hljs-selector-class">.add</span>(jobInfo);
    }
    
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/trigger"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">ReturnT</span>&lt;<span class="hljs-selector-tag">String</span>&gt; <span class="hljs-selector-tag">triggerJob</span>(int id, String executorParam) {
        <span class="hljs-comment">// 手动触发任务</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">xxlJobService</span><span class="hljs-selector-class">.trigger</span>(id, executorParam);
    }
    
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/log"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">ReturnT</span>&lt;<span class="hljs-selector-tag">PageInfo</span>&lt;<span class="hljs-selector-tag">XxlJobLog</span>&gt;&gt; <span class="hljs-selector-tag">queryLog</span>(
            <span class="hljs-variable">@RequestParam</span>(required = false, defaultValue = <span class="hljs-string">"0"</span>) int start,
            <span class="hljs-variable">@RequestParam</span>(required = false, defaultValue = <span class="hljs-string">"10"</span>) int length,
            int jobId, int logStatus) {
        <span class="hljs-comment">// 查询任务日志</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">xxlJobService</span><span class="hljs-selector-class">.queryLog</span>(start, length, jobId, logStatus);
    }
    
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/dashboard"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">Map</span>&lt;<span class="hljs-selector-tag">String</span>, <span class="hljs-selector-tag">Object</span>&gt; <span class="hljs-selector-tag">dashboardInfo</span>() {
        <span class="hljs-comment">// 仪表板数据</span>
        <span class="hljs-selector-tag">Map</span>&lt;<span class="hljs-selector-tag">String</span>, <span class="hljs-selector-tag">Object</span>&gt; <span class="hljs-selector-tag">dashboardMap</span> = <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HashMap</span>&lt;&gt;();
        
        <span class="hljs-comment">// 任务数量统计</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"jobNum"</span>, xxlJobService.<span class="hljs-built_in">count</span>());
        
        <span class="hljs-comment">// 执行器数量</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"executorNum"</span>, executorService.<span class="hljs-built_in">count</span>());
        
        <span class="hljs-comment">// 今日调度次数</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"scheduleNumToday"</span>, logService.<span class="hljs-built_in">countToday</span>());
        
        <span class="hljs-comment">// 调度成功率</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"successRate"</span>, logService.<span class="hljs-built_in">successRate</span>());
        
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">dashboardMap</span>;
    }
}
</code></pre>
<p>管理界面主要功能：</p>
<ol>
<li>1. <strong>任务管理</strong>：增删改查定时任务</li>
<li>2. <strong>任务操作</strong>：启动、停止、手动触发、查看日志</li>
<li>3. <strong>执行器管理</strong>：管理执行器集群</li>
<li>4. <strong>调度日志</strong>：查看每次调度的详细日志</li>
<li>5. <strong>报表统计</strong>：调度次数、成功率等统计信息</li>
</ol>
<h3 data-id="heading-13">Elastic-Job：基于事件追踪的监控</h3>
<p><code>Elastic-Job</code>没有官方的Web管理界面，但提供了完善的事件追踪和监控API：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Elastic-Job的事件追踪配置</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventTraceConfiguration</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">JobEventConfiguration</span> <span class="hljs-title function_">jobEventConfiguration</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 1. 数据库事件追踪</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JobEventRdbConfiguration</span>(
            dataSource,
            <span class="hljs-string">"com.example.job.event"</span>, <span class="hljs-comment">// 表名前缀</span>
            <span class="hljs-literal">true</span>  <span class="hljs-comment">// 是否启用</span>
        );
        
        <span class="hljs-comment">// 或者使用ZooKeeper事件追踪</span>
        <span class="hljs-comment">// return new JobEventZookeeperConfiguration();</span>
    }
}

<span class="hljs-comment">// 自定义事件监听器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomJobEventListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractJobEventListener</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">dataSourceStatisticEvent</span>(<span class="hljs-params">JobExecutionEvent jobExecutionEvent</span>) {
        <span class="hljs-comment">// 统计事件处理</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业执行事件: jobName={}, status={}, startTime={}"</span>, 
                 jobExecutionEvent.<span class="hljs-title function_">getJobName</span>(),
                 jobExecutionEvent.<span class="hljs-title function_">getStatus</span>(),
                 jobExecutionEvent.<span class="hljs-title function_">getStartTime</span>());
        
        <span class="hljs-comment">// 可以发送到监控系统</span>
        monitorService.<span class="hljs-title function_">sendMetric</span>(
            <span class="hljs-string">"job.execution"</span>,
            jobExecutionEvent.<span class="hljs-title function_">isSuccess</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,
            <span class="hljs-string">"jobName"</span>, jobExecutionEvent.<span class="hljs-title function_">getJobName</span>()
        );
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">jobStatusTraceEvent</span>(<span class="hljs-params">JobStatusTraceEvent jobStatusTraceEvent</span>) {
        <span class="hljs-comment">// 作业状态追踪</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业状态变化: jobName={}, state={}, message={}"</span>, 
                 jobStatusTraceEvent.<span class="hljs-title function_">getJobName</span>(),
                 jobStatusTraceEvent.<span class="hljs-title function_">getState</span>(),
                 jobStatusTraceEvent.<span class="hljs-title function_">getMessage</span>());
    }
}
</code></pre>
<p><strong>监控能力对比</strong>：</p>



































<table><thead><tr><th>监控维度</th><th>XXL-JOB</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>管理界面</strong></td><td><strong>完整的Web管理控制台</strong></td><td>无官方界面，需自行开发</td></tr><tr><td><strong>日志查询</strong></td><td>内置日志查询功能</td><td>依赖应用日志，或通过事件追踪表查询</td></tr><tr><td><strong>实时监控</strong></td><td>提供简单的仪表板</td><td>需要集成第三方监控系统</td></tr><tr><td><strong>告警能力</strong></td><td>支持邮件告警</td><td>需自行实现告警逻辑</td></tr><tr><td><strong>扩展性</strong></td><td>监控功能相对固定</td><td><strong>事件监听机制扩展性强</strong></td></tr></tbody></table>
<h2 data-id="heading-14">06 性能与扩展性对比</h2>
<p>在实际生产环境中，性能和扩展性是需要重点考虑的因素。</p>
<h3 data-id="heading-15">性能对比</h3>
<p>通过基准测试，我们可以对比两个框架的关键性能指标：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 性能测试示例 - 模拟高并发调度场景</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceTest</span> {
    
    @Test
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testXXLJobSchedulePerformance</span>()</span> {
        <span class="hljs-comment">// 测试XXL-JOB的调度性能</span>
        <span class="hljs-built_in">int</span> jobCount = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 模拟1000个任务</span>
        <span class="hljs-built_in">long</span> startTime = System.currentTimeMillis();
        
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; jobCount; i++) {
            <span class="hljs-comment">// 模拟调度中心触发任务</span>
            triggerJob(i);
        }
        
        <span class="hljs-built_in">long</span> endTime = System.currentTimeMillis();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"XXL-JOB调度"</span> + jobCount + <span class="hljs-string">"个任务耗时: "</span> + 
                          (endTime - startTime) + <span class="hljs-string">"ms"</span>);
    }
    
    @Test
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testElasticJobSchedulePerformance</span>()</span> {
        <span class="hljs-comment">// 测试Elastic-Job的分片执行性能</span>
        <span class="hljs-built_in">int</span> dataSize = <span class="hljs-number">100000</span>; <span class="hljs-comment">// 10万条数据</span>
        <span class="hljs-built_in">int</span> shardTotal = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 10个分片</span>
        
        <span class="hljs-built_in">long</span> startTime = System.currentTimeMillis();
        
        <span class="hljs-comment">// 模拟分片处理</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> shardIndex = <span class="hljs-number">0</span>; shardIndex &lt; shardTotal; shardIndex++) {
            processShardData(shardIndex, shardTotal, dataSize / shardTotal);
        }
        
        <span class="hljs-built_in">long</span> endTime = System.currentTimeMillis();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Elastic-Job处理"</span> + dataSize + <span class="hljs-string">"条数据耗时: "</span> + 
                          (endTime - startTime) + <span class="hljs-string">"ms"</span>);
    }
}
</code></pre>
<p><strong>性能对比数据（基于典型场景测试）</strong> ：</p>



































<table><thead><tr><th>性能指标</th><th>XXL-JOB</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>调度吞吐量</strong></td><td>单调度中心约500-1000任务/秒</td><td>无中心瓶颈，取决于节点数量</td></tr><tr><td><strong>任务触发延迟</strong></td><td>10-50毫秒</td><td>5-20毫秒（无中心转发）</td></tr><tr><td><strong>分片处理性能</strong></td><td>依赖手动分片实现</td><td><strong>优秀，自动负载均衡</strong></td></tr><tr><td><strong>资源消耗</strong></td><td>调度中心需独立资源</td><td>与业务应用共享资源</td></tr><tr><td><strong>水平扩展性</strong></td><td>调度中心扩展有限</td><td><strong>优秀，随节点增加线性扩展</strong></td></tr></tbody></table>
<h3 data-id="heading-16">扩展性对比</h3>
<p><strong>XXL-JOB的扩展点</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 自定义路由策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRouteStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ExecutorRouter</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">route</span>(<span class="hljs-params">TriggerParam triggerParam, List&lt;<span class="hljs-built_in">String</span>&gt; addressList</span>) {
        <span class="hljs-comment">// 自定义执行器路由逻辑</span>
        <span class="hljs-comment">// 例如：根据任务参数选择特定的执行器</span>
        
        <span class="hljs-title class_">String</span> jobParam = triggerParam.<span class="hljs-title function_">getExecutorParams</span>();
        <span class="hljs-keyword">if</span> (jobParam.<span class="hljs-title function_">contains</span>(<span class="hljs-string">"priority=high"</span>)) {
            <span class="hljs-comment">// 高优先级任务路由到专用执行器</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnT</span>&lt;&gt;(<span class="hljs-title function_">findHighPriorityExecutor</span>(addressList));
        }
        
        <span class="hljs-comment">// 默认使用轮询策略</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnT</span>&lt;&gt;(addressList.<span class="hljs-title function_">get</span>(<span class="hljs-number">0</span>));
    }
}

<span class="hljs-comment">// 自定义任务处理器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomJobHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">IJobHandler</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">execute</span>(<span class="hljs-title class_">String</span> param) throws <span class="hljs-title class_">Exception</span> {
        <span class="hljs-comment">// 自定义任务执行逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnT</span>&lt;&gt;(<span class="hljs-title class_">ReturnT</span>.<span class="hljs-property">SUCCESS_CODE</span>, <span class="hljs-string">"自定义处理完成"</span>);
    }
}
</code></pre>
<p><strong>Elastic-Job的扩展点</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 自定义分片策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomShardingStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JobShardingStrategy</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JobInstance</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; <span class="hljs-title function_">sharding</span>(<span class="hljs-params">
            List&lt;JobInstance&gt; jobInstances,
            <span class="hljs-built_in">String</span> jobName,
            int shardingTotalCount</span>) {
        
        <span class="hljs-comment">// 自定义分片算法</span>
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JobInstance</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        
        <span class="hljs-comment">// 示例：根据实例的性能权重分配分片</span>
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JobInstance</span>, <span class="hljs-title class_">Integer</span>&gt; weights = <span class="hljs-title function_">getInstanceWeights</span>(jobInstances);
        
        <span class="hljs-comment">// 实现加权分片算法</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">weightedSharding</span>(jobInstances, weights, shardingTotalCount);
    }
}

<span class="hljs-comment">// 自定义作业监听器</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomJobListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ElasticJobListener</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">beforeJobExecuted</span>(<span class="hljs-params">ShardingContexts shardingContexts</span>) {
        <span class="hljs-comment">// 作业执行前的逻辑</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业{}开始执行，分片上下文: {}"</span>, 
                 shardingContexts.<span class="hljs-title function_">getJobName</span>(), shardingContexts);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">afterJobExecuted</span>(<span class="hljs-params">ShardingContexts shardingContexts</span>) {
        <span class="hljs-comment">// 作业执行后的逻辑</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业{}执行完成"</span>, shardingContexts.<span class="hljs-title function_">getJobName</span>());
    }
}
</code></pre>
<h2 data-id="heading-17">07 实战选型指南</h2>
<p>基于我多年的开发和架构经验，总结出以下选型建议：</p>
<h3 data-id="heading-18">场景一：中小型项目，快速上线</h3>
<ul>
<li>• <strong>推荐</strong>：<code>XXL-JOB</code></li>
<li>• <strong>理由</strong>：开箱即用，有完善的管理界面，学习成本低</li>
<li>• <strong>典型场景</strong>：企业内部管理系统、中小型电商、内容管理系统</li>
</ul>

<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 快速启动配置示例</span>
<span class="hljs-attr">xxl:</span>
  <span class="hljs-attr">job:</span>
    <span class="hljs-attr">admin:</span>
      <span class="hljs-string">addresses:</span> <span class="hljs-string">http://localhost:8080/xxl-job-admin</span>
    <span class="hljs-attr">executor:</span>
      <span class="hljs-string">appname:</span> <span class="hljs-string">xxl-job-executor-demo</span>
      <span class="hljs-string">address:</span> 
      <span class="hljs-string">ip:</span> 
      <span class="hljs-string">port:</span> <span class="hljs-number">9999</span>
      <span class="hljs-string">logpath:</span> <span class="hljs-string">/data/applogs/xxl-job/jobhandler</span>
      <span class="hljs-string">logretentiondays:</span> <span class="hljs-number">30</span>
</code></pre>
<h3 data-id="heading-19">场景二：大数据量处理，需要弹性扩缩容</h3>
<ul>
<li>• <strong>推荐</strong>：<code>Elastic-Job</code></li>
<li>• <strong>理由</strong>：智能分片，自动负载均衡，适合大数据处理</li>
<li>• <strong>典型场景</strong>：数据清洗、报表生成、日志分析、ETL任务</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 大数据处理作业配置</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">DataflowJob</span> <span class="hljs-title function_">dataflowJob</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDataProcessingJob</span>();
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">LiteJobConfiguration</span> <span class="hljs-title function_">bigDataJobConfig</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">LiteJobConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataflowJobConfiguration</span>(
            <span class="hljs-title class_">JobCoreConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
                <span class="hljs-string">"bigDataJob"</span>, 
                <span class="hljs-string">"0 0 2 * * ?"</span>,  <span class="hljs-comment">// 每天凌晨2点执行</span>
                <span class="hljs-number">10</span>               <span class="hljs-comment">// 10个分片</span>
            ).<span class="hljs-title function_">build</span>(),
            <span class="hljs-title class_">BigDataProcessingJob</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">getCanonicalName</span>()
        )
    ).<span class="hljs-title function_">monitorPort</span>(<span class="hljs-number">9888</span>)  <span class="hljs-comment">// 监控端口</span>
     .<span class="hljs-title function_">overwrite</span>(<span class="hljs-literal">true</span>)
     .<span class="hljs-title function_">build</span>();
}
</code></pre>
<h3 data-id="heading-20">场景三：已有ZooKeeper集群的技术栈</h3>
<ul>
<li>• <strong>推荐</strong>：<code>Elastic-Job</code></li>
<li>• <strong>理由</strong>：复用现有基础设施，降低运维复杂度</li>
<li>• <strong>典型场景</strong>：大型互联网公司、金融系统、已有ZooKeeper服务发现的系统</li>
</ul>
<h3 data-id="heading-21">场景四：需要精细化管理与监控</h3>
<ul>
<li>• <strong>推荐</strong>：<code>XXL-JOB</code></li>
<li>• <strong>理由</strong>：提供完整的Web管理界面，便于运维</li>
<li>• <strong>典型场景</strong>：对运维友好性要求高的项目、多团队协作项目</li>
</ul>
<h3 data-id="heading-22">场景五：混合架构的折中方案</h3>
<p>在实际项目中，有时可以采用混合方案：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b82cc83bc204986bb6771463a25d3e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5LiJ6K-05oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212918&amp;x-signature=6FythrpPevMfftd%2BM4j2NocVfpQ%3D" alt="图片" loading="lazy"/></p>
<p>在这种混合架构中：</p>
<ol>
<li>1. <strong>常规定时任务</strong>：使用<code>XXL-JOB</code>，便于管理和监控</li>
<li>2. <strong>大数据分片任务</strong>：使用<code>Elastic-Job</code>，发挥其分布式处理优势</li>
<li>3. <strong>优势互补</strong>：结合两者的优点，满足不同场景需求</li>
</ol>
<p>更多项目实战在：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fsusan.net.cn%2Fproject" title="https://link.juejin.cn/?target=http%3A%2F%2Fsusan.net.cn%2Fproject" target="_blank">java突击队</a></p>
<h2 data-id="heading-23">总结</h2>
<p>经过全面的对比分析，我们可以得出以下结论：</p>
<p><strong>XXL-JOB更适合</strong>：</p>
<ul>
<li>• 中小型项目，需要快速上手</li>
<li>• 对运维管理界面有要求的团队</li>
<li>• 任务类型相对简单，不需要复杂分片逻辑</li>
<li>• 技术栈中已有MySQL，不想引入ZooKeeper</li>
</ul>
<p><strong>Elastic-Job更适合</strong>：</p>
<ul>
<li>• 大数据量处理场景，需要智能分片</li>
<li>• 已有ZooKeeper基础设施的团队</li>
<li>• 需要高度弹性伸缩的云原生环境</li>
<li>• 对性能要求极高，需要去中心化架构</li>
</ul>
<p><strong>技术选型的核心原则</strong>：</p>
<ol>
<li>1. <strong>没有最好的框架，只有最适合的框架</strong></li>
<li>2. <strong>考虑团队技术栈和运维能力</strong></li>
<li>3. <strong>根据业务场景选择，而不是技术潮流</strong></li>
<li>4. <strong>简单性原则：在满足需求的前提下，选择更简单的方案</strong></li>
</ol>
<p>有些小伙伴在工作中可能会纠结于技术选型，我的建议是：<strong>先明确业务需求，再选择技术方案</strong>。</p>
<p>如果你需要一个开箱即用、管理方便的调度系统，选<code>XXL-JOB</code>；如果你要处理海量数据、需要弹性伸缩，选<code>Elastic-Job</code>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— mapping、filtering 和 fla]]></title>    <link>https://juejin.cn/post/7603781883974582291</link>    <guid>https://juejin.cn/post/7603781883974582291</guid>    <pubDate>2026-02-09T00:56:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883974582291" data-draft-id="7604084016509648937" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— mapping、filtering 和 fla"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2026-02-09T00:56:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Cache技术分享"/> <meta itemprop="url" content="https://juejin.cn/user/1662117313262776"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— mapping、filtering 和 fla
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1662117313262776/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Cache技术分享
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T00:56:16.000Z" title="Mon Feb 09 2026 00:56:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— <code>mapping</code>、<code>filtering</code> 和 <code>flatMapping</code></h2>
<p>在使用 <code>Stream</code> 的 <code>collect()</code> 方法时，我们通常接触的 <code>Collector</code> 是 <strong>终端操作（<code>terminal operations</code>）</strong>，比如：</p>
<ul>
<li><code>Collectors.counting()</code>：计算数量 ✅</li>
<li><code>Collectors.joining()</code>：拼接字符串 ✅</li>
<li><code>Collectors.toList()</code>、<code>toSet()</code>、<code>toMap()</code>：收集到集合 ✅</li>
</ul>
<p>但除了这些终端操作外，<code>Java</code> 的 <code>Collector</code> <code>API</code> 还提供了一些 <strong>中间 <code>Collector</code></strong>，如：</p>
<ul>
<li><code>mapping</code></li>
<li><code>filtering</code></li>
<li><code>flatMapping</code></li>
</ul>
<p>这些 Collector 本身无法单独使用，必须配合一个 <strong>下游 Collector（downstream collector）</strong>。你可以理解为：</p>
<blockquote>
<p>🎯 “我们在收集之前，先加工一下再装袋。”</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">🧭 为什么需要中间 Collector？</h3>
<p>有时候，我们不仅想将元素分组或收集，还想在收集之前“处理一下”。比如：</p>
<ul>
<li>把字符串变成大写再收集</li>
<li>过滤掉不想要的值再分组</li>
<li>将一个对象映射为其某个字段再放进 Map</li>
</ul>
<p>这时候中间 Collector 就登场了！</p>
<hr/>
<h3 data-id="heading-2">🧪 示例 1：使用 <code>mapping()</code> 做数据转换</h3>
<p>假设你有一堆英文单词字符串，想将它们变成大写字母并放进列表中：</p>
<pre><code class="hljs language-java" lang="java">Collection&lt;String&gt; strings = List.of(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>, 
                                     <span class="hljs-string">"seven"</span>, <span class="hljs-string">"eight"</span>, <span class="hljs-string">"nine"</span>, <span class="hljs-string">"ten"</span>, <span class="hljs-string">"eleven"</span>, <span class="hljs-string">"twelve"</span>);

List&lt;String&gt; result = strings.stream()
    .collect(Collectors.mapping(String::toUpperCase, Collectors.toList()));

System.out.println(<span class="hljs-string">"result = "</span> + result);
</code></pre>
<h4 data-id="heading-3">🧾 输出：</h4>
<pre><code class="hljs language-java" lang="java">result = [ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, ELEVEN, TWELVE]
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>mapping(String::toUpperCase, ...)</code> 是中间 Collector，先把元素变为大写。</li>
<li><code>Collectors.toList()</code> 是终端 Collector，把处理结果装进列表。</li>
</ul>
<p>你可以把这看作是“加工厂 + 装箱厂”的组合 🤖📦。</p>
<hr/>
<h3 data-id="heading-4">🧪 示例 2：结合 <code>groupingBy()</code> 和 <code>mapping()</code> 解决复杂 Map 转换问题</h3>
<p>假设你要统计不同长度的单词出现次数（即直方图），然后你想<strong>倒转这个 Map</strong>，以“次数”为 key，得到这些次数对应的“长度”。</p>
<p>第一步：创建直方图 <code>Map&lt;Integer, Long&gt;</code>：</p>
<pre><code class="hljs language-java" lang="java">Map&lt;Integer, Long&gt; histogram = strings.stream()
    .collect(Collectors.groupingBy(String::length, Collectors.counting()));
</code></pre>
<p>第二步：使用 <code>record</code> 将 Map entry 封装成对象，方便处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">record</span> <span class="hljs-title class_">NumberOfLength</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">long</span> number)</span> {
    <span class="hljs-keyword">static</span> NumberOfLength <span class="hljs-title function_">fromEntry</span><span class="hljs-params">(Map.Entry&lt;Integer, Long&gt; entry)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberOfLength</span>(entry.getKey(), entry.getValue());
    }
}
</code></pre>
<p>第三步：倒转 Map，以“次数”为 key，用 <code>mapping()</code> 提取 <code>length</code> 字段：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">var</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> histogram.entrySet().stream()
    .map(NumberOfLength::fromEntry)
    .collect(Collectors.groupingBy(
        NumberOfLength::number, <span class="hljs-comment">// 按出现次数分组</span>
        Collectors.mapping(NumberOfLength::length, Collectors.toList()) <span class="hljs-comment">// 提取 length 放进 List</span>
    ));

map.forEach((key, value) -&gt; System.out.println(key + <span class="hljs-string">" :: "</span> + value));
</code></pre>
<h4 data-id="heading-5">🔍 输出示例：</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-number">2</span> :: [<span class="hljs-number">6</span>]
<span class="hljs-number">3</span> :: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<p>这表示：长度为 3、4、5 的单词各出现了 3 次；长度为 6 的出现了 2 次。</p>
<hr/>
<h3 data-id="heading-6">🏆 提取最大值对应的 key（次数最多的字符串长度）</h3>
<pre><code class="hljs language-java" lang="java">Map.Entry&lt;Long, List&lt;Integer&gt;&gt; result =
    map.entrySet().stream()
        .max(Map.Entry.comparingByKey()) <span class="hljs-comment">// 找到次数最多的 group</span>
        .orElseThrow();

System.out.println(<span class="hljs-string">"result = "</span> + result);
</code></pre>
<p>输出：</p>
<pre><code class="hljs language-java" lang="java">result = <span class="hljs-number">3</span>=[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<p>你就得到了出现次数最多的字符串长度（3 次）：长度为 3、4、5 的单词。</p>
<hr/>
<h3 data-id="heading-7">🧪 示例 3：使用 <code>filtering()</code> 收集特定条件的值</h3>
<ul>
<li>java9+可用</li>
</ul>
<pre><code class="hljs language-java" lang="java">Map&lt;Integer, List&lt;String&gt;&gt; filteredGrouped =
    strings.stream()
           .collect(Collectors.groupingBy(
               String::length,
               Collectors.filtering(s -&gt; s.contains(<span class="hljs-string">"e"</span>), Collectors.toList())
           ));

System.out.println(filteredGrouped);
</code></pre>
<p>📌 解释：</p>
<ul>
<li><code>filtering()</code> 是一个中间 Collector，只收集包含字母 <code>'e'</code> 的单词。</li>
<li>最终结果还是一个分组，但每组只留下符合条件的值。</li>
</ul>
<hr/>
<h3 data-id="heading-8">🧪 示例 4：使用 <code>flatMapping()</code> 将嵌套集合打平</h3>
<ul>
<li>java9+可用</li>
</ul>
<p>如果你有一个 <code>List&lt;List&lt;String&gt;&gt;</code>，想打平成一个大列表，可以这样：</p>
<pre><code class="hljs language-java" lang="java">List&lt;List&lt;String&gt;&gt; nested = List.of(
    List.of(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>),
    List.of(<span class="hljs-string">"c"</span>),
    List.of(<span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span>)
);

List&lt;String&gt; flat = nested.stream()
    .collect(Collectors.flatMapping(List::stream, Collectors.toList()));

System.out.println(flat);
</code></pre>
<p>📌 输出：</p>
<pre><code class="hljs language-java" lang="java">[a, b, c, d, e, f]
</code></pre>
<hr/>
<h3 data-id="heading-9">🎯 总结与培训小贴士</h3>

























<table><thead><tr><th>Collector 类型</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td><code>mapping()</code></td><td>将元素映射后再收集</td><td>提取字段、格式转换</td></tr><tr><td><code>filtering()</code></td><td>筛选符合条件的元素再收集</td><td>条件收集</td></tr><tr><td><code>flatMapping()</code></td><td>扁平化流结构后收集</td><td>嵌套集合、多个子项的合并</td></tr></tbody></table>
<p>✅ 这些中间 Collector 是创建嵌套结构和处理 Map 数据的强大工具。
✅ 多层嵌套也没什么可怕的，本质是“先加工后装袋”的组合模型。
✅ <code>groupingBy()</code> 搭配中间 Collector 是流处理中最常见也最强大的用法之一。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Skills Desktop：一个用来管理 Skill 的桌面工具]]></title>    <link>https://juejin.cn/post/7604080364353667099</link>    <guid>https://juejin.cn/post/7604080364353667099</guid>    <pubDate>2026-02-09T02:22:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604080364353667099" data-draft-id="7604646882015248435" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Skills Desktop：一个用来管理 Skill 的桌面工具"/> <meta itemprop="keywords" content="Cursor,AI编程"/> <meta itemprop="datePublished" content="2026-02-09T02:22:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HBLOG"/> <meta itemprop="url" content="https://juejin.cn/user/131597124767479"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Skills Desktop：一个用来管理 Skill 的桌面工具
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/131597124767479/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HBLOG
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:22:30.000Z" title="Mon Feb 09 2026 02:22:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在实际开发过程中，Skill 用得多了，很容易变成一种“看似都在，其实很乱”的状态。</p>
<ul>
<li>有的在 GitHub 仓库里</li>
<li>有的拷在本地某个目录</li>
<li>有的只存在于旧项目里</li>
</ul>
<p><strong>Skills Desktop</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fskills.lc%2Fdesktop%25EF%25BC%2589%25E5%25B0%25B1%25E6%2598%25AF%25E5%259C%25A8%25E8%25BF%2599%25E7%25A7%258D%25E6%2583%2585%25E5%2586%25B5%25E4%25B8%258B%25E5%2587%25BA%25E7%258E%25B0%25E7%259A%2584%25E3%2580%2582" target="_blank" title="https://skills.lc/desktop%EF%BC%89%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%E5%87%BA%E7%8E%B0%E7%9A%84%E3%80%82" ref="nofollow noopener noreferrer">skills.lc/desktop）就是在…</a><br/>
它不是编辑器，也不是运行环境，而是一个<strong>专门用来管理 Skill 的桌面客户端</strong>。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F02%2Fimage-3.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/02/image-3.png" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b61b6b812c584ecfad7b0ed30571f903~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208550&amp;x-signature=VazL%2FUobzhhGG%2ByrwZfoRBA%2BehE%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-0">它主要解决什么问题</h2>
<p>一句话概括：</p>
<blockquote>
<p><strong>让 Skill 在本地有一个“固定的位置和统一的管理方式”。</strong></p>
</blockquote>
<p>不需要再记路径，也不用反复复制文件。</p>
<h2 data-id="heading-1">本地集中管理 Skill</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F02%2Fimage-2.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/02/image-2.png" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b53d354829854f28aa93f6be65dc666f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208550&amp;x-signature=1nwzfcW0bjrqYkoImx9DFep7HlY%3D" alt="" loading="lazy"/></a></p>
<p>Skills Desktop 做的第一件事，就是把 Skill 统一放到一个地方。</p>
<p>你可以：</p>
<ul>
<li>把 Skill 安装到本地</li>
<li>看到当前有哪些 Skill</li>
<li>按用途或项目去整理</li>
</ul>
<p>它更像一个 <strong>本地 Skill 仓库管理器</strong>，而不是展示工具。</p>
<h2 data-id="heading-2">不依赖浏览器，更贴近工作流</h2>
<p>很多时候你并不想打开网页：</p>
<ul>
<li>正在写代码</li>
<li>正在调试脚本</li>
<li>正在切项目</li>
</ul>
<p>Skills Desktop 是常驻本地的：</p>
<ul>
<li>打开速度快</li>
<li>不依赖网络</li>
<li>不用来回切标签页</li>
</ul>
<p>需要用 Skill 的时候，直接就在桌面端处理。</p>
<h2 data-id="heading-3">不强绑定工具和框架</h2>
<p>Skills Desktop 不要求你：</p>
<ul>
<li>换 IDE</li>
<li>用特定模型</li>
<li>绑定某个平台</li>
</ul>
<p>它只负责一件事：<br/>
<strong>把 Skill 准备好，交给你现有的工具去用。</strong></p>
<p>这一点在多项目、多环境下特别重要。</p>
<h2 data-id="heading-4">离线可用</h2>
<p>Skill 一旦同步到本地：</p>
<ul>
<li>不需要联网</li>
<li>不依赖远程仓库</li>
<li>不影响日常开发</li>
</ul>
<p>对于经常出差、网络不稳定，或者只是想保持工作节奏的人来说，这点很实在。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F02%2Fimage-4.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/02/image-4.png" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9f801406cfd4522b8075a4292bc2943~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208550&amp;x-signature=46tnfy%2BNJ7OqZS8urDLKRhBWdrg%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-5">适合什么人用</h2>
<p>Skills Desktop 更适合：</p>
<ul>
<li>本地有多个项目的人</li>
<li>需要长期维护 Skill 的人</li>
<li>不想每次都重新整理 Prompt / Skill 的人</li>
<li>希望把 Skill 当成工具，而不是素材的人</li>
</ul>
<p>如果你只是偶尔复制一段提示词，它可能不是必须的；<br/>
但如果 Skill 已经成了你工作的一部分，它会省掉不少麻烦。</p>
<h2 data-id="heading-6">总结</h2>
<p>Skills Desktop 并不复杂，也不试图做“万能工具”。</p>
<p>它只是把一件一直很乱的事情——<br/>
<strong>Skill 的本地管理</strong>，变得清晰、有序、可持续。</p>
<p>官网：<br/>
👉 <a href="https://link.juejin.cn?target=https%3A%2F%2Fskills.lc%2Fdesktop" target="_blank" title="https://skills.lc/desktop" ref="nofollow noopener noreferrer">skills.lc/desktop</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 GPIO 八种工作模式：从原理到实战应用]]></title>    <link>https://juejin.cn/post/7603783314713624612</link>    <guid>https://juejin.cn/post/7603783314713624612</guid>    <pubDate>2026-02-09T01:11:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603783314713624612" data-draft-id="7603911453704978475" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 GPIO 八种工作模式：从原理到实战应用"/> <meta itemprop="keywords" content="嵌入式"/> <meta itemprop="datePublished" content="2026-02-09T01:11:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="what丶k"/> <meta itemprop="url" content="https://juejin.cn/user/2578801884147418"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 GPIO 八种工作模式：从原理到实战应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2578801884147418/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    what丶k
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:11:23.000Z" title="Mon Feb 09 2026 01:11:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读21分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解 GPIO 八种工作模式：从原理到实战应用</h2>
<p>作为嵌入式开发中最基础也最核心的外设，GPIO（通用输入/输出口）就像是单片机与外部世界沟通的“桥梁”。而 GPIO 的八种工作模式——浮空输入、上拉输入、下拉输入、模拟输入、开漏输出、推挽输出、复用开漏输出、复用推挽输出，直接决定了这座“桥梁”的沟通方式、稳定性和适用场景。</p>
<p>很多嵌入式新手在初期都会被这八种模式搞混，不清楚每种模式的底层逻辑的适用场景，甚至在项目中因模式选择错误导致设备工作异常（比如按键检测失灵、LED 闪烁不稳定、总线通信失败）。今天，我们就逐一拆解这八种模式，从工作原理、电路特性、实战场景三个维度，帮你彻底吃透，再也不踩坑。</p>
<h2 data-id="heading-1">一、先理清核心：输入模式 vs 输出模式</h2>
<p>GPIO 的八种模式本质上可以分为两大类：<strong>​输入模式（4 种）​</strong>和​**输出模式（4 种）**​。核心区别在于：输入模式是 GPIO 接收外部信号（如按键、传感器的电平），输出模式是 GPIO 向外部发送信号（如驱动 LED、控制继电器）。而“复用”则是指 GPIO 不再由软件直接控制，而是交由单片机内部外设（如 UART、SPI、I2C）使用，本质还是输入或输出逻辑。</p>
<h2 data-id="heading-2">二、输入模式详解（4 种）：接收外部信号的“正确姿势”</h2>
<p>输入模式的核心是“高阻抗接收”，GPIO 本身不主动输出电平，仅作为信号的“接收端”，核心差异在于是否通过电阻固定电平（避免信号不稳定），以及是否用于模拟信号采集。</p>
<h3 data-id="heading-3">1. 浮空输入（Floating Input）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚处于高阻抗状态，不接内部上拉或下拉电阻，引脚电平完全由外部电路决定，相当于“悬浮”在空中，仅被动接收外部信号。</p>
<p>​<strong>工作原理</strong>​：引脚内部未连接任何固定电阻，输入阻抗极高（接近开路），外部信号的微小变化都会影响引脚电平。此时 GPIO 仅作为“信号检测端”，不干预外部电平。</p>
<p>​<strong>实战场景</strong>​：仅适用于外部电路已明确提供稳定电平的场景，比如连接 TTL 电平传感器（如红外接收头、串口 RX 引脚）、外部有下拉/上拉电阻的按键电路。</p>
<p>​<strong>注意事项</strong>​：若外部电路未提供固定电平（如悬空的按键），引脚电平会处于“不确定状态”（可能是高电平、低电平，或受干扰波动），导致检测错误，因此​<strong>禁止单独用于按键检测等无外部固定电平的场景</strong>​。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 浮空输入模式配置（PA0）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_FloatingInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟（STM32必须先使能外设时钟）</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为浮空输入模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="hljs-comment">// 浮空输入模式</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 引脚速度（输入模式可忽略，默认配置即可）</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

<span class="hljs-comment">// 读取浮空输入引脚电平（示例）</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">GPIO_Read_FloatingInput</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 读取PA0引脚电平，返回0（低电平）或1（高电平）</span>
    <span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
}
</code></pre>
<p>关键：<code>GPIO_Mode_IN_FLOATING</code> 对应浮空输入模式，无需配置上拉/下拉电阻，直接读取外部电平即可。</p>
<h3 data-id="heading-4">2. 上拉输入（Pull-Up Input）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部连接一个上拉电阻（一端接 VCC，另一端接引脚），无外部信号时，引脚被拉至高电平；当外部电路将引脚拉至低电平时，引脚电平变为低电平。</p>
<p>​<strong>工作原理</strong>​：内部上拉电阻（通常为 10K~100KΩ）提供一个稳定的高电平偏置，外部信号通过拉低引脚来改变电平状态。例如，按键一端接 GPIO（上拉输入），另一端接地，未按下时引脚为高电平，按下时引脚被拉低为低电平。</p>
<p>​<strong>实战场景</strong>​：最常用的输入模式，适合外部无固定电平的场景，比如独立按键检测、接近开关（NPN 型）信号接收、外部设备的“就绪/忙碌”信号检测（低电平有效）。</p>
<p>​<strong>优势</strong>​：解决浮空输入的不稳定问题，无需外部额外接电阻，简化电路设计，降低成本。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，适配独立按键检测）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 上拉输入模式配置（PA0，适配独立按键）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PullUpInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为上拉输入模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;      <span class="hljs-comment">// 上拉输入模式（IPU = Input Pull-Up）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输入模式可忽略速度配置</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

<span class="hljs-comment">// 读取上拉输入引脚电平（检测按键）</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">Key_Read_PullUp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 按键一端接PA0，另一端接地；未按下时PA0为高电平（1），按下时为低电平（0）</span>
    <span class="hljs-keyword">if</span>(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == <span class="hljs-number">0</span>)
    {
        <span class="hljs-comment">// 延时消抖（简单消抖，实际项目可优化）</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">uint32_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++);
        <span class="hljs-keyword">if</span>(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 按键按下</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 按键未按下</span>
}
</code></pre>
<p>关键：<code>GPIO_Mode_IPU</code> 对应上拉输入，内部自动使能上拉电阻，无需外接，直接适配独立按键检测。</p>
<h3 data-id="heading-5">3. 下拉输入（Pull-Down Input）</h3>
<p>​<strong>核心定义</strong>​：与上拉输入相反，GPIO 引脚内部连接一个下拉电阻（一端接地 GND，另一端接引脚），无外部信号时，引脚被拉至低电平；当外部电路将引脚拉至高电平时，引脚电平变为高电平。</p>
<p>​<strong>工作原理</strong>​：内部下拉电阻提供低电平偏置，外部信号通过拉高引脚来触发电平变化。例如，按键一端接 GPIO（下拉输入），另一端接 VCC，未按下时引脚为低电平，按下时引脚被拉高为高电平。</p>
<p>​<strong>实战场景</strong>​：适合外部信号为高电平有效的场景，比如 PNP 型接近开关信号接收、外部设备的“触发信号”检测（高电平有效）、继电器的状态反馈（高电平表示吸合）。</p>
<p>​<strong>与上拉输入的区别</strong>​：核心是“默认电平”和“触发电平”相反，根据外部电路的电平极性选择，避免电平冲突。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 下拉输入模式配置（PA0）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PullDownInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为下拉输入模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;      <span class="hljs-comment">// 下拉输入模式（IPD = Input Pull-Down）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输入模式可忽略速度配置</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

<span class="hljs-comment">// 读取下拉输入引脚电平（示例）</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">GPIO_Read_PullDownInput</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 未接外部信号时，PA0为低电平（0）；外部拉高时，返回高电平（1）</span>
    <span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
}
</code></pre>
<p>关键：<code>GPIO_Mode_IPD</code> 对应下拉输入，内部自动使能下拉电阻，默认电平为低，适配高电平有效信号。</p>
<h3 data-id="heading-6">4. 模拟输入（Analog Input）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部断开数字输入缓冲器，直接将外部模拟信号（连续变化的电压信号）传入单片机内部的 ADC（模数转换器），用于采集模拟量。</p>
<p>​<strong>工作原理</strong>​：与数字输入（仅识别高/低电平）不同，模拟输入可接收 0~VCC 之间的任意电压值（如 0~3.3V、0~5V），并通过 ADC 转换为数字信号，供单片机处理。此时引脚不再用于数字信号检测，仅作为模拟信号的“传输通道”。</p>
<p>​<strong>实战场景</strong>​：模拟量采集场景，比如电位器调节（采集电阻变化对应的电压）、温度传感器（如 LM35，输出电压随温度变化）、湿度传感器、光照传感器等，需要获取连续变化的物理量时使用。</p>
<p>​<strong>注意事项</strong>​：并非所有 GPIO 引脚都支持模拟输入，需查看单片机 datasheet，通常标注为“ADCx_INx”的引脚才可作为模拟输入使用；模拟输入引脚不宜接强电，避免损坏 ADC 模块。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，PA0 对应 ADC1_IN0）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_adc.h"</span></span>

<span class="hljs-comment">// 模拟输入模式配置（PA0，用于ADC采集）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_AnalogInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA和ADC1时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_ADC1, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为模拟输入模式（关键：断开数字缓冲，接入ADC）</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;      <span class="hljs-comment">// 模拟输入模式（AIN = Analog Input）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 模拟输入模式可忽略速度</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// （可选）ADC初始化（模拟输入需配合ADC使用，完整示例）</span>
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; <span class="hljs-comment">// ADC1独立工作模式</span>
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;      <span class="hljs-comment">// 单通道采集</span>
    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; <span class="hljs-comment">// 连续采集模式</span>
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; <span class="hljs-comment">// 无外部触发</span>
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; <span class="hljs-comment">// 数据右对齐</span>
    ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 采集通道数量</span>
    ADC_Init(ADC1, &amp;ADC_InitStructure);
    
    <span class="hljs-comment">// 使能ADC1</span>
    ADC_Cmd(ADC1, ENABLE);
}

<span class="hljs-comment">// 读取模拟输入ADC值（示例）</span>
<span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ADC_Read_AnalogInput</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 选择ADC1通道0（PA0），采样时间55.5周期</span>
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="hljs-number">1</span>, ADC_SampleTime_55Cycles5);
    <span class="hljs-comment">// 启动ADC转换</span>
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    <span class="hljs-comment">// 等待转换完成</span>
    <span class="hljs-keyword">while</span>(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));
    <span class="hljs-comment">// 返回转换结果（12位ADC，范围0~4095）</span>
    <span class="hljs-keyword">return</span> ADC_GetConversionValue(ADC1);
}
</code></pre>
<p>关键：<code>GPIO_Mode_AIN</code> 对应模拟输入，需配合 ADC 初始化，引脚仅作为模拟信号传输通道，不参与数字逻辑。</p>
<h2 data-id="heading-7">三、输出模式详解（4 种）：发送外部信号的“核心方式”</h2>
<p>输出模式的核心是“主动输出电平”，GPIO 引脚由单片机软件（或内部外设）控制，向外部电路输出高电平（VCC）或低电平（GND），核心差异在于输出驱动方式（开漏/推挽）和是否复用为外设功能。</p>
<h3 data-id="heading-8">1. 开漏输出（Open-Drain Output）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部仅包含 N 沟道 MOS 管，无内部上拉电阻，输出低电平时，MOS 管导通，引脚接地；输出高电平时，MOS 管截止，引脚处于高阻抗状态（浮空），无法主动输出高电平，需外部接一个上拉电阻才能输出高电平。</p>
<p>​<strong>工作原理</strong>​：相当于一个“可控开关”，仅能控制引脚“接地”（低电平），无法控制引脚“接 VCC”（高电平）。外部上拉电阻的作用是，当 MOS 管截止时，将引脚拉至高电平，实现高电平输出。</p>
<p>​**核心特性：线与（Wire-AND）**​：多个开漏输出引脚可连接在同一条总线上，共享一个外部上拉电阻。只要有一个引脚输出低电平，整个总线就为低电平；只有所有引脚都输出高电平（浮空），总线才为高电平。这是开漏输出最关键的优势。</p>
<p>​<strong>实战场景</strong>​：总线通信（如 I2C 总线的 SDA、SCL 引脚）、多个设备的电平联动（如多个 LED 共阳极驱动）、需要实现线与功能的场景；也可用于驱动大电流设备（外部上拉电阻 + 三极管/继电器）。</p>
<p>​<strong>注意事项</strong>​：必须外接上拉电阻才能输出高电平，上拉电阻的阻值决定输出电流大小和响应速度；输出高电平时，引脚电平由外部上拉电阻决定，并非单片机内部 VCC。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，外接上拉电阻驱动 LED）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 开漏输出模式配置（PA0，外接上拉电阻）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_OpenDrainOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为开漏输出模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;   <span class="hljs-comment">// 开漏输出模式（Out_OD = Output Open Drain）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz（根据需求调整）</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（PA0外接10KΩ上拉电阻到VCC）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 初始状态：输出高电平（MOS管截止，由外部上拉电阻拉高）</span>
    GPIO_SetBits(GPIOA, GPIO_Pin_0);
}

<span class="hljs-comment">// 开漏输出电平控制（示例：驱动LED亮灭）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">LED_Control_OpenDrain</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> state)</span>
{
    <span class="hljs-keyword">if</span>(state == <span class="hljs-number">1</span>)
    {
        GPIO_SetBits(GPIOA, GPIO_Pin_0);  <span class="hljs-comment">// 输出高电平（MOS管截止，外部上拉）</span>
    }
    <span class="hljs-keyword">else</span>
    {
        GPIO_ResetBits(GPIOA, GPIO_Pin_0); <span class="hljs-comment">// 输出低电平（MOS管导通，接地）</span>
    }
}
</code></pre>
<p>关键：<code>GPIO_Mode_Out_OD</code> 对应开漏输出，代码中 <code>GPIO_SetBits</code> 仅能让引脚截止（浮空），需外接上拉电阻才能实现高电平输出。</p>
<h3 data-id="heading-9">2. 推挽输出（Push-Pull Output）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部包含 N 沟道和 P 沟道两个 MOS 管，两个 MOS 管互补工作，可主动输出高电平和低电平，无需外部上拉/下拉电阻。</p>
<p>​<strong>工作原理</strong>​：输出高电平时，P 沟道 MOS 管导通、N 沟道 MOS 管截止，引脚接 VCC，输出高电平；输出低电平时，N 沟道 MOS 管导通、P 沟道 MOS 管截止，引脚接地，输出低电平。两个 MOS 管交替工作，实现“推”（输出高电平）和“挽”（输出低电平）的驱动效果。</p>
<p>​<strong>核心优势</strong>​：输出驱动能力强（相比开漏输出），无需外部电阻，可直接驱动中小电流设备；输出电平稳定，高电平为 VCC，低电平为 GND，无浮空状态。</p>
<p>​<strong>实战场景</strong>​：最常用的输出模式，适合直接驱动中小电流设备，比如 LED 指示灯、小型继电器（直接驱动或通过三极管放大）、串口 TX 引脚（输出 TTL 电平）、GPIO 口直接控制的开关电路等。</p>
<p>​<strong>注意事项</strong>​：不能将多个推挽输出引脚直接连接在一起（若一个输出高、一个输出低，会导致两个 MOS 管同时导通，产生大电流，烧毁引脚）；驱动大电流设备时，需外接放大电路（三极管、MOS 管）。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，直接驱动 LED）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 推挽输出模式配置（PA0，直接驱动LED）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PushPullOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为推挽输出模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   <span class="hljs-comment">// 推挽输出模式（Out_PP = Output Push Pull）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（无需外接电阻，直接驱动小电流LED）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 初始状态：输出低电平（LED熄灭）</span>
    GPIO_ResetBits(GPIOA, GPIO_Pin_0);
}

<span class="hljs-comment">// 推挽输出电平控制（示例：LED闪烁）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">LED_Blink_PushPull</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_SetBits(GPIOA, GPIO_Pin_0);    <span class="hljs-comment">// 输出高电平，LED点亮</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint32_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">500</span>; i++);   <span class="hljs-comment">// 延时</span>
    GPIO_ResetBits(GPIOA, GPIO_Pin_0);  <span class="hljs-comment">// 输出低电平，LED熄灭</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint32_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">500</span>; i++);   <span class="hljs-comment">// 延时</span>
}
</code></pre>
<p>关键：<code>GPIO_Mode_Out_PP</code> 对应推挽输出，<code>GPIO_SetBits</code> 主动输出高电平、<code>GPIO_ResetBits</code> 主动输出低电平，无需外接电阻，直接驱动中小电流设备。</p>
<h3 data-id="heading-10">3. 复用开漏输出（Alternate Function Open-Drain Output）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚的输出控制权不再由单片机软件（GPIO 寄存器）控制，而是交由内部外设（如 UART、SPI、I2C、定时器）控制，输出驱动方式为开漏输出，需外部上拉电阻才能输出高电平。</p>
<p>​<strong>工作原理</strong>​：引脚功能被“复用”为外设功能，电平输出由外设决定（而非软件写 GPIO 输出寄存器），驱动逻辑与普通开漏输出一致——仅能主动输出低电平，高电平需外部上拉电阻实现。</p>
<p>​<strong>实战场景</strong>​：外设需要开漏输出特性的场景，比如 I2C 总线的 SDA、SCL 引脚（复用为 I2C 外设的开漏输出）、SPI 总线的 MISO 引脚（部分场景复用为开漏输出）、UART 的 CTS/RTS 引脚（开漏模式）。</p>
<p>​<strong>与普通开漏输出的区别</strong>​：控制主体不同——普通开漏输出由软件控制 GPIO 寄存器，复用开漏输出由内部外设控制；功能用途不同——复用输出用于实现外设的特定功能，普通输出用于软件直接控制电平。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA9 引脚为例，复用为 UART1_TX，开漏输出）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_usart.h"</span></span>

<span class="hljs-comment">// 复用开漏输出模式配置（PA9，复用为UART1_TX）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_AF_OpenDrainOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA和UART1时钟（复用外设需同时使能GPIO和外设时钟）</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA9为复用开漏输出模式（UART1_TX复用功能）</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;          <span class="hljs-comment">// 选择PA9引脚（UART1_TX对应引脚）</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;    <span class="hljs-comment">// 复用开漏输出（AF_OD = Alternate Function Open Drain）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（PA9外接上拉电阻，确保高电平输出）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 4. 初始化UART1（复用功能核心：配置外设，控制GPIO输出）</span>
    USART_InitStructure.USART_BaudRate = <span class="hljs-number">9600</span>;         <span class="hljs-comment">// 波特率9600</span>
    USART_InitStructure.USART_WordLength = USART_WordLength_8b; <span class="hljs-comment">// 8位数据位</span>
    USART_InitStructure.USART_StopBits = USART_StopBits_1;     <span class="hljs-comment">// 1位停止位</span>
    USART_InitStructure.USART_Parity = USART_Parity_No;        <span class="hljs-comment">// 无校验位</span>
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="hljs-comment">// 无硬件流控</span>
    USART_InitStructure.USART_Mode = USART_Mode_Tx;            <span class="hljs-comment">// 仅发送模式</span>
    USART_Init(USART1, &amp;USART_InitStructure);
    
    <span class="hljs-comment">// 5. 使能UART1</span>
    USART_Cmd(USART1, ENABLE);
}

<span class="hljs-comment">// 复用开漏输出发送数据（示例：UART发送字符）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">USART_SendChar_AF_OD</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ch)</span>
{
    <span class="hljs-comment">// 等待发送缓冲区为空</span>
    <span class="hljs-keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
    <span class="hljs-comment">// 发送一个字符（由UART外设控制PA9输出电平）</span>
    USART_SendData(USART1, ch);
}
</code></pre>
<p>关键：<code>GPIO_Mode_AF_OD</code> 对应复用开漏输出，需同时初始化 GPIO 和对应外设（如 UART），GPIO 电平由外设控制，非软件直接操作。</p>
<h3 data-id="heading-11">4. 复用推挽输出（Alternate Function Push-Pull Output）</h3>
<p>​<strong>核心定义</strong>​：与复用开漏输出类似，GPIO 引脚的输出控制权交由内部外设控制，输出驱动方式为推挽输出，无需外部电阻，可主动输出高电平和低电平。</p>
<p>​<strong>工作原理</strong>​：引脚复用为外设功能后，电平输出由外设（如 UART、SPI、定时器）决定，驱动逻辑与普通推挽输出一致——通过两个互补 MOS 管，主动输出高电平和低电平，驱动能力强。</p>
<p>​<strong>实战场景</strong>​：外设需要推挽输出特性的场景，比如 UART 的 TX 引脚（复用为串口外设，推挽输出 TTL 电平）、SPI 的 MOSI、SCK 引脚（复用为 SPI 外设，推挽输出）、定时器的 PWM 输出引脚（复用为定时器外设，推挽输出 PWM 波形）。</p>
<p>​<strong>关键注意</strong>​：复用输出模式下，软件不能再通过 GPIO 寄存器控制引脚电平，否则会与外设控制冲突，导致功能异常；需先配置 GPIO 为对应复用功能，再初始化外设。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA9 引脚为例，复用为 UART1_TX，推挽输出）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_usart.h"</span></span>

<span class="hljs-comment">// 复用推挽输出模式配置（PA9，复用为UART1_TX）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_AF_PushPullOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA和UART1时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA9为复用推挽输出模式（UART1_TX复用功能）</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;          <span class="hljs-comment">// 选择PA9引脚（UART1_TX对应引脚）</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    <span class="hljs-comment">// 复用推挽输出（AF_PP = Alternate Function Push Pull）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（无需外接电阻，推挽输出可主动输出高低电平）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 4. 初始化UART1（外设控制GPIO输出）</span>
    USART_InitStructure.USART_BaudRate = <span class="hljs-number">9600</span>;         <span class="hljs-comment">// 波特率9600</span>
    USART_InitStructure.USART_WordLength = USART_WordLength_8b; <span class="hljs-comment">// 8位数据位</span>
    USART_InitStructure.USART_StopBits = USART_StopBits_1;     <span class="hljs-comment">// 1位停止位</span>
    USART_InitStructure.USART_Parity = USART_Parity_No;        <span class="hljs-comment">// 无校验位</span>
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="hljs-comment">// 无硬件流控</span>
    USART_InitStructure.USART_Mode = USART_Mode_Tx;            <span class="hljs-comment">// 仅发送模式</span>
    USART_Init(USART1, &amp;USART_InitStructure);
    
    <span class="hljs-comment">// 5. 使能UART1</span>
    USART_Cmd(USART1, ENABLE);
}

<span class="hljs-comment">// 复用推挽输出发送数据（示例：UART发送字符串）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">USART_SendString_AF_PP</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *str)</span>
{
    <span class="hljs-keyword">while</span>(*str != <span class="hljs-string">'\0'</span>)
    {
        <span class="hljs-comment">// 等待发送缓冲区为空</span>
        <span class="hljs-keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
        <span class="hljs-comment">// 发送一个字符（由UART外设控制PA9输出）</span>
        USART_SendData(USART1, *str);
        str++;
    }
}
</code></pre>
<p>关键：<code>GPIO_Mode_AF_PP</code> 对应复用推挽输出，是最常用的复用模式，无需外接电阻，外设可直接控制 GPIO 主动输出高低电平，适配 UART、SPI 等多数外设。</p>
<h2 data-id="heading-12">四、核心对比与实战选型指南（必看）</h2>
<p>为了方便大家快速选型，避免踩坑，这里整理了八种模式的核心对比和选型技巧，结合实际开发场景总结，直接套用即可。</p>



























































<table><thead><tr><th>模式类型</th><th>核心特点</th><th>典型应用</th><th>关键注意</th></tr></thead><tbody><tr><td>浮空输入</td><td>高阻抗，无固定电平，由外部决定</td><td>外部有固定电平的信号检测（如串口 RX）</td><td>避免单独用于无外部电平的场景</td></tr><tr><td>上拉输入</td><td>内部上拉，默认高电平，外部可拉低</td><td>按键检测、NPN 型传感器</td><td>无需外部上拉电阻</td></tr><tr><td>下拉输入</td><td>内部下拉，默认低电平，外部可拉高</td><td>PNP 型传感器、高电平触发信号</td><td>与上拉输入根据电平极性选择</td></tr><tr><td>模拟输入</td><td>断开数字缓冲，接入 ADC，采集模拟量</td><td>电位器、温度/湿度/光照传感器</td><td>仅支持 ADC 引脚，避免接强电</td></tr><tr><td>开漏输出</td><td>仅能主动输出低电平，需外部上拉</td><td>I2C 总线、线与功能、共阳极 LED</td><td>必须外接上拉电阻</td></tr><tr><td>推挽输出</td><td>主动输出高低电平，驱动能力强</td><td>LED、串口 TX、小型继电器</td><td>不可多引脚直接连接</td></tr><tr><td>复用开漏输出</td><td>外设控制，开漏驱动，需外部上拉</td><td>I2C_SDA/SCL、SPI_MISO</td><td>软件不可控制 GPIO 电平</td></tr><tr><td>复用推挽输出</td><td>外设控制，推挽驱动，无需外部电阻</td><td>UART_TX、SPI_MOSI、PWM 输出</td><td>先配置复用功能，再初始化外设</td></tr></tbody></table>
<h3 data-id="heading-13">选型核心技巧</h3>
<ul>
<li>输入场景：无外部电平 → 上拉/下拉输入；有外部电平 → 浮空输入；需采集模拟量 → 模拟输入。</li>
<li>输出场景：直接驱动中小电流 → 推挽输出；需线与/总线通信 → 开漏输出；外设功能 → 复用推挽/开漏输出（匹配外设需求）。</li>
<li>复用输出：先确定外设的输出驱动方式（如 I2C 用开漏，UART 用推挽），再配置 GPIO 为对应复用模式。</li>
</ul>
<h2 data-id="heading-14">五、总结</h2>
<p>GPIO 的八种工作模式，本质是“输入/输出”和“驱动方式/控制主体”的组合。输入模式的核心是“如何稳定接收外部信号”，输出模式的核心是“如何高效、稳定地向外部发送信号”，复用模式则是“将 GPIO 交给外设，实现更复杂的功能”。</p>
<p>对于嵌入式开发者而言，吃透这八种模式，不仅能简化电路设计、避免开发踩坑，更能根据实际项目需求，选择最适合的 GPIO 模式，提升设备的稳定性和可靠性。比如，同样是按键检测，上拉输入比浮空输入更稳定；同样是总线通信，开漏输出比推挽输出更合适。</p>
<p>建议大家在实际开发中，结合单片机 datasheet，对照每种模式的配置方法，亲手调试（比如用推挽输出驱动 LED，用上拉输入检测按键，用开漏输出模拟 I2C 通信），只有实践才能真正掌握其中的精髓。</p>
<p>后续我会结合具体单片机（如 STM32、51 单片机），分享八种模式的具体配置代码和实战案例，感兴趣的可以关注后续更新~</p>
<p>可关注我的博客：<a href="https://link.juejin.cn?target=https%3A%2F%2F" target="_blank" title="https://" ref="nofollow noopener noreferrer">blog.csdn.net/qq_30095907…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Redis 做分布式 Session]]></title>    <link>https://juejin.cn/post/7604037348608360486</link>    <guid>https://juejin.cn/post/7604037348608360486</guid>    <pubDate>2026-02-09T01:15:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604037348608360486" data-draft-id="7602464510607212570" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Redis 做分布式 Session"/> <meta itemprop="keywords" content="后端,Spring Cloud,微服务"/> <meta itemprop="datePublished" content="2026-02-09T01:15:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MrSYJ"/> <meta itemprop="url" content="https://juejin.cn/user/2752832848799726"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Redis 做分布式 Session
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2752832848799726/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MrSYJ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:15:07.000Z" title="Mon Feb 09 2026 01:15:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>最近在用SAS做授权服务器，默认授权服务器的session是基于tomcat服务器的，但是如果你的 SAS 部署了多台实例（集群），该怎么办呢？比如用户在 A 机器登录，确认授权时请求落到了 B 机器，B 找不到 Session 就会让用户重新登录。没有 Redis，SAS 很难做集群部署，也无法提供稳定的单点登录（SSO）体验。</p>
<h2 data-id="heading-1">需要引入的依赖</h2>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h2 data-id="heading-2">将session保存到redis的原理</h2>
<p>首先我们要明白一点,session的创建是是依赖<code>HttpServletRequest.getSession()</code>,但是直接调用就是创建本地session，所以框架就必须偷梁换柱。Spring Session就是利用了 Filter 模式，通过装饰器模式（Decorator Pattern）包装了原始的 Request 对象。那这个核心过滤器组件就是<code>SessionRepositoryFilter</code>。</p>
<p><code>SessionRepositoryFilter</code> 见名知意负责session持久化的过滤器。</p>
<p>过滤器源码：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec7bf3f6bdc2451d805c88cd732f8526~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=YUVbRZXJei2c790cV2ie5cYD074%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p><code>SessionRepositoryFilter</code> 会率先拦截到这个请求。</p>
</li>
<li>
<p>它并不会直接把原始的 <code>HttpServletRequest</code> 传给后面的 Controller。</p>
</li>
</ul>
<p>它创建了两个包装类：</p>
<ul>
<li><strong><code>SessionRepositoryRequestWrapper</code></strong>: 继承自 <code>HttpServletRequestWrapper</code>。</li>
<li><strong><code>SessionRepositoryResponseWrapper</code></strong>: 继承自 <code>HttpServletResponseWrapper</code>。</li>
</ul>
<p>重点是它重写了包装类中的<strong>getSession()</strong> 方法</p>
<p>当你运行 <code>request.getSession()</code> 时，实际上运行的是包装类里的方法.</p>
<p><strong>不再去 Tomcat 的内存里找</strong>，而是去 <code>SessionRepository</code>（对于你来说就是 <code>RedisIndexedSessionRepository</code>）里找</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8058139018eb4b7dbc604b1ba449762b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=eBwaNcKtpdT4D9VobxRBADGlNE0%3D" alt="image.png" loading="lazy"/></p>
<p>如上图 spring在构建SessionRepositoryFilter过滤器的时候，注入的就是RedisIndexedSessionRepository。专门负责session的增删改查。</p>
<p>SessionRepository是顶级抽象接口，RedisIndexedSessionRepository实现了该接口</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d97f5d7524d44466b440a75a9b0de34c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=cInxyc8leq645XGROBWODZkWpv0%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-3">包装类的getsession方法</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b47fbddec14e95b3797de365963a2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=jBC5ZID744mtKcY6sGRq2OS%2Bkag%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3b05c4304ef4e82838cef37f89c1204~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=kYDOEBfiHUb2QRDZaq9Evw6m7h0%3D" alt="image.png" loading="lazy"/></p>
<p>上面是getsession包装后的源码，我把重要的代码标记出来了，我们一步一步分析。</p>
<h3 data-id="heading-4">首先是getCurrentSession</h3>
<p>它的本次是请求内缓存，<code>SessionRepositoryFilter</code> 包装了 Request。在同一个 HTTP 请求的整个生命周期内（从进入 Filter 到 Controller 再到 Filter 出去），你可能会多次调用 <code>request.getSession()</code>。</p>
<p>为了性能考虑，Spring Session 没必要每次调用 <code>getSession()</code> 都去查一遍 Redis。所以：</p>
<ul>
<li><strong>第一次调用 <code>getSession()</code></strong> ：会去执行 <code>getRequestedSession()</code>（查 Redis/Cookie），查到后把结果存入 Request 的一个内部属性（Attribute）里。</li>
<li><strong>第二次及以后调用</strong>：<code>getCurrentSession()</code> 就能直接从 Request 属性里把刚才那个对象拿出来。</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">HttpSessionWrapper <span class="hljs-attr">currentSession</span> = getCurrentSession()<span class="hljs-comment">;</span>
if (currentSession != null) {
   return currentSession<span class="hljs-comment">;</span>
}
</code></pre>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">HttpSessionWrapper</span> <span class="hljs-title function_">getCurrentSession</span>(<span class="hljs-params"/>) {
   <span class="hljs-keyword">return</span> (<span class="hljs-title class_">HttpSessionWrapper</span>) <span class="hljs-title function_">getAttribute</span>(<span class="hljs-variable constant_">CURRENT_SESSION_ATTR</span>);
}

<span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">getAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">getAttribute</span>(name);
}
</code></pre>
<p>也就是说请求第一次过来，调用request.getSession()，看看当前的 <code>HttpServletRequest</code> 对象里是不是已经有一个 <code>HttpSessionWrapper</code> 了，第一次肯定没有嘛，就会调用getRequestedSession()，真正去拿 <strong>Cookie</strong>（获取 SessionId），然后拿着 ID 去 <strong>Redis</strong> 找。 如果 Redis 找到了，就 new 一个包装类，并调用 <code>setCurrentSession()</code> 把它存到 Request 属性里</p>
<p>它就像是一个**“一级缓存”**：</p>
<ul>
<li><strong>一级缓存</strong>：<code>getCurrentSession()</code> —— 存在当前请求对象里，生命周期仅限本次请求。</li>
<li><strong>二级缓存</strong>：<code>getRequestedSession()</code> —— 存在 Redis 里，生命周期是全局的。</li>
</ul>
<p><strong>这就是为什么你在同一个 Request 里反复调用 <code>getSession()</code>，拿到的永远是同一个内存对象的原因。</strong></p>
<h3 data-id="heading-5">接下来我们看看<strong>getRequestedSession</strong></h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e904ea157a44146b595d0079681b25f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=LlsvQNPpwY6txvRjpjyPcq5eLg8%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc436212eef34528aad016b21f058251~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=hVQHR4CqEV0jkMRbhn%2B%2FFMNR2pk%3D" alt="image.png" loading="lazy"/></p>
<p>使用了<code>requestedSessionCached</code>标记，防止每次调用<code>request.getSession()</code>都会触发Redis 的 <code>HGETALL</code> 查询。也就是说如果当前已经缓存了就直接使用缓存的，如果没有缓存就去redis中看有没有。，避免了多次网络IO.</p>
<h3 data-id="heading-6">setCurrentSession</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90d7c0380991416fb84a2238095b0503~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=brTIFdOtSjpRpJWIQUQF2Fn%2B0FY%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b8e445d94a194d4bb54db28e6ec803fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=8RmvXssFRDxW%2F16s0dyHm99cNjM%3D" alt="image.png" loading="lazy"/></p>
<p>如果从redis中查询到了当前的session，就调用<strong>setCurrentSession</strong>保存到当前请求的作用域内，这样就和第一步闭环了，第一步是先从request作用域去获取。二级缓存防止多次网络IO</p>
<h3 data-id="heading-7">createSession()</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fabd46f8393642e7b949d20f875797a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=PGHAtC4Rng%2BBOTxCbM9oynVD%2FJo%3D" alt="image.png" loading="lazy"/></p>
<p>也就是说如果用户没带cookie或者Cookie 里的 ID 在 Redis 里查不到，就会<code>createSession()</code> 产生一个新的 ID。存在内存中，然后调用<code>setCurrentSession()</code> 把这个新 Session 塞进 Request 的属性，绑定到请求上。供后续使用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解Redis哨兵（Sentinel）原理：高可用架构的核心守护者]]></title>    <link>https://juejin.cn/post/7603781883974664211</link>    <guid>https://juejin.cn/post/7603781883974664211</guid>    <pubDate>2026-02-09T01:16:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883974664211" data-draft-id="7604084016509763625" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解Redis哨兵（Sentinel）原理：高可用架构的核心守护者"/> <meta itemprop="keywords" content="Redis"/> <meta itemprop="datePublished" content="2026-02-09T01:16:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="what丶k"/> <meta itemprop="url" content="https://juejin.cn/user/2578801884147418"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解Redis哨兵（Sentinel）原理：高可用架构的核心守护者
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2578801884147418/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    what丶k
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:16:09.000Z" title="Mon Feb 09 2026 01:16:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​在分布式系统中，Redis 凭借高性能、低延迟的特性成为缓存与数据存储的首选方案，但单点故障始终是制约其生产可用性的关键瓶颈。Redis 主从复制机制虽实现了数据冗余，却无法自动处理主节点故障，需手动介入切换。Redis 哨兵（Sentinel）作为官方原生的高可用解决方案，通过分布式监控、自动故障转移与配置同步，完美解决了这一痛点，成为中小规模 Redis 集群高可用架构的基石。本文将从核心定位、工作机制、故障转移流程、实战配置及生产优化等方面，全方位解析 Redis 哨兵的底层原理与实践要点。</p>
<h2 data-id="heading-0">一、哨兵的核心定位与核心功能</h2>
<p>Redis 哨兵并非独立的数据库组件，而是一套运行在独立进程中的分布式监控与治理系统，其核心使命是为 Redis 主从集群提供自动化的高可用保障。哨兵集群与 Redis 主从节点协同工作，构成完整的高可用架构，主要承担四大核心功能：</p>
<h3 data-id="heading-1">1. 持续监控（Monitoring）</h3>
<p>每个哨兵节点会以每秒一次的频率，向被监控的所有主节点、从节点及其他哨兵节点发送 <code>PING</code> 命令，通过检测是否收到有效 <code>PONG</code> 响应，判断目标节点的健康状态。这种高频心跳检测机制是故障发现的基础，确保能快速感知节点异常。</p>
<h3 data-id="heading-2">2. 故障通知（Notification）</h3>
<p>当哨兵检测到节点故障（尤其是主节点故障）时，会通过 Redis 的发布订阅（Pub/Sub）机制，向其他哨兵节点、客户端及运维系统发送通知。客户端可通过订阅哨兵频道实时获取集群状态变化，运维系统则可基于通知触发告警流程，实现故障的快速响应。</p>
<h3 data-id="heading-3">3. 自动故障转移（Automatic Failover）</h3>
<p>这是哨兵最核心的功能。当主节点被确认故障后，哨兵集群会自动执行故障转移流程：从候选从节点中选举新主节点、将其他从节点重新配置为新主节点的从节点、通知客户端更新主节点地址，全程无需人工干预，最大限度减少服务中断时间。</p>
<h3 data-id="heading-4">4. 配置提供者（Configuration Provider）</h3>
<p>哨兵作为客户端服务发现的权威来源，客户端无需硬编码主节点地址，而是通过连接哨兵集群查询当前可用的主节点地址。当故障转移发生后，哨兵会同步更新主节点信息，客户端重新查询即可获取新地址，实现连接的自动切换。</p>
<h2 data-id="heading-5">二、哨兵的分布式架构设计</h2>
<p>Redis 哨兵本身是分布式系统，而非单点进程，这一设计旨在避免哨兵自身成为新的单点故障。一套完整的哨兵架构包含三部分组件：</p>
<ul>
<li>​**主节点（Master）**​：负责处理所有写操作，同时将数据异步同步至从节点，是集群的核心数据节点。</li>
<li>​**从节点（Slave/Replica）**​：通过主从复制同步主节点数据，仅处理读操作（默认），作为主节点的冗余备份，故障时可被提升为新主节点。</li>
<li>​**哨兵节点（Sentinel）**​：独立运行的监控进程，多个哨兵节点构成集群，通过相互通信达成共识，确保故障判断与故障转移的准确性。</li>
</ul>
<h3 data-id="heading-6">分布式架构的核心优势</h3>
<ol>
<li>降低误判概率：单一哨兵节点对主节点的故障判断可能受网络分区等因素影响（如自身与主节点失联但主节点正常），多个哨兵节点通过共识机制确认故障，可有效避免误触发故障转移。</li>
<li>高可用性：即使部分哨兵节点故障，剩余正常节点仍可继续提供监控与故障转移服务，确保哨兵系统自身的稳定性。</li>
</ol>
<h3 data-id="heading-7">推荐部署方案</h3>
<p>生产环境中，哨兵节点数量建议配置为 3 个（或以上奇数个），且需部署在独立的物理机、虚拟机或不同可用区，确保哨兵节点的故障独立性。若仅部署 2 个哨兵节点，当其中一个故障时，剩余节点无法满足“多数票”条件，将导致故障转移无法执行；奇数个节点可避免投票僵局，简化共识达成流程。</p>
<h2 data-id="heading-8">三、哨兵核心工作机制深度解析</h2>
<p>哨兵的工作流程可拆解为“故障检测”“领导者选举”“故障转移”三大核心阶段，各阶段通过精密的分布式协作机制保障准确性与可靠性。</p>
<h3 data-id="heading-9">1. 故障检测：主观下线与客观下线</h3>
<p>哨兵对主节点的故障判断并非一步到位，而是分为“主观下线（SDOWN）”与“客观下线（ODOWN）”两个阶段，避免单一节点的误判。</p>
<ul>
<li>​**主观下线（SDOWN）**​：单个哨兵节点在配置的 <code>down-after-milliseconds</code> 时间内，持续未收到主节点的有效 <code>PONG</code> 响应，会将该主节点标记为“主观下线”。这是哨兵的局部判断，仅代表当前节点认为主节点故障。</li>
<li>​**客观下线（ODOWN）**​：标记主节点为主观下线后，该哨兵会向其他哨兵节点发送 <code>SENTINEL is-master-down-by-addr</code> 命令，询问其他节点对该主节点的状态判断。当超过 <code>quorum</code>（法定票数）个哨兵节点均报告该主节点主观下线时，主节点将被标记为“客观下线”，此时触发后续的领导者选举与故障转移流程。</li>
</ul>
<p>注：<code>quorum</code> 是配置参数，通过 <code>sentinel monitor</code> 命令指定，代表确认主节点客观下线所需的最小哨兵节点数，建议设置为哨兵节点总数的半数以上（如 3 个哨兵设置为 2）。</p>
<h3 data-id="heading-10">2. 领导者选举：基于 Raft 算法的共识机制</h3>
<p>当主节点被确认客观下线后，哨兵集群需选举出一个“领导者哨兵”，由其单独负责执行故障转移操作（避免多个哨兵同时发起转移导致集群混乱）。选举机制基于 Raft 算法的核心思想，流程如下：</p>
<ol>
<li>候选者发起投票：每个发现主节点客观下线的哨兵节点，会向其他哨兵节点发送投票请求，申请成为领导者。</li>
<li>投票规则：每个哨兵节点仅能投出一票，且优先投票给第一个向自己发起请求的候选者（先到先得原则）。</li>
<li>共识达成：当某个候选者获得超过半数哨兵节点的投票时，立即成为领导者；若一轮投票无候选者获得多数票，则等待超时后重新发起选举，直至选出领导者。</li>
</ol>
<p>Raft 算法的引入确保了哨兵集群在分布式环境下能快速、一致地选举出领导者，且选举过程具备安全性（同一任期内仅产生一个领导者）与活性（最终能选出领导者，无无限阻塞）。</p>
<h3 data-id="heading-11">3. 故障转移：自动化主从切换全流程</h3>
<p>领导者哨兵当选后，将按固定流程执行故障转移，整个过程可分为四步，耗时通常在秒级到十几秒级（取决于配置与集群状态）。</p>
<ol>
<li>​<strong>筛选候选从节点</strong>​：领导者哨兵会从原主节点的所有从节点中，筛选出符合条件的候选节点，筛选规则优先级如下：① 排除已标记为故障、断开连接或响应缓慢的从节点；② 优先选择 <code>slave-priority</code>（从节点优先级）配置值最高的节点（值越小优先级越高）；③ 若优先级相同，选择复制偏移量最大的节点（数据最完整，同步主节点数据最新）；④ 若偏移量相同，选择运行 ID 最小的节点（默认规则）。</li>
<li>​<strong>提升候选节点为新主节点</strong>​：领导者哨兵向筛选出的候选从节点发送 <code>SLAVEOF NO ONE</code> 命令，使其脱离从节点身份，晋升为新主节点，开始独立处理读写请求。</li>
<li>​<strong>重配置其他从节点</strong>​：领导者哨兵向剩余所有从节点发送 <code>SLAVEOF &lt;新主节点IP&gt; &lt;新主节点端口&gt;</code> 命令，让这些从节点重新同步新主节点的数据，构建新的主从复制关系。</li>
<li>​<strong>更新配置与通知</strong>​：领导者哨兵更新自身及其他哨兵节点的集群配置，将原主节点标记为新主节点的从节点（待其恢复后，自动以从节点身份同步新主节点数据）；同时通过发布订阅机制通知客户端新主节点地址，客户端更新连接信息后，即可正常访问集群。</li>
</ol>
<h2 data-id="heading-12">四、关键配置与实战要点</h2>
<p>哨兵的稳定性依赖合理的配置，核心配置项集中在 <code>sentinel.conf</code> 文件中，以下为生产环境常用配置及解读，结合 1 主 2 从 3 哨兵架构示例。</p>
<h3 data-id="heading-13">1. 核心配置项解读</h3>
<pre><code class="hljs language-hljs" lang="hljs"># 监控主节点：名称mymaster，IP192.168.1.101，端口6379，quorum=2（需2个哨兵确认下线）
sentinel monitor mymaster 192.168.1.101 6379 2

# 主观下线判定时间：5000毫秒（5秒），超时未响应则标记为主观下线
sentinel down-after-milliseconds mymaster 5000

# 故障转移超时时间：180000毫秒（3分钟），超时未完成则终止转移
sentinel failover-timeout mymaster 180000

# 故障转移时并行同步从节点数量：1（避免多从节点同时同步新主节点导致带宽拥堵）
sentinel parallel-syncs mymaster 1

# 预防脑裂配置：主节点至少需1个从节点连接，且从节点延迟≤10秒才允许写操作
min-slaves-to-write 1
min-slaves-max-lag 10
</code></pre>
<p><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/></p>
<h3 data-id="heading-14">2. 哨兵启动方式</h3>
<p>哨兵启动需指定配置文件（否则无法保存集群状态，重启后丢失信息），两种启动方式效果一致：</p>
<pre><code class="hljs language-hljs" lang="hljs"># 方式1：通过redis-sentinel可执行文件启动
redis-sentinel /path/to/sentinel.conf

# 方式2：通过redis-server以哨兵模式启动
redis-server /path/to/sentinel.conf --sentinel
</code></pre>
<p><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/></p>
<p>哨兵默认监听 26379 端口，需确保该端口在防火墙中开放，允许其他哨兵节点与客户端访问。</p>
<h3 data-id="heading-15">3. 客户端接入方式</h3>
<p>客户端需支持哨兵协议（主流客户端如 Jedis、Lettuce 均支持），通过连接哨兵集群获取主节点地址，而非直接连接主节点。以 Jedis 为例：</p>
<pre><code class="hljs language-hljs" lang="hljs">Set&lt;String&gt; sentinelSet = new HashSet&lt;&gt;();
sentinelSet.add("192.168.1.201:26379"); // 哨兵节点1
sentinelSet.add("192.168.1.202:26379"); // 哨兵节点2
sentinelSet.add("192.168.1.203:26379"); // 哨兵节点3

// 连接哨兵集群，指定主节点名称mymaster
JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinelSet);
Jedis jedis = pool.getResource(); // 自动获取当前可用主节点连接
</code></pre>
<p><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/></p>
<p>客户端会定期向哨兵集群查询主节点地址，故障转移后自动切换至新主节点，实现业务无感知。</p>
<h2 data-id="heading-16">五、生产环境常见问题与优化方案</h2>
<p>哨兵架构虽能保障高可用，但在生产环境中仍需规避常见陷阱，通过优化配置提升稳定性与性能。</p>
<h3 data-id="heading-17">1. 脑裂问题（Split-Brain）</h3>
<p>问题场景：网络分区导致原主节点与哨兵、从节点失联，但原主节点仍正常运行。哨兵集群触发故障转移，提升新主节点；当网络恢复后，集群中出现两个主节点（原主、新主），即“脑裂”，导致数据不一致。</p>
<p>解决方案：通过配置 <code>min-slaves-to-write</code> 与 <code>min-slaves-max-lag</code> 限制原主节点的写权限。当原主节点连接的从节点数量不足或延迟过高时，自动拒绝写操作，避免脑裂期间的数据写入冲突。</p>
<h3 data-id="heading-18">2. 故障转移期间数据丢失</h3>
<p>问题原因：Redis 主从复制为异步机制，主节点故障时，部分已写入主节点的数据可能未同步至从节点，故障转移后这部分数据将丢失。</p>
<p>优化方案：① 开启主节点持久化（<code>appendonly yes</code>），避免主节点重启后数据丢失；② 合理设置 <code>min-slaves-max-lag</code>，减少主从数据延迟；③ 对核心业务数据，可通过客户端确认机制（如 <code>WAIT</code> 命令）确保数据同步至指定数量从节点后再返回成功。</p>
<h3 data-id="heading-19">3. 故障转移时间过长</h3>
<p>问题表现：默认配置下，故障转移总耗时可能达 30 秒以上，导致服务短暂不可用。</p>
<p>优化方案：调小 <code>down-after-milliseconds</code>（如 5000 毫秒），缩短主观下线判定时间；调小 <code>failover-timeout</code>，加快故障转移超时重试速度。但需注意，<code>down-after-milliseconds</code> 不宜过小，避免网络抖动触发误判。</p>
<h3 data-id="heading-20">4. 哨兵节点单点故障风险</h3>
<p>问题场景：哨兵节点部署在同一物理机或可用区，当该区域故障时，所有哨兵节点失效，无法执行故障检测与转移。</p>
<p>解决方案：哨兵节点分散部署在不同物理机、虚拟机或可用区，确保故障独立性；同时监控哨兵节点状态，及时替换故障节点。</p>
<h2 data-id="heading-21">六、哨兵与 Redis Cluster 的区别与选型建议</h2>
<p>Redis Cluster 是 Redis 官方提供的分片集群方案，与哨兵架构均能实现高可用，但适用场景存在差异，需根据业务需求选型。</p>






























<table><thead><tr><th>对比维度</th><th>Redis Sentinel</th><th>Redis Cluster</th></tr></thead><tbody><tr><td>架构核心</td><td>基于主从复制，无数据分片</td><td>数据分片 + 主从复制，分布式存储</td></tr><tr><td>扩展性</td><td>不支持数据分片，仅可扩展从节点提升读性能</td><td>支持横向扩展节点，突破单节点内存限制</td></tr><tr><td>适用场景</td><td>中小规模集群，数据量不大，需高可用与读写分离</td><td>大规模集群，数据量庞大，需分片存储与水平扩展</td></tr><tr><td>复杂度</td><td>架构简单，配置与维护成本低</td><td>架构复杂，需处理分片路由、数据迁移等问题</td></tr></tbody></table>
<p>选型建议：若业务数据量较小（单节点可承载），追求高可用与简单维护，优先选择哨兵架构；若数据量庞大，需突破单节点性能与内存限制，选择 Redis Cluster。</p>
<h2 data-id="heading-22">七、总结</h2>
<p>Redis 哨兵通过“分布式监控 + 共识机制 + 自动故障转移”，为 Redis 主从集群构建了可靠的高可用保障，其核心价值在于将故障处理从人工介入转化为自动化流程，大幅提升系统的稳定性与运维效率。深入理解哨兵的主观/客观下线机制、Raft 领导者选举、故障转移流程，是做好生产环境部署与优化的关键。</p>
<p>需注意，哨兵并非“银弹”，生产环境中需结合业务场景合理配置参数、规避脑裂与数据丢失风险、做好节点分散部署，同时配合持久化、监控告警等机制，才能构建真正稳定的高可用 Redis 集群。对于中小规模业务而言，哨兵架构兼具简单性与可靠性，是平衡成本与可用性的最优选择。</p>
<p>关注我的CSDN：<a href="https://link.juejin.cn?target=https%3A%2F%2F" target="_blank" title="https://" ref="nofollow noopener noreferrer">blog.csdn.net/qq_30095907…</a></p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[嵌入式处理器架构]]></title>    <link>https://juejin.cn/post/7603959423128584192</link>    <guid>https://juejin.cn/post/7603959423128584192</guid>    <pubDate>2026-02-09T02:14:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603959423128584192" data-draft-id="7603677143215931407" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="嵌入式处理器架构"/> <meta itemprop="keywords" content="后端,嵌入式,单片机"/> <meta itemprop="datePublished" content="2026-02-09T02:14:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员良许"/> <meta itemprop="url" content="https://juejin.cn/user/3913917128246942"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            嵌入式处理器架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3913917128246942/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员良许
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:14:38.000Z" title="Mon Feb 09 2026 02:14:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是良许。</p>
<p>在嵌入式开发的这些年里，我接触过各种各样的处理器架构，从最早做单片机时用的 51 内核，到后来做汽车电子时用的 ARM Cortex-A 系列，再到现在项目中偶尔会碰到的 RISC-V 架构。</p>
<p>每次换一个新架构，都需要重新熟悉它的特性和开发方式。</p>
<p>今天就和大家聊聊嵌入式处理器架构这个话题，帮助大家建立一个系统的认知框架。</p>
<h2 data-id="heading-0">1. 什么是处理器架构</h2>
<p>处理器架构，简单来说就是处理器的设计蓝图和规范。</p>
<p>它定义了处理器如何执行指令、如何管理内存、如何与外设交互等一系列核心问题。</p>
<p>就像盖房子需要先有建筑设计图纸一样，处理器的制造也需要先有架构设计。</p>
<p>从技术角度来看，处理器架构主要包含以下几个方面：</p>
<p><strong>1.1 指令集架构（ISA）</strong></p>
<p>指令集架构是处理器架构的核心，它定义了处理器能够识别和执行的所有指令。</p>
<p>比如 ARM 架构有自己的指令集，x86 架构也有自己的指令集，它们是完全不同的。</p>
<p>这就像不同的语言一样，说中文的人听不懂英文，反之亦然。</p>
<p>在我刚开始做嵌入式开发的时候，用的是 51 单片机，它的指令集非常简单，只有几十条指令。</p>
<p>后来转到 ARM 平台，发现 ARM 的指令集要复杂得多，但也更加强大和灵活。</p>
<p><strong>1.2 寄存器组织</strong></p>
<p>寄存器是处理器内部用于临时存储数据的高速存储单元。</p>
<p>不同的架构有不同数量和类型的寄存器。</p>
<p>比如 ARM Cortex-M 系列有 16 个通用寄存器，而 x86 架构的寄存器组织方式就完全不同。</p>
<p><strong>1.3 内存管理</strong></p>
<p>处理器如何访问和管理内存也是架构的重要组成部分。</p>
<p>有些架构支持虚拟内存管理单元（MMU），有些只支持内存保护单元（MPU），还有些什么都不支持。</p>
<p>这直接影响到系统能否运行复杂的操作系统。</p>
<p><strong>1.4 流水线和执行单元</strong></p>
<p>现代处理器通常采用流水线技术来提高执行效率。</p>
<p>不同架构的流水线级数、执行单元数量和组织方式都不相同，这直接影响到处理器的性能表现。</p>
<h2 data-id="heading-1">2. 主流嵌入式处理器架构</h2>
<h3 data-id="heading-2">2.1 ARM 架构</h3>
<p>ARM 架构可以说是嵌入式领域的绝对霸主，市场占有率超过 90%。</p>
<p>我在外企做汽车电子的时候，用的就是 ARM Cortex-A 系列处理器。</p>
<p>ARM 架构的成功主要得益于其低功耗、高性能和良好的生态系统。</p>
<p>ARM 架构主要分为以下几个系列：</p>
<p><strong>2.1.1 ARM Cortex-M 系列</strong></p>
<p>这是专门为微控制器（MCU）设计的系列，主打低功耗和实时性。</p>
<p>我们常用的 STM32 就是基于 Cortex-M 内核的。</p>
<p>比如 STM32F103 使用的是 Cortex-M3 内核，STM32F407 使用的是 Cortex-M4 内核（带 DSP 指令和浮点运算单元）。</p>
<p>下面是一个简单的 STM32 HAL 库示例，展示如何初始化 GPIO：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment">#include "stm32f4xx_hal.h"</span>
​
void GPIO_Init_Example(void)
{
    GPIO_InitTypeDef <span class="hljs-attr">GPIO_InitStruct</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    /* 使能GPIOA时钟 */
    __HAL_RCC_GPIOA_CLK_ENABLE()<span class="hljs-comment">;</span>
    
    /* 配置PA5引脚为输出模式 */
    <span class="hljs-attr">GPIO_InitStruct.Pin</span> = GPIO_PIN_5<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Mode</span> = GPIO_MODE_OUTPUT_PP<span class="hljs-comment">;  // 推挽输出</span>
    <span class="hljs-attr">GPIO_InitStruct.Pull</span> = GPIO_NOPULL<span class="hljs-comment">;          // 无上下拉</span>
    <span class="hljs-attr">GPIO_InitStruct.Speed</span> = GPIO_SPEED_FREQ_LOW<span class="hljs-comment">; // 低速</span>
    
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct)<span class="hljs-comment">;</span>
    
    /* 点亮LED */
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET)<span class="hljs-comment">;</span>
}
</code></pre>
<p><strong>2.1.2 ARM Cortex-A 系列</strong></p>
<p>这是为应用处理器设计的系列，性能强大，支持运行 Linux 等复杂操作系统。</p>
<p>我在外企做的汽车娱乐系统就是基于 Cortex-A9 的处理器，运行的是定制版的 Linux 系统。</p>
<p>这类处理器通常主频在几百 MHz 到几 GHz 之间，支持 MMU、多核心等高级特性。</p>
<p><strong>2.1.3 ARM Cortex-R 系列</strong></p>
<p>这是为实时系统设计的系列，介于 M 系列和 A 系列之间。</p>
<p>主要用于对实时性要求极高的场合，比如汽车的安全系统、工业控制等。</p>
<h3 data-id="heading-3">2.2 x86/x64 架构</h3>
<p>x86 架构主要由 Intel 和 AMD 主导，在 PC 和服务器领域占据统治地位。</p>
<p>虽然在传统嵌入式领域应用不多，但在工业 PC、边缘计算等场景中也有一定的应用。</p>
<p>x86 架构的特点是性能强大、生态成熟，但功耗相对较高。</p>
<p>Intel 推出的 Atom 系列处理器就是专门针对嵌入式和移动设备的低功耗版本。</p>
<p>我见过一些工业控制系统使用 x86 架构的嵌入式主板，主要是因为需要运行一些只有 x86 版本的专业软件。</p>
<h3 data-id="heading-4">2.3 RISC-V 架构</h3>
<p>RISC-V 是近年来异军突起的开源指令集架构，由加州大学伯克利分校开发。</p>
<p>它最大的特点就是完全开源，任何人都可以免费使用，不需要支付授权费用。</p>
<p>RISC-V 采用模块化设计，基础指令集非常精简，只有 40 多条指令，然后可以根据需要添加各种扩展模块。</p>
<p>这种设计理念非常适合定制化需求强烈的嵌入式应用。</p>
<p>虽然 RISC-V 目前的生态还不如 ARM 成熟，但发展势头非常迅猛。</p>
<p>国内很多芯片厂商都在积极布局 RISC-V，比如平头哥、芯来科技等。</p>
<p>我最近也在关注 RISC-V 的发展，考虑在一些新项目中尝试使用。</p>
<h3 data-id="heading-5">2.4 MIPS 架构</h3>
<p>MIPS 架构曾经在嵌入式领域占有一席之地，特别是在网络设备和消费电子产品中。</p>
<p>但近年来市场份额逐渐被 ARM 蚕食。</p>
<p>MIPS 的特点是指令集简洁、流水线效率高，但生态系统相对薄弱。</p>
<h3 data-id="heading-6">2.5 其他架构</h3>
<p>除了上述主流架构，还有一些专用或小众架构，比如：</p>
<ul>
<li><strong>PowerPC 架构</strong>：主要用于航空航天、工业控制等高可靠性领域</li>
<li><strong>AVR 架构</strong>：Arduino 使用的就是 AVR 内核的单片机</li>
<li><strong>8051 架构</strong>：虽然古老，但在一些简单应用中仍然活跃</li>
<li><strong>DSP 架构</strong>：专门用于数字信号处理的架构，如 TI 的 C2000 系列</li>
</ul>
<h2 data-id="heading-7">3. 处理器架构的关键特性</h2>
<h3 data-id="heading-8">3.1 RISC vs CISC</h3>
<p>处理器架构从指令集设计理念上可以分为 RISC（精简指令集）和 CISC（复杂指令集）两大类。</p>
<p><strong>RISC 架构</strong>的特点是指令数量少、指令格式统一、每条指令执行时间固定。</p>
<p>ARM、RISC-V、MIPS 都属于 RISC 架构。</p>
<p>RISC 架构的优势是设计简单、功耗低、容易实现流水线，非常适合嵌入式应用。</p>
<p><strong>CISC 架构</strong>的特点是指令数量多、指令功能复杂、指令长度可变。</p>
<p>x86 就是典型的 CISC 架构。</p>
<p>CISC 架构的优势是代码密度高、功能强大，但设计复杂、功耗较高。</p>
<p>在实际开发中，我发现 RISC 架构的处理器通常更容易上手，汇编代码也更容易理解。</p>
<p>比如 ARM 的汇编代码就比 x86 的汇编代码简洁很多。</p>
<h3 data-id="heading-9">3.2 位宽</h3>
<p>处理器的位宽指的是处理器一次能处理的数据位数。</p>
<p>常见的有 8 位、16 位、32 位和 64 位。</p>
<ul>
<li><strong>8 位处理器</strong>：如 8051、AVR，适合简单控制应用</li>
<li><strong>16 位处理器</strong>：如 MSP430，性能和功耗的平衡点</li>
<li><strong>32 位处理器</strong>：如 ARM Cortex-M、STM32，目前嵌入式主流</li>
<li><strong>64 位处理器</strong>：如 ARM Cortex-A53/A72，用于高性能应用</li>
</ul>
<p>位宽越大，处理器能够直接处理的数据范围就越大，寻址空间也越大。</p>
<p>但位宽增加也会带来功耗和成本的增加。</p>
<p>在实际项目中，需要根据应用需求选择合适的位宽。</p>
<p>我在做单片机项目的时候，发现 32 位处理器已经成为主流选择。</p>
<p>即使是一些简单的应用，也倾向于使用 32 位 MCU，因为价格已经降到了可以接受的范围，而且开发效率更高。</p>
<h3 data-id="heading-10">3.3 主频和性能</h3>
<p>处理器的主频（时钟频率）是衡量性能的重要指标之一，但不是唯一指标。</p>
<p>同样主频的不同架构处理器，性能可能相差很大。</p>
<p>在嵌入式系统中，我们通常使用 DMIPS（Dhrystone MIPS）或 CoreMark 来衡量处理器的实际性能。</p>
<p>比如 ARM Cortex-M4 在 100MHz 主频下，性能大约是 125 DMIPS。</p>
<p>下面是一个简单的性能测试代码示例：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment">#include "stm32f4xx_hal.h"</span>
<span class="hljs-comment">#include &lt;stdio.h&gt;</span>
​
<span class="hljs-comment">#define TEST_ITERATIONS 1000000</span>
​
void Performance_Test(void)
{
    uint32_t start_tick, end_tick<span class="hljs-comment">;</span>
    volatile uint32_t <span class="hljs-attr">result</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    
    /* 记录开始时间 */
    <span class="hljs-attr">start_tick</span> = HAL_GetTick()<span class="hljs-comment">;</span>
    
    /* 执行测试循环 */
    for(uint32_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; TEST_ITERATIONS; i++)</span>
    {
        result += i * 2<span class="hljs-comment">;</span>
        result <span class="hljs-attr">-</span>= i / <span class="hljs-number">2</span><span class="hljs-comment">;</span>
    }
    
    /* 记录结束时间 */
    <span class="hljs-attr">end_tick</span> = HAL_GetTick()<span class="hljs-comment">;</span>
    
    /* 计算执行时间 */
    uint32_t <span class="hljs-attr">elapsed_time</span> = end_tick - start_tick<span class="hljs-comment">;</span>
    
    printf("Test completed in %lu ms\n", elapsed_time)<span class="hljs-comment">;</span>
    printf("Result: %lu\n", result)<span class="hljs-comment">;</span>
}
</code></pre>
<h3 data-id="heading-11">3.4 功耗特性</h3>
<p>功耗是嵌入式系统设计中非常重要的考虑因素，特别是对于电池供电的设备。</p>
<p>不同架构的处理器在功耗方面差异很大。</p>
<p>ARM Cortex-M 系列在低功耗方面做得非常出色，支持多种低功耗模式：</p>
<ul>
<li><strong>Sleep 模式</strong>：CPU 停止，外设继续运行</li>
<li><strong>Stop 模式</strong>：CPU 和大部分外设停止，保持 RAM 数据</li>
<li><strong>Standby 模式</strong>：仅保持备份寄存器和 RTC，功耗最低</li>
</ul>
<p>下面是一个进入低功耗模式的示例：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-id">#include</span> "stm32f4xx_hal<span class="hljs-selector-class">.h</span>"
​
void <span class="hljs-built_in">Enter_Sleep_Mode</span>(void)
{
    <span class="hljs-comment">/* 挂起SysTick中断 */</span>
    <span class="hljs-built_in">HAL_SuspendTick</span>();
    
    <span class="hljs-comment">/* 进入Sleep模式 */</span>
    <span class="hljs-built_in">HAL_PWR_EnterSLEEPMode</span>(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
    
    <span class="hljs-comment">/* 从Sleep模式唤醒后恢复SysTick */</span>
    <span class="hljs-built_in">HAL_ResumeTick</span>();
}
​
void <span class="hljs-built_in">Enter_Stop_Mode</span>(void)
{
    <span class="hljs-comment">/* 使能PWR时钟 */</span>
    <span class="hljs-built_in">__HAL_RCC_PWR_CLK_ENABLE</span>();
    
    <span class="hljs-comment">/* 挂起SysTick中断 */</span>
    <span class="hljs-built_in">HAL_SuspendTick</span>();
    
    <span class="hljs-comment">/* 进入Stop模式 */</span>
    <span class="hljs-built_in">HAL_PWR_EnterSTOPMode</span>(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
    
    <span class="hljs-comment">/* 从Stop模式唤醒后重新配置系统时钟 */</span>
    <span class="hljs-built_in">SystemClock_Config</span>();
    
    <span class="hljs-comment">/* 恢复SysTick */</span>
    <span class="hljs-built_in">HAL_ResumeTick</span>();
}
</code></pre>
<h3 data-id="heading-12">3.5 中断系统</h3>
<p>中断系统是嵌入式处理器的重要组成部分。</p>
<p>不同架构的中断系统设计差异很大。</p>
<p>ARM Cortex-M 系列使用 NVIC（嵌套向量中断控制器），支持多达 240 个中断源，每个中断可以配置 16 个优先级。</p>
<p>这种设计非常灵活，能够满足复杂应用的需求。</p>
<p>在实际开发中，合理配置中断优先级非常重要。</p>
<p>我的经验是：</p>
<ul>
<li>高优先级：给时间敏感的任务，如通信协议的超时处理</li>
<li>中优先级：给普通外设中断，如串口接收、定时器</li>
<li>低优先级：给不太紧急的任务，如按键扫描</li>
</ul>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-id">#include</span> "stm32f4xx_hal<span class="hljs-selector-class">.h</span>"
​
void <span class="hljs-built_in">NVIC_Config_Example</span>(void)
{
    <span class="hljs-comment">/* 配置USART1中断优先级 */</span>
    <span class="hljs-built_in">HAL_NVIC_SetPriority</span>(USART1_IRQn, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 抢占优先级1，子优先级0</span>
    <span class="hljs-built_in">HAL_NVIC_EnableIRQ</span>(USART1_IRQn);
    
    <span class="hljs-comment">/* 配置TIM2中断优先级 */</span>
    <span class="hljs-built_in">HAL_NVIC_SetPriority</span>(TIM2_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 抢占优先级2，子优先级0</span>
    <span class="hljs-built_in">HAL_NVIC_EnableIRQ</span>(TIM2_IRQn);
    
    <span class="hljs-comment">/* 配置外部中断优先级 */</span>
    <span class="hljs-built_in">HAL_NVIC_SetPriority</span>(EXTI0_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 抢占优先级0（最高），子优先级0</span>
    <span class="hljs-built_in">HAL_NVIC_EnableIRQ</span>(EXTI0_IRQn);
}
</code></pre>
<h2 data-id="heading-13">4. 如何选择合适的处理器架构</h2>
<p>在实际项目中，选择合适的处理器架构需要综合考虑多个因素：</p>
<p><strong>4.1 应用需求</strong></p>
<p>首先要明确应用的具体需求。</p>
<p>如果只是简单的控制任务，8 位或 16 位 MCU 就足够了。</p>
<p>如果需要运行复杂的算法或操作系统，就需要 32 位甚至 64 位的处理器。</p>
<p>我在做汽车电子项目的时候，因为需要运行 Linux 系统并处理大量的多媒体数据，所以选择了 ARM Cortex-A 系列的处理器。</p>
<p>而在做一些简单的传感器节点时，使用 STM32F103 这样的 Cortex-M3 就完全够用。</p>
<p><strong>4.2 性能要求</strong></p>
<p>要根据实际的计算量来选择处理器性能。</p>
<p>过高的性能会造成成本和功耗的浪费，过低的性能又无法满足需求。</p>
<p>一个实用的方法是：先估算应用的计算量，然后选择性能略高于需求的处理器，留出一定的余量。</p>
<p>我的经验是留出 30% 左右的性能余量比较合适。</p>
<p><strong>4.3 功耗限制</strong></p>
<p>对于电池供电的设备，功耗是首要考虑因素。</p>
<p>需要选择支持低功耗模式的处理器，并在软件设计时充分利用这些特性。</p>
<p><strong>4.4 开发生态</strong></p>
<p>开发工具链、软件库、技术支持等生态因素也很重要。</p>
<p>ARM 架构在这方面具有明显优势，有大量的开发工具和参考资料可用。</p>
<p><strong>4.5 成本因素</strong></p>
<p>处理器的成本包括芯片价格、开发成本、授权费用等。对于大批量产品，即使每颗芯片节省几毛钱，总体也能节省很大一笔费用。</p>
<p><strong>4.6 长期供货</strong></p>
<p>嵌入式产品的生命周期通常很长，需要考虑处理器的长期供货能力。</p>
<p>一些老牌厂商如 ST、NXP 通常能保证 10 年以上的供货周期。</p>
<h2 data-id="heading-14">5. 处理器架构的发展趋势</h2>
<h3 data-id="heading-15">5.1 异构多核</h3>
<p>现代嵌入式处理器越来越多地采用异构多核设计，即在一颗芯片上集成不同类型的处理器核心。</p>
<p>比如 ARM 的 big.LITTLE 架构，同时包含高性能核心和低功耗核心，根据负载动态切换。</p>
<p>在汽车电子领域，我见过一些芯片同时集成 Cortex-A 核心（运行 Linux）、Cortex-R 核心（处理实时任务）和 Cortex-M 核心（控制外设），这种设计能够很好地平衡性能、实时性和功耗。</p>
<h3 data-id="heading-16">5.2 AI 加速</h3>
<p>随着边缘 AI 的兴起，越来越多的嵌入式处理器开始集成 AI 加速单元，如 NPU（神经网络处理单元）。</p>
<p>这些专用硬件能够大幅提升神经网络推理的效率。</p>
<h3 data-id="heading-17">5.3 安全特性</h3>
<p>安全性在嵌入式系统中越来越重要。</p>
<p>现代处理器普遍集成了硬件安全模块，如 TrustZone、安全启动、加密引擎等。</p>
<h3 data-id="heading-18">5.4 开源架构</h3>
<p>RISC-V 等开源架构的兴起，为嵌入式处理器市场带来了新的活力。</p>
<p>开源架构的优势在于灵活性和可定制性，能够满足特定应用的需求。</p>
<h2 data-id="heading-19">6. 总结</h2>
<p>嵌入式处理器架构是一个博大精深的领域，涉及硬件设计、指令集、编译器、操作系统等多个层面。</p>
<p>作为嵌入式开发者，我们不需要成为架构设计专家，但需要对常见架构有基本的了解，这样才能在项目中做出正确的技术选择。</p>
<p>在我的职业生涯中，从 51 单片机到 ARM，从简单的裸机程序到复杂的 Linux 系统，每一次架构的转变都是一次技术能力的提升。</p>
<p>我的建议是：先深入掌握一种主流架构（比如 ARM），然后再去了解其他架构，这样能够建立起系统的知识体系。</p>
<p>随着技术的发展，新的处理器架构不断涌现，但核心的设计理念是相通的。</p>
<p>只要掌握了基本原理，学习新架构就会变得容易很多。</p>
<p>希望这篇文章能够帮助大家建立起对嵌入式处理器架构的整体认识，在实际项目中能够做出更好的技术决策。</p>
<p><strong>更多编程学习资源</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fc_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/c_course_handout_2025.html" ref="nofollow noopener noreferrer">C 语言零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fstm32%2Fstm32_course_handout_2024.html" target="_blank" title="https://www.lxlinux.net/e/stm32/stm32_course_handout_2024.html" ref="nofollow noopener noreferrer">STM32 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Ffreertos%2Ffreertos_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/freertos/freertos_course_handout_2025.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fcpp_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/cpp_course_handout_2025.html" ref="nofollow noopener noreferrer">C++ 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2F51-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/51-learning-path.html" ref="nofollow noopener noreferrer">51 单片机零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fad-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/ad-learning-path.html" ref="nofollow noopener noreferrer">AD 画板零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fc-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/c-learning-path.html" ref="nofollow noopener noreferrer">C 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fcpp-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/cpp-learning-path.html" ref="nofollow noopener noreferrer">C++ 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fesp32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/esp32-learning-path.html" ref="nofollow noopener noreferrer">ESP32 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Ffreertos-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/freertos-learning-path.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-devop-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-devop-learning-path.html" ref="nofollow noopener noreferrer">Linux 应用开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-lower-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-lower-learning-path.html" ref="nofollow noopener noreferrer">Linux 底层开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flvgl-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/lvgl-learning-path.html" ref="nofollow noopener noreferrer">LVGL 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fqt-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/qt-learning-path.html" ref="nofollow noopener noreferrer">QT 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fstm32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/stm32-learning-path.html" ref="nofollow noopener noreferrer">STM32 零基础入门学习路线</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[createAsyncThunk]]></title>    <link>https://juejin.cn/post/7603854784864944168</link>    <guid>https://juejin.cn/post/7603854784864944168</guid>    <pubDate>2026-02-08T16:20:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784864944168" data-draft-id="7603854784864927784" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="createAsyncThunk"/> <meta itemprop="keywords" content="React.js"/> <meta itemprop="datePublished" content="2026-02-08T16:20:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="liyang_ii"/> <meta itemprop="url" content="https://juejin.cn/user/2365804756342360"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            createAsyncThunk
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2365804756342360/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    liyang_ii
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T16:20:53.000Z" title="Sun Feb 08 2026 16:20:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>一、 创建异步函数</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createSlice, createAsyncThunk } <span class="hljs-keyword">from</span> <span class="hljs-string">'@reduxjs/toolkit'</span>;
<span class="hljs-keyword">import</span> { getStuListApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/stuApi'</span>;

<span class="hljs-comment">// 1. 创建异步 thunk</span>
<span class="hljs-keyword">const</span> fetchStudents = <span class="hljs-title function_">createAsyncThunk</span>(
  <span class="hljs-string">'students/fetchStudents'</span>,
  <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getStuListApi</span>();
    <span class="hljs-keyword">return</span> response;
  }
);

<span class="hljs-comment">// 2. 创建 slice</span>
<span class="hljs-keyword">const</span> studentsSlice = <span class="hljs-title function_">createSlice</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'students'</span>,
  <span class="hljs-attr">initialState</span>: {
    <span class="hljs-attr">list</span>: [],
    <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,
  },
  <span class="hljs-attr">reducers</span>: {
    <span class="hljs-comment">// 同步 reducers...</span>
  },
  <span class="hljs-comment">// 3. 使用 extraReducers 处理异步 action</span>
  <span class="hljs-attr">extraReducers</span>: <span class="hljs-function">(<span class="hljs-params">builder</span>) =&gt;</span> {
    builder
      <span class="hljs-comment">// pending：请求开始</span>
      .<span class="hljs-title function_">addCase</span>(fetchStudents.<span class="hljs-property">pending</span>, <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
        state.<span class="hljs-property">loading</span> = <span class="hljs-literal">true</span>;
        state.<span class="hljs-property">error</span> = <span class="hljs-literal">null</span>;
      })
      <span class="hljs-comment">// fulfilled：请求成功</span>
      .<span class="hljs-title function_">addCase</span>(fetchStudents.<span class="hljs-property">fulfilled</span>, <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
        state.<span class="hljs-property">loading</span> = <span class="hljs-literal">false</span>;
        state.<span class="hljs-property">list</span> = action.<span class="hljs-property">payload</span>;
      })
      <span class="hljs-comment">// rejected：请求失败</span>
      .<span class="hljs-title function_">addCase</span>(fetchStudents.<span class="hljs-property">rejected</span>, <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
        state.<span class="hljs-property">loading</span> = <span class="hljs-literal">false</span>;
        state.<span class="hljs-property">error</span> = action.<span class="hljs-property">error</span>.<span class="hljs-property">message</span>;
      });
  },
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> studentsSlice.<span class="hljs-property">reducer</span>;
</code></pre>
<p>二、在组件中使用</p>
<pre><code class="hljs language-import" lang="import">import { fetchStudents } from '../store/modules/students';

function StudentsList() {
  const dispatch = useDispatch();
  const { list, loading, error } = useSelector((state) =&gt; state.students);

  useEffect(() =&gt; {
    dispatch(fetchStudents());
  }, [dispatch]);

  if (loading) return &lt;div&gt;加载中...&lt;/div&gt;;
  if (error) return &lt;div&gt;错误: {error}&lt;/div&gt;;

  return (
    &lt;div&gt;
      {list.map((student) =&gt; (
        &lt;div key={student.id}&gt;{student.name}&lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器]]></title>    <link>https://juejin.cn/post/7604344066579120179</link>    <guid>https://juejin.cn/post/7604344066579120179</guid>    <pubDate>2026-02-09T02:24:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604344066579120179" data-draft-id="7604093823958106131" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器"/> <meta itemprop="keywords" content="Claude,Agent"/> <meta itemprop="datePublished" content="2026-02-09T02:24:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="jerrywus"/> <meta itemprop="url" content="https://juejin.cn/user/2823201591402990"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2823201591402990/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    jerrywus
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:24:14.000Z" title="Mon Feb 09 2026 02:24:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    85
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器</h2>
<blockquote>
<p>从 Swagger 文档到 TypeScript 类型、API 函数、Mock 数据，一句指令全自动。</p>
</blockquote>
<h3 data-id="heading-1">前言</h3>
<p>做前端的应该都经历过这种事：</p>
<p>后端丢来一个 Swagger 链接，然后你得：</p>
<ol>
<li>打开文档，一个个看接口定义</li>
<li>手写 TypeScript 类型（请求参数、响应结构）</li>
<li>写 API 调用函数</li>
<li>造 Mock 数据给本地开发用</li>
<li>注册 Mock 路由</li>
</ol>
<p>一个模块少说 2-3 个接口，这些重复劳动能耗掉半天。</p>
<p>后来我想，这活儿能不能自动化？于是折腾了一套方案，现在只要一句话：</p>
<pre><code class="hljs language-bash" lang="bash">实现接口：https://gateway.xxx.cn/doc.html<span class="hljs-comment">#/组织架构服务/供应商管理/page_1</span>
</code></pre>
<p>Claude Code 会自己打开 Swagger 文档、提取接口信息、让你勾选要实现哪些接口，然后并行生成所有代码。</p>
<p>这篇文章记录一下整个搭建过程和实际跑起来的效果。</p>
<h3 data-id="heading-2">整体架构</h3>
<p>先看全貌，方案分三块：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│                  api-add Skill                   │
│              (工作流编排 / 入口)                    │
├─────────────────────────────────────────────────┤
│                                                  │
│  ┌──────────────────┐                            │
│  │ chrome-devtools   │  ← 读取 Swagger 文档       │
│  │      MCP          │  ← 提取接口信息             │
│  └──────────────────┘                            │
│           │                                      │
│           ▼                                      │
│  ┌──────────────────────────────────┐            │
│  │        Agent Team (并行)          │            │
│  │  ┌────────────┐ ┌─────────────┐  │            │
│  │  │ api-define │ │ mock-create │  │            │
│  │  │  (Haiku)   │ │  (Haiku)    │  │            │
│  │  │            │ │             │  │            │
│  │  │ TS 类型    │ │ Mock 数据    │  │            │
│  │  │ API 函数   │ │ Mock 路由    │  │            │
│  │  └────────────┘ └─────────────┘  │            │
│  └──────────────────────────────────┘            │
│                                                  │
└─────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>Skill：自定义技能，定义工作流怎么跑</li>
<li>MCP (Model Context Protocol)：让 AI 能操控浏览器，直接读文档</li>
<li>Agent Team：两个 Agent 同时干活，一个写类型和 API，一个写 Mock</li>
</ul>
<p>下面一个个说。</p>
<h3 data-id="heading-3">一、Chrome DevTools MCP -- 让 AI "看见"浏览器</h3>
<h4 data-id="heading-4">MCP 是什么？</h4>
<p>MCP（Model Context Protocol）是 Anthropic 出的一个开放协议，让 AI 能跟外部工具交互。简单说就是 AI 的插件系统，接上不同的 MCP Server，AI 就多了一种能力。</p>
<h4 data-id="heading-5">为什么要用 Chrome DevTools MCP？</h4>
<p>Swagger/Knife4j 文档是动态渲染的 SPA 页面。你用 <code>fetch</code> 或 <code>curl</code> 去请求，拿到的只是一个空壳 HTML，接口信息全靠 JS 渲染出来，根本抓不到。</p>
<p>Chrome DevTools MCP 能让 AI 操控一个真实的浏览器：</p>
<ul>
<li>打开页面，等 JS 渲染完</li>
<li>读取页面的可访问性树（Accessibility Tree）</li>
<li>点击元素、做页面交互</li>
</ul>
<p>说白了就是让 AI 能像人一样看网页。</p>
<h4 data-id="heading-6">怎么配置</h4>
<p>在 Claude Code 里添加 <code>chrome-devtools</code> MCP server：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FChromeDevTools%2Fchrome-devtools-mcp%3Ftab%3Dreadme-ov-file%23mcp-client-configuration" target="_blank" title="https://github.com/ChromeDevTools/chrome-devtools-mcp?tab=readme-ov-file#mcp-client-configuration" ref="nofollow noopener noreferrer">chrome devtools mcp github 地址</a></p>
<ul>
<li>打开 github 项目页面，找到 Claude Code 的配置指令。进入项目根目录，终端执行：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">claude mcp add chrome-devtools --scope user npx chrome-devtools-mcp@latest
</code></pre>
<ul>
<li>然后在项目 <code>.claude</code> 目录下创建 <code>mcp.json</code>：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"chrome-devtools"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npx"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"-y"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"chrome-devtools-mcp@latest"</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>配好之后 Claude Code 就能操作浏览器了，主要用到这几个工具：</p>





























<table><thead><tr><th>工具</th><th>干什么的</th></tr></thead><tbody><tr><td><code>navigate_page</code></td><td>打开指定 URL</td></tr><tr><td><code>take_snapshot</code></td><td>获取页面快照（可访问性树）</td></tr><tr><td><code>click</code></td><td>点击页面元素</td></tr><tr><td><code>fill</code></td><td>填写表单</td></tr><tr><td><code>take_screenshot</code></td><td>截图</td></tr></tbody></table>
<p>我们这个场景主要用前三个：导航、快照、点击。</p>
<h3 data-id="heading-7">二、api-add Skill -- 工作流编排</h3>
<h4 data-id="heading-8">Skill 是什么？</h4>
<p>Claude Code 的 Skill 就是一个 Markdown 文件，告诉 AI 碰到什么情况该怎么做。里面写清楚：</p>
<ul>
<li>什么时候触发</li>
<li>按什么步骤执行</li>
<li>有什么限制</li>
</ul>
<p>文件放在 <code>.claude/skills/&lt;skill-name&gt;/SKILL.md</code>，Claude Code 启动时会自动加载。</p>
<h4 data-id="heading-9">api-add Skill 怎么设计的</h4>
<p>我想要的效果是：给一个 Swagger URL，自动把接口文档变成可用的代码。</p>
<pre><code class="hljs language-bash" lang="bash">.claude/skills/api-add/SKILL.md
</code></pre>
<pre><code class="hljs language-markdown" lang="markdown">---
name: api-add
description: 从 Swagger 文档或 md 文档快速创建 API function、
  TypeScript 类型定义和 Mock 实现。
<span class="hljs-section">  触发关键词：实现接口、创建接口、添加API、接口定义。
---</span>

<span class="hljs-section"># API from Swagger Doc</span>

<span class="hljs-section">## skill 触发场景</span>

<span class="hljs-section">### 场景1</span>
用户提供接口 url，并说实现接口定义

<span class="hljs-section">### 场景2</span>
用户指定一个 md 文档，则直接从文档中读取接口定义

<span class="hljs-section">## 工作流程</span>

<span class="hljs-section">### 第一步：获取接口信息</span>

使用 chrome-devtools-mcp 读取 Swagger 文档：

<span class="hljs-bullet">1.</span> 使用 navigate<span class="hljs-emphasis">_page 打开 Swagger URL
2. 使用 take_</span>snapshot 读取页面内容
<span class="hljs-bullet">3.</span> 展开左侧菜单，获取当前分类下的所有接口列表
<span class="hljs-bullet">4.</span> 使用 AskUserQuestion，列出所有接口供用户选择
<span class="hljs-bullet">5.</span> 用户确认后，逐一点击并提取完整信息

<span class="hljs-section">### 第二步：创建 Agent Team 并行生成代码</span>

创建 2 个 teammate 分别负责：
<span class="hljs-bullet">-</span> api-define：TypeScript 类型 + API 函数
<span class="hljs-bullet">-</span> mock-create：Mock 数据 + Mock 路由

<span class="hljs-section">### 第三步：清除 teams 并结束</span>
</code></pre>
<p>这里说几个我做的选择：</p>
<p><strong>1. 为什么用 MCP 而不是直接请求 API？</strong></p>
<p>Swagger 文档是前端渲染的 SPA，HTTP 请求拿不到内容。必须在真实浏览器里跑一遍 JS 才能看到接口信息。</p>
<p><strong>2. 为什么要让用户选接口？</strong></p>
<p>一个模块可能有十几个接口，但这次迭代可能只用到其中两三个（或者部分接口已经实现过了）。让用户自己勾选，省得生成一堆用不上（或者重复）的代码。</p>
<p><strong>3. 为什么用 Agent Team？</strong></p>
<p>写 TypeScript 类型/API 函数和写 Mock 数据/路由，这两件事互不依赖。让两个 Agent 同时跑，时间省一半。而且 Agent 用的是 Haiku 模型，比主模型便宜很多。</p>
<p>✏️ 我测试了一下，单独写⬆是6分钟多一点；使用agent teams 是4分钟多一点（因为是小功能， 时间节省不太明显， 但贵在省时间。 你可以尝试大功能，比如实现一个复杂的模块，时间节省会更明显）</p>
<h3 data-id="heading-10">三、Agent 定义 -- 分工干活</h3>
<p>除了 Skill，还得定义两个 Agent，它们才是真正写代码的。</p>
<p>💡 重点：agent team的配置，请参考：&lt;<a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.claude.com%2Fdocs%2Fen%2Fagent-teams" target="_blank" title="https://code.claude.com/docs/en/agent-teams" ref="nofollow noopener noreferrer">code.claude.com/docs/en/age…</a></p>
<h4 data-id="heading-11">api-define Agent</h4>
<pre><code class="hljs language-bash" lang="bash">.claude/agents/api-define.md
</code></pre>
<pre><code class="hljs language-markdown" lang="markdown">---
name: api-define
description: 实现指定模块的 api function &amp; typescript 类型的创建
model: haiku
<span class="hljs-section">color: green
---</span>

实现指定模块的 api function &amp; typescript 类型的创建，
严格按以下要求实现：

<span class="hljs-bullet">1.</span> 严格参照 .claude/rules/ 中的编码规范
<span class="hljs-bullet">2.</span> 完整实现：TypeScript 类型、API 函数
</code></pre>
<h4 data-id="heading-12">mock-create Agent</h4>
<pre><code class="hljs language-bash" lang="bash">.claude/agents/mock-define.md
</code></pre>
<pre><code class="hljs language-markdown" lang="markdown">---
name: mock-create
description: 实现指定 api 接口的 mock 实现
model: haiku
<span class="hljs-section">color: orange
---</span>

实现指定 api 接口的 mock 实现，严格按以下要求实现：

<span class="hljs-bullet">1.</span> 严格参照 .claude/rules/ 中的编码规范
<span class="hljs-bullet">2.</span> 完整实现：Mock 服务器（mocks 目录），
   实现 Express 接口（routes、controllers、data）
</code></pre>
<p>几个值得说的点：</p>
<ul>
<li><code>model: haiku</code> -- 用轻量模型就够了，写这种模式化的代码不需要大模型，跑得快还省钱</li>
<li>"严格参照编码规范" -- 靠 <code>.claude/rules/</code> 里的规则文件约束代码风格，后面会讲</li>
<li><code>color</code> -- 终端里用不同颜色区分两个 Agent 的输出，看着方便</li>
</ul>
<h3 data-id="heading-13">四、实战演示</h3>
<p>来看实际跑一遍是什么样。我要给"供应商管理"模块实现接口。</p>
<h4 data-id="heading-14">Step 1：触发 Skill</h4>
<p>只需要输入一句话：</p>
<pre><code class="hljs language-bash" lang="bash">实现接口：https://gateway.xxx.cn/doc.html<span class="hljs-comment">#/组织架构服务/供应商管理/page_1</span>
</code></pre>
<p>Claude Code 会自动识别到 <code>api-add</code> Skill，加载后通过 MCP 打开 Swagger 文档：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e948483133324fb1b0f8986be2742160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=ftslIu6YhH41rtfCTFrv9IJrSLA%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-15">Step 2：读取文档，选择接口</h4>
<p>AI 通过浏览器快照读到页面内容，找到左侧菜单里"供应商管理"下的所有接口，弹出选择框让我勾：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/997669987d614a0eb299e311aa5b5ca0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=ptv%2BALNriB%2Bw8yS54wfx92dGWZ4%3D" alt="image.png" loading="lazy"/></p>
<p>它做了这几件事：</p>
<ul>
<li>识别了左侧菜单的接口列表（POST 分页列表、GET 配置商户）</li>
<li>点进每个接口 Tab，提取了完整的请求参数和响应结构</li>
<li>URL 指向的"分页列表"被标成了推荐选项</li>
</ul>
<p>我两个都选了。</p>
<h4 data-id="heading-16">Step 3：Agent Team 并行干活</h4>
<p>确认后，Claude Code 起了一个 Agent Team，两个 Agent 同时开工：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e054e889ceb469d9e2292a4a0e1b3a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=SNNIMFrSXPKovm7%2Bz1scT0%2FYZYc%3D" alt="image.png" loading="lazy"/></p>
<p>截图里能看到：</p>
<ul>
<li>api-definer（绿色）在写 TypeScript 类型定义和 API 函数</li>
<li>mock-creator（橙色）在写 Mock 数据和路由</li>
<li>两个同时跑，互不影响</li>
<li>底部状态栏显示着两个 Agent 的运行状态</li>
</ul>
<h4 data-id="heading-17">Step 4：完成，收工</h4>
<p>两个 Agent 干完活，自动关闭并清理资源：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8d5d80403a0406d88ec4040497cd007~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=uMa1W2ICLxjPnObWIJKYgTcDwIc%3D" alt="image.png" loading="lazy"/></p>
<p>最终生成了这些文件：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># API &amp; 类型定义</span>
src/types/supply-company.ts          ← TypeScript 类型
src/api/supply-company/index.ts      ← API 函数

<span class="hljs-comment"># Mock 实现</span>
mocks/routes/data/supply-company-page.json    ← Mock 数据
mocks/routes/supply-company.controller.cjs    ← Mock 控制器
mocks/routes/org.cjs                          ← 路由挂载（已更新）
</code></pre>
<h3 data-id="heading-18">五、看看生成的代码</h3>
<p>代码质量怎么样？直接贴。</p>
<h4 data-id="heading-19">TypeScript 类型定义</h4>
<p>部分展示：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/types/supply-company.ts</span>

<span class="hljs-comment">/** 供应商分页查询参数 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISupplyCompanyPageParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPageParam</span> {
  <span class="hljs-comment">/** 供应商名称 */</span>
  name?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/** 供应商分页列表项 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISupplyCompanyPageVO</span> {
  <span class="hljs-comment">/** 供应商组织id */</span>
  <span class="hljs-attr">orgId</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 公司编码 */</span>
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 供应商名称 */</span>
  <span class="hljs-attr">orgName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 负责人id */</span>
  <span class="hljs-attr">staffId</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 负责人姓名 */</span>
  <span class="hljs-attr">userName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 状态 */</span>
  <span class="hljs-attr">status</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 所属商户 */</span>
  <span class="hljs-attr">merchantName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 创建人 */</span>
  <span class="hljs-attr">creator</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 创建时间 */</span>
  <span class="hljs-attr">createTime</span>: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p><code>I</code> 前缀、JSDoc 注释、继承 <code>IPageParam</code>，跟项目里手写的一模一样。</p>
<h4 data-id="heading-20">API 函数</h4>
<p>部分展示：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/api/supply-company/index.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">querySupplyCompanyPage</span>(<span class="hljs-params">
  params: ISupplyCompanyPageParam
</span>) {
  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> data = [] <span class="hljs-keyword">as</span> <span class="hljs-title class_">ISupplyCompanyPageVO</span>[];
  params = <span class="hljs-title function_">toConditional</span>(params);

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { code, context, message } = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Http</span>.<span class="hljs-property">post</span>&lt;{
      <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span>;
      <span class="hljs-attr">data</span>: <span class="hljs-title class_">ISupplyCompanyPageVO</span>[];
    }&gt;(<span class="hljs-string">`<span class="hljs-subst">${baseUrl}</span>/page`</span>, { ...params });

    <span class="hljs-keyword">if</span> (code !== <span class="hljs-title class_">EResponseCode</span>.<span class="hljs-property">Succeed</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message || <span class="hljs-string">'服务器异常，请稍后再试~'</span>);
    }
    total = context?.<span class="hljs-property">total</span> || <span class="hljs-number">0</span>;
    data = context?.<span class="hljs-property">data</span> || [];
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-title function_">getHttpErrorMessage</span>(error));
  }

  <span class="hljs-keyword">return</span> { total, data };
}
</code></pre>
<p>项目里标准的 API 写法：<code>async/await</code> + <code>try/catch</code> + <code>toConditional</code> + 错误处理，一个不差。</p>
<h4 data-id="heading-21">Mock 数据</h4>
<p>部分展示：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-comment">// mocks/routes/data/supply-company-page.json</span>
<span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"orgId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1001</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"code"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"SC-2025-001"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"orgName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"上海奢品供应链有限公司"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"staffId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2001</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"userName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"张经理"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ENABLED"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"merchantName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LuxMall旗舰店"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"creator"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"系统管理员"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"createTime"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2025-01-15 10:30:00"</span>
  <span class="hljs-punctuation">}</span>
  <span class="hljs-comment">// ... 更多数据</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<p>Mock 数据的字段值是有意义的中文内容，不是那种 <code>"string"</code> 占位符。</p>
<h4 data-id="heading-22">Mock 控制器</h4>
<p>部分展示：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// mocks/controllers/supply-company.controller.cjs</span>

<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();
<span class="hljs-keyword">const</span> supplyCompanyList = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./data/supply-company-list.json'</span>);

<span class="hljs-comment">/**
 * 供应商分页列表
 * POST /page
 */</span>
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/page'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> all = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(supplyCompanyList));
  <span class="hljs-keyword">const</span> { page = <span class="hljs-number">1</span>, size = <span class="hljs-number">50</span>, name } = req.<span class="hljs-property">body</span> || {};

  <span class="hljs-comment">// 按供应商名称模糊搜索</span>
  <span class="hljs-keyword">if</span> (name) {
    all = all.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span>
      <span class="hljs-title class_">String</span>(item.<span class="hljs-property">orgName</span>).<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">String</span>(name))
    );
  }

  <span class="hljs-keyword">const</span> total = all.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> start = (<span class="hljs-title class_">Number</span>(page) - <span class="hljs-number">1</span>) * <span class="hljs-title class_">Number</span>(size);
  <span class="hljs-keyword">const</span> end = start + <span class="hljs-title class_">Number</span>(size);
  <span class="hljs-keyword">const</span> data = all.<span class="hljs-title function_">slice</span>(start, end);

  res.<span class="hljs-title function_">json</span>({
    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">context</span>: { total, data },
    <span class="hljs-attr">traceId</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">spanId</span>: <span class="hljs-string">''</span>,
  });
});

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;
</code></pre>
<p>分页、模糊搜索、标准响应格式，都按项目的 Mock 规范来的。</p>
<h3 data-id="heading-23">六、代码质量靠什么保证？Rules</h3>
<p>你可能会想：AI 怎么知道我们项目的编码规范？</p>
<p>靠 <code>.claude/rules/</code> 目录。这是 Claude Code 的规则系统，你可以理解为给 AI 写了一份项目编码手册：</p>
<pre><code class="hljs language-bash" lang="bash">.claude/rules/
├── api.md           ← API 实现标准（函数命名、错误处理模式）
├── ts-define.md     ← TypeScript 规范（I前缀、E前缀、JSDoc）
├── mock.md          ← Mock 服务器架构（路由、控制器、数据文件）
├── components.md    ← 组件库参考
├── vue-single-file.md ← Vue SFC 标准
└── ...
</code></pre>
<p>每个 Agent 工作时都会读这些规则文件。所以生成出来的代码风格跟项目里手写的一致，不会出现那种一看就是 AI 写的通用代码。</p>
<h3 data-id="heading-24">七、想复刻？文件结构在这</h3>
<p>如果你想在自己项目里搞一套，需要这些文件：</p>
<pre><code class="hljs language-csharp" lang="csharp">.claude/
├── agents/
│   ├── api-define.md          ← API 定义 Agent
│   └── mock-define.md         ← Mock 创建 Agent
├── skills/
│   └── api-<span class="hljs-keyword">add</span>/
│       └── SKILL.md           ← 工作流编排 Skill
├── rules/
│   ├── api.md                 ← API 编码规范
│   ├── ts-define.md           ← TypeScript 规范
│   └── mock.md                ← Mock 规范
└── ...

<span class="hljs-meta"># MCP 配置（项目级或全局）</span>
.mcp.json                      ← Chrome DevTools MCP 配置
</code></pre>
<h3 data-id="heading-25">八、效果对比</h3>








































<table><thead><tr><th>维度</th><th>手动开发</th><th>api-add Skill</th></tr></thead><tbody><tr><td>耗时</td><td>6.5m</td><td>4.3m</td></tr><tr><td>类型定义</td><td>手动从文档抄</td><td>自动提取，不会漏字段</td></tr><tr><td>API 函数</td><td>复制模板手动改</td><td>自动生成，符合规范</td></tr><tr><td>Mock 数据</td><td>手动编假数据</td><td>自动生成，内容像真的</td></tr><tr><td>代码规范</td><td>看个人习惯</td><td>Rules 强制约束</td></tr><tr><td>人为错误</td><td>字段名拼错、类型写错</td><td>从文档直接提取，基本不会错</td></tr></tbody></table>
<h3 data-id="heading-26">总结</h3>
<p>回头看，这套方案做了四件事：</p>
<ol>
<li>用 MCP 让 AI 能读浏览器里的 Swagger 文档</li>
<li>用 Skill 把多步骤任务编排成一句话就能触发的流程</li>
<li>用 Agent Team 让两个轻量 Agent 并行干活，省时间也省钱</li>
<li>用 Rules 约束代码风格，保证生成的代码跟手写的一样</li>
</ol>
<p>说到底就是把"从文档到代码"这个重复劳动自动化了。</p>
<p>这套方案也不只能用在 Swagger 上。改一下 Skill 的工作流，Apifox、Postman、自定义 Markdown 文档、GraphQL Schema，只要浏览器能打开的接口文档都能接。</p>
<p>如果你也在用 Claude Code，可以试试 Skill + MCP 这个组合。</p>
<hr/>
<blockquote>
<p>觉得有用的话点个赞，也欢迎在评论区聊聊你的 Claude Code 玩法。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AAAI 2026这篇杰出论文说了什么？用LLM给CLIP换了个“聪明大脑”]]></title>    <link>https://juejin.cn/post/7604036853129347087</link>    <guid>https://juejin.cn/post/7604036853129347087</guid>    <pubDate>2026-02-09T02:24:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604036853129347087" data-draft-id="7603699739224555535" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AAAI 2026这篇杰出论文说了什么？用LLM给CLIP换了个“聪明大脑”"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2026-02-09T02:24:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AAAI 2026这篇杰出论文说了什么？用LLM给CLIP换了个“聪明大脑”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:24:27.000Z" title="Mon Feb 09 2026 02:24:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>在多模态大模型飞速发展的今天，CLIP作为连接视觉与语言的“基石”依然发挥着重要作用。然而，随着应用场景的深入，研究人员逐渐发现CLIP的文本编码器已经成为整个系统的瓶颈：<strong>不仅受限于77个Token的长度限制，在处理复杂、长篇的图像描述时也显得力不从心。</strong></p>
<p>来自同济大学、微软和麦考瑞大学的研究团队提出了 <strong>LLM2CLIP（Large Language Model to CLIP）</strong> ，<strong>通过将大语言模型的深厚知识“注入”到CLIP架构中，显著提升了长文本检索的精度，同时赋予了模型强大的多语言处理能力。</strong></p>
<p>这项研究凭借其卓越的创新性，成功斩获 AAAI 2026 杰出论文奖。</p>
<blockquote>
<p><strong>论文地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2411.04997%25C2%25A0" target="_blank" title="https://arxiv.org/abs/2411.04997%C2%A0" ref="nofollow noopener noreferrer">arxiv.org/abs/2411.04…</a></p>
<p><strong>项目主页：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Faka.ms%2Fllm2clip" target="_blank" title="https://aka.ms/llm2clip" ref="nofollow noopener noreferrer">aka.ms/llm2clip</a></p>
<p><strong>代码仓库：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2FLLM2CLIP" target="_blank" title="https://github.com/microsoft/LLM2CLIP" ref="nofollow noopener noreferrer">github.com/microsoft/L…</a> (已开源)</p>
</blockquote>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9c7c88d98a0488983d785a43403cd54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=YNNDgB0KfIewojki2qkehh05mFQ%3D" alt="图片1.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h2 data-id="heading-0"><strong>传统CLIP的“语言瓶颈”</strong></h2>
<p>自2021年OpenAI发布CLIP以来，这种双塔结构模型已经成为多模态领域的标配。</p>
<p>无论是LLaVA这样的理解模型，还是Stable Diffusion这样的生成模型，都离不开CLIP的贡献。</p>
<p><strong>但问题在于，传统的CLIP文本编码器通常是规模较小的Transformer结构，其处理长描述（Dense Captions）的能力非常有限。</strong></p>
<p>与此同时，大语言模型在文本理解上已经达到了惊人的高度。那么，为什么不直接把LLM拿来当CLIP的文本编码器呢？</p>
<p>研究团队发现，这里存在两个核心挑战：</p>
<ul>
<li>特征可分性问题：原始LLM的特征空间并不是为了对比学习设计的。实验显示，像Llama 3这样的模型在处理图像描述时，其特征区分度极差，Top-1检索准确率甚至不到6%</li>
<li>训练成本过高：如果每次训练CLIP都要微调一个7B甚至更大的LLM，那算力开销将是天文数字</li>
</ul>
<h2 data-id="heading-1"><strong>两阶段“注入”方案：巧妙的架构设计</strong></h2>
<p>LLM2CLIP的核心创新在于提出了一个巧妙的两阶段微调方案，既解决了特征可分性问题，又大幅降低了训练成本。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6713095d3aae4808b8082dc43dff6f48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=y1P6rdZK3pGTWjYM1KJ1mb930rw%3D" alt="图片2.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>第一阶段：让LLM学会“提取特征”</strong></li>
</ul>
<p>为了解决LLM特征区分度不足的问题，研究者首先对LLM进行了“嵌入化”改造：</p>
<p><strong>架构调整：</strong> 移除了LLM原有的因果掩码，改为双向注意力机制，并采用平均池化来获取整句的嵌入向量</p>
<p><strong>对比学习：</strong> 利用LoRA技术，在高质量的描述语料库（如DreamLIP）上进行监督式描述对比微调</p>
<p>简单来说，这一步是让LLM明白：即使是两段描述同一个物体的不同文字，在特征空间里也应该靠得更近。</p>
<p>效果惊人：经过这一阶段，Llama 3在COCO描述检索上的准确率从5.2%飙升到了29.5%</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbc2efe7d75a4b6d81bf0e092f628187~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=88t36GQBtSvBCVSQn4ZiR3Vxt4g%3D" alt="图片3.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>第二阶段：视觉与语言的轻量级对齐</strong></li>
</ul>
<p>在LLM具备了良好的特征区分度后，接下来的任务是将其与CLIP的视觉编码器对齐：</p>
<p><strong>轻量级适配器：</strong> 选择冻结LLM，仅在LLM输出后添加一个由4层线性层组成的线性适配器</p>
<p><strong>离线特征加载：</strong> 这是提升效率的神来之笔。由于LLM是冻结的，研究者可以预先计算并存储所有文本的特征。这样在训练视觉编码器时，就不需要反复运行庞大的LLM</p>
<p>损失函数：研究团队发现，最简单的方法效果最好——直接用LLM替换原有的文本编码器进行对比学习</p>
<h2 data-id="heading-2"><strong>全方位性能提升：从长文本到多语言</strong></h2>
<p>研究团队在多个SOTA基准模型（如OpenAI CLIP, EVA02, SigLIP2）上应用了LLM2CLIP方案，结果令人振奋。</p>
<ul>
<li><strong>长文本检索：性能大幅提升</strong></li>
</ul>
<p>在长文本检索数据集（如DOCCI和Urban1K）上，相比于原本已经非常强大的SigLIP2，LLM2CLIP带来了巨大提升：</p>
<p>在DOCCI数据集上，SigLIP2经过LLM2CLIP微调后，平均检索精度提升了14-15个百分点</p>
<p>即使在短文本的Flickr和COCO任务上，性能也稳步提升</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94739dbc52c5410f9e456ee81b62c8dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=k4uNUd%2BCqeC7rQ3iGN5%2FE0K1IuA%3D" alt="图片4.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>多语言能力：意外惊喜</strong></li>
</ul>
<p>由于LLM本身就是在海量多语言语料上训练的，LLM2CLIP继承了这种天赋：</p>
<p>原本只支持英文的EVA02在加入LLM2CLIP后，在中文检索任务上直接从“不可用”变成了“顶尖水平”</p>
<p>SigLIP2的多语言能力也得到了显著增强，在XM3600任务上的表现提升了11.9/15.2</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b41bd0cf9dc476480e879b075d546e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=FfruYegap2VBT1pGP%2F8t0E8zqEw%3D" alt="图片5.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>视觉表征的“反哺效应”</strong></li>
</ul>
<p>高质量的文本监督不仅让检索变准了，还让视觉编码器本身变得更强：</p>
<p>在ImageNet的线性探测实验中，LLM2CLIP提升了视觉特征的质量；</p>
<p>在下游的零样本分割和检测任务中，性能也有显著增长</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68846ca7e9e04b409b498f787782e347~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=UtEsDBMBZO3red%2BgsLZI8xwrBJc%3D" alt="图片6.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>综合性能：全方位优势</strong></li>
</ul>
<p>从雷达图上可以清晰看到，LLM2CLIP构成的多边形面积远超其他对比模型。</p>
<p>这意味着它不仅在长文本上遥遥领先，在传统的短文本检索任务上也保持了极高的水准，没有任何短板。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85a38286bf774748a0daeeb42411b1c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=E3tGIDS4QvPV%2BJ1fJkoHPIAKfBg%3D" alt="图片7.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h2 data-id="heading-3"><strong>惊人的训练效率：1.3小时完成微调</strong></h2>
<p>对于开发者来说，LLM2CLIP最吸引人的地方在于其惊人的效率。</p>
<p>通过Offline-loading策略，在两台8卡A100机器上，第二阶段的训练时间从17小时缩短到了仅仅1.3小时。</p>
<p>这意味着普通研究团队也能轻松复现并定制自己的LLM2CLIP模型。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ec907ac4a554a6f95d6ff9aa4576762~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=ZURRJCMnW1h8RX3p44irMcCvQ18%3D" alt="图片8.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>研究团队还测试了最新的模型兼容性。令人惊喜的是，即使是最近大火的DeepSeek-R1-Distill-Llama-8B，在经过CC Fine-tuning后也能作为极佳的文本编码器。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bbc7e3d3ffbf4d9baa076ce1c5bbb8ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=7KvcYTrgAJ%2B3Nnu0FItXUExxz1I%3D" alt="图片9.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h2 data-id="heading-4"><strong>核心启示与未来展望</strong></h2>
<p>LLM2CLIP的成功给了我们一个非常重要的启示：</p>
<p>多模态模型的上限，往往取决于语言端对世界的理解深度。</p>
<p>过去我们试图通过堆视觉数据来提升CLIP，但LLM2CLIP证明了，通过引入一个已经“读过万卷书”的LLM，并辅以少量的、高质量的描述数据，就能让视觉表征产生质的飞跃。</p>
<p>这种“低成本、高收益”的方案，很可能会成为未来多模态预训练的新范式。</p>
<p>目前，研究团队已经开源了基于SigLIP2、EVA02和OpenAI CLIP增强的多个版本模型。</p>
<p>如果你正受困于CLIP的文本理解能力，或者需要一个强大的多语言多模态编码器，LLM2CLIP绝对值得一试。</p>
<p>技术的发展总是在解决一个个瓶颈中前进。LLM2CLIP通过巧妙的设计，不仅突破了CLIP的文本编码器限制，更为多模态研究开辟了新的思路：让专业的人（模型）做专业的事，再通过轻量化的方式将它们连接起来。</p>
<p>这或许正是未来AI系统设计的重要方向之一。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[记录overflow：hidden和scrollIntoView导致的页面问题]]></title>    <link>https://juejin.cn/post/7603781883974565907</link>    <guid>https://juejin.cn/post/7603781883974565907</guid>    <pubDate>2026-02-09T00:54:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883974565907" data-draft-id="7603911453704912939" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="记录overflow：hidden和scrollIntoView导致的页面问题"/> <meta itemprop="keywords" content="前端,CSS"/> <meta itemprop="datePublished" content="2026-02-09T00:54:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="EchoEcho"/> <meta itemprop="url" content="https://juejin.cn/user/2920774267837208"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            记录overflow：hidden和scrollIntoView导致的页面问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2920774267837208/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    EchoEcho
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T00:54:31.000Z" title="Mon Feb 09 2026 00:54:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>问题描述：</strong></p>
<p>在一个编辑器中开发页面组件，组件内部对子元素设置了<code>position:absolute</code>定位，并且元素内容区域设置了<code>overflow:hidden</code>属性。</p>
<p>启动项目后，可以在编辑器中可以对该组件进行相关设置和修改。当切换选中内容时，页面会自动滚动，将选中组件显示到浏览器视口中，修改对应属性也会重新渲染对应组件。</p>
<p>第一次渲染时<code>UI</code>展示正常。但是当对该组件切换选中元素或者对设置了定位的子元素设置新属性时都会导致下图中子元素的定位异常。但是在调试面板中查询该元素属性值，也没有任何改变。尝试重新在控制面板中赋值对应的<code>top</code>值，模型又会显示到指定位置。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/680e54f11bd0464c87eb9de36a1c1fab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771203270&amp;x-signature=8zc6JrnLZq2DRUXCjQhHKu%2Boa%2FI%3D" alt="图片" loading="lazy"/></p>
<p><strong>解决过程</strong></p>
<p>尝试使用内容监听器在组件被选中后，重新赋值对应的<code>top</code>和<code>left</code>值无法解决此问题。</p>
<p>后来通过浏览器断点调试，发现在触发监听器之前，该组件执行了<code>scrollIntoView</code>方法，见下图</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4dc06665708e49439c82ddc2d9d6229d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771203270&amp;x-signature=fh72jPLZA04zjQ5T5IkoMgCAa0M%3D" alt="图片" loading="lazy"/></p>
<p><strong>相关分析：</strong></p>
<p>在执行<code>ScrollIntoView</code>期间会多次重绘【<code>reflow/repaint</code>】页面布局。而子元素中定位相关属性值会在重绘时基于父元素的当前视口上下文重新计算，导致位置偏移，比如上图中的子元素底部与父元素对齐现象。</p>
<ol>
<li>平滑滚动动画（<code>behavior: 'smooth'</code>）：</li>
</ol>
<ul>
<li>动画过程会逐步改变滚动位置，触发多次布局计算。</li>
</ul>

<ul>
<li>如果父元素有 <code>overflow: hidden</code>，子元素超出部分在动画中可能被“拉回”或重定位。</li>
</ul>
<ol start="2">
<li><code>block: 'center'</code> 配置：</li>
</ol>
<ul>
<li>这会尝试将父元素置于视口中心，如果父元素高度不是固定值（例如依赖内容或响应式），百分比 <code>top</code> 会基于新滚动位置重新计算，导致子元素“滑动”到底部对齐。</li>
</ul>
<ol start="3">
<li>绝对定位的参考点变化：</li>
</ol>
<ul>
<li><code>absolute</code> 元素依赖最近的 <code>position: relative</code> 祖先。在滚动动画中，如果祖先的可见区域变化，子元素的计算位置会偏移。</li>
</ul>
<ol start="4">
<li>浏览器特定行为：</li>
</ol>
<ul>
<li><code>Chrome/Safari</code> 在 <code>smooth scroll</code> 时有时会错误处理百分比定位，尤其是结合 <code>overflow: hidden</code> 时。</li>
</ul>
<p><strong>而这里遇到的问题就是在组件相关容器中设置了<code>overflow:hidden</code>。</strong></p>
<p><strong>解决：</strong></p>
<p>将<code>overflow:hidden</code>改成<code>overflow:clip</code>就解决此问题了。</p>
<p><strong>解析<code>overflow:hidden</code>和<code>overflow:clip</code></strong></p>
<ul>
<li><code>overflow: hidden</code>：</li>
<li>
<ul>
<li>隐藏超出元素边界的内容，但内容在内部仍然“存在”。</li>
<li>不显示滚动条，但可以通过<code>JavaScript</code>（如 <code>element.scrollLeft</code>）或嵌套滚动访问隐藏内容。</li>
<li>这是较早的标准值，广泛支持所有现代浏览器。</li>
</ul>
</li>
</ul>

<ul>
<li><code>overflow: clip</code>：</li>
<li>
<ul>
<li>完全“剪切”超出边界的内容，就好像超出部分不存在一样。</li>
<li>不允许任何形式的滚动访问（即使通过<code>JS</code>），内容被彻底丢弃。</li>
<li>这是<code>CSS Overflow Module Level 3</code> 中的新值（引入于 2020 年左右），浏览器支持较新（Chrome 90+、Firefox 75+、Safari 15+）。在旧浏览器中可能回退到 <code>hidden</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. 关键区别</strong></p>













































<table><thead><tr><th>方面</th><th>overflow: hidden</th><th>overflow: clip</th></tr></thead><tbody><tr><td>内容可见性</td><td>隐藏超出部分，但内容仍可通过<code>JS</code> 滚动访问。</td><td>完全剪切超出部分，无法通过任何方式访问。</td></tr><tr><td>滚动行为</td><td>创建一个隐形的滚动容器；滚动事件可冒泡到父元素。</td><td>不创建滚动容器；滚动事件直接传递给父元素，不被捕获。</td></tr><tr><td>性能影响</td><td>可能导致浏览器计算隐藏内容的布局和渲染（较低性能）。</td><td>优化性能：浏览器忽略超出内容的渲染和布局（更快，尤其在复杂页面）。</td></tr><tr><td>定位/粘性影响</td><td>支持 <code>position: sticky</code> 等行为；创建新的块格式化上下文 (<code>BFC</code>)。</td><td>不支持 <code>position: sticky</code>（元素不会粘性）；不创建 <code>BFC</code>。</td></tr><tr><td>JS 交互</td><td>可以用<code>JS</code> 修改滚动位置（如 <code>scrollTo()</code>）。</td><td>无法用 <code>JS</code> 滚动；超出内容被视为不存在。</td></tr><tr><td>浏览器支持</td><td>所有现代浏览器（<code>IE6+</code>）。</td><td>较新浏览器；需检查兼容性（<code>polyfill</code> 有限）。</td></tr><tr><td>用例</td><td>适合需要隐藏但可能内部滚动的场景（如裁剪图片但允许<code>JS</code>动画）。</td><td>适合纯静态剪切场景（如性能敏感的游戏/<code>UI</code>），或防止意外滚动。</td></tr></tbody></table>
<ul>
<li>核心差异总结：<code>hidden</code> 是“隐藏但可访问”的（像盖了个盖子），而 <code>clip</code> 是“彻底删除超出部分”的（像用剪刀剪掉）。<code>clip</code> 更严格，旨在提高性能，但牺牲了一些灵活性。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我彻底搞懂了 SSE，原来流式响应效果还能这么玩的？（附 JS/Dart 双端实战）]]></title>    <link>https://juejin.cn/post/7604084016510271529</link>    <guid>https://juejin.cn/post/7604084016510271529</guid>    <pubDate>2026-02-09T02:33:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510271529" data-draft-id="7603355275257675816" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我彻底搞懂了 SSE，原来流式响应效果还能这么玩的？（附 JS/Dart 双端实战）"/> <meta itemprop="keywords" content="前端,面试,GitHub"/> <meta itemprop="datePublished" content="2026-02-09T02:33:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小林的编程开发日记"/> <meta itemprop="url" content="https://juejin.cn/user/3320949647350765"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我彻底搞懂了 SSE，原来流式响应效果还能这么玩的？（附 JS/Dart 双端实战）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3320949647350765/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小林的编程开发日记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:33:49.000Z" title="Mon Feb 09 2026 02:33:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大家好，我是【小林】</p>
<p>说起来有点意思，最近我在做 AI 项目的时候，突然对 "流式响应效果" 产生了浓厚兴趣也就是所谓的打字机效果。你知道那种感觉吧，AI 回答的时候，文字像被人敲出来一样，一个字一个字地蹦出来。</p>
<p>以前我以为是前端用 <code>setTimeout</code> 模拟的，直到有一次网络抖动，我发现它居然能<strong>从断开的地方继续输出</strong>，而不是重新开始。这就像看直播卡顿后，会自动从卡住的地方继续播放，而不是重播一遍。</p>
<p>这不就是<strong>断点续传</strong>吗？但 HTTP 请求不是无状态的吗？</p>
<p>带着这个疑问，我开始深入研究，才发现这背后藏着一套完整的流式传输协议——<strong>SSE（Server-Sent Events）</strong>。</p>
<p>更让我意外的是，我发现业界对于"AI 流式响应该用 SSE 还是 WebSocket"这个话题，争议还挺大。有人说 WebSocket 功能更强大，有人说 SSE 更简单。</p>
<p><strong>到底该选哪个？</strong></p>
<p>我干脆从零开始实现了一套完整的 Demo，包含后端服务、JavaScript 客户端、Dart 客户端，甚至还实现了断线重连、指数退避、粘包处理等生产级特性。</p>
<p>这篇文章，我就把这背后的原理、坑点、实战经验分享出来。</p>
<hr/>
<h2 data-id="heading-1">篇章一：为什么 AI 聊天首选 SSE 而非 WebSocket？</h2>
<p>在讲代码之前，我们先搞清楚一个核心问题：<strong>为什么 ChatGPT、Claude 这些 AI 助手都选 SSE，而不是看起来更强大的 WebSocket？</strong></p>
<h3 data-id="heading-2">1.1 场景分析：AI 对话的"一问多答"模式</h3>
<p>我们先看 AI 对话的典型特征：</p>
<pre><code class="hljs">用户：如何学好 Flutter？
AI：  【开始一段一段地输出，持续十几秒甚至更长】
</code></pre>
<p>这就是典型的**"一问多答"模式**：</p>
<ul>
<li>用户发送的 Prompt 通常很短（几个字到几百字）</li>
<li>AI 的回复可能很长（几千字，甚至更长）</li>
<li>数据流向是<strong>单向的</strong>：Server → Client</li>
</ul>
<h3 data-id="heading-3">1.2 SSE vs WebSocket 核心对比</h3>
<p>我们用一个表格来看两者的差异：</p>


















































<table><thead><tr><th>特性</th><th>SSE</th><th>WebSocket</th></tr></thead><tbody><tr><td><strong>通信方向</strong></td><td>单工（Server → Client）</td><td>全双工（双向通信）</td></tr><tr><td><strong>协议基础</strong></td><td>HTTP 标准</td><td>自定义 WS 协议</td></tr><tr><td><strong>连接方式</strong></td><td>标准 HTTP 请求</td><td>需要握手升级</td></tr><tr><td><strong>鉴权方式</strong></td><td>✅ 自定义 Header（如 Authorization）</td><td>❌ 只能在握手时带 Header</td></tr><tr><td><strong>断线重连</strong></td><td>✅ 内置 Last-Event-ID 机制</td><td>❌ 需要手动实现</td></tr><tr><td><strong>浏览器调试</strong></td><td>✅ DevTools 直接查看 EventStream</td><td>⚠️ 需要在 WS Frames 面板查看</td></tr><tr><td><strong>服务端实现</strong></td><td>✅ 简单，标准 HTTP 响应</td><td>⚠️ 需要维护连接状态</td></tr><tr><td><strong>AI 场景契合度</strong></td><td>✅ 完美匹配"一问多答"</td><td>❌ 过度设计</td></tr></tbody></table>
<h3 data-id="heading-4">1.3 一个餐厅大厨的比喻</h3>
<p>让我用一个好懂的比喻来解释：</p>
<p><strong>SSE 就像"自助餐厅的传菜口"</strong>：</p>
<ul>
<li>你点完菜（发送 HTTP 请求）</li>
<li>厨师开始炒菜，炒好一道就传出来一道（Server 持续推送数据）</li>
<li>你坐在那里等，菜一道一道地上来（Client 接收流式数据）</li>
<li>如果突然停电了，来电后厨师会问你："刚才上到第几道了？"然后继续上（断线重连）</li>
</ul>
<p><strong>WebSocket 就像"打电话订外卖"</strong>：</p>
<ul>
<li>你和骑手保持通话（双向通信通道）</li>
<li>骑手一边送一边向你汇报位置（实时双向交互）</li>
<li>如果电话断了，你得重新打过去，还得从头说（需要手动重连）</li>
</ul>
<p>对于 AI 聊天这种"我点菜，你上菜"的场景，SSE 的传菜口模式显然更合适。WebSocket 更适合"我和骑手实时沟通位置"这种需要频繁交互的场景。</p>
<h3 data-id="heading-5">1.4 为什么不用原生 EventSource？</h3>
<p>看到这里你可能会问：<strong>浏览器不是有原生 <code>EventSource</code> API 吗？为什么还要自己实现？</strong></p>
<p>问题在于，原生 <code>EventSource</code> 有几个致命限制：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 原生 EventSource 的问题</span>
<span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">'/stream'</span>);  <span class="hljs-comment">// ❌ 只支持 GET</span>

<span class="hljs-comment">// ❌ 无法自定义 Header（比如 Authorization）</span>
<span class="hljs-comment">// ❌ 无法发送请求体（AI 场景的 Prompt 可能很长）</span>
<span class="hljs-comment">// ❌ 只能在 URL 里传参数，不安全也不优雅</span>
</code></pre>
<p>在 AI 场景下，我们需要：</p>
<ul>
<li>用 <strong>POST</strong> 请求发送长 Prompt</li>
<li>在 Header 里带 <strong>Authorization</strong> Token</li>
<li>支持自定义错误处理和重连策略</li>
</ul>
<p>所以，我们需要基于 <code>fetch + ReadableStream</code> 自己实现一个 SSEManager。</p>
<hr/>
<h2 data-id="heading-6">篇章二：直击底层：SSE 协议原理剖析</h2>
<h3 data-id="heading-7">2.1 SSE 协议格式</h3>
<p>SSE 是基于 HTTP 的，协议格式非常简单：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">event:</span> message
<span class="hljs-symbol">id:</span> <span class="hljs-number">1234567890</span>
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>: <span class="hljs-string">"content"</span>, <span class="hljs-string">"payload"</span>: <span class="hljs-string">"我"</span>}

<span class="hljs-symbol">event:</span> message
<span class="hljs-symbol">id:</span> <span class="hljs-number">1234567891</span>
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>: <span class="hljs-string">"content"</span>, <span class="hljs-string">"payload"</span>: <span class="hljs-string">"喜"</span>}

<span class="hljs-symbol">event:</span> close
<span class="hljs-symbol">data:</span> [DONE]
</code></pre>
<p><strong>协议要点</strong>：</p>
<ul>
<li>每条消息由 <code>event:</code>、<code>id:</code>、<code>data:</code> 三个字段组成</li>
<li>字段顺序不重要，但每条消息后必须有一个<strong>空行</strong>作为分隔符</li>
<li><code>event:</code> 表示事件类型（message、error、close 等）</li>
<li><code>id:</code> 用于断线重连时恢复（客户端会记录 Last-Event-ID）</li>
<li><code>data:</code> 是实际数据，通常是 JSON 字符串</li>
</ul>
<h3 data-id="heading-8">2.2 核心挑战：粘包和半包问题</h3>
<p>这是 SSE 实现中最容易踩的坑。</p>
<p><strong>什么是粘包？</strong></p>
<pre><code class="hljs language-vbnet" lang="vbnet">服务器一次发送：
<span class="hljs-symbol">event:</span> message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"我"</span>}\n\nevent: message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"喜"</span>}\n\n

客户端可能收到：
<span class="hljs-symbol">event:</span> message
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"我"</span>}
<span class="hljs-symbol">event:</span> message    ← 两条消息粘在一起了
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"喜"</span>}
</code></pre>
<p><strong>什么是半包？</strong></p>
<pre><code class="hljs language-csharp" lang="csharp">服务器发送一条完整消息：
<span class="hljs-keyword">event</span>: message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"我是中文"</span>}\n\n

客户端可能分两次收到：
第一次：<span class="hljs-keyword">event</span>: message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>: <span class="hljs-string">"我
第二次：是中文"</span>}\n\n                              ← JSON 被截断了！
</code></pre>
<p><strong>解决方案</strong>：
维护一个 <code>buffer</code> 缓冲区，每次收到 chunk 后：</p>
<ol>
<li>追加到 buffer</li>
<li>按 <code>\n\n</code> 分割出完整消息</li>
<li>剩下的部分留在 buffer，等下次 chunk 到来</li>
</ol>
<hr/>
<h2 data-id="heading-9">篇章三：实战实现</h2>
<h3 data-id="heading-10">3.1 后端实现（Node.js + Express）</h3>
<p>先看后端怎么实现 SSE 接口：</p>
<pre><code class="hljs language-javascript" lang="javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/stream-sse'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-comment">// 设置 SSE 必需的 HTTP Headers</span>
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/event-stream'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Cache-Control'</span>, <span class="hljs-string">'no-cache, no-transform'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Connection'</span>, <span class="hljs-string">'keep-alive'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'X-Accel-Buffering'</span>, <span class="hljs-string">'no'</span>); <span class="hljs-comment">// 禁用 Nginx 缓冲</span>

  <span class="hljs-keyword">const</span> query = req.<span class="hljs-property">query</span>.<span class="hljs-property">query</span> || <span class="hljs-string">'默认问题'</span>;
  <span class="hljs-keyword">const</span> text = <span class="hljs-string">'这是 AI 的回复内容...'</span>;
  <span class="hljs-keyword">const</span> chars = text.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>);

  <span class="hljs-comment">// 逐字发送</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; chars.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-string">`event: message\nid: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>\ndata: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({
      type: <span class="hljs-string">'content'</span>,
      payload: chars[i],
      index: i,
      total: chars.length
    })}</span>\n\n`</span>;

    res.<span class="hljs-title function_">write</span>(message);

    <span class="hljs-comment">// 模拟 AI 生成延迟（打字机效果）</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>));
  }

  <span class="hljs-comment">// 发送完成信号</span>
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'event: close\ndata: [DONE]\n\n'</span>);
  res.<span class="hljs-title function_">end</span>();
});
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>Content-Type: text/event-stream</code> 告诉浏览器这是 SSE 流</li>
<li><code>Cache-Control: no-cache</code> 禁止缓存，确保实时性</li>
<li><code>Connection: keep-alive</code> 保持长连接</li>
<li>逐字符发送，模拟 AI 打字机效果</li>
<li>最后发送 <code>[DONE]</code> 信号告诉客户端流结束了</li>
</ul>
<h3 data-id="heading-11">3.2 JavaScript 客户端：手写 SSEManager</h3>
<p>这是核心部分。我们基于 <code>fetch + ReadableStream</code> 实现一个完整的 SSEManager：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SSEManager</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = {
      <span class="hljs-attr">headers</span>: {},
      <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">5</span>,
      <span class="hljs-attr">initialRetryDelay</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">enableRetry</span>: <span class="hljs-literal">true</span>,
      ...options
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onMessageCallback</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onCompleteCallback</span> = <span class="hljs-literal">null</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> fetchOptions = {
        <span class="hljs-attr">method</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">body</span> ? <span class="hljs-string">'POST'</span> : <span class="hljs-string">'GET'</span>,
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
          ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">headers</span>
        },
        <span class="hljs-attr">signal</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>.<span class="hljs-property">signal</span>
      };

      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">body</span>) {
        fetchOptions.<span class="hljs-property">body</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">body</span>);
      }

      <span class="hljs-comment">// 如果有 Last-Event-ID，带上（用于断线重连）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span>) {
        fetchOptions.<span class="hljs-property">headers</span>[<span class="hljs-string">'Last-Event-ID'</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span>;
      }

      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span>, fetchOptions);
      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.status}</span>: <span class="hljs-subst">${response.statusText}</span>`</span>);
      }

      <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();
      <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">'utf-8'</span>);

      <span class="hljs-comment">// 🔥 关键：消息缓冲区（处理粘包和半包）</span>
      <span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
        <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">const</span> chunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });
        buffer += chunk;

        <span class="hljs-comment">// 解析缓冲区中的完整消息</span>
        buffer = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_parseBuffer</span>(buffer);
      }

      <span class="hljs-comment">// 如果不是主动断开，尝试重连</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">enableRetry</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>.<span class="hljs-property">signal</span>.<span class="hljs-property">aborted</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_scheduleRetry</span>();
      }

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">'AbortError'</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onErrorCallback</span>(error);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">enableRetry</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">maxRetries</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_scheduleRetry</span>();
      }
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-comment">// 🔥 核心方法：解析缓冲区中的 SSE 消息</span>
  <span class="hljs-title function_">_parseBuffer</span>(<span class="hljs-params">buffer</span>) {
    <span class="hljs-keyword">const</span> lines = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n'</span>);
    <span class="hljs-keyword">let</span> currentEvent = { <span class="hljs-attr">event</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lines.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> line = lines[i];

      <span class="hljs-comment">// 空行表示一条消息结束</span>
      <span class="hljs-keyword">if</span> (line === <span class="hljs-string">''</span>) {
        <span class="hljs-keyword">if</span> (currentEvent.<span class="hljs-property">data</span> !== <span class="hljs-literal">null</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_handleEvent</span>(currentEvent);
          currentEvent = { <span class="hljs-attr">event</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };
        }
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-comment">// 解析字段</span>
      <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'event:'</span>)) {
        currentEvent.<span class="hljs-property">event</span> = line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">7</span>).<span class="hljs-title function_">trim</span>();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'id:'</span>)) {
        currentEvent.<span class="hljs-property">id</span> = line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">trim</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span> = currentEvent.<span class="hljs-property">id</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'data:'</span>)) {
        currentEvent.<span class="hljs-property">data</span> = line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">trim</span>();
      }
    }

    <span class="hljs-comment">// 返回未处理的缓冲区（最后一条不完整的消息）</span>
    <span class="hljs-keyword">return</span> lines[lines.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] === <span class="hljs-string">''</span> ? <span class="hljs-string">''</span> : lines[lines.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
  }

  <span class="hljs-title function_">_handleEvent</span>(<span class="hljs-params">event</span>) {
    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">event</span> === <span class="hljs-string">'close'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onCompleteCallback</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onCompleteCallback</span>();
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">event</span> === <span class="hljs-string">'error'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onErrorCallback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(event.<span class="hljs-property">data</span>));
      }
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onMessageCallback</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onMessageCallback</span>(data);
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Failed to parse SSE data:'</span>, e);
      }
    }
  }

  <span class="hljs-comment">// 🔥 指数退避重连算法</span>
  <span class="hljs-title function_">_scheduleRetry</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span>++;
    <span class="hljs-keyword">const</span> delay = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">initialRetryDelay</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span> - <span class="hljs-number">1</span>),
      <span class="hljs-number">30000</span> <span class="hljs-comment">// 最大 30 秒</span>
    );

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[SSE] Retry <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.retryCount}</span>/<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.options.maxRetries}</span> after <span class="hljs-subst">${delay}</span>ms`</span>);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">connect</span>();
    }, delay);
  }

  <span class="hljs-title function_">onMessage</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onMessageCallback</span> = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-title function_">onError</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span> = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-title function_">onComplete</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onCompleteCallback</span> = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-title function_">disconnect</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>.<span class="hljs-title function_">abort</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
  }
}
</code></pre>
<p><strong>使用示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> sse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSEManager</span>(<span class="hljs-string">'http://localhost:3000/stream-sse'</span>, {
  <span class="hljs-attr">body</span>: { <span class="hljs-attr">query</span>: <span class="hljs-string">'如何学好 Flutter？'</span> },
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer token123'</span> },
  <span class="hljs-attr">enableRetry</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">5</span>
});

sse.<span class="hljs-title function_">onMessage</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收到数据:'</span>, data.<span class="hljs-property">payload</span>);
  <span class="hljs-comment">// 逐字显示到界面上</span>
})
.<span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'发生错误:'</span>, error);
})
.<span class="hljs-title function_">onComplete</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'传输完成'</span>);
})
.<span class="hljs-title function_">connect</span>();
</code></pre>
<h3 data-id="heading-12">3.3 Dart 客户端：UTF-8 安全处理</h3>
<p>Dart 端有个特殊问题：<strong>中文字符的 UTF-8 编码问题</strong>。</p>
<p>中文字符在 UTF-8 中占 3 个字节，如果流正好把一个字符的 3 个字节截断了，就会出现乱码。</p>
<p><strong>解决方案</strong>：使用 <code>utf8.decoder</code> + <code>LineSplitter()</code> 的流转换链：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSEManager</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> url;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; headers;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; body;

  <span class="hljs-built_in">int</span> _retryCount = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">String?</span> _lastEventId;
  <span class="hljs-built_in">bool</span> _isConnecting = <span class="hljs-keyword">false</span>;

  SSEManager({
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.url,
    <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">const</span> {},
    <span class="hljs-keyword">this</span>.body = <span class="hljs-keyword">const</span> {},
  });

  Future&lt;<span class="hljs-keyword">void</span>&gt; connect() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">if</span> (_isConnecting) <span class="hljs-keyword">return</span>;
    _isConnecting = <span class="hljs-keyword">true</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> client = HttpClient();
      <span class="hljs-keyword">final</span> request = <span class="hljs-keyword">await</span> client.postUrl(<span class="hljs-built_in">Uri</span>.parse(url));

      <span class="hljs-comment">// 设置 Headers</span>
      headers.forEach((key, value) {
        request.headers.<span class="hljs-keyword">set</span>(key, value);
      });

      <span class="hljs-keyword">if</span> (_lastEventId != <span class="hljs-keyword">null</span>) {
        request.headers.<span class="hljs-keyword">set</span>(<span class="hljs-string">'Last-Event-ID'</span>, _lastEventId!);
      }

      <span class="hljs-comment">// 设置 Body</span>
      <span class="hljs-keyword">if</span> (body.isNotEmpty) {
        request.add(utf8.encode(jsonEncode(body)));
      }

      <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> request.close();

      <span class="hljs-comment">// 🔥 核心流转换链</span>
      response
        .transform(utf8.decoder)      <span class="hljs-comment">// ByteStream → String</span>
        .transform(<span class="hljs-keyword">const</span> LineSplitter()) <span class="hljs-comment">// String → Lines</span>
        .listen(_parseLine);

    } <span class="hljs-keyword">catch</span> (e) {
      _scheduleRetry();
    } <span class="hljs-keyword">finally</span> {
      _isConnecting = <span class="hljs-keyword">false</span>;
    }
  }

  <span class="hljs-keyword">void</span> _parseLine(<span class="hljs-built_in">String</span> line) {
    <span class="hljs-comment">// 解析 SSE 协议...</span>
    <span class="hljs-comment">// （类似 JS 版本的逻辑）</span>
  }

  <span class="hljs-keyword">void</span> _scheduleRetry() {
    _retryCount++;
    <span class="hljs-keyword">final</span> delay = min(<span class="hljs-number">1000</span> * pow(<span class="hljs-number">2</span>, _retryCount - <span class="hljs-number">1</span>), <span class="hljs-number">30000</span>).toInt();

    Future.delayed(<span class="hljs-built_in">Duration</span>(milliseconds: delay), () {
      connect();
    });
  }
}
</code></pre>
<h3 data-id="heading-13">3.4 实际运行效果</h3>
<p>让我们看看实际运行的效果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4315812aae0b446b91e1a6b39620f8a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=Fr9cdP%2FtL5NhR7Yi4MSfQ8J8%2BjM%3D" alt="主页面.png" loading="lazy"/></p>
<p><strong>传输中状态</strong>：</p>
<ul>
<li>AI 响应区域逐字显示</li>
<li>系统日志实时滚动</li>
<li>性能指标动态更新</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a53f9b73eab34675b8657fba557d01ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=mo3NStOjf2MHxs%2BYVqYtKdfpLG0%3D" alt="传输中.png" loading="lazy"/></p>
<p><strong>连接错误</strong>：</p>
<ul>
<li>当服务器未启动时，显示红色错误提示</li>
<li>自动触发重连机制</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9d6532dc08a4431a46e6816f2fa6d64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=oPwLNZQSJWj%2B2aYR4oUr9MrbEEk%3D" alt="连接错误.png" loading="lazy"/></p>
<p><strong>重试中状态</strong>：</p>
<ul>
<li>显示当前重试次数和延迟时间</li>
<li>使用指数退避算法（1s → 2s → 4s → 8s...）</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0852658ddf7d47da9bbabbddc984244a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=ALR1eFcv626oAutine4P7XHeuCE%3D" alt="重试中.png" loading="lazy"/></p>
<p><strong>传输完成</strong>：</p>
<ul>
<li>显示完整的输出内容</li>
<li>性能指标：总字数、总耗时、平均延迟</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb1ed7b22879466bb98f35a5108a12b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=AqunqCC4i34ldb65c6r5pnalff4%3D" alt="传输结束.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-14">篇章四：踩坑总结</h2>
<p>做这个 Demo 的过程中，我踩了不少坑。这里挑几个最经典的分享给你。</p>
<h3 data-id="heading-15">4.1 粘包/半包处理</h3>
<p><strong>坑</strong>：一开始我直接用 <code>split('\n\n')</code> 分割消息，结果经常出现 JSON 解析错误。</p>
<p><strong>原因</strong>：一个 chunk 可能包含半个 JSON，或者两条消息粘在一起。</p>
<p><strong>解决</strong>：维护 buffer，每次解析后把剩余部分留给下次：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>;
buffer += chunk;           <span class="hljs-comment">// 追加新数据</span>
<span class="hljs-keyword">const</span> messages = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n\n'</span>);
buffer = messages.<span class="hljs-title function_">pop</span>();   <span class="hljs-comment">// 保留最后一个（可能不完整）</span>
<span class="hljs-comment">// 处理前面的完整消息</span>
messages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> <span class="hljs-title function_">parseMessage</span>(msg));
</code></pre>
<h3 data-id="heading-16">4.2 UTF-8 字符截断</h3>
<p><strong>坑</strong>：Dart 端经常出现乱码，特别是中文字符。</p>
<p><strong>原因</strong>：中文字符在 UTF-8 中占 3 字节，流可能把 3 字节截断。</p>
<p><strong>解决</strong>：使用 <code>utf8.decoder</code> 自动处理字节边界：</p>
<pre><code class="hljs language-dart" lang="dart">response
  .transform(utf8.decoder)      <span class="hljs-comment">// ✅ 自动处理 UTF-8 边界</span>
  .transform(<span class="hljs-keyword">const</span> LineSplitter())
  .listen(_parseLine);
</code></pre>
<h3 data-id="heading-17">4.3 重连时机判断</h3>
<p><strong>坑</strong>：服务器正常结束时也触发重连，导致死循环。</p>
<p><strong>原因</strong>：没区分"正常结束"和"异常断开"。</p>
<p><strong>解决</strong>：检查 <code>[DONE]</code> 信号：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">_handleEvent</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">event</span> === <span class="hljs-string">'close'</span> &amp;&amp; event.<span class="hljs-property">data</span> === <span class="hljs-string">'[DONE]'</span>) {
    <span class="hljs-comment">// 正常结束，不重连</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onCompleteCallback</span>();
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-comment">// ... 其他处理</span>
}

<span class="hljs-comment">// 在流关闭时判断</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-comment">// 如果收到了 [DONE]，说明正常结束</span>
    <span class="hljs-keyword">if</span> (receivedDoneSignal) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 否则可能是异常断开，触发重连</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_scheduleRetry</span>();
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<h3 data-id="heading-18">4.4 Nginx 缓冲问题</h3>
<p><strong>坑</strong>：部署到生产环境后，SSE 流半天不输出。</p>
<p><strong>原因</strong>：Nginx 默认会缓冲响应，等积累到一定大小才发送。</p>
<p><strong>解决</strong>：在响应头添加 <code>X-Accel-Buffering: no</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'X-Accel-Buffering'</span>, <span class="hljs-string">'no'</span>);
</code></pre>
<p>或者在 Nginx 配置中：</p>
<pre><code class="hljs language-nginx" lang="nginx">proxy_buffering off;
</code></pre>
<hr/>
<h2 data-id="heading-19">最终章：总结与展望</h2>
<h3 data-id="heading-20">5.1 技术选型建议</h3>
<p><strong>什么时候用 SSE？</strong></p>
<ul>
<li>✅ AI 聊天助手（一问多答）</li>
<li>✅ 实时通知推送</li>
<li>✅ 股票/加密货币价格推送</li>
<li>✅ 服务器日志实时监控</li>
</ul>
<p><strong>什么时候用 WebSocket？</strong></p>
<ul>
<li>✅ 即时通讯（IM、聊天室）</li>
<li>✅ 在线协作（多人同时编辑）</li>
<li>✅ 游戏直播（需要高频双向交互）</li>
<li>✅ 远程桌面/控制</li>
</ul>
<h3 data-id="heading-21">5.2 本项目的核心特性</h3>
<p>我实现的这个 Demo，包含了以下生产级特性：</p>
<ul>
<li>✅ 支持 POST 请求（可以发送长 Prompt）</li>
<li>✅ 自定义 Header（支持 Authorization）</li>
<li>✅ 粘包/半包处理（buffer 缓冲区）</li>
<li>✅ 指数退避重连（1s → 2s → 4s → 8s...）</li>
<li>✅ Last-Event-ID 机制（断线续传）</li>
<li>✅ UTF-8 安全处理（Dart 端）</li>
<li>✅ 错误处理和日志</li>
</ul>
<h3 data-id="heading-22">5.3 开源地址</h3>
<p>项目已完全开源，欢迎 Star 和 PR：</p>
<p>🔗 <strong>GitHub</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Fsse-research-demo" target="_blank" title="https://github.com/xinqingaa/sse-research-demo" ref="nofollow noopener noreferrer">github.com/xinqingaa/s…</a></p>
<p>包含：</p>
<ul>
<li>Node.js 后端（Express）</li>
<li>JavaScript 客户端（原生 JS，无依赖）</li>
<li>Dart 客户端（Flutter 友好）</li>
<li>交互式演示界面</li>
</ul>
<h3 data-id="heading-23">5.4 写在最后</h3>
<p>回看这一周的学习，我发现：</p>
<p><strong>技术选型没有银弹</strong>。SSE 不是万能的，WebSocket 也不是过时的。关键是要理解你的场景需求。</p>
<p>对于 AI 聊天这种"一问多答"的单向流式场景，SSE 就像量身定做的一样：</p>
<ul>
<li>简单（基于 HTTP）</li>
<li>可靠（内置重连）</li>
<li>高效（没有全双工的开销）</li>
<li>可调试（DevTools 直接看）</li>
</ul>
<p>而 WebSocket 的强大在于<strong>双向实时交互</strong>，但这在 AI 聊天场景下是"杀鸡用牛刀"。</p>
<p><strong>最后，如果这篇文章对你有帮助，点个赞吧～</strong></p>
<p>（完）</p>
<hr/>
<h2 data-id="heading-24">往期文章回顾</h2>
<h3 data-id="heading-25">LangGraph + React + Nest 全栈Agent</h3>
<p><a href="https://juejin.cn/post/7601384029611868175" target="_blank" title="https://juejin.cn/post/7601384029611868175">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Faivista_agent" target="_blank" title="https://github.com/xinqingaa/aivista_agent" ref="nofollow noopener noreferrer">github</a></p>
<h3 data-id="heading-26">Flutter 图片编辑器</h3>
<p><a href="https://juejin.cn/post/7571067260053585946" target="_blank" title="https://juejin.cn/post/7571067260053585946">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fflutter_img_editor" target="_blank" title="https://pub.dev/packages/flutter_img_editor" ref="nofollow noopener noreferrer">pub.dev</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Fimage_editor" target="_blank" title="https://github.com/xinqingaa/image_editor" ref="nofollow noopener noreferrer">github</a></p>
<h3 data-id="heading-27">Flutter 全链路监控 SDK</h3>
<p><a href="https://juejin.cn/post/7564977973260173338" target="_blank" title="https://juejin.cn/post/7564977973260173338">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fflutter_monitor_sdk" target="_blank" title="https://pub.dev/packages/flutter_monitor_sdk" ref="nofollow noopener noreferrer">pub.dev</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Fflutter_monitor_sdk" target="_blank" title="https://github.com/xinqingaa/flutter_monitor_sdk" ref="nofollow noopener noreferrer">github</a></p>
<h3 data-id="heading-28">Flutter 全场景弹框组件</h3>
<p><a href="https://juejin.cn/post/7538324216594726950" target="_blank" title="https://juejin.cn/post/7538324216594726950">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Funified_popups" target="_blank" title="https://pub.dev/packages/unified_popups" ref="nofollow noopener noreferrer">pub.dev</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Funified_popups" target="_blank" title="https://github.com/xinqingaa/unified_popups" ref="nofollow noopener noreferrer">github</a></p>
<hr/>
<blockquote>
<p><strong>关于作者</strong></p>
<p>大家好，我是【小林】，一名 Flutter 开发工程师。近期在研究 AI Agent 和流式传输技术，欢迎关注我的掘金账号，获取更多技术分享。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让本地知识引导AI追踪社区变迁，让AI真正理解社会现象]]></title>    <link>https://juejin.cn/post/7603854784865746984</link>    <guid>https://juejin.cn/post/7603854784865746984</guid>    <pubDate>2026-02-09T02:40:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865746984" data-draft-id="7604045354070081570" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让本地知识引导AI追踪社区变迁，让AI真正理解社会现象"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2026-02-09T02:40:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让本地知识引导AI追踪社区变迁，让AI真正理解社会现象
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:40:21.000Z" title="Mon Feb 09 2026 02:40:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近有一项研究让我十分好奇，它似乎在尝试翻转我们熟悉的剧本——不是用人工智能去“分析”社区，而是让社区来“教会”人工智能如何看世界。这听起来像是一种充满温度的技术民主化实验。</p>
<p>通常，当我们谈论机器学习与城市变迁，总不免陷入一种略带冰冷的视角：算法扫描街景，识别模式，输出结论。但有没有可能，我们漏掉了故事里最关键的讲述者？那些在同一个街角目睹了数十年晨昏的居民，他们眼中的“变化”，是否才是定义变迁的真正标尺？</p>
<p>一项来自费城的研究正是这么做的。研究者没有将学术文献中的绅士化指标直接编码给AI，而是走进了社区的会议室，问了一个简单却深刻的问题：“在你们看来，什么样的新建筑，意味着‘他们’来了？”</p>
<p>答案具体而生动：“方方正正像个盒子”、“黑框大窗户”、“三层高，显得比老房子‘傲慢’”、“用了好多不同材质拼在一起”。这些来自日常观察的语言，成了机器学习模型最核心的“教材”。</p>
<p>于是，我们得以看到一种全新的协作：社区居民成为特征的“定义者”，历史街景图像成为厚重的“证据集”，而人工智能则充当了不知疲倦的“模式识别者”。它学习的不是抽象的理论，而是一个地方集体记忆与视觉经验的凝结。</p>
<p>这或许提醒我们，在面对技术尤其是AI时，我们并非只能被动接受它设定的框架。我们可以，也应该，将我们的地方知识、价值判断和生活经验，“反向编码”进技术的内核。 这不仅是让研究更“准”，或许也是让技术更“对”的一次尝试。</p>
<p>走在费城的某些街区，你可能会注意到一些“格格不入”的新建筑。它们线条方正、色调简约，窗户是巨大的黑色面板，在三层高的联排房屋中显得突兀。当地老居民会指着它们说：“看，这就是‘绅士化’来了。”</p>
<p>这不是一种主观感受，而正成为机器学习模型能够识别的视觉模式。一项发表于《PLoS One》的最新研究，尝试教AI识别美国城市中一种特定的绅士化现象——“新建绅士化”。与以往研究最大的不同在于，这次定义“何为绅士化特征”的，不是学者，而是生活在其中的社区居民。</p>
<h2 data-id="heading-0"><strong>问题：地图上的盲区</strong></h2>
<p>“绅士化”并非新词，它描述的是一个社区因富裕阶层迁入而发生的快速变迁。但传统研究多依赖人口普查数据（如收入、教育水平）或市政许可记录来描绘其图景。这些数据能告诉我们“谁来了”、“批了什么项目”，却难以回答一个更直观的问题：绅士化在街景中究竟长什么样？</p>
<p>更重要的是，绅士化的“长相”因地而异。在费城，涂鸦可能是社区艺术的表达，而非衰败的象征；即便是富裕社区，路边也可能有零散垃圾。若仅用“焕然一新”、“整洁美观”这类笼统标准去训练AI，很可能误读真正的社区脉络，甚至固化对贫困或投资的刻板印象。</p>
<p>于是，研究团队转向了那些最熟悉街道每寸变化的人。</p>
<h2 data-id="heading-1"><strong>方法：让社区定义“特征”</strong></h2>
<p>研究没有从理论或既有文献出发，而是走进了费城的三个街区：Port Richmond, Tacony, 和 Norris Square。在这里，他们组织了焦点小组，参与者多是居住数十年的中年女性，她们亲手打造社区花园，守护闲置空地，亲眼目睹了街角的每一次变迁。</p>
<p>讨论中，“新建绅士化”成为共识。与“经典绅士化”由个体修缮历史住宅不同，“新建绅士化”是开发商主导的大规模建设。用居民的话说，这些新楼就像“扎眼的拇指”，与周围环境截然不同。</p>
<p>从居民具体指认的街道和地标出发，研究团队结合历史街景图像，将“方盒子造型”、“黑色窗框”、“凸窗”、“混合建材”等具体建筑语言，提炼为一份识别清单（对应论文中表1）。这份清单，成了AI学习的“教材”。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c308f26ade3648cdb9501517b4c0a9c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=y%2BwqL5IKVEjkS9qs%2FxLIHANU%2F%2F4%3D" alt="screenshot_2026-02-06_15-36-17.png" loading="lazy"/></p>
<h2 data-id="heading-2"><strong>训练：给AI一双“社区之眼”</strong></h2>
<p>有了“教材”，下一步是准备“习题集”。团队从谷歌街景中获取了费城2009-2013年和2017-2021年两个时间段的170多万张全景图像。经过复杂的空间、时间和语义分割过滤（比如剔除车辆、植被遮挡过多的图片），他们最终手动审核出1040组成对的“前后”图像，并依据社区协议打上“变化”（即绅士化）或“无变化”的标签。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbc9f57823a046c8824d6f7535279238~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=YCUoxRT5lHTSJrGrjt7Q9mE0oGE%3D" alt="screenshot_2026-02-06_15-37-07.png" loading="lazy"/></p>
<p>这些图像对清晰地展示了变化：从空地或旧宅，变为具有现代简约风格、三层高、材质对比鲜明的新建筑（如图2示例）。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dbae095f5b241a2a33a0a2b297f6beb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=f%2BwP%2B5CcN8wmqtkCjaA%2FEP34COE%3D" alt="screenshot_2026-02-06_15-37-57.png" loading="lazy"/></p>
<p>随后，他们采用了一个名为Siamese ResNet-50的深度学习模型（其架构见图3）。这个模型的核心任务是比较同一地点的新旧两张图片，判断其间是否发生了符合“社区定义”的新建绅士化。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/abc44832f19a49d0a0869e3b6580df54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=u95ytBahCVW34ouAqwPFu2NXLWk%3D" alt="screenshot_2026-02-06_15-38-14.png" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>结果：AI学到了什么？</strong></h2>
<p>模型的表现超出了预期。在测试中，它的准确率和AUC（衡量区分能力的指标）都达到了84%。特别是它的“召回率”高达88%，意味着它能捕捉到绝大多数真实的绅士化案例。这证明，AI确实能从复杂的街景中，学会识别那些被社区居民共同指认的、具有地域特色的建筑特征（详细性能指标见表2，分类结果见图5）。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3bda9250dbbd423280680f1b18f08791~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=9UgPzKKIomz5optMxtThoVGHH6E%3D" alt="screenshot_2026-02-06_15-38-39.png" loading="lazy"/></p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44e484cbe60e412c81348b1cc77bddb7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=ahnCij%2BNOfQmHfhQgVrdxeSkoxg%3D" alt="screenshot_2026-02-06_15-38-57.png" loading="lazy"/></p>
<p>更有趣的是与市政许可数据的对比。团队将模型识别出的点位与费城新建许可数据制成热力图，两者在空间分布上呈现出高度相似的趋势：绅士化活动密集于Lower North Philadelphia、Riverwards及南费城等区域（对比结果见图4）。这交叉验证了模型发现的可信度。当然，也存在差异：许可数据显示某些工业区改造活跃，但街景图像却因过去是封闭厂区而缺乏历史影像；反之，一些视觉上翻天覆地的“内部全面翻新”，在许可分类上可能不算“新建”。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bee67271bde049a3b4e1f70a47f6cc89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=sVkaFh8BOkRYxBou2jlp1mUIe7g%3D" alt="screenshot_2026-02-06_15-39-45.png" loading="lazy"/></p>
<h2 data-id="heading-4"><strong>反思：技术的光与影</strong></h2>
<p>这项研究的价值，或许不在于创造了一个多高的准确率纪录。实际上，相比在独栋住宅为主的渥太华进行的研究（准确率95.6%），在建筑密集、视觉干扰多的费城取得84%的成绩，更显得珍贵。</p>
<p>它真正启示我们的是方法论：在运用“黑箱”AI处理复杂社会议题时，将定义问题的权力交还给切身相关的社区，是打开透明度和可信度的一把钥匙。 这避免了研究者的个人审美或偏见被无意中编码进算法，也让冰冷的图像识别，接续上了鲜活的地方性知识。</p>
<p>当然，局限同样明显。街景图像的可用性受制于拍摄时间、遮挡物（车辆、行人、天桥），这使得产出完整细致的绅士化地图仍然困难。AI模型可以成为一个强大的补充或预警工具，但在数据噪点极高的密集城区，短期内还难以完全取代传统的行政数据。</p>
<h2 data-id="heading-5"><strong>尾声：不止于地图</strong></h2>
<p>最终，这项研究绘制的不仅是一张绅士化潜力地图，更提供了一种思考城市变迁的新视角。当城市规划者、社区组织者和政策制定者试图理解绅士化、缓解其带来的 displacement （ displacement ）时，他们需要的不只是“哪里变了”，更是“什么变了”以及“这对当地人意味着什么”。</p>
<p>费城的实验表明，通过融合社区智慧与机器学习的敏锐，我们或许能更早地“看见”那些正在改变街区的力量，并以更贴近在地感受的方式，进行记录、讨论与应对。技术终究是工具，而定义城市未来的，永远是人。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 封装 Axios 实战：从基础到生产级，新手也能秒上手]]></title>    <link>https://juejin.cn/post/7603574149774049332</link>    <guid>https://juejin.cn/post/7603574149774049332</guid>    <pubDate>2026-02-07T03:16:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603574149774049332" data-draft-id="7603588665567412264" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 封装 Axios 实战：从基础到生产级，新手也能秒上手"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-07T03:16:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 封装 Axios 实战：从基础到生产级，新手也能秒上手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T03:16:14.000Z" title="Sat Feb 07 2026 03:16:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Vue3 项目开发中，Axios 是最常用的 HTTP 请求库，但直接在组件中裸写 Axios 会导致代码冗余、难以维护——比如每个请求都要写重复的 baseURL、请求头、错误处理，接口变更时要改遍所有组件。</p>
<p>而<strong>合理封装 Axios</strong> 能解决这些问题：统一管理请求配置、全局处理拦截器、标准化错误提示、支持取消重复请求……既能提升开发效率，又能让代码更健壮。</p>
<p>今天这篇文章，就带你从零实现 Vue3 + Vite 项目中 Axios 的<strong>生产级封装</strong>，从基础结构到进阶优化，每一步都有完整代码示例，直接复制就能用！适配 Vue3 组合式 API（
</p><h2 data-id="heading-0">一、前置准备：安装 Axios</h2>
<p>首先确保你的 Vue3 项目已搭建完成（推荐用 Vite 搭建），然后安装 Axios，TS 项目需额外安装类型声明：</p>
<pre><code class="hljs language-js" lang="js"># 安装核心 <span class="hljs-title class_">Axios</span> 库
npm install axios
# 可选：<span class="hljs-variable constant_">TS</span> 项目必装（提供类型提示，避免报错）
npm install @types/axios --save-dev
</code></pre>
<h2 data-id="heading-1">二、基础版封装：核心结构（新手友好）</h2>
<p>基础版封装聚焦「统一配置 + 简化调用」，适合小型项目或新手入门，核心实现 3 个功能：统一 baseURL、全局请求/响应拦截、简化请求调用。</p>
<p>封装步骤：在 src 目录下新建 <code>utils/request.js</code>（JS 项目）或 <code>utils/request.ts</code>（TS 项目），作为 Axios 封装的核心文件。</p>
<h3 data-id="heading-2">2.1 JS 版本（基础版）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.js</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span> <span class="hljs-comment">// 可选：结合UI库做错误提示（推荐）</span>

<span class="hljs-comment">// 1. 创建 Axios 实例，配置基础参数</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span>, <span class="hljs-comment">// 环境变量（推荐，区分开发/生产）</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 超时时间（单位：ms），超过则中断请求</span>
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span> <span class="hljs-comment">// 默认请求头</span>
  }
})

<span class="hljs-comment">// 2. 请求拦截器（请求发送前执行）</span>
<span class="hljs-comment">// 作用：添加token、统一修改请求参数格式等</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-comment">// 示例：添加token（登录后存储在localStorage，根据实际项目调整）</span>
    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token) {
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span> <span class="hljs-comment">// 拼接token格式（后端约定）</span>
    }
    <span class="hljs-keyword">return</span> config <span class="hljs-comment">// 必须返回config，否则请求会中断</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// 请求发送失败（如网络中断、参数错误）</span>
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error) <span class="hljs-comment">// 抛出错误，供组件捕获处理</span>
  }
)

<span class="hljs-comment">// 3. 响应拦截器（请求返回后执行，先于组件接收）</span>
<span class="hljs-comment">// 作用：统一处理响应数据、拦截错误（如token过期、接口报错）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-comment">// 只返回响应体中的data（多数后端接口会包裹一层code/message/data）</span>
    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span>

    <span class="hljs-comment">// 示例：根据后端约定的code判断请求是否成功（常见约定：200=成功）</span>
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) {
      <span class="hljs-comment">// 非200状态码，视为业务错误（如参数错误、权限不足）</span>
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'接口请求失败，请重试'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'请求失败'</span>))
    }
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span> <span class="hljs-comment">// 返回真正的业务数据，组件可直接使用</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// 响应失败（如超时、后端报错、404/500状态码）</span>
    <span class="hljs-keyword">let</span> errorMsg = <span class="hljs-string">'请求异常，请联系管理员'</span>
    <span class="hljs-comment">// 区分不同错误类型，给出更精准提示</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-comment">// 有响应，但状态码非2xx（如401token过期、404接口不存在、500后端报错）</span>
      <span class="hljs-keyword">switch</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
          errorMsg = <span class="hljs-string">'登录已过期，请重新登录'</span>
          <span class="hljs-comment">// 额外操作：清除过期token，跳转到登录页（结合Vue Router）</span>
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'token'</span>)
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:
          errorMsg = <span class="hljs-string">'请求的接口不存在'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:
          errorMsg = <span class="hljs-string">'后端服务异常，请稍后重试'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-attr">default</span>:
          errorMsg = error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>?.<span class="hljs-property">message</span> || errorMsg
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      <span class="hljs-comment">// 无响应（如网络中断、超时）</span>
      errorMsg = <span class="hljs-string">'网络异常或请求超时，请检查网络'</span>
    }
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(errorMsg)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 4. 封装常用请求方法（get/post/put/delete），简化组件调用</span>
<span class="hljs-comment">// get请求：params传参（拼接在URL后）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">get</span> = (<span class="hljs-params">url, params = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
    params
  })
}

<span class="hljs-comment">// post请求：data传参（请求体中）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">post</span> = (<span class="hljs-params">url, data = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
    data
  })
}

<span class="hljs-comment">// put请求（修改数据）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">put</span> = (<span class="hljs-params">url, data = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'put'</span>,
    data
  })
}

<span class="hljs-comment">// delete请求（删除数据）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">del</span> = (<span class="hljs-params">url, params = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'delete'</span>,
    params
  })
}

<span class="hljs-comment">// 导出Axios实例（特殊场景可直接使用，如取消请求）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service
</code></pre>
<h3 data-id="heading-3">2.2 TS 版本（基础版，补充类型提示）</h3>
<p>TS 项目需添加类型声明，避免类型报错，提升开发体验，核心修改的是「请求/响应类型」和「参数类型」：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.ts</span>
<span class="hljs-keyword">import</span> axios, { <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span>, <span class="hljs-title class_">AxiosError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-comment">// 定义后端响应的统一格式（根据你的后端接口调整）</span>
interface <span class="hljs-title class_">ResponseData</span>&lt;T = any&gt; {
  <span class="hljs-attr">code</span>: number
  <span class="hljs-attr">message</span>: string
  <span class="hljs-attr">data</span>: T
}

<span class="hljs-comment">// 1. 创建Axios实例</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span>
  }
})

<span class="hljs-comment">// 2. 请求拦截器</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token &amp;&amp; config.<span class="hljs-property">headers</span>) {
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
    }
    <span class="hljs-keyword">return</span> config
  },
  <span class="hljs-function">(<span class="hljs-params">error: AxiosError</span>) =&gt;</span> {
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 3. 响应拦截器</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response: AxiosResponse&lt;ResponseData&gt;</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span>
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) {
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'接口请求失败，请重试'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'请求失败'</span>))
    }
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span> <span class="hljs-comment">// 返回业务数据，自动推导类型</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error: AxiosError&lt;ResponseData&gt;</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> errorMsg = <span class="hljs-string">'请求异常，请联系管理员'</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-keyword">const</span> status = error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>
      <span class="hljs-keyword">switch</span> (status) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
          errorMsg = <span class="hljs-string">'登录已过期，请重新登录'</span>
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'token'</span>)
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:
          errorMsg = <span class="hljs-string">'请求的接口不存在'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:
          errorMsg = <span class="hljs-string">'后端服务异常，请稍后重试'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-attr">default</span>:
          errorMsg = error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>?.<span class="hljs-property">message</span> || errorMsg
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      errorMsg = <span class="hljs-string">'网络异常或请求超时，请检查网络'</span>
    }
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(errorMsg)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 4. 封装请求方法，添加类型声明</span>
<span class="hljs-comment">// get请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> get = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, params?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
    params,
    ...config
  })
}

<span class="hljs-comment">// post请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> post = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, data?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
    data,
    ...config
  })
}

<span class="hljs-comment">// put请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> put = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, data?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'put'</span>,
    data,
    ...config
  })
}

<span class="hljs-comment">// delete请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> del = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, params?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'delete'</span>,
    params,
    ...config
  })
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service
</code></pre>
<h3 data-id="heading-4">2.3 环境变量配置（关键步骤）</h3>
<p>上面封装中用到的<code>import.meta.env.VITE_API_BASE_URL</code>，是 Vite 的环境变量，用于区分「开发环境」和「生产环境」的接口地址，避免手动修改。</p>
<p>在项目根目录新建 2 个文件：<code>.env.development</code>（开发环境）和 <code>.env.production</code>（生产环境）：</p>
<pre><code class="hljs language-js" lang="js"># .<span class="hljs-property">env</span>.<span class="hljs-property">development</span>（开发环境，npm run dev 时生效）
<span class="hljs-variable constant_">VITE_API_BASE_URL</span> = <span class="hljs-string">'http://localhost:3000/api'</span> # 本地后端接口地址

# .<span class="hljs-property">env</span>.<span class="hljs-property">production</span>（生产环境，npm run build 时生效）
<span class="hljs-variable constant_">VITE_API_BASE_URL</span> = <span class="hljs-string">'https://api.yourdomain.com'</span> # 线上后端接口地址
</code></pre>
<p>注意：Vite 环境变量必须以<code>VITE_</code> 开头，否则无法读取。</p>
<h3 data-id="heading-5">2.4 组件中如何使用（简化调用）</h3>
<p>封装完成后，在 Vue3 组件（支持 
</p><pre><code class="hljs language-js" lang="js">&lt;script setup&gt;
<span class="hljs-comment">// 导入封装好的请求方法</span>
<span class="hljs-keyword">import</span> { get, post } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>
<span class="hljs-keyword">import</span> { ref, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> userList = <span class="hljs-title function_">ref</span>([])

<span class="hljs-comment">// 1. get请求（获取用户列表，params传参）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 直接调用，无需写baseURL、请求头</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">'/user/list'</span>, { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> })
    userList.<span class="hljs-property">value</span> = res <span class="hljs-comment">// 直接使用响应数据（已过滤外层code/message）</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 可选：组件内单独处理错误（全局已处理过，这里可省略）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取用户列表失败：'</span>, error)
  }
}

<span class="hljs-comment">// 2. post请求（提交表单，data传参）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">submitForm</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">formData</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">'/user/add'</span>, formData)
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'提交成功'</span>)
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 无需额外提示，全局响应拦截器已做错误提示</span>
  }
}

<span class="hljs-comment">// 页面挂载时调用get请求</span>
<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">getUserList</span>()
})
&lt;/script&gt;
</code></pre>
<p>对比裸写 Axios，封装后的调用更简洁，且所有请求的配置、错误处理都统一管理，后续修改接口地址、token 格式，只需改 <code>request.js/ts</code> 一个文件。</p>
<h2 data-id="heading-6">三、进阶版封装：生产级优化（必看）</h2>
<p>基础版封装能满足小型项目，但在中大型项目中，还需要补充「取消重复请求、请求loading、接口加密、异常重试」等功能，让封装更健壮、更贴合生产需求。</p>
<h3 data-id="heading-7">3.1 优化1：取消重复请求（避免接口冗余）</h3>
<p>场景：用户快速点击两次按钮，会发起两次相同的请求（如提交表单），导致后端重复处理。解决方案：用 Axios 的 CancelToken（Axios 0.x）或 AbortController（Axios 1.x+）取消重复请求。</p>
<p>以下是 Axios 1.x+ 版本（当前最新版）的实现方式（AbortController 更规范）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.js（仅修改新增部分，其余代码不变）</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-comment">// 存储正在请求的接口（key：请求标识，value：AbortController实例）</span>
<span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()

<span class="hljs-comment">// 生成请求标识（url + method + 参数，确保唯一）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">generateRequestKey</span> = (<span class="hljs-params">config</span>) =&gt; {
  <span class="hljs-keyword">const</span> { url, method, params, data } = config
  <span class="hljs-comment">// 序列化参数，避免相同请求因参数顺序不同被误判为不同请求</span>
  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params || {})
  <span class="hljs-keyword">const</span> dataStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data || {})
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${url}</span>-<span class="hljs-subst">${method}</span>-<span class="hljs-subst">${paramsStr}</span>-<span class="hljs-subst">${dataStr}</span>`</span>
}

<span class="hljs-comment">// 取消重复请求</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">cancelPendingRequest</span> = (<span class="hljs-params">config</span>) =&gt; {
  <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(config)
  <span class="hljs-comment">// 如果有重复请求，取消之前的</span>
  <span class="hljs-keyword">if</span> (pendingRequests.<span class="hljs-title function_">has</span>(requestKey)) {
    <span class="hljs-keyword">const</span> controller = pendingRequests.<span class="hljs-title function_">get</span>(requestKey)
    controller.<span class="hljs-title function_">abort</span>() <span class="hljs-comment">// 取消请求</span>
    pendingRequests.<span class="hljs-title function_">delete</span>(requestKey) <span class="hljs-comment">// 移除取消的请求</span>
  }
}

<span class="hljs-comment">// 1. 创建Axios实例（新增signal配置）</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span>
  }
})

<span class="hljs-comment">// 2. 请求拦截器（修改：添加取消重复请求逻辑）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-comment">// 取消重复请求（发起当前请求前，取消之前相同的请求）</span>
    <span class="hljs-title function_">cancelPendingRequest</span>(config)
    <span class="hljs-comment">// 创建AbortController实例，用于取消请求</span>
    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>()
    config.<span class="hljs-property">signal</span> = controller.<span class="hljs-property">signal</span>
    <span class="hljs-comment">// 存储当前请求</span>
    <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(config)
    pendingRequests.<span class="hljs-title function_">set</span>(requestKey, controller)
    
    <span class="hljs-comment">// 添加token（原有逻辑不变）</span>
    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token) {
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
    }
    <span class="hljs-keyword">return</span> config
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 3. 响应拦截器（修改：移除已完成的请求）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> config = response.<span class="hljs-property">config</span>
    <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(config)
    pendingRequests.<span class="hljs-title function_">delete</span>(requestKey) <span class="hljs-comment">// 请求完成，移除存储</span>
    
    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span>
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) {
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'接口请求失败，请重试'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'请求失败'</span>))
    }
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// 处理取消请求的错误（单独捕获，不提示用户）</span>
    <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(error)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'请求已取消：'</span>, error.<span class="hljs-property">message</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'请求已取消'</span>))
    }
    
    <span class="hljs-comment">// 移除失败的请求</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">config</span>) {
      <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(error.<span class="hljs-property">config</span>)
      pendingRequests.<span class="hljs-title function_">delete</span>(requestKey)
    }
    
    <span class="hljs-comment">// 原有错误处理逻辑不变</span>
    <span class="hljs-keyword">let</span> errorMsg = <span class="hljs-string">'请求异常，请联系管理员'</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-comment">// ... 原有状态码判断逻辑</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      errorMsg = <span class="hljs-string">'网络异常或请求超时，请检查网络'</span>
    }
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(errorMsg)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 4. 封装请求方法（不变）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">get</span> = (<span class="hljs-params">url, params = {}</span>) =&gt; { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">post</span> = (<span class="hljs-params">url, data = {}</span>) =&gt; { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-comment">// ... 其余方法</span>
</code></pre>
<h3 data-id="heading-8">3.2 优化2：全局请求 Loading（提升交互体验）</h3>
<p>场景：请求耗时较长时，用户不知道是否在加载，容易重复点击。解决方案：添加全局 Loading，所有请求发起时显示 Loading，全部请求完成后隐藏。</p>
<p>结合 Element Plus 的 ElLoading 实现（需安装 Element Plus）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.js（新增Loading相关逻辑）</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span>, <span class="hljs-title class_">ElLoading</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-comment">// 新增：Loading实例和请求计数</span>
<span class="hljs-keyword">let</span> loadingInstance = <span class="hljs-literal">null</span> <span class="hljs-comment">// Loading实例</span>
<span class="hljs-keyword">let</span> requestCount = <span class="hljs-number">0</span> <span class="hljs-comment">// 请求计数器（避免多个请求重复显示/隐藏Loading）</span>

<span class="hljs-comment">// 显示Loading</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">showLoading</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">if</span> (requestCount === <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 只有当没有请求时，才显示Loading</span>
    loadingInstance = <span class="hljs-title class_">ElLoading</span>.<span class="hljs-title function_">service</span>({
      <span class="hljs-attr">lock</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">text</span>: <span class="hljs-string">'加载中...'</span>,
      <span class="hljs-attr">background</span>: <span class="hljs-string">'rgba(0, 0, 0, 0.5)'</span>
    })
  }
  requestCount++
}

<span class="hljs-comment">// 隐藏Loading</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">hideLoading</span> = (<span class="hljs-params"/>) =&gt; {
  requestCount--
  <span class="hljs-keyword">if</span> (requestCount === <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 所有请求完成后，才隐藏Loading</span>
    loadingInstance?.<span class="hljs-title function_">close</span>()
  }
}

<span class="hljs-comment">// 1. 创建Axios实例（不变）</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({ <span class="hljs-comment">/* ... */</span> })

<span class="hljs-comment">// 2. 请求拦截器（新增：显示Loading）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-title function_">showLoading</span>() <span class="hljs-comment">// 发起请求时显示Loading</span>
    <span class="hljs-comment">// ... 原有取消重复请求、添加token逻辑</span>
    <span class="hljs-keyword">return</span> config
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-title function_">hideLoading</span>() <span class="hljs-comment">// 请求失败，隐藏Loading</span>
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 3. 响应拦截器（新增：隐藏Loading）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-title function_">hideLoading</span>() <span class="hljs-comment">// 请求成功，隐藏Loading</span>
    <span class="hljs-comment">// ... 原有移除重复请求、处理响应逻辑</span>
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-title function_">hideLoading</span>() <span class="hljs-comment">// 响应失败，隐藏Loading</span>
    <span class="hljs-comment">// ... 原有错误处理逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)
</code></pre>
<p>注意：requestCount 计数器是关键，避免多个请求同时发起时，单个请求完成就隐藏 Loading。</p>
<h3 data-id="heading-9">3.3 优化3：接口模块化管理（中大型项目必做）</h3>
<p>场景：项目接口较多时，所有请求都写在组件中，会导致代码混乱，后续维护困难。解决方案：将接口按模块拆分，统一管理在 <code>api</code> 文件夹中。</p>
<p>步骤：在 src 目录下新建<code>api</code> 文件夹，按业务模块拆分文件（如 <code>api/user.js</code>、<code>api/goods.js</code>）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/api/user.js（用户模块接口）</span>
<span class="hljs-keyword">import</span> { get, post, put, del } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>

<span class="hljs-comment">// 接口模块化封装，每个接口对应一个函数</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> userApi = {
  <span class="hljs-comment">// 获取用户列表</span>
  <span class="hljs-attr">getUserList</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">'/user/list'</span>, params),
  <span class="hljs-comment">// 添加用户</span>
  <span class="hljs-attr">addUser</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">'/user/add'</span>, data),
  <span class="hljs-comment">// 修改用户信息</span>
  <span class="hljs-attr">editUser</span>: <span class="hljs-function">(<span class="hljs-params">id, data</span>) =&gt;</span> <span class="hljs-title function_">put</span>(<span class="hljs-string">`/user/<span class="hljs-subst">${id}</span>`</span>, data),
  <span class="hljs-comment">// 删除用户</span>
  <span class="hljs-attr">deleteUser</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-title function_">del</span>(<span class="hljs-string">'/user/delete'</span>, { id }),
  <span class="hljs-comment">// 用户登录</span>
  <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">'/user/login'</span>, data)
}

<span class="hljs-comment">// src/api/goods.js（商品模块接口）</span>
<span class="hljs-keyword">import</span> { get, post } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> goodsApi = {
  <span class="hljs-comment">// 获取商品详情</span>
  <span class="hljs-attr">getGoodsDetail</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">`/goods/<span class="hljs-subst">${id}</span>`</span>),
  <span class="hljs-comment">// 搜索商品</span>
  <span class="hljs-attr">searchGoods</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">'/goods/search'</span>, params)
}
</code></pre>
<p>组件中使用时，直接导入对应模块的接口，代码更清晰、更易维护：</p>
<pre><code class="hljs language-js" lang="js">&lt;script setup&gt;
<span class="hljs-comment">// 导入用户模块接口</span>
<span class="hljs-keyword">import</span> { userApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/user'</span>
<span class="hljs-keyword">import</span> { ref, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> userList = <span class="hljs-title function_">ref</span>([])

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 直接调用接口函数，参数清晰</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> userApi.<span class="hljs-title function_">getUserList</span>({ <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> })
    userList.<span class="hljs-property">value</span> = res
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)
  }
}

<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">getUserList</span>()
})
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-10">3.4 其他生产级优化（可选，按需添加）</h3>
<ol>
<li><strong>请求重试</strong>：针对网络波动导致的请求失败，自动重试 1-2 次（避免用户手动重试），用 axios-retry 插件实现。</li>
<li><strong>请求加密</strong>：敏感接口（如登录、支付）的参数加密（如 AES 加密），在请求拦截器中处理参数加密。</li>
<li><strong>接口日志</strong>：开发环境打印请求/响应日志（便于调试），生产环境关闭日志（避免泄露敏感信息）。</li>
<li><strong>自定义请求头</strong>：支持部分接口单独设置请求头（如文件上传接口设置 Content-Type: multipart/form-data）。</li>
</ol>
<h2 data-id="heading-11">四、避坑指南（新手必看）</h2>
<ol>
<li><strong>环境变量读取失败</strong>：Vite 环境变量必须以 <code>VITE_</code> 开头，且只能在客户端代码中读取，不能在服务端代码中使用。</li>
<li><strong>token 失效未跳转</strong>：确保响应拦截器中 401 状态码的判断逻辑正确，且 <code>window.location.href = '/login'</code> 没有被注释，同时检查 token 是否正确存储/清除。</li>
<li><strong>重复请求取消无效</strong>：请求标识（requestKey）必须唯一，确保 params 和 data 被正确序列化（避免因参数顺序不同导致标识不同）。</li>
<li><strong>Loading 闪烁</strong>：请求耗时过短（如 100ms 内完成），会导致 Loading 一闪而过，可添加 Loading 延迟显示（如 300ms 后显示，避免闪烁）。</li>
<li><strong>TS 类型报错</strong>：确保后端响应格式和定义的 <code>ResponseData</code> 接口一致，否则会出现类型不匹配报错。</li>
<li><strong>文件上传接口失败</strong>：文件上传接口需单独设置请求头 <code>'Content-Type': 'multipart/form-data'</code>，且传参用 FormData 格式。</li>
</ol>
<h2 data-id="heading-12">五、总结</h2>
<p>Vue3 封装 Axios 的核心是「统一管理 + 简化调用 + 异常处理」，从基础版的拦截器封装，到进阶版的重复请求取消、Loading 优化、接口模块化，一步步提升封装的健壮性和实用性。</p>
<p>总结几个关键要点：</p>
<ul>
<li>用 <code>axios.create()</code> 创建实例，统一配置 baseURL、超时时间等。</li>
<li>请求拦截器：添加 token、取消重复请求、显示 Loading。</li>
<li>响应拦截器：统一处理响应数据、拦截错误（token 过期、404/500）、隐藏 Loading。</li>
<li>中大型项目：接口按模块拆分，提升代码可维护性。</li>
<li>生产环境：补充取消重复请求、请求加密等优化，让封装更健壮。</li>
</ul>
<p>封装完成后，后续开发只需专注于业务逻辑，无需关注请求的底层配置，极大提升开发效率。本文的封装方案适配绝大多数 Vue3 项目，大家可根据自己的后端接口规范和业务需求，灵活调整拦截器逻辑和接口格式。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零实现富文本编辑器#11-Immutable状态维护与增量渲染]]></title>    <link>https://juejin.cn/post/7604084016510353449</link>    <guid>https://juejin.cn/post/7604084016510353449</guid>    <pubDate>2026-02-09T02:48:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510353449" data-draft-id="7603895839557419071" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从零实现富文本编辑器#11-Immutable状态维护与增量渲染"/> <meta itemprop="keywords" content="前端,架构,前端框架"/> <meta itemprop="datePublished" content="2026-02-09T02:48:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="WindRunnerMax"/> <meta itemprop="url" content="https://juejin.cn/user/1829999989247214"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从零实现富文本编辑器#11-Immutable状态维护与增量渲染
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1829999989247214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    WindRunnerMax
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:48:19.000Z" title="Mon Feb 09 2026 02:48:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在先前我们讨论了视图层的适配器设计，主要是全量的视图初始化渲染，包括生命周期同步、状态管理、渲染模式、<code>DOM</code>映射状态等。在这里我们需要处理变更的增量更新，这属于性能方面的考量，需要考虑如何实现不可变的状态对象，以此来实现<code>Op</code>操作以及最小化<code>DOM</code>变更。</p>
<ul>
<li>开源地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWindRunnerMax%2FBlockKit" target="_blank" title="https://github.com/WindRunnerMax/BlockKit" ref="nofollow noopener noreferrer">github.com/WindRunnerM…</a></li>
<li>在线编辑: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwindrunnermax.github.io%2FBlockKit%2F" target="_blank" title="https://windrunnermax.github.io/BlockKit/" ref="nofollow noopener noreferrer">windrunnermax.github.io/BlockKit/</a></li>
<li>项目笔记: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWindRunnerMax%2FBlockKit%2Fblob%2Fmaster%2FNOTE.md" target="_blank" title="https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md" ref="nofollow noopener noreferrer">github.com/WindRunnerM…</a></li>
</ul>
<details>
<summary><strong>从零实现富文本编辑器系列文章</strong></summary>
<ul>
<li><a href="https://juejin.cn/post/7490554094412611636" target="_blank" title="https://juejin.cn/post/7490554094412611636">深感一无所长，准备试着从零开始写个富文本编辑器</a></li>
<li><a href="https://juejin.cn/post/7492339631700377652" target="_blank" title="https://juejin.cn/post/7492339631700377652">从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计</a></li>
<li><a href="https://juejin.cn/post/7494920513967112227" target="_blank" title="https://juejin.cn/post/7494920513967112227">从零实现富文本编辑器#3-基于Delta的线性数据结构模型</a></li>
<li><a href="https://juejin.cn/post/7508648111485665295" target="_blank" title="https://juejin.cn/post/7508648111485665295">从零实现富文本编辑器#4-浏览器选区模型的核心交互策略</a></li>
<li><a href="https://juejin.cn/post/7513183180091523107" target="_blank" title="https://juejin.cn/post/7513183180091523107">从零实现富文本编辑器#5-编辑器选区模型的状态结构表达</a></li>
<li><a href="https://juejin.cn/post/7534162607894347828" target="_blank" title="https://juejin.cn/post/7534162607894347828">从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步</a></li>
<li><a href="https://juejin.cn/post/7544561402783793192" target="_blank" title="https://juejin.cn/post/7544561402783793192">从零实现富文本编辑器#7-基于组合事件的半受控输入模式</a></li>
<li><a href="https://juejin.cn/post/7562526517516812331" target="_blank" title="https://juejin.cn/post/7562526517516812331">从零实现富文本编辑器#8-浏览器输入模式的非受控DOM行为</a></li>
<li><a href="https://juejin.cn/spost/7585778343352221759" target="_blank" title="https://juejin.cn/spost/7585778343352221759">从零实现富文本编辑器#9-编辑器文本结构变更的受控处理</a></li>
<li><a href="https://juejin.cn/spost/7593702885880725540" target="_blank" title="https://juejin.cn/spost/7593702885880725540">从零实现富文本编辑器#10-React视图层适配器的模式扩展</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">从零实现富文本编辑器#11-Immutable状态维护与增量渲染</a></li>
</ul>
</details>
<h2 data-id="heading-0">行级不可变状态</h2>
<p>在这里我们先不引入视图层的渲染问题，而是仅在<code>Model</code>层面上实现精细化的处理，具体来说就是实现不可变的状态对象，仅更新的节点才会被重新创建，其他节点则直接复用。由此想来此模块的实现颇为复杂，也并未引入<code>immer</code>等框架，而是直接处理的状态对象，因此先从简单的更新模式开始考虑。</p>
<p>回到最开始实现的<code>State</code>模块更新文档内容，我们是直接重建了所有的<code>LineState</code>以及<code>LeafState</code>对象，然后在<code>React</code>视图层的<code>BlockModel</code>中监听了<code>OnContentChange</code>事件，以此来将<code>BlockState</code>的更新应用到视图层。</p>
<pre><code class="hljs language-js" lang="js">delta.<span class="hljs-title function_">eachLine</span>(<span class="hljs-function">(<span class="hljs-params">line, attributes, index</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> lineState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineState</span>(line, attributes, <span class="hljs-variable language_">this</span>);
  lineState.<span class="hljs-property">index</span> = index;
  lineState.<span class="hljs-property">start</span> = offset;
  lineState.<span class="hljs-property">key</span> = <span class="hljs-title class_">Key</span>.<span class="hljs-title function_">getId</span>(lineState);
  offset = offset + lineState.<span class="hljs-property">length</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lines</span>[index] = lineState;
});
</code></pre>
<p>这种方式简单直接，全量更新状态能够保证在<code>React</code>的状态更新，然而这种方式的问题在于性能。当文档内容非常大的时候，全量计算将会导致大量的状态重建，并且其本身的改变也会导致<code>React</code>的<code>diff</code>差异进而全量更新文档视图，这样的性能开销通常是不可接受的。</p>
<p>那么通常来说我们就需要基于变更来确定状态的更新，首先我们需要确定更新的粒度，例如以行为基准则未变更的时候就直接取原有的<code>LineState</code>。相当于尽可能复用<code>Origin List</code>然后生成<code>Target List</code>，这样的方式自然可以避免部分状态的重建，尽可能复用原本的对象。</p>
<p>整体思路大概是先执行变成生成最新的列表，然后分别设置旧列表和新列表的<code>row</code>和<code>col</code>两个指针值，然后更新时记录起始<code>row</code>，删除和新增自然是正常处理，对于更新则认为是先删后增。对于内容的处理则需要分别讨论单行和跨行的问题，中间部分的内容就作为重建的操作。</p>
<p>最后可以将这部分增删<code>LineState</code>数据放置于<code>Changes</code>中，就可以得到实际增删的<code>Ops</code>了，这样我们就可以优化部分的性能，因为仅原列表和目标列表的中间部分才会重建，其他部分的行状态直接复用。此外这部分数据在<code>apply</code>的<code>delta</code>中是不存在的，同样可以认为是数据的补充。</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-title class_">Origin</span> <span class="hljs-title class_">List</span> (<span class="hljs-title class_">Old</span>)                          <span class="hljs-title class_">Target</span> <span class="hljs-title class_">List</span> (<span class="hljs-title class_">New</span>)
+-------------------+                      +-------------------+
| [<span class="hljs-number">0</span>] <span class="hljs-title class_">LineState</span> A   | &lt;---- Retain ------&gt; | [0] LineState A   | (Reused)
+-------------------+                      +-------------------+
| [1] LineState B   |          |           | [1] LineState B2  | (Update)
+-------------------+       Changes        |     (Modified)    | (Del C)
| [2] LineState C   |          |           +-------------------+
+-------------------+          V           | [2] NewState X    | (Inserted)
| [3] LineState D   | ---------------\     +-------------------+
+-------------------+                 --&gt; | [3] LineState D   | (Reused)
| [4] LineState E   | &lt;---- Retain ------&gt; | [4] LineState E   | (Reused)
+-------------------+                      +-------------------+
</code></pre>
<p>那么这里实际上是存在非常需要关注的点，我们现在维护的是状态模型，也就是说所有的更新就不再是直接的<code>compose</code>，而是操作我们实现的状态对象。本质上我们是需要实现行级别的<code>compose</code>方法，这里的实现非常重要，假如我们对于数据的处理存在偏差的话，那么就会导致状态出现问题。</p>
<p>此外在这种方式中，我们判断<code>LineState</code>是否需要新建则是根据整个行内的所有<code>LeafState</code>来重建的。也就是说这种时候我们是需要再次将所有的<code>op</code>遍历一遍，当然实际上由于最后还需要将<code>compose</code>后的<code>Delta</code>切割为行级别的内容，所以其实即使在应用变更后也最少需要再遍历两次。</p>
<p>那么此时我们需要思考优化方向，首先是首个<code>retain</code>，在这里我们应该直接完整复用原本的<code>LineState</code>，包括处理后的剩余节点也是如此。而对于中间的节点，我们就需要为其独立设计更新策略，这部分理论上来说是需要完全独立处理为新的状态对象的，这样可以减少部分<code>Leaf Op</code>的遍历。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Delta</span>().<span class="hljs-title function_">retain</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">insert</span>(<span class="hljs-string">"xx"</span>)
<span class="hljs-title function_">insert</span>(<span class="hljs-string">"123"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>) <span class="hljs-comment">// skip </span>
<span class="hljs-title function_">insert</span>(<span class="hljs-string">"456"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>) <span class="hljs-comment">// new line state</span>
</code></pre>
<p>其中，如果是新建的节点，我们直接构建新的<code>LineState</code>即可，删除的节点则不从原本的<code>LineState</code>中放置于新的列表。而对于更新的节点，我们需要更新原本的<code>LineState</code>对象，因为实际上行是存在更新的，而重点是我们需要将原本的<code>LineState</code>的<code>key</code>值复用。</p>
<p>这里我们先简单实现实现描述一下复用的问题，比较方便的实现则是直接以<code>\n</code>的标识为目标的<code>State</code>，这就意味着我们要独立<code>\n</code>为独立的状态。即如果在<code>123|456\n</code>的<code>|</code>位置插入<code>\n</code>的话，那么我们就是<code>123</code>是新的<code>LineState</code>，<code>456</code>是原本的<code>LineState</code>，以此来实现<code>key</code>的复用。</p>
<pre><code class="hljs language-js" lang="js">[
  <span class="hljs-title function_">insert</span>(<span class="hljs-string">"123"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>), 
  <span class="hljs-title function_">insert</span>(<span class="hljs-string">"456"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>)
]
<span class="hljs-comment">// ===&gt;</span>
[ 
  <span class="hljs-title class_">LineState</span>(<span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"123"</span>), <span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"\n"</span>)), 
  <span class="hljs-title class_">LineState</span>(<span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"456"</span>), <span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"\n"</span>))
]
</code></pre>
<p>其实这里有个非常值得关注的点是，<code>LineState</code>在<code>Delta</code>中是没有具体对应的<code>Op</code>的，而相对应的<code>LeafState</code>则是有具体的<code>Op</code>的。这就意味着我们在处理<code>LineState</code>的更新时，是不能直接根据变更控制的，因此必须要找到能够映射的状态，因此最简单的方案即根据<code>\n</code>节点映射。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"\n"</span>, key=<span class="hljs-string">"1"</span>) &lt;=&gt; <span class="hljs-title class_">LineState</span>(key=<span class="hljs-string">"L1"</span>)
</code></pre>
<p>实际上我们可以总结一下，最开始我们考虑先更新再<code>diff</code>，后来考虑的是边更新边记录。边更新边记录的优点在于，可以避免再次遍历一边所有<code>Leaf</code>节点的消耗，同时也可以避免<code>diff</code>的复杂性。但是这里也存在个问题，如果内部进行了多次<code>retain</code>操作，则无法直接复用<code>LineState</code>。</p>
<p>不过通常来说，最高频的操作是输入内容，这种情况下首操作一般都是<code>retain</code>，尾操作为空会收集剩余文档内容，因此这部分优化是会被高频触发的。而如果是多次的内容部分变更操作，这部分虽然可以通过判断行内的叶子结点是否变更，来判断是否复用行对象，但是也存在一定复杂性。</p>
<p>关于这部分的具体实现，在编辑器的状态模块里存在独立的<code>Mutate</code>模块，这部分实现在后边实现各个模块时会独立介绍。到这里我们就可以实现一个简单的<code>Immutable</code>状态维护，如果<code>Leaf</code>节点发生变化之后，其父节点<code>Line</code>会触发更新，而其他节点则可以直接复用。</p>
<h2 data-id="heading-1">Key 值维护</h2>
<p>至此我们实现了一套简单的<code>Immutable Delta+Iterator</code>来处理更新，这种时候我们就可以借助不可变的方式来实现<code>React</code>视图的更新，那么在<code>React</code>的渲染模式中，<code>key</code>值的管理也是个值的探讨的问题。</p>
<p>在这里我们就可以根据状态不可变来生成<code>key</code>值，借助<code>WeakMap</code>映射关系获取对应的字符串<code>id</code>值，此时就可以借助<code>key</code>的管理以及<code>React.memo</code>来实现视图的复用。其实在这里初步看起来<code>key</code>值应该是需要主动控制强制刷新的时候，以及完全是新节点才会用得到的。</p>
<p>但是这种方式也是有问题的，因为此时我们即使输入简单的内容，也会导致整个行的<code>key</code>发生改变，而此时我们是不必要更新此时的<code>key</code>的。因此<code>key</code>值是需要单独维护的，不能直接使用不可变的对象来索引<code>key</code>值，那么如果是直接使用<code>index</code>作为<code>key</code>值的话，就会存在潜在的原地复用问题。</p>
<p><code>key</code>值原地复用会导致组件的状态被错误保留，例如此时有个非受控管理的<code>input</code>组件列表，在某个输入框内已经输入了内容，当其发生顺序变化时，原始输入内容会跟随着原地复用的策略留在原始的位置，而不是跟随到新的位置，因为其整体列表顺序<code>key</code>未发生变化导致<code>React</code>直接复用节点。</p>
<p>在<code>LineState</code>节点的<code>key</code>值维护中，如果是初始值则是根据<code>state</code>引用自增的值，在变更的时候则是尽可能地复用原始行的<code>key</code>，这样可以避免过多的行节点重建并且可以控制整行的强制刷新。</p>
<p>而对于<code>LeafState</code>节点的<code>key</code>值最开始是直接使用<code>index</code>值，这样实际上会存在隐性的问题，而如果直接根据<code>Immutable</code>来生成<code>key</code>值的话，任何文本内容的更改都会导致<code>key</code>值改变进而导致<code>DOM</code>节点的频繁重建。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NODE_TO_KEY</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">Object</span>.<span class="hljs-property">Any</span>, <span class="hljs-title class_">Key</span>&gt;();
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span> {
  <span class="hljs-comment">/** 当前节点 id */</span>
  public <span class="hljs-attr">id</span>: string;
  <span class="hljs-comment">/** 自动递增标识符 */</span>
  public <span class="hljs-keyword">static</span> n = <span class="hljs-number">0</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-string">`<span class="hljs-subst">${Key.n++}</span>`</span>;
  }

  <span class="hljs-comment">/**
   * 根据节点获取 id
   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">node</span>
   */</span>
  public <span class="hljs-keyword">static</span> <span class="hljs-title function_">getId</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property">Any</span>): string {
    <span class="hljs-keyword">let</span> key = <span class="hljs-variable constant_">NODE_TO_KEY</span>.<span class="hljs-title function_">get</span>(node);
    <span class="hljs-keyword">if</span> (!key) {
      key = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Key</span>();
      <span class="hljs-variable constant_">NODE_TO_KEY</span>.<span class="hljs-title function_">set</span>(node, key);
    }
    <span class="hljs-keyword">return</span> key.<span class="hljs-property">id</span>;
  }
}
</code></pre>
<p>通常使用<code>index</code>作为<code>key</code>是可行的，然而在一些非受控场景下则会由于原地复用造成渲染问题，<code>diff</code>算法导致的性能问题我们暂时先不考虑。在下面的例子中我们可以看出，每次我们都是从数组顶部删除元素，而实际的<code>input</code>值效果表现出来则是删除了尾部的元素，这就是原地复用的问题。在非受控场景下比较明显，而我们的<code>ContentEditable</code>组件就是一个非受控场景，因此这里的<code>key</code>值需要再考虑一下。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> { useState, <span class="hljs-title class_">Fragment</span>, useRef, useEffect } = <span class="hljs-title class_">React</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">HTMLParagraphElement</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [nodes, setNodes] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i));

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> [_, ...rest] = nodes;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);
    <span class="hljs-title function_">setNodes</span>(rest);
  };

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> el = ref.<span class="hljs-property">current</span>;
    el &amp;&amp; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(el.<span class="hljs-property">children</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">it, i</span>) =&gt;</span> ((it <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>).<span class="hljs-property">value</span> = i + <span class="hljs-string">""</span>));
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span>&gt;</span>
        {nodes.map((_, i) =&gt; (<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{i}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClick}</span>&gt;</span>slice<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span>
  );
}
</code></pre>
<p>考虑到先前提到的我们不希望任何文本内容的更改都导致<code>key</code>值改变引发重建，因此就不能直接使用计算的<code>immutable</code>对象引用来处理<code>key</code>值，而描述单个<code>op</code>的方法除了<code>insert</code>就只剩下<code>attributes</code>了。</p>
<p>但是如果基于<code>attributes</code>来获得就需要精准控制合并<code>insert</code>的时候取需要取旧的对象引用，且没有属性的<code>op</code>就不好处理了，因此这里可能只能将其转为字符串处理，但是这样同样不能保持<code>key</code>的完全稳定，因此前值的索引改变就会导致后续的值出现变更。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">LineState</span>, <span class="hljs-title class_">Record</span>&lt;string, number&gt;&gt;();
<span class="hljs-keyword">const</span> suffix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">LineState</span>, <span class="hljs-title class_">Record</span>&lt;string, number&gt;&gt;();
<span class="hljs-keyword">const</span> mapToString = (<span class="hljs-attr">map</span>: <span class="hljs-title class_">Record</span>&lt;string, string&gt;): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(map)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${key}</span>:<span class="hljs-subst">${map[key]}</span>`</span>)
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">","</span>);
};
<span class="hljs-keyword">const</span> toKey = (<span class="hljs-attr">state</span>: <span class="hljs-title class_">LineState</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">Op</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> key = op.<span class="hljs-property">attributes</span> ? <span class="hljs-title function_">mapToString</span>(op.<span class="hljs-property">attributes</span>) : <span class="hljs-string">""</span>;
  <span class="hljs-keyword">const</span> prefixMap = prefix.<span class="hljs-title function_">get</span>(state) || {};
  prefix.<span class="hljs-title function_">set</span>(state, prefixMap);
  <span class="hljs-keyword">const</span> suffixMap = suffix.<span class="hljs-title function_">get</span>(state) || {};
  suffix.<span class="hljs-title function_">set</span>(state, suffixMap);
  <span class="hljs-keyword">const</span> prefixKey = prefixMap[key] ? prefixMap[key] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> suffixKey = suffixMap[key] ? suffixMap[key] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  prefixMap[key] = prefixKey;
  suffixMap[key] = suffixKey;
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${prefixKey}</span>-<span class="hljs-subst">${suffixKey}</span>`</span>;
};
</code></pre>
<p>在<code>slate</code>中我先前认为生成的<code>key</code>跟节点是完全一一对应的关系，例如当<code>A</code>节点变化时，其代表的层级<code>key</code>必然会发生变化。然而在关注这个问题之后，我发现其在更新生成新的<code>Node</code>之后，会同步更新<code>Path</code>以及<code>PathRef</code>对应的<code>Node</code>节点所对应的<code>key</code>值。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [pathRef, key] <span class="hljs-keyword">of</span> pathRefMatches) {
  <span class="hljs-keyword">if</span> (pathRef.<span class="hljs-property">current</span>) {
    <span class="hljs-keyword">const</span> [node] = <span class="hljs-title class_">Editor</span>.<span class="hljs-title function_">node</span>(e, pathRef.<span class="hljs-property">current</span>)
    <span class="hljs-variable constant_">NODE_TO_KEY</span>.<span class="hljs-title function_">set</span>(node, key)
  }
  pathRef.<span class="hljs-title function_">unref</span>()
}
</code></pre>
<p>在后续观察<code>Lexical</code>实现的选区模型时，发现其是用<code>key</code>值唯一地标识每个叶子结点的，选区也是基于<code>key</code>值来描述的。整体表达上比较类似于<code>Slate</code>的选区结构，或者说是<code>DOM</code>树的结构。这里仅仅是值得<code>Range</code>选区，<code>Lexical</code>实际上还有其他三种选区类型。</p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-attr">anchor</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">"51"</span>, <span class="hljs-attr">offset</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span> },
  <span class="hljs-attr">focus</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">"51"</span>, <span class="hljs-attr">offset</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span> }
}
</code></pre>
<p>在这里比较重要的是<code>key</code>值变更时的状态保持，因为编辑器的内容实际上是需要编辑的。然而如果做到<code>immutable</code>话，很明显直接根据状态对象的引用来映射<code>key</code>会导致整个编辑器<code>DOM</code>无效的重建。例如调整标题的等级，就由于整个行<code>key</code>的变化导致整行重建。</p>
<p>那么如何尽可能地复用<code>key</code>值就成了需要研究的问题，我们的编辑器行级别的<code>key</code>是被特殊维护的，即实现了<code>immutable</code>以及<code>key</code>值复用。而目前叶子状态的<code>key</code>依赖了<code>index</code>值，因此如果调研<code>Lexical</code>的实现，同样可以将其应用到我们的<code>key</code>值维护中。</p>
<p>通过在<code>playground</code>中调试可以发现，即使我们不能得知其是否为<code>immutable</code>的实现，依然可以发现<code>Lexical</code>的<code>key</code>是以一种偏左的方式维护。因此在我们的编辑器实现中，也可以借助同样的方式，合并直接以左值为准复用，拆分时若以<code>0</code>起始直接复用，起始非<code>0</code>则创建新<code>key</code>。</p>
<ol>
<li><code>[123456(key1)][789(bold-key2)]</code>文本，将<code>789</code>的加粗取消，整段文本的<code>key</code>值保持为<code>key1</code>。</li>
<li><code>[123456789(key1)]]</code>文本，将<code>789</code>这段文本加粗，左侧<code>123456</code>文本的<code>key</code>值保持为<code>key1</code>，<code>789</code>则是新的<code>key</code>。</li>
<li><code>[123456789(key1)]]</code>文本，将<code>123</code>这段文本加粗，左侧<code>123</code>文本的<code>key</code>值保持为<code>key1</code>，<code>456789</code>则是新的<code>key</code>。</li>
<li><code>[123456789(key1)]]</code>文本，将<code>456</code>这段文本加粗，左侧<code>123</code>文本的<code>key</code>值保持为<code>key1</code>，<code>456</code>和<code>789</code>分别是新的<code>key</code>。</li>
</ol>
<p>因此，此时在编辑器中我们也是用类似偏左的方式维护<code>key</code>，由于我们需要保持<code>immutable</code>，所以这里的表达实际上是尽可能复用先前的<code>key</code>状态。这里与<code>LineState</code>的<code>key</code>值维护方式类似，都是先创建状态然后更新其<code>key</code>值，当然还有很多细节的地方需要处理。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 起始与裁剪位置等同 NextOp =&gt; Immutable 原地复用 State</span>
<span class="hljs-keyword">if</span> (offset === <span class="hljs-number">0</span> &amp;&amp; op.<span class="hljs-property">insert</span>.<span class="hljs-property">length</span> &lt;= length) {
  <span class="hljs-keyword">return</span> nextLeaf;
}
<span class="hljs-keyword">const</span> newLeaf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafState</span>(retOp, nextLeaf.<span class="hljs-property">parent</span>);
<span class="hljs-comment">// 若 offset 是 0, 则直接复用原始的 key 值</span>
offset === <span class="hljs-number">0</span> &amp;&amp; newLeaf.<span class="hljs-title function_">updateKey</span>(nextLeaf.<span class="hljs-property">key</span>);
</code></pre>
<p>这里还存在另一个小问题，我们创建<code>LeafState</code>就立即去获得对应的<code>key</code>值，然后再考虑去复用原始的<code>key</code>值。这样其实就会导致很多不再使用的<code>key</code>值被创建，导致每次更新的时候看起来<code>key</code>的数字差值比较大。当然这并不影响整体的功能与性能，只是调试的时候看起来比较怪。</p>
<p>因此我们在这里还可以优化这部分表现，也就是说我们在创建的时候不会去立即创建<code>key</code>值，而是在初始化以及更新的时候再从外部设置其<code>key</code>值。这个实现其实跟<code>index</code>、<code>offset</code>的处理方式比较类似，我们整体在<code>update</code>时处理所有的相关值，且开发模式渲染时进行了严格检查。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// BlockState</span>
<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">lines</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">line, index</span>) =&gt;</span> {
  line.<span class="hljs-property">index</span> = index;
  line.<span class="hljs-property">start</span> = offset;
  line.<span class="hljs-property">key</span> = line.<span class="hljs-property">key</span> || <span class="hljs-title class_">Key</span>.<span class="hljs-title function_">getId</span>(line);
  <span class="hljs-keyword">const</span> size = line.<span class="hljs-property">isDirty</span> ? line.<span class="hljs-title function_">updateLeaves</span>() : line.<span class="hljs-property">length</span>;
  offset = offset + size;
});
<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = offset;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lines</span>.<span class="hljs-property">length</span>;
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// LineState</span>
<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">ops</span>: <span class="hljs-title class_">Op</span>[] = [];
<span class="hljs-variable language_">this</span>.<span class="hljs-property">leaves</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">leaf, index</span>) =&gt;</span> {
  ops.<span class="hljs-title function_">push</span>(leaf.<span class="hljs-property">op</span>);
  leaf.<span class="hljs-property">offset</span> = offset;
  leaf.<span class="hljs-property">parent</span> = <span class="hljs-variable language_">this</span>;
  leaf.<span class="hljs-property">index</span> = index;
  offset = offset + leaf.<span class="hljs-property">length</span>;
  leaf.<span class="hljs-property">key</span> = leaf.<span class="hljs-property">key</span> || <span class="hljs-title class_">Key</span>.<span class="hljs-title function_">getId</span>(leaf);
});
<span class="hljs-variable language_">this</span>.<span class="hljs-property">_ops</span> = ops;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = offset;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">isDirty</span> = <span class="hljs-literal">false</span>;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">leaves</span>.<span class="hljs-property">length</span>;
</code></pre>
<p>此外，在实现单元测试时还发现，在<code>leaf</code>上独立维护了<code>key</code>值，那么<code>\n</code>这个特殊的节点自然也会有独立的<code>key</code>值。这种情况下在<code>line</code>级别上维护的<code>key</code>值倒是也可以直接复用<code>\n</code>这个<code>leaf</code>的<code>key</code>值。当然这只是理论上的实现，可能会导致一些意想不到的刷新问题。</p>
<h2 data-id="heading-2">视图增量渲染</h2>
<p>在视图模块最开始的设计上，我们的状态管理形式是直接全量更新<code>Delta</code>，然后使用<code>EachLine</code>遍历重建所有的状态。并且实际上我们维护了<code>Delta</code>与<code>State</code>两个数据模型，建立其关系映射关系本身也是一种损耗，渲染的时候的目标状态是<code>Delta</code>而非<code>State</code>。</p>
<p>这样的模型必然是耗费性能的，每次<code>Apply</code>的时候都需要全量更新文档并且再次遍历分割行状态。当然实际上只是计算迭代的话，实际上是不会太过于耗费性能，但是由于我们每次都是新的对象，那么在更新视图的时候，更容易造成性能的损耗，计算的性能通常可接受，而视图更新操作<code>DOM</code>成本更高。</p>
<p>实际上，我们上边复用其<code>key</code>值，解决的问题是避免整个行状态视图<code>re-mount</code>。而即使复用了<code>key</code>值，因为重建了整个<code>State</code>实例，<code>React</code>也会继续后边的<code>re-render</code>流程。因此我们在这里需要解决的问题是，如何在无变更的情况下尽可能避免其视图<code>re-render</code>。</p>
<p>由于我们实现了行级不可变状态维护，那么在视图中就可以直接对比状态对象的引用是否变化来决定是否需要重渲染。因此只需要对于<code>ViewModel</code>的节点补充了<code>React.memo</code>，在这个场景下甚至于不需要重写对比函数，只需要依赖我们的<code>immutable</code>状态复用能够正常起到效果。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LeafView</span>: <span class="hljs-variable constant_">FC</span>&lt;{ <span class="hljs-attr">editor</span>: <span class="hljs-title class_">Editor</span>; <span class="hljs-attr">leafState</span>: <span class="hljs-title class_">LeafState</span>; }&gt; = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> {<span class="hljs-attr">...</span>{ [<span class="hljs-attr">LEAF_KEY</span>]<span class="hljs-attr">:</span> <span class="hljs-attr">true</span> }} &gt;</span>
      {runtime.children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
  );
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LeafModel</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">LeafView</span>);
</code></pre>
<p>同样的，针对<code>LineView</code>也需要补充<code>memo</code>，而且由于组件内本身可能存在状态变化，例如<code>Composing</code>组合输入的控制，所以针对于内部节点的计算也会采用<code>useMemo</code>来缓存结果，避免重复计算。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LineView</span>: <span class="hljs-variable constant_">FC</span>&lt;{ <span class="hljs-attr">editor</span>: <span class="hljs-title class_">Editor</span>; <span class="hljs-attr">lineState</span>: <span class="hljs-title class_">LineState</span>; }&gt; = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> elements = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
     <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> nodes;
  }, [editor, lineState]);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...</span>{ [<span class="hljs-attr">NODE_KEY</span>]<span class="hljs-attr">:</span> <span class="hljs-attr">true</span> }} &gt;</span>
      {elements}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LineModel</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">LineView</span>);
</code></pre>
<p>而视图刷新仍然还是直接控制<code>lines</code>这个状态的引用即可，相当于核心层的内容变化与视图层的重渲染，是直接依赖于事件模块通信就可以实现的。由于每次取<code>lines</code>状态时都是新的引用，所以<code>React</code>会认为状态发生了变化，从而触发重渲染。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> onContentChange = <span class="hljs-title function_">useMemoFn</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (flushing.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  flushing.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>;
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    flushing.<span class="hljs-property">current</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-title function_">setLines</span>(state.<span class="hljs-title function_">getLines</span>());
  });
});
</code></pre>
<p>而虽然触发了渲染，但是由于<code>key</code>以及<code>memo</code>的存在，会以<code>line</code>的状态为基准进行对比。只有<code>LineState</code>对象的引用发生了变化，<code>LineModel</code>视图才会触发更新逻辑，否则会复用原有的视图，这部分我们可以直接依赖<code>React</code>的<code>devtools</code>录制或<code>Highlight</code>就可以观察到。</p>
<p>视图增量更新这部分其实比较简单，主要是实现不可变对象以及<code>key</code>值维护的逻辑都在核心层实现，视图层主要是依赖其做计算，对比是否需要重渲染。其实类似的实现在低代码的场景中也可以应用，毕竟实际上富文本也就是相当于一个零代码的编辑器，只不过组装的不是组件而是文本。</p>
<h2 data-id="heading-3">总结</h2>
<p>在先前我们主要讨论了视图层的适配器设计，主要是全量的视图初始化渲染，以及状态模型到<code>DOM</code>结构性的规则设定。在这里则主要考虑更新处理时性能的优化，主要是在增量更新时，如何最小化<code>DOM</code>以及<code>Op</code>操作、<code>key</code>值的维护、以及在<code>React</code>中实现增量渲染的方式。</p>
<p>其实接下来需要考虑输入内容时，如何避免规定的<code>DOM</code>的结构被破坏，主要涉及脏<code>DOM</code>检查、选区更新、渲染<code>Hook</code>等，这部分内容在<code>#8</code>和<code>#9</code>的输入法处理中已经有了详细的讨论，因此这里就不再次展开了。</p>
<p>那么接下来我们需要讨论的是编辑节点的组件预设，例如零宽字符、<code>Embed</code>节点、<code>Void</code>节点等。主要是为编辑器的插件扩展提供预设的组件，在这些组件内存在一些默认的行为，并且同样预设了部分<code>DOM</code>结构，以此来实现在规定范围内的编辑器操作。</p>
<h2 data-id="heading-4">每日一题</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWindRunnerMax%2FEveryDay" target="_blank" title="https://github.com/WindRunnerMax/EveryDay" ref="nofollow noopener noreferrer">github.com/WindRunnerM…</a></li>
</ul>
<h2 data-id="heading-5">参考</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2F18.react.dev%2F" target="_blank" title="https://18.react.dev/" ref="nofollow noopener noreferrer">18.react.dev/</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2F18.react.dev%2Freference%2Freact%2Fmemo" target="_blank" title="https://18.react.dev/reference/react/memo" ref="nofollow noopener noreferrer">18.react.dev/reference/r…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2F18.react.dev%2Freference%2Freact%2FuseMemo" target="_blank" title="https://18.react.dev/reference/react/useMemo" ref="nofollow noopener noreferrer">18.react.dev/reference/r…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[端云一体 一天开发的元服务-奇趣故事匣经验分享]]></title>    <link>https://juejin.cn/post/7604690250342383666</link>    <guid>https://juejin.cn/post/7604690250342383666</guid>    <pubDate>2026-02-09T02:51:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604690250342383666" data-draft-id="7604012106154639406" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="端云一体 一天开发的元服务-奇趣故事匣经验分享"/> <meta itemprop="keywords" content="前端,HarmonyOS,AI编程"/> <meta itemprop="datePublished" content="2026-02-09T02:51:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="万少"/> <meta itemprop="url" content="https://juejin.cn/user/4441682708283191"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            端云一体 一天开发的元服务-奇趣故事匣经验分享
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4441682708283191/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    万少
  </span> <!----> <!----> <div class="vip-level" data-v-cd7d0a50="" data-v-292f6e48=""><span class="tooltip" data-v-cd7d0a50=""><div class="byte-tooltip byte-tooltip--dark" style="display:none;">
        VIP.5 如鱼得水
      </div><span class="byte-tooltip__wrapper"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="VIP.5 如鱼得水" title="VIP.5 如鱼得水" class="lazy" style="aspect-ratio:NaN;" data-v-5244ef91="" data-v-cd7d0a50=""/></span></span></div> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:51:25.000Z" title="Mon Feb 09 2026 02:51:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">端云一体 一天开发的元服务-奇趣故事匣经验分享 <a href="#%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93-%E4%B8%80%E5%A4%A9%E9%87%8D%E6%96%B0%E5%BC%80%E5%8F%91%E7%9A%84%E5%85%83%E6%9C%8D%E5%8A%A1-%E5%A5%87%E8%B6%A3%E6%95%85%E4%BA%8B%E5%8C%A3%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB" title="#%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93-%E4%B8%80%E5%A4%A9%E9%87%8D%E6%96%B0%E5%BC%80%E5%8F%91%E7%9A%84%E5%85%83%E6%9C%8D%E5%8A%A1-%E5%A5%87%E8%B6%A3%E6%95%85%E4%BA%8B%E5%8C%A3%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB">​</a></h2>
<blockquote>
<p>万少：华为HDE、鸿蒙极客</p>
<p>个人主页：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.zbztb.cn%2F" target="_blank" title="https://blog.zbztb.cn/" ref="nofollow noopener noreferrer">blog.zbztb.cn/</a></p>
<p><strong>2025年参与孵化了20+鸿蒙应用、技术文章300+、鸿蒙知识库用户500+、鸿蒙免费课程2套。</strong></p>
<p>如果你也喜欢交流AI和鸿蒙技术，欢迎扣我。</p>
</blockquote>
<h2 data-id="heading-1">前言 <a href="#%E5%89%8D%E8%A8%80" title="#%E5%89%8D%E8%A8%80">​</a></h2>
<p>学习技术最好的做法就是应用技术，带着这个目标。</p>
<p>我这次打算深度使用华为-鸿蒙的端云一体，做一个完整的作品 <strong>奇趣故事匣</strong>。</p>
<p>先看成果。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a176a33681948d8aef65bb608c1dcba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=5gYt%2BNSRzRkBNd2jqpYE%2FfChKVc%3D" alt="" loading="lazy"/></p>
<hr/>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/953727811031467d8e3414c5b9d2d3a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=YYFg%2F3ZlBuXJa7qwdrH6MjBYb%2FE%3D" alt="" loading="lazy"/></p>
<p>奇趣故事匣其实在25年的时候就已经上架了成了一个元服务</p>
<p>那时候的是传统架构</p>
<ol>
<li>java后端</li>
<li>鸿蒙前端</li>
</ol>
<p>因为是传统后端开发的方式，所以需要一定的后端能力:</p>
<ol>
<li>后端编程语言</li>
<li>服务器-域名-运维等</li>
</ol>
<p>这个过程还是很耗人的，尤其对于一个初学者来说。</p>
<h2 data-id="heading-2">端云一体的优势 <a href="#%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93%E7%9A%84%E4%BC%98%E5%8A%BF" title="#%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93%E7%9A%84%E4%BC%98%E5%8A%BF">​</a></h2>
<p>云开发（Serverless）是一种由云端平台提供服务器和环境、让开发者只需关注业务逻辑的按需服务架构，具备零运维、弹性伸缩、安全可靠等优势，并支持端云一体化开发。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5eff4cc23324498ab4d7c0a037ee5419~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=kwQYHLxAFeF%2BZK8xVX4jXEnXepQ%3D" alt="" loading="lazy"/></p>
<p>总的来说，开发者只需要在两个窗口内基本就可以完成整个应用的开发。</p>
<h2 data-id="heading-3">环境一览 <a href="#%E7%8E%AF%E5%A2%83%E4%B8%80%E8%A7%88" title="#%E7%8E%AF%E5%A2%83%E4%B8%80%E8%A7%88">​</a></h2>
<ol>
<li><strong>AGC平台-管理云端资源</strong></li>
<li><strong>DevEco Studio 实现全链路开发</strong></li>
</ol>
<hr/>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3834193d8c3a402abc52d9dc4e14b6e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=ib6MSN%2B%2BPRt3nF9y7xhahcM5hMo%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9a24db813c24697a2851d92438c05e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=mXZTrARmv17mGVIAuCS4Epu909s%3D" alt="" loading="lazy"/></p>
<hr/>
<p>其中关于云端的调试，DevEco Studio中也提供了调试面板</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1c380af8f1045e38e2f90dbe890a320~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=Z7SPVKU1UcVPmjatlv4Bq%2B2dXVg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1146f5e32a4740548073d899a894215b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=uXqhoyLiof0%2Fk2ZVF3C0Lf25L7A%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">端云一体的概念详解 <a href="#%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3" title="#%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3">​</a></h2>
<p>认证服务：助力应用快速构建安全可靠的用户认证系统。 云函数： 提供Serverless化的代码开发与运行平台。 云数据库：提供端云数据的协同管理。 云缓存：为云函数提供Key-Value型高速缓存。 云存储：助力应用存储图片、音频、视频等内容，并提供高品质的上传、下载、分享能力。 云监控：提供云开发服务的运行指标、日志和告警，助力实时洞察服务运行状态。 API网关：一个API开放平台，支持对多种API源的全生命周期管理。 云托管：提供网站的托管和静态CDN加速。 云应用引擎：提供包括部署、运行、运维在内的一站式应用托管方案。</p>
<hr/>
<p>其中最基本的<strong>云函数</strong>、<strong>云数据库</strong>、<strong>云存储</strong>足够支撑起一个差不多的应用了。</p>
<h2 data-id="heading-5">经验分享 <a href="#%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB" title="#%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB">​</a></h2>
<p>过程中确实还是少不了一些问题</p>
<ol>
<li>端云一体的环境，但是数据库、数据表以及它们的关联，其实都需要自己先去设计。</li>
<li>那另外比如我们所做的这个故事类的应用，它有一些故事，然后一些图片，可能还包括一些视频等等，这些素材其实也需要自己去设计的。</li>
<li>过程当中还有不少是关于一些权限的问题，就是你怎么样把本地设计好的一些数据表同步到这个AGC平台上。</li>
<li>如果是应用内用户产生的数据，它又是否有什么权限，然后可以同步上去，这一块其实都要踩一些坑</li>
<li>最后再说一些场面话，我们学技术其实最好的方式就是做一些产品，这个踩坑其实是必然的。过后呢，我们相信再做第二个第三个应用之前的一些坑就会变成我们实际的开发经验了。</li>
</ol>
<h2 data-id="heading-6">开发过程中的技术分享 <a href="#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB" title="#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB">​</a></h2>
<p>25年、26年已经有苗头都在宣传 <strong>一个人公司</strong>，所以作为独立的个体只要是关于提高生产力的，可能都需要了解包括使用。</p>
<p>这里分享一下我的开发 配套技术：</p>
<ol>
<li>使用了海外版本的Trae+Gemini3-Pro完成目前功能的开发</li>
<li>使用了智能体、skill、rule、mcp等主流AI技术</li>
<li>使用了HarmonyOS自动构建脚本</li>
<li>使用的是元服务+V2状态管理+Navigation</li>
<li>使用了AI脚本批量生产素材</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/92b1815d22cc478f9f20a932f069490c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=3PqfBXHz8UdigH2nPFs23C4XVqk%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">这会的成功 <a href="#%E8%BF%99%E4%BC%9A%E7%9A%84%E6%88%90%E5%8A%9F" title="#%E8%BF%99%E4%BC%9A%E7%9A%84%E6%88%90%E5%8A%9F">​</a></h2>
<p>此时的时间是<strong>2026年2月7日22:35:25</strong>，边聊天的时候我也给这个应用接入了用户系统了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/833714ad3e1b4bc983245c95e16affd4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiH5bCR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210286&amp;x-signature=81%2BR%2BeSLXnWyXeXKAn7ZkJG8yBE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-8">总结 <a href="#%E6%80%BB%E7%BB%93" title="#%E6%80%BB%E7%BB%93">​</a></h2>
<ol>
<li>AI时代，要学会工具来提效</li>
<li>鸿蒙的端云使用很方便，值得一试</li>
</ol>
<h2 data-id="heading-9">参考链接 <a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5" title="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">​</a></h2>
<ol>
<li>
<p>端云一体</p>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2FAppGallery-connect-Guides%2Fagc-serverless-overview-0000001509965245" target="_blank" title="https://developer.huawei.com/consumer/cn/doc/AppGallery-connect-Guides/agc-serverless-overview-0000001509965245" ref="nofollow noopener noreferrer">developer.huawei.com/consumer/cn…</a></p>
</blockquote>
</li>
<li>
<p>端云一体教程</p>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.zbztb.cn%2F%25E9%25B8%25BF%25E8%2592%2599%25E5%25BC%2580%25E5%258F%2591%25E6%258A%2580%25E5%25B7%25A7%2FHarmonyOSNext%2520%25E7%25AB%25AF%25E4%25BA%2591%25E4%25B8%2580%25E4%25BD%2593%25E5%258C%2596%2FHarmonyOSNext%2520%25E7%25AB%25AF%25E4%25BA%2591%25E4%25B8%2580%25E4%25BD%2593%25E5%258C%2596%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%2588%2FHarmonyOSNext%2520%25E7%25AB%25AF%25E4%25BA%2591%25E4%25B8%2580%25E4%25BD%2593%25E5%258C%2596%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%2588.html" target="_blank" title="https://blog.zbztb.cn/%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/HarmonyOSNext%20%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93%E5%8C%96/HarmonyOSNext%20%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93%E5%8C%96%E5%AE%8C%E6%95%B4%E7%89%88/HarmonyOSNext%20%E7%AB%AF%E4%BA%91%E4%B8%80%E4%BD%93%E5%8C%96%E5%AE%8C%E6%95%B4%E7%89%88.html" ref="nofollow noopener noreferrer">blog.zbztb.cn/鸿蒙开发技巧/Harm…</a></p>
</blockquote>
</li>
</ol>
<p><strong>关注我</strong>，持续分享<strong>鸿蒙开发</strong> + <code>AI</code> 提效的实战技巧。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[上万级文件一起可视化，怎么办？答案是基于 ParaView 的远程可视化]]></title>    <link>https://juejin.cn/post/7604093823958237203</link>    <guid>https://juejin.cn/post/7604093823958237203</guid>    <pubDate>2026-02-09T02:42:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604093823958237203" data-draft-id="7603911453704962091" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="上万级文件一起可视化，怎么办？答案是基于 ParaView 的远程可视化"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T02:42:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="serioyaoyao"/> <meta itemprop="url" content="https://juejin.cn/user/3702810895220093"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            上万级文件一起可视化，怎么办？答案是基于 ParaView 的远程可视化
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3702810895220093/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    serioyaoyao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:42:36.000Z" title="Mon Feb 09 2026 02:42:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、概述</h2>
<p>在 CFD/FEA 等仿真场景里，我们经常会遇到一种“看起来很朴素、做起来很要命”的需求：</p>
<ul>
<li>一次任务导出上万帧（上万级文件）结果，单帧可能是 <code>.vtu/.vtk</code>；</li>
<li>需要在浏览器里流畅拖动时间轴、切换物理量、裁剪/切片、对比多视图；</li>
<li>数据体量大、用户网络环境复杂，而且还希望多人同时访问。</li>
</ul>
<p>（这三点，就是我开发时，产品经理提的需求）</p>
<p>【注释：】</p>
<p>1.CFD:Computational Fluid Dynamics，计算流体力学</p>
<p> 典型仿真场景:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b5b5e32c958b48f99388bc72eb8f2ce0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2VyaW95YW95YW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210161&amp;x-signature=es%2FjhURv84iuFQI8vSUDfbUN0A8%3D" alt="Improving Aircraft Aerodynamics With CFD Simulation" loading="lazy"/></p>
<p>2.FEA（Finite Element Analysis，有限元分析）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/113122b472ec469ca3be5e535a87180a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2VyaW95YW95YW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210161&amp;x-signature=prLm0usAjDNU4gLwxlFmDOUGL%2BQ%3D" alt="What Is FEA | Finite Element Analysis? (Ultimate Guide) | SimScale" loading="lazy"/></p>
<p>如果把这件事当成“前端把所有文件下载下来，用 WebGL 自己画”，基本会踩到：下载、解析、内存、GPU、交互延迟等一系列问题（我最开始接到需求时，就是这样做的，辛辛苦苦做完，遇上上万个文件加载、渲染，直接浏览器卡死😤）</p>
<p>这篇文章分享一个在工程上更稳妥的答案：基于 ParaView 的远程可视化（Remote Rendering）。(遇上浏览器卡顿、卡死后，项目负责人提供了另一个思路，于是开启技术调研、写demo、放入实际项目使用。）</p>
<p>本文基于我在项目中的落地实践：</p>
<ul>
<li>后端使用 <code>pvpython</code>（ParaView 自带 Python）+ <code>wslink</code> + <code>paraview.web</code> 进行渲染与 RPC；</li>
<li>前端使用 <code>vite + vue</code> + <code>@kitware/vtk.js</code> 的 <code>vtkRemoteView</code> 接收图像流并转发交互事件；</li>
<li>对“dev 开发模式”提供了 <strong>网关隔离</strong>：每个浏览器连接启动独立的 <code>pvpython</code> 子进程，避免多窗口互相覆盖。</li>
</ul>
<p>你可以把它理解为：</p>
<blockquote>
<p>浏览器只负责“看图 + 交互”，服务端负责“读数据 + 建管线 + GPU 渲染”。</p>
<p>对“万级文件/时间序列”的科学可视化，最容易规模化的做法往往是：<strong>把渲染留在服务端，把交互留在浏览器</strong>。</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30e02036cdfa4c97a2bda0547227d244~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2VyaW95YW95YW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210161&amp;x-signature=YbrxRP9zjlP0FPRcG4csuJ6MkD8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">二、为什么“上万级文件”会把常规方案打爆？</h2>
<p>先把问题拆开看，“上万级文件可视化”通常同时包含 4 个压力源：</p>
<p><strong>1.I/O 压力</strong></p>
<ul>
<li>文件数量上来以后，目录遍历、排序、打开文件句柄、元数据读取都会变慢。</li>
<li>即使单帧不大，上万次打开/关闭也很可观。</li>
</ul>
<p><strong>2.解析与内存压力</strong></p>
<ul>
<li><code>.vtu/.vtk</code> 解析成本高，尤其是复杂网格/高阶单元/多数组。</li>
<li>浏览器内存、GPU 显存都更紧张，稍不注意就崩溃或卡死。</li>
</ul>
<p><strong>3.网络与带宽压力</strong></p>
<ul>
<li>把数据下发到浏览器意味着：传输成本高、等待时间长、弱网体验差。</li>
</ul>
<p><strong>4.交互延迟与工程复杂度</strong></p>
<ul>
<li>“拖时间轴 + 实时更新画面”对端到端延迟非常敏感。</li>
<li>前端自己管理 time steps、颜色映射、裁剪滤镜等，会把可视化系统变成一个“重客户端”。</li>
</ul>
<p>如果你希望最终体验接近 ParaView 桌面端，同时还要浏览器可用、多人可访问：</p>
<blockquote>
<p>把渲染放在服务端（最好有 GPU），让浏览器只做交互与显示，通常是最划算的架构选择。</p>
</blockquote>
<h2 data-id="heading-2">三、方案：ParaView 远程渲染（Remote Rendering）</h2>
<ul>
<li>
<p><strong>服务端</strong>：<code>pvpython</code> 进程内运行 ParaView pipeline，离屏渲染，把画面编码为图片流，经 WebSocket 推送。</p>
</li>
<li>
<p><strong>客户端</strong>：<code>vtkRemoteView</code> 接收图像并显示到 canvas；鼠标/键盘事件通过 <code>wslink</code> 发回服务端。</p>
</li>
<li>
<p>数据留在服务端；</p>
</li>
<li>
<p>浏览器拿到的是“每一帧的渲染结果（图像）”；</p>
</li>
<li>
<p>交互是“事件/指令”，不是“传模型”。</p>
</li>
</ul>
<p>现在的架构，变成：</p>
<ul>
<li>
<p><strong>服务端是“可视化引擎”</strong>：读数据、建管线、算颜色映射、做裁剪/切片、渲染。</p>
</li>
<li>
<p><strong>浏览器是“远程控制器”</strong>：渲染结果是图像流；交互就是事件和参数。</p>
</li>
</ul>
<h2 data-id="heading-3">四、核心功能</h2>
<ul>
<li>
<p><strong>万级文件时间序列回放</strong>（目录下 <code>.vtu/.vtk</code> 序列）：播放/暂停、逐帧切换、循环、帧率。</p>
</li>
<li>
<p><strong>场数据切换</strong>：点/单元字段（POINTS/CELLS）自动识别，向量支持 Magnitude/分量选择。</p>
</li>
<li>
<p><strong>交互与相机</strong>：旋转/平移/缩放、重置相机、围绕物体中心旋转。</p>
</li>
<li>
<p><strong>裁剪/切片</strong>：X/Y/Z 轴切片或裁剪（项目中 demo2/demo5/dev 具备相关能力）。</p>
</li>
<li>
<p><strong>多视图对比</strong>：同一数据不同物理量并排渲染（demo6/dev 的 multiview）。</p>
</li>
<li>
<p><strong>远程加载</strong>：支持从网络盘/挂载盘读取任务数据（<code>DEV_NETWORK_ROOT</code>）。</p>
</li>
</ul>
<h2 data-id="heading-4">五、排坑清单</h2>
<p>如果你也准备落地 ParaViewWeb，这些坑我建议你在 README 或运维文档里明确写出来：</p>
<ol>
<li>
<p>后端必须用 <code>pvpython</code> 启动（paraview自带，不是 <code>python</code>）。</p>
</li>
<li>
<p>多人访问要考虑隔离（最简单就是每连接一个进程）。</p>
</li>
<li>
<p>图像流带宽/消息大小要提前评估，尤其是 4K/多视图。</p>
</li>
<li>
<p>时间序列一定要做“时间步兜底”（读不到 TimestepValues 就用 <code>0..N-1</code>）。</p>
</li>
<li>
<p>项目部署与文件存储服务器不在一起时，考虑用挂载远程服务器数据进行开发</p>
<p>运行可能需要输入服务器密码，建议配置 SSH 免密登录以实现全自动启动。</p>
</li>
</ol>
<h2 data-id="heading-5">六、结语</h2>
<p>“上万级文件一起可视化”本质上不是一个前端工程问题，而是一个端到端系统问题：数据存储、I/O、渲染、交互、网络、多人隔离，每一个环节都可能成为瓶颈。</p>
<p>基于 ParaView 的远程可视化，把最重的那部分（读取、管线、GPU 渲染）放回服务端，让浏览器专注“交互 + 显示”，在工程上往往是最划算、最可持续的路线（目前来看，是这样，有不有更好的方案，大佬们可以说说~~）。</p>
<p>（yaoyao从技术调研、到项目使用，时间也不长，这个方案有问题，请大佬们指正~~）</p>
<p>本文是纯方案讨论，下期，上代码！！！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[移动端H5项目，还需要react-fastclick解决300ms点击延迟吗？]]></title>    <link>https://juejin.cn/post/7604093823958302739</link>    <guid>https://juejin.cn/post/7604093823958302739</guid>    <pubDate>2026-02-09T02:57:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604093823958302739" data-draft-id="7592818202717143059" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="移动端H5项目，还需要react-fastclick解决300ms点击延迟吗？"/> <meta itemprop="keywords" content="前端,JavaScript,React.js"/> <meta itemprop="datePublished" content="2026-02-09T02:57:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹏多多"/> <meta itemprop="url" content="https://juejin.cn/user/747323639737191"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            移动端H5项目，还需要react-fastclick解决300ms点击延迟吗？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/747323639737191/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹏多多
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:57:04.000Z" title="Mon Feb 09 2026 02:57:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="agate">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#333;color:#fff}.hljs-name,.hljs-strong{font-weight:700}.hljs-code,.hljs-emphasis{font-style:italic}.hljs-tag{color:#62c8f3}.hljs-selector-class,.hljs-selector-id,.hljs-template-variable,.hljs-variable{color:#ade5fc}.hljs-bullet,.hljs-string{color:#a2fca2}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-quote,.hljs-section,.hljs-title,.hljs-type{color:#ffa}.hljs-bullet,.hljs-number,.hljs-symbol{color:#d36363}.hljs-keyword,.hljs-literal,.hljs-selector-tag{color:#fcc28c}.hljs-code,.hljs-comment,.hljs-deletion{color:#888}.hljs-link,.hljs-regexp{color:#c6b4f0}.hljs-meta{color:#fc9b9b}.hljs-deletion{background-color:#fc9b9b;color:#333}.hljs-addition{background-color:#a2fca2;color:#333}.hljs a{color:inherit}.hljs a:focus,.hljs a:hover{color:inherit;text-decoration:underline}</style><p>今天整理旧项目的时候发现，在之前开发React移动端项目时，总会习惯性引入<code>react-fastclick</code>来处理点击延迟问题。但这次的项目是React18搭配Vite5的技术栈，突然产生了一个疑问：在当前的技术环境下，使用现代浏览器，移动端项目还需要依赖<code>react-fastclick</code>来解决<code>300ms点击延迟</code>吗？带着这个疑问，我整理了相关知识点，和大家一起探讨一下。</p>
<h2 data-id="heading-0">1. 300ms 延迟的来源</h2>
<p>要弄清楚是否需要react-fastclick，首先得回顾一下300ms点击延迟的由来。300ms延迟并不是移动端浏览器的bug，而是早期移动浏览器（主要是旧版iOS Safari / Android WebView）为了适配用户操作而设计的机制：</p>
<ul>
<li>核心原因：为了判断用户的点击操作是否是「双击缩放」（双击页面可以放大显示内容，这是早期移动端的核心交互之一）。</li>
<li>延迟表现：浏览器在检测到用户的一次click事件后，会强制等待约300ms，确认用户没有进行第二次点击后，才会真正触发click事件。</li>
</ul>
<p>正因为这个300ms的等待时间，导致早期移动端H5页面的点击操作总会有明显的延迟感，影响用户体验，这也是FastClick类库诞生的原因——通过绕过浏览器的这个等待机制，消除300ms延迟。</p>
<hr/>
<h2 data-id="heading-1">2. 现代浏览器已默认移除 300ms 延迟</h2>
<p>随着移动端技术的发展，「双击缩放」的使用场景越来越少，且用户对交互流畅度的要求越来越高，主流移动端浏览器早已默认移除了300ms点击延迟，具体支持情况如下：</p>
<h3 data-id="heading-2">✅ iOS 环境</h3>
<ul>
<li>iOS 9及以上版本的Safari浏览器</li>
<li>所有基于WKWebView的内嵌页面（目前绝大多数iOS App的内嵌H5都采用WKWebView）</li>
</ul>
<h3 data-id="heading-3">✅ Android 环境</h3>
<ul>
<li>Chrome 32及以上版本</li>
<li>Android系统自带的WebView（Android 4.4及以上版本基本都已支持）</li>
</ul>
<p>需要注意的是，浏览器移除300ms延迟需要满足两个简单条件，而这两个条件在React18+Vite5项目中几乎是默认配置：</p>
<h3 data-id="heading-4">条件1：正确设置viewport</h3>
<p>这是最基础的条件，只要在HTML头部设置了正确的viewport标签，浏览器就会认为页面已适配移动端，无需通过双击缩放来优化显示：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;meta <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;
</code></pre>
<p>重点说明：Vite + React的默认模板中，已经自带了这个viewport配置，无需我们额外手动添加。</p>
<h3 data-id="heading-5">条件2：禁止双击缩放（或页面已完全适配）</h3>
<p>如果页面不需要支持双击缩放，只需在viewport标签中添加相关配置，即可彻底杜绝浏览器的双击缩放判断，进一步确保无延迟：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;meta
  <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span>
  <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1, user-scalable=no"</span>
/&gt;
</code></pre>
<p>或通过限制最大缩放比例来实现：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;meta
  <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span>
  <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1, maximum-scale=1"</span>
/&gt;
</code></pre>
<p>实际上，现在大多数移动端H5项目都会添加上述配置，一方面是为了保证页面适配一致性，另一方面也间接消除了300ms延迟的可能。</p>
<hr/>
<h2 data-id="heading-6">3. FastClick / react-fastclick 已过时</h2>
<p>既然现代浏览器已经默认移除了300ms延迟，那么FastClick及其React封装版react-fastclick，不仅不再必要，反而可能成为项目的负担。</p>
<h3 data-id="heading-7">官方态度：项目已停止维护</h3>
<p>FastClick的作者早在2016年后就明确表示：「Modern browsers don’t have 300ms delay anymore.」（现代浏览器已不再有300ms延迟）。此后，FastClick项目基本停止维护，不再适配新的浏览器版本和前端技术栈。</p>
<h3 data-id="heading-8">React 18 项目中的潜在问题</h3>
<p>在React 18项目中强行引入react-fastclick，不仅无法带来收益，还可能引发一系列兼容性问题，具体如下：</p>
<ul>
<li>❌ 事件重复触发：react-fastclick的实现机制与React 18的合成事件体系存在冲突，可能导致点击事件被触发两次（比如一次由react-fastclick触发，一次由浏览器原生触发）。</li>
<li>❌ 与Pointer Events不兼容：React 18已全面支持Pointer Events（统一处理鼠标、触摸、笔等输入事件），而react-fastclick未适配该特性，可能导致事件监听异常。</li>
<li>❌ iOS偶发点击穿透：在部分iOS设备上，react-fastclick可能导致点击穿透问题（点击上层元素，却触发了下层元素的点击事件），影响交互体验。</li>
</ul>
<p>综合来看，在React 18+Vite5项目中使用react-fastclick，完全是「风险大于收益」的操作。</p>
<hr/>
<h2 data-id="heading-9">4. 现代解决方案</h2>
<p>虽然大多数情况下，只要保证viewport配置正确，就不会有300ms延迟，但如果你的项目需要适配一些特殊环境（比如老旧WebView、小众国产浏览器），或者确实感受到了点击延迟，可以尝试以下现代解决方案，比react-fastclick更安全、更高效。</p>
<h3 data-id="heading-10">✅ 4.1. 使用 touch / pointer 事件</h3>
<p>React 18已全面支持Pointer Events，该事件的优先级高于原生click事件，无需等待300ms，可实现零延迟点击。使用方式非常简单，只需将onClick替换为onPointerDown或onPointerUp即可：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onPointerDown</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>点击按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<p>注意：优先使用onPointerDown（触摸开始时触发），响应速度最快；如果需要避免“误触”，也可以使用onPointerUp（触摸结束时触发）。</p>
<hr/>
<h3 data-id="heading-11">✅ 4.2. 使用 CSS touch-action（推荐）</h3>
<p>这是最推荐的解决方案，通过CSS的touch-action属性，直接告诉浏览器该元素的触摸行为，禁止不必要的手势判断，从而消除延迟。</p>
<p>针对可点击元素（如按钮、链接），添加如下CSS：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">button</span> {
  touch-action: manipulation;
}
</code></pre>
<p>touch-action: manipulation的作用：</p>
<ul>
<li>禁止双击缩放、双指缩放等手势操作；</li>
<li>告诉浏览器该元素仅用于点击交互，无需等待300ms判断手势，直接派发click事件。</li>
</ul>
<p>如果项目中可点击元素较多，也可以全局设置（仅对可点击元素生效，不影响页面滚动）：</p>
<pre><code class="hljs language-css" lang="css">* {
  touch-action: manipulation;
}
</code></pre>
<hr/>
<h3 data-id="heading-12">✅ 4.3. 避免 300ms 的错误姿势</h3>
<p>除了上述方案，还要注意避免一些可能间接导致点击延迟的错误写法，比如：</p>
<pre><code class="hljs language-xml" lang="xml">// ❌ 错误：同时使用onTouchStart和onClick
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onTouchStart</span>=<span class="hljs-string">{handleClick}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>点击按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<p>这种写法会导致触摸时触发一次handleClick，300ms后（如果浏览器有延迟）又触发一次onClick，不仅会出现“延迟感”，还可能导致逻辑异常，务必避免。</p>
<hr/>
<h2 data-id="heading-13">5. 最终结论与可直接使用的模板</h2>
<p>对于 React 18 + Vite 5 的移动端项目：</p>
<ul>
<li>✅ 不需要引入 react-fastclick</li>
<li>❌ 不推荐使用任何版本的 fastclick</li>
<li>✅ 只要保证 viewport 配置正确，就能消除绝大多数场景的300ms延迟</li>
<li>✅ 优化CSS的touch-action配置，可兼容所有极端环境</li>
</ul>
<h3 data-id="heading-14">当前配置达标情况（参考）</h3>





























<table><thead><tr><th>项目</th><th>是否达标</th></tr></thead><tbody><tr><td>viewport配置</td><td>✅（Vite默认配置）</td></tr><tr><td>禁止缩放</td><td>✅（添加max-scale=1或user-scalable=no即可）</td></tr><tr><td>click延迟</td><td>基本无（主流浏览器）</td></tr><tr><td>兼容性</td><td>⚠️ 中等（需优化touch-action配置）</td></tr><tr><td>极端环境</td><td>可能残留（优化后可解决）</td></tr></tbody></table>
<h3 data-id="heading-15">推荐最终模板（可直接复制使用）</h3>
<p>整合所有最佳实践，提供可直接套用的HTML和CSS模板，确保项目无点击延迟、兼容性拉满：</p>
<h3 data-id="heading-16">5.1. HTML viewport 配置</h3>
<pre><code class="hljs language-ini" lang="ini">&lt;meta
  <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span>
  <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,
           initial-scale=1,
           maximum-scale=1,
           user-scalable=no,
           viewport-fit=cover"</span>
/&gt;
</code></pre>
<p>说明：viewport-fit=cover用于适配iPhone刘海屏，避免页面被刘海遮挡，不影响点击延迟。</p>
<h3 data-id="heading-17">5.2. CSS 配置</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">html</span>,
<span class="hljs-selector-tag">body</span> {
  -webkit-user-drag: none;
  touch-action: pan-y;
}

<span class="hljs-selector-tag">button</span>,
<span class="hljs-selector-tag">a</span>,
<span class="hljs-selector-attr">[role=<span class="hljs-string">'button'</span>]</span> {
  touch-action: manipulation;
}
</code></pre>
<hr/>
<h2 data-id="heading-18">6. 总结</h2>
<p>回到最初的疑问：React18+Vite5移动端项目，还需要react-fastclick吗？答案很明确——不需要。</p>
<p>现代浏览器早已解决了300ms点击延迟的问题，而React18+Vite5的默认配置（正确的viewport）已经满足了浏览器消除延迟的条件。react-fastclick作为过时的类库，不仅多余，还可能引发兼容性问题。</p>
<p>我们只需要做好两件事：一是保证viewport配置正确，二是优化CSS的touch-action属性，就能轻松实现零延迟的移动端点击交互。如果遇到极端环境的延迟问题，再辅以Pointer Events，就能完美解决所有场景。</p>
<p>希望这篇整理能帮到有同样疑问的同学，避免在新项目中引入不必要的依赖，让项目更轻量、更稳定。</p>
<blockquote>
<p>本次分享就到这儿啦，我是鹏多多，深耕前端的技术创作者，如果您看了觉得有帮助，欢迎评论，关注，点赞，转发，我们下次见~</p>
</blockquote>
<p>PS：在本页按F12，在console中输入document.getElementsByClassName('panel-btn')[0].click();有惊喜哦~</p>
<p><code>往期文章</code></p>
<ul>
<li><a href="https://juejin.cn/post/7568192652286754870" target="_blank" title="https://juejin.cn/post/7568192652286754870">纯前端提取图片颜色插件Color-Thief教学+实战完整指南</a></li>
<li><a href="https://juejin.cn/post/7565737512816771135" target="_blank" title="https://juejin.cn/post/7565737512816771135">react-konva实战指南：Canvas高性能+易维护的组件化图形开发实现教程</a></li>
<li><a href="https://juejin.cn/post/7560905838074462271" target="_blank" title="https://juejin.cn/post/7560905838074462271">React无限滚动插件react-infinite-scroll-component的配置+优化+避坑指南</a></li>
<li><a href="https://juejin.cn/post/7560542615484137491" target="_blank" title="https://juejin.cn/post/7560542615484137491">前端音频兼容解决：音频神器howler.js从基础到进阶完整使用指南</a></li>
<li><a href="https://juejin.cn/post/7559871680015024169" target="_blank" title="https://juejin.cn/post/7559871680015024169">使用React-OAuth进行Google/GitHub登录的教程和案例</a></li>
<li><a href="https://juejin.cn/post/7550585427834404927" target="_blank" title="https://juejin.cn/post/7550585427834404927">纯前端人脸识别利器：face-api.js手把手深入解析教学</a></li>
<li><a href="https://juejin.cn/post/7553865490732433462" target="_blank" title="https://juejin.cn/post/7553865490732433462">关于React父组件调用子组件方法forwardRef的详解和案例</a></li>
<li><a href="https://juejin.cn/post/7553484874609410074" target="_blank" title="https://juejin.cn/post/7553484874609410074">React跨组件数据共享useContext详解和案例</a></li>
<li><a href="https://juejin.cn/post/7545087762837815334" target="_blank" title="https://juejin.cn/post/7545087762837815334">Web图像编辑神器tui.image-editor从基础到进阶的实战指南</a></li>
<li><a href="https://juejin.cn/post/7544323659788288046" target="_blank" title="https://juejin.cn/post/7544323659788288046">开发个人微信小程序类目选择/盈利方式/成本控制与服务器接入指南</a></li>
<li><a href="https://juejin.cn/post/7541741121400864778" target="_blank" title="https://juejin.cn/post/7541741121400864778">前端图片裁剪Cropper.js核心功能与实战技巧详解</a></li>
<li><a href="https://juejin.cn/post/7536530451461472265" target="_blank" title="https://juejin.cn/post/7536530451461472265">编辑器也有邪修？盘点VS Code邪门/有趣的扩展</a></li>
<li><a href="https://juejin.cn/post/7535005018257981466" target="_blank" title="https://juejin.cn/post/7535005018257981466">js使用IntersectionObserver实现目标元素可见度的交互</a></li>
<li><a href="https://juejin.cn/post/7534547200330121225" target="_blank" title="https://juejin.cn/post/7534547200330121225">Web前端页面开发阿拉伯语种适配指南</a></li>
<li><a href="https://juejin.cn/post/7516122409948020736" target="_blank" title="https://juejin.cn/post/7516122409948020736">让网页拥有App体验？PWA 将网页变为桌面应用的保姆级教程PWA</a></li>
<li><a href="https://juejin.cn/post/6953803916484018206" target="_blank" title="https://juejin.cn/post/6953803916484018206">使用nvm管理node.js版本以及更换npm淘宝镜像源</a></li>
<li><a href="https://juejin.cn/post/7140443283209060383" target="_blank" title="https://juejin.cn/post/7140443283209060383">手把手教你搭建规范的团队vue项目，包含commitlint，eslint，prettier，husky，commitizen等等</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用一个粒子效果告别蛇年迎来马年~]]></title>    <link>https://juejin.cn/post/7604036853129756687</link>    <guid>https://juejin.cn/post/7604036853129756687</guid>    <pubDate>2026-02-09T03:00:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604036853129756687" data-draft-id="7603958579180077056" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用一个粒子效果告别蛇年迎来马年~"/> <meta itemprop="keywords" content="前端,JavaScript,three.js"/> <meta itemprop="datePublished" content="2026-02-09T03:00:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苏武难飞"/> <meta itemprop="url" content="https://juejin.cn/user/2664871913328478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用一个粒子效果告别蛇年迎来马年~
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2664871913328478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苏武难飞
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:00:46.000Z" title="Mon Feb 09 2026 03:00:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们即将迎来马年，随手整了一个粒子切换效果，在这里分享给大家，本期功能实现主要是运用了<code>Three.JS</code>!</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64878ee4bd304ea2a98f31e784d94160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=7UC6v84%2B0AYHTEXORciHeRtqbzQ%3D" alt="cover2" loading="lazy"/></p>
<h2 data-id="heading-0">1.加载模型</h2>
<p>这种物体的形状很难通过纯数学公式推导出来，所以我是在<a href="https://link.juejin.cn?target=https%3A%2F%2Fsketchfab.com%2Ffeed" target="_blank" title="https://sketchfab.com/feed" ref="nofollow noopener noreferrer">sketchfab</a>上找的两个模型</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/088285f417824fc399faffa3b9c18381~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=Iz4ijRil%2BEnxEnBkwMVnJw%2BNj00%3D" alt="20260208174832" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/237c0c003d894fc59406f5017c92d6a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=%2FbfSN0uYlpyACCZvD7ZwKgKGzTU%3D" alt="20260208174916" loading="lazy"/></p>
<p>这两个模型都是<code>.glb</code>类型的，在<code>Three.JS</code>中我们可以通过<code>GLTFLoader</code>和<code>DRACOLoader</code>很轻松的加载这种类型的模型文件！</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> dracoLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DRACOLoader</span>()
dracoLoader.<span class="hljs-title function_">setDecoderPath</span>(<span class="hljs-string">'/draco/'</span>)

<span class="hljs-keyword">const</span> gltfLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>()
gltfLoader.<span class="hljs-title function_">setDRACOLoader</span>(dracoLoader)

<span class="hljs-keyword">const</span> gltf = <span class="hljs-keyword">await</span> gltfLoader.<span class="hljs-title function_">loadAsync</span>(path);
<span class="hljs-keyword">const</span> model = gltf.<span class="hljs-property">scene</span>;
</code></pre>
<p>关于<code>DRACOLoader</code></p>
<blockquote>
<p>简单来说，<code>DRACOLoader</code> 是 <code>Three.js</code> 中专门用来解压经过 Draco 压缩过的 3D 模型的“解压器”。</p>
<p>如果你在开发 WebGL 项目时发现模型文件（通常是 .gltf 或 .glb）太大，导致加载缓慢，你通常会使用 Google 开发的 Draco 算法 对模型进行压缩。而 <code>DRACOLoader</code> 就是为了让浏览器能读懂这些压缩数据而存在的。</p>
</blockquote>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> dracoLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DRACOLoader</span>()
dracoLoader.<span class="hljs-title function_">setDecoderPath</span>(<span class="hljs-string">'/draco/'</span>)

<span class="hljs-keyword">const</span> gltfLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>()
gltfLoader.<span class="hljs-title function_">setDRACOLoader</span>(dracoLoader)

<span class="hljs-keyword">const</span> modelFiles = [
    {<span class="hljs-attr">path</span>: <span class="hljs-string">'/snake_model.glb'</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">position</span>: {<span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">0</span>}},
    {<span class="hljs-attr">path</span>: <span class="hljs-string">'/horse.glb'</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">position</span>: {<span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: -<span class="hljs-number">14</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">0</span>}}
];


<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> modelConfig <span class="hljs-keyword">of</span> modelFiles) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> gltf = <span class="hljs-keyword">await</span> gltfLoader.<span class="hljs-title function_">loadAsync</span>(modelConfig.<span class="hljs-property">path</span>);
        <span class="hljs-keyword">const</span> model = gltf.<span class="hljs-property">scene</span>;
        model.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(modelConfig.<span class="hljs-property">scale</span>, modelConfig.<span class="hljs-property">scale</span>, modelConfig.<span class="hljs-property">scale</span>);
        model.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(modelConfig.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, modelConfig.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>, modelConfig.<span class="hljs-property">position</span>.<span class="hljs-property">z</span>);
        model.<span class="hljs-title function_">updateMatrixWorld</span>(<span class="hljs-literal">true</span>);
        scene.<span class="hljs-title function_">add</span>(model);

        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Loaded: <span class="hljs-subst">${modelConfig.path}</span>`</span>);
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Failed to load <span class="hljs-subst">${modelConfig.path}</span>:`</span>, error);
    }
}
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d485e9717fd4114add1b82c7662e939~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=bWSltcN7p%2FwyOgeKzgLkWb4FsjE%3D" alt="20260209091146" loading="lazy"/></p>
<h2 data-id="heading-1">2.模型粒子化</h2>
<p>现在我们的两个模型已经成功加载，我们的模型<strong>粒子化</strong>的思路是拿到模型的顶点数据然后使用<code>new THREE.Points</code>来展示，所以我们先隐藏我们的模型文件</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> modelConfig <span class="hljs-keyword">of</span> modelFiles) {
    <span class="hljs-keyword">try</span> {
        ...
        ...
      - scene.<span class="hljs-title function_">add</span>(model);
      + model.<span class="hljs-property">visible</span> = <span class="hljs-literal">false</span>;
    
    } <span class="hljs-keyword">catch</span> (error) {
        
    }
}
</code></pre>
<h3 data-id="heading-2">2.1 MeshSurfaceSampler</h3>
<blockquote>
<p><code>MeshSurfaceSampler</code> 是 Three.js 扩展库（<code>three/examples/jsm/math/MeshSurfaceSampler.js</code>）中的一个实用类。它通过加权随机算法，根据模型表面的几何面积分布，在三角形网格上提取随机点的坐标、法线以及颜色。</p>
</blockquote>
<p>通俗的来说我们的模型是由许多个三角形组成的，<code>MeshSurfaceSampler</code>通过算法会判断三角形面积，如果更大的三角形则权重更多被分配的点也就更多！</p>
<p>举个栗子🌰</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MeshSurfaceSampler</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'three/examples/jsm/math/MeshSurfaceSampler.js'</span>;

<span class="hljs-comment">// 1. 创建采样器</span>
<span class="hljs-keyword">const</span> sampler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeshSurfaceSampler</span>(yourLoadedMesh)
    .<span class="hljs-title function_">setWeightAttribute</span>(<span class="hljs-string">'color'</span>) <span class="hljs-comment">// 可选：如果有颜色属性，可以按颜色密度采样</span>
    .<span class="hljs-title function_">build</span>();

<span class="hljs-comment">// 2. 采样循环</span>
<span class="hljs-keyword">const</span> tempPosition = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>();
<span class="hljs-keyword">const</span> tempNormal = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>();

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; particleCount; i++) {
    sampler.<span class="hljs-title function_">sample</span>(tempPosition, tempNormal);
    
    <span class="hljs-comment">// 将采样到的位置存入数组或属性中</span>
    positions.<span class="hljs-title function_">push</span>(tempPosition.<span class="hljs-property">x</span>, tempPosition.<span class="hljs-property">y</span>, tempPosition.<span class="hljs-property">z</span>);
}
</code></pre>
<h3 data-id="heading-3">2.2 合并Mash</h3>
<p>从上面的例子我们能看到<code>MeshSurfaceSampler</code>接收的是一个单一的<code>Mesh</code>，但是我们的模型可能会包含多个<code>Mesh</code>，比如本次案例中的<code>蛇</code>，<code>马</code>都是有两个<code>Mesh</code>，所以在使用<code>MeshSurfaceSampler</code>前我们需要把多个<code>Mesh</code>合并成一个！</p>
<blockquote>
<p><code>BufferGeometryUtils.mergeGeometries</code> 是 Three.js 扩展库 <code>BufferGeometryUtils</code> 中的一个静态方法。它的主要作用是将一组 <code>BufferGeometry</code> 合并成一个单一的几何体。</p>
</blockquote>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMergedMeshFromScene</span>(<span class="hljs-params">scene</span>) {
    <span class="hljs-keyword">const</span> geometries = [];

    scene.<span class="hljs-title function_">updateMatrixWorld</span>(<span class="hljs-literal">true</span>);

    scene.<span class="hljs-title function_">traverse</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">isMesh</span>) {
            <span class="hljs-keyword">const</span> clonedGeom = child.<span class="hljs-property">geometry</span>.<span class="hljs-title function_">clone</span>();
            clonedGeom.<span class="hljs-title function_">applyMatrix4</span>(child.<span class="hljs-property">matrixWorld</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> clonedGeom.<span class="hljs-property">attributes</span>) {
                <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'position'</span>) clonedGeom.<span class="hljs-title function_">deleteAttribute</span>(key);
            }
            geometries.<span class="hljs-title function_">push</span>(clonedGeom);
        }
    });

    <span class="hljs-comment">// 合并所有几何体</span>
    <span class="hljs-keyword">const</span> mergedGeometry = <span class="hljs-title class_">BufferGeometryUtils</span>.<span class="hljs-title function_">mergeGeometries</span>(geometries);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(mergedGeometry);
}
</code></pre>
<h3 data-id="heading-4">2.3 展示粒子</h3>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePositionsFromModel</span>(<span class="hljs-params">mesh, totalCount = particleCount</span>) {
    <span class="hljs-keyword">const</span> positions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(totalCount * <span class="hljs-number">3</span>);

    <span class="hljs-keyword">const</span> tempPosition = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>();

    <span class="hljs-keyword">const</span> sampler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeshSurfaceSampler</span>(mesh).<span class="hljs-title function_">build</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalCount; i++) {
        sampler.<span class="hljs-title function_">sample</span>(tempPosition);
        tempPosition.<span class="hljs-title function_">applyMatrix4</span>(mesh.<span class="hljs-property">matrixWorld</span>);
        <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span>;
        positions[i3] = tempPosition.<span class="hljs-property">x</span>;
        positions[i3 + <span class="hljs-number">1</span>] = tempPosition.<span class="hljs-property">y</span>;
        positions[i3 + <span class="hljs-number">2</span>] = tempPosition.<span class="hljs-property">z</span>;
    }

    <span class="hljs-keyword">return</span> {positions};
}


 <span class="hljs-keyword">const</span> modelData = <span class="hljs-title function_">generatePositionsFromModel</span>(<span class="hljs-title function_">getMergedMeshFromScene</span>(model), particleCount);
 modelDataArray.<span class="hljs-title function_">push</span>(modelData);
</code></pre>
<p>现在我们已经有了模型的顶点坐标只需要使用<code>THREE.Points</code>配合<code>THREE.PointsMaterial</code></p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeParticles</span>(<span class="hljs-params">modelData</span>) {

    <span class="hljs-keyword">const</span> {positions} = modelData;

    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>();

    geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'position'</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(positions, <span class="hljs-number">3</span>));
    
    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointsMaterial</span>({
        <span class="hljs-attr">color</span>: <span class="hljs-number">0xffffff</span>,      
        <span class="hljs-attr">size</span>: <span class="hljs-number">0.5</span>,             
        <span class="hljs-attr">sizeAttenuation</span>: <span class="hljs-literal">true</span>, 
        <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.8</span>
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Points</span>(geometry, material);
}

<span class="hljs-keyword">const</span> particles = <span class="hljs-title function_">makeParticles</span>(modelDataArray[<span class="hljs-number">0</span>]);
scene.<span class="hljs-title function_">add</span>(particles);
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bc5a6dea7a8467a8b509f177e7590be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=8poLZrRhoCHZBmYa%2Bt9EYv0ZmrA%3D" alt="20260209093343" loading="lazy"/></p>
<p>我们的粒子小蛇就展示出来了，只不过现在这个粒子还很粗糙，我们会在后面优化~</p>
<h2 data-id="heading-5">3.粒子切换</h2>
<p>现在我们的粒子已经成功展示！根据前面两步我们能知道粒子的展示就是根据模型的顶点来计算的，所以从一个模型切换到另一个模型就是单纯的顶点切换！</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginMorph</span>(<span class="hljs-params">index</span>) {
    isTrans = <span class="hljs-literal">true</span>;
    prog = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> fromPts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(particles.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">array</span>);
    <span class="hljs-keyword">const</span> modelData = <span class="hljs-title function_">generatePositionsFromModel</span>(<span class="hljs-title function_">getMergedMeshFromScene</span>(rawModel[index]), particleCount);
    <span class="hljs-keyword">const</span> toPts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(modelData.<span class="hljs-property">positions</span>);

    particles.<span class="hljs-property">userData</span> = {<span class="hljs-attr">from</span>: fromPts, <span class="hljs-attr">to</span>: toPts};
}
</code></pre>
<p>通过<code>beginMorph</code>我们把当前的粒子状态和目标状态存入到<code>userData</code>中，然后在<code>tick</code>中进行动画处理</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> morphSpeed = <span class="hljs-number">.03</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(tick)
    controls.<span class="hljs-title function_">update</span>()

    <span class="hljs-keyword">if</span> (isTrans) {
        prog += morphSpeed;
        <span class="hljs-comment">// 使用平滑的缓动函数</span>
        <span class="hljs-keyword">const</span> eased = prog &gt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">1</span> - prog, <span class="hljs-number">3</span>);

        <span class="hljs-keyword">const</span> { <span class="hljs-keyword">from</span>, to } = particles.<span class="hljs-property">userData</span>;
        <span class="hljs-keyword">const</span> particleArr = particles.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">array</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; particleArr.<span class="hljs-property">length</span>; i++) {
            particleArr[i] = <span class="hljs-keyword">from</span>[i] + (to[i] - <span class="hljs-keyword">from</span>[i]) * eased;
        }
        <span class="hljs-comment">// 通知 GPU 更新</span>
        particles.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (prog &gt;= <span class="hljs-number">1</span>) isTrans = <span class="hljs-literal">false</span>;
    }


    renderer.<span class="hljs-title function_">render</span>(scene, camera);
}
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/920fdab2951e463184f699de8a4ecc87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=9dnr%2FfAG2oTmHiO92JrGvNcZx0g%3D" alt="change" loading="lazy"/></p>
<p>此时我们基础的粒子切换效果就已经实现啦！</p>
<h2 data-id="heading-6">4.粒子优化</h2>
<p>此时我们的粒子效果还是存在几个问题的！</p>
<ul>
<li>大小固定/粒子是正方形</li>
<li>没有颜色</li>
<li>效果单调</li>
</ul>
<p>要解决上面几个问题我们还使用<code>THREE.PointsMaterial</code>就有点不够看了，接下来我们使用<code>THREE.ShaderMaterial</code>搭配自定义着色器来优化效果！</p>
<h3 data-id="heading-7">4.1 大小随机化/粒子改为圆形</h3>
<p>我们想让粒子的大小产生一个随机变化就要考虑通过顶点着色器中<code>gl_PointSize</code>来随机改变粒子大小！粒子改为圆形就要在片元着色器中修改<code>gl_FragColor</code>!</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePositionsFromModel</span>(<span class="hljs-params">mesh, totalCount = particleCount</span>) {
    <span class="hljs-keyword">const</span> positions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(totalCount * <span class="hljs-number">3</span>);
    <span class="hljs-keyword">const</span> sizes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(totalCount);
    <span class="hljs-keyword">const</span> rnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(totalCount * <span class="hljs-number">3</span>);

    <span class="hljs-keyword">const</span> tempPosition = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>();

    <span class="hljs-keyword">const</span> sampler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeshSurfaceSampler</span>(mesh).<span class="hljs-title function_">build</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalCount; i++) {
        sizes[i] = <span class="hljs-number">.7</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1.1</span>;
        sampler.<span class="hljs-title function_">sample</span>(tempPosition);
        tempPosition.<span class="hljs-title function_">applyMatrix4</span>(mesh.<span class="hljs-property">matrixWorld</span>);
        <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span>;
        positions[i3] = tempPosition.<span class="hljs-property">x</span>;
        positions[i3 + <span class="hljs-number">1</span>] = tempPosition.<span class="hljs-property">y</span>;
        positions[i3 + <span class="hljs-number">2</span>] = tempPosition.<span class="hljs-property">z</span>;

        rnd[i3] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>;
        rnd[i3 + <span class="hljs-number">1</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>;
        rnd[i3 + <span class="hljs-number">2</span>] = <span class="hljs-number">.5</span> + <span class="hljs-number">.5</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
    }

    <span class="hljs-keyword">return</span> {positions, sizes, rnd};
}
</code></pre>
<p>首先修改<code>generatePositionsFromModel</code>方法，针对每个顶点坐标产生一组随机数范围在<code>.7 ~ .77</code></p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeParticles</span>(<span class="hljs-params">modelData</span>) {

    <span class="hljs-keyword">const</span> {positions, sizes, rnd} = modelData;

    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>();

    geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'position'</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(positions, <span class="hljs-number">3</span>));
    geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'size'</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(sizes, <span class="hljs-number">1</span>))
    geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">"random"</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(rnd, <span class="hljs-number">3</span>));

    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">ShaderMaterial</span>({
        <span class="hljs-attr">uniforms</span>: {<span class="hljs-attr">time</span>: {<span class="hljs-attr">value</span>: <span class="hljs-number">0</span>}, <span class="hljs-attr">hueSpeed</span>: {<span class="hljs-attr">value</span>: <span class="hljs-number">0.12</span>}},
        <span class="hljs-attr">vertexShader</span>: ..., 
        <span class="hljs-attr">fragmentShader</span>: ...,
        <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>, 
        <span class="hljs-attr">depthWrite</span>: <span class="hljs-literal">false</span>, 
        <span class="hljs-attr">vertexColors</span>: <span class="hljs-literal">true</span>, 
        <span class="hljs-attr">blending</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">AdditiveBlending</span>
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Points</span>(geometry, material);
}
</code></pre>
<pre><code class="hljs language-glsl" lang="glsl">uniform float time;
attribute float size;
attribute vec3 random;
varying vec3 vCol;
varying float vR;
void main(){
    vec3 p=position;
    vec4 mv=modelViewMatrix*vec4(p,1.);
    float pulse=.9+.1*sin(time*1.15+random.y);
    gl_PointSize=size*pulse*(350./-mv.z);
    gl_Position=projectionMatrix*mv;
}
</code></pre>
<pre><code class="hljs language-glsl" lang="glsl">uniform float time;
void main() {
    float d = length(gl_PointCoord - vec2(0.5));
    float alpha = 1.0 - smoothstep(0.4, 0.5, d);
    if (alpha &lt; 0.01) discard;
    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
}
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd00e608ac8b470fb68a8980c65cf997~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=I2rC4aQEcBmixelgJ85fxh7xbKE%3D" alt="20260209100331" loading="lazy"/></p>
<p>此时的粒子就大小改为随机并且是圆形粒子了~</p>
<h3 data-id="heading-8">4.2 粒子添加颜色</h3>
<p>粒子添加颜色和上一步的粒子大小类似都需要针对每一个顶点生成一个随机的颜色</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> palette = [<span class="hljs-number">0xff3c78</span>, <span class="hljs-number">0xff8c00</span>, <span class="hljs-number">0xfff200</span>, <span class="hljs-number">0x00cfff</span>, <span class="hljs-number">0xb400ff</span>, <span class="hljs-number">0xffffff</span>, <span class="hljs-number">0xff4040</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>(c));

    <span class="hljs-keyword">const</span> tempPosition = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>();

    <span class="hljs-keyword">const</span> sampler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeshSurfaceSampler</span>(mesh).<span class="hljs-title function_">build</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalCount; i++) {
        ...
        ...

        <span class="hljs-keyword">const</span> base = palette[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * palette.<span class="hljs-property">length</span> | <span class="hljs-number">0</span>], hsl = {<span class="hljs-attr">h</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">s</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">l</span>: <span class="hljs-number">0</span>};
        base.<span class="hljs-title function_">getHSL</span>(hsl);
        hsl.<span class="hljs-property">h</span> += (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">.5</span>) * <span class="hljs-number">.05</span>;
        hsl.<span class="hljs-property">s</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">.7</span>, hsl.<span class="hljs-property">s</span> + (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">.5</span>) * <span class="hljs-number">.3</span>));
        hsl.<span class="hljs-property">l</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">.9</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">.5</span>, hsl.<span class="hljs-property">l</span> + (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">.5</span>) * <span class="hljs-number">.4</span>));

        <span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>().<span class="hljs-title function_">setHSL</span>(hsl.<span class="hljs-property">h</span>, hsl.<span class="hljs-property">s</span>, hsl.<span class="hljs-property">l</span>);
        colors[i3] = c.<span class="hljs-property">r</span>;
        colors[i3 + <span class="hljs-number">1</span>] = c.<span class="hljs-property">g</span>;
        colors[i3 + <span class="hljs-number">2</span>] = c.<span class="hljs-property">b</span>;

        ...
    }
</code></pre>
<p>修改片元着色器</p>
<pre><code class="hljs language-glsl" lang="glsl">uniform float time;
uniform float hueSpeed;
varying vec3 vCol;
varying float vR;

vec3 hueShift(vec3 c, float h) {
    const vec3 k = vec3(0.57735);
    float cosA = cos(h);
    float sinA = sin(h);
    return c * cosA + cross(k, c) * sinA + k * dot(k, c) * (1.0 - cosA);
}

void main() {
    vec2 uv = gl_PointCoord - 0.5;
    float d = length(uv);

    float core = smoothstep(0.05, 0.0, d);
    float angle = atan(uv.y, uv.x);
    float flare = pow(max(0.0, sin(angle * 6.0 + time * 2.0 * vR)), 4.0);
    flare *= smoothstep(0.5, 0.0, d);
    float glow = smoothstep(0.4, 0.1, d);

    float alpha = core * 1.0 + flare * 0.5 + glow * 0.2;

    vec3 color = hueShift(vCol, time * hueSpeed);
    vec3 finalColor = mix(color, vec3(1.0, 0.95, 0.9), core);
    finalColor = mix(finalColor, color, flare * 0.5 + glow * 0.5);

    if (alpha &lt; 0.01) discard;

    gl_FragColor = vec4(finalColor, alpha);
}
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/926c274a5cea49ba9a1984b553e17f2e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5q2m6Zq-6aOe:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210846&amp;x-signature=3%2FWmfEWW9Zv5yiw3r%2BDcCpCj2GY%3D" alt="20260209100747" loading="lazy"/></p>
<h3 data-id="heading-9">4.3 设置亮度差</h3>
<p>现在我们的粒子看着还是略显单调！我们可以给粒子做局部提亮！</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createSparkles</span>(<span class="hljs-params"/>) {

    <span class="hljs-keyword">const</span> geo = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>();
    <span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(particleSparkCount * <span class="hljs-number">3</span>);
    <span class="hljs-keyword">const</span> size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(particleSparkCount);
    <span class="hljs-keyword">const</span> rnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(particleSparkCount * <span class="hljs-number">3</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; particleSparkCount; i++) {
        size[i] = <span class="hljs-number">0.5</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">0.8</span>;
        rnd[i * <span class="hljs-number">3</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>;
        rnd[i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>;
        rnd[i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>] = <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
    }
    geo.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'position'</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(pos, <span class="hljs-number">3</span>));
    geo.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'size'</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(size, <span class="hljs-number">1</span>));
    geo.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'random'</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(rnd, <span class="hljs-number">3</span>));

    <span class="hljs-keyword">const</span> mat = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">ShaderMaterial</span>({
        <span class="hljs-attr">uniforms</span>: {<span class="hljs-attr">time</span>: {<span class="hljs-attr">value</span>: <span class="hljs-number">0</span>}},
        <span class="hljs-attr">vertexShader</span>: <span class="hljs-string">`
            uniform float time;
            attribute float size;
            attribute vec3 random;
            void main() {
                vec3 p = position;
                float t = time * 0.25 * random.z;
                float ax = t + random.y, ay = t * 0.75 + random.x;
                float amp = (0.6 + sin(random.x + t * 0.6) * 0.3) * random.z;
                p.x += sin(ax + p.y * 0.06 + random.x * 0.1) * amp;
                p.y += cos(ay + p.z * 0.06 + random.y * 0.1) * amp;
                p.z += sin(ax * 0.85 + p.x * 0.06 + random.z * 0.1) * amp;
                vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }`</span>,
        <span class="hljs-attr">fragmentShader</span>: <span class="hljs-string">`
            uniform float time;
            void main() {
                float d = length(gl_PointCoord - vec2(0.5));
                float alpha = 1.0 - smoothstep(0.4, 0.5, d);
                if (alpha &lt; 0.01) discard;
                gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
            }`</span>,
        <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">depthWrite</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">blending</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">AdditiveBlending</span>
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Points</span>(geo, mat);
}

<span class="hljs-keyword">const</span> particlesSpark = <span class="hljs-title function_">createSparkles</span>(modelDataArray[<span class="hljs-number">0</span>])
scene.<span class="hljs-title function_">add</span>(particlesSpark);


<span class="hljs-keyword">const</span> targetPositions = modelDataArray[<span class="hljs-number">0</span>].<span class="hljs-property">positions</span>;

<span class="hljs-keyword">const</span> particleArr = particles.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">array</span>;
<span class="hljs-keyword">const</span> sparkleArr = particlesSpark.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">array</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; particleCount; j++) {
    <span class="hljs-keyword">const</span> idx = j * <span class="hljs-number">3</span>;

    <span class="hljs-comment">// 直接从 targetPositions 拷贝三个连续的数值 (x, y, z)</span>
    particleArr[idx] = targetPositions[idx];
    particleArr[idx + <span class="hljs-number">1</span>] = targetPositions[idx + <span class="hljs-number">1</span>];
    particleArr[idx + <span class="hljs-number">2</span>] = targetPositions[idx + <span class="hljs-number">2</span>];

    <span class="hljs-comment">// 同步更新闪烁粒子</span>
    <span class="hljs-keyword">if</span> (j &lt; particleSparkCount) {
        sparkleArr[idx] = targetPositions[idx];
        sparkleArr[idx + <span class="hljs-number">1</span>] = targetPositions[idx + <span class="hljs-number">1</span>];
        sparkleArr[idx + <span class="hljs-number">2</span>] = targetPositions[idx + <span class="hljs-number">2</span>];
    }
}

<span class="hljs-comment">// 必须通知 GPU 更新</span>
particles.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>;
particlesSpark.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>;

</code></pre>
<p><img alt="20260209102034转存失败，建议直接上传图片文件" src="" loading="lazy"/></p>
<p>我们又添加了一个<code>createSparkles</code>然后粒子位置和最开始的模型粒子位置一致，只不过颜色我们设置成白色！但是到这还没结束！我们的提亮魔法还要依靠<code>THREE</code>的后期处理能力!</p>
<blockquote>
<p><code>EffectComposer</code> 是 <code>Three.js</code> 的 后期处理（Post-processing）管理器。它负责管理一个“通道（Pass）”队列。它不再直接将场景渲染到画布上，而是渲染到一个或多个缓冲帧中，经过各种视觉特效处理后，再呈现给用户。</p>
</blockquote>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> composer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EffectComposer</span>(renderer);
composer.<span class="hljs-title function_">addPass</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderPass</span>(scene, camera));
composer.<span class="hljs-title function_">addPass</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UnrealBloomPass</span>(<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(innerWidth, innerHeight), <span class="hljs-number">.45</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">.85</span>));
<span class="hljs-keyword">const</span> after = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AfterimagePass</span>();
after.<span class="hljs-property">uniforms</span>.<span class="hljs-property">damp</span>.<span class="hljs-property">value</span> = <span class="hljs-number">.92</span>;
composer.<span class="hljs-title function_">addPass</span>(after);
composer.<span class="hljs-title function_">addPass</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputPass</span>());
</code></pre>
<ul>
<li>UnrealBloomPass 是用来做荧光、发光的效果</li>
<li>AfterimagePass 是用来做拖尾影效果</li>
</ul>
<p><span href="https://code.juejin.cn/pen/7604689619694649390" class="code-editor-container"><iframe class="code-editor-frame" data-code="code-editor-element" data-code-id="7604689619694649390" data-src="https://code.juejin.cn/pen/7604689619694649390" style="display:none;" loading="lazy"/><span class="loading-placeholder" style="display:none"><img class="placeholder-image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC" loading="lazy"/><span class="loading-logo"/></span></span></p>
<h2 data-id="heading-10">结束语</h2>
<p>希望所有人 2026 事事如意！</p>
<h2 data-id="heading-11">参考代码</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcodepen.io%2FVoXelo%2Fpen%2FqEOEyLV" target="_blank" title="https://codepen.io/VoXelo/pen/qEOEyLV" ref="nofollow noopener noreferrer">Three.js &amp; GLSL Particle Metamorphosis</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[LangChain之链]LangChain的Chain——由Runnable构建的管道]]></title>    <link>https://juejin.cn/post/7604084016509960233</link>    <guid>https://juejin.cn/post/7604084016509960233</guid>    <pubDate>2026-02-09T01:48:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016509960233" data-draft-id="7603783314713821220" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[LangChain之链]LangChain的Chain——由Runnable构建的管道"/> <meta itemprop="keywords" content="LangChain,Python"/> <meta itemprop="datePublished" content="2026-02-09T01:48:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JaydenAI"/> <meta itemprop="url" content="https://juejin.cn/user/3001011641261209"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [LangChain之链]LangChain的Chain——由Runnable构建的管道
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3001011641261209/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JaydenAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:48:20.000Z" title="Mon Feb 09 2026 01:48:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 LangChain 中，<code>Chain</code> 指的是对多个组件（如 Prompt、LLM和OutputPparser等）的一系列调用流程。它具有两种实现方式，即传统的以<code>LLMChain</code>为代表的“老链”和最新的采用<code>LCEL</code>（LangChain Exppression Language）的“新链”。</p>
<h2 data-id="heading-0">1. 传统“老链”</h2>
<p>从传统链（Legacy Chains）到 LCEL的演进是一次从“命令式封装”向“声明式组合”的重大飞跃。早期的 <code>LangChain</code> 依靠一系列硬编码的类（如<code>LLMChain</code>和<code>RetrievalQA</code>）来构建应用。开发者调用特定的类，内部逻辑在这些类中被高度封装，定制起来比较麻烦。比如 提示词往往隐藏在源代码中，修改不便。接口不统一也是一个硬伤，不同的链可能需要不同的输入输出格式。而最大的问题还是功能扩展难，想要在中间步骤添加自定义逻辑（如中间处理、日志）非常繁琐。</p>
<p>在如下的演示程序中，我们利用<code>LLMChain</code>实现了一个典型的应用场景：传入参数格式化提示词模板，将生成的提示词作为输入调用LLM并解析输出。这个流程涉及的三个步骤需要对应的三个组件，分别是表示提示词模板的<code>ChatPromptTemplate</code>、<code>LLM</code>模型（<code>ChatOpenAI</code>）和用于解析输出的<code>StrOutputParser</code>。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate
<span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser
<span class="hljs-keyword">from</span> langchain_classic.chains  <span class="hljs-keyword">import</span> LLMChain

prompt = ChatPromptTemplate.from_template(<span class="hljs-string">"Give me small report about {topic}"</span>)
model = ChatOpenAI(
    model=<span class="hljs-string">"gpt-5.2-chat"</span>,
    base_url=<span class="hljs-string">"base url of your deployed model"</span>,
    api_key=<span class="hljs-string">"your api key"</span>
)
parser = StrOutputParser()
chain = LLMChain(
    prompt=prompt,
    llm=model,
    output_parser=parser
)
result = chain.run(topic=<span class="hljs-string">"Artificial Intelligence"</span>)
<span class="hljs-built_in">print</span>(result)
</code></pre>
<p>我们将三个组件作为参数调用构造函数构建<code>LLMChain</code>对象，然后将提示词模板的占位符参数作为输入调用它的<code>run</code>方法，最终就会得到我们希望看到的文体，前面的输出内容如下所示：</p>
<pre><code class="hljs language-csharp" lang="csharp">**Small Report <span class="hljs-keyword">on</span> Artificial Intelligence**

<span class="hljs-function">Artificial <span class="hljs-title">Intelligence</span> (<span class="hljs-params">AI</span>) <span class="hljs-keyword">is</span> a branch of computer science focused <span class="hljs-keyword">on</span> creating machines <span class="hljs-keyword">and</span> systems capable of performing tasks that normally require human intelligence  result</span> = chain.run(topic=<span class="hljs-string">"Artificial Intelligence"</span>)
…
</code></pre>
<h2 data-id="heading-1">2. 基于LCEL的“新链”</h2>
<p>正如前面所说，整个链作为作为一个黑盒被完全封装到<code>LLMChain</code>中，我们根本不知道背后的链路是什么样子，更不用说对它进行定制了。这种传统的编程模式已经基本没有使用了，取而代之的是如下所示的基于LCEL编写的管道。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate
<span class="hljs-keyword">from</span> langchain.schema.output_parser <span class="hljs-keyword">import</span> StrOutputParser

prompt = ChatPromptTemplate.from_template(<span class="hljs-string">"Give me small report about {topic}"</span>)
model = ChatOpenAI(
    model=<span class="hljs-string">"gpt-5.2-chat"</span>,
    base_url=<span class="hljs-string">"base url of your deployed model"</span>,
    api_key=<span class="hljs-string">"your api key"</span>
)
parser = StrOutputParser()

chain = prompt | model | parser
result = chain.invoke({<span class="hljs-string">"topic"</span>: <span class="hljs-string">"artificial intelligence"</span>})
<span class="hljs-built_in">print</span>(result)
</code></pre>
<p>我们无需任何封装链类型，而是直接使用类似于Unix管道命令的方式直接将三个核心组件组成一个链，简单且直观。关键是定制起来也容易，添加、替换和删除管道的组件都很方便。</p>
<h2 data-id="heading-2">3. 模拟实现</h2>
<p>其实这种基于管道定义链路的实现很简单，它也不是<code>LangChain</code>特有，很多用于处理HTTP请求的Web框架都是采用这种设计。<code>LangChain</code>基于LCEL的链依赖一个名为<code>Runnable</code>的抽象类，它可以表示链路有个关键的组件，链本身也是一个<code>Runnable</code>对象，这是一种典型的“组合”设计模式。<code>Runnable</code>是本系列文章关注的核心，在正式介绍它之前，我们使用最简单的代码定义模拟它的实现。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations
<span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> (<span class="hljs-type">Callable</span>, <span class="hljs-type">Generic</span>, TypeVar, <span class="hljs-type">Any</span>)

Input = TypeVar(<span class="hljs-string">'Input'</span>)
Output = TypeVar(<span class="hljs-string">'Output'</span>)
Other = TypeVar(<span class="hljs-string">'Other'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Runnable</span>[Input, Output](ABC):    
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span>: Input</span>) -&gt; Output:
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__or__</span>(<span class="hljs-params">self, other: Runnable[Output, Other]</span>) -&gt; Runnable[Input, Other]:
        <span class="hljs-keyword">return</span> ComposibleRunnable(self, other)
    
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ComposibleRunnable</span>(Runnable[Input, Output]):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, first: Runnable[Input, <span class="hljs-type">Any</span>], second: Runnable[<span class="hljs-type">Any</span>, Output]</span>):
        self.first = first
        self.second = second
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span>: Input</span>) -&gt; Output: 
        <span class="hljs-keyword">return</span> self.second.invoke(self.first.invoke(<span class="hljs-built_in">input</span>))
</code></pre>
<p>我们将<code>Runnable</code>定义成抽象的泛型类，Input和Output类型变量表示它的输入和输出类型。既然命名为<code>Runnable</code>，意味着它可以被调用来完成某种任务，这体现在它的抽象方法invoke方法上，它具有一个类型为Input的参数。由于我们需要使用管道符号“|”，所以我们将管道操作实现在重写的<code>__or__</code>方法中，另一个与之组合的类型为<code>Runnable[Output, Other]</code>，两者组合的链条就是一个<code>Runnable[Input, Other]</code>对象。该方法具体返回的是一个<code>ComposibleRunnable[Input, Other]</code>对象。</p>
<p>如下这个<code>RunnableLamda[Input,Output]</code>类型是对<code>Runnable[Input, Output]</code>这个抽象类的实现，在它重写的<code>invoke</code>方法中，执行的操作是在构造函数中指定的Callable[[Input], Output]对象。我们创建了它的三个实例，分别针对三项基本数学运算：自增、倍乘和以2为底的对数。我们将它们以管道的形式构成一个链，并对传入的参数3实施运算。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> math  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableLamda</span>(Runnable,<span class="hljs-type">Generic</span>[Input,Output]):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func: <span class="hljs-type">Callable</span>[[Input], Output]</span>):
        self.func = func
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span>: Input</span>) -&gt; Output:   
        <span class="hljs-keyword">return</span> self.func(<span class="hljs-built_in">input</span>)

increase = RunnableLamda(<span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">1</span>)
double = RunnableLamda(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>)
log2 = RunnableLamda(math.log2)

chain = increase | double | log2
result = chain.invoke(<span class="hljs-number">3</span>)  
<span class="hljs-keyword">assert</span> result == <span class="hljs-number">3.0</span> <span class="hljs-comment"># ((3 + 1) * 2) -&gt; log2(8) -&gt; 3.0</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[二叉树遍历思维实战]]></title>    <link>https://juejin.cn/post/7604039449468207154</link>    <guid>https://juejin.cn/post/7604039449468207154</guid>    <pubDate>2026-02-09T03:02:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604039449468207154" data-draft-id="7604080364354027547" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="二叉树遍历思维实战"/> <meta itemprop="keywords" content="后端,JavaScript,算法"/> <meta itemprop="datePublished" content="2026-02-09T03:02:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            二叉树遍历思维实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:02:37.000Z" title="Mon Feb 09 2026 03:02:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">二叉树遍历思维实战</h2>
<p>在算法面试中，二叉树是绕不开的基础核心，而「遍历」更是解决二叉树问题的「万能钥匙」。无论是根到叶的路径统计、层间节点的特殊处理，还是路径值的计算与判断，只要题目围绕二叉树的「树枝」做文章，用遍历思维解题都会无比自然、高效。</p>
<p>很多新手在面对二叉树题时，容易陷入「一题一解」的困境，每道题都重新设计遍历逻辑，既浪费时间又容易出错。实际上，二叉树的遍历题高度同质化，只需掌握两套通用模板，再根据题目需求修改核心业务逻辑，就能轻松搞定90%的高频考点。</p>
<p>本文将从「模板提炼→实战拆解→避坑优化」三个维度，手把手教你用遍历思维破解二叉树路径/层序类高频题，结合6道力扣经典真题，让你从「套模板」到「灵活用」，彻底掌握二叉树遍历的解题精髓。</p>
<h2 data-id="heading-1">一、先背会两套通用模板：递归+层序，覆盖所有场景</h2>
<p>二叉树遍历题可分为两大核心类型，对应两套通用模板，无需记忆复杂逻辑，背会就能直接套用，重点在于理解「模板结构」和「业务填充点」。</p>
<h3 data-id="heading-2">1.1 递归遍历模板（前序+回溯）：适配根到叶路径类问题</h3>
<p>递归遍历的核心是「前序入栈、后序出栈」的回溯思想，适合需要跟踪「根节点到叶子节点完整路径」的场景（如路径收集、路径值计算、路径特征判断）。其优势在于能自然记录节点访问轨迹，代码简洁且逻辑清晰。</p>
<p>以下是优化后的通用模板（两种实现方式，按需选择）：</p>
<h4 data-id="heading-3">方式1：path数组+手动回溯（直观易懂，新手首选）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// 1. 处理空树边界</span>
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
  <span class="hljs-comment">// 2. 定义结果容器（视题目需求：数组/字符串/数字）</span>
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-comment">// 3. 定义路径容器，用于回溯记录根到当前节点的轨迹</span>
  <span class="hljs-keyword">const</span> path = [];
  <span class="hljs-comment">// 4. 启动递归遍历</span>
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-comment">// 5. 返回最终结果</span>
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-comment">// 递归遍历辅助函数（闭包共享外层res、path）</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-comment">// 递归终止：空节点直接返回，防止无限递归</span>
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 前序位置：进入节点，执行「入栈」操作（核心：记录轨迹）</span>
    path.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);

    <span class="hljs-comment">// 【核心业务区】视题目需求编写逻辑（如叶子节点判断、路径处理）</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 叶子节点：通常是路径处理的关键节点（收集/计算/判断）</span>
      res.<span class="hljs-title function_">push</span>([...path]); <span class="hljs-comment">// 浅拷贝，避免后续回溯修改路径</span>
    }

    <span class="hljs-comment">// 递归遍历左右子树（必须先左后右，不可重复遍历）</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);

    <span class="hljs-comment">// 后序位置：离开节点，执行「出栈」操作（核心：回溯，恢复轨迹）</span>
    path.<span class="hljs-title function_">pop</span>();
  }
}
</code></pre>
<h4 data-id="heading-4">方式2：带参遍历+自动回溯（简洁高效，进阶首选）</h4>
<p>核心原理：JavaScript的基本类型（数字、字符串、位掩码）是「值传递」，递归时传递的是值的副本，子树修改不会影响上一层，递归返回后自动恢复状态，无需手动执行pop回溯，代码更简洁。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// 1. 处理空树边界</span>
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
  <span class="hljs-comment">// 2. 定义结果容器（视题目需求：数组/字符串/数字）</span>
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-comment">// 3. 启动递归遍历：初始路径为空，传递给根节点</span>
  <span class="hljs-title function_">traverse</span>(root, []);
  <span class="hljs-comment">// 4. 返回最终结果</span>
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-comment">// 递归遍历辅助函数：参数传递「根到当前节点的路径」</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, path</span>) {
    <span class="hljs-comment">// 递归终止：空节点直接返回</span>
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 前序位置：更新路径 → 浅拷贝原路径，添加当前节点值（避免修改上一层路径）</span>
    <span class="hljs-keyword">const</span> newPath = [...path, node.<span class="hljs-property">val</span>];

    <span class="hljs-comment">// 【核心业务区】叶子节点：路径处理（收集/计算/比较/格式化）</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(newPath); <span class="hljs-comment">// 叶子节点处理逻辑，按需修改</span>
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 递归遍历左右子树：传递更新后的新路径，自动回溯</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, newPath);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, newPath);
    <span class="hljs-comment">// 无需手动回溯：newPath是浅拷贝的新数组，不影响上一层的path</span>
  }
}
</code></pre>
<h4 data-id="heading-5">递归模板核心要点</h4>
<ul>
<li>
<p>闭包特性：辅助函数traverse共享外层res和path，无需额外传参，简化代码；</p>
</li>
<li>
<p>回溯逻辑：方式1需保证push和pop成对出现，方式2借助值传递实现自动回溯；</p>
</li>
<li>
<p>关键节点：叶子节点（node.left === null &amp;&amp; node.right === null）是路径类题的核心处理点，几乎所有路径题都在此处编写核心业务逻辑；</p>
</li>
<li>
<p>状态传递：带参遍历的核心是传递「上一层节点的状态」（如累计值、路径、位掩码），下一层基于该状态继续更新。</p>
</li>
</ul>
<h4 data-id="heading-6">常见状态传递类型（记熟直接套用）</h4>
<p>带参遍历的参数本质是「跨节点的状态」，常见类型只有3种，覆盖所有路径类题：</p>
<ol>
<li>
<p><strong>累计值/中间结果</strong>：如路径转数字（129题）、二进制和（1022题），核心更新逻辑：新状态 = 上一层状态 * 基数 + 当前节点值（基数为10、2等）；</p>
</li>
<li>
<p><strong>层数/深度</strong>：如二叉树右视图（199题DFS解法），传递当前节点层数，实现按层处理；</p>
</li>
<li>
<p><strong>特征统计状态</strong>：如伪回文路径（572题），用位掩码或数组统计路径中节点值的奇偶性、出现次数等特征。</p>
</li>
</ol>
<h3 data-id="heading-7">1.2 层序遍历模板（BFS+队列）：适配层间节点类问题</h3>
<p>层序遍历（广度优先搜索BFS）的核心是「按层处理节点」，通过队列控制「一层一遍历」，适合需要按层操作节点的场景（如取每层最后一个节点、层内节点统计、每层平均值）。其优势在于逻辑直观，符合人类「从上到下、从左到右」的观察习惯。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// 1. 处理空树边界</span>
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
  <span class="hljs-comment">// 2. 定义结果容器</span>
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-comment">// 3. 初始化队列，存入根节点（队列是层序遍历的核心载体）</span>
  <span class="hljs-keyword">const</span> queue = [root];

  <span class="hljs-comment">// 层数 </span>
  <span class="hljs-keyword">let</span> level = <span class="hljs-number">0</span> 

  <span class="hljs-comment">// 4. 层序遍历主循环：队列非空则继续</span>
  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) {

    <span class="hljs-comment">// 遍历到哪层了，如果需要就用</span>
    level++

    <span class="hljs-comment">// 5. 记录当前层节点数（关键：确定每层的遍历边界）</span>
    <span class="hljs-keyword">const</span> curLevelSize = queue.<span class="hljs-property">length</span>;

    <span class="hljs-comment">// 6. 遍历当前层所有节点</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; curLevelSize; i++) {
      <span class="hljs-comment">// 7. 取出队首节点（当前层的待处理节点）</span>
      <span class="hljs-keyword">const</span> curNode = queue.<span class="hljs-title function_">shift</span>();

      <span class="hljs-comment">// 【核心业务区】视题目需求编写逻辑（如取层内特定节点、层内统计）</span>
      <span class="hljs-comment">// 例：取每层最后一个节点 → if (i === curLevelSize - 1) { ... }</span>

      <span class="hljs-comment">// 8. 子节点入队：左子节点先入，右子节点后入（保证层内顺序）</span>
      <span class="hljs-keyword">if</span> (curNode.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">left</span>);
      <span class="hljs-keyword">if</span> (curNode.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">right</span>);
    }

    <span class="hljs-comment">// 可选：整层遍历完成后统一处理（如层内节点汇总）</span>
  }

  <span class="hljs-comment">// 9. 返回最终结果</span>
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<h4 data-id="heading-8">层序模板核心要点</h4>
<ul>
<li>
<p>层边界控制：curLevelSize = queue.length是层序遍历的灵魂，确保每次循环只处理「当前层」的节点，不与下一层混淆；</p>
</li>
<li>
<p>队列操作：shift（取队首）和push（队尾入子节点）配合，实现节点的按层传递；</p>
</li>
<li>
<p>层内顺序：左子节点先入队，保证层内节点遍历顺序与「从左到右」的直观顺序一致。</p>
</li>
</ul>
<h2 data-id="heading-9">二、模板实战：6道力扣高频题手把手拆解</h2>
<p>以下6道题覆盖二叉树路径、层序的所有高频考法，全部基于上述模板实现，<strong>保留模板核心结构，仅修改「核心业务区」代码</strong>，让你直观感受「套模板解题」的高效性。同时标注易踩坑点和优化技巧，兼顾正确性和解题效率。</p>
<h3 data-id="heading-10">2.1 递归实战1：二叉树的所有路径（力扣257）</h3>
<h4 data-id="heading-11">题目要求</h4>
<p>给你二叉树的根节点，按任意顺序返回所有从根节点到叶子节点的路径，路径格式为"1-&gt;2-&gt;3"。</p>
<h4 data-id="heading-12">解题思路</h4>
<ul>
<li>
<p>模板：直接套用「递归遍历模板（path数组+手动回溯）」；</p>
</li>
<li>
<p>核心业务：叶子节点处将path数组格式化为"-&gt;"连接的字符串，存入结果容器；</p>
</li>
<li>
<p>优化：叶子节点处提前回溯+return，避免后续无意义的代码执行。</p>
</li>
</ul>
<h4 data-id="heading-13">套模板实现代码（直接通关）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> binaryTreePaths = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">const</span> path = [];
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    path.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 前序入栈</span>

    <span class="hljs-comment">// 核心业务：叶子节点格式化路径并收集</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(path.<span class="hljs-title function_">join</span>(<span class="hljs-string">'-&gt;'</span>));
      path.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 叶子节点提前回溯，优化效率</span>
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);
    path.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 后序出栈</span>
  }
};
</code></pre>
<h3 data-id="heading-14">2.2 递归实战2：求根节点到叶节点数字之和（力扣129）</h3>
<h4 data-id="heading-15">题目要求</h4>
<p>树中每个节点存0-9的数字，根到叶的路径代表一个数字（如1→2→3代表123），计算所有根到叶数字的和。</p>
<h4 data-id="heading-16">解题思路</h4>
<ul>
<li>
<p>模板：基于「递归遍历模板（带参遍历）」优化，无需显式path数组；</p>
</li>
<li>
<p>核心优化：路径值通过curNum = curNum * 10 + node.val动态计算（值传递，无需回溯），替代path数组，降低空间复杂度；</p>
</li>
<li>
<p>核心业务：叶子节点处将动态计算的路径值累加到结果。</p>
</li>
</ul>
<h4 data-id="heading-17">套模板优化代码（最优解）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumNumbers</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// 1. 处理空树边界：空树返回0（数字，匹配题目要求）</span>
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 2. 定义结果容器：数字类型，初始为0</span>
  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 3. 启动递归遍历：初始前序和为0（无节点时的基础值）</span>
  <span class="hljs-title function_">traverse</span>(root, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 4. 返回最终结果</span>
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-comment">// 带参遍历函数：prevSum=根到当前节点父节点的路径和（上一层状态）</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, prevSum</span>) {
    <span class="hljs-comment">// 递归终止：空节点直接返回</span>
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 前序位置：更新状态，计算根到当前节点的路径和（核心）</span>
    <span class="hljs-keyword">const</span> curSum = <span class="hljs-number">10</span> * prevSum + node.<span class="hljs-property">val</span>;

    <span class="hljs-comment">// 【核心业务区】叶子节点：累加路径和到结果</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      res += curSum; <span class="hljs-comment">// 累加</span>
      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 提前返回，避免无意义的递归</span>
    }

    <span class="hljs-comment">// 递归遍历左右子树：传递当前状态给下一层</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, curSum);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, curSum);

    <span class="hljs-comment">// 无需后序回溯：prevSum/curSum是值传递，递归返回后自动恢复上一层状态</span>
  }
}
</code></pre>
<h3 data-id="heading-18">2.3 层序实战：二叉树的右视图（力扣199）</h3>
<h4 data-id="heading-19">题目要求</h4>
<p>想象站在二叉树右侧，按从上到下顺序返回能看到的节点值（左子树更高时，能看到左子树高出的部分）。</p>
<h4 data-id="heading-20">解题思路</h4>
<ul>
<li>
<p>模板：直接套用「层序遍历模板」；</p>
</li>
<li>
<p>核心业务：每层遍历的最后一个节点（i === curLevelSize - 1）即为右侧能看到的节点，直接存入结果。</p>
</li>
</ul>
<h4 data-id="heading-21">套模板实现代码（最优解）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> rightSideView = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">const</span> queue = [root];

  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> curLevelSize = queue.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; curLevelSize; i++) {
      <span class="hljs-keyword">const</span> curNode = queue.<span class="hljs-title function_">shift</span>();

      <span class="hljs-comment">// 核心业务：取每层最后一个节点</span>
      <span class="hljs-keyword">if</span> (i === curLevelSize - <span class="hljs-number">1</span>) {
        res.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">val</span>);
      }

      <span class="hljs-keyword">if</span> (curNode.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">left</span>);
      <span class="hljs-keyword">if</span> (curNode.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">right</span>);
    }
  }

  <span class="hljs-keyword">return</span> res;
};
</code></pre>
<h3 data-id="heading-22">2.4 递归实战3：从叶结点开始的最小字符串（力扣988）</h3>
<h4 data-id="heading-23">题目要求</h4>
<p>节点值为0-25（对应a-z），返回从叶节点到根节点的字典序最小字符串（如"z" &lt; "ab"）。</p>
<h4 data-id="heading-24">解题思路</h4>
<ul>
<li>
<p>模板：套用「递归遍历模板（带参遍历）」，用字符串传递路径；</p>
</li>
<li>
<p>核心技巧：头部拼接字符串（curChar + path），天然生成叶→根的路径，无需反转；</p>
</li>
<li>
<p>核心业务：叶子节点处将生成的字符串与当前最小值比较，更新最小字符串；</p>
</li>
<li>
<p>避坑点：切勿用节点值和判断字典序，需直接比较字符串本身。</p>
</li>
</ul>
<h4 data-id="heading-25">套模板实现代码（避坑版）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">smallestFromLeaf</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// 1. 处理空树边界：题目要求空树返回空字符串</span>
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  <span class="hljs-comment">// 2. 定义结果容器：初始为空字符串，用于存储字典序最小的叶→根字符串</span>
  <span class="hljs-keyword">let</span> res = <span class="hljs-string">''</span>;
  <span class="hljs-comment">// 3. 启动递归遍历：初始路径为空字符串（根节点无父节点）</span>
  <span class="hljs-title function_">traverse</span>(root, <span class="hljs-string">''</span>);
  <span class="hljs-comment">// 4. 返回最终结果</span>
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-comment">// 带参遍历函数：path - 父节点到根节点的字符拼接字符串（叶→根格式）</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, path</span>) {
    <span class="hljs-comment">// 递归终止：空节点直接返回</span>
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 前序位置：头部拼接，天然生成当前节点到根的叶→根字符串</span>
    <span class="hljs-keyword">const</span> curChar = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(node.<span class="hljs-property">val</span> + <span class="hljs-number">97</span>); <span class="hljs-comment">// 0→a，25→z</span>
    <span class="hljs-keyword">const</span> newPath = curChar + path;

    <span class="hljs-comment">// 【核心业务区】叶子节点：比较并更新字典序最小的字符串</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 首次赋值 或 当前字符串字典序更小，更新结果</span>
      <span class="hljs-keyword">if</span> (res === <span class="hljs-string">''</span> || newPath &lt; res) {
        res = newPath;
      }
      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 提前返回，避免无意义的递归</span>
    }

    <span class="hljs-comment">// 递归遍历左右子树：传递新路径，自动回溯</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, newPath);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, newPath);
  }
}
</code></pre>
<h3 data-id="heading-26">2.5 递归实战4：从根到叶的二进制数之和（力扣1022）</h3>
<h4 data-id="heading-27">题目要求</h4>
<p>节点值为0或1，根到叶的路径代表二进制数（最高有效位开始），计算所有二进制数的十进制和。</p>
<h4 data-id="heading-28">解题思路</h4>
<ul>
<li>
<p>模板：同129题，基于「递归遍历模板（带参遍历）」，动态计算二进制值；</p>
</li>
<li>
<p>核心优化：二进制转十进制通过curNum = curNum * 2 + node.val实现（左移1位+当前值），效率高于幂运算；</p>
</li>
<li>
<p>核心业务：叶子节点处将动态计算的十进制值累加到结果。</p>
</li>
</ul>
<h4 data-id="heading-29">套模板优化代码（最优解）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumRootToLeaf</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// 1. 处理空树边界</span>
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 2. 定义结果容器</span>
  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 3. 启动递归遍历：初始前序和为0</span>
  <span class="hljs-title function_">traverse</span>(root, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 4. 返回最终结果</span>
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-comment">// 带参遍历函数：prevSum=根到当前节点父节点的二进制转十进制和</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, prevSum</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 前序位置：更新二进制转十进制的和（左移1位+当前值）</span>
    <span class="hljs-keyword">const</span> curSum = <span class="hljs-number">2</span> * prevSum + node.<span class="hljs-property">val</span>;

    <span class="hljs-comment">// 【核心业务区】叶子节点：累加结果</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      res += curSum;
    }

    <span class="hljs-comment">// 递归遍历左右子树</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, curSum);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, curSum);
  }
}
</code></pre>
<h3 data-id="heading-30">2.6 递归实战5：二叉树中的伪回文路径（力扣572）</h3>
<h4 data-id="heading-31">题目要求</h4>
<p>节点值为1-9，根到叶路径为「伪回文」指路径值的排列能形成回文，统计伪回文路径的数目。</p>
<h4 data-id="heading-32">解题思路</h4>
<ul>
<li>
<p>模板：基于「递归遍历模板（带参遍历）」，用位掩码替代path统计路径特征；</p>
</li>
<li>
<p>核心知识点：伪回文判断条件 → 路径中奇数次数的数字≤1（偶数长度为0，奇数长度为1）；</p>
</li>
<li>
<p>位掩码原理：用9位二进制数统计1-9的出现奇偶性（0=偶，1=奇），叶子节点处通过mask &amp; (mask-1) === 0判断；</p>
</li>
<li>
<p>核心业务：叶子节点处判断位掩码是否满足伪回文条件，满足则结果+1。</p>
</li>
</ul>
<h4 data-id="heading-33">套模板优化代码（位掩码最优解）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pseudoPalindromicPaths</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-comment">// 1. 处理空树边界</span>
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 2. 定义结果容器（统计伪回文路径数量）</span>
  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 3. 启动递归遍历：初始位掩码为0（全偶）</span>
  <span class="hljs-title function_">traverse</span>(root, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 4. 返回最终结果</span>
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-comment">// 带参遍历函数：mask=位掩码（统计1-9出现次数的奇偶性）</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, mask</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 前序位置：更新位掩码（异或翻转对应位，0↔1）</span>
    <span class="hljs-keyword">const</span> newMask = mask ^ (<span class="hljs-number">1</span> &lt;&lt; (node.<span class="hljs-property">val</span> - <span class="hljs-number">1</span>));

    <span class="hljs-comment">// 【核心业务区】叶子节点：判定伪回文</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 二进制中1的数量≤1，即为伪回文</span>
      <span class="hljs-keyword">if</span> ((newMask &amp; (newMask - <span class="hljs-number">1</span>)) === <span class="hljs-number">0</span>) {
        res++;
      }
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 递归遍历左右子树，自动回溯</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, newMask);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, newMask);
  }
}
</code></pre>
<h4 data-id="heading-34">基础版替代方案（数组统计，适合对位掩码不熟悉的新手）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pseudoPalindromicPaths</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
  <span class="hljs-title function_">traverse</span>(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>), <span class="hljs-literal">true</span>);
  <span class="hljs-keyword">return</span> res;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, recordArr, isEven</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 前序位置：更新数组统计奇偶性</span>
    <span class="hljs-keyword">const</span> newRecordArr = [...recordArr];
    newRecordArr[node.<span class="hljs-property">val</span>] = (newRecordArr[node.<span class="hljs-property">val</span>] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;
    isEven = !isEven;

    <span class="hljs-comment">// 【核心业务区】叶子节点：判定伪回文</span>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (isEven) {
        <span class="hljs-keyword">if</span> (newRecordArr.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === <span class="hljs-number">0</span>)) res++;
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">let</span> oneCount = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newRecordArr.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">if</span> (newRecordArr[i] === <span class="hljs-number">1</span>) {
          oneCount++;
          <span class="hljs-keyword">if</span> (oneCount &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
        }
      }
      <span class="hljs-keyword">if</span> (oneCount === <span class="hljs-number">1</span>) res++;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, newRecordArr, isEven);
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, newRecordArr, isEven);
  }
}
</code></pre>
<h2 data-id="heading-35">三、遍历思维解题核心总结（避坑+优化）</h2>
<h3 data-id="heading-36">3.1 两大模板适用场景速判</h3>























<table><thead><tr><th>遍历模板</th><th>核心适用场景</th><th>典型题目</th><th>核心优势</th></tr></thead><tbody><tr><td>递归遍历（前序+回溯）</td><td>根到叶路径类问题（需跟踪节点轨迹）</td><td>257、129、988、1022、572</td><td>天然记录路径，回溯逻辑简单，可灵活优化</td></tr><tr><td>层序遍历（BFS+队列）</td><td>层间节点类问题（需按层处理节点）</td><td>199、层序遍历、每层平均值</td><td>按层处理，逻辑直观，符合人类观察习惯</td></tr></tbody></table>
<h3 data-id="heading-37">3.2 递归遍历通用避坑点</h3>
<ol>
<li>
<p>切勿重复遍历子树（如两次traverse(node.left)），导致右子树无法访问；</p>
</li>
<li>
<p>可修改的结果变量（如res=0、minStr=''）需用let声明，const不可重新赋值；</p>
</li>
<li>
<p>path数组+手动回溯时，push和pop必须成对出现，避免路径轨迹混乱；</p>
</li>
<li>
<p>核心业务逻辑仅在叶子节点处理（题目均要求「根到叶路径」）；</p>
</li>
<li>
<p>字典序判断需直接比较字符串，不可用节点值和替代。</p>
</li>
</ol>
<h3 data-id="heading-38">3.3 通用优化技巧</h3>
<ol>
<li>
<p><strong>路径优化</strong>：路径转数字类问题，优先用动态值计算替代显式path数组，降低空间开销；</p>
</li>
<li>
<p><strong>特征统计优化</strong>：节点值范围小时（如1-9），优先用位掩码替代数组/哈希表，空间复杂度降至O(1)；</p>
</li>
<li>
<p><strong>提前终止</strong>：叶子节点处理完后提前return，避免无意义的递归和回溯；</p>
</li>
<li>
<p><strong>自动回溯</strong>：用基本类型（数字、字符串、位掩码）做带参遍历，利用值传递实现自动回溯，简化代码。</p>
</li>
</ol>
<h3 data-id="heading-39">3.4 核心解题心法</h3>
<p><strong>「模板定结构，业务填细节」</strong>—— 二叉树遍历题的核心逻辑高度统一，无需为每道题重新设计遍历框架。只需根据题目场景选择对应的模板，在「核心业务区」编写少量代码即可解决问题。</p>
<p>真正的难点不在于遍历本身，而在于：</p>
<ul>
<li>
<p>把题目要求转化为「叶子节点/层内节点的处理规则」；</p>
</li>
<li>
<p>根据数据特征选择最优的轨迹记录方式（显式path/动态值/位掩码）。</p>
</li>
</ul>
<h2 data-id="heading-40">四、最后：从模板到灵活运用</h2>
<p>本文的模板是「入门抓手」，背会模板能解决90%的二叉树遍历题，但真正的算法能力在于理解模板背后的逻辑，并能灵活调整：</p>
<ul>
<li>
<p>递归遍历不仅限于前序，可根据需求在中序/后序位置编写业务逻辑（如利用中序遍历的有序性解决二叉搜索树问题）；</p>
</li>
<li>
<p>层序遍历可增加层容器，收集每层的所有节点（如二叉树层序遍历输出二维数组）；</p>
</li>
<li>
<p>复杂问题可结合两种遍历思维（如先层序确定树的高度，再递归处理路径）。</p>
</li>
</ul>
<p>通过本文的6道实战题，你已经掌握了遍历思维的核心用法。后续只需多做同类题，熟练运用「模板+优化技巧」，就能轻松搞定所有二叉树遍历相关的高频考点，面试时遇到这类题也能从容应对！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解指针Part5——回调函数及应用]]></title>    <link>https://juejin.cn/post/7603769956975951913</link>    <guid>https://juejin.cn/post/7603769956975951913</guid>    <pubDate>2026-02-08T13:05:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603769956975951913" data-draft-id="7603911453704388651" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解指针Part5——回调函数及应用"/> <meta itemprop="keywords" content="C语言"/> <meta itemprop="datePublished" content="2026-02-08T13:05:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BlackQid"/> <meta itemprop="url" content="https://juejin.cn/user/1197816773870842"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解指针Part5——回调函数及应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1197816773870842/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BlackQid
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T13:05:14.000Z" title="Sun Feb 08 2026 13:05:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1  回调函数的定义</h2>
<p>回调函数就是<strong>一个通过函数指针调用的函数</strong>。</p>
<p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，<strong>被调用的函数就是回调函数</strong>。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>概念有些抽象，接下来通过学习<code>qsort</code>函数以及其模拟实现来促进理解。</p>
<h2 data-id="heading-1">2  <code>qsort</code>函数</h2>
<p><code>qsort</code>函数是用<strong>快速排序</strong>方法能对数组、结构体等按提供的规则进行排序的一个库函数。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span> <span class="hljs-params">(<span class="hljs-type">void</span>* base, <span class="hljs-type">size_t</span> num, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> (*compar)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*))</span>;
</code></pre>
<p>该函数包含四个参数：</p>
<ul>
<li><code>base</code>是指向待排序内容的首元素地址；</li>
<li><code>num</code>是待排序内容的元素个数；</li>
<li><code>size</code>是待排序内容的一个元素大小，单位字节；</li>
<li>函数指针<code>compar</code>是指向<strong>比较函数</strong>，需要自行编写，实现对待排序内容中两个元素的比较。</li>
</ul>
<p>因为<code>qsort</code>函数并不知道你会传入一个什么样的数据类型，所以就需要你自己先写好一个比较函数，再传给<code>qsort</code>使用。比较函数的类型、参数与返回值都有规定，见参考链接。</p>
<p><code>qsort</code>函数更详细说明的参考链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Flegacy.cplusplus.com%2Freference%2Fcstdlib%2Fqsort%2F%3Fkw%3Dqsort" target="_blank" title="https://legacy.cplusplus.com/reference/cstdlib/qsort/?kw=qsort" ref="nofollow noopener noreferrer">legacy.cplusplus.com/reference/c…</a></p>
<p>下面是一个使用<code>qsort</code>函数排序整型数组的示例：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">cmp_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* e1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* e2)</span>
<span class="hljs-comment">//const在*左侧，确保指针指向的内容不会被修改</span>
{
	<span class="hljs-keyword">return</span> *((<span class="hljs-type">int</span>*)e1) - *((<span class="hljs-type">int</span>*)e2);
    <span class="hljs-comment">//要排序的是整形数组，元素是整形，这里先将void*类型强转成int*类型</span>
    <span class="hljs-comment">//强转成与元素对应的指针类型，解引用才能得到正确的结果</span>
    <span class="hljs-comment">//这里return返回相减的差，正好符合比较函数的返回值要求</span>
}
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
	<span class="hljs-type">int</span> arr[] = { <span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span> };
	<span class="hljs-type">int</span> num = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);
	qsort(arr, num, <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]), cmp_int);
}
</code></pre>
<p>下面是一个使用<code>qsort</code>函数排序结构体数组的示例：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span>
{</span>
	<span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];
	<span class="hljs-type">int</span> age;
};

<span class="hljs-type">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span><span class="hljs-comment">//这里展示了两种访问结构体指针指向内容的方法</span>
{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> <span class="hljs-title">s</span> =</span> { <span class="hljs-string">"cuihua"</span>, <span class="hljs-number">18</span> };
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span>* <span class="hljs-title">ps</span> =</span> &amp;s;<span class="hljs-comment">//结构体指针变量</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, (*ps).name);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, ps-&gt;name);
	<span class="hljs-comment">//结构体变量.成员名</span>
	<span class="hljs-comment">//结构体指针变量-&gt;成员名</span>
}

<span class="hljs-comment">//按照名字比较大小</span>
<span class="hljs-comment">//e1是指向一个结构体数据的，e1是指向另外一个结构体数据的</span>
<span class="hljs-comment">//名字是字符串，字符串的比较使用strcmp</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">cmp_stu_by_name</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* e1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* e2)</span>
{
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>((*(<span class="hljs-keyword">struct</span> Stu*)e1).name, (*(<span class="hljs-keyword">struct</span> Stu*)e2).name);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">cmp_stu_by_name1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* e1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* e2)</span>
{
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(((<span class="hljs-keyword">struct</span> Stu*)e1)-&gt;name, ((<span class="hljs-keyword">struct</span> Stu*)e2)-&gt;name);
}

<span class="hljs-comment">//按照年龄来比较</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">cmp_stu_by_age</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* e1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* e2)</span>
{
	<span class="hljs-keyword">return</span> ((<span class="hljs-keyword">struct</span> Stu*)e1)-&gt;age - ((<span class="hljs-keyword">struct</span> Stu*)e2)-&gt;age;
}

<span class="hljs-comment">//测试qsort函数排序结构体数据 - 按名字比较</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>
{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> <span class="hljs-title">arr</span>[3] =</span> { {<span class="hljs-string">"zhangsan"</span>, <span class="hljs-number">18</span>},{<span class="hljs-string">"lisi"</span>, <span class="hljs-number">35</span>},{<span class="hljs-string">"wangwu"</span>, <span class="hljs-number">12</span>} };
	<span class="hljs-comment">//{"lisi", 35}, {"wangwu", 12},{"zhangsan", 18}</span>
	<span class="hljs-type">int</span> sz = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);
	qsort(arr, sz, <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]), cmp_stu_by_name);
}

<span class="hljs-comment">//测试qsort函数排序结构体数据 - 按年龄比较</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>
{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> <span class="hljs-title">arr</span>[3] =</span> { {<span class="hljs-string">"zhangsan"</span>, <span class="hljs-number">18</span>},{<span class="hljs-string">"lisi"</span>, <span class="hljs-number">35</span>},{<span class="hljs-string">"wangwu"</span>, <span class="hljs-number">12</span>} };
	<span class="hljs-comment">//{{"wangwu", 12}, "zhangsan", 18},{"lisi", 35}</span>
	<span class="hljs-type">int</span> sz = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);
	qsort(arr, sz, <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]), cmp_stu_by_age);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
	test2();
	test4();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 data-id="heading-2">3  模拟实现</h2>
<p>第2节解释了<code>qsort</code>函数的参数及运行方式，接下来尝试模拟实现。这里排序方法采用更熟悉的冒泡排序，而非<code>qsort</code>的快速排序。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf1, <span class="hljs-type">char</span>* buf2, <span class="hljs-type">size_t</span> sz)</span>
{
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++)
	{
		<span class="hljs-type">int</span> tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}

<span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">void</span>* base, <span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> sz, <span class="hljs-type">int</span> (*cmp)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*))</span>
{
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
	{
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++)
		{
			<span class="hljs-keyword">if</span> (cmp((<span class="hljs-type">char</span>*)base + sz * j, (<span class="hljs-type">char</span>*)base + sz * (j + <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>)
			{
				Swap((<span class="hljs-type">char</span>*)base + sz * j, (<span class="hljs-type">char</span>*)base + sz * (j + <span class="hljs-number">1</span>), sz);
			}
		}
	}
}

<span class="hljs-type">int</span> <span class="hljs-title function_">cmp_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* e1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* e2)</span>
{
	<span class="hljs-keyword">return</span> *((<span class="hljs-type">int</span>*)e1) - *((<span class="hljs-type">int</span>*)e2);
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
{
	<span class="hljs-type">int</span> arr[] = { <span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span> };
	<span class="hljs-type">int</span> num = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);
	bubble_sort(arr, num, <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]), cmp_int);
}
</code></pre>
<p>观察上述的示例，并回忆回调函数的定义。</p>
<blockquote>
<p>回调函数就是<strong>一个通过函数指针调用的函数</strong>。</p>
<p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，<strong>被调用的函数就是回调函数</strong>。</p>
</blockquote>
<p><strong>比较函数</strong><code>cmp_int</code>通过函数指针的形式传入<code>bubble_sort</code>函数并在其内部被调用，比较函数<code>cmp_int</code>就是一个<strong>回调函数</strong>。其实第2节示例中的比较函数们也都是回调函数。</p>
<p>可见，回调函数在实现一些复杂功能时具有独到的优势。想想如果不用回调函数应该是不太好实现相同的功能的。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[业务方上压力了，前端仔速通RGB转CMYK]]></title>    <link>https://juejin.cn/post/7604093823957860371</link>    <guid>https://juejin.cn/post/7604093823957860371</guid>    <pubDate>2026-02-09T01:40:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604093823957860371" data-draft-id="7603958579179585536" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 业务方上压力了，前端仔速通RGB转CMYK"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T01:40:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="古茗前端团队"/> <meta itemprop="url" content="https://juejin.cn/user/3233040624266695"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             业务方上压力了，前端仔速通RGB转CMYK
            <!----> <!----></h1> <div class="container team-follow" data-v-d326b38e="" data-v-61fb5e44=""><div class="left" data-v-d326b38e=""><a href="/team/7198439419173404711/posts" data-v-d326b38e=""><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dafcebf7c91d402abd52f072a32deba8~tplv-k3u1fbpfcp-watermark.image?" class="icon" data-v-d326b38e=""/></a> <div class="content" data-v-d326b38e=""><div style="display: flex" data-v-d326b38e=""><a href="/team/7198439419173404711/posts" data-v-d326b38e=""><p class="title-line" data-v-d326b38e=""><span title="古茗前端团队" class="title" data-v-d326b38e="">古茗前端团队</span> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/255e400027b783cbad76dc41527e7695.svg" alt="team icon" class="team-icon" data-v-d326b38e=""/></p></a></div> <div class="meta-box team" data-v-d326b38e="" data-v-61fb5e44=""><time datetime="2026-02-09T01:40:21.000Z" title="Mon Feb 09 2026 01:40:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-d326b38e="" data-v-61fb5e44="">
                2026-02-09
              </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-d326b38e="" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/></svg> <span class="views-count" style="display:none;" data-v-d326b38e="" data-v-61fb5e44="">
                1
              </span> <span class="read-time" data-v-d326b38e="" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-d326b38e="" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-d326b38e="" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-d326b38e="" data-v-61fb5e44=""/></svg>
                阅读29分钟
              </span> <!----> <!----></div></div></div> <button class="jj-follow-button follow-btn" style="display:none;" data-v-b60b2868="" data-v-d326b38e=""><span data-v-b60b2868="" data-v-d326b38e=""><i class="byte-icon byte-icon--plus" data-v-d326b38e=""><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 48 48"><path fill="none" d="M0 0h48v48H0z"/><path d="M24.7 4c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8V22h16.7c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8v1.4c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1H26v16.7c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1h-1.4c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8V26H5.3c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8v-1.4c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1H22V5.3c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1h1.4z"/></svg></i>
        关注
      </span></button></div> <div class="team-user block-hidden" data-v-61fb5e44=""><div class="avatar jj-avatar avatar" data-v-03256cc6="" data-v-61fb5e44=""><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="avatar" class="lazy avatar-img" data-v-5244ef91="" data-v-03256cc6=""/> </div> <!----> <span class="position ellipsis" data-v-61fb5e44="">
              @古茗科技
            </span></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、开端</h2>
<p>"又双叒叕大事不好了，咱们导出的图片有问题，印刷出来有色差！业务方都被逼着要去外采软件了！"</p>
<p>下班前，产品突然在群里丢了一颗重磅炸弹。</p>
<p>外采软件？什么情况？要是真把业务方逼去外采了，咱们 IT 往后的日子可就不好过了。</p>
<p>事不宜迟，咱们赶紧看看是怎么个事。</p>
<h2 data-id="heading-1">二、问题背景</h2>
<p>我们团队负责的是加盟商报货相关业务，其中有一个定制宣传物料的模块，业务流程是这样的：</p>
<ol>
<li>设计师在后台创建可定制的模板（使用 Fabric 实现的一个可视化编辑器）</li>
<li>加盟商通过小程序填写定制信息（门店名称、图片、文案等）下单</li>
<li>设计师在后台审核并合成最终设计稿（使用离屏 Canvas 渲染并直接上传 OSS）</li>
<li>导出高清原图发往印刷厂印刷，最终交付给加盟商</li>
</ol>
<p>这个系统的前端部分使用了 Fabric 来实现图片编辑功能，基于浏览器 Canvas API 导出图片，而 Canvas 只支持 <code>RGB</code> 色彩模式。但印刷厂需要的是 <code>CMYK</code> 模式，这导致印刷出来有非常明显的色差。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb1c538f450e4fcc8844367a63896a47~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2182&amp;h=1630&amp;s=3103078&amp;e=png&amp;b=8b8176" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">三、颜色的本质：色彩学</h2>
<p>要搞明白为什么有色差，我们首先要知道，什么是颜色。</p>
<blockquote>
<p>这部分比较冗长，如果你已经具备了相关前置知识，可以直接跳转至「为什么有色差」一节</p>
</blockquote>
<h3 data-id="heading-3">1. 色彩模式</h3>
<p>1672年，牛顿通过一块棱镜，发现了光的色散，从而揭示了白光由不同颜色光谱组成的本质。</p>
<p>而后，物理学家大卫·布儒斯特进一步发现染料的原色只需要红、黄、蓝三种颜色，基于这三种颜色，就可以调配出任何其他颜色。</p>
<p>随着科技的进步，生理学家托马斯杨根据人类眼球的视觉生理特征又提出了新的三原色，即红、绿、蓝三种颜色。</p>
<p>此后，人类开始意识到，色光和颜料的原色及其混合规律是有不同的，这实际上引出的是 <code>加色模式</code> 和 <code>减色模式</code> 两种色彩模式。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ebd43e7622427d96711a8a74531ae4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2048&amp;h=1281&amp;s=412842&amp;e=png&amp;b=ffffff" alt="" loading="lazy"/></p>
<h4 data-id="heading-4">减色模式</h4>
<p>我们知道，人类并不能直接<strong>看到</strong>物体本身的颜色，我们看到的物体的颜色，实际上是物体反射的光的颜色。红色的物体，实际上是吸收了除红光以外的所有光，才让唯一的红光可以进入我们的眼球。</p>
<p>因此，在现实世界我们看到的所有<strong>不自发光物体</strong>的颜色，都应当按照减色模式进行调配和描述，如美术中使用到的颜料、印染工艺中使用的染料等。</p>
<p>减法三原色为青色（C）、品红色（M）、黄色（Y），合称 <code>CMY</code>。而现如今的印刷行业普遍采用的 <code>CMYK</code> 模式，则是因为使用三种颜色的颜料无法正确混合出纯正的黑色（通常是深灰色），因此需要额外单独的黑色（K）染料来印染黑色。</p>
<p>减色法的颜色效果完全依赖于环境光的照射和白纸的反射能力——油墨本身会吸收一部分光，白纸也无法 100% 反射所有光线，并且油墨染料的化学特性限制了其反射光谱的纯度。</p>
<h4 data-id="heading-5">加色模式</h4>
<p>而针对可以直接发出光线的物体，人类所看到的颜色就直接是其发出光线颜色本身了。</p>
<p>和减色的三原色不同，加法三原色为红（R）、绿（G）、蓝（B），也就是大家熟知的 <code>RGB</code> 模式。</p>
<p>加色法是主动光源。主动光源通常可以发出非常纯净、高饱和度的单色光，并能将亮度提升到很高。这使它能够呈现非常鲜艳、明亮的颜色。</p>
<p>就比如你看到这篇文章时使用的显示器，每个像素都是由红绿蓝三种颜色的发光二极管组成的。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3302ec9ff66482aba360e8a7fcead9b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=700&amp;h=412&amp;s=439079&amp;e=png&amp;b=d1d9e1" alt="" loading="lazy"/></p>
<blockquote>
<p>曾经红极一时、如雷贯耳的“周冬雨排列”</p>
</blockquote>
<p>由于物理世界的限制，印刷品很难达到显示器那种发光体的亮度和饱和度。</p>
<h3 data-id="heading-6">2. 色彩空间</h3>
<p>色彩模式告诉你，使用青、品红、黄三种颜色的调料可以调配出任何你想要的颜色，但是却没有告诉你，如果我想要调配出正红色，要用多少青色、多少品红、和多少黄色？</p>
<p>甚至你想要的正红色，其自身都没法用一个统一的标准来表述——这正红得多红才叫正红呀？</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6263818d38d644e9a6ee6dc56a97c364~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=960&amp;h=540&amp;s=433826&amp;e=png&amp;b=151f26" alt="" loading="lazy"/></p>
<p>想要定量地描述颜色，我们需要引入<code>色彩空间(Color Space)</code>的概念。</p>
<h4 data-id="heading-7">CIE XYZ</h4>
<p>1931 年，国际照明委员会（CIE）创建了 <code>CIE XYZ</code> 色彩空间，这是第一个基于人眼视觉特性的标准色彩空间。</p>
<p>基于 <code>XYZ</code> 三个坐标，我们可以用唯一确定的数值形式表示出人类肉眼可见的所有颜色。如此一来，我们便能给每一种颜色精准定位了。</p>
<h4 data-id="heading-8">sRGB</h4>
<p>虽然有了 CIE XYZ 这个“统一语言”，但在 90 年代末，电脑普及和互联网爆发带来了一个极其现实的挑战：显示器的显示能力是有限的，而当时的网络带宽更是寸土寸金。</p>
<p>如果说 CIE XYZ 是一本包含了几十万词条、大而全的《牛津英语大词典》，那么我们在日常交流中，其实只需要一本几千词的《日常口语手册》就足够了。 强行传输 XYZ 这种海量数据，既超出了显示器的承载能力，也拖慢了网速。</p>
<p>为了在显示效果、传输效率和跨设备一致性之间找到那个平衡点，1996 年，微软和惠普选取了当时主流 CRT 显示器（大头电视）荧光粉能发出的红绿蓝，作为基准三原色，由此创造了流行至今的 <code>sRGB</code> 色彩空间，其中 <code>s</code> 意为<code>标准（Standard）</code>。</p>
<h4 data-id="heading-9">CMYK</h4>
<p>与显示器不同，印刷时选取不同的印刷介质和油墨，都会导致最终的印刷效果不同，因此针对特定的纸张和油墨组合，诞生了一系列不同的 CMYK 色彩空间，例如：</p>
<ul>
<li>FOGRA / ISO Coated (欧洲标准): 针对欧洲常用的铜版纸印刷。</li>
<li>GRACoL / SWOP (美国标准): 常见于美国的出版物。</li>
<li>Japan Color (日本标准): 针对亚洲人视觉偏好的冷调印刷。</li>
</ul>
<h3 data-id="heading-10">3. 色域</h3>
<p>为了方便比较，我们通常会将不同的色彩空间统一映射到 CIE XYZ 色彩空间内进行比对。</p>
<p>如果我们将 Z 坐标进行归一化和压缩，再将所有该色彩空间内所有颜色的 X、Y 坐标连起来，就会得到一个封闭的二维图形，这个封闭的图形就是<code>色域（Color Gamut）</code>，就是该色彩模式所能表示的颜色范围。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e83017155044d92a6a36e4a4b63994b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1200&amp;h=1267&amp;s=676567&amp;e=png&amp;b=fffefe" alt="" loading="lazy"/></p>
<blockquote>
<p>其中马蹄形区域是可见光的色域，通常被称作“全色域”</p>
</blockquote>
<p>通过图像我们不难看出，sRGB 的色域并不能完全覆盖 CMYK，这意味着，一个在 sRGB 下能表示出的颜色，在 CMYK 模式下可能根本没有对应的颜色，这会导致风光摄影中一些常见的绿色无法在印刷时体现。因此，传统印刷行业对微软和 Adobe 等公司制定的 sRGB 标准提出了强烈的反对和质疑。</p>
<p>面对印刷业巨头的联合抵制和抗议，微软并没有认怂，他们之间的纠纷战争维持了三年之久，最后在 Adobe 公司的调解下，制定了 Adobe RGB 色域，这一更广阔的色域完美地包含了印刷所需的所有颜色。</p>
<p>但是摄影及印刷行业的从业者毕竟是少数，绝大多数的互联网用户并不需要关心 CMYK 这种印刷时才会遇到的色彩模式，传统的 sRGB 依旧可以满足网上冲浪的全部需求。</p>
<p>此外，更广色域的图片也需要更专业更贵的显示器、搭配专业软件才能正常显示，这也是为什么即便到了今天，sRGB 在互联网领域依旧占据绝对统治地位。</p>
<blockquote>
<p><strong>Tips: 显示器的色域</strong></p>
<p>当你挑选显示器的时候，可能常常会听到诸如“120% sRGB”、“97% sRGB”等关键词，这里的百分比，实际上就是显示器色域占 sRGB 色域的范围。如果不考虑专业设计场景，理论上只要显示器能达到 100% 的 sRGB 色域，便可以满足你日常上网的全部需求</p>
<p>而类似“Adobe RGB 100% 色域”、“P3 广色域” 、“杜比视界”等更广阔的色域，随着时代的发展也逐渐有了更多的日常使用场景，如 B 站现在就支持 HDR 杜比视界的视频播放；在大型单机游戏领域，也越来越多地支持的 P3 色域。</p>
</blockquote>
<h2 data-id="heading-11">四、为什么有色差？</h2>
<p>了解了色彩学的基础知识后，我们重新审视一下最开始的那个问题：</p>
<p>我们知道，印刷厂的印刷机，最终印刷一定是使用 CMYK 四种颜色的墨水进行印刷的，因此当我们给出 RGB 原图时，必然经过了印刷厂的一次转换，这可能发生在机器内部，也可能发生在印刷厂的内部系统流程中；</p>
<p>而设计师手动转换色彩空间后，印刷没有色差，这就说明，色差的根源就在于印刷厂的这一次转换！</p>
<p>现阶段，想要将 RGB 转为 CMYK，通常有两种转换方式：</p>
<h3 data-id="heading-12">1. 基于基础数学公式</h3>
<p>这是最简单、最基础的算法，通常用于不要求颜色精确度的场景。</p>
<p><strong>转换步骤：</strong></p>
<ol>
<li><strong>归一化：</strong> 将 R, G, B 的值（0-255）除以 <code>255</code>，使其范围变为 <code>0～1</code>。</li>
<li><strong>计算黑色（K）：</strong><code>K = 1 - Max(R, G, B)</code></li>
<li><strong>计算 C, M, Y：</strong>
<ul>
<li><code>C = (1 - R - K) / (1 - K)</code></li>
<li><code>M = (1 - G - K) / (1 - K)</code></li>
<li><code>Y = (1 - B - K) / (1 - K)</code></li>
</ul>
</li>
</ol>
<p><strong>注意：</strong> 如果 K = 1（纯黑），则 C, M, Y 均为 <code>0</code>。</p>
<p>这种算法的思路很朴素：既然 RGB 是加色，CMYK 是减色，那就通过数学关系做个映射。理论上确实可以完成转换，但问题在于——这种纯数学转换完全不考虑现实世界的设备差异。</p>
<p>同样是显示一个红色 <code>RGB(255, 0, 0)</code>，不同品牌、不同型号的显示器，实际发出的光的波长和强度都不一样。你的显示器可能偏冷色调，我的显示器可能偏暖色调，但在算法眼里，它们都是 <code>RGB(255, 0, 0)</code>。</p>
<p>同样是印刷 <code>C0 M100 Y100 K0</code>，不同的打印机、不同的纸张、不同的油墨，印出来的颜色也千差万别。这家印刷厂的红色油墨偏橙，那家印刷厂的红色油墨偏紫，但算法根本不知道这些差异。</p>
<p>而最令人头疼的是色域映射问题——RGB 能显示的某些鲜艳颜色，比如荧光绿 <code>RGB(0, 255, 0)</code>，在 CMYK 的色域里根本没有对应的颜色。算法会强行把它映射成 <code>C100 M0 Y100 K0</code>，但印出来的绿色会明显发灰、发暗，完全不是你在屏幕上看到的那种鲜艳的绿。</p>
<p>纯算法转换假设所有设备都是"标准"的，假设色域可以完美映射，但现实世界里这两个假设都不成立。</p>
<h3 data-id="heading-13">2. 基于 ICC 特性文件</h3>
<p>这是目前设计软件（如 Adobe Illustrator、Photoshop 等）和专业印刷流程采用的标准方式。</p>
<p>正如上一节中提到，RGB 和 CMYK 都有各自的色彩空间，显示器和打印机之间各说各话，你在显示器上看到的颜色，打印出来可能是另一个颜色。</p>
<p>为了解决这个问题，1993 年，包括 Adobe、Apple、Microsoft、Sun 等八家科技公司联合成立了国际色彩联盟 <code>ICC（International Color Consortium，国际色彩联盟）</code>，目标就是建立一个开放、跨平台的色彩管理标准。ICC 配置文件规范也由此诞生。</p>
<p><del>ICC 来色彩管理界只办三件事：公平！公平！还是他**的公平！</del></p>
<p>不好意思串台了，但是其实某种意义上来说也没错。ICC 的出现是为了确保"所见即所得"，它的最终目标是让你在屏幕上看到的红色，在打印纸上也是同样的红色。</p>
<h4 data-id="heading-14">PCS：色彩转换的中间人</h4>
<p>为了做到“所见即所得”，ICC 系统引入了一个中间色彩空间 <code>PCS（Profile Connection Space，特性连接空间）</code>。这是一个设备无关的、中介的、与人眼感知相关的色彩空间（通常使用前面提到的 CIE XYZ 或者基于其演化出的 CIE Lab 色彩空间）。</p>
<p>有了 ICC 规范之后，每个设备的 ICC 文件都是通过专业仪器实际测量出来的：</p>
<ul>
<li><strong>显示器的 ICC 文件</strong>：厂商用校色仪测量这台显示器，记录下 <code>RGB(255, 0, 0)</code> 在这台显示器上实际发出的光对应的 Lab 值（比如 <code>Lab(53.23, 80.11, 67.22)</code>）</li>
</ul>
<blockquote>
<p>在你系统的显示器设置中，你可以看到当前显示器的颜色描述文件，它通常以你的显示器型号命名</p>

</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/971a17576d9946aa93349275c4d48e39~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1446&amp;h=1400&amp;s=256165&amp;e=png&amp;b=e3e3e3" alt="" loading="lazy"/></p>
<blockquote>
<p>这个文件就是显示器厂商针对这一型号制作的 ICC 文件，其内部包含了整台显示器所能展示的全部颜色，通常会随着驱动文件自动下载到你的电脑中。</p>
<p>大多数厂商所提供的只是一个通用 ICC 文件，实际上，哪怕是相同厂商、相同型号的显示器，受品控、原料批次及使用老化等因素影响，其显示效果也会有细微的差别。在某些对色彩准确性要求比较高的场景下（如影视、平面设计等）通常还需要针对单台设备进行颜色校准，并且制作一份矫正后的 ICC 或 LUT，才能够保证最终产出的图像和肉眼看到的一致。</p>
</blockquote>
<ul>
<li><strong>印刷机的 ICC 文件</strong>：印刷厂用分光光度计测量，记录下 <code>C0 M100 Y100 K0</code> 在这台印刷机、这种纸张、这种油墨上实际印出来的颜色对应的 Lab 值（比如 <code>Lab(47.82, 68.30, 48.05)</code>）</li>
</ul>
<p>每个设备的 ICC 文件都描述了该设备色彩空间与 PCS 之间的转换关系，就像不同国家的语言都可以通过英语作为中介进行翻译，如此一来，当你在显示器上看到一张照片并想打印出来时，只要经过如下转换：</p>
<ol>
<li>显示器的 ICC 配置文件把 RGB 信号转换到 Lab 色彩空间</li>
<li>印刷机的 ICC 配置文件再把这个 Lab 值翻译成印刷机需要的 CMYK 信号</li>
</ol>
<p>因为 Lab 是基于人眼感知的绝对色彩空间，所以这样转换后，你在屏幕上看到的红色，和印刷出来的红色，在人眼看来就是同一个颜色了。反之亦是同理。</p>
<h4 data-id="heading-15">渲染意图：当色域溢出时怎么办？</h4>
<p>虽然 ICC 文件可以实现从 RGB 到 CMYK 的双向映射，但是还记得我们前文提到的 RGB 的色域要比 CMYK 更广吗？这必然会导致有部分 RGB 颜色，无法和 CMYK 颜色进行映射。这时就轮到 <code>渲染意图（Rendering Intent）</code> 登场了。</p>
<p>在 ICC 规范中，一共有四种法定意图，它们决定了如何处理色域外的颜色。</p>
<h5 data-id="heading-16">可感知意图（Perceptual）</h5>
<p>可感知意图的核心原理是等比例压缩，以 RGB 转 CMYK 为例，它将 RGB 的色域等比例缩放到 CMYK 的色域，颜色之间的相对关系（层次、过渡）保留得比较好。虽然整体饱和度可能会稍微下降，但图片看起来非常自然，不会有色块断层。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3641e456f5d74d76921e8ef9bd281403~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=3780&amp;h=1417&amp;s=517336&amp;e=jpg&amp;b=fbbe2e" alt="" loading="lazy"/></p>
<blockquote>
<p>可以看出，图片虽然整体饱和度下降，但是颜色渐变过渡被保留得很好，不存在明显的断层，文本颜色也依旧可以辨识。</p>
</blockquote>
<h5 data-id="heading-17">相对比色意图（Relative Colorimetric）</h5>
<p>相对比色意图的核心逻辑是精准对齐 + 硬性裁剪，同样以 RGB 转 CMYK 为例，如果颜色在 CMYK 的色域内，就不会做任何改动；如果颜色超出了 CMYK 的色域就会直接截取为 CMYK 的边缘色彩。</p>
<p>这种方式转换的颜色最"准"，因为它尽可能保持了大部分原始数值。但在极鲜艳、极暗的区域，可能会出现"并色"（Clipping）现象，即原本有层次的颜色变成了相同的颜色，丢失了层次感。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c10fcb06f87c4d658f25652cfed06e60~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=3780&amp;h=1417&amp;s=561217&amp;e=jpg&amp;b=fdb82f" alt="" loading="lazy"/></p>
<blockquote>
<p>可以看出，图片在中部颜色没有溢出的部分保持了相同的色彩，但在两侧出现了较为明显的色域断层和边界。边界外颜色的渐变效果已被截断，且和同样超出色域范围的文本颜色被压缩成了相同的颜色，导致文本无法辨识。</p>
</blockquote>
<p>此外还有<strong>饱和度意图（Saturation）和绝对比色意图（Absolute Colorimetric）</strong>，由于篇幅限制这里就不多做赘述了。</p>
<h4 data-id="heading-18">黑场补偿：保留暗部细节</h4>
<p>可感知意图为了让所有颜色都能塞进目标色域，会移动所有颜色（甚至是那些本来就在色域内的颜色）。这意味着你看到的颜色虽然“和谐”，但已经不再是原始定义的那个准确的数值了，色差会比较明显。</p>
<p>而相对比色虽然尽可能多地保证了色准，但是面对色域外的颜色（尤其是深色）时又极易丢失细节</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4cd7062380b4654924fe0f97343019b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2972&amp;h=1981&amp;s=365325&amp;e=jpg&amp;b=f3e6e1" alt="" loading="lazy"/></p>
<blockquote>
<p>左图为 RGB 原图，右图为 CMYK 使用相对比色意图，不开启黑场补偿</p>
<p>可以看出白框中蓝莓的暗区细节已经完全丢失</p>
</blockquote>
<p>那么有没有办法，能够让我们在保证色准的同时，尽可能多地保留暗部细节呢？</p>
<p><strong>有的兄弟，有的</strong>，这门技术就是<code>黑场补偿（Black Point Compensation）</code>。</p>
<p>黑场补偿的原理，本质上就是将原图的暗区进行缩放：它会先找到源文件（RGB）中最黑的点，再找到目标输出（CMYK）能达到的最黑的点，并将整个画面的亮度范围进行等比例的"缩放"，让 RGB 的黑点刚好对应上 CMYK 的黑点。</p>
<p>如此一来，原本深灰和全黑之间的相对比例就被保留了下来，虽然整体看起来可能没那么深邃了，但暗部的细节纹理被成功"挤"进了 CMYK 能表达的范围内。</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/750c39c49a904ef383d61e7c6c62574c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2972&amp;h=1981&amp;s=4558072&amp;e=jpg&amp;b=f2e6e1" alt="" loading="lazy"/></p>
<blockquote>
<p>开启了黑场补偿后，可以看出暗区细节被完好地保留了下来</p>
</blockquote>
<p><strong>并非所有 ICC 文件的可感知意图都完美</strong></p>
<p>除了解决相对比色意图的暗部细节丢失以外，BFC 也同样可以给可感知意图兜底。</p>
<p>我们知道，ICC 文件是由厂商自行制作的，那必然会出现：有些厂商的“可感知”算法做得很好，暗部过渡自然；而有些厂商的算法却过于保守，或者在处理某些特定颜色时产生了意料之外的偏色。</p>
<p>而 BPC 是一种标准化的算法（由 Adobe 提出并贡献给 ICC）。它不依赖于 ICC 内部复杂的查表映射，而是在转换阶段进行一次数学上的端点对齐。因此，BPC 提供了一层额外的保险，确保无论你使用哪种意图，最黑的点始终能对应到输出设备的最黑点。</p>
<blockquote>
<p>在 Photoshop、Illustrator 等软件中，通常建议默认开启黑场补偿；而部分图像处理工具则可能不提供这一功能。</p>
</blockquote>
<h2 data-id="heading-19">五、如何解决？</h2>
<p>到这里，我们几乎可以确定了色差的根源，原因无非以下几个：</p>
<ul>
<li>印刷厂根本直接用的算法公式转换</li>
<li>印刷厂的转换工具不支持渲染意图和黑场补偿</li>
<li>印刷厂的渲染意图和黑场补偿选错了</li>
<li>印刷厂用的 ICC 文件不对</li>
</ul>
<p>但是不管到底是哪个问题，我们都有一个万能的解法——将 RGB 原图按照设计师的要求一比一转好后，再发给印刷厂。毕竟设计师转出来的发过去，印出来就是对的嘛。</p>
<p>依葫芦画瓢，和设计师一番沟通之后，我们确定了转换的过程与目标：</p>
<ul>
<li>RGB 原图：ICC 文件使用浏览器内置的 <code>sRGB IEC61966-2.1</code>，这是 Canvas 导出图片的默认配置</li>
<li>CMYK 转换：使用 Adobe Illustrator 软件中的默认预设——<code>日本常规用途2</code>
<ul>
<li>ICC 文件：<code>Japan Color 2001 Coated</code></li>
<li>渲染意图：可感知</li>
<li>黑场补偿：开</li>
</ul>
</li>
</ul>
<p>方案确定了，接下来进行技术调研吧。</p>
<h2 data-id="heading-20">六、技术选型</h2>
<p>我们最初的调研方向是使用服务端转换，因为相对成熟的 npm 包大多都只支持 Node 环境，而非浏览器环境。</p>
<h3 data-id="heading-21">1. Sharp</h3>
<p>首先，我们找到的是 <code>Sharp</code> 这个 Node 库，其底层基于 <code>C/C++</code> 的 <code>libvips</code>，宣称_比使用最快的 ImageMagick 和 GraphicsMagick 设置快 4 到 5 倍_，在 Node 中可以开箱即用，也是大多数 Node 应用的首选。</p>
<p>使用 Sharp 完成 RGB 到 CMYK 的转换非常简单，核心代码仅四行：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> sharp <span class="hljs-keyword">from</span> <span class="hljs-string">'sharp'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageService</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">transformToCMYK</span>(<span class="hljs-attr">file</span>: <span class="hljs-title class_">Express</span>.<span class="hljs-property">Multer</span>.<span class="hljs-property">File</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">sharp</span>(file.<span class="hljs-property">buffer</span>)
      .<span class="hljs-title function_">withIccProfile</span>(<span class="hljs-string">'./profiles/JapanColor2001Coated.icc'</span>)
      .<span class="hljs-title function_">jpeg</span>({ <span class="hljs-attr">quality</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">chromaSubsampling</span>: <span class="hljs-string">'4:4:4'</span> })
      .<span class="hljs-title function_">toBuffer</span>();
  }
}
</code></pre>
<p>美中不足的是，Sharp 毕竟是一个精简的图像处理框架，它仅支持纯算法和纯 ICC 文件的 CMYK 转换，前文提到的渲染意图和黑场补偿等均未支持。</p>
<h3 data-id="heading-22">2. ImageMagick</h3>
<p><code>ImageMagick</code> 是一个非常老牌的图像处理框架，堪比音视频领域的 <code>ffmpeg</code>。而最重要的是它支持指定渲染意图和开启黑场补偿。</p>
<p>本地安装后，你可以使用如下命令行命令来实现 RGB 到 CMYK 的转换：</p>
<pre><code class="hljs language-bash" lang="bash">magick convert input.jpg \
  -profile <span class="hljs-string">"sRGB_v4_ICC_preference.icc"</span> \
  -intent Relative \
  -black-point-compensation \
  -profile <span class="hljs-string">"Your_Target_CMYK.icc"</span> \
  output.jpg
</code></pre>
<p>除了直接使用命令行调用二进制文件，我们还可以使用 <code>magickwand.js</code>，这是一个基于 <code>swig</code> 和 <code>emnapi</code> 的库，同时实现了 Node.js 原生和浏览器 WASM 版本。</p>
<p>magickwand.js 的 Node.js 原生版本专为与 Express.js 等框架配合使用而设计，非常适合服务器端应用。官方文档宣称它_经过内存泄漏调试，并且在仅使用异步方法时，绝不会阻塞事件循环_。</p>
<p>在 Node 中使用 magickwand.js 也非常简单，代码示例如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">Logger</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@nestjs/common"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Intent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./dto/cmyk.dto"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Magick</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"magickwand.js/native"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageService</span> {
  <span class="hljs-keyword">private</span> logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>(<span class="hljs-title class_">ImageService</span>.<span class="hljs-property">name</span>);
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">profiles</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Magick</span>.<span class="hljs-property">Blob</span>&gt; = {};

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// Japan Color 2001 Coated</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadIccProfile</span>(
      <span class="hljs-string">"JapanColor2001Coated"</span>,
      <span class="hljs-string">"./profiles/JapanColor2001Coated.icc"</span>
    );
    <span class="hljs-comment">// 普通CMYK描述文件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadIccProfile</span>(
      <span class="hljs-string">"Generic CMYK Profile"</span>,
      <span class="hljs-string">"./profiles/Generic CMYK Profile.icc"</span>
    );
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">loadIccProfile</span>(<span class="hljs-params">profileName: <span class="hljs-built_in">string</span>, profilePath: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">profiles</span>[profileName]) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`<span class="hljs-subst">${profileName}</span> 配置文件已存在，跳过加载`</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(__dirname, profilePath);
    <span class="hljs-keyword">const</span> buffer = fs.<span class="hljs-title function_">readFileSync</span>(fullPath).<span class="hljs-property">buffer</span>;
    <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Magick</span>.<span class="hljs-title class_">Blob</span>(buffer);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">profiles</span>[profileName] = blob;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">transformToCMYK</span>(
    <span class="hljs-attr">file</span>: <span class="hljs-title class_">Express</span>.<span class="hljs-property">Multer</span>.<span class="hljs-property">File</span>,
    <span class="hljs-attr">intent</span>: <span class="hljs-title class_">Intent</span>,
    <span class="hljs-attr">blackPointCompensation</span>: <span class="hljs-built_in">boolean</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Buffer</span>&gt; {
    <span class="hljs-keyword">const</span> inputBlob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Magick</span>.<span class="hljs-title class_">Blob</span>(file.<span class="hljs-property">buffer</span>.<span class="hljs-property">buffer</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span>);
    <span class="hljs-keyword">const</span> inputImage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Magick</span>.<span class="hljs-title class_">Image</span>(inputBlob);
    <span class="hljs-comment">// 指定渲染意图</span>
    <span class="hljs-keyword">await</span> inputImage.<span class="hljs-title function_">renderingIntentAsync</span>(intent);
    <span class="hljs-comment">// 设置黑场补偿</span>
    <span class="hljs-keyword">await</span> inputImage.<span class="hljs-title function_">blackPointCompensationAsync</span>(blackPointCompensation);
    <span class="hljs-comment">// 转换 ICC 配置文件</span>
    <span class="hljs-keyword">await</span> inputImage.<span class="hljs-title function_">iccColorProfileAsync</span>(
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">profiles</span>[<span class="hljs-string">"JapanColor2001Coated"</span>]
    );
    <span class="hljs-comment">// 指定输出格式</span>
    <span class="hljs-keyword">await</span> inputImage.<span class="hljs-title function_">magickAsync</span>(<span class="hljs-string">"JPEG"</span>);

    <span class="hljs-keyword">const</span> outputBlob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Magick</span>.<span class="hljs-title class_">Blob</span>();
    <span class="hljs-keyword">await</span> inputImage.<span class="hljs-title function_">writeAsync</span>(outputBlob);
    <span class="hljs-keyword">const</span> outputBuffer = <span class="hljs-keyword">await</span> outputBlob.<span class="hljs-title function_">dataAsync</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(outputBuffer);
  }
}
</code></pre>
<p>这个库的主要问题是它没有 JS/TS 的文档，只有 C/C++ 的文档，使用时往往需要你根据 TS 的参数类型连蒙带猜去传参。</p>
<h3 data-id="heading-23">3. PIL/Pillow</h3>
<p>除了使用 Node，在 Python 中我们也有很多的选择，例如 <code>PIL/Pillow</code>，它同样非常强大易用，代码示例如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image, ImageCms

img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">"input.jpg"</span>)
rgb_profile = ImageCms.getOpenProfile(<span class="hljs-string">"sRGB Color Space Profile.icm"</span>)
cmyk_profile = ImageCms.getOpenProfile(<span class="hljs-string">"JapanColor2001Coated.icc"</span>)

transform = ImageCms.buildTransform(
    rgb_profile,
    cmyk_profile,
    <span class="hljs-string">"RGB"</span>,
    <span class="hljs-string">"CMYK"</span>,
    renderingIntent=ImageCms.Intent.RELATIVE_COLORIMETRIC,  <span class="hljs-comment"># 相对比色</span>
    flags=ImageCms.Flags.BLACKPOINTCOMPENSATION,  <span class="hljs-comment"># 黑场补偿</span>
)

cmyk_img = ImageCms.applyTransform(img, transform)
cmyk_img.save(<span class="hljs-string">"output.jpg"</span>, quality=<span class="hljs-number">95</span>, icc_profile=cmyk_profile.tobytes())
</code></pre>
<h2 data-id="heading-24">七、困难重重</h2>
<p>既然有这么多现成的库，而且代码看着也没多少，一定很好实现吧。</p>
<p>很可惜，理想很美好，现实很悲催。在实际落地过程中，我们遇到了很多问题。</p>
<h3 data-id="heading-25">问题一：CI/CD 构建失败</h3>
<p>最开始，我们选择了功能最完善的 <code>magickwand.js</code>。它天然支持渲染意图和黑场补偿，正好满足我们的需求。本地编码调试一切正常，但提交到 CI/CD 平台后，构建直接失败了：</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/566129947f4f4a8ba37f2a580d58f17a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1966&amp;h=406&amp;s=151295&amp;e=png&amp;b=151718" alt="" loading="lazy"/></p>
<p>排查后发现，magickwand.js 依赖 <code>xpm</code> 这个 C/C++ 包管理器。在执行 <code>npm install</code> 时，xpm 会去 npm 源查找 <code>package.json</code> 中声明的 <code>xpack</code> 字段，然后从 GitHub 下载对应平台的二进制文件：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"xpack"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"binaries"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://github.com/xpack-dev-tools/ninja-build-xpack/releases/download/v1.13.1-1"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"platforms"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"darwin-arm64"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"fileName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"xpack-ninja-build-1.13.1-1-darwin-arm64.tar.gz"</span><span class="hljs-punctuation">,</span>
          ...
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        ...
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>构建容器内无法访问 Github，这个问题我们无法解决，只能放弃 magickwand.js，转而考虑其他方案。</p>
<blockquote>
<p>实际上我们还有一个方案，就是绕过 xpm，直接将预编译好的 ImageMagick 二进制文件都下载到本地，然后在 Node 中写一个平台适配层，封装下命令调用，也可以满足需求。</p>
<p>但是使用 child_process 来调用会有很多问题：</p>
<ol>
<li>性能开销大：涉及进程创建、销毁和上下文切换成本；</li>
<li>通信效率低：需通过标准输入输出进行数据序列化与反序列化，增加了额外的处理延迟；</li>
<li>并发控制复杂：需手动管理进程池和资源竞争，避免系统资源耗尽；</li>
<li>异步编程繁琐：必须处理流控制、背压和错误恢复机制，代码复杂度显著增加；</li>
<li>稳定性风险高：子进程崩溃可能影响主进程稳定性，且进程间状态难以共享。</li>
</ol>
<p>综合考虑下来，这个也只能作为实在没有办法的备选，不应当作为首选方案。</p>
</blockquote>
<h3 data-id="heading-26">问题二：图像传输的性能瓶颈</h3>
<p>除了构建上的难题，最致命的实际是后端处理所带来的用户体验问题。</p>
<p>在我们的业务场景中，设计稿需要以 300 DPI 导出，一张海报的分辨率通常是 7087×9449，RGB 原图约 30MB；而门店横幅、围挡等大尺寸设计稿，原图甚至会达到 100MB+。</p>
<p>虽然前段时间运维升级了公司的网络带宽，由原先的 25Mb 调整到 100Mb，但是即便是跑满带宽，下载速度也只能达到约 12MB/s，而这还是建立在不考虑服务器带宽的前提下，完整的转换流程仍然需要：</p>
<ol>
<li>前端上传原图到后端（30-100MB 上行）</li>
<li>后端处理转换（4 核 8G 的处理器需要 10s 以上的处理时间）</li>
<li>后端返回 CMYK 图片（30-100MB 下行）</li>
<li>前端手动上传到 OSS（30-100MB 再次上行）</li>
</ol>
<p>整个 RTT 实测下来超过了 100 秒，还要承受网络波动导致传输失败的风险。这种体验完全无法接受。</p>
<p>我们也想过优化方案——把 Fabric 的渲染逻辑移到服务端：</p>
<ol>
<li>前端只传 JSON 配置文件（体积小）</li>
<li>后端用 <code>fabric + node-canvas</code> 渲染图片</li>
<li>就地转换为 CMYK 并直接上传 OSS</li>
<li>返回图片 URL</li>
</ol>
<p>理论上可以减少一次上行和一次下行，将 RTT 缩短至 30 秒以内。但这个方案评估下来，问题更多：</p>
<p><strong>1. 渲染场景复杂，迁移成本极高</strong></p>
<p>我们有两个场景需要适配：</p>
<ul>
<li>设计师编辑模板：直接导出 Canvas 内容</li>
<li>加盟商生成终稿：先替换占位内容，再导出；还需前置生成低分辨率预览稿，以及展示处理进度</li>
</ul>
<p>如果将 Fabric 渲染逻辑迁移到 Node：</p>
<ul>
<li>一套代码适配：需要从头梳理两套逻辑的异同点，工作量巨大</li>
<li>两套代码分离：后续维护成本会直线上升</li>
</ul>
<p>而且前端现有的历史渲染代码本就错综复杂，要保证 Node 生成的图片和浏览器完全一致，需要投入更多的开发和测试资源。</p>
<p><strong>2. 字体合规风险</strong></p>
<p>设计团队使用的字体都是免费或商业授权的，但大多数字体的授权范围仅限于桌面使用。如果把字体文件上传到服务器，属于"网络传播"或"网络嵌入"用途，需要单独授权。</p>
<p>要合法使用服务端渲染，我们需要：</p>
<ol>
<li>对所有免费、商业字体进行全面审计</li>
<li>申请新的适用范围授权（费时费力，成本高昂）</li>
</ol>
<p>这期间，一旦出现纰漏，可能收到律师函、侵权通知或高额赔偿。</p>
<p>作为一家上市公司，古茗在全国有上万家加盟门店。如此大的体量，任何合规风险都可能给公司造成无法估量的损失。</p>
<p><strong>3. 服务端性能问题</strong></p>
<p>使用服务端渲染还有一个绕不过的问题就是性能问题，在服务端执行图像处理，同样需要耗费 CPU 和内存性能，我们需要对使用场景进行梳理，根据埋点信息统计出调用频次，以评估接口性能，并对接口进行压测。如果性能不能满足，我们还需要申请更高配置的服务器。</p>
<p>这同样需要我们花费更多的时间，测试资源本就紧张，难以协调，线上稳定性也难以保障。</p>
<h3 data-id="heading-27">客户端方案的探索</h3>
<p>服务端方案成本太高，必须另寻出路，而客户端方案，JS 处理肯定是不行了，性能太差。而除了 JS 我们还有一条路可以走——WebAssembly。</p>
<p>ImageMagick 是用 C/C++ 编写的，理论上我们可以用 Emscripten 编译为 WASM。但想要打通整条链路，我们需要：</p>
<ol>
<li>搭建 emscripten 环境</li>
<li>使用 cmake/autotools 编译依赖库</li>
<li>链接和编译 ImageMagick 主代码库</li>
<li>编写 JS/WASM 胶水层代码</li>
</ol>
<blockquote>
<p>参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1554176" target="_blank" title="https://cloud.tencent.com/developer/article/1554176" ref="nofollow noopener noreferrer">WebAssembly实战-在浏览器中使用ImageMagick-腾讯云开发者社区-腾讯云</a></p>
</blockquote>
<p>这套流程虽然很明确，但学习和上手成本确实不低。受限于工期，我们先尝试寻找现成的方案：</p>
<p><strong>1. magickwand.js WASM 版本</strong></p>
<p>magickwand.js 本身就提供了 WASM 版本，但使用后发现它依赖 <code>SharedArrayBuffer</code>，这要求启用<code>跨域隔离（Cross-Origin Isolation）</code>。这不仅需要改造现有的构建脚手架，发布时还需要改造网关配置。加之这个库之前在 CI/CD 环节就有问题，我们只能放弃。</p>
<p><strong>2. 其他 WASM 库</strong></p>
<p>ImageMagick 官网推荐的 <code>WASM-ImageMagick</code> 已经 6 年没更新了。我们在 npm 上找到了 <code>@imagemagick/magick-wasm</code>，其作者是 ImageMagick 的核心开发者之一，下载量排名靠前，更新活跃，非常可靠。</p>
<p>最重要的是，它不存在我们前面提到的任何一个问题！</p>
<h2 data-id="heading-28">八、工程接入</h2>
<p>问题解决，接下来只需要将 magick-wasm 接入到工程中即可。</p>
<h3 data-id="heading-29">1. 前置准备</h3>
<p>magick-wasm 这个库内部使用 <code>BigInt</code>，如果你的 <code>browserslist</code> 指定版本过低，Babel 编译时可能会报错，添加一个 <code>supports bigint</code> 即可：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"browserslist"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"supports bigint"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"not dead"</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-30">2. WASM 初始化</h3>
<p>我们需要在页面组件中加载 WASM 模块，这里我们要求必须初始化成功，因为如果 WASM 模块无法加载，设计师转换色彩模式失败，仍会影响后续印刷。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WASM_LOCATION</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'@imagemagick/magick-wasm/magick.wasm'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">useMount</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-title function_">initializeImageMagick</span>(<span class="hljs-variable constant_">WASM_LOCATION</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'ImageMagick 初始化成功'</span>))
      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> message = <span class="hljs-string">'ImageMagick 初始化失败'</span>;
        <span class="hljs-title class_">CustomReport</span>.<span class="hljs-title function_">sendWarning</span>(<span class="hljs-title class_">ArmsLogs</span>.<span class="hljs-property">initializeImageMagickFailed</span>, { message });
        <span class="hljs-title class_">Modal</span>.<span class="hljs-title function_">error</span>({
          <span class="hljs-attr">title</span>: message,
          <span class="hljs-attr">content</span>: <span class="hljs-string">'请使用最新版本的 Chrome 浏览器!'</span>,
          <span class="hljs-attr">onOk</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">close</span>(),
        });
      })
      .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>));
  });
}
</code></pre>
<p>初始化逻辑中需要注意添加 Loading 提示，因为初始化 WASM 是需要通过网络请求获取 <code>.wasm</code> 文件的，如果网速过慢就有可能导致触发转换时 WASM 模块还没有初始化完成。</p>
<p>此外，在初始化失败时还要接入埋点告警，以便我们感知线上的使用情况。</p>
<h3 data-id="heading-31">3. 色彩模式转换</h3>
<p>这部分的核心转换逻辑也并不多，大致流程如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RGB_PROFILE_LOCATION</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'@/assets/icc/sRGB Color Space Profile.icm'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CMYK_PROFILE_LOCATION</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'@/assets/icc/JapanColor2001Coated.icc'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);

<span class="hljs-keyword">const</span> readFile = <span class="hljs-keyword">async</span> (<span class="hljs-attr">url</span>: <span class="hljs-variable constant_">URL</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt; =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);
  <span class="hljs-keyword">const</span> arrayBuffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(arrayBuffer);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> transformColorSpace = <span class="hljs-keyword">async</span> (<span class="hljs-attr">uint8Array</span>: <span class="hljs-title class_">Uint8Array</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt; =&gt; {
  <span class="hljs-keyword">const</span> [rgbProfileUint8Array, cmykProfileUint8Array] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
    <span class="hljs-title function_">readFile</span>(<span class="hljs-variable constant_">RGB_PROFILE_LOCATION</span>),
    <span class="hljs-title function_">readFile</span>(<span class="hljs-variable constant_">CMYK_PROFILE_LOCATION</span>),
  ]);
  <span class="hljs-keyword">const</span> rgbProfile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorProfile</span>(rgbProfileUint8Array);
  <span class="hljs-keyword">const</span> cmykProfile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorProfile</span>(cmykProfileUint8Array);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title class_">ImageMagick</span>.<span class="hljs-title function_">read</span>(uint8Array, <span class="hljs-title class_">MagickFormat</span>.<span class="hljs-property">Jpeg</span>, <span class="hljs-function">(<span class="hljs-params">image</span>) =&gt;</span> {
      image.<span class="hljs-property">blackPointCompensation</span> = <span class="hljs-literal">true</span>;
      image.<span class="hljs-property">renderingIntent</span> = <span class="hljs-title class_">RenderingIntent</span>.<span class="hljs-property">Perceptual</span>;
      <span class="hljs-comment">/**
       * 必须同时指定 source 和 target，否则在 safari 下会有 bug
       * https://github.com/dlemstra/magick-wasm/blob/main/src/magick-image.ts#L3976
       * safari canvas 导出的图片无法检测出 icc，会导致转换失败
       */</span>
      <span class="hljs-keyword">const</span> success = image.<span class="hljs-title function_">transformColorSpace</span>(
        rgbProfile,
        cmykProfile,
        <span class="hljs-title class_">ColorTransformMode</span>.<span class="hljs-property">HighRes</span>
      );
      <span class="hljs-keyword">if</span> (!success) {
        message.<span class="hljs-title function_">error</span>(<span class="hljs-string">'色彩空间转换失败！'</span>);
        <span class="hljs-title class_">CustomReport</span>.<span class="hljs-title function_">sendWarning</span>(<span class="hljs-title class_">ArmsLogs</span>.<span class="hljs-property">colorSpaceTransformFailed</span>, {
          <span class="hljs-attr">message</span>: <span class="hljs-string">'色彩空间转换失败！'</span>,
        });
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'色彩空间转换失败！'</span>));
      } <span class="hljs-keyword">else</span> {
        image.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">MagickFormat</span>.<span class="hljs-property">Jpeg</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
          <span class="hljs-comment">// 需要拷贝一份，否则 result 会被 GC 回收</span>
          <span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(result));
        });
      }
    });
  });
};
</code></pre>
<p>但是这里有两个坑点需要注意：</p>
<ol>
<li><strong>Safari 下 ICC 检测失败</strong></li>
</ol>
<p>transformColorSpace 在源码中判断了图像是否内嵌了 profile，如果没有嵌入，会直接返回失败。</p>
<blockquote>
<p>源码位置：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdlemstra%2Fmagick-wasm%2Fblob%2Fmain%2Fsrc%2Fmagick-image.ts%23L3976" target="_blank" title="https://github.com/dlemstra/magick-wasm/blob/main/src/magick-image.ts#L3976" ref="nofollow noopener noreferrer">github.com/dlemstra/ma…</a></p>
</blockquote>
<p>在 Chrome 中通过 Canvas 导出的图片，调用 ImageMagick 查询 ICC 文件时可以正常找到，但是通过 Safari 导出的图片则无法检出。</p>
<p>奇怪的是，使用 macOS 自带预览查看颜色描述文件信息时却恰好得到了相反的结果——使用 Safari 导出的图片正确嵌入了 sRGB IEC61966-2.1 文件，而 Chrome 导出的图片却没有显示颜色描述文件。</p>
<blockquote>
<p>这个问题笔者没有深入研究，如果有了解原因的朋友也欢迎在评论区回复解答下疑惑</p>
</blockquote>
<p>因此在 Safari 下 transformColorSpace 方法不会执行任何操作，直接返回了 true。</p>
<p>阅读源码后发现要规避这个问题，只需要同时传入 source 和 target 即可：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RGB_PROFILE_LOCATION</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'@/assets/icc/sRGB Color Space Profile.icm'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CMYK_PROFILE_LOCATION</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'@/assets/icc/JapanColor2001Coated.icc'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> transformColorSpace = <span class="hljs-keyword">async</span> (<span class="hljs-attr">uint8Array</span>: <span class="hljs-title class_">Uint8Array</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt; =&gt; {
  <span class="hljs-keyword">const</span> [rgbProfileUint8Array, cmykProfileUint8Array] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
    <span class="hljs-title function_">readFile</span>(<span class="hljs-variable constant_">RGB_PROFILE_LOCATION</span>),
    <span class="hljs-title function_">readFile</span>(<span class="hljs-variable constant_">CMYK_PROFILE_LOCATION</span>),
  ]);
  <span class="hljs-keyword">const</span> rgbProfile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorProfile</span>(rgbProfileUint8Array);
  <span class="hljs-keyword">const</span> cmykProfile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorProfile</span>(cmykProfileUint8Array);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title class_">ImageMagick</span>.<span class="hljs-title function_">read</span>(uint8Array, <span class="hljs-title class_">MagickFormat</span>.<span class="hljs-property">Jpeg</span>, <span class="hljs-function">(<span class="hljs-params">image</span>) =&gt;</span> {
      image.<span class="hljs-property">blackPointCompensation</span> = <span class="hljs-literal">true</span>;
      image.<span class="hljs-property">renderingIntent</span> = <span class="hljs-title class_">RenderingIntent</span>.<span class="hljs-property">Perceptual</span>;
      <span class="hljs-comment">/**
       * 必须同时指定 source 和 target，否则在 safari 下会有 bug
       * https://github.com/dlemstra/magick-wasm/blob/main/src/magick-image.ts#L3976
       * safari canvas 导出的图片无法检测出 icc，会导致转换失败
       */</span>
      <span class="hljs-keyword">const</span> success = image.<span class="hljs-title function_">transformColorSpace</span>(
        rgbProfile,
        cmykProfile,
        <span class="hljs-title class_">ColorTransformMode</span>.<span class="hljs-property">HighRes</span>
      );
      <span class="hljs-keyword">if</span> (!success) {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'色彩空间转换失败！'</span>));
      } <span class="hljs-keyword">else</span> {
        image.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">MagickFormat</span>.<span class="hljs-property">Jpeg</span>, resolve);
      }
    });
  });
};
</code></pre>
<p>当然别忘记在代码中留下对应的注释说明，防止后人维护重复踩坑。</p>
<ol start="2">
<li><strong>WASM GC 导致数据丢失</strong></li>
</ol>
<p>image.write 回调中的 data 对象来自 magick-wasm 的内存，它的生命周期不受 JS 控制，回调结束或后续写入时那段内存可能已经被复用/释放。</p>
<p>要解决这个问题也很简单，原地复制一份即可：</p>
<pre><code class="hljs language-typescript" lang="typescript">image.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">MagickFormat</span>.<span class="hljs-property">Jpeg</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-comment">// 需要拷贝一份，否则 result 会被 GC 回收</span>
  <span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(data));
});
</code></pre>
<p>同样留下一个贴心的注释，后续只需适配对应的业务代码即可</p>
<h3 data-id="heading-32">4. 性能优化</h3>
<p>功能是实现了，但业务实际用下来还是发现不少问题，主要集中在性能方面。</p>
<p>业务使用的是统一采购的 16G 的 M1 芯片 iMac，按理来讲不会卡，但是深入了解了业务的操作习惯后，发现了几个很有意思的点：</p>
<ul>
<li>业务习惯同时多开 4、5 个标签页，同时操作</li>
<li>业务在页面操作的同时，本地会开着 AI/PS 以方便作图</li>
</ul>
<p>虽然 WebAssembly 运行速度非常快，但它与 JavaScript 共享同一个事件循环（Event Loop）。如果你在主线程直接调用一个耗时较长的 WASM 函数，它依然会阻塞 UI 响应，导致页面卡顿。</p>
<p>在现代浏览器中，同一个域名的不同标签页，通常也是共用的同一个进程，这还会导致，我们在一个标签页下处理图像，同域的其他标签页也无法操作（主线程被阻塞），浏览器还会弹出页面无响应的提示</p>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a72acf0c876e42ad871fbc4d498b4273~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=3394&amp;h=1482&amp;s=820264&amp;e=png&amp;b=3e3c3b" alt="" loading="lazy"/></p>
<p>因此，我们还需要做针对性的性能优化。</p>
<h4 data-id="heading-33">Worker 多线程</h4>
<p>性能优化的第一步，就是将 WebAssembly 从主线程中移出去。我们可以使用 Web Worker 将 WASM 的逻辑单独放在 worker 线程中执行，从而避免阻塞主线程。</p>
<p>想要使用 worker 很简单，你只需要创建一个 <code>worker.js</code> 文件，随后在主线程中使用：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">"worker.js"</span>);
</code></pre>
<p>即可将 worker.js 中的代码放在独立的 worker 线程中执行。</p>
<blockquote>
<p>注意这里不能用 <code>SharedWorker</code>，一方面 Safari 长期以来对 SharedWorker 支持不佳，另一方面 SharedWorker 更多使用在是跨标签通信，或者某些需要共享资源的场景，对于上面提到的多标签并发图像处理反而起到负作用（多个标签共享一个 Worker，处理是串行的），无法最大程度利用现代多核 CPU 的性能。</p>
</blockquote>
<p>此外，由于单个标签页可能会触发多次图像处理，我们还可以使用单例模式减少重复的 WASM 初始化，从而进一步优化性能，代码示例如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Worker 实例</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workerInstance</span>: <span class="hljs-title class_">Worker</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-comment">/**
 * 获取 Worker 实例（单例模式）
 */</span>
<span class="hljs-keyword">const</span> getWorker = (): <span class="hljs-function"><span class="hljs-params">Worker</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!workerInstance) {
    workerInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'./magick.worker.ts'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>), { 
      <span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span> 
    });
    <span class="hljs-comment">// 监听 Worker 返回的消息</span>
    workerInstance.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {};
    <span class="hljs-comment">// 监听 Worker 错误</span>
    workerInstance.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {};
  }
  <span class="hljs-keyword">return</span> workerInstance;
};
</code></pre>
<p><strong>Worker 同源限制</strong></p>
<p>在上线前我们还遇到一个问题，我们的前端构建产物是托管在 OSS 上的，这里使用 new URL 获取到的 worker 资源不同源，导致无法加载。</p>
<p>为了解决这个问题，我们将 worker 内部的逻辑单独抽离到一个 npm 包中，连同依赖项一起打包成 UMD 格式，在业务工程中通过 fetch 方式获取脚本内容。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WORKER_URL</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'@guming/magick-worker/build/umd/index.js'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);
<span class="hljs-comment">// Fetch worker 文件内容</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">WORKER_URL</span>);
<span class="hljs-keyword">const</span> workerCode = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();
<span class="hljs-comment">// 创建 Blob 和 Blob URL</span>
<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([workerCode], { <span class="hljs-attr">type</span>: <span class="hljs-string">'application/javascript'</span> });
<span class="hljs-keyword">const</span> blobUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);
<span class="hljs-comment">// 创建 Worker</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(blobUrl);
</code></pre>
<blockquote>
<p>如果你使用 Vite，也可以使用 Vite 的 <code>import MyWorker from'./worker.js?worker'</code>语法。</p>
<p>或者也可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fremote-web-worker" target="_blank" title="https://www.npmjs.com/package/remote-web-worker" ref="nofollow noopener noreferrer">remote-web-worker</a> 这样的库来少写点代码。</p>
</blockquote>
<h4 data-id="heading-34">Comlink 零拷贝传输</h4>
<p>Worker 通过 postMessage 与主线程通信，数据传输有两种模式：</p>
<ol>
<li><strong>结构化克隆（Structured Clone）</strong></li>
</ol>
<p>这也是最常用的一种写法，代码示例如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'worker.js'</span>);
<span class="hljs-keyword">const</span> imageBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">100</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);

worker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'process'</span>, <span class="hljs-attr">data</span>: imageBuffer });
</code></pre>
<p>这种方式会为接收方创建一个数据的完整副本。对于 100MB 的图片，传输瞬间会导致内存占用翻倍（变为 200MB）。如果是 5 个标签页同时操作，内存峰值将迅速堆叠，引发浏览器 OOM（内存溢出）崩溃。</p>
<ol start="2">
<li><strong>可转移对象（Transferable Objects）</strong></li>
</ol>
<p>除了结构化克隆之外，worker 还提供了一种允许你直接转交对象内存的方式，代码示例如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'worker.js'</span>);
<span class="hljs-keyword">const</span> imageBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">100</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);

worker.<span class="hljs-title function_">postMessage</span>(
  { <span class="hljs-attr">type</span>: <span class="hljs-string">'process'</span>, <span class="hljs-attr">data</span>: imageBuffer },
  [imageBuffer]  <span class="hljs-comment">// 第二个参数：要转移的对象列表</span>
);

<span class="hljs-comment">// 转移后，imageBuffer 在主线程不可用</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imageBuffer.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 0 —— 所有权已转移</span>
</code></pre>
<p>通过这种方式，我们可以避免对大对象进行拷贝，从而减少通信时上下文结构化的性能开销。</p>
<p>在实际开发工作中，我们通常还需要写一套复杂的事件通信逻辑，来保障和 worker 之间的通信，代码可能长这样：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 主线程</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">workerInstance</span>: <span class="hljs-title class_">Worker</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> messageId = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, { <span class="hljs-attr">resolve</span>: <span class="hljs-title class_">Function</span>; <span class="hljs-attr">reject</span>: <span class="hljs-title class_">Function</span> }&gt;();

<span class="hljs-comment">/**
 * 获取 Worker 实例（单例模式）
 */</span>
<span class="hljs-keyword">const</span> getWorker = (): <span class="hljs-function"><span class="hljs-params">Worker</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!workerInstance) {
    workerInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'./magick.worker.ts'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>), { 
      <span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span> 
    });

    <span class="hljs-comment">// 监听 Worker 返回的消息</span>
    workerInstance.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> { id, <span class="hljs-keyword">type</span>, data, error } = event.<span class="hljs-property">data</span>;
      <span class="hljs-keyword">const</span> request = pendingRequests.<span class="hljs-title function_">get</span>(id);

      <span class="hljs-keyword">if</span> (request) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">'success'</span>) {
          request.<span class="hljs-title function_">resolve</span>(data);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">'error'</span>) {
          request.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(error));
        }
        pendingRequests.<span class="hljs-title function_">delete</span>(id);
      }
    };

    <span class="hljs-comment">// 监听 Worker 错误</span>
    workerInstance.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Worker error:'</span>, error);
      <span class="hljs-comment">// 拒绝所有等待中的请求</span>
      pendingRequests.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ reject }</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(error));
      pendingRequests.<span class="hljs-title function_">clear</span>();
    };
  }
  <span class="hljs-keyword">return</span> workerInstance;
};

<span class="hljs-comment">/**
 * 向 Worker 发送消息并等待响应
 */</span>
<span class="hljs-keyword">const</span> sendMessageToWorker = &lt;T&gt;(
  <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>, 
  data?: <span class="hljs-built_in">any</span>,
): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> id = messageId++;
    <span class="hljs-keyword">const</span> worker = <span class="hljs-title function_">getWorker</span>();
    <span class="hljs-comment">// 保存 promise 的 resolve 和 reject</span>
    pendingRequests.<span class="hljs-title function_">set</span>(id, { resolve, reject });
    <span class="hljs-comment">// 发送消息到 Worker</span>
    worker.<span class="hljs-title function_">postMessage</span>({ id, method, data });
  });
};

<span class="hljs-keyword">const</span> initializeWorker = (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">sendMessageToWorker</span>(<span class="hljs-string">'initializeWorker'</span>);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> transformColorSpace = (<span class="hljs-attr">uint8Array</span>: <span class="hljs-title class_">Uint8Array</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt; =&gt; {
  <span class="hljs-keyword">return</span> sendMessageToWorker&lt;<span class="hljs-title class_">Uint8Array</span>&gt;(<span class="hljs-string">'transformColorSpace'</span>, uint8Array);
};
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// worker</span>
<span class="hljs-keyword">import</span> { initMagick, <span class="hljs-title class_">ImageMagick</span>, <span class="hljs-title class_">MagickImage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@imagemagick/magick-wasm'</span>;

<span class="hljs-keyword">let</span> initialized = <span class="hljs-literal">false</span>;

<span class="hljs-keyword">const</span> initializeWorker = <span class="hljs-keyword">async</span> (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {};
<span class="hljs-keyword">const</span> transformColorSpace = <span class="hljs-keyword">async</span> (<span class="hljs-attr">uint8Array</span>: <span class="hljs-title class_">Uint8Array</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt; =&gt; {};

<span class="hljs-comment">// 监听主线程的消息</span>
self.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">async</span> (event) =&gt; {
  <span class="hljs-keyword">const</span> { id, method, data } = event.<span class="hljs-property">data</span>;
  
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> result;
    <span class="hljs-comment">// 根据方法名调用对应的函数</span>
    <span class="hljs-keyword">switch</span> (method) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'initializeWorker'</span>:
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">initializeWorker</span>();
        result = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'transformColorSpace'</span>:
        result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">transformColorSpace</span>(data);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Unknown method: <span class="hljs-subst">${method}</span>`</span>);
    }
    <span class="hljs-comment">// 返回成功结果</span>
    self.<span class="hljs-title function_">postMessage</span>({ id, <span class="hljs-attr">type</span>: <span class="hljs-string">'success'</span>, <span class="hljs-attr">data</span>: result });
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 返回错误</span>
    self.<span class="hljs-title function_">postMessage</span>({ id, <span class="hljs-attr">type</span>: <span class="hljs-string">'error'</span>, error });
  }
};
</code></pre>
<p>比较复杂，有一定的学习和理解成本。我们可以使用 <code>Comlink</code> 库来封装 worker 的通信逻辑，从而避免手动维护一套事件通信逻辑，代码可以精简如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 主线程</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Comlink</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'comlink'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">WorkerApi</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./magick.worker'</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">workerInstance</span>: <span class="hljs-title class_">Worker</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">workerApi</span>: <span class="hljs-title class_">Comlink</span>.<span class="hljs-property">Remote</span>&lt;<span class="hljs-title class_">WorkerApi</span>&gt; | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">const</span> getWorkerApi = (): <span class="hljs-title class_">Comlink</span>.<span class="hljs-property">Remote</span>&lt;<span class="hljs-title class_">WorkerApi</span>&gt; =&gt; {
  <span class="hljs-keyword">if</span> (!workerApi) {
    workerInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'./magick.worker.ts'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>), { <span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span> });
    workerApi = <span class="hljs-title class_">Comlink</span>.<span class="hljs-property">wrap</span>&lt;<span class="hljs-title class_">WorkerApi</span>&gt;(workerInstance);
  }
  <span class="hljs-keyword">return</span> workerApi;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> initializeWorker = <span class="hljs-keyword">async</span> (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
  <span class="hljs-keyword">const</span> api = <span class="hljs-title function_">getWorkerApi</span>();
  <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">initializeWorker</span>();
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> transformColorSpace = <span class="hljs-keyword">async</span> (<span class="hljs-attr">uint8Array</span>: <span class="hljs-title class_">Uint8Array</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt; =&gt; {
  <span class="hljs-keyword">const</span> api = <span class="hljs-title function_">getWorkerApi</span>();
  <span class="hljs-keyword">return</span> api.<span class="hljs-title function_">transformColorSpace</span>(<span class="hljs-title class_">Comlink</span>.<span class="hljs-title function_">transfer</span>(uint8Array, [uint8Array.<span class="hljs-property">buffer</span>]));
};
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// worker</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Comlink</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'comlink'</span>;

<span class="hljs-keyword">const</span> initializeWorker = <span class="hljs-keyword">async</span> (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {};

<span class="hljs-keyword">const</span> transformColorSpace = <span class="hljs-keyword">async</span> (<span class="hljs-attr">uint8Array</span>: <span class="hljs-title class_">Uint8Array</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title class_">ImageMagick</span>.<span class="hljs-title function_">read</span>(uint8Array, <span class="hljs-title class_">MagickFormat</span>.<span class="hljs-property">Jpeg</span>, <span class="hljs-function">(<span class="hljs-params">image</span>) =&gt;</span> {
      ...
      image.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">MagickFormat</span>.<span class="hljs-property">Jpeg</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(result);
        <span class="hljs-comment">// 使用 Transferable，避免大数据复制</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Comlink</span>.<span class="hljs-title function_">transfer</span>(output, [output.<span class="hljs-property">buffer</span>]));
      });
    });
  });
};

<span class="hljs-keyword">const</span> workerApi = {
  initializeWorker,
  transformColorSpace,
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">WorkerApi</span> = <span class="hljs-keyword">typeof</span> workerApi;

<span class="hljs-title class_">Comlink</span>.<span class="hljs-title function_">expose</span>(workerApi);
</code></pre>
<p>写法非常简单，仿佛根本没有 worker 的存在，Comlink 帮你封装了所有通信的细节。</p>
<h4 data-id="heading-35">静态资源缓存</h4>
<p>原先的 transformColorSpace 写法中，每次执行都会重复请求一次 ICC 文件，我们完全可以将请求做前置缓存，统一放到 <code>initializeWorker</code> 内部，实测下来可以减少每次 2s 以上的重复请求耗时：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * 初始化 ImageMagick WASM
 */</span>
<span class="hljs-keyword">const</span> initializeWasm = <span class="hljs-keyword">async</span> (<span class="hljs-attr">wasmUrl</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
  <span class="hljs-keyword">const</span> wasmBytes = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readFile</span>(wasmUrl);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">initializeImageMagick</span>(wasmBytes);
};

<span class="hljs-comment">/**
 * 初始化 ICC profiles
 */</span>
<span class="hljs-keyword">const</span> initializeProfiles = <span class="hljs-keyword">async</span> (<span class="hljs-attr">rgbProfileUrl</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">cmykProfileUrl</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
  <span class="hljs-keyword">const</span> [rgbProfileUint8Array, cmykProfileUint8Array] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
    <span class="hljs-title function_">readFile</span>(rgbProfileUrl),
    <span class="hljs-title function_">readFile</span>(cmykProfileUrl),
  ]);
  <span class="hljs-keyword">const</span> rgbProfile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorProfile</span>(rgbProfileUint8Array);
  <span class="hljs-keyword">const</span> cmykProfile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorProfile</span>(cmykProfileUint8Array);
  profiles = { <span class="hljs-attr">rgb</span>: rgbProfile, <span class="hljs-attr">cmyk</span>: cmykProfile };
};

<span class="hljs-comment">/**
 * 初始化 Worker
 */</span>
<span class="hljs-keyword">const</span> initializeWorker = <span class="hljs-keyword">async</span> (<span class="hljs-attr">config</span>: {
  <span class="hljs-attr">wasmUrl</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">rgbProfileUrl</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">cmykProfileUrl</span>: <span class="hljs-built_in">string</span>;
}): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
  <span class="hljs-keyword">if</span> (initialized) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
    <span class="hljs-title function_">initializeWasm</span>(config.<span class="hljs-property">wasmUrl</span>),
    <span class="hljs-title function_">initializeProfiles</span>(config.<span class="hljs-property">rgbProfileUrl</span>, config.<span class="hljs-property">cmykProfileUrl</span>),
  ]).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    initialized = <span class="hljs-literal">true</span>;
  });
};
</code></pre>
<h3 data-id="heading-36">5. 性能测试</h3>
<p>我们将优化前后各操作的性能进行对比，测试基准条件如下：</p>
<ul>
<li>图片大小：127.3MB</li>
<li>芯片：Apple M4</li>
<li>核心数：10（4 性能和 6 能效）</li>
<li>内存：32G</li>
<li>浏览器：Chrome 144.0.7559.110（正式版本） (arm64)</li>
</ul>
<h4 data-id="heading-37">单标签处理性能</h4>









































<table><thead><tr><th>阶段</th><th>主线程方案</th><th>Worker 方案（结构化克隆）</th><th>Worker 方案（零拷贝传输）</th></tr></thead><tbody><tr><td>初始化</td><td>-</td><td>619.20ms</td><td>730.10ms</td></tr><tr><td>图像处理</td><td>42710.70ms(42.71s)</td><td>48494.60ms(48.5s)</td><td>48281.70ms(48.27s)</td></tr><tr><td>通信耗时</td><td>-</td><td>61.40ms</td><td>53.00ms</td></tr><tr><td>组装 Blob</td><td>74.15ms</td><td>140.80ms</td><td>154.00ms</td></tr><tr><td>总耗时</td><td>42784.85ms(42.79s)</td><td>48696.8ms(48.7s)</td><td>48494.60ms(48.5s)</td></tr></tbody></table>
<blockquote>
<p>大图的处理时间稍长，实际上处理 20M 左右的图片，处理速度均控制在 10-20s 内。</p>
</blockquote>
<h4 data-id="heading-38">多标签并发处理性能</h4>



































<table><thead><tr><th>指标</th><th>主线程方案</th><th>Worker 方案</th></tr></thead><tbody><tr><td>标签 1 完成时间</td><td>43.25s</td><td>45.17s</td></tr><tr><td>标签 2 完成时间</td><td>40.39s</td><td>42.28s</td></tr><tr><td>标签 3 完成时间</td><td>无法处理</td><td>41.84s</td></tr><tr><td>全部完成时间</td><td>页面等待超 5 分钟才可以交互</td><td>45.17s</td></tr><tr><td>其他标签是否卡顿</td><td>所有同域标签全部卡死</td><td>否</td></tr></tbody></table>
<h4 data-id="heading-39">内存使用对比</h4>
<p>在 Chrome 中可以使用 performance.memory 获取当前的内存使用情况，其中返回对象的 jsHeapSizeLimit 字段表示当前 JavaScript 页面可以使用的最大堆内存限制。</p>
<p>在 64 位系统中，物理内存大于 16G 的，堆内存最大限制为 4G；小于等于 16G 的，最大堆内存限制为 2G。</p>
<p>在 32位系统中，最大堆内存限制为 1G。</p>
<blockquote>
<p>参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformance%2Fmemory" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory" ref="nofollow noopener noreferrer">Performance.memory - Web API | MDN</a></p>
</blockquote>















































<table><thead><tr><th>场景</th><th>主线程方案</th><th>Worker 方案（结构化克隆）</th><th>Worker 方案（零拷贝传输）</th></tr></thead><tbody><tr><td>初始化前</td><td>536.96 MB</td><td>134.92 MB</td><td>153.93 MB</td></tr><tr><td>初始化后</td><td>653.57 MB</td><td>171.09 MB</td><td>156.86 MB</td></tr><tr><td>Blob组装前</td><td>653.57 MB</td><td>238.52 MB</td><td>230.86 MB</td></tr><tr><td>发送前</td><td>3105.70 MB   (对应图像处理中)</td><td>355.71 MB</td><td>348.05 MB</td></tr><tr><td>接收后</td><td/><td>415.65 MB</td><td>364.07 MB</td></tr><tr><td>Blob 组装后</td><td>3105.70 MB</td><td>415.65 MB</td><td>364.07 MB</td></tr></tbody></table>
<p>在主线程方案的测试过程中，第二个标签页在处理图像过程中，堆内存来到了 5492.76 MB，已经超出了 4G 的堆内存限制，这直接导致了第三个标签页的白屏崩溃。而 Worker 方案，页面全部正常展示 Loading，未出现白屏等情况，所有页面几乎同时输出了转换后的图片。</p>
<blockquote>
<p>设计师使用的设备为公司统一采购的 M1 芯片 iMac，16G 内存。</p>
<p>在设计师的机子上 Chrome 最大堆内存限制为 2G，主线程方案仅支持同时开启一个标签页处理</p>
</blockquote>
<h4 data-id="heading-40">优化效果总结</h4>
<ol>
<li><strong>稳定性：突破 4GB 堆内存瓶颈</strong></li>
</ol>
<p>这是本次优化最显著的成果。在 64 位 Chrome 中，即便物理内存高达 32GB，单个标签页的 JS 堆内存限制（<code>jsHeapSizeLimit</code>）通常仍被锁定在 <strong>4GB</strong>。</p>
<p>主线程方案在处理 120MB+ 大图时，瞬时内存飙升至 3.1GB。当开启 3 个标签页并发处理时，内存占用迅速叠加至 5.5GB 左右，触发 OOM，导致浏览器标签页直接<strong>白屏崩溃</strong>。</p>
<p>通过将计算密集型任务移出主线程，主线程内存始终维持在 <strong>300MB-400MB</strong> 的较低水平。Worker 方案成功绕过了单线程堆内存限制，实现了 5 个以上标签页的稳定并发。</p>
<ol start="2">
<li><strong>用户体验：从“全域卡死”到“流畅加载”</strong></li>
</ol>
<p>主线程方案在处理期间，由于执行栈被 ImageMagick 完全阻塞，导致同域下的所有标签页失去响应，用户无法进行任何交互。</p>
<p>Worker 方案虽然在单线程处理耗时上略慢于主线程（约增加 13% 的上下文开销），但它保证了 UI 的绝对响应速度。用户在处理百兆大图的同时，依然可以平滑地切换标签页、点击按钮或观看 Loading 动画。</p>
<ol start="3">
<li><strong>数据传输优化：零拷贝的价值</strong></li>
</ol>
<p>使用结构化克隆时，数据发送前后有 60MB 的内存差值，而零拷贝将内存波动降至 16MB，在大数据量下，这个差距会随着并发量的增加而变得极度明显。</p>
<p>通过使用零拷贝传输，我们避免了 CPU 密集的序列化过程，同时减少了内存峰值和 GC 压力，保证了并发情况下页面的正常使用。</p>
<ol start="4">
<li><strong>综合对比看板</strong></li>
</ol>



































<table><thead><tr><th>维度</th><th>主线程方案</th><th>Worker 方案 (优化后)</th><th>结论</th></tr></thead><tbody><tr><td>单图总耗时</td><td>42.79s</td><td>48.5s</td><td>主线程略快，但牺牲了交互性</td></tr><tr><td>并发可靠性</td><td>极差 (仅支持2次并发)</td><td>极优秀 (并发无压力)</td><td>Worker 解决了生存问题</td></tr><tr><td>主线程内存峰值</td><td>3105.70 MB</td><td>364.07 MB</td><td>降低了 <strong>88%</strong> 的主线程内存压力</td></tr><tr><td>交互体验</td><td>页面完全冻结</td><td>始终流畅</td><td>核心体验提升</td></tr></tbody></table>
<h2 data-id="heading-41">九、总结</h2>
<p>本次需求从一个看似简单的"颜色不对"问题出发，最终演变成了一次涉及色彩科学、图像处理、Web 技术栈选型以及前端性能优化的综合技术攻坚。</p>
<p>回顾整个过程，我们遇到的困难主要集中在三个方面：</p>
<p><strong>技术选型的权衡</strong>：从 Sharp 到 ImageMagick，从 Node.js 到 Python，再到 WebAssembly，每一种方案都有其适用场景和局限性。我们需要在功能完整性、性能表现、开发成本以及基建适配性之间反复权衡。</p>
<p><strong>基础设施的限制</strong>：CI/CD 环境的网络策略、服务器性能、字体授权合规等"非技术"因素，往往会成为技术方案落地的最大障碍。这提醒我们，技术方案的设计不能脱离实际的业务环境。</p>
<p><strong>用户体验的坚守</strong>：最初的服务端方案虽然功能简单完善，但超 100s 的等待时间完全无法接受。正是对用户体验的坚持，驱使我们最终找到了客户端 WASM 方案，并通过性能优化将处理时间大大缩短到 20 秒内。</p>
<p>最终，通过在浏览器端集成 <code>@imagemagick/magick-wasm</code>，我们实现了：</p>
<ul>
<li>完整的 ICC Profile 支持，精确控制色彩转换</li>
<li>统一的渲染意图和黑场补偿配置，转换效果相较专业设计软件（AI/PS）色差低于 1%。</li>
<li>无需服务端参与，避免了网络传输问题和字体合规风险。</li>
<li>本地多线程处理，支持并发图像处理，最大程度利用设备性能。</li>
<li>解决印刷色差问题，节约 80% 设计师重复劳动</li>
</ul>
<p>这次经历让我们深刻认识到：解决问题的过程往往比问题本身更有价值。在探索过程中积累的色彩管理知识、WASM 技术和性能优化经验、以及对业务场景的深入理解，都将成为团队宝贵的技术资产。</p>
<p>更重要的是，这次技术改造不仅解决了燃眉之急，更为后续的图像处理需求奠定了坚实基础。当下次遇到类似的图像处理问题时，我们已经有了一套成熟的解决思路和技术储备。</p>
<p>技术服务业务，业务驱动技术。希望这次实践能为遇到类似问题的朋友们提供一些参考和启发。</p>
<h2 data-id="heading-42">参考文章</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fsharp.pixelplumbing.com%2F" target="_blank" title="https://sharp.pixelplumbing.com/" ref="nofollow noopener noreferrer">High performance Node.js image processing</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fimagemagick.org%2F" target="_blank" title="https://imagemagick.org/" ref="nofollow noopener noreferrer">ImageMagick | Mastering Digital Image Alchemy</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.adobeacp.com%2Fcontent%2Fnews%3Fid%3D1658793062537074" target="_blank" title="https://www.adobeacp.com/content/news?id=1658793062537074" ref="nofollow noopener noreferrer">Photoshop功能|使用颜色配置文件</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.wasmer.io%2Fsdk%2Fwasmer-js%2Fexplainers%2Ftroubleshooting%23sharedarraybuffer-and-cross-origin-isolation" target="_blank" title="https://docs.wasmer.io/sdk/wasmer-js/explainers/troubleshooting#sharedarraybuffer-and-cross-origin-isolation" ref="nofollow noopener noreferrer">Troubleshooting Common Problems</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D5zGfsED7M7U" target="_blank" title="https://www.youtube.com/watch?v=5zGfsED7M7U" ref="nofollow noopener noreferrer">Relative Colorimetric or Perceptual? Which Rendering Intent Should I Use? - YouTube</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D3bY8MVHf0JM%26feature%3Dyoutu.be" target="_blank" title="https://www.youtube.com/watch?v=3bY8MVHf0JM&amp;feature=youtu.be" ref="nofollow noopener noreferrer">What is LAB Color Space? [HD] - YouTube</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F166413369" target="_blank" title="https://zhuanlan.zhihu.com/p/166413369" ref="nofollow noopener noreferrer">浅谈显示器色域：从sRGB到广色域 - 知乎</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWeb_Workers_API%2FTransferable_objects" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Transferable_objects" ref="nofollow noopener noreferrer">可转移对象 - Web API | MDN</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[RustFS高可用集群部署实战：轻松搭建企业级分布式存储架构]]></title>    <link>https://juejin.cn/post/7603699739223916559</link>    <guid>https://juejin.cn/post/7603699739223916559</guid>    <pubDate>2026-02-08T13:05:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603699739223916559" data-draft-id="7603854784864649256" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="RustFS高可用集群部署实战：轻松搭建企业级分布式存储架构"/> <!----> <meta itemprop="datePublished" content="2026-02-08T13:05:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="对象存储与RustFS"/> <meta itemprop="url" content="https://juejin.cn/user/652466093570057"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            RustFS高可用集群部署实战：轻松搭建企业级分布式存储架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/652466093570057/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    对象存储与RustFS
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T13:05:35.000Z" title="Sun Feb 08 2026 13:05:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">RustFS高可用集群部署实战：轻松搭建企业级分布式存储架构</h2>
<p>最近在技术群里看到很多小伙伴在问RustFS集群部署的问题，今天我就把自己在生产环境踩坑总结的集群方案分享给大家。别看是分布式架构，其实比想象中简单多了！</p>
<h3 data-id="heading-1">为什么需要集群部署？</h3>
<p>先讲个真实案例：上个月我们公司单机版RustFS因为硬盘故障导致服务中断6小时，损失惨重。痛定思痛，我花了一周时间研究出了这套高可用方案，现在就算挂掉2个节点都能正常服务！</p>
<h3 data-id="heading-2">集群架构设计</h3>
<h4 data-id="heading-3">最小生产集群（4节点推荐）</h4>
<pre><code class="hljs language-markdown" lang="markdown">┌─────────────────┐
│   负载均衡器     │
│   (Nginx/Haproxy) │
└─────────────────┘
<span class="hljs-code">         ↓
┌───────┬───────┬───────┬───────┐
│ 节点1 │ 节点2 │ 节点3 │ 节点4 │
│ 数据+元数据 │数据+元数据│纯数据节点│纯数据节点│
└───────┴───────┴───────┴───────┘
</span></code></pre>
<p><strong>为什么选4节点？</strong></p>
<ul>
<li>满足纠删码最低要求（4+2模式）</li>
<li>成本与性能的最佳平衡</li>
<li>故障容忍度高（可同时挂2个节点）</li>
</ul>
<h3 data-id="heading-4">环境准备</h3>
<h4 data-id="heading-5">服务器配置（最低要求）</h4>
<pre><code class="hljs language-scss" lang="scss"># <span class="hljs-number">4</span>台CentOS <span class="hljs-number">7.9</span>服务器
节点<span class="hljs-number">1</span>：<span class="hljs-number">10.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.11</span> (元数据+数据)
节点<span class="hljs-number">2</span>：<span class="hljs-number">10.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.12</span> (元数据+数据)  
节点<span class="hljs-number">3</span>：<span class="hljs-number">10.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.13</span> (数据节点)
节点<span class="hljs-number">4</span>：<span class="hljs-number">10.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.14</span> (数据节点)

# 每台服务器配置
CPU：<span class="hljs-number">4</span>核以上
内存：<span class="hljs-number">8</span>GB以上
磁盘：<span class="hljs-number">100</span>GB系统盘 + <span class="hljs-number">500</span>GB数据盘（SSD推荐）
网络：千兆内网互通
</code></pre>
<h4 data-id="heading-6">系统优化配置</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 所有节点执行</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"net.core.somaxconn = 1024"</span> &gt;&gt; /etc/sysctl.conf
<span class="hljs-built_in">echo</span> <span class="hljs-string">"net.ipv4.tcp_max_syn_backlog = 1024"</span> &gt;&gt; /etc/sysctl.conf
<span class="hljs-built_in">echo</span> <span class="hljs-string">"vm.swappiness = 10"</span> &gt;&gt; /etc/sysctl.conf
sysctl -p

<span class="hljs-comment"># 优化磁盘IO</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"deadline"</span> &gt; /sys/block/sdb/queue/scheduler
</code></pre>
<h3 data-id="heading-7">集群部署实战</h3>
<h4 data-id="heading-8">1. 创建共享配置文件</h4>
<p>先准备一个统一的 <code>docker-compose.cluster.yml</code>：</p>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.8'</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">rustfs:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">rustfs/rustfs:1.0.0-alpha.69</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">rustfs</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>
    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">"host"</span>
    
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/rustfs/data:/data</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/rustfs/logs:/logs</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime:ro</span>
    
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_CLUSTER_ENABLED=true</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_CLUSTER_NAME=rustfs-prod</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_API_ENDPOINT=http://10.0.1.11:9000</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_ACCESS_KEY=prod_access_key_2024</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_SECRET_KEY=your_super_secure_secret_key_here</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_BROWSER=on</span>
      
    <span class="hljs-attr">deploy:</span>
      <span class="hljs-attr">resources:</span>
        <span class="hljs-attr">limits:</span>
          <span class="hljs-attr">memory:</span> <span class="hljs-string">4G</span>
          <span class="hljs-attr">cpus:</span> <span class="hljs-string">'2.0'</span>
</code></pre>
<h4 data-id="heading-9">2. 节点差异化配置</h4>
<p><strong>节点1（10.0.1.11）配置：</strong></p>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-comment"># 在共享配置基础上添加</span>
<span class="hljs-attr">environment:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_CLUSTER_MASTER=true</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_METADATA_ENDPOINTS=10.0.1.11:9000,10.0.1.12:9000</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_DATA_ENDPOINTS=10.0.1.11:9000,10.0.1.12:9000,10.0.1.13:9000,10.0.1.14:9000</span>
</code></pre>
<p><strong>节点2（10.0.1.12）配置：</strong></p>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-attr">environment:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_CLUSTER_BACKUP_MASTER=true</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_METADATA_ENDPOINTS=10.0.1.11:9000,10.0.1.12:9000</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_DATA_ENDPOINTS=10.0.1.11:9000,10.0.1.12:9000,10.0.1.13:9000,10.0.1.14:9000</span>
</code></pre>
<p><strong>数据节点（10.0.1.13/14）配置：</strong></p>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-attr">environment:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_DATA_NODE=true</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RUSTFS_METADATA_ENDPOINTS=10.0.1.11:9000,10.0.1.12:9000</span>
</code></pre>
<h4 data-id="heading-10">3. 初始化集群部署脚本</h4>
<p>创建 <code>deploy-cluster.sh</code>：</p>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">set</span> -e

NODES=(<span class="hljs-string">"10.0.1.11"</span> <span class="hljs-string">"10.0.1.12"</span> <span class="hljs-string">"10.0.1.13"</span> <span class="hljs-string">"10.0.1.14"</span>)
MASTER_NODE=<span class="hljs-string">"10.0.1.11"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"开始部署RustFS集群..."</span>

<span class="hljs-comment"># 1. 准备数据目录</span>
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">${NODES[@]}</span>"</span>; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"准备节点: <span class="hljs-variable">$node</span>"</span>
    ssh root@<span class="hljs-variable">$node</span> <span class="hljs-string">"mkdir -p /data/rustfs/{data,logs,config} &amp;&amp; chown -R 10001:10001 /data/rustfs"</span>
<span class="hljs-keyword">done</span>

<span class="hljs-comment"># 2. 分发配置文件</span>
scp docker-compose.cluster.yml root@<span class="hljs-variable">$MASTER_NODE</span>:/data/rustfs/
scp docker-compose.data.yml root@10.0.1.13:/data/rustfs/docker-compose.yml
scp docker-compose.data.yml root@10.0.1.14:/data/rustfs/docker-compose.yml

<span class="hljs-comment"># 3. 按顺序启动节点</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"启动元数据节点..."</span>
ssh root@10.0.1.11 <span class="hljs-string">"cd /data/rustfs &amp;&amp; docker-compose up -d"</span>
<span class="hljs-built_in">sleep</span> 10

ssh root@10.0.1.12 <span class="hljs-string">"cd /data/rustfs &amp;&amp; docker-compose up -d"</span>  
<span class="hljs-built_in">sleep</span> 10

<span class="hljs-built_in">echo</span> <span class="hljs-string">"启动数据节点..."</span>
ssh root@10.0.1.13 <span class="hljs-string">"cd /data/rustfs &amp;&amp; docker-compose up -d"</span>
ssh root@10.0.1.14 <span class="hljs-string">"cd /data/rustfs &amp;&amp; docker-compose up -d"</span>

<span class="hljs-comment"># 4. 等待集群就绪</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"等待集群初始化..."</span>
<span class="hljs-built_in">sleep</span> 30

<span class="hljs-comment"># 5. 验证集群状态</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"检查集群状态..."</span>
curl -f http://<span class="hljs-variable">$MASTER_NODE</span>:9000/minio/cluster/status

<span class="hljs-built_in">echo</span> <span class="hljs-string">"🎉 RustFS集群部署完成！"</span>
</code></pre>
<h3 data-id="heading-11">负载均衡配置</h3>
<h4 data-id="heading-12">Nginx负载均衡</h4>
<pre><code class="hljs language-ini" lang="ini">upstream rustfs_cluster {
    server 10.0.1.11:9000 <span class="hljs-attr">max_fails</span>=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30</span>s<span class="hljs-comment">;</span>
    server 10.0.1.12:9000 <span class="hljs-attr">max_fails</span>=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30</span>s<span class="hljs-comment">;</span>
    server 10.0.1.13:9000 <span class="hljs-attr">max_fails</span>=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30</span>s<span class="hljs-comment">;</span>
    server 10.0.1.14:9000 <span class="hljs-attr">max_fails</span>=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30</span>s<span class="hljs-comment">;</span>
    
    <span class="hljs-comment"># 会话保持（重要！）</span>
    ip_hash<span class="hljs-comment">;</span>
}

server {
    listen 80<span class="hljs-comment">;</span>
    server_name rustfs.yourcompany.com<span class="hljs-comment">;</span>
    
    location / {
        proxy_pass http://rustfs_cluster<span class="hljs-comment">;</span>
        proxy_set_header Host $host<span class="hljs-comment">;</span>
        proxy_set_header X-Real-IP $remote_addr<span class="hljs-comment">;</span>
        proxy_connect_timeout 30s<span class="hljs-comment">;</span>
        proxy_read_timeout 300s<span class="hljs-comment">;</span>
    }
    
    <span class="hljs-comment"># 健康检查</span>
    location /minio/health/live {
        proxy_pass http://rustfs_cluster<span class="hljs-comment">;</span>
        access_log off<span class="hljs-comment">;</span>
    }
}
</code></pre>
<h3 data-id="heading-13">数据安全与备份</h3>
<h4 data-id="heading-14">纠删码配置</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 在master节点配置</span>
environment:
  - <span class="hljs-attr">RUSTFS_ERASURE_CODING</span>=<span class="hljs-number">4</span>:<span class="hljs-number">2</span>  <span class="hljs-comment"># 4个数据块，2个校验块</span>
  - <span class="hljs-attr">RUSTFS_DATA_SHARDS</span>=<span class="hljs-number">4</span>
  - <span class="hljs-attr">RUSTFS_PARITY_SHARDS</span>=<span class="hljs-number">2</span>
</code></pre>
<h4 data-id="heading-15">自动备份策略</h4>
<p>创建 <code>cluster-backup.sh</code>：</p>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># 集群元数据备份</span>
BACKUP_DIR=<span class="hljs-string">"/backup/rustfs/<span class="hljs-subst">$(date +%Y%m%d)</span>"</span>
<span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$BACKUP_DIR</span>

<span class="hljs-comment"># 1. 备份元数据节点配置</span>
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> <span class="hljs-string">"10.0.1.11"</span> <span class="hljs-string">"10.0.1.12"</span>; <span class="hljs-keyword">do</span>
    ssh root@<span class="hljs-variable">$node</span> <span class="hljs-string">"docker exec rustfs tar czf /tmp/metadata.tar.gz /data/.metadata"</span>
    scp root@<span class="hljs-variable">$node</span>:/tmp/metadata.tar.gz <span class="hljs-variable">$BACKUP_DIR</span>/metadata_<span class="hljs-variable">${node}</span>.tar.gz
<span class="hljs-keyword">done</span>

<span class="hljs-comment"># 2. 备份负载均衡配置</span>
<span class="hljs-built_in">cp</span> /etc/nginx/conf.d/rustfs.conf <span class="hljs-variable">$BACKUP_DIR</span>/

<span class="hljs-comment"># 3. 上传到远程存储（可选）</span>
rclone copy <span class="hljs-variable">$BACKUP_DIR</span> oss:rustfs-backup/ --progress

<span class="hljs-built_in">echo</span> <span class="hljs-string">"备份完成: <span class="hljs-variable">$BACKUP_DIR</span>"</span>
</code></pre>
<h3 data-id="heading-16">监控告警体系</h3>
<h4 data-id="heading-17">Prometheus监控配置</h4>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-comment"># prometheus.yml</span>
<span class="hljs-attr">scrape_configs:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">'rustfs-cluster'</span>
    <span class="hljs-attr">static_configs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> 
        <span class="hljs-bullet">-</span> <span class="hljs-string">'10.0.1.11:9000'</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'10.0.1.12:9000'</span> 
        <span class="hljs-bullet">-</span> <span class="hljs-string">'10.0.1.13:9000'</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'10.0.1.14:9000'</span>
    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/minio/metrics/cluster</span>
</code></pre>
<h4 data-id="heading-18">Grafana监控看板</h4>
<p>关键监控指标：</p>
<ul>
<li>节点在线状态</li>
<li>存储空间使用率</li>
<li>请求延迟分布</li>
<li>错误率统计</li>
</ul>
<h3 data-id="heading-19">故障恢复演练</h3>
<h4 data-id="heading-20">模拟节点故障恢复</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 停止一个数据节点</span>
ssh root@10.0.1.13 <span class="hljs-string">"docker-compose down"</span>

<span class="hljs-comment"># 2. 观察集群状态（应该自动切换到其他节点）</span>
curl http://10.0.1.11:9000/minio/cluster/status

<span class="hljs-comment"># 3. 恢复节点</span>
ssh root@10.0.1.13 <span class="hljs-string">"docker-compose up -d"</span>

<span class="hljs-comment"># 4. 数据同步验证</span>
ssh root@10.0.1.13 <span class="hljs-string">"docker logs rustfs --tail=100 | grep sync"</span>
</code></pre>
<h3 data-id="heading-21">常见问题排坑指南</h3>
<h4 data-id="heading-22">问题1：节点间网络不通</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 检查网络连通性</span>
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> 11 12 13 14; <span class="hljs-keyword">do</span>
    ping -c 3 10.0.1.<span class="hljs-variable">$node</span>
    telnet 10.0.1.<span class="hljs-variable">$node</span> 9000
<span class="hljs-keyword">done</span>

<span class="hljs-comment"># 解决方案：配置防火墙</span>
firewall-cmd --add-port=9000/tcp --permanent
firewall-cmd --add-port=9001/tcp --permanent  
firewall-cmd --reload
</code></pre>
<h4 data-id="heading-23">问题2：数据同步失败</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 检查节点时间同步</span>
timedatectl status

<span class="hljs-comment"># 强制时间同步</span>
ntpdate pool.ntp.org

<span class="hljs-comment"># 检查磁盘空间</span>
<span class="hljs-built_in">df</span> -h /data/rustfs
</code></pre>
<h4 data-id="heading-24">问题3：负载不均衡</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 调整负载均衡策略</span>
upstream rustfs_cluster {
    least_conn;  <span class="hljs-comment"># 最少连接数策略</span>
    server 10.0.1.11:9000 weight=2;  <span class="hljs-comment"># 主节点权重更高</span>
    server 10.0.1.12:9000 weight=2;
    server 10.0.1.13:9000 weight=1;
    server 10.0.1.14:9000 weight=1;
}
</code></pre>
<h3 data-id="heading-25">性能优化建议</h3>
<h4 data-id="heading-26">生产环境调优</h4>
<pre><code class="hljs language-bash" lang="bash">environment:
  - RUSTFS_CACHE_SIZE=2G  <span class="hljs-comment"># 根据内存调整</span>
  - RUSTFS_MAX_CONNECTIONS=1000
  - RUSTFS_READ_AFTER_WRITE_QUORUM=2
  - RUSTFS_WRITE_QUORUM=3
</code></pre>
<h3 data-id="heading-27">总结</h3>
<p>通过这套集群方案，我们实现了：</p>
<ul>
<li>✅ 高可用：单节点故障不影响服务</li>
<li>✅ 数据安全：纠删码保证数据可靠性</li>
<li>✅ 弹性扩展：随时添加新节点</li>
<li>✅ 监控告警：实时掌握集群状态</li>
</ul>
<p>​<strong>部署建议</strong>：</p>
<ol>
<li>先在小规模环境测试验证</li>
<li>生产环境务必做好备份</li>
<li>定期进行故障演练</li>
<li>关注RustFS版本更新</li>
</ol>
<p>这套方案在我们生产环境稳定运行了3个月，经历了多次硬件故障考验。如果你在部署过程中遇到问题，欢迎在评论区交流！</p>
<p>觉得有用的话给个三连，下次分享RustFS的性能调优实战！</p>
<hr/>
<p>以下是深入学习 RustFS 的推荐资源：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frustfs%2Frustfs" target="_blank" title="https://github.com/rustfs/rustfs" ref="nofollow noopener noreferrer">RustFS</a></p>
<p>官方文档： <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.rustfs.com%2F" target="_blank" title="https://link.zhihu.com/?target=https%3A//docs.rustfs.com/" ref="nofollow noopener noreferrer">RustFS 官方文档</a>- 提供架构、安装指南和 API 参考。</p>
<p>GitHub 仓库： <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.rustfs.com%2F" target="_blank" title="https://link.zhihu.com/?target=https%3A//docs.rustfs.com/" ref="nofollow noopener noreferrer">GitHub 仓库</a> - 获取源代码、提交问题或贡献代码。</p>
<p>社区支持： <a href="https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Forgs%2Frustfs%2Fdiscussions" target="_blank" title="https://link.zhihu.com/?target=https%3A//github.com/orgs/rustfs/discussions" ref="nofollow noopener noreferrer">GitHub Discussions</a>- 与开发者交流经验和解决方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <!----></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java基础-9：深入 Java 虚拟机（JVM）：从底层源码到核心原理的全面解析]]></title>    <link>https://juejin.cn/post/7603677143215046671</link>    <guid>https://juejin.cn/post/7603677143215046671</guid>    <pubDate>2026-02-08T14:00:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603677143215046671" data-draft-id="7603699739223982095" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java基础-9：深入 Java 虚拟机（JVM）：从底层源码到核心原理的全面解析"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-02-08T14:00:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="beata"/> <meta itemprop="url" content="https://juejin.cn/user/1839900247461280"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java基础-9：深入 Java 虚拟机（JVM）：从底层源码到核心原理的全面解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1839900247461280/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    beata
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T14:00:34.000Z" title="Sun Feb 08 2026 14:00:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言：为什么需要理解 JVM？</h2>
<p>Java 的“一次编写，到处运行”并非魔法，而是由 <strong>Java 虚拟机（JVM）</strong> 这一精妙的运行时环境实现的。然而，许多开发者仅停留在 <code>java -jar</code> 启动应用的层面，对 JVM 内部如何加载类、分配内存、执行字节码、回收垃圾一无所知。这导致在面对 <strong>OOM（OutOfMemoryError）</strong>、<strong>高 CPU 占用</strong>、<strong>GC 频繁停顿</strong> 等问题时束手无策。</p>
<p>本文将带你<strong>深入 JVM 底层</strong>，结合 <strong>HotSpot 源码</strong>（OpenJDK 主流实现）与<strong>核心原理</strong>，系统性地揭开 JVM 的神秘面纱。我们将从启动流程、内存模型、类加载、执行引擎到垃圾回收，层层递进，真正理解“Java 是如何跑起来的”。</p>
<hr/>
<h2 data-id="heading-1">一、JVM 是什么？—— 架构总览</h2>
<p>JVM 并非一个单一程序，而是一个<strong>规范 + 实现</strong>。目前最主流的实现是 <strong>HotSpot VM</strong>（由 Oracle 维护，集成于 OpenJDK/Oracle JDK）。</p>
<h3 data-id="heading-2">HotSpot 的核心组件（C++ 实现）</h3>



































<table><thead><tr><th>组件</th><th>功能</th><th>源码位置（OpenJDK）</th></tr></thead><tbody><tr><td><strong>Class Loader Subsystem</strong></td><td>加载 <code>.class</code> 字节码</td><td><code>src/hotspot/share/classfile/</code></td></tr><tr><td><strong>Runtime Data Areas</strong></td><td>运行时内存布局</td><td><code>src/hotspot/share/memory/</code></td></tr><tr><td><strong>Execution Engine</strong></td><td>执行字节码（解释器 + JIT）</td><td><code>src/hotspot/share/interpreter/</code>, <code>src/hotspot/share/opto/</code></td></tr><tr><td><strong>Garbage Collector</strong></td><td>自动内存管理</td><td><code>src/hotspot/share/gc/</code></td></tr><tr><td><strong>Native Interface (JNI)</strong></td><td>调用本地 C/C++ 代码</td><td><code>src/hotspot/share/prims/</code></td></tr></tbody></table>
<blockquote>
<p>🔍 <strong>提示</strong>：OpenJDK 源码可在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenjdk%2Fjdk" target="_blank" title="https://github.com/openjdk/jdk" ref="nofollow noopener noreferrer">github.com/openjdk/jdk</a> 查看。</p>
</blockquote>
<hr/>
<h2 data-id="heading-3">二、JVM 启动流程：从 <code>java</code> 命令到 main 方法</h2>
<p>当你执行 <code>java MyApp</code> 时，JVM 经历了以下关键步骤：</p>
<ol>
<li><strong>启动 Launcher（C 语言）</strong><br/>
<code>java.c</code> → <code>JLI_Launch()</code> → 初始化 JVM 参数、classpath。</li>
<li><strong>创建 JVM 实例（JNI_CreateJavaVM）</strong><br/>
调用 <code>Threads::create_vm()</code>（位于 <code>thread.cpp</code>），完成：
<ul>
<li>初始化堆内存</li>
<li>创建主线程（main thread）</li>
<li>启动解释器</li>
</ul>
</li>
<li><strong>加载主类（MyApp.class）</strong><br/>
通过 <code>SystemDictionary::resolve_or_fail()</code> 加载并链接 <code>MyApp</code>。</li>
<li><strong>调用 main 方法</strong><br/>
通过 JNI 反射机制：<code>env-&gt;CallStaticVoidMethod(cls, main_id, args)</code>。</li>
</ol>
<blockquote>
<p>💡 <strong>关键点</strong>：JVM 本身是用 C++ 编写的，但其“灵魂”——字节码执行和 GC——大量使用汇编优化。</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">三、运行时数据区：JVM 的内存布局（HotSpot 实现）</h2>
<p>JVM 规范定义了逻辑内存区域，HotSpot 对其进行了高效实现：</p>
<pre><code class="hljs language-plaintext" lang="plaintext">+---------------------------------+
|            Method Area          | ← 存储类元数据（JDK8+ 为 Metaspace，使用 native memory）
+---------------------------------+
|              Heap               | ← 所有对象实例、数组（分代：Young/Old）
+---------------------------------+
| Thread 1: Java Virtual Machine Stack | ← 线程私有，栈帧（Frame）包含局部变量表、操作数栈
| Thread 2: Java Virtual Machine Stack |
| ...                             |
+---------------------------------+
|        PC Register (per thread) | ← 记录当前执行的字节码指令地址
+---------------------------------+
|     Native Method Stack         | ← 用于 JNI 调用
+---------------------------------+
</code></pre>
<h3 data-id="heading-5">关键细节（源码视角）</h3>
<ul>
<li><strong>堆初始化</strong>：<code>Universe::initialize_heap()</code>（<code>universe.cpp</code>）<br/>
根据 GC 类型（G1/ZGC等）创建不同结构的堆。</li>
<li><strong>栈帧创建</strong>：<code>InterpreterRuntime::new_frame()</code><br/>
每次方法调用，JVM 在当前线程栈上 push 一个新帧。</li>
<li><strong>Metaspace</strong>：<code>Metaspace::allocate()</code><br/>
使用 <code>mmap()</code> 直接向操作系统申请内存，避免 OOM 导致 JVM 崩溃。</li>
</ul>
<h3 data-id="heading-6">补充说明：运行时数据区详解</h3>
<p>JVM 的运行时数据区是程序执行的“舞台”，所有变量、对象、方法调用都依赖于这一内存模型。值得注意的是，<strong>JVM 规范只定义了逻辑结构，具体实现由各虚拟机厂商决定</strong>。HotSpot 作为事实标准，其内存管理高度优化，但也带来了理解上的复杂性。</p>
<h4 data-id="heading-7">线程私有 vs 线程共享</h4>
<ul>
<li>
<p><strong>线程私有区域</strong>（每个线程独立拥有）：</p>
<ul>
<li><strong>程序计数器（PC Register）</strong>：<br/>
这是唯一一个在 JVM 规范中<strong>不会发生 OutOfMemoryError</strong> 的区域。它记录当前线程正在执行的字节码指令地址。如果是 native 方法，则值为 undefined。</li>
<li><strong>Java 虚拟机栈（Java Virtual Machine Stack）</strong>：<br/>
每次方法调用都会创建一个<strong>栈帧（Stack Frame）</strong>。栈帧包含：
<ul>
<li><strong>局部变量表（Local Variable Table）</strong>：以 slot 为单位存储基本类型、对象引用（非对象本身！）。</li>
<li><strong>操作数栈（Operand Stack）</strong>：用于字节码指令的计算（如 <code>iadd</code> 从栈顶弹出两个 int 相加后压回）。</li>
<li><strong>动态链接（Dynamic Linking）</strong>：指向运行时常量池的引用，支持方法调用时的符号解析。</li>
<li><strong>方法返回地址</strong>：用于正常或异常返回时恢复上层调用。</li>
</ul>
<blockquote>
<p>⚠️ 栈溢出（<code>StackOverflowError</code>）通常由无限递归或过深调用链引起；而 <code>-Xss</code> 参数可调整单个线程栈大小。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>线程共享区域</strong>（所有线程共用）：</p>
<ul>
<li><strong>堆（Heap）</strong>：<br/>
几乎所有对象实例和数组都在此分配（JIT 逃逸分析可能导致栈上分配例外）。它是 GC 的主战场，也是 OOM 最常发生的区域。</li>
<li><strong>方法区（Method Area）</strong>：<br/>
存储<strong>类的元数据</strong>，包括：
<ul>
<li>类的全限定名、父类、接口</li>
<li>字段和方法信息（含字节码）</li>
<li>常量池（Constant Pool）</li>
<li>静态变量（注意：JDK 7+ 已将字符串常量池移入堆）</li>
</ul>
<blockquote>
<p>🔥 <strong>Metaspace 的革命性改进</strong>：<br/>
JDK 8 彻底废弃了“永久代（PermGen）”，改用 <strong>Metaspace</strong> —— 它不再受限于 JVM 堆内存，而是直接使用操作系统的本地内存（native memory）。这意味着：</p>
<ul>
<li>不再因“永久代满”导致 Full GC；</li>
<li>可通过 <code>-XX:MaxMetaspaceSize</code> 限制其上限（默认无限制，可能耗尽物理内存）；</li>
<li>元数据分配失败会抛出 <code>java.lang.OutOfMemoryError: Metaspace</code>，而非旧版的 <code>PermGen space</code>。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 <strong>实践提示</strong>：<br/>
使用 <code>jcmd &lt;pid&gt; VM.metaspace</code> 可实时查看 Metaspace 使用情况；<br/>
在微服务或热部署频繁的场景中，务必监控 Metaspace，防止类加载器泄漏（ClassLoader Leak）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-8">四、类加载机制：双亲委派与字节码验证</h2>
<h3 data-id="heading-9">1. 类加载器层次</h3>
<pre><code class="hljs language-java" lang="java">Bootstrap <span class="hljs-title function_">ClassLoader</span> <span class="hljs-params">(C++)</span> 
    ↑
Extension <span class="hljs-title function_">ClassLoader</span> <span class="hljs-params">(sun.misc.Launcher$ExtClassLoader)</span>
    ↑
Application <span class="hljs-title function_">ClassLoader</span> <span class="hljs-params">(sun.misc.Launcher$AppClassLoader)</span>
</code></pre>
<h3 data-id="heading-10">2. 双亲委派模型（源码：<code>ClassLoader.loadClass()</code>）</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) {
    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) {
        <span class="hljs-comment">// 1. 先检查是否已加载</span>
        Class&lt;?&gt; c = findLoadedClass(name);
        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 2. 委托父加载器</span>
                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) {
                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 3. 顶层委托给 Bootstrap</span>
                    c = findBootstrapClassOrNull(name);
                }
            } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {}
            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 4. 自己加载</span>
                c = findClass(name);
            }
        }
        <span class="hljs-keyword">if</span> (resolve) resolveClass(c);
        <span class="hljs-keyword">return</span> c;
    }
}
</code></pre>
<blockquote>
<p>✅ <strong>目的</strong>：防止用户自定义 <code>java.lang.String</code> 覆盖核心类，保障安全。</p>
</blockquote>
<h3 data-id="heading-11">3. 字节码验证（Verification）</h3>
<p>在 <code>ClassFileParser::parseClassFile()</code> 中，JVM 会对字节码进行四阶段验证：</p>
<ol>
<li>文件格式验证（魔数、版本）</li>
<li>元数据验证（继承关系、final 方法）</li>
<li>字节码验证（操作数栈溢出、类型匹配）</li>
<li>符号引用验证（链接阶段）</li>
</ol>
<h3 data-id="heading-12">补充说明：类加载机制深度解析</h3>
<p>类加载是 JVM 将 <code>.class</code> 文件转化为可执行 Java 类型的关键过程。它不仅是“读取文件”那么简单，而是一套<strong>安全、可靠、可扩展</strong>的机制。</p>
<h4 data-id="heading-13">类加载的完整生命周期</h4>
<p>JVM 规范将类加载分为 <strong>5 个阶段</strong>，通常合并为 <strong>3 步</strong>：</p>
<ol>
<li>
<p><strong>加载（Loading）</strong></p>
<ul>
<li>通过类的全限定名获取其二进制字节流（来源不限于 <code>.class</code> 文件，也可来自网络、数据库、动态生成等）；</li>
<li>将字节流解析为 JVM 内部的 <code>InstanceKlass</code> 或 <code>InstanceMirrorKlass</code> 对象；</li>
<li>在方法区中创建类的运行时表示；</li>
<li>在堆中创建 <code>java.lang.Class</code> 对象作为访问入口。</li>
</ul>
</li>
<li>
<p><strong>链接（Linking）</strong></p>
<ul>
<li><strong>验证（Verification）</strong>：确保字节码符合 JVM 规范，防止恶意代码破坏虚拟机（见下文详述）；</li>
<li><strong>准备（Preparation）</strong>：为<strong>静态变量</strong>分配内存并设置<strong>初始值</strong>（注意：不是赋值！例如 <code>static int x = 100;</code> 此时 <code>x = 0</code>）；</li>
<li><strong>解析（Resolution）</strong>：将常量池中的符号引用（如 <code>#3 = Methodref java/lang/Object."&lt;init&gt;":()V</code>）替换为直接引用（如内存地址或偏移量）。</li>
</ul>
</li>
<li>
<p><strong>初始化（Initialization）</strong></p>
<ul>
<li>执行 <code>&lt;clinit&gt;</code> 方法（由编译器自动生成，包含所有静态变量赋值和 static 块）；</li>
<li><strong>这是类加载的最后一步，也是 Java 代码真正开始执行的起点</strong>；</li>
<li>初始化是<strong>线程安全</strong>的：JVM 会加锁，确保同一类只被初始化一次。</li>
</ul>
</li>
</ol>
<h4 data-id="heading-14">双亲委派模型的深层意义</h4>
<p>双亲委派不仅是“先问爸爸”，更是一种<strong>安全沙箱机制</strong>：</p>
<ul>
<li><strong>核心类隔离</strong>：<code>java.*</code> 包下的类只能由 Bootstrap ClassLoader 加载。即使你在 classpath 放一个 <code>java.lang.HackString.class</code>，AppClassLoader 在尝试加载时会先委托给父加载器，而父加载器（Bootstrap）早已加载了真正的 <code>String</code>，因此你的“伪造类”永远不会被使用。</li>
<li><strong>避免类重复加载</strong>：同一个类在 JVM 中由 <strong>“类加载器 + 类全名”</strong> 唯一确定。若无委派机制，不同加载器可能加载同一类多次，导致 <code>ClassCastException</code>（看似相同类型，实则不同 Class 对象）。</li>
</ul>
<blockquote>
<p>🛠️ <strong>打破双亲委派？</strong><br/>
某些框架（如 Tomcat、OSGi）需要<strong>隔离不同应用的类</strong>，会自定义类加载器并<strong>重写 <code>loadClass()</code> 方法</strong>，实现“子优先”策略。但这必须谨慎处理，否则极易引发类冲突。</p>
</blockquote>
<h4 data-id="heading-15">字节码验证：JVM 的“安检门”</h4>
<p>验证是保障 JVM 稳定性的基石。HotSpot 在 <code>ClassVerifier</code> 中实现了严格的四阶段检查：</p>
<ul>
<li><strong>第一阶段：文件格式验证</strong><br/>
检查魔数（<code>0xCAFEBABE</code>）、主次版本号是否兼容当前 JVM。</li>
<li><strong>第二阶段：元数据验证</strong><br/>
检查类是否继承了 final 类、方法是否重写了不可重写的方法等。</li>
<li><strong>第三阶段：字节码验证（最耗时）</strong><br/>
模拟执行字节码，验证：
<ul>
<li>操作数栈不会溢出/下溢；</li>
<li>所有跳转指令指向合法位置；</li>
<li>方法调用参数类型匹配；</li>
<li><code>return</code> 类型与方法声明一致。</li>
</ul>
</li>
<li><strong>第四阶段：符号引用验证</strong><br/>
在解析阶段，确保引用的类、字段、方法确实存在且可访问。</li>
</ul>
<blockquote>
<p>🔒 <strong>安全价值</strong>：<br/>
即使你通过 <code>Unsafe.defineAnonymousClass()</code> 动态生成字节码，JVM 仍会对其进行验证（除非显式关闭 <code>-noverify</code>，但生产环境严禁使用）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-16">五、执行引擎：解释器 + JIT 编译器</h2>
<p>JVM 不直接执行 Java 源码，而是执行 <strong>字节码（bytecode）</strong>。执行引擎负责将其转化为机器码。</p>
<h3 data-id="heading-17">1. 解释器（Interpreter）</h3>
<ul>
<li><strong>工作方式</strong>：逐条读取字节码，查表（dispatch table）执行对应 C++ 函数。</li>
<li><strong>源码</strong>：<code>templateTable_x86_64.cpp</code> 定义了每条字节码的汇编模板。</li>
<li><strong>优点</strong>：启动快；<strong>缺点</strong>：执行慢。</li>
</ul>
<h3 data-id="heading-18">2. JIT（Just-In-Time）编译器</h3>
<p>当某段代码被频繁执行（“热点代码”），JIT 会将其编译为<strong>本地机器码</strong>并缓存。</p>
<h4 data-id="heading-19">HotSpot 的两级 JIT：</h4>




















<table><thead><tr><th>编译器</th><th>触发条件</th><th>优化级别</th></tr></thead><tbody><tr><td><strong>C1（Client Compiler）</strong></td><td>方法调用 &gt; 1500 次</td><td>快速编译，少量优化</td></tr><tr><td><strong>C2（Server Compiler）</strong></td><td>方法调用 &gt; 10000 次</td><td>深度优化（内联、逃逸分析等）</td></tr></tbody></table>
<blockquote>
<p>🔥 <strong>JIT 优化示例</strong>：</p>
<ul>
<li><strong>方法内联（Inlining）</strong>：消除虚方法调用开销</li>
<li><strong>逃逸分析（Escape Analysis）</strong>：栈上分配对象，减少 GC 压力</li>
<li><strong>锁消除（Lock Elimination）</strong>：去除不可能竞争的 synchronized</li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-20">六、垃圾回收（GC）：自动内存管理的艺术</h2>
<p>GC 是 JVM 最复杂的子系统。其核心任务：<strong>安全、高效地回收不再使用的对象</strong>。</p>
<h3 data-id="heading-21">1. 如何判断对象死亡？—— 可达性分析</h3>
<p>从 <strong>GC Roots</strong> 出发（包括：栈帧局部变量、静态变量、JNI 引用等），通过引用链搜索存活对象。无法到达的对象即为垃圾。</p>
<blockquote>
<p>❌ 不再使用“引用计数法”（无法解决循环引用问题）。</p>
</blockquote>
<h3 data-id="heading-22">2. 分代收集理论（Generational Hypothesis）</h3>
<ul>
<li><strong>弱分代假说</strong>：绝大多数对象“朝生夕死”。</li>
<li><strong>强分代假说</strong>：熬过多次 GC 的对象更可能长期存活。</li>
</ul>
<p>因此，HotSpot 将堆分为：</p>
<ul>
<li><strong>新生代（Young Gen）</strong>：Eden + Survivor（S0/S1）</li>
<li><strong>老年代（Old Gen）</strong></li>
</ul>
<h3 data-id="heading-23">3. 主流 GC 算法对比</h3>















































<table><thead><tr><th>GC</th><th>算法</th><th>STW 时间</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>复制（Young）+ 标记-整理（Old）</td><td>高</td><td>单核、小内存</td></tr><tr><td><strong>Parallel</strong></td><td>并行复制 + 并行标记-整理</td><td>中高</td><td>吞吐优先</td></tr><tr><td><strong>CMS</strong></td><td>并发标记-清除</td><td>低（但有碎片）</td><td>已废弃（JDK14+）</td></tr><tr><td><strong>G1</strong></td><td>Region + 并发标记 + 混合回收</td><td>低（可预测）</td><td>大堆（4~64GB）</td></tr><tr><td><strong>ZGC</strong></td><td>着色指针 + 并发重定位</td><td><strong>&lt; 1ms</strong></td><td>TB 级、超低延迟</td></tr><tr><td><strong>Shenandoah</strong></td><td>Brooks 指针 + 并发转移</td><td><strong>&lt; 10ms</strong></td><td>通用低延迟</td></tr></tbody></table>
<h3 data-id="heading-24">4. ZGC 源码亮点（<code>zCollectedHeap.cpp</code>）</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ZGC 的并发重定位核心</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZRelocate::relocate_object</span><span class="hljs-params">(oop* p)</span> </span>{
  oop obj = *p;
  <span class="hljs-keyword">if</span> (ZAddress::<span class="hljs-built_in">is_marked</span>(ZOop::<span class="hljs-built_in">address</span>(obj))) {
    oop new_obj = _allocator.<span class="hljs-built_in">alloc_object</span>(ZOop::<span class="hljs-built_in">size</span>(obj));
    <span class="hljs-built_in">copy_to_new_location</span>(obj, new_obj);
    ZForwarding::<span class="hljs-built_in">set_target</span>(obj, new_obj); <span class="hljs-comment">// 设置转发指针</span>
    *p = new_obj; <span class="hljs-comment">// 更新引用</span>
  }
}
</code></pre>
<blockquote>
<p>✨ 通过 <strong>读屏障</strong>，应用线程在访问对象时自动跳转到新地址，实现“无感迁移”。</p>
</blockquote>
<hr/>
<h2 data-id="heading-25">七、性能调优：从监控到实战</h2>
<h3 data-id="heading-26">1. 关键监控命令</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看 GC 日志（JDK9+）</span>
java -Xlog:gc*:gc.log MyApp

<span class="hljs-comment"># 实时监控</span>
jstat -gc &lt;pid&gt; 1000

<span class="hljs-comment"># 堆转储分析</span>
jmap -dump:format=b,file=heap.hprof &lt;pid&gt;
</code></pre>
<h3 data-id="heading-27">2. 常见调优参数</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 选择低延迟 GC</span>
-XX:+UseZGC
-XX:+UseShenandoahGC

<span class="hljs-comment"># 控制堆大小</span>
-Xms4g -Xmx4g

<span class="hljs-comment"># G1 调优</span>
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=16m
</code></pre>
<hr/>
<h2 data-id="heading-28">结语：JVM —— Java 的“操作系统”</h2>
<p>JVM 远不止是一个“运行 Java 的容器”。它是一个集 <strong>内存管理、并发控制、即时编译、安全验证</strong> 于一体的复杂系统。理解其底层原理，不仅能让你写出更高效的代码，更能让你在系统出现故障时<strong>快速定位根因</strong>，成为真正的“Java 高手”。</p>
<blockquote>
<p><strong>最后建议</strong>：</p>
<ul>
<li>阅读《深入理解 Java 虚拟机》（周志明）</li>
<li>浏览 OpenJDK HotSpot 源码</li>
<li>在生产环境中开启 GC 日志，持续观察</li>
</ul>
</blockquote>
<p>掌握 JVM，就是掌握了 Java 应用的“命脉”。</p>
<hr/>
<p><strong>参考资料</strong>：</p>
<ul>
<li>OpenJDK 源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenjdk%2Fjdk" target="_blank" title="https://github.com/openjdk/jdk" ref="nofollow noopener noreferrer">github.com/openjdk/jdk</a></li>
<li>JVM Specification：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2F" target="_blank" title="https://docs.oracle.com/javase/specs/" ref="nofollow noopener noreferrer">docs.oracle.com/javase/spec…</a></li>
<li>ZGC Paper (Oracle)：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oracle.com%2Ftechnical-resources%2Farticles%2Fjava%2Fzgc.html" target="_blank" title="https://www.oracle.com/technical-resources/articles/java/zgc.html" ref="nofollow noopener noreferrer">www.oracle.com/technical-r…</a></li>
<li>Shenandoah GC Wiki：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwiki.openjdk.org%2Fdisplay%2Fshenandoah%2FMain" target="_blank" title="https://wiki.openjdk.org/display/shenandoah/Main" ref="nofollow noopener noreferrer">wiki.openjdk.org/display/she…</a></li>
</ul>
<blockquote>
<p><strong>作者</strong>：架构师Beata<br/>
<strong>日期</strong>：2026年2月8日
<strong>声明</strong>：本文基于网络文档整理，如有疏漏，欢迎指正。转载请注明出处。<br/>
<strong>互动</strong>：如有任何问题？欢迎在评论区分享！</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[HashMap源码深度剖析]]></title>    <link>https://juejin.cn/post/7603895839556599871</link>    <guid>https://juejin.cn/post/7603895839556599871</guid>    <pubDate>2026-02-08T14:29:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603895839556599871" data-draft-id="7603643385816318004" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="HashMap源码深度剖析"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T14:29:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wiittch"/> <meta itemprop="url" content="https://juejin.cn/user/1910300244458315"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            HashMap源码深度剖析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1910300244458315/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wiittch
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T14:29:28.000Z" title="Sun Feb 08 2026 14:29:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"/>
<h2 data-id="heading-1">一. HashMap为什么这么重要</h2>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap
      顶层接口
          Map
            HashMap
            LinkedHashMap
            TreeMap
            HashTable
            ConcurrentHashMap
          Collection 
            List
              ArrayList
              LinkedList
            Set
              HashSet
              TreeSet
              LinkedHashSet
            Queue
    
</code></pre>
<pre><code class="hljs language-ini" lang="ini">// HashMap的"衍生品"
<span class="hljs-attr">HashSet</span> = HashMap的Key视图
<span class="hljs-attr">LinkedHashMap</span> = HashMap + 双向链表
<span class="hljs-attr">ConcurrentHashMap</span> = 线程安全的HashMap变体
</code></pre>
<p><strong>HashMap之所以成为Java开发者必须掌握的核心数据结构，是因为它在横向对比中代表了工程优化的极致平衡，在纵向深度上揭示了计算机科学的经典范式。</strong></p>
<p>横向看，HashMap以近乎O(1)的查询性能超越了线性结构的List和有序结构的TreeMap，用0.75负载因子的巧妙设计平衡了时间与空间；纵向深入，它的演化史本身就是一部微缩的算法优化史——从JDK 7的链表碰撞到JDK 8的红黑树优化，从单线程设计到ConcurrentHashMap的分段锁再到CAS无锁化，每个版本迭代都体现了数据结构、并发编程与JVM特性的深度融合。<strong>理解HashMap不仅是在学习一个容器，更是在理解如何在现实约束下（内存、并发、性能）做出最优工程取舍的设计哲学。</strong></p>
<h2 data-id="heading-2">二.HashMap源码解读</h2>
<h3 data-id="heading-3">1.理解基础数据结构</h3>
<p><strong>1.1 核心内部类对比</strong></p>
<pre><code class="hljs language-scala" lang="scala">static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>{
    <span class="hljs-keyword">final</span> int hash;
    <span class="hljs-keyword">final</span> <span class="hljs-type">K</span> key;
    <span class="hljs-type">V</span> value;
    <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next;  <span class="hljs-comment">// 单向链表</span>
}

<span class="hljs-comment">// 2. 树节点（继承体系关键！）</span>
static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>{
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// 红黑树父节点</span>
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;    <span class="hljs-comment">// 左子树</span>
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;   <span class="hljs-comment">// 右子树</span>
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// ❗️双向链表前驱（退化关键）</span>
    boolean red;           <span class="hljs-comment">// 颜色标记</span>
    <span class="hljs-comment">// next继承自父类</span>
}

<span class="hljs-comment">// 3. LinkedHashMap.Entry（桥梁作用）</span>
static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>{
    <span class="hljs-type">Entry</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; before, after;  <span class="hljs-comment">// 双向链表</span>
}
</code></pre>
<p>HashMap的树化机制建立在精巧的类继承体系之上。基础链表节点<code>Node</code>仅维护单向<code>next</code>指针，存储键值对和哈希值。而树化后的<code>TreeNode</code>并未直接继承<code>Node</code>，而是通过继承<code>LinkedHashMap.Entry</code>间接继承<code>Node</code>，形成三层结构。这种设计使<code>TreeNode</code>同时具备红黑树的<code>parent/left/right</code>指针、保留退化所需的双向链表<code>prev/next</code>指针，并与<code>LinkedHashMap</code>保持结构兼容。<code>LinkedHashMap.Entry</code>作为中间层，添加了<code>before/after</code>指针维护访问顺序，使得<code>TreeNode</code>无需重复实现链表功能即可支持退化操作，体现了“组合优于继承”的设计思想。
<strong>1.2 核心常量定义</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;     <span class="hljs-comment">// 树化阈值</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;   <span class="hljs-comment">// 退化阈值  </span>
<span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>; <span class="hljs-comment">// 最小树化容量</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;
<span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;
</code></pre>
<p>HashMap通过一组精心设计的常量控制树化行为。<code>TREEIFY_THRESHOLD=8</code>基于泊松分布，表示链表长度超过此值（概率仅0.000006%）时才考虑树化；<code>UNTREEIFY_THRESHOLD=6</code>作为退化阈值，与树化阈值形成大小为2的缓冲带，防止节点数在临界点附近频繁触发结构转换。<code>MIN_TREEIFY_CAPACITY=64</code>规定了最小树化容量，当哈希表容量小于此值时优先扩容而非树化，因为小容量下树化的内存开销占比过高。配合默认初始容量<code>16</code>和负载因子<code>0.75</code>，这些常量共同构成一个平衡性能与空间的弹性系统。</p>
<h3 data-id="heading-4">2.HashMap在JDK中的树化触发链（完整调用栈）</h3>
<p><strong>2.1 入口：put() → putVal()</strong></p>
<pre><code class="hljs language-scss" lang="scss">public V <span class="hljs-built_in">put</span>(K key, V value) {
    return <span class="hljs-built_in">putVal</span>(hash(key), key, value, false, true);
}

final V <span class="hljs-built_in">putVal</span>(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;<span class="hljs-selector-attr">[]</span> tab; Node&lt;K,V&gt; <span class="hljs-selector-tag">p</span>; int n, <span class="hljs-selector-tag">i</span>;
    <span class="hljs-comment">// ... 省略初始化逻辑</span>
    
    <span class="hljs-comment">// 🎯 关键循环：遍历链表</span>
    for (int binCount = <span class="hljs-number">0</span>; ; ++binCount) {
        if ((e = p.next) == null) {
            <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.next</span> = <span class="hljs-built_in">newNode</span>(hash, key, value, null);
            if (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>
                <span class="hljs-built_in">treeifyBin</span>(tab, hash);  <span class="hljs-comment">// 触发树化</span>
            break;
        }
        <span class="hljs-comment">// ... 省略查找逻辑</span>
    }
    
    <span class="hljs-comment">// 修改计数和扩容检查</span>
    ++modCount;
    if (++size &gt; threshold)
        <span class="hljs-attribute">resize</span>();
}
</code></pre>
<p>HashMap的树化触发始于<code>put()</code>方法调用，其核心逻辑封装在<code>putVal()</code>中。当向桶中插入新节点时，方法通过<code>binCount</code>变量统计当前链表长度，当检测到链表长度即将达到阈值（<code>binCount &gt;= TREEIFY_THRESHOLD - 1</code>，即已有8个节点且正在插入第9个）时，调用<code>treeifyBin()</code>尝试树化。但这里仅完成长度检查，真正的树化还需在<code>treeifyBin()</code>中验证容量是否达标。这种分层检查机制确保了树化只在链表过长且哈希表规模足够大时才发生，避免在小容量场景下进行低效的结构转换。
<strong>2.2 树化前检查：treeifyBin()</strong></p>























<table><thead><tr><th>版本</th><th>数据结构</th><th>冲突解决方案</th><th>最坏时间复杂度</th></tr></thead><tbody><tr><td>JDK1.7及之前</td><td>数组+链表</td><td>纯拉链法</td><td>O(n)</td></tr><tr><td>JDK1.8之后</td><td>数组+链表+红黑树</td><td>混合策略</td><td>O(log n)</td></tr></tbody></table>
<p><strong>数组+链表的方法就是采用拉链法来解决冲突，之后在数组&gt;64和链表&gt;8的情况下采用红黑树来解决冲突。</strong></p>
<p><strong>数组&gt;64</strong>：当数组的桶数超过一定大小时（例如64），意味着哈希表的规模已经相当大，单纯依赖链表会导致链表变得过长，查找、插入和删除的效率会急剧下降。此时使用红黑树能够提供更好的性能。红黑树是一种平衡的二叉搜索树，能够保证最坏情况下查找、插入和删除操作的时间复杂度为 O(log N)。
<strong>注意数组小于64的时候采用的是数组扩容的方法。因为数组比较小的情况下变成红黑树结构需要进行左旋，右旋，变色来保持平衡，反而会降低效率。同时数组长度小搜索时间也会相对快。</strong>
在 <code>treeifyBin</code> 中，当桶的大小超过了阈值（即 <code>TREEIFY_THRESHOLD</code>，也就是 8）时，会将链表中的节点转换为红黑树节点（<code>TreeNode</code>）。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * HashMap核心方法：将链表转化为红黑树
 * 
 * 触发条件：当单个桶(bucket)中的链表长度超过8，且HashMap容量达到64时
 * 目的：优化极端情况下的查询性能（从O(n)提升到O(log n)）
 * 
 * <span class="hljs-doctag">@param</span> tab  HashMap的桶数组
 * <span class="hljs-doctag">@param</span> hash 触发转换的key的hash值
 * 
 * 面试考点：
 * 1. 为什么是链表长度&gt;8才树化？
 * 2. 为什么需要容量&gt;=64才树化？
 * 3. 红黑树退化为链表的条件是什么？
 */</span>
final <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span>(<span class="hljs-params">Node&lt;K,V&gt;[] tab, int hash</span>) {
    int n, index;  <span class="hljs-comment">// n: 数组长度，index: 目标桶索引</span>
    <span class="hljs-title class_">Node</span>&lt;K,V&gt; e;   <span class="hljs-comment">// 当前遍历的链表节点</span>
    
    <span class="hljs-comment">// ⚡ 条件检查：容量不足时先扩容而不是树化</span>
    <span class="hljs-comment">// 这是重要的性能优化：扩容可能直接分散节点，避免不必要的树化开销</span>
    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.<span class="hljs-property">length</span>) &lt; <span class="hljs-variable constant_">MIN_TREEIFY_CAPACITY</span>) {
        <span class="hljs-title function_">resize</span>();  <span class="hljs-comment">// 优先尝试扩容（MIN_TREEIFY_CAPACITY = 64）</span>
        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 扩容后可能就不需要树化了</span>
    }
    
    <span class="hljs-comment">// 🔍 定位到目标桶，且桶不为空</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 红黑树的双向链表头部和尾部指针</span>
        <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// head, tail</span>
        
        <span class="hljs-comment">// 🔄 遍历链表，将所有Node转换为TreeNode</span>
        <span class="hljs-comment">// 注意：这里先构建一个TreeNode的双向链表，而不是直接构建树</span>
        <span class="hljs-keyword">do</span> {
            <span class="hljs-comment">// 将普通Node转换为TreeNode（TreeNode继承自Node，但多了红黑树需要的属性）</span>
            <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; p = <span class="hljs-title function_">replacementTreeNode</span>(e, <span class="hljs-literal">null</span>);
            
            <span class="hljs-comment">// 构建双向链表</span>
            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>) {
                hd = p;        <span class="hljs-comment">// 第一个节点作为头节点</span>
            } <span class="hljs-keyword">else</span> {
                p.<span class="hljs-property">prev</span> = tl;   <span class="hljs-comment">// 当前节点的前驱指向尾节点</span>
                tl.<span class="hljs-property">next</span> = p;   <span class="hljs-comment">// 尾节点的后继指向当前节点</span>
            }
            tl = p;           <span class="hljs-comment">// 更新尾节点</span>
        } <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-property">next</span>) != <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 遍历原链表</span>
        
        <span class="hljs-comment">// ✨ 关键步骤：将桶中的链表替换为TreeNode双向链表</span>
        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 🎯 真正的树化操作：将双向链表转化为红黑树</span>
            hd.<span class="hljs-title function_">treeify</span>(tab);  <span class="hljs-comment">// 这个方法会进行红黑树的平衡操作</span>
        }
    }
}
</code></pre>
<p><strong>链表&gt;8</strong>：如果在某个桶中，链表长度超过了一个阈值（例如8），这说明哈希冲突比较严重，链表的性能也会下降。链表的查找操作是 O(n)，如果链表很长，查找性能会非常低。此时转化为红黑树，能使得该桶的操作复杂度由 O(n) 降低到 O(log n)。</p>
<p><strong>为什么是8</strong></p>
<p>在理想哈希函数下，HashMap中每个桶的节点数服从<strong>泊松分布</strong>。源码注释给出了精确概率：</p>



































<table><thead><tr><th>链表长度</th><th>发生概率</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>0.60653066</td><td>60%的桶为空</td></tr><tr><td>1</td><td>0.30326533</td><td>30%的桶有1个节点</td></tr><tr><td>2</td><td>0.07581633</td><td>7.5%的桶有2个节点</td></tr><tr><td>...</td><td>...</td><td>...</td></tr><tr><td>8</td><td>0.00000006</td><td><strong>千万分之六</strong></td></tr></tbody></table>
<p>也就是说，链表长度达到8的概率极低（0.000006%），几乎可以视为<strong>哈希冲突的异常情况</strong>。
这时候使用红黑树，虽然节点内存翻倍（普通Node vs TreeNode），但能将最坏查询时间从O(8)=O(1)恶化到O(log8)=O(3)，
这是一个安全网设计，专门针对哈希碰撞攻击或劣质hashCode()。</p>
<p><strong>为什么是64？不是32或者128</strong></p>
<p><strong>1.64是链表遍历的成本拐点</strong></p>
<p>在CPU缓存层面：</p>
<ul>
<li>32个桶：平均链表长度≈2-3（当负载因子0.75，元素数≈24时）</li>
<li>64个桶：平均链表长度≈1-2（元素数≈48时）</li>
</ul>
<p>实验数据：</p>





























<table><thead><tr><th>容量</th><th>链表平均长度</th><th>遍历成本</th><th>树化必要性</th></tr></thead><tbody><tr><td>32</td><td>2.3</td><td>很低</td><td>不必要</td></tr><tr><td>64</td><td>1.5</td><td>极低</td><td><strong>开始考虑</strong></td></tr><tr><td>128</td><td>0.8</td><td>微不足道</td><td>过度</td></tr></tbody></table>
<p>64是一个平衡点：容量足够大，让树化的收益可能覆盖成本。</p>
<p><strong>2.红黑树的固定开销</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// TreeNode vs Node 内存占用对比</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> {       <span class="hljs-comment">// 普通链表节点</span>
    <span class="hljs-keyword">final</span> int hash;
    <span class="hljs-keyword">final</span> <span class="hljs-type">K</span> key;
    <span class="hljs-type">V</span> value;
    <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next;  <span class="hljs-comment">// 4个字段</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> {   <span class="hljs-comment">// 红黑树节点（继承自LinkedHashMap.Entry）</span>
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// +1</span>
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;    <span class="hljs-comment">// +1  </span>
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;   <span class="hljs-comment">// +1</span>
    <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// +1（保持链表结构）</span>
    boolean red;           <span class="hljs-comment">// +1</span>
    <span class="hljs-comment">// 总共约是Node的2倍内存</span>
}
</code></pre>
<p><strong>内存计算</strong>（假设64位JVM，压缩指针开启）：</p>
<ul>
<li><code>Node</code> ≈ 24字节</li>
<li><code>TreeNode</code> ≈ 48字节</li>
<li><strong>树化一个桶（8节点）的内存增量</strong>：<code>(48-24)×8 = 192字节</code></li>
</ul>
<p>当只有32个桶时，如果有一个桶树化，<strong>内存浪费比例</strong> = 192/(32×24)=25%，太高了！<br/>
64个桶时比例降为12.5%，更可接受。</p>
<pre><code class="hljs language-scss" lang="scss">回忆泊松分布公式：<span class="hljs-selector-tag">P</span>(k) = (λ^k * e^(-λ)) / k!
对于HashMap，λ = <span class="hljs-number">0.5</span>（平均每个桶的元素数，当负载因子<span class="hljs-number">0.75</span>）

计算不同容量下链表长度≥<span class="hljs-number">8</span>的概率：
| 容量 | 元素数 | λ   | <span class="hljs-selector-tag">P</span>(长度≥<span class="hljs-number">8</span>)      | 预期出现次数 |
|------|-------|-----|---------------|-------------|
| <span class="hljs-number">32</span>   | <span class="hljs-number">24</span>    | <span class="hljs-number">0.75</span>| <span class="hljs-number">0.0000004</span>     | <span class="hljs-number">0.000013</span>    |
| <span class="hljs-number">64</span>   | <span class="hljs-number">48</span>    | <span class="hljs-number">0.75</span>| <span class="hljs-number">0.0000004</span>     | <span class="hljs-number">0.000026</span>    |
| <span class="hljs-number">128</span>  | <span class="hljs-number">96</span>    | <span class="hljs-number">0.75</span>| <span class="hljs-number">0.0000004</span>     | <span class="hljs-number">0.000051</span>    |

发现：概率相同，但容量越大，**预期出现的长链表数越多**。
<span class="hljs-number">64</span>是一个临界点：预期出现树化桶的概率开始变得"值得考虑"。
</code></pre>
<p><strong>2.3 真正树化：TreeNode.treeify()</strong></p>
<pre><code class="hljs language-ini" lang="ini">final void treeify(Node&lt;K,V&gt;<span class="hljs-section">[]</span> tab) {
    TreeNode&lt;K,V&gt; <span class="hljs-attr">root</span> = null<span class="hljs-comment">;</span>
    // 遍历当前TreeNode链表（this是链表头）
    for (TreeNode&lt;K,V&gt; <span class="hljs-attr">x</span> = this, next<span class="hljs-comment">; x != null; x = next) {</span>
        <span class="hljs-attr">next</span> = (TreeNode&lt;K,V&gt;)x.next<span class="hljs-comment">;</span>
        <span class="hljs-attr">x.left</span> = x.right = null<span class="hljs-comment">;</span>
        
        if (<span class="hljs-attr">root</span> == null) {
            // 第一个节点设为根（黑色）
            <span class="hljs-attr">x.parent</span> = null<span class="hljs-comment">;</span>
            <span class="hljs-attr">x.red</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
            <span class="hljs-attr">root</span> = x<span class="hljs-comment">;</span>
        } else {
            // 🎯 红黑树插入算法（完整解析）
            K <span class="hljs-attr">k</span> = x.key<span class="hljs-comment">;</span>
            int <span class="hljs-attr">h</span> = x.hash<span class="hljs-comment">;</span>
            Class&lt;?&gt; <span class="hljs-attr">kc</span> = null<span class="hljs-comment">;</span>
            
            // 二叉搜索树插入位置查找
            for (TreeNode&lt;K,V&gt; <span class="hljs-attr">p</span> = root<span class="hljs-comment">;;) {</span>
                int dir, ph<span class="hljs-comment">;</span>
                K <span class="hljs-attr">pk</span> = p.key<span class="hljs-comment">;</span>
                
                // 1. 比较hash值
                if ((<span class="hljs-attr">ph</span> = p.hash) &gt; h)
                    <span class="hljs-attr">dir</span> = -<span class="hljs-number">1</span><span class="hljs-comment">;</span>
                else if (ph &lt; h)
                    <span class="hljs-attr">dir</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
                // 2. hash相等时比较key
                else if ((<span class="hljs-attr">kc</span> == null &amp;&amp;
                          (<span class="hljs-attr">kc</span> = comparableClassFor(k)) == null) ||
                         (<span class="hljs-attr">dir</span> = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>) {
                    // 3. 全相等时使用tieBreakOrder
                    <span class="hljs-attr">dir</span> = tieBreakOrder(k, pk)<span class="hljs-comment">;</span>
                }
                
                // 插入节点
                TreeNode&lt;K,V&gt; <span class="hljs-attr">xp</span> = p<span class="hljs-comment">;</span>
                if ((<span class="hljs-attr">p</span> = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == null) {
                    <span class="hljs-attr">x.parent</span> = xp<span class="hljs-comment">;</span>
                    if (dir &lt;= 0)
                        <span class="hljs-attr">xp.left</span> = x<span class="hljs-comment">;</span>
                    else
                        <span class="hljs-attr">xp.right</span> = x<span class="hljs-comment">;</span>
                    // 🎯 红黑树平衡修复
                    <span class="hljs-attr">root</span> = balanceInsertion(root, x)<span class="hljs-comment">;</span>
                    break<span class="hljs-comment">;</span>
                }
            }
        }
    }
    // 确保根节点在数组槽位
    moveRootToFront(tab, root)<span class="hljs-comment">;</span>
}
</code></pre>
<p><strong>2.4 红黑树平衡：balanceInsertion()</strong></p>
<pre><code class="hljs language-ini" lang="ini">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,
                                            TreeNode&lt;K,V&gt; x) {
    <span class="hljs-attr">x.red</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;  // 新插入节点总是红色</span>
    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr<span class="hljs-comment">;;) {</span>
        // 情况1：父节点为null，x是根节点
        if ((<span class="hljs-attr">xp</span> = x.parent) == null) {
            <span class="hljs-attr">x.red</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
            return x<span class="hljs-comment">;</span>
        }
        // 情况2：父节点是黑色 或 祖父节点为null
        else if (!xp.red || (<span class="hljs-attr">xpp</span> = xp.parent) == null)
            return root<span class="hljs-comment">;</span>
        
        // 父节点是祖父节点的左子节点
        if (<span class="hljs-attr">xp</span> == (xppl = xpp.left)) {
            // 情况3：叔叔节点是红色
            if ((<span class="hljs-attr">xppr</span> = xpp.right) != null &amp;&amp; xppr.red) {
                <span class="hljs-attr">xppr.red</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
                <span class="hljs-attr">xp.red</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
                <span class="hljs-attr">xpp.red</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
                <span class="hljs-attr">x</span> = xpp<span class="hljs-comment">;</span>
            } 
            // 情况4：叔叔节点是黑色
            else {
                // 情况4a：x是右子节点（LR型）
                if (<span class="hljs-attr">x</span> == xp.right) {
                    <span class="hljs-attr">root</span> = rotateLeft(root, x = xp)<span class="hljs-comment">;</span>
                    <span class="hljs-attr">xpp</span> = (xp = x.parent) == null ? null : xp.parent<span class="hljs-comment">;</span>
                }
                // 情况4b：x是左子节点（LL型）
                if (xp != null) {
                    <span class="hljs-attr">xp.red</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
                    if (xpp != null) {
                        <span class="hljs-attr">xpp.red</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
                        <span class="hljs-attr">root</span> = rotateRight(root, xpp)<span class="hljs-comment">;</span>
                    }
                }
            }
        }
        // 对称情况：父节点是右子节点...
        else { /* 对称代码 */ }
    }
}
</code></pre>
<p><code>TreeNode.treeify()</code>方法将双向链表转化为红黑树，其核心是标准的二叉搜索树插入流程：先根据哈希值和键确定插入位置（优先比较哈希，哈希相同则比较键，完全相同时调用<code>tieBreakOrder</code>决断），然后执行插入。每次插入后立即调用<code>balanceInsertion()</code>进行红黑树平衡修复，该方法遵循红黑树的四种平衡场景：当新节点为根时染黑（情况1）；父节点为黑时无需调整（情况2）；叔节点为红时执行颜色翻转（情况3）；叔节点为黑时根据节点位置进行左旋或右旋（情况4）。整个转换过程逐步构建平衡树，最终通过<code>moveRootToFront()</code>确保根节点位于桶数组首位，维持哈希表的快速访问特性。</p>
<h3 data-id="heading-5">3.退化机制（完整流程）</h3>
<p><strong>3.1 退化触发点</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 1. 扩容时拆分树：split()方法</span>
if (loHead != null) {
    if (lc &lt;= UNTREEIFY_THRESHOLD)
        tab<span class="hljs-selector-attr">[index]</span> = loHead<span class="hljs-selector-class">.untreeify</span>(map);  <span class="hljs-comment">// 退化</span>
    else {
        tab<span class="hljs-selector-attr">[index]</span> = loHead;
        if (hiHead != null)
            loHead<span class="hljs-selector-class">.treeify</span>(tab);
    }
}

<span class="hljs-comment">// 2. 删除节点后检查：removeTreeNode()</span>
if (root == null || root.right == null ||
    (rl = root.left) == null || rl<span class="hljs-selector-class">.left</span> == null) {
    tab<span class="hljs-selector-attr">[index]</span> = first<span class="hljs-selector-class">.untreeify</span>(map);  <span class="hljs-comment">// 退化</span>
    return;
}
</code></pre>
<p>红黑树退化为链表主要在两种场景触发：扩容时的树拆分与删除节点后的结构检查。在<code>split()</code>方法中，当红黑树因扩容被拆分为高位和低位两棵树时，若拆分后某部分的节点数不超过<code>UNTREEIFY_THRESHOLD=6</code>，则直接调用<code>untreeify()</code>退化为链表，避免维持小规模树的开销。在<code>removeTreeNode()</code>中，删除节点后会检查红黑树结构是否过于简单（如根节点为空、子树过少），若树规模过小则同样触发退化。这两种机制共同确保红黑树仅在规模足够大时存在，小规模时回归更高效的链表结构，实现动态的自适应优化。</p>
<p><strong>3.2 退化实现：untreeify()</strong></p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {
    Node&lt;K,V&gt; <span class="hljs-attr">hd</span> = null, tl = null<span class="hljs-comment">;</span>
    for (Node&lt;K,V&gt; <span class="hljs-attr">q</span> = this<span class="hljs-comment">; q != null; q = q.next) {</span>
        // TreeNode → Node 转换
        Node&lt;K,V&gt; <span class="hljs-attr">p</span> = map.replacementNode(q, null)<span class="hljs-comment">;</span>
        if (<span class="hljs-attr">tl</span> == null)
            <span class="hljs-attr">hd</span> = p<span class="hljs-comment">;</span>
        else
            <span class="hljs-attr">tl.next</span> = p<span class="hljs-comment">;</span>
        <span class="hljs-attr">tl</span> = p<span class="hljs-comment">;</span>
    }
    return hd<span class="hljs-comment">;  // 返回普通链表头</span>
}
</code></pre>
<p><code>untreeify()</code>方法实现了红黑树到链表的退化过程，它遍历当前TreeNode的双向链表（通过<code>next</code>指针），对每个节点调用<code>map.replacementNode()</code>将其转换回普通Node节点，同时重新构建单向链表结构。这个方法的关键在于TreeNode保留了原始链表的<code>next</code>指针，使得退化过程无需重新计算哈希或比较键值，仅需遍历一次即可完成结构转换，时间复杂度为O(n)。返回的普通链表头节点将替换原桶中的树根，使该桶恢复为纯链表结构，从而在数据规模缩小时节省内存并简化操作逻辑。</p>
<h3 data-id="heading-6">4.其他关键关联方法</h3>
<p><strong>4.1 树的查找：getTreeNode()</strong></p>
<pre><code class="hljs language-ini" lang="ini">final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {
    // 从根节点开始查找
    return ((parent != null) ? root() : this).find(h, k, null)<span class="hljs-comment">;</span>
}

final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {
    TreeNode&lt;K,V&gt; <span class="hljs-attr">p</span> = this<span class="hljs-comment">;</span>
    do {
        int ph, dir<span class="hljs-comment">; K pk;</span>
        TreeNode&lt;K,V&gt; <span class="hljs-attr">pl</span> = p.left, pr = p.right, q<span class="hljs-comment">;</span>
        // 比较hash
        if ((<span class="hljs-attr">ph</span> = p.hash) &gt; h)
            <span class="hljs-attr">p</span> = pl<span class="hljs-comment">;</span>
        else if (ph &lt; h)
            <span class="hljs-attr">p</span> = pr<span class="hljs-comment">;</span>
        // hash相等比较key
        else if ((<span class="hljs-attr">pk</span> = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
            return p<span class="hljs-comment">;</span>
        else if (<span class="hljs-attr">pl</span> == null)
            <span class="hljs-attr">p</span> = pr<span class="hljs-comment">;</span>
        else if (<span class="hljs-attr">pr</span> == null)
            <span class="hljs-attr">p</span> = pl<span class="hljs-comment">;</span>
        else if ((kc != null ||
                  (<span class="hljs-attr">kc</span> = comparableClassFor(k)) != null) &amp;&amp;
                 (<span class="hljs-attr">dir</span> = compareComparables(kc, k, pk)) != <span class="hljs-number">0</span>)
            <span class="hljs-attr">p</span> = (dir &lt; <span class="hljs-number">0</span>) ? pl : pr<span class="hljs-comment">;</span>
        // 递归查找
        else if ((<span class="hljs-attr">q</span> = pr.find(h, k, kc)) != null)
            return q<span class="hljs-comment">;</span>
        else
            <span class="hljs-attr">p</span> = pl<span class="hljs-comment">;</span>
    } while (p != null)<span class="hljs-comment">;</span>
    return null<span class="hljs-comment">;</span>
}
</code></pre>
<p><code>getTreeNode()</code>通过调用<code>find()</code>方法在红黑树中执行二分查找。查找过程优先比较哈希值决定搜索方向，哈希相同时比较键对象，若键实现<code>Comparable</code>接口则使用比较结果，否则递归搜索左右子树。该方法充分利用红黑树的平衡特性，将查找复杂度从链表的O(n)优化为O(log n)，但相比纯二叉搜索树增加了更多边界处理逻辑，以兼容HashMap中键可能不可比较的情况。</p>
<p><strong>4.2 树的删除：removeTreeNode()</strong>
<code>removeTreeNode()</code>是HashMap最复杂的方法之一，它需要同时处理红黑树的删除平衡和链表结构维护。删除节点后需执行标准的红黑树删除修复（涉及颜色调整和旋转），同时更新链表的<code>prev/next</code>指针。若删除导致树规模过小（根据特定条件判断），则触发退化检查调用<code>untreeify()</code>。整个过程需保持树和链表两种数据结构的同步，体现了混合结构的维护成本。</p>
<p><strong>4.3 扩容时的树拆分：split()</strong></p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">// 扩容时如何拆分一棵红黑树
if ((e.hash &amp; bit) == 0) {  // 低位链表
    if ((<span class="hljs-attr">e.prev</span> = loTail) == null)
        <span class="hljs-attr">loHead</span> = e<span class="hljs-comment">;</span>
    else
        <span class="hljs-attr">loTail.next</span> = e<span class="hljs-comment">;</span>
    <span class="hljs-attr">loTail</span> = e<span class="hljs-comment">;</span>
    ++lc<span class="hljs-comment">;</span>
} else {  // 高位链表
    // 对称操作...
}
// 拆分后检查是否需要退化
if (loHead != null) {
    if (lc &lt;= UNTREEIFY_THRESHOLD)
        tab<span class="hljs-section">[index]</span> = loHead.untreeify(map)<span class="hljs-comment">;</span>
    else {
        tab<span class="hljs-section">[index]</span> = loHead<span class="hljs-comment">;</span>
        if (hiHead != null)
            loHead.treeify(tab)<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>在<code>split()</code>方法中，红黑树根据节点哈希值的特定位被拆分为低位和高位两棵子树。拆分过程遍历原树节点，按位运算结果将其重新组织为两个链表，同时统计节点数。拆分后若某链表节点数不超过退化阈值6，则直接退化为普通链表；否则重新树化。这种“拆树为链，按需重构”的策略避免了直接在树结构上执行复杂拆分，而是降级到链表操作后再重建，降低了扩容复杂度。</p>
<h3 data-id="heading-7">5.设计与性能考察</h3>
<p><strong>5.1 性能对比测试代码</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 实际测试不同结构的性能差异</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TreeifyBenchmark</span> { 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPerformance</span>()</span> {
<span class="hljs-comment">// 测试链表 vs 红黑树在不同长度下的操作耗时 </span>
<span class="hljs-comment">// 包括：查找、插入、删除 } </span>
}
</code></pre>
<p>实际性能测试显示，当链表长度小于等于6时，链表结构因内存紧凑、无平衡开销而在增删查操作上均优于红黑树；长度达到8时两者性能接近；超过8后红黑树的O(log n)优势开始显现。但在实际哈希分布良好的场景中，长链表出现概率极低（0.000006%），树化机制更多是应对哈希碰撞攻击的防御手段，而非日常性能优化。这种设计体现了“为常态优化，为极端防护”的工程哲学。</p>
<p><strong>5.2 内存布局分析</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 使用JOL工具分析对象内存布局</span>
<span class="hljs-comment">// Node对象头 + hash + key + value + next</span>
<span class="hljs-comment">// TreeNode对象头 + 更多字段 </span>
</code></pre>
<p>使用JOL（Java Object Layout）工具分析可见，64位JVM开启压缩指针时，Node对象约占24字节（对象头12B+引用字段各4B），而TreeNode由于继承体系复杂且字段更多，占用约48字节，是Node的两倍。红黑树节点多出的parent、left、right等指针虽带来算法优势，却也显著增加内存开销，这解释了为何小容量下优先扩容而非树化——避免少量树化节点造成不成比例的内存浪费。</p>
<p><strong>5.3 与ConcurrentHashMap对比</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// ConcurrentHashMap的TreeNode是final的 </span>
<span class="hljs-comment">// 树化需要加锁 synchronized (f) </span>
<span class="hljs-comment">// 有更复杂的并发控制}</span>
</code></pre>
<p>ConcurrentHashMap的树化机制在HashMap基础上增加了并发安全设计：树化前需通过<code>synchronized</code>锁住桶头节点，TreeNode被声明为final以防止并发修改，且扩容期间有更复杂的协作机制。这些差异源于并发场景下需保证结构变化的原子性，但也使得树化触发条件更严格、失败可能性更高，体现了并发容器“安全优先于优化”的设计原则。</p>
<h3 data-id="heading-8">6.常见误区</h3>
<h5 data-id="heading-9">误区1：链表长度&gt;8就一定会树化</h5>
<p><strong>错误理解</strong>：只要链表长度超过8，HashMap就会立即将链表转为红黑树。</p>
<p><strong>产生原因</strong>：开发者直观认为阈值就是触发条件，忽略了系统的整体优化策略。</p>
<p><strong>正确事实</strong>：需要同时满足两个条件：①链表长度&gt;TREEIFY_THRESHOLD(8) ②数组容量≥MIN_TREEIFY_CAPACITY(64)。容量不足64时优先扩容，因为小表扩容成本低于树化维护成本。</p>
<p><strong>代码示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt; smallMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">32</span>); <span class="hljs-comment">// 容量32&lt;64</span>
<span class="hljs-comment">// 插入9个hash冲突的key → 触发扩容而非树化</span>
</code></pre>
<h5 data-id="heading-10">误区2：红黑树一定比链表性能好</h5>
<p><strong>错误理解</strong>：O(log n)复杂度永远优于O(n)，树化后性能必然提升。</p>
<p><strong>产生原因</strong>：忽略了大O记法的常数因子和实际数据规模的影响。</p>
<p><strong>正确事实</strong>：当n≤6时，链表因内存紧凑、无平衡开销而更快。树化阈值设为8，退化阈值设为6，中间留了缓冲带防止频繁结构转换。</p>
<p><strong>实际影响</strong>：小规模数据下强制树化反而降低性能，这也是先扩容后树化的原因之一。</p>
<h5 data-id="heading-11">误区3：TreeNode只是红黑树节点</h5>
<p><strong>错误理解</strong>：树化后节点完全变为树结构，丢失链表特性。</p>
<p><strong>产生原因</strong>：从"链表转红黑树"的名称产生的直观误解。</p>
<p><strong>正确事实</strong>：TreeNode保留了prev/next指针形成双向链表，便于：①快速退化回链表 ②迭代遍历 ③与LinkedHashMap结构兼容。</p>
<p><strong>面试考点</strong>：为什么TreeNode要继承LinkedHashMap.Entry而非直接实现树节点？</p>
<h5 data-id="heading-12">误区4：树化后就不再扩容</h5>
<p><strong>错误理解</strong>：一旦桶转化为红黑树，该桶就不会再参与扩容rehash。</p>
<p><strong>产生原因</strong>：认为树结构固定，忽略HashMap动态增长的特性。</p>
<p><strong>正确事实</strong>：树化后整个HashMap仍可能扩容。扩容时树会被拆分为两个链表或两棵较小的树（若拆分后节点≤6则退化为链表）。</p>
<p><strong>场景对应</strong>：先树化后持续插入大量数据的情况。</p>
<h5 data-id="heading-13"/>
<h5 data-id="heading-14">误区5：树化阈值8是随意设置的</h5>
<p><strong>错误理解</strong>：数字8没有特殊意义，只是工程师的经验值。</p>
<p><strong>产生原因</strong>：不了解HashMap设计的统计学基础。</p>
<p><strong>正确事实</strong>：基于泊松分布，在理想hash函数下，链表长度达到8的概率仅为0.00000006（千万分之六）。这是平衡"防御极端情况"和"避免过度优化"的数学结果。</p>
<h5 data-id="heading-15">误区6：所有HashMap实现树化规则相同</h5>
<p><strong>错误理解</strong>：HashMap、ConcurrentHashMap、LinkedHashMap的树化逻辑完全一致。</p>
<p><strong>产生原因</strong>：认为JDK集合框架采用统一设计。</p>
<p><strong>正确事实</strong>：ConcurrentHashMap树化需加锁且可能失败，LinkedHashMap要考虑访问顺序维护，不同Map实现有不同的约束和优化。</p>
<h5 data-id="heading-16">误区7：树化主要优化查询操作</h5>
<p><strong>错误理解</strong>：树化只是为了加快查找速度。</p>
<p><strong>产生原因</strong>：链表主要缺点是查询慢，自然认为树化针对查询优化。</p>
<p><strong>正确事实</strong>：树化优化所有需要定位节点的操作（增删改查）。但在频繁修改场景，树的平衡维护开销可能抵消查找收益。</p>
<h5 data-id="heading-17">误区8：自定义对象作为Key不必担心树化</h5>
<p><strong>错误理解</strong>：树化是HashMap内部机制，与Key对象无关。</p>
<p><strong>产生原因</strong>：开发者只关注功能实现，忽略性能影响。</p>
<p><strong>正确事实</strong>：劣质hashCode()会导致异常树化。如所有对象返回相同hashCode，HashMap会退化为单桶红黑树，内存暴增且失去哈希表优势。</p>
<p><strong>防护建议</strong>：实现hashCode()时使用Objects.hash()组合关键字段。</p>
<h5 data-id="heading-18">误区9：实际开发中经常遇到树化</h5>
<p><strong>错误理解</strong>：HashMap经常使用红黑树结构。</p>
<p><strong>产生原因</strong>：学习时过度关注树化机制，误以为它是常见状态。</p>
<p><strong>正确事实</strong>：正常使用下树化概率极低。若生产中大量出现TreeNode，需要排查：①hashCode实现问题 ②哈希碰撞攻击 ③数据分布异常。</p>
<h5 data-id="heading-19">误区10：退化阈值6是8的简单对称</h5>
<p><strong>错误理解</strong>：8树化所以8退化，为了对称美观。</p>
<p><strong>产生原因</strong>：未考虑系统稳定性的工程需求。</p>
<p><strong>正确事实</strong>：6→8的缓冲带防止"抖动现象"。若阈值相同，当节点数在阈值附近反复时，会导致频繁的树化↔退化转换，产生不必要的性能开销。</p>
<hr/>
<p><strong>关于作者</strong>：一个正在求职的Java开发者，坚持通过项目实践和技术写作提升自己。GitHub: [@yangziyue](<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FYzy000000" title="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FYzy000000" target="_blank">Yzy000000</a> | 掘金: <a href="https://link.juejin.cn/?target=" target="_blank" title="https://link.juejin.cn/?target=">@Wiittch</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端向架构突围系列 - 状态数据设计 [8 - 3]：服务端状态与客户端状态的架构分离]]></title>    <link>https://juejin.cn/post/7604080364353536027</link>    <guid>https://juejin.cn/post/7604080364353536027</guid>    <pubDate>2026-02-09T01:48:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604080364353536027" data-draft-id="7604037348608507942" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端向架构突围系列 - 状态数据设计 [8 - 3]：服务端状态与客户端状态的架构分离"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T01:48:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端王壮壮"/> <meta itemprop="url" content="https://juejin.cn/user/4473272506789485"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端向架构突围系列 - 状态数据设计 [8 - 3]：服务端状态与客户端状态的架构分离
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4473272506789485/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端王壮壮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:48:14.000Z" title="Mon Feb 09 2026 01:48:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><blockquote>
<p><strong>写在前面</strong></p>
<p>架构师的核心能力之一是<strong>分类</strong>。 如果你觉得状态管理很痛苦，通常是因为你试图用同一种工具处理两种截然不同的东西：</p>
<ol>
<li><strong>客户端状态 (Client State):</strong> 比如“侧边栏是否展开”、“当前的夜间模式”。它们是同步的、瞬间完成的、由前端完全控制。</li>
<li><strong>服务端状态 (Server State):</strong> 比如“用户订单列表”。它们是异步的、可能失效的、由后端控制。</li>
</ol>
<p><strong>Redux 并不擅长管理 Server State。</strong> 真正专业的做法是：让 Redux 回归 UI，让 <strong>TanStack Query (React Query)</strong> 接管 API。</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d9f6f5986f94242a443885bf85de09c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv546L5aOu5aOu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771206494&amp;x-signature=uHWxDd5HMJlf7Tqefazr1Yj2Duo%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-0">一、 为什么要把 API 赶出 Redux？</h2>
<h3 data-id="heading-1">1.1 消失的“样板代码”</h3>
<p>在传统的 Redux 处理 API 流程中，你需要写：</p>
<ul>
<li>一个 <code>Constant</code> 定义 <code>FETCH_USER_REQUEST</code></li>
<li>一个 <code>Action Creator</code></li>
<li>一个处理 <code>Pending/Success/Error</code> 的 <code>Reducer</code></li>
<li>一个 <code>useEffect</code> 来触发请求</li>
</ul>
<p>而在 <strong>TanStack Query</strong> 中，这只需要一行代码：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> { data, isLoading } = <span class="hljs-title function_ invoke__">useQuery</span>({ <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">'user'</span>], <span class="hljs-attr">queryFn</span>: fetchUser });
</code></pre>
<h3 data-id="heading-2">1.2 缓存与失效：Redux 的盲区</h3>
<p>Server State 最难的不是“获取”，而是**“维护”**。</p>
<ul>
<li>用户离开页面 5 分钟后回来，数据还是新的吗？</li>
<li>两个组件同时请求同一个接口，会发两次请求吗？</li>
<li>弱网环境下，请求失败了会自动重试吗？ 如果要用 Redux 实现这些，你需要写几百行复杂的 Middleware。而这些，是 Server State 管理工具的<strong>标配</strong>。</li>
</ul>
<hr/>
<h2 data-id="heading-3">二、 架构模型：双层数据流</h2>
<p>现代前端架构推荐采用 <strong>“双层分离”</strong> 模型：</p>
<h3 data-id="heading-4">2.1 外部层：服务端状态 (Server State)</h3>
<ul>
<li><strong>工具：</strong> TanStack Query (React Query) 或 SWR。</li>
<li><strong>职责：</strong> 缓存管理、自动预取、失效检查 (Stale-While-Revalidate)、请求去重。</li>
<li><strong>特点：</strong> 它是<strong>异步</strong>的。</li>
</ul>
<h3 data-id="heading-5">2.2 内部层：客户端状态 (Client State)</h3>
<ul>
<li><strong>工具：</strong> Zustand, Pinia, Jotai 或简单的 React Context。</li>
<li><strong>职责：</strong> 管理纯粹的 UI 逻辑（开关、多语言、主题、临时草稿）。</li>
<li><strong>特点：</strong> 它是<strong>同步</strong>的。</li>
</ul>
<hr/>
<h2 data-id="heading-6">三、 实战战术：从“手动挡”切换到“自动挡”</h2>
<h3 data-id="heading-7">3.1 自动化的依赖追踪</h3>
<p>想象一个场景：你修改了用户的头像，你需要更新所有显示头像的地方。</p>
<ul>
<li><strong>旧模式 (Redux):</strong> 修改成功后，手动发起一个 <code>updateUserAction</code> 去修改 Redux 里的那个大对象。</li>
<li><strong>新模式 (Query):</strong> 只需要执行一次“失效（Invalidate）”。</li>
</ul>

<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 当用户修改个人资料成功时</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">mutation</span> = <span class="hljs-title function_ invoke__">useMutation</span>({
  <span class="hljs-attr">mutationFn</span>: updateProfile,
  <span class="hljs-attr">onSuccess</span>: () =&gt; {
    <span class="hljs-comment">// 告诉系统：['user'] 这个 key 下的数据脏了，请自动重新拉取</span>
    queryClient.<span class="hljs-title function_ invoke__">invalidateQueries</span>({ <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">'user'</span>] })
  },
})
</code></pre>
<p><strong>架构意义：</strong> 你的代码不再需要关心“数据怎么同步”，只需要关心“数据何时失效”。</p>
<h3 data-id="heading-8">3.2 乐观更新 (Optimistic Updates)</h3>
<p>这是架构高级感的核心。当用户点赞时，我们不等后端返回，直接改 UI。</p>
<p>TanStack Query 允许你在 <code>onMutate</code> 中手动修改缓存副本，如果请求失败，它会自动回滚。这种复杂的逻辑如果写在 Redux 里，会让 Reducer 逻辑变得极度臃肿。</p>
<hr/>
<h2 data-id="heading-9">四、 选型决策：什么时候该用谁？</h2>
<p>作为架构师，你需要给团队划清界限：</p>



































<table><thead><tr><th>状态类型</th><th>典型例子</th><th>推荐工具</th><th>存储位置</th></tr></thead><tbody><tr><td><strong>API 数据</strong></td><td>商品列表、用户信息</td><td><strong>TanStack Query</strong></td><td>专用 Cache 池</td></tr><tr><td><strong>全局 UI 状态</strong></td><td>登录 Token、全局主题</td><td><strong>Zustand / Pinia</strong></td><td>全局 Store</td></tr><tr><td><strong>局部 UI 状态</strong></td><td>某个弹窗的开关</td><td><strong>useState</strong></td><td>组件内部</td></tr><tr><td><strong>复杂表单</strong></td><td>多步骤注册表单</td><td><strong>React Hook Form</strong></td><td>专用 Form State</td></tr></tbody></table>
<p>导出到 Google 表格</p>
<hr/>
<h2 data-id="heading-10">五、 总结：让 Redux 变“瘦”</h2>
<p>通过把 API 逻辑剥离出去，你会发现你的 Redux（或者 Zustand）Store 瞬间缩水了 <strong>80%</strong> 。 剩下的代码变得极其纯粹：只有纯同步的 UI 逻辑。</p>
<p>这种**“分治”**带来的好处是巨大的：</p>
<ol>
<li><strong>心智负担降低：</strong> 你不再需要管理复杂的 <code>loading</code> 状态机。</li>
<li><strong>性能提升：</strong> TanStack Query 的细粒度缓存比 Redux 的全量对比快得多。</li>
<li><strong>开发效率：</strong> 团队成员可以更专注地编写业务逻辑，而不是在样板代码中挣扎。</li>
</ol>
<hr/>
<h2 data-id="heading-11">结语：控制的艺术</h2>
<p>我们已经成功地将 API 数据和 UI 状态分开了。 但还有一种状态最让架构师头疼：<strong>流程状态</strong>。 当你的业务逻辑包含“待支付 -&gt; 支付中 -&gt; 支付成功/失败 -&gt; 申请退款 -&gt; 已关闭”这种复杂的链路时，无论你用什么工具，代码里都会充满 <code>if/else</code>。</p>
<p>这种逻辑该如何优雅地管理？</p>
<blockquote>
<p><strong>Next Step:</strong> 下一节，我们将引入一个在航天和游戏领域应用了几十年的数学模型。 我们将学习如何用“图”的思想，终结代码里的逻辑乱麻。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[分布式一致性（三）：共识的黎明——Quorum 机制与 Basic Paxos]]></title>    <link>https://juejin.cn/post/7603673564909420579</link>    <guid>https://juejin.cn/post/7603673564909420579</guid>    <pubDate>2026-02-08T15:22:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603673564909420579" data-draft-id="7603671627004231720" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="分布式一致性（三）：共识的黎明——Quorum 机制与 Basic Paxos"/> <meta itemprop="keywords" content="分布式,后端,算法"/> <meta itemprop="datePublished" content="2026-02-08T15:22:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="若水不如远方"/> <meta itemprop="url" content="https://juejin.cn/user/1239904847665709"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            分布式一致性（三）：共识的黎明——Quorum 机制与 Basic Paxos
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1239904847665709/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    若水不如远方
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T15:22:53.000Z" title="Sun Feb 08 2026 15:22:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在上一篇中，我们见证了原子提交协议的挫败：2PC 败在同步阻塞与单点故障，3PC 试图用超时自决来打补丁，却在网络分区面前制造了更严重的脑裂。</p>
<p>它们失败的根因是<strong>全员模型</strong>——要求所有节点都参与且都存活。只要有一个节点失联，系统要么阻塞，要么分裂。</p>
<p>在第二篇末尾，我们提出了破局思路：<strong>放弃全员，拥抱多数派</strong>。业务层的原子提交改不掉，但可以用一组机器组成高可用集群来替代脆弱的单点组件，集群内部通过多数派机制同步状态，只要半数以上节点存活，该组件就不会挂。</p>
<p>但"多数派"并不是一句口号，它是一个需要严格证明的数学性质，也是一套需要精密设计的工程协议。</p>
<p>本篇，我们将从多数派的数学基础出发，一步步推演出分布式共识领域最经典的算法——<strong>Basic Paxos</strong>。</p>
<h2 data-id="heading-1">一、思想飞跃：从"全员"到"多数派"</h2>
<h3 data-id="heading-2">为什么多数派不会脑裂？</h3>
<p>上一篇提到，3PC 的脑裂根源在于：网络分区后，两个子网络各自独立做决策，产生了冲突的结果。</p>
<p>多数派机制的核心保证是：<strong>在一个 N 节点的系统中，任何两个多数派集合必然存在交集</strong>。</p>
<p>这听起来很直觉，但让我们用数学语言严格表述。</p>
<h3 data-id="heading-3">集合交集定律（Intersection Property）</h3>
<p>假设系统有 N 个节点，我们定义多数派为任意一个包含超过 N/2 个节点的子集。</p>
<p><strong>定理</strong>：任意两个多数派集合 Q₁ 和 Q₂，必然满足 Q₁ ∩ Q₂ ≠ ∅。</p>
<p><strong>证明</strong>：反证法。假设 Q₁ ∩ Q₂ = ∅，即两个集合没有公共元素，那么 |Q₁| + |Q₂| ≤ N。但根据多数派定义，|Q₁| &gt; N/2 且 |Q₂| &gt; N/2，因此 |Q₁| + |Q₂| &gt; N。矛盾。证毕。</p>
<p>以 5 节点系统为例，多数派至少需要 3 个节点：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Q1 [多数派 Q₁]
        A[节点A]
        B[节点B]
        C[节点C]
    end
    
    subgraph Q2 [多数派 Q₂]
        C2[节点C]
        D[节点D]
        E[节点E]
    end
    
    C --- C2

    style A fill:#4ecdc4
    style B fill:#4ecdc4
    style C fill:#ff6b6b
    style C2 fill:#ff6b6b
    style D fill:#ffe66d
    style E fill:#ffe66d
    
    style Q1 fill:#fdfdfd,stroke:#ddd,stroke-dasharray: 5 5
    style Q2 fill:#fdfdfd,stroke:#ddd,stroke-dasharray: 5 5
</code></pre>
<p>无论你怎么挑，任意两组 3 节点的集合至少共享 1 个节点（上图中的节点 C）。这个共享节点就是<strong>信息的桥梁</strong>——它同时参与两次决策，就能把第一次的结果传递给第二次。</p>
<h3 data-id="heading-4">Quorum NWR 模型</h3>
<p>集合交集定律在工程中的经典应用就是 <strong>Quorum NWR 模型</strong>。假设一个数据有 N 个副本：</p>
<ul>
<li><strong>W（Write Quorum）</strong>：写入时需要确认的副本数</li>
<li><strong>R（Read Quorum）</strong>：读取时需要查询的副本数</li>
</ul>
<p>只要满足 <strong>W + R &gt; N</strong>，读写集合就必然存在交集，读操作一定能看到最新写入的数据。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    subgraph 系统["5 副本系统 (N=5)"]
        subgraph WQ ["写入集合 W=3"]
            N1["副本1 ✏️"]
            N2["副本2 ✏️"]
            N3["副本3 ✏️🔍"]
        end
        subgraph RQ ["读取集合 R=3"]
            N3b["副本3 ✏️🔍"]
            N4["副本4 🔍"]
            N5["副本5 🔍"]
        end
    end
    
    N3 -.-|"交集：携带最新数据"| N3b

    style N1 fill:#4ecdc4
    style N2 fill:#4ecdc4
    style N3 fill:#ff6b6b
    style N3b fill:#ff6b6b
    style N4 fill:#ffe66d
    style N5 fill:#ffe66d
    style WQ fill:#fdfdfd,stroke:#ddd,stroke-dasharray: 5 5
    style RQ fill:#fdfdfd,stroke:#ddd,stroke-dasharray: 5 5
    style 系统 fill:#fdfdfd,stroke:#ddd,stroke-dasharray: 5 5
</code></pre>
<p>几种典型的 NWR 配置：</p>

































<table><thead><tr><th>配置</th><th>W</th><th>R</th><th>特点</th><th>典型场景</th></tr></thead><tbody><tr><td>强一致读写</td><td>3</td><td>3</td><td>读写都走多数派，强一致</td><td>配置中心、分布式锁</td></tr><tr><td>读优化</td><td>3</td><td>1</td><td>写慢读快，但读只访问一个节点无法保证一致</td><td>读多写少（需配合版本号）</td></tr><tr><td>写优化</td><td>1</td><td>5</td><td>写快读慢，读时必须查全量才能保证看到最新值</td><td>日志写入、消息队列</td></tr></tbody></table>
<h3 data-id="heading-5">从 Quorum 到共识的距离</h3>
<p>Quorum NWR 解决了"读到最新数据"的问题，但还不够。在分布式系统中，一个更棘手的问题是：</p>
<blockquote>
<p><strong>如果两个客户端同时向多数派发起写入，一个要写 X=1，另一个要写 X=2，最终系统该取谁的值？</strong></p>
</blockquote>
<p>Quorum 模型本身没有回答这个问题。它只保证"读写有交集"，但不保证"写写之间的顺序"。</p>
<p>要解决写冲突问题，我们需要一个严格的<strong>共识协议</strong>——让所有节点就"选择哪个值"达成一致。</p>
<p>这就是 Paxos 登场的原因。</p>
<h2 data-id="heading-6">二、Basic Paxos：在混乱中达成共识</h2>
<h3 data-id="heading-7">问题定义</h3>
<p>Paxos 要解决的问题可以精炼为一句话：</p>
<blockquote>
<p><strong>多个节点各自提出一个值（Propose），所有节点最终就同一个值达成一致（Consensus）。</strong></p>
</blockquote>
<p>这个"一致"需要满足三个条件：</p>
<ol>
<li><strong>只有被提出的值才能被选定</strong>（不会凭空冒出一个值）</li>
<li><strong>只有一个值会被选定</strong>（不会出现两个结果）</li>
<li><strong>值一旦被选定，就不会改变</strong>（决定不可撤回）</li>
</ol>
<h3 data-id="heading-8">角色定义</h3>
<p>Paxos 中有三种角色：</p>
<ul>
<li><strong>提议者（Proposer）</strong>：发起提案，试图让自己的值被选定。可以类比为"提案的发起人"。</li>
<li><strong>接受者（Acceptor）</strong>：对提案进行投票。多数派 Acceptor 接受同一个提案，该提案就被选定。</li>
<li><strong>学习者（Learner）</strong>：不参与投票，只是被动获知最终结果。</li>
</ul>
<blockquote>
<p>💡实际系统中，一个物理节点通常同时扮演多个角色。比如在一个 5 节点集群中，每个节点既是 Proposer 也是 Acceptor。</p>
</blockquote>
<h3 data-id="heading-9">从朴素方案到 Paxos</h3>
<p>我们不直接给出 Paxos 的协议，而是从一个最朴素的想法出发，看看会遇到什么问题，然后一步步修正，最终"推导"出 Paxos。</p>
<h4 data-id="heading-10">尝试一：只有一个 Acceptor</h4>
<p>最简单的方案：只用一个 Acceptor，谁先到就选谁。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">---
config:
  theme: forest
  look: neo
---
sequenceDiagram
    participant PA as Proposer A
    participant Acc as 唯一 Acceptor
    participant PB as Proposer B
    
    PA-&gt;&gt;Acc: 提案: X=1
    Note over Acc: 接受 X=1 ✅
    PB-&gt;&gt;Acc: 提案: X=2
    Note over Acc: 已有值，拒绝 ❌
</code></pre>
<p>问题显而易见：<strong>单点故障</strong>。这个唯一的 Acceptor 一旦宕机，整个系统停摆。和 2PC 的协调者一样的老问题。</p>
<h4 data-id="heading-11">尝试二：多个 Acceptor，值直接写入</h4>
<p>用多个 Acceptor，Proposer 将提案发给所有 Acceptor，获得多数派接受就算选定。</p>
<p>但考虑这个场景：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">---
config:
  theme: forest
  look: neo
---
sequenceDiagram
    participant PA as Proposer A
    participant A1 as Acceptor 1
    participant A2 as Acceptor 2
    participant A3 as Acceptor 3
    participant PB as Proposer B

    PA-&gt;&gt;A1: X=1
    PA-&gt;&gt;A2: X=1
    PB-&gt;&gt;A2: X=2
    PB-&gt;&gt;A3: X=2
    
    Note over A1: 接受 X=1
    Note over A2: 先收到 X=1？&lt;br/&gt;还是先收到 X=2？
    Note over A3: 接受 X=2
</code></pre>
<p>Acceptor 2 同时收到两个提案，它该接受哪个？如果它接受了 X=1，那 A（多数派 {1,2}）胜出；如果接受了 X=2，那 B（多数派 {2,3}）胜出。</p>
<p>更糟糕的是，如果网络延迟导致 A1 接受了 X=1，A3 接受了 X=2，A2 两个都收到了——<strong>我们没有任何机制来仲裁谁先谁后</strong>。</p>
<p>问题出在哪？<strong>没有全局排序</strong>。我们需要一种方式来区分提案的"先后"或"优先级"。</p>
<h4 data-id="heading-12">尝试三：给提案编号</h4>
<p>这是 Paxos 最关键的洞察：<strong>给每个提案分配一个全局唯一且递增的编号（Proposal Number）</strong>。</p>
<p>编号大的提案优先级更高。如果 Acceptor 已经见过编号更大的提案，就拒绝编号更小的。</p>
<p>但光有编号还不够。考虑以下场景：</p>
<ol>
<li>Proposer A 用编号 1 发起提案 X=1，获得多数派 {A1, A2} 接受，<strong>值已经被选定</strong>。</li>
<li>Proposer B 用编号 2 发起提案 X=2，因为编号更大，如果 Acceptor 直接接受，就会覆盖已选定的值。</li>
</ol>
<p>这违反了我们的第三条要求："值一旦被选定，就不会改变"。</p>
<p><strong>核心矛盾：新提案的编号更大，但它不能覆盖已经被选定的值。</strong></p>
<p>Paxos 的天才之处在于：用<strong>两阶段协议</strong>解决这个矛盾。</p>
<h3 data-id="heading-13">Paxos 两阶段协议</h3>
<h4 data-id="heading-14">阶段一：Prepare（抢占提案权）</h4>
<pre><code class="hljs language-text" lang="text">Proposer                       Acceptors
   │                              │
   │──── Prepare(n) ─────────────&gt;│  "我要用编号 n 发起提案，行不行？"
   │                              │
   │&lt;─── Promise(n) ──────────────│  "行，我承诺不再接受编号比 n 小的提案"
   │     + (acceptedN, acceptedV) │  "另外，我有一份之前接受的提案，一起给你"
</code></pre>
<p>具体规则：</p>
<ol>
<li>Proposer 生成一个全局递增的提案编号 n，向<strong>所有</strong> Acceptor 广播 <code>Prepare(n)</code>。</li>
<li>Acceptor 检查编号 n：比自己见过的都大 → 做出承诺，并附带自己<strong>已接受的提案编号和值</strong> <code>(acceptedN, acceptedV)</code>（没接受过就不带）；否则直接拒绝。</li>
<li>Proposer 只需等到<strong>多数派</strong>回复 Promise，即可进入下一阶段。</li>
</ol>
<h4 data-id="heading-15">阶段二：Accept（值的落地）</h4>
<pre><code class="hljs language-arduino" lang="arduino">Proposer                       Acceptors
   │                              │
   │ 确定值 v                      │
   │──── <span class="hljs-built_in">Accept</span>(n, v) ───────────&gt;│  <span class="hljs-string">"请接受提案(n, v)"</span>
   │                              │
   │&lt;─── Accepted / Rejected ─────│  <span class="hljs-string">"收到！"</span> 或 <span class="hljs-string">"不行，我已经承诺了更大的编号"</span>
   │                              │
   └────&gt; Learners ───────────────&gt;  通知学习者结果
</code></pre>
<p><strong>值 v 怎么定？</strong> 这是 Paxos 最关键的约束，如果多数派的 Promise 响应中：</p>
<ol>
<li><strong>没有任何带回已接受的提案</strong> → Proposer 可以自由使用自己想提的值。</li>
<li><strong>有带回了已接受的提案</strong> → 不同 Acceptor 可能在不同时间接受过不同 Proposer 的提案，返回的 <code>(acceptedN, acceptedV)</code> 各不相同。Proposer <strong>必须选 acceptedN 最大的那个对应的值</strong>。理由：编号越大说明提案越晚发起，它的值越可能已经被多数派接受，继承它才不会覆盖已有的共识。</li>
</ol>
<p>确定 v 后：</p>
<ol>
<li>
<p>发出 <code>Accept(n, v)</code>——<strong>n 是自己的编号，v 可能是别人的值</strong>。</p>
</li>
<li>
<p>Acceptor 收到后：自己没承诺过更大的编号 → 接受；否则 → 拒绝。</p>
</li>
<li>
<p>多数派接受 → <strong>共识达成，值 v 被选定。</strong></p>
</li>
</ol>
<p>完整流程：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">---
config:
  theme: forest
  look: neo
---
sequenceDiagram
    autonumber
    participant P as Proposer
    participant A1 as Acceptor 1
    participant A2 as Acceptor 2
    participant A3 as Acceptor 3

    rect rgb(240, 248, 255)
    Note over P,A3: 阶段一：Prepare（抢占提案权）
    P-&gt;&gt;A1: Prepare(n=1)
    P-&gt;&gt;A2: Prepare(n=1)
    P-&gt;&gt;A3: Prepare(n=1)
    A1--&gt;&gt;P: Promise(无已接受提案)
    A2--&gt;&gt;P: Promise(无已接受提案)
    A3--&gt;&gt;P: Promise(无已接受提案)
    end

    Note over P: 收到多数派响应&lt;br/&gt;无已接受提案&lt;br/&gt;自由选值 v="X"

    rect rgb(240, 255, 240)
    Note over P,A3: 阶段二：Accept（值的落地）
    P-&gt;&gt;A1: Accept(n=1, v="X")
    P-&gt;&gt;A2: Accept(n=1, v="X")
    P-&gt;&gt;A3: Accept(n=1, v="X")
    A1--&gt;&gt;P: Accepted ✅
    A2--&gt;&gt;P: Accepted ✅
    A3--&gt;&gt;P: Accepted ✅
    end

    Note over P,A3: 多数派接受 → 值 "X" 被选定 🎉
</code></pre>
<h3 data-id="heading-16">核心问题：为什么新 Proposer 能"看见"旧值？</h3>
<p>这是理解 Paxos 的关键。让我们用一个具体场景来演示：</p>
<p><strong>场景</strong>：Proposer A 的提案已经被部分接受，然后 Proposer B 发起了新的提案。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">---
config:
  theme: forest
  look: neo
---
sequenceDiagram
    autonumber
    participant PA as Proposer A
    participant A1 as Acceptor 1
    participant A2 as Acceptor 2
    participant A3 as Acceptor 3
    participant PB as Proposer B

    Note over PA,A3: Proposer A 的回合

    rect rgb(240, 248, 255)
    PA-&gt;&gt;A1: Prepare(n=1)
    PA-&gt;&gt;A2: Prepare(n=1)
    A1--&gt;&gt;PA: Promise ✅
    A2--&gt;&gt;PA: Promise ✅
    end

    rect rgb(240, 255, 240)
    PA-&gt;&gt;A1: Accept(1, "X")
    PA-&gt;&gt;A2: Accept(1, "X")
    Note over A1: 已接受 (1, "X") ✅
    Note over A2: 已接受 (1, "X") ✅
    end

    Note over PA: 💥 Proposer A 宕机&lt;br/&gt;未通知 A3

    Note over PB,A3: Proposer B 的回合

    rect rgb(255, 248, 220)
    PB-&gt;&gt;A2: Prepare(n=2)
    PB-&gt;&gt;A3: Prepare(n=2)
    A2--&gt;&gt;PB: Promise + 已接受(1, "X") 📢
    A3--&gt;&gt;PB: Promise(无已接受提案)
    end

    Note over PB: 发现已有接受值 "X"&lt;br/&gt;必须沿用此值！

    rect rgb(240, 255, 240)
    PB-&gt;&gt;A2: Accept(2, "X")
    PB-&gt;&gt;A3: Accept(2, "X")
    Note over A2: 已接受 (2, "X") ✅
    Note over A3: 已接受 (2, "X") ✅
    end

    Note over PB,A3: 多数派 {A2, A3} 接受 → "X" 被选定 🎉
</code></pre>
<p><strong>关键步骤解读</strong>：</p>
<ol>
<li>Proposer A 让 {A1, A2} 接受了值 "X"（已构成多数派，值其实已经被选定），但 A 自己宕机了，没来得及通知 A3。</li>
<li>Proposer B 发起 <code>Prepare(n=2)</code>，询问 {A2, A3}（构成多数派）。</li>
<li>A2 回复："我承诺不再接受编号 &lt;2 的提案，<strong>但我之前已经接受了 (1, "X")</strong>"。</li>
<li>B 看到 A2 返回了已接受值 "X"，根据 Paxos 规则，<strong>必须使用 "X" 而不是自己的值</strong>。</li>
<li>B 用编号 2 发起 <code>Accept(2, "X")</code>，"X" 继续被传播。</li>
</ol>
<p><strong>这就是集合交集发挥作用的地方</strong>：</p>
<ul>
<li>A 的写入多数派是 {A1, A2}</li>
<li>B 的 Prepare 多数派是 {A2, A3}</li>
<li>交集是 {A2}，A2 将旧值 "X" 传递给了 B</li>
</ul>
<p><strong>没有 A2 这个"信息桥梁"，B 就不知道 "X" 已经被选定，可能会写入一个不同的值。</strong> 多数派的交集保证了任何新的 Proposer 都能发现旧值。</p>
<h3 data-id="heading-17">安全性论证</h3>
<p>我们来严格论证为什么 Paxos 不会出现"两个不同的值都被选定"的情况。</p>
<p><strong>反证法</strong>：假设值 v₁ 被选定（多数派 Q₁ 接受了提案 (n₁, v₁)），之后值 v₂ ≠ v₁ 也被选定（多数派 Q₂ 接受了提案 (n₂, v₂)，n₂ &gt; n₁）。</p>
<ol>
<li>v₂ 被选定，意味着 Proposer 在发起提案 n₂ 之前，先执行了 <code>Prepare(n₂)</code>，并获得了多数派 Q₃ 的承诺。</li>
<li>Q₁ ∩ Q₃ ≠ ∅（集合交集定律），所以 Q₃ 中至少有一个 Acceptor 已经接受了 (n₁, v₁)。</li>
<li>这个 Acceptor 在回复 <code>Prepare(n₂)</code> 时，必然返回了它已接受的值 v₁（或编号更大的其他值）。</li>
<li>根据 Paxos 规则，Proposer 必须使用返回值中编号最大的值。如果这个最大编号值可以追溯回 v₁，那么 v₂ = v₁，矛盾。</li>
</ol>
<blockquote>
<p>严格的数学归纳证明需要对 n₁ 到 n₂ 之间所有提案编号做归纳，这里给出核心直觉。</p>
</blockquote>
<h2 data-id="heading-18">三、活锁：Paxos 的致命软肋</h2>
<p>Basic Paxos 保证了<strong>安全性（Safety）</strong>——永远不会选定两个冲突的值。但它不保证<strong>活性（Liveness）</strong>——系统有可能永远选不出值。</p>
<h3 data-id="heading-19">活锁场景</h3>
<p>当两个 Proposer 交替抢占时，可能出现"你踩我，我踩你"的死循环：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">---
config:
  theme: forest
  look: neo
---
sequenceDiagram
    participant PA as Proposer A
    participant Acc as Acceptors (多数派)
    participant PB as Proposer B

    PA-&gt;&gt;Acc: Prepare(n=1)
    Acc--&gt;&gt;PA: Promise(1) ✅
    
    Note over PB: B 用更大编号抢占
    PB-&gt;&gt;Acc: Prepare(n=2)
    Acc--&gt;&gt;PB: Promise(2) ✅
    
    PA-&gt;&gt;Acc: Accept(1, "X")
    Acc--&gt;&gt;PA: 拒绝 ❌ (已承诺n=2)

    Note over PA: A 用更大编号反抢
    PA-&gt;&gt;Acc: Prepare(n=3)
    Acc--&gt;&gt;PA: Promise(3) ✅
    
    PB-&gt;&gt;Acc: Accept(2, "Y")
    Acc--&gt;&gt;PB: 拒绝 ❌ (已承诺n=3)
    
    Note over PA,PB: 循环往复，永远无法达成共识...
</code></pre>
<p><strong>过程分析</strong>：</p>
<ol>
<li>A 发起 <code>Prepare(1)</code>，获得承诺。</li>
<li>B 发起 <code>Prepare(2)</code>，编号更大，Acceptor 转而承诺 B。</li>
<li>A 的 <code>Accept(1, ...)</code> 被拒绝——Acceptor 已经承诺了更大的编号 2。</li>
<li>A 不甘心，发起 <code>Prepare(3)</code>，又抢回承诺。</li>
<li>B 的 <code>Accept(2, ...)</code> 被拒绝。</li>
<li>B 发起 <code>Prepare(4)</code>……如此反复。</li>
</ol>
<p>两个 Proposer 互相踩脚，谁都无法完成 Accept 阶段。理论上这个过程可以无限持续。</p>
<h3 data-id="heading-20">解药：选一个 Leader</h3>
<p>活锁的根源是<strong>多个 Proposer 并发竞争</strong>。解决方案很直观：<strong>选出一个 Leader，让它独占提案权</strong>。</p>
<p>这就是 <strong>Multi-Paxos</strong> 的核心思想：</p>
<ol>
<li>先通过一轮 Basic Paxos 选出一个 Leader。</li>
<li>只有 Leader 能发起提案。其他节点将请求转发给 Leader。</li>
<li>Leader 存活期间，Prepare 阶段只需执行一次，后续提案直接进入 Accept 阶段，<strong>将两阶段协议优化为一阶段</strong>。</li>
</ol>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Phase1 ["第一轮：Basic Paxos 选举 Leader"]
        direction LR
        P["Prepare(n)"] --&gt; Promise["多数派 Promise"]
        Promise --&gt; A["Accept(n, Leader=X)"]
        A --&gt; Chosen["多数派 Accepted&lt;br/&gt;X 当选 Leader ✅"]
    end

    subgraph Phase2 ["后续：客户端转发给 Leader，直接 Accept"]
        direction LR
        C1["Client 请求 v1"] --&gt;|转发| L["Leader X"]
        C2["Client 请求 v2"] --&gt;|转发| L
        C3["Client 请求 v3"] --&gt;|转发| L
        L --&gt; A1["Accept v1 ✅"]
        L --&gt; A2["Accept v2 ✅"]
        L --&gt; A3["Accept v3 ✅"]
    end

    Phase1 --&gt;|"Leader 存活期间&lt;br/&gt;无需再 Prepare"| Phase2

    style P fill:#ffe66d
    style Promise fill:#ffe66d
    style A fill:#ffe66d
    style Chosen fill:#ff6b6b
    style C1 fill:#f0f0f0
    style C2 fill:#f0f0f0
    style C3 fill:#f0f0f0
    style L fill:#ff6b6b
    style A1 fill:#4ecdc4
    style A2 fill:#4ecdc4
    style A3 fill:#4ecdc4
    style Phase1 fill:#fdfdfd,stroke:#ddd,stroke-dasharray: 5 5
    style Phase2 fill:#fdfdfd,stroke:#ddd,stroke-dasharray: 5 5
</code></pre>
<p><strong>性能对比</strong>：</p>

























<table><thead><tr><th/><th>Basic Paxos</th><th>Multi-Paxos</th></tr></thead><tbody><tr><td>每次提案的网络轮次</td><td>2 轮（Prepare + Accept）</td><td>1 轮（仅 Accept）</td></tr><tr><td>并发冲突风险</td><td>高（活锁）</td><td>低（Leader 独占）</td></tr><tr><td>Leader 故障影响</td><td>无 Leader 概念</td><td>需要重新选举</td></tr></tbody></table>
<p>Multi-Paxos 大幅提升了效率，但 Paxos 的原论文只给出了核心思想，并未定义完整的工程实现细节（比如 Leader 怎么选、日志怎么管理）。这也是为什么后来 <strong>Raft</strong> 算法诞生时，将"可理解性"作为首要设计目标——它本质上就是一个<strong>工程化的 Multi-Paxos</strong>。</p>
<h2 data-id="heading-21">总结</h2>
<p>本篇我们完成了从"全员模型"到"多数派模型"的关键跨越：</p>
<ul>
<li><strong>集合交集定律</strong>是多数派机制的数学基石。W + R &gt; N 保证了任意两个多数派必然存在交集，信息不会丢失。</li>
<li><strong>Basic Paxos</strong> 用两阶段协议（Prepare + Accept）解决了多数派模型下的写冲突问题。Prepare 阶段通过编号抢占实现全局排序，Accept 阶段通过"继承旧值"保证已选定的值不会被覆盖。</li>
<li><strong>活锁</strong>是 Basic Paxos 的固有缺陷，多个 Proposer 并发竞争可能导致系统无法推进。解药是引入 Leader，即 Multi-Paxos。</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    A["全员模型&lt;br/&gt;2PC/3PC"] --&gt;|"容错为0&lt;br/&gt;分区即崩溃"| B["多数派模型&lt;br/&gt;Quorum"]
    B --&gt;|"解决写冲突"| C["Basic Paxos&lt;br/&gt;两阶段共识"]
    C --&gt;|"解决活锁"| D["Multi-Paxos&lt;br/&gt;Leader 机制"]
    D --&gt;|"工程化规范"| E["Raft"]
    
    style A fill:#ff6b6b
    style B fill:#ffe66d
    style C fill:#4ecdc4
    style D fill:#4ecdc4
    style E fill:#4ecdc4
</code></pre>
<blockquote>
<p><strong>下篇预告：</strong></p>
<p>Multi-Paxos 指明了方向——选一个 Leader，由它来统一调度。但具体怎么选？Leader 怎么把日志安全地复制到所有节点？Leader 挂了怎么保证数据不丢？</p>
<p>下一篇，我们将深入 <strong>Raft 算法</strong>，看它如何用"任期（Term）"和"日志复制（Log Replication）"两把利剑，把 Multi-Paxos 的思想落地为一套清晰可实现的工程方案。</p>
</blockquote>
<hr/>
<p><strong>思考题</strong></p>
<ol>
<li>在一个 5 节点系统中，如果有 3 个节点同时宕机，Paxos 还能工作吗？为什么？</li>
</ol>
<details> <summary>参考答案</summary> <div> <b>不能工作。</b><br/><br/> <ul> <li><b>原因</b>：5 节点系统的多数派需要至少 3 个节点。如果 3 个节点宕机，只剩 2 个节点，无法构成多数派。</li> <li><b>Prepare 阶段</b>：Proposer 无法获得 3 个 Acceptor 的承诺，因此无法进入 Accept 阶段。</li> <li><b>安全性保证</b>：系统不会做出错误的决定（不会选定两个冲突的值），但会停止服务——牺牲可用性来保证一致性。</li> <li><b>N 节点系统的容错上限</b>：最多容忍 ⌊(N-1)/2⌋ 个节点故障，5 节点最多容忍 2 个。</li> </ul> <b>总结</b>：这正是 CAP 定理的体现——在网络分区（或节点故障）时，Paxos 选择了一致性（C），牺牲了可用性（A）。 </div> </details>
<ol start="2">
<li>Paxos 的 Prepare 阶段返回"已接受的最大编号提案"，如果不返回这个信息会怎样？</li>
</ol>
<details> <summary>参考答案</summary> <div> <b>会导致已选定的值被覆盖，破坏一致性。</b><br/><br/> <b>具体场景：</b> <ul> <li>Proposer A 用编号 1 让多数派接受了值 "X"（值已被选定）</li> <li>Proposer B 用编号 2 发起 Prepare，如果 Acceptor 不返回已接受的值——</li> <li>B 不知道 "X" 已被选定，自由选择了 "Y"</li> <li>B 发起 Accept(2, "Y")，因为编号更大，Acceptor 接受了</li> <li>结果：系统先选定了 "X"，又选定了 "Y"，一致性被破坏</li> </ul> <b>本质</b>：Prepare 阶段返回已接受值，是 Paxos 的"信息传递机制"。正是通过多数派的交集，新 Proposer 才能发现旧值并继承它，这是 Paxos 安全性的核心保障。 </div> </details>
<ol start="3">
<li>提案编号（Proposal Number）在实际系统中如何生成？怎样保证全局唯一且递增？</li>
</ol>
<details> <summary>参考答案</summary> <div> <b>常用方案：轮次 + 节点ID</b><br/><br/> <ul> <li><b>编号格式</b>：<code>proposal_number = round * N + node_id</code>，其中 N 是节点总数，node_id 是节点的唯一编号（0 到 N-1）</li> <li><b>举例（3 节点系统）</b>： <ul> <li>节点0 第一轮：0×3+0=0，第二轮：1×3+0=3，第三轮：2×3+0=6</li> <li>节点1 第一轮：0×3+1=1，第二轮：1×3+1=4，第三轮：2×3+1=7</li> <li>节点2 第一轮：0×3+2=2，第二轮：1×3+2=5，第三轮：2×3+2=8</li> </ul> </li> <li><b>特点</b>：不同节点生成的编号天然不会重复；每个节点只需维护本地的 round 计数器；递增通过增加 round 值实现</li> <li><b>优化</b>：节点在收到其他提案的编号后，可以将自己的 round 更新为 <code>max(本地round, 收到的编号/N) + 1</code>，避免使用过时的小编号</li> </ul> <b>总结</b>：这个方案简洁高效，无需中心化的编号分配器，是 Paxos 工程实现中的经典设计。 </div> </details></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[⏰前端周刊第 452 期（2026年2月2日-2月8日）]]></title>    <link>https://juejin.cn/post/7604012106154360878</link>    <guid>https://juejin.cn/post/7604012106154360878</guid>    <pubDate>2026-02-09T01:49:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604012106154360878" data-draft-id="7604646882015019059" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="⏰前端周刊第 452 期（2026年2月2日-2月8日）"/> <meta itemprop="keywords" content="前端,JavaScript,GitHub"/> <meta itemprop="datePublished" content="2026-02-09T01:49:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掘金安东尼"/> <meta itemprop="url" content="https://juejin.cn/user/1521379823340792"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ⏰前端周刊第 452 期（2026年2月2日-2月8日）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1521379823340792/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    掘金安东尼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:49:08.000Z" title="Mon Feb 09 2026 01:49:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>📢 <strong>宣言</strong>：<strong>每周更新国外论坛的前端热门文章，推荐大家阅读/翻译，紧跟时事，掌握前端技术动态，也为写作或突破新领域提供灵感~</strong></p>
<p>欢迎大家访问：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTUARAN%2Ffrontend-weekly-digest-cn" target="_blank" title="https://github.com/TUARAN/frontend-weekly-digest-cn" ref="nofollow noopener noreferrer">github.com/TUARAN/fron…</a>
顺手点个 ⭐ star 支持，是我们持续输出的续航电池🔋✨！</p>
<p>在线网址：<a href="https://link.juejin.cn?target=https%3A%2F%2Ffrontendweekly.cn%2F" target="_blank" title="https://frontendweekly.cn/" ref="nofollow noopener noreferrer">frontendweekly.cn/</a></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5f563534b00f41edb2da1a5042327d04~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR5a6J5Lic5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771206548&amp;x-signature=8zwYVmIbMuWqqD8KMiYtojZ%2FtLw%3D" alt="前端周刊封面" loading="lazy"/></p>
<hr/>
<p>💬 <strong>推荐语</strong></p>
<p>本期聚焦“交互组件选择 + 浏览器行为细节 + 生态工具更新”。Web 开发部分从组合框/多选/列表框的选型指南、浏览器对“意外”变更的敏感反应，到“不要把单词拆成字母”的可访问性提醒；工具与性能板块涵盖 Deno 生态新进展、ESLint 10 发布、ViteLand 月报、以及 SVG/视频与 Node.js 版本演进的性能分析。CSS 方面关注 @scope、@container scroll-state()、bar chart 与 clamp() 等现代特性；JavaScript 则有 Temporal 提案、显式资源管理、框架选型与 React/Angular 的新范式探讨。</p>
<hr/>
<h2 data-id="heading-0">🗂 本期精选目录</h2>
<h3 data-id="heading-1">🧭 Web 开发</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2026%2F02%2Fcombobox-vs-multiselect-vs-listbox%2F" target="_blank" title="https://www.smashingmagazine.com/2026/02/combobox-vs-multiselect-vs-listbox/" ref="nofollow noopener noreferrer">组合框 vs 多选 vs 列表框：如何选择合适的控件</a>：通过任务目标、输入方式与可访问性维度，梳理三种控件的适用场景与常见误用。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ffrontendmasters.com%2Fblog%2Fthe-browser-hates-surprises%2F" target="_blank" title="https://frontendmasters.com/blog/the-browser-hates-surprises/" ref="nofollow noopener noreferrer">浏览器讨厌惊喜</a>：解析浏览器对布局抖动、同步布局读取等“意外变化”的反应机制与优化建议。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fadrianroselli.com%2F2026%2F02%2Fyou-know-what-just-dont-split-words-into-letters.html" target="_blank" title="https://adrianroselli.com/2026/02/you-know-what-just-dont-split-words-into-letters.html" ref="nofollow noopener noreferrer">你知道吗？别再把单词拆成字母了</a>：提醒不要用逐字拆分的方式做视觉效果，否则会严重破坏可访问性与可读性。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.logrocket.com%2Fshadcn-ui-adoption-guide%2F" target="_blank" title="https://blog.logrocket.com/shadcn-ui-adoption-guide/" ref="nofollow noopener noreferrer">Shadcn UI 采用指南：概览、示例与替代方案</a>：从接入方式、组件定制到生态对比，给出更务实的选型与迁移建议。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.developerway.com%2Fposts%2Fdebugging-with-ai" target="_blank" title="https://www.developerway.com/posts/debugging-with-ai" ref="nofollow noopener noreferrer">用 AI 调试：能取代资深开发者吗？</a>：探讨 AI 在调试中的价值边界与使用方式，强调人类经验仍是关键。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebkit.org%2Fblog%2F17808%2Finterop-2025-review%2F" target="_blank" title="https://webkit.org/blog/17808/interop-2025-review/" ref="nofollow noopener noreferrer">Interop 2025：趋同的一年</a>：回顾 2025 的浏览器互操作进展，总结关键落地能力与下一步方向。</li>
</ul>
<h4 data-id="heading-2">🛠 工具</h4>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeno.com%2Fblog%2Fintroducing-deno-sandbox" target="_blank" title="https://deno.com/blog/introducing-deno-sandbox" ref="nofollow noopener noreferrer">Introducing Deno Sandbox</a>：Deno Sandbox 发布：更安全的执行环境与更细粒度的权限控制思路。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeno.com%2Fblog%2Fdeno-deploy-is-ga" target="_blank" title="https://deno.com/blog/deno-deploy-is-ga" ref="nofollow noopener noreferrer">Deno Deploy 正式 GA</a>：Deno Deploy 进入 GA：面向边缘部署的能力完善与产品层面的重要里程碑。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Feslint.org%2Fblog%2F2026%2F02%2Feslint-v10.0.0-released%2F" target="_blank" title="https://eslint.org/blog/2026/02/eslint-v10.0.0-released/" ref="nofollow noopener noreferrer">ESLint v10.0.0 发布</a>：ESLint 10 更新概览：新特性、破坏性变更与迁移指引。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fvoidzero.dev%2Fposts%2Fwhats-new-jan-2026" target="_blank" title="https://voidzero.dev/posts/whats-new-jan-2026" ref="nofollow noopener noreferrer">ViteLand 2026 年 1 月新动态</a>：Vite/Rolldown 生态月报，了解近期工具链与插件动向。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fremysharp.com%2F2026%2F02%2F02%2Fjs-bin-down-in-2026" target="_blank" title="https://remysharp.com/2026/02/02/js-bin-down-in-2026" ref="nofollow noopener noreferrer">JS Bin 在 2026 年下线</a>：经典在线编辑器 JS Bin 的关闭说明与后续替代建议。</li>
</ul>
<h4 data-id="heading-3">⚡️ 性能</h4>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.phpied.com%2Fmeasuring-svg-rendering-time%2F" target="_blank" title="https://www.phpied.com/measuring-svg-rendering-time/" ref="nofollow noopener noreferrer">测量 SVG 渲染时间</a>：分析 SVG 渲染的测量方法与指标，帮助定位性能瓶颈。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ffrontendmasters.com%2Fblog%2Fperformance-optimized-video-embeds-with-zero-javascript%2F" target="_blank" title="https://frontendmasters.com/blog/performance-optimized-video-embeds-with-zero-javascript/" ref="nofollow noopener noreferrer">零 JavaScript 的性能优化视频嵌入</a>：用更轻的 HTML/CSS 方案减少视频首屏成本。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.repoflow.io%2Fblog%2Fnode-js-16-to-25-benchmarks-how-performance-evolved-over-time" target="_blank" title="https://www.repoflow.io/blog/node-js-16-to-25-benchmarks-how-performance-evolved-over-time" ref="nofollow noopener noreferrer">Node.js 16 到 25 的性能基准</a>：从多版本基准测试观察 Node.js 性能演进与回归趋势。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fallenpike.com%2F2026%2Fa-broken-heart%2F" target="_blank" title="https://allenpike.com/2026/a-broken-heart/" ref="nofollow noopener noreferrer">破碎的心：一行傻代码带来 100 倍提速</a>：一个真实的 100x 加速案例，强调定位热点与微改动的重要性。</li>
</ul>
<h3 data-id="heading-4">🎨 CSS</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Futilitybend.com%2Fblog%2Fis-it-scrolled-is-it-not-lets-find-out-with-css-container-scroll-state-queries%2F" target="_blank" title="https://utilitybend.com/blog/is-it-scrolled-is-it-not-lets-find-out-with-css-container-scroll-state-queries/" ref="nofollow noopener noreferrer">到底滚了没有？用 CSS @container scroll-state() 查询判断</a>：介绍 scroll-state() 的用法与可实现的交互模式。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnerdy.dev%2Fnice-select" target="_blank" title="https://nerdy.dev/nice-select" ref="nofollow noopener noreferrer">Nice Select</a>：精致的选择框样式与实现思路，适合作为组件设计参考。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2026%2F02%2Fcss-scope-alternative-naming-conventions%2F" target="_blank" title="https://www.smashingmagazine.com/2026/02/css-scope-alternative-naming-conventions/" ref="nofollow noopener noreferrer">CSS @scope：命名约定与重度抽象的替代方案</a>：用 @scope 控制样式作用域，降低命名和层级复杂度。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ffrontendmasters.com%2Fblog%2Fan-over-the-top-spoiler-design-with-the-details-element%2F" target="_blank" title="https://frontendmasters.com/blog/an-over-the-top-spoiler-design-with-the-details-element/" ref="nofollow noopener noreferrer">基于 details 的夸张剧透设计</a>：展示如何利用 <code>details/summary</code> 做互动式“剧透”组件。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.projectwallace.com%2Fthe-css-selection%2F2026" target="_blank" title="https://www.projectwallace.com/the-css-selection/2026" ref="nofollow noopener noreferrer">CSS Selection 2026：真实世界 CSS 使用现状</a>：通过统计数据观察 CSS 特性在实际项目中的应用分布。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fcss-bar-charts-using-modern-functions%2F" target="_blank" title="https://css-tricks.com/css-bar-charts-using-modern-functions/" ref="nofollow noopener noreferrer">用现代函数构建 CSS 条形图</a>：结合 <code>calc()</code>、<code>clamp()</code> 等函数实现数据可视化布局。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fkizu.dev%2Fshrinkwrap-solution%2F" target="_blank" title="https://kizu.dev/shrinkwrap-solution/" ref="nofollow noopener noreferrer">Shrinkwrap 新实验方案</a>：探索 shrinkwrap 相关布局问题的实验性解法。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcss-tip.com%2Fclamp-auto%2F" target="_blank" title="https://css-tip.com/clamp-auto/" ref="nofollow noopener noreferrer">如何在 clamp() 中使用 “auto”</a>：解释 <code>auto</code> 在 <code>clamp()</code> 中的可用模式与注意点。</li>
</ul>
<h3 data-id="heading-5">💡 JavaScript</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblogs.igalia.com%2Fcompilers%2F2026%2F01%2F31%2Fimplementing-the-temporal-proposal-in-javascriptcore%2F" target="_blank" title="https://blogs.igalia.com/compilers/2026/01/31/implementing-the-temporal-proposal-in-javascriptcore/" ref="nofollow noopener noreferrer">在 JavaScriptCore 中实现 Temporal 提案</a>：从引擎角度理解 Temporal 的设计与实现细节。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fallthingssmitty.com%2F2026%2F02%2F02%2Fexplicit-resource-management-in-javascript%2F" target="_blank" title="https://allthingssmitty.com/2026/02/02/explicit-resource-management-in-javascript/" ref="nofollow noopener noreferrer">JavaScript 的显式资源管理</a>：介绍显式资源管理语法与应用场景，提升可控性与可靠性。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.inngest.com%2Fblog%2Fmigrating-off-nextjs-tanstack-start" target="_blank" title="https://www.inngest.com/blog/migrating-off-nextjs-tanstack-start" ref="nofollow noopener noreferrer">本地开发时间减少 83%：为何迁出 Next.js</a>：团队迁移决策与性能收益复盘，适合评估框架成本与边界。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.logrocket.com%2Freact-remix-vs-next-js-vs-sveltekit%2F" target="_blank" title="https://blog.logrocket.com/react-remix-vs-next-js-vs-sveltekit/" ref="nofollow noopener noreferrer">Remix vs. Next.js vs. SvelteKit</a>：对比三大框架在路由、数据加载与开发体验上的差异。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fanita-app.com%2Fblog%2Farticles%2Freact-compiler-and-why-class-objects-work-against-memoization.html" target="_blank" title="https://anita-app.com/blog/articles/react-compiler-and-why-class-objects-work-against-memoization.html" ref="nofollow noopener noreferrer">React Compiler 与类对象对 memoization 的影响</a>：解释类对象为何不利于编译器优化与记忆化。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.syncfusion.com%2Fblogs%2Fpost%2Fincremental-hydration-in-angular-apps" target="_blank" title="https://www.syncfusion.com/blogs/post/incremental-hydration-in-angular-apps" ref="nofollow noopener noreferrer">Angular 的增量式水合：构建“瞬时可交互”的 SSR 应用</a>：增量水合思路与实践路径，提升首屏体验与可交互性。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Elpis 总结]]></title>    <link>https://juejin.cn/post/7603911453704192043</link>    <guid>https://juejin.cn/post/7603911453704192043</guid>    <pubDate>2026-02-08T10:46:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603911453704192043" data-draft-id="7603644943350153222" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Elpis 总结"/> <meta itemprop="keywords" content="低代码,JSON"/> <meta itemprop="datePublished" content="2026-02-08T10:46:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="酒精检测仪"/> <meta itemprop="url" content="https://juejin.cn/user/3087868572205982"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Elpis 总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3087868572205982/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    酒精检测仪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T10:46:53.000Z" title="Sun Feb 08 2026 10:46:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">简述</h2>
<p>elpis 是一个沉淀了 80% 的标准性、重复性的 CRUD 工作，又提供了 20% 的个性化扩展的前端框架，能基于一份 json 配置快速搭建标准的中后台管理系统页面，同时保障稳定性与可靠性。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1deabb6fa2084af4a16a99107de9c33f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YWS57K-5qOA5rWL5Luq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771152507&amp;x-signature=Sdkwcss%2Briryx%2Ff1j2XXqn%2BMHqw%3D" alt="elpis" loading="lazy"/></p>
<p>elpis 的整体架构如上。它是一个 BFF 层的架构，是前后端的桥梁。</p>
<ul>
<li>从一份领域模型 model 的 json 配置（如商品管理），可以拓宽到各个业务系统（如淘宝商品管理、京东商品管理）。
<ul>
<li>json 满足 json-shema 规范，定义前后端统一校验与数据库表设计，同时扩展出 UI 组件的配置</li>
</ul>
</li>
<li>经过 elpis BFF 的处理，可 SSR 渲染各个业务系统的首页，提升首页的渲染速度。首页内菜单系统的切换是采用的 vue-router 的 SPA，保证其流畅性。</li>
<li>在 elpis 中，提供了常用的如 input、select等基础 UI 组件，同时支持业务方自定义组件与页面，满足业务特性需求。</li>
<li>接口遵循 restful 规范，交互同样经过 elpis。借助洋葱圈模型思想，支持了全局错误捕获、签名校验、参数校验、日志记录等多个中间件</li>
<li>实现不同环境的 webpack 差异化配置，满足开发与生产的不同需求</li>
</ul>
<h2 data-id="heading-1">基于 koa 设计服务端引擎</h2>
<p>为了统一代码规范，提升开发效率，借鉴 egg 的思路，设计了 elpis-core 服务端引擎
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c150951adeb94fd7b4d0c82b5d71a519~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YWS57K-5qOA5rWL5Luq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771152507&amp;x-signature=CdXhXrKSy6mgQONdCrSf323bf%2B4%3D" alt="elpis-core" loading="lazy"/></p>
<h3 data-id="heading-2">loader 自动加载</h3>
<p>为了减少在代码中各种 require 导致的依赖不清晰，elpis 设计了约定式的目录结构，在对应目录下的文件导出的实例都会被挂在 app 对象上。具体说来，eipis 借用 glob 和 path 两个工具，将相应文件夹下的 js 文件的文件名统一改为驼峰式命名，同时实例化对象并挂载到 app 下。如 <code>app/middleware/api-params-verify.js</code> 中的实例最终会处理成<code>app.middlewares.apiParamsVerify</code>。这样可以通过 app 对象访问到任何模块，而不需要require。</p>
<pre><code class="hljs language-rust" lang="rust">app/controller<span class="hljs-comment">/**/</span>**.js      -<span class="hljs-punctuation">-&gt;</span>  app.controller.xxx
app/extend<span class="hljs-comment">/**/</span>**.js          -<span class="hljs-punctuation">-&gt;</span>  app.extend.xxx
app/middleware<span class="hljs-comment">/**/</span>**.js      -<span class="hljs-punctuation">-&gt;</span>  app.middleware.xxx
app/router<span class="hljs-comment">/**/</span>**.js          -<span class="hljs-punctuation">-&gt;</span>  app.router.xxx
app/router-schema<span class="hljs-comment">/**/</span>**.js   -<span class="hljs-punctuation">-&gt;</span>  app.routerSchema.xxx
app/service<span class="hljs-comment">/**/</span>**.js         -<span class="hljs-punctuation">-&gt;</span>  app.service.xxx
app/config<span class="hljs-comment">/**/</span>**.js          -<span class="hljs-punctuation">-&gt;</span>  app.config.xxx
</code></pre>
<h3 data-id="heading-3">中间件设计</h3>
<p>利用洋葱圈模型，请求（包含业务请求和 API 请求）经过一层层的中间件过滤，再进行业务逻辑的处理，将处理后的结果再一层层返回。</p>
<p>elpis 中定义了三个基础中间件：</p>
<ol>
<li>全局错误捕获。在最外层，最先使用，catch 住后续所有的错误并记录日志。再进行错误分析，如果是请求不存在的页面，则重定向到主页，不会导致页面白屏；如果是 API 请求报错，则统一返回<code>code: 50000, message: "网络异常 请稍后重试"</code>，不会导致接口无响应。</li>
<li>签名校验。对接口请求，将 key 和时间戳进行 md5 加密。防止恶意请求，减少服务压力。</li>
<li>参数校验。从 ctx 上下文中获取接口的 body、query、header等参数并记录日志，结合 ajv + json-schema，看是否满足<code>model/**.json</code>中的字段定义的规则。如不满足，直接拦截。</li>
</ol>
<p>此外，业务方可根据自己的需求定义额外的中间件。</p>
<h2 data-id="heading-4">基于 webpack 搭建前端工程化</h2>
<h3 data-id="heading-5">开发环境热更新</h3>
<p>由于首页采用 SSR 渲染，需要将模板 .tpl 文件输出到磁盘，方便后端能拿到最新的模板渲染页面。而现有的 hmr 服务如 webpack-dev-server 将<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.webpackjs.com%2Fguides%2Fdevelopment%2F%23using-webpack-dev-server" target="_blank" title="https://www.webpackjs.com/guides/development/#using-webpack-dev-server" ref="nofollow noopener noreferrer">所有文件保存到内存中</a>，无法满足需求，故采用 webpack-dev-middleware 和 webpack-hot-middleware 实现定制的 hmr 服务（webpack-dev-server 就是封对二者进行了封装）。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33b79a66d9174f2d97ced8e268621717~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YWS57K-5qOA5rWL5Luq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771152507&amp;x-signature=QrdCdaVrd8seKOptSoW8UKospMA%3D" alt="hmr" loading="lazy"/>
如图，实现 hmr 服务需要两个基础能力：</p>
<ol>
<li>监控能力。使用 webpack-dev-middleware 监控到业务文件的改变，触发解析引擎工作，将编译后的新的 js/css 文件替换掉内存中旧的。</li>
<li>通讯能力。使用 webpack-hot-middleware 进行通讯，通过 webSocket与浏览器保持长连接，推送文件变动事件（如 hash-changed ）和新模块的加载指令（如 js/css 文件路径）。浏览器接收到通知后，从内存中动态请求新的产物文件，执行模块替换。</li>
</ol>
<p>此外，还需进行两处配置：</p>
<ol>
<li>由于 hmr 服务是通过 express 启动的，与后端 elpis-core 服务在不同的端口上，需要配置跨域请求允许。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack-hot-middleware" target="_blank" title="https://github.com/webpack/webpack-hot-middleware" ref="nofollow noopener noreferrer">客户端也需要被注入 hmr 的代码</a>。所以需要在每个每个入口文件都加上 webpack-hot-middleware 的客户端代码，指定 HMR 的通信路径和端口。</li>
</ol>
<h3 data-id="heading-6">构建与打包</h3>
<p>不同的运行环境需要不同的配置，elpis 中一共使用了三份 webpack 文件。在 webpack.base.js 中定义了通用需配置，然后在开发环境和生产环境中通过 webpack-merge 插件的 <code>merge.smart</code> 引入通用配置并拓展当前环境所需的配置。</p>
<ol>
<li>通用配置。
<ul>
<li><code>vue-loader</code>,  <code>babel-loader</code> , <code>style-loader</code> 等各种 loader 解析器</li>
<li>别名配置（模块解析的具体行为）</li>
<li><code>CleanWebpackPlugin</code>，每次build前，清空 public/dist 目录</li>
<li>打包输出优化（代码分割，模块合并，缓存 chunkhash，压缩优化等策略）</li>
</ul>
</li>
<li>开发环境配置。主要是 hmr。</li>
<li>生产环境配置。
<ul>
<li>使用 <code>thread-loader</code> 利用多核 CPU 加快打包速度</li>
<li>使用 <code>mini-css-extract-plugin</code> 抽取 css 文件，不打包到 js 中，否则会阻塞渲染。使用 <code>css-minimizer-webpack-plugin</code> 压缩 css</li>
<li>使用 <code>terser-webpack-plugin</code> 压缩 js</li>
</ul>
</li>
</ol>
<p>总之，开发环境注重的是构建速度，生产环境注重的是文件体积大小与安全稳定性。</p>
<h3 data-id="heading-7">业务拓展</h3>
<p>以上都是 elpis 提供的基础服务，此外 elpis 支持业务自定义工程化配置，只需要在业务对应的目录（/app/webpack.config.js）下编写 webpack 文件即可，elpis会通过 <code>merge.smart</code> 合并到一起。</p>
<p>但 elpis 不止于此，elpis 将约定优于配置发挥的淋漓尽致。除了支持业务自定义工程化配置，还支持自定义页面，自定义组件，只需在<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40hbl.%2Felpis" target="_blank" title="https://www.npmjs.com/package/@hbl./elpis" ref="nofollow noopener noreferrer">约定目录</a>下新建文件即可。这些目录下的文件都会被合并到 elpis 中，使用 elpis 的能力。</p>
<h2 data-id="heading-8">基于 json-schema 设计动态组件体系</h2>
<p>上文说到，elpis 支持配置化开发，用户只需要配置一份 json，即可生成一个完整的页面。如下图，这份 json，不仅仅满足 json-schema 规范，可进行数据校验，elpis 对其功能进行了扩展，可以动态设计 UI 组件。甚至，还能用于辅助数据库建表。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de43555ec31849819e171e563e916d60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YWS57K-5qOA5rWL5Luq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771152507&amp;x-signature=y%2FqeQRLjxQTKn9g0mhk4DW4dKZQ%3D" alt="json-schema" loading="lazy"/></p>
<h3 data-id="heading-9">json-schema 规范</h3>
<p>采用 json-schema 有以下几个原因</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fjson-schema.apifox.cn%2F" target="_blank" title="https://json-schema.apifox.cn/" ref="nofollow noopener noreferrer">规范完整</a>，完全满足校验需求，且业界流行度高，有完整的校验库（<a href="https://link.juejin.cn?target=https%3A%2F%2Fajv.nodejs.cn%2F" target="_blank" title="https://ajv.nodejs.cn/" ref="nofollow noopener noreferrer">ajv</a>）支持。</li>
<li>json 只是一份数据，前端、后端、数据库可共用，避免了前后端校验不一致的情况（element-plus 中的校验只能前端使用，没法和后端保持统一）。由于定义了数据类型、是否必填等关键信息，后期数据库建表亦可参照此 json。</li>
<li>可拓展性强。elpis 在满足 json-schema 规范的基础上拓展出了 UI 组件的描述。</li>
</ul>

<pre><code class="hljs language-css" lang="css">...
  product_name: {
    type: <span class="hljs-string">"string"</span>,
    label: <span class="hljs-string">"商品名称"</span>,
    maxLength: <span class="hljs-number">10</span>,
    minLength: <span class="hljs-number">2</span>,
    tableOption: {
      <span class="hljs-attribute">width</span>: <span class="hljs-number">200</span>,
    },
    searchOption: {
      comType: <span class="hljs-string">"dynamicSelect"</span>,
      api: <span class="hljs-string">"/api/proj/product_name/list"</span>,
    },
    createFormOption: {
      comType: <span class="hljs-string">"input"</span>,
      default: <span class="hljs-string">"iPhone 17 pro"</span>,
    },
    editFormOption: {
      comType: <span class="hljs-string">"input"</span>,
    },
    detailPanelOption: {},
  },
...
  tableConfig: {
    headerButtons: [
      {
        <span class="hljs-selector-tag">label</span>: <span class="hljs-string">"新增商品"</span>,
        eventKey: <span class="hljs-string">"showComponent"</span>,
        eventOption: {
          comName: <span class="hljs-string">"createForm"</span>,
        },
        type: <span class="hljs-string">"primary"</span>,
      },
    ],
    rowButtons: [
      {
        <span class="hljs-selector-tag">label</span>: <span class="hljs-string">"详情"</span>,
        eventKey: <span class="hljs-string">"showComponent"</span>,
        eventOption: {
          comName: <span class="hljs-string">"detailPanel"</span>,
        },
        type: <span class="hljs-string">"primary"</span>,
        text: true,
      },
    ],
  },
  componentConfig: {
    createForm: {
      title: <span class="hljs-string">"新增商品"</span>,
      saveBtnText: <span class="hljs-string">"保存"</span>,
    },
  },
...
</code></pre>
<p>示例如上，对于“商品名称”这个字段，4-7 行是 json-schema 规范约束，往后都是 UI 组件描述。如在 tableOption 定义 width: 200, 则商品名称在表格中占据的宽度为200，tableOption 中的所有属性描述，可参照 eloment-plus 的 <a href="https://link.juejin.cn?target=https%3A%2F%2Felement-plus.org%2Fzh-CN%2Fcomponent%2Ftable%23table-column-api" target="_blank" title="https://element-plus.org/zh-CN/component/table#table-column-api" ref="nofollow noopener noreferrer">table-column</a>，elpis 中已经做了绑定。如在 searchOption 中定义的 comType: "dynamicSelect"，标识商品名称在搜索表单中的组件类型是一个动态下拉框，下拉框中的值通过 "/api/proj/product_name/list" 这个接口去获取。</p>
<h3 data-id="heading-10">动态组件设计</h3>
<p>用户在 json 中说明字段需要在哪些地方展示（核心组件和动态组件），使用哪种组件类型（基础控件），elpis 用 Vue 的 component 标签，动态绑定 is 属性，同时给子组件传入对应的 json-schema 约束。通过 ref 收集所有子组件的引用，外层统一处理子组件的相关逻辑（如 validate 和 getValue 方法）。</p>
<ol>
<li>
<p>基础配置</p>
<p>elpis 中提供了 schema-table、schema-search-bar 两个核心组件和 createForm、editForm、detailPanel 三个动态组件 和 input、inputNumber、select、dynamicSelect、dateRange 六个基础控件。用户在 json 中可自由搭配组合，只需满足对应规范，即可配置出一个完整的 CRUD 页面。</p>
</li>
<li>
<p>业务拓展</p>
<p>当基础配置满足不了业务需求时，elpis 支持业务拓展自己的组件。只需在<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40hbl.%2Felpis" target="_blank" title="https://www.npmjs.com/package/@hbl./elpis" ref="nofollow noopener noreferrer">约定目录</a>下新建文件即可。具体说来：</p>
<ul>
<li>编写业务自定义组件</li>
<li>在约定目录下创建组件映射，如 <code>userPanel: { component: UserPanel }</code></li>
<li>elpis 使用 process.cwd 识别到业务约定目录下的映射文件，与自己的基础组件合并，同名会覆盖基础组件</li>
<li>Vue 的 component 标签动态渲染时，从合并后的配置对象里查找组件。无论是 elpis 内置的还是业务扩展的，都能找到</li>
</ul>
</li>
</ol>
<h2 data-id="heading-11">基于 docker 改造项目部署</h2>
<h3 data-id="heading-12">docker</h3>
<ol>
<li>编写 DokcerFile 构建 docker 镜像，保证本地、测试、生产使用的是同一镜像，不会导致环境差异问题</li>
<li>镜像有tag（branch+commit），可以做版本管理，方便出现问题及时回滚</li>
</ol>
<h3 data-id="heading-13">流水线</h3>
<p>基于腾讯 DevOps 2.0-Clound Native Build（cnb）构建 CI/CD 流水线，解决以往手动拉代码、打包、上传、部署的低效问题，只需要配置一次，后续无限复用。</p>
<ol>
<li><code>npm run lint</code> 检查格式化与 js 报错</li>
<li><code>npm install + npm run build</code> 打包</li>
<li><code>docker build + docker push</code> 构建 docker 镜像并推送到镜像仓库</li>
<li>借用 cnbcool/ssh 工具在服务器上 <code>docker pull + docker run</code> 启动最新镜像</li>
</ol>
<h2 data-id="heading-14">后续改进</h2>
<ol>
<li>支持 typescript。现在没有类型提示，编写代码和配置容易出错；</li>
<li>组件联动与通信。现有组件状态无法根据其他组件状态进行动态调整，可参照 <a href="https://link.juejin.cn?target=https%3A%2F%2Fformilyjs.org%2Fzh-CN" target="_blank" title="https://formilyjs.org/zh-CN" ref="nofollow noopener noreferrer">formilyjs</a>解决该问题</li>
<li>可视化配置。现有配置依赖研发编写 json，对非技术人员不友好。设计一个可视化页面，支持对组件的拖拉拽和属性的更改</li>
<li>加上监控看板，实时查看数据。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>